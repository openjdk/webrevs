{"files":[{"patch":"@@ -366,0 +366,1 @@\n+#ifdef _LP64\n@@ -367,3 +368,3 @@\n-    \/\/ We don't want any valid object to be at the very bottom of the archive.\n-    \/\/ See ArchivePtrMarker::mark_pointer().\n-    rw_region()->allocate(16);\n+    \/\/ The region that will be located at the bottom of the encoding range at runtime shall have\n+    \/\/ space for a protection zone.\n+    MetaspaceShared::allocate_and_mark_protection_zone(rw_region());\n@@ -371,0 +372,1 @@\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1339,0 +1339,7 @@\n+\n+          \/\/ After narrowKlass encoding scheme is decided: if encoding base points to archive start (can happen\n+          \/\/ for both cases above), establish protection zone.\n+          if (CompressedKlassPointers::base() == cds_base) {\n+            MetaspaceShared::check_and_establish_protection_zone(cds_base);\n+          }\n+\n@@ -1355,0 +1362,45 @@\n+#ifdef _LP64\n+\n+\/\/ Protection zone handling.\n+\/\/\n+\/\/ A Klass structure must never be located at the encoding base since that would encode to an\n+\/\/ invalid nKlass of zero. At runtime, we set the encoding base to the start of the mapped\n+\/\/ archive. In order to catch accidental accesses via a zero nKlass, we will establis a no-access\n+\/\/ zone there, similar to how the heap does it. Space for that page must be prepared when dumping\n+\/\/ the archive.\n+static constexpr uint64_t protzone_tag       = 0x50524F545A4F4E45ULL; \/\/ \"PROTZONE\"\n+static constexpr uint64_t protzone_tag_start = 0x2D3E2D3E50524F54ULL; \/\/ \"->->PROT\"\n+static constexpr uint64_t protzone_tag_end   = 0x50524F543C2D3C2DULL; \/\/ \"PROT<-<-\"\n+\n+\/\/ Dumptime\n+void MetaspaceShared::allocate_and_mark_protection_zone(DumpRegion* region) {\n+\n+  assert(region->used() == 0, \"Should not have allocations yet\");\n+\n+  \/\/ Note: not page size but core region alignment! Page size can differ at runtime.\n+  const size_t protzone_size = MetaspaceShared::core_region_alignment();\n+  uint64_t* const protzone = (uint64_t*) region->allocate(protzone_size);\n+  const size_t len = protzone_size\/sizeof(uint64_t);\n+  protzone[0] = protzone_tag_start;\n+  protzone[len - 1] = protzone_tag_end;\n+\n+  for (size_t i = 1; i < len - 1; i++) {\n+    protzone[i] = protzone_tag;\n+  }\n+}\n+\n+\/\/ Runtime\n+void MetaspaceShared::check_and_establish_protection_zone(address addr) {\n+  const size_t protzone_size = MetaspaceShared::core_region_alignment();\n+  const uint64_t* const protzone = (const uint64_t*) addr;\n+  const size_t len = protzone_size\/sizeof(uint64_t);\n+  guarantee(protzone[0] == protzone_tag_start, \"Corrupted CDS protection zone\");\n+  guarantee(protzone[len - 1] == protzone_tag_end, \"Corrupted CDS protection zone\");\n+#ifdef ASSERT\n+  for (size_t i = 1; i < len - 1; i++) {\n+    assert(protzone[i] == protzone_tag, \"Corrupted CDS protection zone\");\n+  }\n+#endif\n+  CompressedKlassPointers::establish_protection_zone((address)protzone, protzone_size);\n+}\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class DumpRegion;\n@@ -166,0 +167,8 @@\n+  \/\/ Given a dump region (that should not yet have allocations), allocate and prepare a protection\n+  \/\/ at the start of the region.\n+  LP64_ONLY( static void allocate_and_mark_protection_zone(DumpRegion* region); )\n+\n+  \/\/ Given an address that should point to a mapped protection zone, check markers, then protect\n+  \/\/ the zone. Will return false if markers don't match up (misshapen\/tempered archive)\n+  LP64_ONLY( static void check_and_establish_protection_zone(address address) );\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"memory\/metaspace\/metachunk.hpp\"\n@@ -808,0 +809,18 @@\n+\n+    \/\/ After narrowKlass encoding scheme is decided: if the encoding base points to class space start,\n+    \/\/ establish a protection zone.\n+    if (CompressedKlassPointers::base() == (address)rs.base()) {\n+      \/\/ Let the protection zone be a whole commit granule. Otherwise, buddy allocator may later place neighboring\n+      \/\/ chunks in the same granule, see that the granule is not yet committed, and commit it, which would replace\n+      \/\/ the protection mapping and make the zone readable.\n+      \/\/ Alternatively, we could commit the chunk right now, but that is a tiny bit more fiddly, since we are not\n+      \/\/ fully set up yet at this point.\n+      const size_t protzone_size = metaspace::Settings::commit_granule_bytes(); \/\/ granule size >= page size\n+      const size_t protzone_wordsize = protzone_size \/ BytesPerWord;\n+      const metaspace::chunklevel_t lvl = metaspace::chunklevel::level_fitting_word_size(protzone_wordsize);\n+      metaspace::Metachunk* const chunk = MetaspaceContext::context_class()->cm()->get_chunk(lvl);\n+      const address protzone = (address) chunk->base();\n+      assert(protzone == (address)rs.base(), \"The very first chunk should be located at the class space start?\");\n+      assert(chunk->word_size() == protzone_wordsize, \"Weird chunk size\");\n+      CompressedKlassPointers::establish_protection_zone(protzone, protzone_size);\n+    }\n@@ -810,1 +829,1 @@\n-#endif\n+#endif \/\/ _LP64\n@@ -817,14 +836,0 @@\n-  \/\/ We must prevent the very first address of the ccs from being used to store\n-  \/\/ metadata, since that address would translate to a narrow pointer of 0, and the\n-  \/\/ VM does not distinguish between \"narrow 0 as in null\" and \"narrow 0 as in start\n-  \/\/  of ccs\".\n-  \/\/ Before Elastic Metaspace that did not happen due to the fact that every Metachunk\n-  \/\/ had a header and therefore could not allocate anything at offset 0.\n-#ifdef _LP64\n-  if (using_class_space()) {\n-    \/\/ The simplest way to fix this is to allocate a tiny dummy chunk right at the\n-    \/\/ start of ccs and do not use it for anything.\n-    MetaspaceContext::context_class()->cm()->get_chunk(metaspace::chunklevel::HIGHEST_CHUNK_LEVEL);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+size_t CompressedKlassPointers::_protection_zone_size = 0;\n@@ -307,0 +308,5 @@\n+    if (_protection_zone_size > 0) {\n+      st->print_cr(\"Protection zone: \" RANGEFMT, RANGEFMTARGS(_base, _protection_zone_size));\n+    } else {\n+      st->print_cr(\"No protection zone.\");\n+    }\n@@ -312,0 +318,18 @@\n+\/\/ Protect a zone a the start of the encoding range\n+void CompressedKlassPointers::establish_protection_zone(address addr, size_t size) {\n+  assert(_protection_zone_size == 0, \"just once\");\n+  assert(addr == base(), \"Protection zone not at start of encoding range?\");\n+  assert(size > 0 && is_aligned(size, os::vm_page_size()), \"Protection zone not page sized\");\n+  const bool rc = os::protect_memory((char*)addr, size, os::MEM_PROT_NONE, false);\n+  assert(rc, \"Failed to protect the Class space protection zone\");\n+  log_info(metaspace)(\"%s Narrow Klass Protection zone \" RANGEFMT,\n+      (rc ? \"Established\" : \"FAILED to establish \"),\n+      RANGEFMTARGS(addr, size));\n+  _protection_zone_size = size;\n+}\n+\n+bool CompressedKlassPointers::is_in_protection_zone(address addr) {\n+  return _protection_zone_size > 0 ?\n+      (addr >= base() && addr < base() + _protection_zone_size) : false;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -137,0 +137,2 @@\n+  \/\/ Protection zone size (0 if not set up)\n+  static size_t _protection_zone_size;\n@@ -234,0 +236,1 @@\n+  static inline Klass* decode_not_null_without_asserts(narrowKlass v);\n@@ -261,0 +264,6 @@\n+  \/\/ Protect a zone a the start of the encoding range\n+  static void establish_protection_zone(address addr, size_t size);\n+\n+  \/\/ Returns true if address points into protection zone (for error reporting)\n+  static bool is_in_protection_zone(address addr);\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,0 +43,4 @@\n+inline Klass* CompressedKlassPointers::decode_not_null_without_asserts(narrowKlass v) {\n+  return decode_not_null_without_asserts(v, base(), shift());\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -326,0 +326,11 @@\n+WB_ENTRY(void, WB_DecodeNKlassAndAccessKlass(JNIEnv* env, jobject o, jint nKlass))\n+  assert(UseCompressedClassPointers, \"Should only call for UseCompressedClassPointers\");\n+  const narrowKlass nk = (narrowKlass)nKlass;\n+  const Klass* const k = CompressedKlassPointers::decode_not_null_without_asserts(nKlass);\n+  printf(\"WB_DecodeNKlassAndAccessKlass: nk %u k \" PTR_FORMAT \"\\n\", nk, p2i(k));\n+  printf(\"Will attempt to crash now...\\n\");\n+  fflush(stdout); \/\/ flush now - we will crash below\n+  \/\/ Access k by calling a virtual function - will result in loading the vtable from *k\n+  k->print_on(tty);\n+WB_END\n+\n@@ -2733,0 +2744,1 @@\n+  {CC\"decodeNKlassAndAccessKlass\",CC\"(I)V\",            (void*)&WB_DecodeNKlassAndAccessKlass},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1295,0 +1295,6 @@\n+  \/\/ Check if addr points into the narrow Klass protection zone\n+  if (UseCompressedClassPointers && CompressedKlassPointers::is_in_protection_zone(addr)) {\n+    st->print_cr(PTR_FORMAT \" points into nKlass protection zone\", p2i(addr));\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"oops\/klass.hpp\"\n","filename":"test\/hotspot\/gtest\/oops\/test_compressedKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=no_coh_no_cds\n+ * @summary Test that dereferencing a Klass that is the result of a decode(0) crashes accessing the nKlass guard zone\n+ * @library \/test\/lib\n+ * @requires vm.bits == 64 & vm.debug == true\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver AccessZeroNKlassHitsProtectionZone no_coh_no_cds\n+ *\/\n+\n+\/*\n+ * @test id=no_coh_cds\n+ * @summary Test that dereferencing a Klass that is the result of a decode(0) crashes accessing the nKlass guard zone\n+ * @requires vm.bits == 64 & vm.debug == true & vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver AccessZeroNKlassHitsProtectionZone no_coh_cds\n+ *\/\n+\n+\/*\n+ * @test id=coh_no_cds\n+ * @summary Test that dereferencing a Klass that is the result of a decode(0) crashes accessing the nKlass guard zone\n+ * @requires vm.bits == 64 & vm.debug == true & vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver AccessZeroNKlassHitsProtectionZone coh_no_cds\n+ *\/\n+\n+\/*\n+ * @test id=coh_cds\n+ * @summary Test that dereferencing a Klass that is the result of a decode(0) crashes accessing the nKlass guard zone\n+ * @requires vm.bits == 64 & vm.debug == true & vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver AccessZeroNKlassHitsProtectionZone coh_cds\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+import jtreg.SkippedException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.regex.Pattern;\n+\n+\/\/ Test that dereferencing a Klass that is the result of a narrowKlass=0 will give us immediate crashes\n+\/\/ that hit the protection zone at encoding base.\n+public class AccessZeroNKlassHitsProtectionZone {\n+\n+    private static OutputAnalyzer run_test(boolean COH, boolean CDS, String forceBaseString) throws IOException, SkippedException {\n+        ArrayList<String> args = new ArrayList<>();\n+        args.add(\"-Xbootclasspath\/a:.\");\n+        args.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        args.add(\"-XX:+WhiteBoxAPI\");\n+        args.add(\"-XX:CompressedClassSpaceSize=128m\");\n+        args.add(\"-Xmx128m\");\n+        args.add(\"-XX:-CreateCoredumpOnCrash\");\n+        args.add(\"-Xlog:metaspace*\");\n+        if (COH) {\n+            args.add(\"-XX:+UnlockExperimentalVMOptions\");\n+            args.add(\"-XX:+UseCompactObjectHeaders\");\n+        }\n+        if (CDS) {\n+            args.add(\"-Xshare:on\");\n+        } else {\n+            args.add(\"-Xshare:off\");\n+            args.add(\"-XX:CompressedClassSpaceBaseAddress=\" + forceBaseString);\n+        }\n+        args.add(AccessZeroNKlassHitsProtectionZone.class.getName());\n+        args.add(\"runwb\");\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args.toArray(new String[0]));\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.reportDiagnosticSummary();\n+        return output;\n+    }\n+\n+    private static void run_test(boolean COH, boolean CDS) throws IOException, SkippedException {\n+        \/\/ Notes:\n+        \/\/ We want to enforce zero-based encoding, to test the protection page in that case. For zero-based encoding,\n+        \/\/ protection page is at address zero, no need to test that.\n+        \/\/ If CDS is on, we never use zero-based, forceBase is ignored.\n+        \/\/ If CDS is off, we use forceBase to (somewhat) reliably force the encoding base to beyond 32G,\n+        \/\/ in order to prevent zero-based encoding. Since that may fail, we try several times.\n+        OutputAnalyzer output = null;\n+        long forceBase = -1;\n+        if (CDS) {\n+            output = run_test(COH, CDS, \"\");\n+        } else {\n+            long g4 = 0x1_0000_0000L;\n+            long start = g4 * 8; \/\/ 32g\n+            long step = g4;\n+            long end = start + step * 16;\n+            for (forceBase = start; forceBase < end; forceBase += step) {\n+                String thisBaseString = String.format(\"0x%016X\", forceBase).toLowerCase();\n+                output = run_test(COH, CDS, thisBaseString);\n+                if (output.contains(\"CompressedClassSpaceBaseAddress=\" + thisBaseString + \" given, but reserving class space failed.\")) {\n+                    \/\/ try next one\n+                } else if (output.contains(\"Successfully forced class space address to \" + thisBaseString)) {\n+                    break;\n+                } else {\n+                    throw new RuntimeException(\"Unexpected\");\n+                }\n+            }\n+            if (forceBase >= end) {\n+\/\/ testtest                throw new SkippedException(\"Failed to force ccs to any of the given bases. Skipping test.\");\n+            }\n+        }\n+\n+        \/\/ Parse the encoding base from the output. In case of CDS, it depends on ASLR. Even in case of CDS=off, we want\n+        \/\/ to double-check it is the force address.\n+        String nKlassBaseString = output.firstMatch(\"Narrow klass base: 0x([0-9a-f]+)\", 1);\n+        if (nKlassBaseString == null) {\n+            throw new RuntimeException(\"did not find Narrow klass base in log output\");\n+        }\n+        long nKlassBase = Long.valueOf(nKlassBaseString, 16);\n+\n+        if (!CDS && nKlassBase != forceBase) {\n+            throw new RuntimeException(\"Weird - we should have mapped at force base\"); \/\/ .. otherwise we would have skipped out above\n+        }\n+        if (nKlassBase == 0) {\n+            throw new RuntimeException(\"We should not be running zero-based at this point.\");\n+        }\n+\n+        \/\/ Calculate the expected crash address pattern. The precise crash address is unknown, but should be located\n+        \/\/ in the lower part of the guard page following the encoding base. We just accept any address matching the\n+        \/\/ upper 52 digits (leaving 4K = 12 bits = 4 nibbles of wiggle room)\n+        String expectedCrashAddressString = nKlassBaseString.substring(0, nKlassBaseString.length() - 3);\n+\n+        \/\/ output from whitebox function: Klass* should point to encoding base\n+        output.shouldMatch(\"WB_DecodeNKlassAndAccessKlass: nk 0 k 0x\" + nKlassBaseString);\n+\n+        \/\/ Then, we should have crashed\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(\"# A fatal error has been detected\");\n+\n+        \/\/ The hs-err file should contain a reference to the nKlass protection zone, like this:\n+        \/\/ \"RDI=0x0000000800000000 points into nKlass protection zone\"\n+        File hsErrFile = HsErrFileUtils.openHsErrFileFromOutput(output);\n+\n+        ArrayList<Pattern> hsErrPatternList = new ArrayList<>();\n+        hsErrPatternList.add(Pattern.compile(\".*(SIGBUS|SIGSEGV|EXCEPTION_ACCESS_VIOLATION).*\"));\n+        hsErrPatternList.add(Pattern.compile(\".*(si_addr|ExceptionInformation).*\" + expectedCrashAddressString + \".*\"));\n+        hsErrPatternList.add(Pattern.compile(\".*\" + expectedCrashAddressString + \".*points into nKlass protection zone.*\"));\n+        Pattern[] hsErrPattern = hsErrPatternList.toArray(new Pattern[0]);\n+        HsErrFileUtils.checkHsErrFileContent(hsErrFile, hsErrPattern, true);\n+    }\n+\n+    enum Argument { runwb, no_coh_no_cds, no_coh_cds, coh_no_cds, coh_cds };\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Expecting one argument\");\n+        }\n+        Argument arg = Argument.valueOf(args[0]);\n+        System.out.println(arg);\n+        switch (arg) {\n+            case runwb -> WhiteBox.getWhiteBox().decodeNKlassAndAccessKlass(0);\n+            case no_coh_no_cds -> run_test(false, false);\n+            case no_coh_cds -> run_test(false, true);\n+            case coh_no_cds -> run_test(true, false);\n+            case coh_cds -> run_test(true, true);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/AccessZeroNKlassHitsProtectionZone.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -645,0 +645,2 @@\n+\n+  public native void decodeNKlassAndAccessKlass(int nKlass);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}