{"files":[{"patch":"@@ -156,1 +156,0 @@\n-  _num_dump_regions_used(0),\n@@ -164,0 +163,1 @@\n+  _pz_region(\"pz\", MAX_SHARED_DELTA), \/\/ protection zone -- used only during dumping; does NOT exist in cds archive.\n@@ -326,3 +326,8 @@\n-  _current_dump_region = &_rw_region;\n-  _num_dump_regions_used = 1;\n-  _current_dump_region->init(&_shared_rs, &_shared_vs);\n+\n+  if (CDSConfig::is_dumping_static_archive()) {\n+    _current_dump_region = &_pz_region;\n+    _current_dump_region->init(&_shared_rs, &_shared_vs);\n+  } else {\n+    _current_dump_region = &_rw_region;\n+    _current_dump_region->init(&_shared_rs, &_shared_vs);\n+  }\n@@ -369,1 +374,2 @@\n-    rw_region()->allocate(16);\n+    _pz_region.allocate(MetaspaceShared::protection_zone_size());\n+    start_dump_region(&_rw_region);\n@@ -548,1 +554,0 @@\n-  _num_dump_regions_used ++;\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,0 @@\n-  int _num_dump_regions_used;\n@@ -213,0 +212,6 @@\n+  \/\/ The \"pz\" region is used only during static dumps to reserve an unused space between SharedBaseAddress and\n+  \/\/ the bottom of the rw region. During runtime, this space will be filled with a reserved area that disallows\n+  \/\/ read\/write\/exec, so we can track for bad CompressedKlassPointers encoding.\n+  \/\/ Note: this region does NOT exist in the cds archive.\n+  DumpRegion _pz_region;\n+\n@@ -273,3 +278,0 @@\n-\n-  static const int _total_dump_regions = 2;\n-\n@@ -370,0 +372,1 @@\n+  DumpRegion* pz_region() { return &_pz_region; }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -76,2 +76,3 @@\n-  address* rw_bottom = (address*)ArchiveBuilder::current()->rw_region()->base();\n-  address* ro_bottom = (address*)ArchiveBuilder::current()->ro_region()->base();\n+  address* buff_bottom = (address*)ArchiveBuilder::current()->buffer_bottom();\n+  address* rw_bottom   = (address*)ArchiveBuilder::current()->rw_region()->base();\n+  address* ro_bottom   = (address*)ArchiveBuilder::current()->ro_region()->base();\n@@ -79,2 +80,3 @@\n-  _rw_ptrmap = rw_ptrmap;\n-  _ro_ptrmap = ro_ptrmap;\n+  \/\/ The bit in _ptrmap that cover the very first word in the rw\/ro regions.\n+  size_t rw_start = rw_bottom - buff_bottom;\n+  size_t ro_start = ro_bottom - buff_bottom;\n@@ -82,0 +84,3 @@\n+  \/\/ The number of bits used by the rw\/ro ptrmaps. We might have lots of zero\n+  \/\/ bits at the bottom and top of rrw\/ro ptrmaps, but these zeros will be\n+  \/\/ removed by FileMapInfo::write_bitmap_region().\n@@ -84,14 +89,12 @@\n-  \/\/ ro_start is the first bit in _ptrmap that covers the pointer that would sit at ro_bottom.\n-  \/\/ E.g., if rw_bottom = (address*)100\n-  \/\/          ro_bottom = (address*)116\n-  \/\/       then for 64-bit platform:\n-  \/\/          ro_start = ro_bottom - rw_bottom = (116 - 100) \/ sizeof(address) = 2;\n-  size_t ro_start = ro_bottom - rw_bottom;\n-\n-  \/\/ Note: ptrmap is big enough only to cover the last pointer in ro_region.\n-  \/\/ See ArchivePtrMarker::compact()\n-  _rw_ptrmap->initialize(rw_size);\n-  _ro_ptrmap->initialize(_ptrmap->size() - ro_start);\n-\n-  for (size_t rw_bit = 0; rw_bit < _rw_ptrmap->size(); rw_bit++) {\n-    _rw_ptrmap->at_put(rw_bit, _ptrmap->at(rw_bit));\n+\n+  \/\/ The last (exclusive) bit in _ptrmap that covers the rw\/ro regions.\n+  \/\/ Note: _ptrmap is dynamically expanded only when an actual pointer is written, so\n+  \/\/ it may not be as large as we want.\n+  size_t rw_end = MIN2<size_t>(rw_start + rw_size, _ptrmap->size());\n+  size_t ro_end = MIN2<size_t>(ro_start + ro_size, _ptrmap->size());\n+\n+  rw_ptrmap->initialize(rw_size);\n+  ro_ptrmap->initialize(ro_size);\n+\n+  for (size_t rw_bit = rw_start; rw_bit < rw_end; rw_bit++) {\n+    rw_ptrmap->at_put(rw_bit - rw_start, _ptrmap->at(rw_bit));\n@@ -100,2 +103,2 @@\n-  for(size_t ro_bit = ro_start; ro_bit < _ptrmap->size(); ro_bit++) {\n-    _ro_ptrmap->at_put(ro_bit-ro_start, _ptrmap->at(ro_bit));\n+  for(size_t ro_bit = ro_start; ro_bit < ro_end; ro_bit++) {\n+    ro_ptrmap->at_put(ro_bit - ro_start, _ptrmap->at(ro_bit));\n@@ -103,1 +106,3 @@\n-  assert(_ptrmap->size() - ro_start == _ro_ptrmap->size(), \"must be\");\n+\n+  _rw_ptrmap = rw_ptrmap;\n+  _ro_ptrmap = ro_ptrmap;\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -170,1 +170,0 @@\n-    assert(_num_dump_regions_used == _total_dump_regions, \"must be\");\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -540,1 +540,1 @@\n-  char* mapped_base()    const { return first_core_region()->mapped_base(); }\n+  char* mapped_base()    const { return header()->mapped_base_address();    }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -148,0 +148,4 @@\n+size_t MetaspaceShared::protection_zone_size() {\n+  return os::cds_core_region_alignment();\n+}\n+\n@@ -1237,0 +1241,1 @@\n+  size_t prot_zone_size = 0;\n@@ -1248,0 +1253,12 @@\n+    if (Metaspace::using_class_space()) {\n+      prot_zone_size = protection_zone_size();\n+#ifdef ASSERT\n+      \/\/ Before mapping the core regions into the newly established address space, we mark\n+      \/\/ start and the end of the future protection zone with canaries. That way we easily\n+      \/\/ catch mapping errors (accidentally mapping data into the future protection zone).\n+      os::commit_memory(mapped_base_address, prot_zone_size, false);\n+      *(mapped_base_address) = 'P';\n+      *(mapped_base_address + prot_zone_size - 1) = 'P';\n+#endif\n+    }\n+\n@@ -1253,0 +1270,3 @@\n+      assert(archive_space_rs.base() == mapped_base_address &&\n+          archive_space_rs.size() > protection_zone_size(),\n+          \"Archive space must lead and include the protection zone\");\n@@ -1255,1 +1275,1 @@\n-      assert(class_space_rs.is_reserved(),\n+      assert(class_space_rs.is_reserved() && class_space_rs.size() > 0,\n@@ -1268,2 +1288,3 @@\n-    log_info(cds)(\"Reserved archive_space_rs [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] (%zu) bytes\",\n-                   p2i(archive_space_rs.base()), p2i(archive_space_rs.end()), archive_space_rs.size());\n+    log_info(cds)(\"Reserved archive_space_rs [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] (%zu) bytes%s\",\n+                   p2i(archive_space_rs.base()), p2i(archive_space_rs.end()), archive_space_rs.size(),\n+                   (prot_zone_size > 0 ? \" (includes protection zone)\" : \"\"));\n@@ -1341,32 +1362,34 @@\n-        if (Metaspace::using_class_space()) {\n-          \/\/ Set up ccs in metaspace.\n-          Metaspace::initialize_class_space(class_space_rs);\n-\n-          \/\/ Set up compressed Klass pointer encoding: the encoding range must\n-          \/\/  cover both archive and class space.\n-          address cds_base = (address)static_mapinfo->mapped_base();\n-          address ccs_end = (address)class_space_rs.end();\n-          assert(ccs_end > cds_base, \"Sanity check\");\n-          if (INCLUDE_CDS_JAVA_HEAP || UseCompactObjectHeaders) {\n-            \/\/ The CDS archive may contain narrow Klass IDs that were precomputed at archive generation time:\n-            \/\/ - every archived java object header (only if INCLUDE_CDS_JAVA_HEAP)\n-            \/\/ - every archived Klass' prototype   (only if +UseCompactObjectHeaders)\n-            \/\/\n-            \/\/ In order for those IDs to still be valid, we need to dictate base and shift: base should be the\n-            \/\/ mapping start, shift the shift used at archive generation time.\n-            address precomputed_narrow_klass_base = cds_base;\n-            const int precomputed_narrow_klass_shift = ArchiveBuilder::precomputed_narrow_klass_shift();\n-            CompressedKlassPointers::initialize_for_given_encoding(\n-              cds_base, ccs_end - cds_base, \/\/ Klass range\n-              precomputed_narrow_klass_base, precomputed_narrow_klass_shift \/\/ precomputed encoding, see ArchiveBuilder\n-            );\n-          } else {\n-            \/\/ Let JVM freely chose encoding base and shift\n-            CompressedKlassPointers::initialize (\n-              cds_base, ccs_end - cds_base \/\/ Klass range\n-              );\n-          }\n-          \/\/ map_or_load_heap_region() compares the current narrow oop and klass encodings\n-          \/\/ with the archived ones, so it must be done after all encodings are determined.\n-          static_mapinfo->map_or_load_heap_region();\n-        }\n+    if (Metaspace::using_class_space()) {\n+      assert(*(mapped_base_address) == 'P' &&\n+             *(mapped_base_address + prot_zone_size - 1) == 'P',\n+          \"Protection zone was overwritten?\");\n+\n+      \/\/ Set up ccs in metaspace.\n+      Metaspace::initialize_class_space(class_space_rs);\n+\n+      \/\/ Set up compressed Klass pointer encoding: the encoding range must\n+      \/\/  cover both archive and class space.\n+      const address encoding_base = (address)mapped_base_address;\n+      const address klass_range_start = encoding_base + prot_zone_size;\n+      const size_t klass_range_size = (address)class_space_rs.end() - klass_range_start;\n+      if (INCLUDE_CDS_JAVA_HEAP || UseCompactObjectHeaders) {\n+        \/\/ The CDS archive may contain narrow Klass IDs that were precomputed at archive generation time:\n+        \/\/ - every archived java object header (only if INCLUDE_CDS_JAVA_HEAP)\n+        \/\/ - every archived Klass' prototype   (only if +UseCompactObjectHeaders)\n+        \/\/\n+        \/\/ In order for those IDs to still be valid, we need to dictate base and shift: base should be the\n+        \/\/ mapping start (including protection zone), shift should be the shift used at archive generation time.\n+        CompressedKlassPointers::initialize_for_given_encoding(\n+          klass_range_start, klass_range_size,\n+          encoding_base, ArchiveBuilder::precomputed_narrow_klass_shift() \/\/ precomputed encoding, see ArchiveBuilder\n+        );\n+      } else {\n+        \/\/ Let JVM freely chose encoding base and shift\n+        CompressedKlassPointers::initialize(klass_range_start, klass_range_size);\n+      }\n+      CompressedKlassPointers::establish_protection_zone(encoding_base, prot_zone_size);\n+\n+      \/\/ map_or_load_heap_region() compares the current narrow oop and klass encodings\n+      \/\/ with the archived ones, so it must be done after all encodings are determined.\n+      static_mapinfo->map_or_load_heap_region();\n+    }\n@@ -1454,1 +1477,0 @@\n-  assert(static_mapinfo->mapping_base_offset() == 0, \"Must be\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":58,"deletions":36,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+  static size_t protection_zone_size();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,1 +72,4 @@\n-  char*   _mapped_base;       \/\/ Actually mapped address (null if this region is not mapped).\n+  char*   _mapped_base;       \/\/ Actually mapped address used for mapping the core regions. At that address the\n+                              \/\/ zero nklass protection zone is established; following that (at offset\n+                              \/\/ MetaspaceShared::protection_zone_size()) the lowest core region (rw for the\n+                              \/\/ static archive) is is mapped.\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2023, 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2025, Red Hat, Inc. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"memory\/metaspace\/metachunk.hpp\"\n@@ -808,0 +809,22 @@\n+\n+    \/\/ After narrowKlass encoding scheme is decided: if the encoding base points to class space start,\n+    \/\/ establish a protection zone. Accidentally decoding a zero nKlass ID and then using it will result\n+    \/\/ in an immediate segmentation fault instead of a delayed error much later.\n+    if (CompressedKlassPointers::base() == (address)rs.base()) {\n+      \/\/ Let the protection zone be a whole commit granule. Otherwise, buddy allocator may later place neighboring\n+      \/\/ chunks in the same granule, see that the granule is not yet committed, and commit it, which would replace\n+      \/\/ the protection mapping and make the zone readable.\n+      \/\/ Alternatively, we could commit the chunk right now, but that is a tiny bit more fiddly, since we are not\n+      \/\/ fully set up yet at this point.\n+      const size_t protzone_size = metaspace::Settings::commit_granule_bytes(); \/\/ granule size >= page size\n+      const size_t protzone_wordsize = protzone_size \/ BytesPerWord;\n+      const metaspace::chunklevel_t lvl = metaspace::chunklevel::level_fitting_word_size(protzone_wordsize);\n+      metaspace::Metachunk* const chunk = MetaspaceContext::context_class()->cm()->get_chunk(lvl);\n+      const address protzone = (address) chunk->base();\n+      assert(protzone == (address)rs.base(), \"The very first chunk should be located at the class space start?\");\n+      assert(chunk->word_size() == protzone_wordsize, \"Weird chunk size\");\n+      CompressedKlassPointers::establish_protection_zone(protzone, protzone_size);\n+    } else {\n+      assert(CompressedKlassPointers::base() == nullptr, \"Zero-based encoding expected\");\n+    }\n+\n@@ -810,1 +833,1 @@\n-#endif\n+#endif \/\/ _LP64\n@@ -817,14 +840,0 @@\n-  \/\/ We must prevent the very first address of the ccs from being used to store\n-  \/\/ metadata, since that address would translate to a narrow pointer of 0, and the\n-  \/\/ VM does not distinguish between \"narrow 0 as in null\" and \"narrow 0 as in start\n-  \/\/  of ccs\".\n-  \/\/ Before Elastic Metaspace that did not happen due to the fact that every Metachunk\n-  \/\/ had a header and therefore could not allocate anything at offset 0.\n-#ifdef _LP64\n-  if (using_class_space()) {\n-    \/\/ The simplest way to fix this is to allocate a tiny dummy chunk right at the\n-    \/\/ start of ccs and do not use it for anything.\n-    MetaspaceContext::context_class()->cm()->get_chunk(metaspace::chunklevel::HIGHEST_CHUNK_LEVEL);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+size_t CompressedKlassPointers::_protection_zone_size = 0;\n@@ -165,5 +166,0 @@\n-  \/\/ Note: While it would be technically valid for the encoding base to precede the start of the Klass range,\n-  \/\/ we never do this here. This is used at CDS runtime to re-instate the scheme used to precompute the\n-  \/\/ narrow Klass IDs in the archive, and the requested base should point to the start of the Klass range.\n-  assert(requested_base == addr, \"Invalid requested base\");\n-\n@@ -307,0 +303,5 @@\n+    if (_protection_zone_size > 0) {\n+      st->print_cr(\"Protection zone: \" RANGEFMT, RANGEFMTARGS(_base, _protection_zone_size));\n+    } else {\n+      st->print_cr(\"No protection zone.\");\n+    }\n@@ -312,0 +313,18 @@\n+\/\/ Protect a zone a the start of the encoding range\n+void CompressedKlassPointers::establish_protection_zone(address addr, size_t size) {\n+  assert(_protection_zone_size == 0, \"just once\");\n+  assert(addr == base(), \"Protection zone not at start of encoding range?\");\n+  assert(size > 0 && is_aligned(size, os::vm_page_size()), \"Protection zone not page sized\");\n+  const bool rc = os::protect_memory((char*)addr, size, os::MEM_PROT_NONE, false);\n+  assert(rc, \"Failed to protect the Class space protection zone\");\n+  log_info(metaspace)(\"%s Narrow Klass Protection zone \" RANGEFMT,\n+      (rc ? \"Established\" : \"FAILED to establish \"),\n+      RANGEFMTARGS(addr, size));\n+  _protection_zone_size = size;\n+}\n+\n+bool CompressedKlassPointers::is_in_protection_zone(address addr) {\n+  return _protection_zone_size > 0 ?\n+      (addr >= base() && addr < base() + _protection_zone_size) : false;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,0 +137,2 @@\n+  \/\/ Protection zone size (0 if not set up)\n+  static size_t _protection_zone_size;\n@@ -234,0 +236,1 @@\n+  static inline Klass* decode_not_null_without_asserts(narrowKlass v);\n@@ -261,0 +264,6 @@\n+  \/\/ Protect a zone a the start of the encoding range\n+  static void establish_protection_zone(address addr, size_t size);\n+\n+  \/\/ Returns true if address points into protection zone (for error reporting)\n+  static bool is_in_protection_zone(address addr);\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,4 @@\n+inline Klass* CompressedKlassPointers::decode_not_null_without_asserts(narrowKlass v) {\n+  return decode_not_null_without_asserts(v, base(), shift());\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.inline.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -329,0 +329,11 @@\n+WB_ENTRY(void, WB_DecodeNKlassAndAccessKlass(JNIEnv* env, jobject o, jint nKlass))\n+  assert(UseCompressedClassPointers, \"Should only call for UseCompressedClassPointers\");\n+  const narrowKlass nk = (narrowKlass)nKlass;\n+  const Klass* const k = CompressedKlassPointers::decode_not_null_without_asserts(nKlass);\n+  printf(\"WB_DecodeNKlassAndAccessKlass: nk %u k \" PTR_FORMAT \"\\n\", nk, p2i(k));\n+  printf(\"Will attempt to crash now...\\n\");\n+  fflush(stdout); \/\/ flush now - we will crash below\n+  \/\/ Access k by calling a virtual function - will result in loading the vtable from *k\n+  k->print_on(tty);\n+WB_END\n+\n@@ -2745,0 +2756,1 @@\n+  {CC\"decodeNKlassAndAccessKlass\",CC\"(I)V\",            (void*)&WB_DecodeNKlassAndAccessKlass},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1294,0 +1294,6 @@\n+  \/\/ Check if addr points into the narrow Klass protection zone\n+  if (UseCompressedClassPointers && CompressedKlassPointers::is_in_protection_zone(addr)) {\n+    st->print_cr(PTR_FORMAT \" points into nKlass protection zone\", p2i(addr));\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=no_coh_no_cds\n+ * @summary Test that dereferencing a Klass that is the result of a decode(0) crashes accessing the nKlass guard zone\n+ * @library \/test\/lib\n+ * @requires vm.bits == 64 & vm.debug == true\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver AccessZeroNKlassHitsProtectionZone no_coh_no_cds\n+ *\/\n+\n+\/*\n+ * @test id=no_coh_cds\n+ * @summary Test that dereferencing a Klass that is the result of a decode(0) crashes accessing the nKlass guard zone\n+ * @requires vm.bits == 64 & vm.debug == true & vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver AccessZeroNKlassHitsProtectionZone no_coh_cds\n+ *\/\n+\n+\/*\n+ * @test id=coh_no_cds\n+ * @summary Test that dereferencing a Klass that is the result of a decode(0) crashes accessing the nKlass guard zone\n+ * @requires vm.bits == 64 & vm.debug == true & vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver AccessZeroNKlassHitsProtectionZone coh_no_cds\n+ *\/\n+\n+\/*\n+ * @test id=coh_cds\n+ * @summary Test that dereferencing a Klass that is the result of a decode(0) crashes accessing the nKlass guard zone\n+ * @requires vm.bits == 64 & vm.debug == true & vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver AccessZeroNKlassHitsProtectionZone coh_cds\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+import jtreg.SkippedException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.regex.Pattern;\n+\n+\/\/ Test that dereferencing a Klass that is the result of a narrowKlass=0 will give us immediate crashes\n+\/\/ that hit the protection zone at encoding base.\n+public class AccessZeroNKlassHitsProtectionZone {\n+\n+    private static OutputAnalyzer run_test(boolean COH, boolean CDS, String forceBaseString) throws IOException, SkippedException {\n+        ArrayList<String> args = new ArrayList<>();\n+        args.add(\"-Xbootclasspath\/a:.\");\n+        args.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        args.add(\"-XX:+WhiteBoxAPI\");\n+        args.add(\"-XX:CompressedClassSpaceSize=128m\");\n+        args.add(\"-Xmx128m\");\n+        args.add(\"-XX:-CreateCoredumpOnCrash\");\n+        args.add(\"-Xlog:metaspace*\");\n+        if (COH) {\n+            args.add(\"-XX:+UnlockExperimentalVMOptions\");\n+            args.add(\"-XX:+UseCompactObjectHeaders\");\n+        }\n+        if (CDS) {\n+            args.add(\"-Xshare:on\");\n+        } else {\n+            args.add(\"-Xshare:off\");\n+            args.add(\"-XX:CompressedClassSpaceBaseAddress=\" + forceBaseString);\n+        }\n+        args.add(AccessZeroNKlassHitsProtectionZone.class.getName());\n+        args.add(\"runwb\");\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args.toArray(new String[0]));\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.reportDiagnosticSummary();\n+        return output;\n+    }\n+\n+    private static void run_test(boolean COH, boolean CDS) throws IOException, SkippedException {\n+        \/\/ Notes:\n+        \/\/ We want to enforce zero-based encoding, to test the protection page in that case. For zero-based encoding,\n+        \/\/ protection page is at address zero, no need to test that.\n+        \/\/ If CDS is on, we never use zero-based, forceBase is ignored.\n+        \/\/ If CDS is off, we use forceBase to (somewhat) reliably force the encoding base to beyond 32G,\n+        \/\/ in order to prevent zero-based encoding. Since that may fail, we try several times.\n+        OutputAnalyzer output = null;\n+        long forceBase = -1;\n+        if (CDS) {\n+            output = run_test(COH, CDS, \"\");\n+        } else {\n+            long g4 = 0x1_0000_0000L;\n+            long start = g4 * 8; \/\/ 32g\n+            long step = g4;\n+            long end = start + step * 16;\n+            for (forceBase = start; forceBase < end; forceBase += step) {\n+                String thisBaseString = String.format(\"0x%016X\", forceBase).toLowerCase();\n+                output = run_test(COH, CDS, thisBaseString);\n+                if (output.contains(\"CompressedClassSpaceBaseAddress=\" + thisBaseString + \" given, but reserving class space failed.\")) {\n+                    \/\/ try next one\n+                } else if (output.contains(\"Successfully forced class space address to \" + thisBaseString)) {\n+                    break;\n+                } else {\n+                    throw new RuntimeException(\"Unexpected\");\n+                }\n+            }\n+            if (forceBase >= end) {\n+                throw new SkippedException(\"Failed to force ccs to any of the given bases. Skipping test.\");\n+            }\n+        }\n+\n+        \/\/ Parse the encoding base from the output. In case of CDS, it depends on ASLR. Even in case of CDS=off, we want\n+        \/\/ to double-check it is the force address.\n+        String nKlassBaseString = output.firstMatch(\"Narrow klass base: 0x([0-9a-f]+)\", 1);\n+        if (nKlassBaseString == null) {\n+            throw new RuntimeException(\"did not find Narrow klass base in log output\");\n+        }\n+        long nKlassBase = Long.valueOf(nKlassBaseString, 16);\n+\n+        if (!CDS && nKlassBase != forceBase) {\n+            throw new RuntimeException(\"Weird - we should have mapped at force base\"); \/\/ .. otherwise we would have skipped out above\n+        }\n+        if (nKlassBase == 0) {\n+            throw new RuntimeException(\"We should not be running zero-based at this point.\");\n+        }\n+\n+        \/\/ Calculate the expected crash address pattern. The precise crash address is unknown, but should be located\n+        \/\/ in the lower part of the guard page following the encoding base. We just accept any address matching the\n+        \/\/ upper 52 digits (leaving 4K = 12 bits = 4 nibbles of wiggle room)\n+        String expectedCrashAddressString = nKlassBaseString.substring(0, nKlassBaseString.length() - 3);\n+\n+        \/\/ output from whitebox function: Klass* should point to encoding base\n+        output.shouldMatch(\"WB_DecodeNKlassAndAccessKlass: nk 0 k 0x\" + nKlassBaseString);\n+\n+        \/\/ Then, we should have crashed\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(\"# A fatal error has been detected\");\n+\n+        \/\/ The hs-err file should contain a reference to the nKlass protection zone, like this:\n+        \/\/ \"RDI=0x0000000800000000 points into nKlass protection zone\"\n+        File hsErrFile = HsErrFileUtils.openHsErrFileFromOutput(output);\n+\n+        ArrayList<Pattern> hsErrPatternList = new ArrayList<>();\n+        hsErrPatternList.add(Pattern.compile(\".*(SIGBUS|SIGSEGV|EXCEPTION_ACCESS_VIOLATION).*\"));\n+\n+        hsErrPatternList.add(Pattern.compile(\".*siginfo:.*\" + expectedCrashAddressString + \".*\"));\n+        hsErrPatternList.add(Pattern.compile(\".*\" + expectedCrashAddressString + \".*points into nKlass protection zone.*\"));\n+        Pattern[] hsErrPattern = hsErrPatternList.toArray(new Pattern[0]);\n+        HsErrFileUtils.checkHsErrFileContent(hsErrFile, hsErrPattern, true);\n+    }\n+\n+    enum Argument { runwb, no_coh_no_cds, no_coh_cds, coh_no_cds, coh_cds };\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Expecting one argument\");\n+        }\n+        Argument arg = Argument.valueOf(args[0]);\n+        System.out.println(arg);\n+        switch (arg) {\n+            case runwb -> WhiteBox.getWhiteBox().decodeNKlassAndAccessKlass(0);\n+            case no_coh_no_cds -> run_test(false, false);\n+            case no_coh_cds -> run_test(false, true);\n+            case coh_no_cds -> run_test(true, false);\n+            case coh_cds -> run_test(true, true);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/AccessZeroNKlassHitsProtectionZone.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -645,0 +645,2 @@\n+\n+  public native void decodeNKlassAndAccessKlass(int nKlass);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}