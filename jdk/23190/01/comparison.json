{"files":[{"patch":"@@ -367,0 +367,1 @@\n+#ifdef _LP64\n@@ -368,3 +369,3 @@\n-    \/\/ We don't want any valid object to be at the very bottom of the archive.\n-    \/\/ See ArchivePtrMarker::mark_pointer().\n-    rw_region()->allocate(16);\n+    \/\/ The region that will be located at the bottom of the encoding range at runtime shall have\n+    \/\/ space for a protection zone.\n+    MetaspaceShared::allocate_and_mark_protection_zone(rw_region());\n@@ -372,0 +373,1 @@\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1340,0 +1340,7 @@\n+\n+          \/\/ After narrowKlass encoding scheme is decided: if encoding base points to archive start (can happen\n+          \/\/ for both cases above), establish protection zone.\n+          if (CompressedKlassPointers::base() == cds_base) {\n+            MetaspaceShared::check_and_establish_protection_zone(cds_base);\n+          }\n+\n@@ -1356,0 +1363,45 @@\n+#ifdef _LP64\n+\n+\/\/ Protection zone handling.\n+\/\/\n+\/\/ A Klass structure must never be located at the encoding base since that would encode to an\n+\/\/ invalid nKlass of zero. At runtime, we set the encoding base to the start of the mapped\n+\/\/ archive. In order to catch accidental accesses via a zero nKlass, we will establis a no-access\n+\/\/ zone there, similar to how the heap does it. Space for that page must be prepared when dumping\n+\/\/ the archive.\n+static constexpr uint64_t protzone_tag       = 0x50524F545A4F4E45ULL; \/\/ \"PROTZONE\"\n+static constexpr uint64_t protzone_tag_start = 0x2D3E2D3E50524F54ULL; \/\/ \"->->PROT\"\n+static constexpr uint64_t protzone_tag_end   = 0x50524F543C2D3C2DULL; \/\/ \"PROT<-<-\"\n+\n+\/\/ Dumptime\n+void MetaspaceShared::allocate_and_mark_protection_zone(DumpRegion* region) {\n+\n+  assert(region->used() == 0, \"Should not have allocations yet\");\n+\n+  \/\/ Note: not page size but core region alignment! Page size can differ at runtime.\n+  const size_t protzone_size = MetaspaceShared::core_region_alignment();\n+  uint64_t* const protzone = (uint64_t*) region->allocate(protzone_size);\n+  const size_t len = protzone_size\/sizeof(uint64_t);\n+  protzone[0] = protzone_tag_start;\n+  protzone[len - 1] = protzone_tag_end;\n+\n+  for (size_t i = 1; i < len - 1; i++) {\n+    protzone[i] = protzone_tag;\n+  }\n+}\n+\n+\/\/ Runtime\n+void MetaspaceShared::check_and_establish_protection_zone(address addr) {\n+  const size_t protzone_size = MetaspaceShared::core_region_alignment();\n+  const uint64_t* const protzone = (const uint64_t*) addr;\n+  const size_t len = protzone_size\/sizeof(uint64_t);\n+  guarantee(protzone[0] == protzone_tag_start, \"Corrupted CDS protection zone\");\n+  guarantee(protzone[len - 1] == protzone_tag_end, \"Corrupted CDS protection zone\");\n+#ifdef ASSERT\n+  for (size_t i = 1; i < len - 1; i++) {\n+    assert(protzone[i] == protzone_tag, \"Corrupted CDS protection zone\");\n+  }\n+#endif\n+  CompressedKlassPointers::establish_protection_zone((address)protzone, protzone_size);\n+}\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class DumpRegion;\n@@ -166,0 +167,8 @@\n+  \/\/ Given a dump region (that should not yet have allocations), allocate and prepare a protection\n+  \/\/ at the start of the region.\n+  LP64_ONLY( static void allocate_and_mark_protection_zone(DumpRegion* region); )\n+\n+  \/\/ Given an address that should point to a mapped protection zone, check markers, then protect\n+  \/\/ the zone. Will return false if markers don't match up (misshapen\/tempered archive)\n+  LP64_ONLY( static void check_and_establish_protection_zone(address address) );\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"memory\/metaspace\/metachunk.hpp\"\n@@ -809,0 +810,13 @@\n+\n+    \/\/ After narrowKlass encoding scheme is decided: if the encoding base points to class space start,\n+    \/\/ establish a protection zone.\n+    if (CompressedKlassPointers::base() == (address)rs.base()) {\n+      const size_t protzone_size = os::vm_page_size();\n+      const size_t protzone_wordsize = protzone_size \/ BytesPerWord;\n+      const metaspace::chunklevel_t lvl = metaspace::chunklevel::level_fitting_word_size(protzone_wordsize);\n+      metaspace::Metachunk* const chunk = MetaspaceContext::context_class()->cm()->get_chunk(lvl);\n+      const address protzone = (address) chunk->base();\n+      assert(protzone == (address)rs.base(), \"The very first chunk should be located at the class space start?\");\n+      assert(chunk->word_size() == protzone_wordsize, \"Weird chunk size\");\n+      CompressedKlassPointers::establish_protection_zone(protzone, protzone_size);\n+    }\n@@ -818,14 +832,0 @@\n-  \/\/ We must prevent the very first address of the ccs from being used to store\n-  \/\/ metadata, since that address would translate to a narrow pointer of 0, and the\n-  \/\/ VM does not distinguish between \"narrow 0 as in null\" and \"narrow 0 as in start\n-  \/\/  of ccs\".\n-  \/\/ Before Elastic Metaspace that did not happen due to the fact that every Metachunk\n-  \/\/ had a header and therefore could not allocate anything at offset 0.\n-#ifdef _LP64\n-  if (using_class_space()) {\n-    \/\/ The simplest way to fix this is to allocate a tiny dummy chunk right at the\n-    \/\/ start of ccs and do not use it for anything.\n-    MetaspaceContext::context_class()->cm()->get_chunk(metaspace::chunklevel::HIGHEST_CHUNK_LEVEL);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+size_t CompressedKlassPointers::_protection_zone_size = 0;\n@@ -308,0 +309,5 @@\n+    if (_protection_zone_size > 0) {\n+      st->print_cr(\"Protection zone: \" RANGEFMT, RANGEFMTARGS(_base, _protection_zone_size));\n+    } else {\n+      st->print_cr(\"No protection zone.\");\n+    }\n@@ -313,0 +319,18 @@\n+\/\/ Protect a zone a the start of the encoding range\n+void CompressedKlassPointers::establish_protection_zone(address addr, size_t size) {\n+  assert(_protection_zone_size == 0, \"just once\");\n+  assert(addr == base(), \"Protection zone not at start of encoding range?\");\n+  assert(size > 0 && is_aligned(size, os::vm_page_size()), \"Protection zone not page sized\");\n+  const bool rc = os::protect_memory((char*)addr, size, os::MEM_PROT_NONE, false);\n+  assert(rc, \"Failed to protect the Class space protection zone\");\n+  log_info(metaspace)(\"%s Narrow Klass Protection zone \" RANGEFMT,\n+      (rc ? \"Established\" : \"FAILED to establish \"),\n+      RANGEFMTARGS(addr, size));\n+  _protection_zone_size = size;\n+}\n+\n+bool CompressedKlassPointers::is_in_protection_zone(address addr) {\n+  return _protection_zone_size > 0 ?\n+      (addr >= base() && addr < base() + _protection_zone_size) : false;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -137,0 +137,2 @@\n+  \/\/ Protection zone size (0 if not set up)\n+  static size_t _protection_zone_size;\n@@ -154,2 +156,0 @@\n-  static inline Klass* decode_not_null_without_asserts(narrowKlass v, address base, int shift);\n-\n@@ -234,0 +234,1 @@\n+  static inline Klass* decode_not_null_without_asserts(narrowKlass v, address base, int shift);\n@@ -261,0 +262,6 @@\n+  \/\/ Protect a zone a the start of the encoding range\n+  static void establish_protection_zone(address addr, size_t size);\n+\n+  \/\/ Returns true if address points into protection zone (for error reporting)\n+  static bool is_in_protection_zone(address addr);\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1296,0 +1296,6 @@\n+  \/\/ Check if addr points into the narrow Klass protection zone\n+  if (UseCompressedClassPointers && CompressedKlassPointers::is_in_protection_zone(addr)) {\n+    st->print_cr(PTR_FORMAT \" points into nKlass protection zone\", p2i(addr));\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"oops\/klass.hpp\"\n@@ -111,0 +112,30 @@\n+\n+\/\/ This tests the protection zone mechanism. If the encoding base is not zero, VM should have\n+\/\/ established a protection zone. Decoding an nKlass==0 should result in a Klass* that, upon\n+\/\/ access, causes a SIGSEGV\n+static bool test_nklass_protection_zone() {\n+  if (!UseCompressedClassPointers) {\n+    tty->print_cr(\"UseCompressedClassPointers is off, test not possible\");\n+    return true; \/\/ skipped\n+  } else if (CompressedKlassPointers::base() == nullptr) {\n+    tty->print_cr(\"Zero-based encoding; test not needed\");\n+    return true; \/\/ skipped\n+  } else {\n+    constexpr narrowKlass nk = 0;\n+    Klass* const k = CompressedKlassPointers::decode_not_null_without_asserts(nk, CompressedKlassPointers::base(), CompressedKlassPointers::shift());\n+    assert(k == (Klass*) CompressedKlassPointers::base(), \"Sanity? (\" PTR_FORMAT \" vs \" PTR_FORMAT \")\",\n+           p2i(k), p2i(CompressedKlassPointers::base()));\n+    \/\/ Now call a virtual function on that klass.\n+    k->print_on(tty); \/\/ << loading vtable ptr from protected page, crash expected here\n+    return false;\n+  }\n+}\n+\n+\/\/ This does not work yet, since gtest death tests don't work with real signals. That needs to be fixed first (see JDK-8348028).\n+TEST_VM_FATAL_ERROR_MSG(CompressedKlass, DISABLED_test_nklass_protection_zone_death_test, \".*SIGSEGV.*\") {\n+  if (test_nklass_protection_zone()) {\n+    \/\/ Still alive but returned true, so we skipped the test.\n+    \/\/ Do a fake assert that matches the regex above to satisfy the death test\n+    guarantee(false, \"fake message ignore this - SIGSEGV\");\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/oops\/test_compressedKlass.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"}]}