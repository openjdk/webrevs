{"files":[{"patch":"@@ -140,1 +140,0 @@\n-  const size_t min_address_offset_bits = 42; \/\/ 4TB\n@@ -142,0 +141,2 @@\n+#if !defined(ADDRESS_SANITIZER)\n+  const size_t min_address_offset_bits = 42; \/\/ 4TB\n@@ -145,0 +146,6 @@\n+#else\n+  \/\/ ASan reserves roughly the addresses in the range 2GB through 16TB. This overlaps with layouts 1\n+  \/\/ and 2 above, causing ZGC to fail to reserve enough memory. To work around this, we force the\n+  \/\/ use of layout 3 when built with ASan.\n+  return max_address_offset_bits;\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zGlobals_x86.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -67,0 +68,1 @@\n+    LSAN_REGISTER_ROOT_REGION(addr, size);\n@@ -85,0 +87,2 @@\n+  LSAN_REGISTER_ROOT_REGION(addr, size);\n+\n@@ -90,1 +94,5 @@\n-  bool result = os::release_memory((char*)addr, size_for(length));\n+  size_t size = size_for(length);\n+\n+  LSAN_UNREGISTER_ROOT_REGION(addr, size);\n+\n+  bool result = os::release_memory((char*)addr, size);\n","filename":"src\/hotspot\/share\/memory\/allocation.inline.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"}]}