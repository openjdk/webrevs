{"files":[{"patch":"@@ -1266,5 +1266,4 @@\n-    \/\/ Taking the thread lock here assures that any thread created after we change the gc\n-    \/\/ state will have the correct state. It also prevents attaching threads from seeing\n-    \/\/ an inconsistent state. If another thread holds this lock while it is being created,\n-    \/\/ they will have the wrong GC state, but they will be added to the list of java threads\n-    \/\/ and so will be corrected by the handshake.\n+    \/\/ Java threads take this lock while they are being attached and added to the list of thread.\n+    \/\/ If another thread holds this lock before we update the gc state, it will receive a stale\n+    \/\/ gc state, but they will have been added to the list of java threads and so will be corrected\n+    \/\/ by the following handshake.\n@@ -2036,0 +2035,6 @@\n+  \/\/ Holding the thread lock here assures that any thread created after we change the gc\n+  \/\/ state will have the correct state. It also prevents attaching threads from seeing\n+  \/\/ an inconsistent state. See ShenandoahBarrierSet::on_thread_attach for reference. Established\n+  \/\/ threads will use their thread local copy of the gc state (changed by a handshake, or on a\n+  \/\/ safepoint).\n+  assert(Threads_lock->is_locked(), \"Must hold thread lock for concurrent gc state change\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"}]}