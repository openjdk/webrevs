{"files":[{"patch":"@@ -327,1 +327,2 @@\n-    \/\/ Cycle is complete\n+    \/\/ Cycle is complete.  There were no failed allocation requests and no degeneration, so count this as good progress.\n+    heap->notify_gc_progress();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-    heap->notify_gc_no_progress();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -948,18 +948,44 @@\n-    \/\/ Block until control thread reacted, then retry allocation.\n-    \/\/\n-    \/\/ It might happen that one of the threads requesting allocation would unblock\n-    \/\/ way later after GC happened, only to fail the second allocation, because\n-    \/\/ other threads have already depleted the free storage. In this case, a better\n-    \/\/ strategy is to try again, as long as GC makes progress (or until at least\n-    \/\/ one full GC has completed).\n-    size_t original_count = shenandoah_policy()->full_gc_count();\n-    while (result == nullptr\n-        && (get_gc_no_progress_count() == 0 || original_count == shenandoah_policy()->full_gc_count())) {\n-      control_thread()->handle_alloc_failure(req, true);\n-      result = allocate_memory_under_lock(req, in_new_region);\n-    }\n-\n-    if (log_is_enabled(Debug, gc, alloc)) {\n-      ResourceMark rm;\n-      log_debug(gc, alloc)(\"Thread: %s, Result: \" PTR_FORMAT \", Request: %s, Size: \" SIZE_FORMAT \", Original: \" SIZE_FORMAT \", Latest: \" SIZE_FORMAT,\n-                           Thread::current()->name(), p2i(result), req.type_string(), req.size(), original_count, get_gc_no_progress_count());\n+    if (result == nullptr) {\n+      \/\/ Block until control thread reacted, then retry allocation.\n+      \/\/\n+      \/\/ It might happen that one of the threads requesting allocation would unblock\n+      \/\/ way later after GC happened, only to fail the second allocation, because\n+      \/\/ other threads have already depleted the free storage. In this case, a better\n+      \/\/ strategy is to try again, until at least one full GC has completed.\n+      \/\/\n+      \/\/ Stop retrying and return nullptr to cause OOMError exception if our allocation failed even after:\n+      \/\/   a) We experienced a GC that had good progress, or\n+      \/\/   b) We experienced at least one Full GC (whether or not it had good progress)\n+      \/\/\n+      \/\/ TODO: Rather than require a Full GC before throwing OOMError, it might be more appropriate for handle_alloc_failure()\n+      \/\/       to trigger a concurrent GLOBAL GC, and throw OOMError if we cannot allocate even after GLOBAL GC has finished.\n+      \/\/       There is no \"perfect\" solution here:\n+      \/\/\n+      \/\/        1. As currently implemented, there may be a race between multiple allocating threads, both attempting\n+      \/\/           to allocate very large objects.  The first thread to retry its allocation might succeed and the second\n+      \/\/           thread to retry its allocation might fail (because the first thread consumed the newly available memory).\n+      \/\/           So the second thread experiences OOMError even through another GC would have reclaimed the memory it wanted\n+      \/\/           to allocate.\n+      \/\/        2. A GLOBAL GC won't necessarily reclaim all garbage.  Following a concurrent Generational GLOBAL GC, we may\n+      \/\/           need to perform multiple concurrent mixed evacuations in order to reclaim all of the dead memory identified\n+      \/\/           by the GLOBAL GC mark.  However, the first evacuation performed by the GLOBAL GC will normally reclaim\n+      \/\/           a significant amount of garbage (as guided by garbage first heuristic).  If this is not enough memory\n+      \/\/           to satisfy the pending allocation request, we are in \"dire straits\", and a fail-fast OOMError is probably\n+      \/\/           the better remediation than repeated attempts to allocate following repeated GC cycles.\n+\n+      size_t original_count = shenandoah_policy()->full_gc_count();\n+      while ((result == nullptr) && (original_count == shenandoah_policy()->full_gc_count())) {\n+        control_thread()->handle_alloc_failure(req, true);\n+        result = allocate_memory_under_lock(req, in_new_region);\n+      }\n+      if (result != nullptr) {\n+        \/\/ If our allocation request has been satisifed after it initially failed, we count this as good gc progress\n+        notify_gc_progress();\n+      }\n+      if (log_is_enabled(Debug, gc, alloc)) {\n+        ResourceMark rm;\n+        log_debug(gc, alloc)(\"Thread: %s, Result: \" PTR_FORMAT \", Request: %s, Size: \" SIZE_FORMAT\n+                             \", Original: \" SIZE_FORMAT \", Latest: \" SIZE_FORMAT,\n+                             Thread::current()->name(), p2i(result), req.type_string(), req.size(),\n+                             original_count, get_gc_no_progress_count());\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":44,"deletions":18,"binary":false,"changes":62,"status":"modified"}]}