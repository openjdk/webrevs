{"files":[{"patch":"@@ -960,15 +960,1 @@\n-      \/\/ TODO: Rather than require a Full GC before throwing OOMError, it might be more appropriate for handle_alloc_failure()\n-      \/\/       to trigger a concurrent GLOBAL GC, and throw OOMError if we cannot allocate even after GLOBAL GC has finished.\n-      \/\/       There is no \"perfect\" solution here:\n-      \/\/\n-      \/\/        1. As currently implemented, there may be a race between multiple allocating threads, both attempting\n-      \/\/           to allocate very large objects.  The first thread to retry its allocation might succeed and the second\n-      \/\/           thread to retry its allocation might fail (because the first thread consumed the newly available memory).\n-      \/\/           So the second thread experiences OOMError even through another GC would have reclaimed the memory it wanted\n-      \/\/           to allocate.\n-      \/\/        2. A GLOBAL GC won't necessarily reclaim all garbage.  Following a concurrent Generational GLOBAL GC, we may\n-      \/\/           need to perform multiple concurrent mixed evacuations in order to reclaim all of the dead memory identified\n-      \/\/           by the GLOBAL GC mark.  However, the first evacuation performed by the GLOBAL GC will normally reclaim\n-      \/\/           a significant amount of garbage (as guided by garbage first heuristic).  If this is not enough memory\n-      \/\/           to satisfy the pending allocation request, we are in \"dire straits\", and a fail-fast OOMError is probably\n-      \/\/           the better remediation than repeated attempts to allocate following repeated GC cycles.\n+      \/\/ TODO: Consider GLOBAL GC rather than Full GC to remediate OOM condition: https:\/\/bugs.openjdk.org\/browse\/JDK-8335910\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"}]}