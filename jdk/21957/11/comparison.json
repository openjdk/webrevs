{"files":[{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights\n+ * reserved.  Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_AARCH64_STUBDECLARATIONS_HPP\n+#define CPU_AARCH64_STUBDECLARATIONS_HPP\n+\n+#define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n+  do_arch_blob(initial, 10000)                                          \\\n+\n+\n+#define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \\\n+                                           do_arch_blob,                \\\n+                                           do_arch_entry,               \\\n+                                           do_arch_entry_init)          \\\n+  do_arch_blob(continuation, 2000)                                      \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \\\n+                                       do_arch_blob,                    \\\n+                                       do_arch_entry,                   \\\n+                                       do_arch_entry_init)              \\\n+  do_arch_blob(compiler, 30000 ZGC_ONLY(+10000))                        \\\n+  do_stub(compiler, vector_iota_indices)                                \\\n+  do_arch_entry(aarch64, compiler, vector_iota_indices,                 \\\n+                vector_iota_indices, vector_iota_indices)               \\\n+  do_stub(compiler, large_array_equals)                                 \\\n+  do_arch_entry(aarch64, compiler, large_array_equals,                  \\\n+                large_array_equals, large_array_equals)                 \\\n+  do_stub(compiler, large_arrays_hashcode_boolean)                      \\\n+  do_arch_entry(aarch64, compiler, large_arrays_hashcode_boolean,       \\\n+                large_arrays_hashcode_boolean,                          \\\n+                large_arrays_hashcode_boolean)                          \\\n+  do_stub(compiler, large_arrays_hashcode_byte)                         \\\n+  do_arch_entry(aarch64, compiler, large_arrays_hashcode_byte,          \\\n+                large_arrays_hashcode_byte,                             \\\n+                large_arrays_hashcode_byte)                             \\\n+  do_stub(compiler, large_arrays_hashcode_char)                         \\\n+  do_arch_entry(aarch64, compiler, large_arrays_hashcode_char,          \\\n+                large_arrays_hashcode_char,                             \\\n+                large_arrays_hashcode_char)                             \\\n+  do_stub(compiler, large_arrays_hashcode_short)                        \\\n+  do_arch_entry(aarch64, compiler, large_arrays_hashcode_short,         \\\n+                large_arrays_hashcode_short,                            \\\n+                large_arrays_hashcode_short)                            \\\n+  do_stub(compiler, large_arrays_hashcode_int)                          \\\n+  do_arch_entry(aarch64, compiler, large_arrays_hashcode_int,           \\\n+                large_arrays_hashcode_int,                              \\\n+                large_arrays_hashcode_int)                              \\\n+  do_stub(compiler, large_byte_array_inflate)                           \\\n+  do_arch_entry(aarch64, compiler, large_byte_array_inflate,            \\\n+                large_byte_array_inflate, large_byte_array_inflate)     \\\n+  do_stub(compiler, count_positives)                                    \\\n+  do_arch_entry(aarch64, compiler, count_positives, count_positives,    \\\n+                count_positives)                                        \\\n+  do_stub(compiler, count_positives_long)                               \\\n+  do_arch_entry(aarch64, compiler, count_positives_long,                \\\n+                count_positives_long, count_positives_long)             \\\n+  do_stub(compiler, compare_long_string_LL)                             \\\n+  do_arch_entry(aarch64, compiler, compare_long_string_LL,              \\\n+                compare_long_string_LL, compare_long_string_LL)         \\\n+  do_stub(compiler, compare_long_string_UU)                             \\\n+  do_arch_entry(aarch64, compiler, compare_long_string_UU,              \\\n+                compare_long_string_UU, compare_long_string_UU)         \\\n+  do_stub(compiler, compare_long_string_LU)                             \\\n+  do_arch_entry(aarch64, compiler, compare_long_string_LU,              \\\n+                compare_long_string_LU, compare_long_string_LU)         \\\n+  do_stub(compiler, compare_long_string_UL)                             \\\n+  do_arch_entry(aarch64, compiler, compare_long_string_UL,              \\\n+                compare_long_string_UL, compare_long_string_UL)         \\\n+  do_stub(compiler, string_indexof_linear_ll)                           \\\n+  do_arch_entry(aarch64, compiler, string_indexof_linear_ll,            \\\n+                string_indexof_linear_ll, string_indexof_linear_ll)     \\\n+  do_stub(compiler, string_indexof_linear_uu)                           \\\n+  do_arch_entry(aarch64, compiler, string_indexof_linear_uu,            \\\n+                string_indexof_linear_uu, string_indexof_linear_uu)     \\\n+  do_stub(compiler, string_indexof_linear_ul)                           \\\n+  do_arch_entry(aarch64, compiler, string_indexof_linear_ul,            \\\n+                string_indexof_linear_ul, string_indexof_linear_ul)     \\\n+  \/* this uses the entry for ghash_processBlocks *\/                     \\\n+  do_stub(compiler, ghash_processBlocks_wide)                           \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \\\n+                                    do_arch_blob,                       \\\n+                                    do_arch_entry,                      \\\n+                                    do_arch_entry_init)                 \\\n+  do_arch_blob(final, 20000 ZGC_ONLY(+100000))                          \\\n+  do_stub(final, copy_byte_f)                                           \\\n+  do_arch_entry(aarch64, final, copy_byte_f, copy_byte_f,               \\\n+                copy_byte_f)                                            \\\n+  do_stub(final, copy_byte_b)                                           \\\n+  do_arch_entry(aarch64, final, copy_byte_b, copy_byte_b,               \\\n+                  copy_byte_b)                                          \\\n+  do_stub(final, copy_oop_f)                                            \\\n+  do_arch_entry(aarch64, final, copy_oop_f, copy_oop_f, copy_oop_f)     \\\n+  do_stub(final, copy_oop_b)                                            \\\n+  do_arch_entry(aarch64, final, copy_oop_b, copy_oop_b, copy_oop_b)     \\\n+  do_stub(final, copy_oop_uninit_f)                                     \\\n+  do_arch_entry(aarch64, final, copy_oop_uninit_f, copy_oop_uninit_f,   \\\n+                copy_oop_uninit_f)                                      \\\n+  do_stub(final, copy_oop_uninit_b)                                     \\\n+  do_arch_entry(aarch64, final, copy_oop_uninit_b, copy_oop_uninit_b,   \\\n+                copy_oop_uninit_b)                                      \\\n+  do_stub(final, zero_blocks)                                           \\\n+  do_arch_entry(aarch64, final, zero_blocks, zero_blocks,               \\\n+                zero_blocks)                                            \\\n+  do_stub(final, spin_wait)                                             \\\n+  do_arch_entry_init(aarch64, final, spin_wait, spin_wait,              \\\n+                     spin_wait, empty_spin_wait)                        \\\n+  \/* stub only -- entries are not stored in StubRoutines::aarch64 *\/    \\\n+  \/* n.b. these are not the same as the generic atomic stubs *\/         \\\n+  do_stub(final, atomic_entry_points)                                   \\\n+\n+\n+#endif \/\/ CPU_AARCH64_STUBDECLARATIONS_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/stubDeclarations_aarch64.hpp","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -206,1 +206,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"call_stub\");\n+    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -425,1 +426,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"catch_exception\");\n+    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -480,1 +482,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"forward exception\");\n+    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -569,2 +572,2 @@\n-\n-    StubCodeMark mark(this, \"StubRoutines\", \"verify_oop\");\n+    StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -618,1 +621,1 @@\n-  address generate_iota_indices(const char *stub_name) {\n+  address generate_iota_indices(StubGenStubId stub_id) {\n@@ -620,1 +623,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubCodeMark mark(this, stub_id);\n@@ -663,1 +666,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"zero_blocks\");\n+    StubGenStubId stub_id = StubGenStubId::zero_blocks_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -802,2 +806,33 @@\n-  void generate_copy_longs(DecoratorSet decorators, BasicType type, Label &start, Register s, Register d, Register count,\n-                           copy_direction direction) {\n+  void generate_copy_longs(StubGenStubId stub_id, DecoratorSet decorators, Label &start, Register s, Register d, Register count) {\n+    BasicType type;\n+    copy_direction direction;\n+\n+    switch (stub_id) {\n+    case copy_byte_f_id:\n+      direction = copy_forwards;\n+      type = T_BYTE;\n+      break;\n+    case copy_byte_b_id:\n+      direction = copy_backwards;\n+      type = T_BYTE;\n+      break;\n+    case copy_oop_f_id:\n+      direction = copy_forwards;\n+      type = T_OBJECT;\n+      break;\n+    case copy_oop_b_id:\n+      direction = copy_backwards;\n+      type = T_OBJECT;\n+      break;\n+    case copy_oop_uninit_f_id:\n+      direction = copy_forwards;\n+      type = T_OBJECT;\n+      break;\n+    case copy_oop_uninit_b_id:\n+      direction = copy_backwards;\n+      type = T_OBJECT;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -818,5 +853,0 @@\n-    const char *stub_name;\n-    if (direction == copy_forwards)\n-      stub_name = \"forward_copy_longs\";\n-    else\n-      stub_name = \"backward_copy_longs\";\n@@ -826,1 +856,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1481,4 +1511,5 @@\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   is_oop  - true => oop array, so generate store check code\n-  \/\/   name    - stub name string\n+  \/\/   stub_id - is used to name the stub and identify all details of\n+  \/\/             how to perform the copy.\n+  \/\/\n+  \/\/   entry - is assigned to the stub's post push entry point unless\n+  \/\/           it is null\n@@ -1495,3 +1526,3 @@\n-  \/\/ Side Effects:\n-  \/\/   disjoint_int_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_int_oop_copy().\n+  \/\/ Side Effects: entry is set to the (post push) entry point so it\n+  \/\/               can be used by the corresponding conjoint copy\n+  \/\/               method\n@@ -1499,2 +1530,1 @@\n-  address generate_disjoint_copy(int size, bool aligned, bool is_oop, address *entry,\n-                                  const char *name, bool dest_uninitialized = false) {\n+  address generate_disjoint_copy(StubGenStubId stub_id, address *entry) {\n@@ -1503,0 +1533,81 @@\n+    int size;\n+    bool aligned;\n+    bool is_oop;\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case jbyte_disjoint_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jbyte_disjoint_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jshort_disjoint_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jshort_disjoint_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jint_disjoint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jint_disjoint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jlong_disjoint_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case arrayof_jlong_disjoint_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case arrayof_jlong_disjoint_arraycopy_id:\n+      size = sizeof(jlong);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_disjoint_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_disjoint_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+    }\n+\n@@ -1504,1 +1615,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1551,4 +1662,10 @@\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   is_oop  - true => oop array, so generate store check code\n-  \/\/   name    - stub name string\n+  \/\/   stub_id - is used to name the stub and identify all details of\n+  \/\/             how to perform the copy.\n+  \/\/\n+  \/\/   nooverlap_target - identifes the (post push) entry for the\n+  \/\/             corresponding disjoint copy routine which can be\n+  \/\/             jumped to if the ranges do not actually overlap\n+  \/\/\n+  \/\/   entry - is assigned to the stub's post push entry point unless\n+  \/\/           it is null\n+  \/\/\n@@ -1565,3 +1682,5 @@\n-  address generate_conjoint_copy(int size, bool aligned, bool is_oop, address nooverlap_target,\n-                                 address *entry, const char *name,\n-                                 bool dest_uninitialized = false) {\n+  \/\/ Side Effects:\n+  \/\/   entry is set to the no-overlap entry point so it can be used by\n+  \/\/   some other conjoint copy method\n+  \/\/\n+  address generate_conjoint_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n@@ -1570,1 +1689,81 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    int size;\n+    bool aligned;\n+    bool is_oop;\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case jbyte_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jbyte_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jshort_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jshort_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jlong_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case arrayof_jlong_disjoint_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case arrayof_jlong_arraycopy_id:\n+      size = sizeof(jlong);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1616,181 +1815,0 @@\n-}\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n-  \/\/ we let the hardware handle it.  The one to eight bytes within words,\n-  \/\/ dwords or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_byte_copy_entry is set to the no-overlap entry point  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n-  \/\/ we let the hardware handle it.  The one to eight bytes within words,\n-  \/\/ dwords or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_byte_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_byte_copy().\n-  \/\/\n-  address generate_disjoint_byte_copy(bool aligned, address* entry, const char *name) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jbyte), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n-  \/\/ we let the hardware handle it.  The one to eight bytes within words,\n-  \/\/ dwords or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  address generate_conjoint_byte_copy(bool aligned, address nooverlap_target,\n-                                      address* entry, const char *name) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jbyte), aligned, not_oop, nooverlap_target, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4- or 2-byte boundaries, we\n-  \/\/ let the hardware handle it.  The two or four words within dwords\n-  \/\/ or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_short_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_short_copy().\n-  \/\/\n-  address generate_disjoint_short_copy(bool aligned,\n-                                       address* entry, const char *name) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jshort), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4- or 2-byte boundaries, we\n-  \/\/ let the hardware handle it.  The two or four words within dwords\n-  \/\/ or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  address generate_conjoint_short_copy(bool aligned, address nooverlap_target,\n-                                       address *entry, const char *name) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jshort), aligned, not_oop, nooverlap_target, entry, name);\n-\n-  }\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-byte boundaries, we let\n-  \/\/ the hardware handle it.  The two dwords within qwords that span\n-  \/\/ cache line boundaries will still be loaded and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_int_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_int_oop_copy().\n-  \/\/\n-  address generate_disjoint_int_copy(bool aligned, address *entry,\n-                                         const char *name, bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jint), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-byte boundaries, we let\n-  \/\/ the hardware handle it.  The two dwords within qwords that span\n-  \/\/ cache line boundaries will still be loaded and stored atomically.\n-  \/\/\n-  address generate_conjoint_int_copy(bool aligned, address nooverlap_target,\n-                                     address *entry, const char *name,\n-                                     bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jint), aligned, not_oop, nooverlap_target, entry, name);\n-  }\n-\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_oop_copy_entry or disjoint_long_copy_entry is set to the\n-  \/\/   no-overlap entry point used by generate_conjoint_long_oop_copy().\n-  \/\/\n-  address generate_disjoint_long_copy(bool aligned, address *entry,\n-                                          const char *name, bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jlong), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  address generate_conjoint_long_copy(bool aligned,\n-                                      address nooverlap_target, address *entry,\n-                                      const char *name, bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jlong), aligned, not_oop, nooverlap_target, entry, name);\n@@ -1799,41 +1817,0 @@\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_oop_copy_entry or disjoint_long_copy_entry is set to the\n-  \/\/   no-overlap entry point used by generate_conjoint_long_oop_copy().\n-  \/\/\n-  address generate_disjoint_oop_copy(bool aligned, address *entry,\n-                                     const char *name, bool dest_uninitialized) {\n-    const bool is_oop = true;\n-    const int size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n-    return generate_disjoint_copy(size, aligned, is_oop, entry, name, dest_uninitialized);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  address generate_conjoint_oop_copy(bool aligned,\n-                                     address nooverlap_target, address *entry,\n-                                     const char *name, bool dest_uninitialized) {\n-    const bool is_oop = true;\n-    const int size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n-    return generate_conjoint_copy(size, aligned, is_oop, nooverlap_target, entry,\n-                                  name, dest_uninitialized);\n-  }\n-\n-\n@@ -1877,2 +1854,12 @@\n-  address generate_checkcast_copy(const char *name, address *entry,\n-                                  bool dest_uninitialized = false) {\n+  address generate_checkcast_copy(StubGenStubId stub_id, address *entry) {\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case checkcast_arraycopy_id:\n+      dest_uninitialized = false;\n+      break;\n+    case checkcast_arraycopy_uninit_id:\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -1912,1 +1899,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2084,2 +2071,1 @@\n-  address generate_unsafe_copy(const char *name,\n-                               address byte_copy_entry,\n+  address generate_unsafe_copy(address byte_copy_entry,\n@@ -2089,0 +2075,2 @@\n+    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+\n@@ -2093,1 +2081,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2137,2 +2125,1 @@\n-  address generate_generic_copy(const char *name,\n-                                address byte_copy_entry, address short_copy_entry,\n+  address generate_generic_copy(address byte_copy_entry, address short_copy_entry,\n@@ -2141,0 +2128,1 @@\n+    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n@@ -2158,1 +2146,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2411,1 +2399,33 @@\n-  address generate_fill(BasicType t, bool aligned, const char *name) {\n+  address generate_fill(StubGenStubId stub_id) {\n+    BasicType t;\n+    bool aligned;\n+\n+    switch (stub_id) {\n+    case jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = false;\n+      break;\n+    case jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = false;\n+      break;\n+    case jint_fill_id:\n+      t = T_INT;\n+      aligned = false;\n+      break;\n+    case arrayof_jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = true;\n+      break;\n+    case arrayof_jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = true;\n+      break;\n+    case arrayof_jint_fill_id:\n+      t = T_INT;\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    };\n+\n@@ -2413,1 +2433,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2555,1 +2575,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"_data_cache_writeback\");\n+    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2571,1 +2592,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"_data_cache_writeback_sync\");\n+    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_sync_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2597,2 +2619,2 @@\n-    generate_copy_longs(IN_HEAP | IS_ARRAY, T_BYTE, copy_f, r0, r1, r15, copy_forwards);\n-    generate_copy_longs(IN_HEAP | IS_ARRAY, T_BYTE, copy_b, r0, r1, r15, copy_backwards);\n+    generate_copy_longs(StubGenStubId::copy_byte_f_id, IN_HEAP | IS_ARRAY, copy_f, r0, r1, r15);\n+    generate_copy_longs(StubGenStubId::copy_byte_b_id, IN_HEAP | IS_ARRAY, copy_b, r0, r1, r15);\n@@ -2600,2 +2622,2 @@\n-    generate_copy_longs(IN_HEAP | IS_ARRAY, T_OBJECT, copy_obj_f, r0, r1, r15, copy_forwards);\n-    generate_copy_longs(IN_HEAP | IS_ARRAY, T_OBJECT, copy_obj_b, r0, r1, r15, copy_backwards);\n+    generate_copy_longs(StubGenStubId::copy_oop_f_id, IN_HEAP | IS_ARRAY, copy_obj_f, r0, r1, r15);\n+    generate_copy_longs(StubGenStubId::copy_oop_b_id, IN_HEAP | IS_ARRAY, copy_obj_b, r0, r1, r15);\n@@ -2603,2 +2625,2 @@\n-    generate_copy_longs(IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, T_OBJECT, copy_obj_uninit_f, r0, r1, r15, copy_forwards);\n-    generate_copy_longs(IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, T_OBJECT, copy_obj_uninit_b, r0, r1, r15, copy_backwards);\n+    generate_copy_longs(StubGenStubId::copy_oop_uninit_f_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, copy_obj_uninit_f, r0, r1, r15);\n+    generate_copy_longs(StubGenStubId::copy_oop_uninit_b_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, copy_obj_uninit_b, r0, r1, r15);\n@@ -2610,9 +2632,4 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy         = generate_disjoint_byte_copy(false, &entry,\n-                                                                                  \"jbyte_disjoint_arraycopy\");\n-    StubRoutines::_jbyte_arraycopy                  = generate_conjoint_byte_copy(false, entry,\n-                                                                                  &entry_jbyte_arraycopy,\n-                                                                                  \"jbyte_arraycopy\");\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy = generate_disjoint_byte_copy(true, &entry,\n-                                                                                  \"arrayof_jbyte_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jbyte_arraycopy          = generate_conjoint_byte_copy(true, entry, nullptr,\n-                                                                                  \"arrayof_jbyte_arraycopy\");\n+    StubRoutines::_jbyte_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jbyte_arraycopy                  = generate_conjoint_copy(StubGenStubId::jbyte_arraycopy_id, entry, &entry_jbyte_arraycopy);\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jbyte_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jbyte_arraycopy_id, entry, nullptr);\n@@ -2622,9 +2639,4 @@\n-    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_short_copy(false, &entry,\n-                                                                                    \"jshort_disjoint_arraycopy\");\n-    StubRoutines::_jshort_arraycopy                  = generate_conjoint_short_copy(false, entry,\n-                                                                                    &entry_jshort_arraycopy,\n-                                                                                    \"jshort_arraycopy\");\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_short_copy(true, &entry,\n-                                                                                    \"arrayof_jshort_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_short_copy(true, entry, nullptr,\n-                                                                                    \"arrayof_jshort_arraycopy\");\n+    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubGenStubId::jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jshort_arraycopy_id, entry, nullptr);\n@@ -2634,4 +2646,2 @@\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy = generate_disjoint_int_copy(true, &entry,\n-                                                                                \"arrayof_jint_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jint_arraycopy          = generate_conjoint_int_copy(true, entry, &entry_jint_arraycopy,\n-                                                                                \"arrayof_jint_arraycopy\");\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jint_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2640,5 +2650,2 @@\n-    StubRoutines::_jint_disjoint_arraycopy         = generate_disjoint_int_copy(false, &entry,\n-                                                                                \"jint_disjoint_arraycopy\");\n-    StubRoutines::_jint_arraycopy                  = generate_conjoint_int_copy(false, entry,\n-                                                                                &entry_jint_arraycopy,\n-                                                                                \"jint_arraycopy\");\n+    StubRoutines::_jint_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubGenStubId::jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2648,4 +2655,2 @@\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_long_copy(true, &entry,\n-                                                                                  \"arrayof_jlong_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_long_copy(true, entry, &entry_jlong_arraycopy,\n-                                                                                  \"arrayof_jlong_arraycopy\");\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n@@ -2662,2 +2667,1 @@\n-        = generate_disjoint_oop_copy(aligned, &entry, \"arrayof_oop_disjoint_arraycopy\",\n-                                     \/*dest_uninitialized*\/false);\n+        = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_id, &entry);\n@@ -2665,2 +2669,1 @@\n-        = generate_conjoint_oop_copy(aligned, entry, &entry_oop_arraycopy, \"arrayof_oop_arraycopy\",\n-                                     \/*dest_uninitialized*\/false);\n+        = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n@@ -2669,2 +2672,1 @@\n-        = generate_disjoint_oop_copy(aligned, &entry, \"arrayof_oop_disjoint_arraycopy_uninit\",\n-                                     \/*dest_uninitialized*\/true);\n+        = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_uninit_id, &entry);\n@@ -2672,2 +2674,1 @@\n-        = generate_conjoint_oop_copy(aligned, entry, nullptr, \"arrayof_oop_arraycopy_uninit\",\n-                                     \/*dest_uninitialized*\/true);\n+        = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_uninit_id, entry, nullptr);\n@@ -2681,3 +2682,2 @@\n-    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(\"checkcast_arraycopy\", &entry_checkcast_arraycopy);\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", nullptr,\n-                                                                        \/*dest_uninitialized*\/true);\n+    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id, nullptr);\n@@ -2685,2 +2685,1 @@\n-    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(\"unsafe_arraycopy\",\n-                                                              entry_jbyte_arraycopy,\n+    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(entry_jbyte_arraycopy,\n@@ -2691,2 +2690,1 @@\n-    StubRoutines::_generic_arraycopy   = generate_generic_copy(\"generic_arraycopy\",\n-                                                               entry_jbyte_arraycopy,\n+    StubRoutines::_generic_arraycopy   = generate_generic_copy(entry_jbyte_arraycopy,\n@@ -2699,6 +2697,6 @@\n-    StubRoutines::_jbyte_fill = generate_fill(T_BYTE, false, \"jbyte_fill\");\n-    StubRoutines::_jshort_fill = generate_fill(T_SHORT, false, \"jshort_fill\");\n-    StubRoutines::_jint_fill = generate_fill(T_INT, false, \"jint_fill\");\n-    StubRoutines::_arrayof_jbyte_fill = generate_fill(T_BYTE, true, \"arrayof_jbyte_fill\");\n-    StubRoutines::_arrayof_jshort_fill = generate_fill(T_SHORT, true, \"arrayof_jshort_fill\");\n-    StubRoutines::_arrayof_jint_fill = generate_fill(T_INT, true, \"arrayof_jint_fill\");\n+    StubRoutines::_jbyte_fill = generate_fill(StubGenStubId::jbyte_fill_id);\n+    StubRoutines::_jshort_fill = generate_fill(StubGenStubId::jshort_fill_id);\n+    StubRoutines::_jint_fill = generate_fill(StubGenStubId::jint_fill_id);\n+    StubRoutines::_arrayof_jbyte_fill = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n+    StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n+    StubRoutines::_arrayof_jint_fill = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n@@ -2718,1 +2716,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_encryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2751,1 +2750,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_decryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2789,1 +2789,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_encryptAESCrypt\");\n+    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2893,1 +2894,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_decryptAESCrypt\");\n+    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3079,1 +3081,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"counterMode_AESCrypt\");\n+    StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3288,1 +3291,2 @@\n-     StubCodeMark mark(this, \"StubRoutines\", \"galoisCounterMode_AESCrypt\");\n+    StubGenStubId stub_id = StubGenStubId::galoisCounterMode_AESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3497,1 +3501,12 @@\n-  address generate_md5_implCompress(bool multi_block, const char *name) {\n+  address generate_md5_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch (stub_id) {\n+    case md5_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case md5_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -3499,1 +3514,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -3638,1 +3654,13 @@\n-  address generate_sha1_implCompress(bool multi_block, const char *name) {\n+  address generate_sha1_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch (stub_id) {\n+    case sha1_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case sha1_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -3640,1 +3668,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -3730,1 +3759,13 @@\n-  address generate_sha256_implCompress(bool multi_block, const char *name) {\n+  address generate_sha256_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch (stub_id) {\n+    case sha256_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case sha256_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -3749,0 +3790,1 @@\n+\n@@ -3750,1 +3792,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -3872,1 +3915,13 @@\n-  address generate_sha512_implCompress(bool multi_block, const char *name) {\n+  address generate_sha512_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch (stub_id) {\n+    case sha512_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case sha512_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -3904,1 +3959,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -4020,1 +4076,13 @@\n-  address generate_sha3_implCompress(bool multi_block, const char *name) {\n+  address generate_sha3_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch (stub_id) {\n+    case sha3_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case sha3_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -4033,1 +4101,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -4250,1 +4319,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32\");\n+    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4295,1 +4365,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+    StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4417,1 +4488,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32C\");\n+    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32C_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4455,1 +4527,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesAdler32\");\n+    StubGenStubId stub_id = StubGenStubId::updateBytesAdler32_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4676,1 +4749,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"multiplyToLen\");\n+    StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4708,1 +4782,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"squareToLen\");\n+    StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4741,1 +4816,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"mulAdd\");\n+    StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4771,1 +4847,2 @@\n-    StubCodeMark mark(this,  \"StubRoutines\", \"bigIntegerRightShiftWorker\");\n+    StubGenStubId stub_id = StubGenStubId::bigIntegerRightShiftWorker_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4893,1 +4970,2 @@\n-    StubCodeMark mark(this,  \"StubRoutines\", \"bigIntegerLeftShiftWorker\");\n+    StubGenStubId stub_id = StubGenStubId::bigIntegerLeftShiftWorker_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5001,1 +5079,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"count_positives\");\n+    StubGenStubId stub_id = StubGenStubId::count_positives_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5262,1 +5341,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"large_array_equals\");\n+    StubGenStubId stub_id = StubGenStubId::large_array_equals_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5387,1 +5467,1 @@\n-    const char *mark_name = \"\";\n+    StubGenStubId stub_id;\n@@ -5390,1 +5470,1 @@\n-      mark_name = \"_large_arrays_hashcode_boolean\";\n+      stub_id = StubGenStubId::large_arrays_hashcode_boolean_id;\n@@ -5393,1 +5473,1 @@\n-      mark_name = \"_large_arrays_hashcode_byte\";\n+      stub_id = StubGenStubId::large_arrays_hashcode_byte_id;\n@@ -5396,1 +5476,1 @@\n-      mark_name = \"_large_arrays_hashcode_char\";\n+      stub_id = StubGenStubId::large_arrays_hashcode_char_id;\n@@ -5399,1 +5479,1 @@\n-      mark_name = \"_large_arrays_hashcode_short\";\n+      stub_id = StubGenStubId::large_arrays_hashcode_short_id;\n@@ -5402,1 +5482,1 @@\n-      mark_name = \"_large_arrays_hashcode_int\";\n+      stub_id = StubGenStubId::large_arrays_hashcode_int_id;\n@@ -5405,2 +5485,2 @@\n-      mark_name = \"_large_arrays_hashcode_incorrect_type\";\n-      __ should_not_reach_here();\n+      stub_id = StubGenStubId::NO_STUBID;\n+      ShouldNotReachHere();\n@@ -5409,1 +5489,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", mark_name);\n+    StubCodeMark mark(this, stub_id);\n@@ -5642,1 +5722,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", isCos ? \"libmDcos\" : \"libmDsin\");\n+    StubGenStubId stub_id = (isCos ? StubGenStubId::dcos_id : StubGenStubId::dsin_id);\n+    StubCodeMark mark(this, stub_id);\n@@ -5693,3 +5774,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", isLU\n-        ? \"compare_long_string_different_encoding LU\"\n-        : \"compare_long_string_different_encoding UL\");\n+    StubGenStubId stub_id = (isLU ? StubGenStubId::compare_long_string_LU_id : StubGenStubId::compare_long_string_UL_id);\n+    StubCodeMark mark(this, stub_id);\n@@ -5804,1 +5884,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"float16ToFloat\");\n+    StubGenStubId stub_id = StubGenStubId::hf2f_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5817,1 +5898,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"floatToFloat16\");\n+    StubGenStubId stub_id = StubGenStubId::f2hf_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5827,1 +5909,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5892,3 +5975,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", isLL\n-        ? \"compare_long_string_same_encoding LL\"\n-        : \"compare_long_string_same_encoding UU\");\n+    StubGenStubId stub_id = (isLL ? StubGenStubId::compare_long_string_LL_id : StubGenStubId::compare_long_string_UU_id);\n+    StubCodeMark mark(this, stub_id);\n@@ -6024,0 +6106,9 @@\n+    StubGenStubId stub_id;\n+    switch (mode) {\n+      case LL: stub_id = StubGenStubId::compare_long_string_LL_id;  break;\n+      case LU: stub_id = StubGenStubId::compare_long_string_LU_id; break;\n+      case UL: stub_id = StubGenStubId::compare_long_string_UL_id; break;\n+      case UU: stub_id = StubGenStubId::compare_long_string_UU_id; break;\n+      default: ShouldNotReachHere();\n+    }\n+\n@@ -6059,10 +6150,1 @@\n-    const char* stubname;\n-    switch (mode) {\n-      case LL: stubname = \"compare_long_string_same_encoding LL\";      break;\n-      case LU: stubname = \"compare_long_string_different_encoding LU\"; break;\n-      case UL: stubname = \"compare_long_string_different_encoding UL\"; break;\n-      case UU: stubname = \"compare_long_string_same_encoding UU\";      break;\n-      default: ShouldNotReachHere();\n-    }\n-\n-    StubCodeMark mark(this, \"StubRoutines\", stubname);\n+    StubCodeMark mark(this, stub_id);\n@@ -6160,3 +6242,14 @@\n-    const char* stubName = str1_isL\n-        ? (str2_isL ? \"indexof_linear_ll\" : \"indexof_linear_ul\")\n-        : \"indexof_linear_uu\";\n+    StubGenStubId stub_id;\n+    if (str1_isL) {\n+      if (str2_isL) {\n+        stub_id = StubGenStubId::string_indexof_linear_ll_id;\n+      } else {\n+        stub_id = StubGenStubId::string_indexof_linear_ul_id;\n+      }\n+    } else {\n+      if (str2_isL) {\n+        ShouldNotReachHere();\n+      } else {\n+        stub_id = StubGenStubId::string_indexof_linear_uu_id;\n+      }\n+    }\n@@ -6164,1 +6257,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stubName);\n+    StubCodeMark mark(this, stub_id);\n@@ -6462,1 +6555,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"large_byte_array_inflate\");\n+    StubGenStubId stub_id = StubGenStubId::large_byte_array_inflate_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6527,1 +6621,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"ghash_processBlocks\");\n+    StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6593,1 +6688,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"ghash_processBlocks_wide\");\n+    StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_wide_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6704,1 +6800,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"encodeBlock\");\n+    StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6972,1 +7069,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"decodeBlock\");\n+    StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7088,1 +7186,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"spin_wait\");\n+    StubGenStubId stub_id = StubGenStubId::spin_wait_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7097,2 +7196,3 @@\n-  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+  void generate_lookup_secondary_supers_table_stub() {\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7100,1 +7200,0 @@\n-    address start = __ pc();\n@@ -7112,10 +7211,11 @@\n-    Label L_success;\n-    __ enter();\n-    __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n-                                           r_array_base, r_array_length, r_array_index,\n-                                           vtemp, result, super_klass_index,\n-                                           \/*stub_is_near*\/true);\n-    __ leave();\n-    __ ret(lr);\n-\n-    return start;\n+    for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+      Label L_success;\n+      __ enter();\n+      __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n+                                             r_array_base, r_array_length, r_array_index,\n+                                             vtemp, result, slot,\n+                                             \/*stub_is_near*\/true);\n+      __ leave();\n+      __ ret(lr);\n+    }\n@@ -7126,1 +7226,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7279,1 +7380,0 @@\n-\n@@ -7281,1 +7381,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic entry points\");\n+    StubGenStubId stub_id = StubGenStubId::atomic_entry_points_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7440,1 +7541,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"Cont thaw\");\n+    StubGenStubId stub_id = StubGenStubId::cont_thaw_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7450,1 +7552,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier\");\n+    StubGenStubId stub_id = StubGenStubId::cont_returnBarrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7461,1 +7564,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier exception handler\");\n+    StubGenStubId stub_id = StubGenStubId::cont_returnBarrierExc_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7471,1 +7575,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\",\"Continuation preempt stub\");\n+    StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7553,1 +7658,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"poly1305_processBlocks\");\n+    StubGenStubId stub_id = StubGenStubId::poly1305_processBlocks_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7667,1 +7773,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+    StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7684,1 +7791,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+    StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -8673,3 +8781,2 @@\n-    if (UsePoly1305Intrinsics) {\n-      StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n-    }\n+    StubRoutines::_upcall_stub_exception_handler = generate_upcall_stub_exception_handler();\n+    StubRoutines::_upcall_stub_load_target = generate_upcall_stub_load_target();\n@@ -8687,4 +8794,1 @@\n-        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n-            = generate_lookup_secondary_supers_table_stub(slot);\n-        }\n+        generate_lookup_secondary_supers_table_stub();\n@@ -8695,3 +8799,0 @@\n-    StubRoutines::_upcall_stub_exception_handler = generate_upcall_stub_exception_handler();\n-    StubRoutines::_upcall_stub_load_target = generate_upcall_stub_load_target();\n-\n@@ -8705,1 +8806,1 @@\n-      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(\"iota_indices\");\n+      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(StubGenStubId::vector_iota_indices_id);\n@@ -8749,1 +8850,2 @@\n-      StubCodeMark mark(this, \"StubRoutines\", \"montgomeryMultiply\");\n+      StubGenStubId stub_id = StubGenStubId::montgomeryMultiply_id;\n+      StubCodeMark mark(this, stub_id);\n@@ -8755,1 +8857,2 @@\n-      StubCodeMark mark(this, \"StubRoutines\", \"montgomerySquare\");\n+      StubGenStubId stub_id = StubGenStubId::montgomerySquare_id;\n+      StubCodeMark mark(this, stub_id);\n@@ -8795,2 +8898,2 @@\n-      StubRoutines::_md5_implCompress      = generate_md5_implCompress(false,    \"md5_implCompress\");\n-      StubRoutines::_md5_implCompressMB    = generate_md5_implCompress(true,     \"md5_implCompressMB\");\n+      StubRoutines::_md5_implCompress      = generate_md5_implCompress(StubGenStubId::md5_implCompress_id);\n+      StubRoutines::_md5_implCompressMB    = generate_md5_implCompress(StubGenStubId::md5_implCompressMB_id);\n@@ -8799,2 +8902,2 @@\n-      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(false,   \"sha1_implCompress\");\n-      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(true,    \"sha1_implCompressMB\");\n+      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(StubGenStubId::sha1_implCompress_id);\n+      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(StubGenStubId::sha1_implCompressMB_id);\n@@ -8803,2 +8906,2 @@\n-      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(false, \"sha256_implCompress\");\n-      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(true,  \"sha256_implCompressMB\");\n+      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n@@ -8807,2 +8910,2 @@\n-      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(false, \"sha512_implCompress\");\n-      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(true,  \"sha512_implCompressMB\");\n+      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n@@ -8811,2 +8914,6 @@\n-      StubRoutines::_sha3_implCompress     = generate_sha3_implCompress(false,   \"sha3_implCompress\");\n-      StubRoutines::_sha3_implCompressMB   = generate_sha3_implCompress(true,    \"sha3_implCompressMB\");\n+      StubRoutines::_sha3_implCompress     = generate_sha3_implCompress(StubGenStubId::sha3_implCompress_id);\n+      StubRoutines::_sha3_implCompressMB   = generate_sha3_implCompress(StubGenStubId::sha3_implCompressMB_id);\n+    }\n+\n+    if (UsePoly1305Intrinsics) {\n+      StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n@@ -8824,3 +8931,3 @@\n-  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    switch(kind) {\n-    case Initial_stubs:\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+    switch(blob_id) {\n+    case initial_id:\n@@ -8829,1 +8936,1 @@\n-     case Continuation_stubs:\n+     case continuation_id:\n@@ -8832,1 +8939,1 @@\n-    case Compiler_stubs:\n+    case compiler_id:\n@@ -8835,1 +8942,1 @@\n-    case Final_stubs:\n+    case final_id:\n@@ -8839,1 +8946,1 @@\n-      fatal(\"unexpected stubs kind: %d\", kind);\n+      fatal(\"unexpected blob id: %d\", blob_id);\n@@ -8845,2 +8952,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":555,"deletions":448,"binary":false,"changes":1003,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-\/\/ Implementation of the platform-specific part of StubRoutines - for\n-\/\/ a description of how to extend it, see the stubRoutines.hpp file.\n+\/\/ function used as default for spin_wait stub\n@@ -36,1 +35,1 @@\n-address StubRoutines::aarch64::_get_previous_sp_entry = nullptr;\n+static void empty_spin_wait() { }\n@@ -38,26 +37,1 @@\n-address StubRoutines::aarch64::_f2i_fixup = nullptr;\n-address StubRoutines::aarch64::_f2l_fixup = nullptr;\n-address StubRoutines::aarch64::_d2i_fixup = nullptr;\n-address StubRoutines::aarch64::_d2l_fixup = nullptr;\n-address StubRoutines::aarch64::_vector_iota_indices = nullptr;\n-address StubRoutines::aarch64::_float_sign_mask = nullptr;\n-address StubRoutines::aarch64::_float_sign_flip = nullptr;\n-address StubRoutines::aarch64::_double_sign_mask = nullptr;\n-address StubRoutines::aarch64::_double_sign_flip = nullptr;\n-address StubRoutines::aarch64::_zero_blocks = nullptr;\n-address StubRoutines::aarch64::_count_positives = nullptr;\n-address StubRoutines::aarch64::_count_positives_long = nullptr;\n-address StubRoutines::aarch64::_large_array_equals = nullptr;\n-address StubRoutines::aarch64::_large_arrays_hashcode_boolean = nullptr;\n-address StubRoutines::aarch64::_large_arrays_hashcode_byte = nullptr;\n-address StubRoutines::aarch64::_large_arrays_hashcode_char = nullptr;\n-address StubRoutines::aarch64::_large_arrays_hashcode_int = nullptr;\n-address StubRoutines::aarch64::_large_arrays_hashcode_short = nullptr;\n-address StubRoutines::aarch64::_compare_long_string_LL = nullptr;\n-address StubRoutines::aarch64::_compare_long_string_UU = nullptr;\n-address StubRoutines::aarch64::_compare_long_string_LU = nullptr;\n-address StubRoutines::aarch64::_compare_long_string_UL = nullptr;\n-address StubRoutines::aarch64::_string_indexof_linear_ll = nullptr;\n-address StubRoutines::aarch64::_string_indexof_linear_uu = nullptr;\n-address StubRoutines::aarch64::_string_indexof_linear_ul = nullptr;\n-address StubRoutines::aarch64::_large_byte_array_inflate = nullptr;\n+\/\/ define fields for arch-specific entries\n@@ -65,2 +39,10 @@\n-static void empty_spin_wait() { }\n-address StubRoutines::aarch64::_spin_wait = CAST_FROM_FN_PTR(address, empty_spin_wait);\n+#define DEFINE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = nullptr;\n+\n+#define DEFINE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = CAST_FROM_FN_PTR(address, init_function);\n+\n+STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY, DEFINE_ARCH_ENTRY_INIT)\n+\n+#undef DEFINE_ARCH_ENTRY_INIT\n+#undef DEFINE_ARCH_ENTRY\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":13,"deletions":31,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -37,0 +37,5 @@\n+\/\/ emit enum used to size per-blob code buffers\n+\n+#define DEFINE_BLOB_SIZE(blob_name, size) \\\n+  _ ## blob_name ## _code_size = size,\n+\n@@ -38,5 +43,1 @@\n-  \/\/ simply increase sizes if too small (assembler will crash if too small)\n-  _initial_stubs_code_size      = 10000,\n-  _continuation_stubs_code_size =  2000,\n-  _compiler_stubs_code_size     = 30000 ZGC_ONLY(+10000),\n-  _final_stubs_code_size        = 20000 ZGC_ONLY(+100000)\n+  STUBGEN_ARCH_BLOBS_DO(DEFINE_BLOB_SIZE)\n@@ -45,0 +46,2 @@\n+#undef DEFINE_BLOB_SIZE\n+\n@@ -47,0 +50,3 @@\n+#if INCLUDE_JVMCI\n+  friend class JVMCIVMStructs;\n+#endif\n@@ -48,44 +54,1 @@\n- private:\n-  static address _get_previous_sp_entry;\n-\n-  static address _f2i_fixup;\n-  static address _f2l_fixup;\n-  static address _d2i_fixup;\n-  static address _d2l_fixup;\n-\n-  static address _vector_iota_indices;\n-  static address _float_sign_mask;\n-  static address _float_sign_flip;\n-  static address _double_sign_mask;\n-  static address _double_sign_flip;\n-\n-  static address _zero_blocks;\n-\n-  static address _large_array_equals;\n-  static address _large_arrays_hashcode_boolean;\n-  static address _large_arrays_hashcode_byte;\n-  static address _large_arrays_hashcode_char;\n-  static address _large_arrays_hashcode_int;\n-  static address _large_arrays_hashcode_short;\n-  static address _compare_long_string_LL;\n-  static address _compare_long_string_LU;\n-  static address _compare_long_string_UL;\n-  static address _compare_long_string_UU;\n-  static address _string_indexof_linear_ll;\n-  static address _string_indexof_linear_uu;\n-  static address _string_indexof_linear_ul;\n-  static address _large_byte_array_inflate;\n-\n-  static address _spin_wait;\n-\n-  static bool _completed;\n-\n- public:\n-\n-  static address _count_positives;\n-  static address _count_positives_long;\n-\n-  static address get_previous_sp_entry()\n-  {\n-    return _get_previous_sp_entry;\n-  }\n+  \/\/ declare fields for arch-specific entries\n@@ -93,4 +56,2 @@\n-  static address f2i_fixup()\n-  {\n-    return _f2i_fixup;\n-  }\n+#define DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address STUB_FIELD_NAME(field_name) ;\n@@ -98,4 +59,2 @@\n-  static address f2l_fixup()\n-  {\n-    return _f2l_fixup;\n-  }\n+#define DECLARE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name)\n@@ -103,9 +62,2 @@\n-  static address d2i_fixup()\n-  {\n-    return _d2i_fixup;\n-  }\n-\n-  static address d2l_fixup()\n-  {\n-    return _d2l_fixup;\n-  }\n+private:\n+  STUBGEN_ARCH_ENTRIES_DO(DECLARE_ARCH_ENTRY, DECLARE_ARCH_ENTRY_INIT)\n@@ -113,3 +65,2 @@\n-  static address vector_iota_indices() {\n-    return _vector_iota_indices;\n-  }\n+#undef DECLARE_ARCH_ENTRY_INIT\n+#undef DECLARE_ARCH_ENTRY\n@@ -117,9 +68,1 @@\n-  static address float_sign_mask()\n-  {\n-    return _float_sign_mask;\n-  }\n-\n-  static address float_sign_flip()\n-  {\n-    return _float_sign_flip;\n-  }\n+  static bool _completed;\n@@ -127,4 +70,1 @@\n-  static address double_sign_mask()\n-  {\n-    return _double_sign_mask;\n-  }\n+ public:\n@@ -132,4 +72,1 @@\n-  static address double_sign_flip()\n-  {\n-    return _double_sign_flip;\n-  }\n+  \/\/ declare getters for arch-specific entries\n@@ -137,3 +74,2 @@\n-  static address zero_blocks() {\n-    return _zero_blocks;\n-  }\n+#define DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address getter_name() { return STUB_FIELD_NAME(field_name) ; }\n@@ -141,3 +77,2 @@\n-  static address count_positives() {\n-    return _count_positives;\n-  }\n+#define DEFINE_ARCH_ENTRY_GETTER_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name)\n@@ -145,3 +80,1 @@\n-  static address count_positives_long() {\n-      return _count_positives_long;\n-  }\n+  STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY_GETTER, DEFINE_ARCH_ENTRY_GETTER_INIT)\n@@ -149,3 +82,2 @@\n-  static address large_array_equals() {\n-      return _large_array_equals;\n-  }\n+#undef DEFINE_ARCH_ENTRY_GETTER_INIT\n+#undef DEFINE_ARCH_ENTRY_GETTER\n@@ -156,1 +88,1 @@\n-      return _large_arrays_hashcode_boolean;\n+      return large_arrays_hashcode_boolean();\n@@ -158,1 +90,1 @@\n-      return _large_arrays_hashcode_byte;\n+      return large_arrays_hashcode_byte();\n@@ -160,1 +92,1 @@\n-      return _large_arrays_hashcode_char;\n+      return large_arrays_hashcode_char();\n@@ -162,1 +94,1 @@\n-      return _large_arrays_hashcode_short;\n+      return large_arrays_hashcode_short();\n@@ -164,1 +96,1 @@\n-      return _large_arrays_hashcode_int;\n+      return large_arrays_hashcode_int();\n@@ -172,36 +104,0 @@\n-  static address compare_long_string_LL() {\n-      return _compare_long_string_LL;\n-  }\n-\n-  static address compare_long_string_LU() {\n-      return _compare_long_string_LU;\n-  }\n-\n-  static address compare_long_string_UL() {\n-      return _compare_long_string_UL;\n-  }\n-\n-  static address compare_long_string_UU() {\n-      return _compare_long_string_UU;\n-  }\n-\n-  static address string_indexof_linear_ul() {\n-      return _string_indexof_linear_ul;\n-  }\n-\n-  static address string_indexof_linear_ll() {\n-      return _string_indexof_linear_ll;\n-  }\n-\n-  static address string_indexof_linear_uu() {\n-      return _string_indexof_linear_uu;\n-  }\n-\n-  static address large_byte_array_inflate() {\n-      return _large_byte_array_inflate;\n-  }\n-\n-  static address spin_wait() {\n-    return _spin_wait;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.hpp","additions":35,"deletions":139,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights\n+ * reserved.  Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ARM_STUBDECLARATIONS_HPP\n+#define CPU_ARM_STUBDECLARATIONS_HPP\n+\n+#define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n+  do_arch_blob(initial, 9000)                                           \\\n+  do_stub(initial, idiv_irem)                                           \\\n+  do_arch_entry(Arm, initial, idiv_irem,                                \\\n+                idiv_irem_entry, idiv_irem_entry)                       \\\n+  do_stub(initial, atomic_load_long)                                    \\\n+  do_arch_entry(Arm, initial, atomic_load_long,                         \\\n+                atomic_load_long_entry, atomic_load_long_entry)         \\\n+  do_stub(initial, atomic_store_long)                                   \\\n+  do_arch_entry(Arm, initial, atomic_load_long,                         \\\n+                atomic_store_long_entry, atomic_store_long_entry)       \\\n+\n+#define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \\\n+                                           do_arch_blob,                \\\n+                                           do_arch_entry,               \\\n+                                           do_arch_entry_init)          \\\n+  do_arch_blob(continuation, 2000)                                      \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \\\n+                                       do_arch_blob,                    \\\n+                                       do_arch_entry,                   \\\n+                                       do_arch_entry_init)              \\\n+  do_arch_blob(compiler, 22000)                                         \\\n+  do_stub(compiler, partial_subtype_check)                              \\\n+  do_arch_entry(Arm, compiler, partial_subtype_check,                   \\\n+                partial_subtype_check, partial_subtype_check)           \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \\\n+                                    do_arch_blob,                       \\\n+                                    do_arch_entry,                      \\\n+                                    do_arch_entry_init)                 \\\n+  do_arch_blob(final, 22000)                                            \\\n+\n+\n+#endif \/\/ CPU_ARM_STUBDECLARATIONS_HPP\n","filename":"src\/hotspot\/cpu\/arm\/stubDeclarations_arm.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -176,1 +176,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"call_stub\");\n+    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -255,1 +256,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"catch_exception\");\n+    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -267,1 +269,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"forward exception\");\n+    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -316,0 +319,2 @@\n+    StubGenStubId stub_id = StubGenStubId::idiv_irem_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -457,1 +462,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_add\");\n+    StubGenStubId stub_id = StubGenStubId::atomic_add_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -508,1 +514,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_xchg\");\n+    StubGenStubId stub_id = StubGenStubId::atomic_xchg_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -558,1 +565,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_cmpxchg\");\n+    StubGenStubId stub_id = StubGenStubId::atomic_cmpxchg_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -596,1 +604,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_cmpxchg_long\");\n+    StubGenStubId stub_id = StubGenStubId::atomic_cmpxchg_long_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -633,1 +642,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_load_long\");\n+    StubGenStubId stub_id = StubGenStubId::atomic_load_long_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -657,1 +667,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_store_long\");\n+    StubGenStubId stub_id = StubGenStubId::atomic_store_long_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -699,1 +710,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"partial_subtype_check\");\n+    StubGenStubId stub_id = StubGenStubId::partial_subtype_check_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -788,1 +800,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"verify_oop\");\n+    StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1989,0 +2002,17 @@\n+  \/* Internal development flag                     *\/\n+  \/* enabled by defining TEST_C2_GENERIC_ARRAYCOPY *\/\n+\n+  \/\/ With this flag, the C2 stubs are tested by generating calls to\n+  \/\/ generic_arraycopy instead of Runtime1::arraycopy\n+\n+  \/\/ Runtime1::arraycopy return a status in R0 (0 if OK, else ~copied)\n+  \/\/ and the result is tested to see whether the arraycopy stub should\n+  \/\/ be called.\n+\n+  \/\/ When we test arraycopy this way, we must generate extra code in the\n+  \/\/ arraycopy methods callable from C2 generic_arraycopy to set the\n+  \/\/ status to 0 for those who always succeed (calling the slow path stub might\n+  \/\/ lead to errors since the copy has already been performed).\n+\n+  static const bool set_status;\n+\n@@ -2001,1 +2031,101 @@\n-  address generate_primitive_copy(bool aligned, const char * name, bool status, int bytes_per_count, bool disjoint, address nooverlap_target = nullptr) {\n+  address generate_primitive_copy(StubGenStubId stub_id, address nooverlap_target = nullptr) {\n+    bool aligned;\n+    bool status;\n+    int bytes_per_count;\n+    bool disjoint;\n+\n+    switch (stub_id) {\n+    case jbyte_disjoint_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 1;\n+      disjoint = true;\n+      break;\n+    case jshort_disjoint_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 2;\n+      disjoint = true;\n+      break;\n+    case jint_disjoint_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 4;\n+      disjoint = true;\n+      break;\n+    case jlong_disjoint_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 8;\n+      disjoint = true;\n+      break;\n+    case arrayof_jbyte_disjoint_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      bytes_per_count = 1;\n+      disjoint = true;\n+      break;\n+    case arrayof_jshort_disjoint_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      bytes_per_count = 2;\n+      disjoint = true;\n+      break;\n+    case arrayof_jint_disjoint_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      bytes_per_count = 4;\n+      disjoint = true;\n+      break;\n+    case arrayof_jlong_disjoint_arraycopy_id:\n+      aligned = false;\n+      status = set_status;\n+      bytes_per_count = 8;\n+      disjoint = true;\n+      break;\n+    case jbyte_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 1;\n+      disjoint = false;\n+      break;\n+    case jshort_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 2;\n+      disjoint = false;\n+      break;\n+    case jint_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 4;\n+      disjoint = false;\n+      break;\n+    case jlong_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 8;\n+      disjoint = false;\n+      break;\n+    case arrayof_jbyte_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      bytes_per_count = 1;\n+      disjoint = false;\n+      break;\n+    case arrayof_jshort_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      bytes_per_count = 2;\n+      disjoint = false;\n+      break;\n+    case arrayof_jint_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      bytes_per_count = 4;\n+      disjoint = false;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -2003,1 +2133,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2175,1 +2305,30 @@\n-  address generate_oop_copy(bool aligned, const char * name, bool status, bool disjoint, address nooverlap_target = nullptr) {\n+  address generate_oop_copy(StubGenStubId stub_id, address nooverlap_target = nullptr) {\n+    bool aligned;\n+    bool status;\n+    bool disjoint;\n+\n+    switch (stub_id) {\n+    case oop_disjoint_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      disjoint = true;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      disjoint = true;\n+      break;\n+    case oop_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      disjoint = false;\n+      break;\n+    case arrayof_oop_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      disjoint = false;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -2177,1 +2336,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2312,1 +2471,1 @@\n-  address generate_unsafe_copy(const char* name) {\n+  address generate_unsafe_copy() {\n@@ -2321,1 +2480,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2446,1 +2606,1 @@\n-  address generate_checkcast_copy(const char * name) {\n+  address generate_checkcast_copy() {\n@@ -2448,1 +2608,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::checkcast_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2599,1 +2760,1 @@\n-  address generate_generic_copy(const char *name) {\n+  address generate_generic_copy() {\n@@ -2615,1 +2776,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2846,18 +3008,0 @@\n-    bool status = false; \/\/ non failing C2 stubs need not return a status in R0\n-\n-#ifdef TEST_C2_GENERIC_ARRAYCOPY \/* Internal development flag *\/\n-    \/\/ With this flag, the C2 stubs are tested by generating calls to\n-    \/\/ generic_arraycopy instead of Runtime1::arraycopy\n-\n-    \/\/ Runtime1::arraycopy return a status in R0 (0 if OK, else ~copied)\n-    \/\/ and the result is tested to see whether the arraycopy stub should\n-    \/\/ be called.\n-\n-    \/\/ When we test arraycopy this way, we must generate extra code in the\n-    \/\/ arraycopy methods callable from C2 generic_arraycopy to set the\n-    \/\/ status to 0 for those who always succeed (calling the slow path stub might\n-    \/\/ lead to errors since the copy has already been performed).\n-\n-    status = true; \/\/ generate a status compatible with C1 calls\n-#endif\n-\n@@ -2868,11 +3012,11 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy  = generate_primitive_copy(false, \"jbyte_disjoint_arraycopy\",  true, 1, true);\n-    StubRoutines::_jshort_disjoint_arraycopy = generate_primitive_copy(false, \"jshort_disjoint_arraycopy\", true, 2, true);\n-    StubRoutines::_jint_disjoint_arraycopy   = generate_primitive_copy(false, \"jint_disjoint_arraycopy\",   true, 4, true);\n-    StubRoutines::_jlong_disjoint_arraycopy  = generate_primitive_copy(false, \"jlong_disjoint_arraycopy\",  true, 8, true);\n-    StubRoutines::_oop_disjoint_arraycopy    = generate_oop_copy      (false, \"oop_disjoint_arraycopy\",    true,    true);\n-\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_primitive_copy(true, \"arrayof_jbyte_disjoint_arraycopy\", status, 1, true);\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_primitive_copy(true, \"arrayof_jshort_disjoint_arraycopy\",status, 2, true);\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_primitive_copy(true, \"arrayof_jint_disjoint_arraycopy\",  status, 4, true);\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy  = generate_primitive_copy(true, \"arrayof_jlong_disjoint_arraycopy\", status, 8, true);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy    = generate_oop_copy      (true, \"arrayof_oop_disjoint_arraycopy\",   status,    true);\n+    StubRoutines::_jbyte_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_jshort_disjoint_arraycopy = generate_primitive_copy(StubGenStubId::jshort_disjoint_arraycopy_id);\n+    StubRoutines::_jint_disjoint_arraycopy   = generate_primitive_copy(StubGenStubId::jint_disjoint_arraycopy_id);\n+    StubRoutines::_jlong_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::jlong_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy    = generate_oop_copy      (StubGenStubId::oop_disjoint_arraycopy_id);\n+\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_primitive_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_primitive_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy    = generate_oop_copy      (StubGenStubId::arrayof_oop_disjoint_arraycopy_id);\n@@ -2881,8 +3025,8 @@\n-    StubRoutines::_jbyte_arraycopy  = generate_primitive_copy(false, \"jbyte_arraycopy\",  true, 1, false, StubRoutines::_jbyte_disjoint_arraycopy);\n-    StubRoutines::_jshort_arraycopy = generate_primitive_copy(false, \"jshort_arraycopy\", true, 2, false, StubRoutines::_jshort_disjoint_arraycopy);\n-    StubRoutines::_jint_arraycopy   = generate_primitive_copy(false, \"jint_arraycopy\",   true, 4, false, StubRoutines::_jint_disjoint_arraycopy);\n-    StubRoutines::_jlong_arraycopy  = generate_primitive_copy(false, \"jlong_arraycopy\",  true, 8, false, StubRoutines::_jlong_disjoint_arraycopy);\n-    StubRoutines::_oop_arraycopy    = generate_oop_copy      (false, \"oop_arraycopy\",    true,    false, StubRoutines::_oop_disjoint_arraycopy);\n-\n-    StubRoutines::_arrayof_jbyte_arraycopy    = generate_primitive_copy(true, \"arrayof_jbyte_arraycopy\",  status, 1, false, StubRoutines::_arrayof_jbyte_disjoint_arraycopy);\n-    StubRoutines::_arrayof_jshort_arraycopy   = generate_primitive_copy(true, \"arrayof_jshort_arraycopy\", status, 2, false, StubRoutines::_arrayof_jshort_disjoint_arraycopy);\n+    StubRoutines::_jbyte_arraycopy  = generate_primitive_copy(StubGenStubId::jbyte_arraycopy_id, StubRoutines::_jbyte_disjoint_arraycopy);\n+    StubRoutines::_jshort_arraycopy = generate_primitive_copy(StubGenStubId::jshort_arraycopy_id, StubRoutines::_jshort_disjoint_arraycopy);\n+    StubRoutines::_jint_arraycopy   = generate_primitive_copy(StubGenStubId::jint_arraycopy_id, StubRoutines::_jint_disjoint_arraycopy);\n+    StubRoutines::_jlong_arraycopy  = generate_primitive_copy(StubGenStubId::jlong_arraycopy_id, StubRoutines::_jlong_disjoint_arraycopy);\n+    StubRoutines::_oop_arraycopy    = generate_oop_copy      (StubGenStubId::oop_arraycopy_id, StubRoutines::_oop_disjoint_arraycopy);\n+\n+    StubRoutines::_arrayof_jbyte_arraycopy    = generate_primitive_copy(StubGenStubId::arrayof_jbyte_arraycopy_id, StubRoutines::_arrayof_jbyte_disjoint_arraycopy);\n+    StubRoutines::_arrayof_jshort_arraycopy   = generate_primitive_copy(StubGenStubId::arrayof_jshort_arraycopy_id, StubRoutines::_arrayof_jshort_disjoint_arraycopy);\n@@ -2891,1 +3035,1 @@\n-    StubRoutines::_arrayof_jint_arraycopy     = generate_primitive_copy(true, \"arrayof_jint_arraycopy\",   status, 4, false, StubRoutines::_arrayof_jint_disjoint_arraycopy);\n+    StubRoutines::_arrayof_jint_arraycopy     = generate_primitive_copy(StubGenStubId::arrayof_jint_arraycopy_id, StubRoutines::_arrayof_jint_disjoint_arraycopy);\n@@ -2896,1 +3040,1 @@\n-      StubRoutines::_arrayof_oop_arraycopy    = generate_oop_copy      (true, \"arrayof_oop_arraycopy\",    status,    false, StubRoutines::_arrayof_oop_disjoint_arraycopy);\n+      StubRoutines::_arrayof_oop_arraycopy    = generate_oop_copy      (StubGenStubId::arrayof_oop_arraycopy_id, StubRoutines::_arrayof_oop_disjoint_arraycopy);\n@@ -2902,3 +3046,3 @@\n-    StubRoutines::_checkcast_arraycopy = generate_checkcast_copy(\"checkcast_arraycopy\");\n-    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(\"unsafe_arraycopy\");\n-    StubRoutines::_generic_arraycopy   = generate_generic_copy(\"generic_arraycopy\");\n+    StubRoutines::_checkcast_arraycopy = generate_checkcast_copy();\n+    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy();\n+    StubRoutines::_generic_arraycopy   = generate_generic_copy();\n@@ -2911,1 +3055,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2964,1 +3109,1 @@\n-  address generate_cont_thaw(const char* label, Continuation::thaw_kind kind) {\n+  address generate_cont_thaw(StubGenStubId stub_id) {\n@@ -2971,1 +3116,1 @@\n-    return generate_cont_thaw(\"Cont thaw\", Continuation::thaw_top);\n+    return generate_cont_thaw(StubGenStubId::cont_thaw_id);\n@@ -2975,1 +3120,1 @@\n-    return generate_cont_thaw(\"Cont thaw return barrier\", Continuation::thaw_return_barrier);\n+    return generate_cont_thaw(StubGenStubId::cont_returnBarrier_id);\n@@ -2979,1 +3124,1 @@\n-    return generate_cont_thaw(\"Cont thaw return barrier exception\", Continuation::thaw_return_barrier_exception);\n+    return generate_cont_thaw(StubGenStubId::cont_returnBarrierExc_id);\n@@ -3011,2 +3156,2 @@\n-    StubRoutines::_atomic_load_long_entry = generate_atomic_load_long();\n-    StubRoutines::_atomic_store_long_entry = generate_atomic_store_long();\n+    StubRoutines::Arm::_atomic_load_long_entry = generate_atomic_load_long();\n+    StubRoutines::Arm::_atomic_store_long_entry = generate_atomic_store_long();\n@@ -3062,3 +3207,3 @@\n-  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    switch(kind) {\n-    case Initial_stubs:\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+    switch(blob_id) {\n+    case initial_id:\n@@ -3067,1 +3212,1 @@\n-     case Continuation_stubs:\n+     case continuation_id:\n@@ -3070,1 +3215,1 @@\n-    case Compiler_stubs:\n+    case compiler_id:\n@@ -3073,1 +3218,1 @@\n-    case Final_stubs:\n+    case final_id:\n@@ -3077,1 +3222,1 @@\n-      fatal(\"unexpected stubs kind: %d\", kind);\n+      fatal(\"unexpected blob id: %d\", blob_id);\n@@ -3083,2 +3228,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n@@ -3086,0 +3231,9 @@\n+\n+\/\/ implementation of internal development flag\n+\n+#ifdef TEST_C2_GENERIC_ARRAYCOPY\n+const bool StubGenerator::set_status = true; \/\/ generate a status compatible with C1 calls\n+#else\n+const bool StubGenerator::set_status = false; \/\/ non failing C2 stubs need not return a status in R0\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":233,"deletions":79,"binary":false,"changes":312,"status":"modified"},{"patch":"@@ -122,1 +122,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"aesencryptBlock\");\n+  StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -319,1 +320,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"aesdecryptBlock\");\n+  StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -539,1 +541,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_encryptAESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -604,1 +607,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_decryptAESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/arm\/stubRoutinesCrypto_arm.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-address StubRoutines::Arm::_idiv_irem_entry = nullptr;\n+#define DEFINE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = nullptr;\n@@ -32,1 +33,2 @@\n-address StubRoutines::Arm::_partial_subtype_check = nullptr;\n+#define DEFINE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = CAST_FROM_FN_PTR(address, init_function);\n@@ -34,2 +36,4 @@\n-address StubRoutines::_atomic_load_long_entry = nullptr;\n-address StubRoutines::_atomic_store_long_entry = nullptr;\n+STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY, DEFINE_ARCH_ENTRY_INIT)\n+\n+#undef DEFINE_ARCH_ENTRY_INIT\n+#undef DEFINE_ARCH_ENTRY\n","filename":"src\/hotspot\/cpu\/arm\/stubRoutines_arm.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,0 +32,5 @@\n+\/\/ emit enum used to size per-blob code buffers\n+\n+#define DEFINE_BLOB_SIZE(blob_name, size) \\\n+  _ ## blob_name ## _code_size = size,\n+\n@@ -33,5 +38,1 @@\n-  \/\/ simply increase sizes if too small (assembler will crash if too small)\n-  _initial_stubs_code_size      =  9000,\n-  _continuation_stubs_code_size =  2000,\n-  _compiler_stubs_code_size     = 22000,\n-  _final_stubs_code_size        = 22000\n+  STUBGEN_ARCH_BLOBS_DO(DEFINE_BLOB_SIZE)\n@@ -40,0 +41,7 @@\n+#undef DEFINE_BLOB_SIZE\n+\n+public:\n+  static bool returns_to_call_stub(address return_pc) {\n+    return return_pc == _call_stub_return_address;\n+  }\n+\n@@ -44,1 +52,2 @@\n- private:\n+#define DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address STUB_FIELD_NAME(field_name) ;\n@@ -46,2 +55,2 @@\n-  static address _idiv_irem_entry;\n-  static address _partial_subtype_check;\n+#define DECLARE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name)\n@@ -49,1 +58,2 @@\n- public:\n+private:\n+  STUBGEN_ARCH_ENTRIES_DO(DECLARE_ARCH_ENTRY, DECLARE_ARCH_ENTRY_INIT)\n@@ -51,3 +61,2 @@\n-  static address idiv_irem_entry() { return _idiv_irem_entry; }\n-  static address partial_subtype_check() { return _partial_subtype_check; }\n-};\n+#undef DECLARE_ARCH_ENTRY_INIT\n+#undef DECLARE_ARCH_ENTRY\n@@ -55,3 +64,3 @@\n-  static bool returns_to_call_stub(address return_pc) {\n-    return return_pc == _call_stub_return_address;\n-  }\n+public:\n+\n+  \/\/ declare getters for arch-specific entries\n@@ -59,2 +68,2 @@\n-  static address _atomic_load_long_entry;\n-  static address _atomic_store_long_entry;\n+#define DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address getter_name() { return STUB_FIELD_NAME(field_name) ; }\n@@ -62,2 +71,2 @@\n-  static address atomic_load_long_entry()                  { return _atomic_load_long_entry; }\n-  static address atomic_store_long_entry()                 { return _atomic_store_long_entry; }\n+#define DEFINE_ARCH_ENTRY_GETTER_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name)\n@@ -65,0 +74,6 @@\n+  STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY_GETTER, DEFINE_ARCH_ENTRY_GETTER_INIT)\n+\n+#undef DEFINE_ARCH_ENTRY_GETTER_INIT\n+#undef DEFINE_ARCH_ENTRY_GETTER\n+\n+};\n","filename":"src\/hotspot\/cpu\/arm\/stubRoutines_arm.hpp","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights\n+ * reserved.  Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_PPC_STUBDECLARATIONS_HPP\n+#define CPU_PPC_STUBDECLARATIONS_HPP\n+\n+#define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n+  do_arch_blob(initial, 20000)                                          \\\n+\n+\n+#define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \\\n+                                           do_arch_blob,                \\\n+                                           do_arch_entry,               \\\n+                                           do_arch_entry_init)          \\\n+  do_arch_blob(continuation, 2000)                                      \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \\\n+                                       do_arch_blob,                    \\\n+                                       do_arch_entry,                   \\\n+                                       do_arch_entry_init)              \\\n+  do_arch_blob(compiler, 24000)                                         \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \\\n+                                    do_arch_blob,                       \\\n+                                    do_arch_entry,                      \\\n+                                    do_arch_entry_init)                 \\\n+  do_arch_blob(final, 24000)                                            \\\n+\n+\n+#endif \/\/ CPU_PPC_STUBDECLARATIONS_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/stubDeclarations_ppc.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -93,1 +93,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"call_stub\");\n+    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -396,1 +397,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"catch_exception\");\n+    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -451,1 +453,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"forward_exception\");\n+    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -521,87 +524,0 @@\n-\n-  \/\/ Support for void zero_words_aligned8(HeapWord* to, size_t count)\n-  \/\/\n-  \/\/ Arguments:\n-  \/\/   to:\n-  \/\/   count:\n-  \/\/\n-  \/\/ Destroys:\n-  \/\/\n-  address generate_zero_words_aligned8() {\n-    StubCodeMark mark(this, \"StubRoutines\", \"zero_words_aligned8\");\n-\n-    \/\/ Implemented as in ClearArray.\n-    address start = __ function_entry();\n-\n-    Register base_ptr_reg   = R3_ARG1; \/\/ tohw (needs to be 8b aligned)\n-    Register cnt_dwords_reg = R4_ARG2; \/\/ count (in dwords)\n-    Register tmp1_reg       = R5_ARG3;\n-    Register tmp2_reg       = R6_ARG4;\n-    Register zero_reg       = R7_ARG5;\n-\n-    \/\/ Procedure for large arrays (uses data cache block zero instruction).\n-    Label dwloop, fast, fastloop, restloop, lastdword, done;\n-    int cl_size = VM_Version::L1_data_cache_line_size();\n-    int cl_dwords = cl_size >> 3;\n-    int cl_dwordaddr_bits = exact_log2(cl_dwords);\n-    int min_dcbz = 2; \/\/ Needs to be positive, apply dcbz only to at least min_dcbz cache lines.\n-\n-    \/\/ Clear up to 128byte boundary if long enough, dword_cnt=(16-(base>>3))%16.\n-    __ dcbtst(base_ptr_reg);                    \/\/ Indicate write access to first cache line ...\n-    __ andi(tmp2_reg, cnt_dwords_reg, 1);       \/\/ to check if number of dwords is even.\n-    __ srdi_(tmp1_reg, cnt_dwords_reg, 1);      \/\/ number of double dwords\n-    __ load_const_optimized(zero_reg, 0L);      \/\/ Use as zero register.\n-\n-    __ cmpdi(CCR1, tmp2_reg, 0);                \/\/ cnt_dwords even?\n-    __ beq(CCR0, lastdword);                    \/\/ size <= 1\n-    __ mtctr(tmp1_reg);                         \/\/ Speculatively preload counter for rest loop (>0).\n-    __ cmpdi(CCR0, cnt_dwords_reg, (min_dcbz+1)*cl_dwords-1); \/\/ Big enough to ensure >=min_dcbz cache lines are included?\n-    __ neg(tmp1_reg, base_ptr_reg);             \/\/ bit 0..58: bogus, bit 57..60: (16-(base>>3))%16, bit 61..63: 000\n-\n-    __ blt(CCR0, restloop);                     \/\/ Too small. (<31=(2*cl_dwords)-1 is sufficient, but bigger performs better.)\n-    __ rldicl_(tmp1_reg, tmp1_reg, 64-3, 64-cl_dwordaddr_bits); \/\/ Extract number of dwords to 128byte boundary=(16-(base>>3))%16.\n-\n-    __ beq(CCR0, fast);                         \/\/ already 128byte aligned\n-    __ mtctr(tmp1_reg);                         \/\/ Set ctr to hit 128byte boundary (0<ctr<cnt).\n-    __ subf(cnt_dwords_reg, tmp1_reg, cnt_dwords_reg); \/\/ rest (>0 since size>=256-8)\n-\n-    \/\/ Clear in first cache line dword-by-dword if not already 128byte aligned.\n-    __ bind(dwloop);\n-      __ std(zero_reg, 0, base_ptr_reg);        \/\/ Clear 8byte aligned block.\n-      __ addi(base_ptr_reg, base_ptr_reg, 8);\n-    __ bdnz(dwloop);\n-\n-    \/\/ clear 128byte blocks\n-    __ bind(fast);\n-    __ srdi(tmp1_reg, cnt_dwords_reg, cl_dwordaddr_bits); \/\/ loop count for 128byte loop (>0 since size>=256-8)\n-    __ andi(tmp2_reg, cnt_dwords_reg, 1);       \/\/ to check if rest even\n-\n-    __ mtctr(tmp1_reg);                         \/\/ load counter\n-    __ cmpdi(CCR1, tmp2_reg, 0);                \/\/ rest even?\n-    __ rldicl_(tmp1_reg, cnt_dwords_reg, 63, 65-cl_dwordaddr_bits); \/\/ rest in double dwords\n-\n-    __ bind(fastloop);\n-      __ dcbz(base_ptr_reg);                    \/\/ Clear 128byte aligned block.\n-      __ addi(base_ptr_reg, base_ptr_reg, cl_size);\n-    __ bdnz(fastloop);\n-\n-    \/\/__ dcbtst(base_ptr_reg);                  \/\/ Indicate write access to last cache line.\n-    __ beq(CCR0, lastdword);                    \/\/ rest<=1\n-    __ mtctr(tmp1_reg);                         \/\/ load counter\n-\n-    \/\/ Clear rest.\n-    __ bind(restloop);\n-      __ std(zero_reg, 0, base_ptr_reg);        \/\/ Clear 8byte aligned block.\n-      __ std(zero_reg, 8, base_ptr_reg);        \/\/ Clear 8byte aligned block.\n-      __ addi(base_ptr_reg, base_ptr_reg, 16);\n-    __ bdnz(restloop);\n-\n-    __ bind(lastdword);\n-    __ beq(CCR1, done);\n-    __ std(zero_reg, 0, base_ptr_reg);\n-    __ bind(done);\n-    __ blr();                                   \/\/ return\n-\n-    return start;\n-  }\n-\n@@ -651,2 +567,34 @@\n-  address generate_fill(BasicType t, bool aligned, const char* name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_fill(StubGenStubId stub_id) {\n+    BasicType t;\n+    bool aligned;\n+\n+    switch (stub_id) {\n+    case jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = false;\n+      break;\n+    case jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = false;\n+      break;\n+    case jint_fill_id:\n+      t = T_INT;\n+      aligned = false;\n+      break;\n+    case arrayof_jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = true;\n+      break;\n+    case arrayof_jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = true;\n+      break;\n+    case arrayof_jint_fill_id:\n+      t = T_INT;\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -897,2 +845,14 @@\n-  address generate_disjoint_byte_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_disjoint_byte_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jbyte_disjoint_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jbyte_disjoint_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1076,2 +1036,14 @@\n-  address generate_conjoint_byte_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_conjoint_byte_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jbyte_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jbyte_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1165,2 +1137,14 @@\n-  address generate_disjoint_short_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_disjoint_short_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jshort_disjoint_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jshort_disjoint_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1348,2 +1332,14 @@\n-  address generate_conjoint_short_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_conjoint_short_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jshort_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jshort_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1519,2 +1515,14 @@\n-  address generate_disjoint_int_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_disjoint_int_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jint_disjoint_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jint_disjoint_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1666,2 +1674,14 @@\n-  address generate_conjoint_int_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_conjoint_int_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jint_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jint_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1797,2 +1817,14 @@\n-  address generate_disjoint_long_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_disjoint_long_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jlong_disjoint_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jlong_disjoint_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1923,2 +1955,14 @@\n-  address generate_conjoint_long_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_conjoint_long_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jlong_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jlong_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1952,2 +1996,23 @@\n-  address generate_conjoint_oop_copy(bool aligned, const char * name, bool dest_uninitialized) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_conjoint_oop_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case oop_arraycopy_id:\n+      aligned = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_arraycopy_id:\n+      aligned = true;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_arraycopy_uninit_id:\n+      aligned = false;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_arraycopy_uninit_id:\n+      aligned = true;\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -1955,0 +2020,1 @@\n+    StubCodeMark mark(this, stub_id);\n@@ -2001,2 +2067,25 @@\n-  address generate_disjoint_oop_copy(bool aligned, const char * name, bool dest_uninitialized) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_disjoint_oop_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case oop_disjoint_arraycopy_id:\n+      aligned = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_id:\n+      aligned = true;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_disjoint_arraycopy_uninit_id:\n+      aligned = false;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+      aligned = true;\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -2069,2 +2158,1 @@\n-  address generate_checkcast_copy(const char *name, bool dest_uninitialized) {\n-\n+  address generate_checkcast_copy(StubGenStubId stub_id) {\n@@ -2085,0 +2173,11 @@\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case checkcast_arraycopy_id:\n+      dest_uninitialized = false;\n+      break;\n+    case checkcast_arraycopy_uninit_id:\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -2086,1 +2185,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2206,2 +2305,1 @@\n-  address generate_unsafe_copy(const char* name,\n-                               address byte_copy_entry,\n+  address generate_unsafe_copy(address byte_copy_entry,\n@@ -2220,1 +2318,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2303,2 +2402,1 @@\n-  address generate_generic_copy(const char *name,\n-                                address entry_jbyte_arraycopy,\n+  address generate_generic_copy(address entry_jbyte_arraycopy,\n@@ -2327,1 +2425,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2529,1 +2628,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_encryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2736,1 +2836,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_decryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2973,1 +3074,1 @@\n-  address generate_sha256_implCompress(bool multi_block, const char *name) {\n+  address generate_sha256_implCompress(StubGenStubId stub_id) {\n@@ -2975,1 +3076,12 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    bool multi_block;\n+    switch (stub_id) {\n+    case sha256_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case sha256_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    StubCodeMark mark(this, stub_id);\n@@ -2984,1 +3096,1 @@\n-  address generate_sha512_implCompress(bool multi_block, const char *name) {\n+  address generate_sha512_implCompress(StubGenStubId stub_id) {\n@@ -2986,1 +3098,12 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    bool multi_block;\n+    switch (stub_id) {\n+    case sha512_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case sha512_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    StubCodeMark mark(this, stub_id);\n@@ -2997,1 +3120,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"_data_cache_writeback\");\n+    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3010,2 +3134,2 @@\n-\n-    StubCodeMark mark(this, \"StubRoutines\", \"_data_cache_writeback_sync\");\n+    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_sync_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3031,6 +3155,6 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy       = generate_disjoint_byte_copy(false, \"jbyte_disjoint_arraycopy\");\n-    StubRoutines::_jshort_disjoint_arraycopy      = generate_disjoint_short_copy(false, \"jshort_disjoint_arraycopy\");\n-    StubRoutines::_jint_disjoint_arraycopy        = generate_disjoint_int_copy(false, \"jint_disjoint_arraycopy\");\n-    StubRoutines::_jlong_disjoint_arraycopy       = generate_disjoint_long_copy(false, \"jlong_disjoint_arraycopy\");\n-    StubRoutines::_oop_disjoint_arraycopy         = generate_disjoint_oop_copy(false, \"oop_disjoint_arraycopy\", false);\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_oop_copy(false, \"oop_disjoint_arraycopy_uninit\", true);\n+    StubRoutines::_jbyte_disjoint_arraycopy       = generate_disjoint_byte_copy(StubGenStubId::jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_jshort_disjoint_arraycopy      = generate_disjoint_short_copy(StubGenStubId::jshort_disjoint_arraycopy_id);\n+    StubRoutines::_jint_disjoint_arraycopy        = generate_disjoint_int_copy(StubGenStubId::jint_disjoint_arraycopy_id);\n+    StubRoutines::_jlong_disjoint_arraycopy       = generate_disjoint_long_copy(StubGenStubId::jlong_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy         = generate_disjoint_oop_copy(StubGenStubId::oop_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id);\n@@ -3039,6 +3163,6 @@\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_byte_copy(true, \"arrayof_jbyte_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_short_copy(true, \"arrayof_jshort_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_int_copy(true, \"arrayof_jint_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_long_copy(true, \"arrayof_jlong_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy(true, \"arrayof_oop_disjoint_arraycopy\", false);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy(true, \"oop_disjoint_arraycopy_uninit\", true);\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_byte_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_short_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_int_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_long_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id);\n@@ -3047,6 +3171,6 @@\n-    StubRoutines::_jbyte_arraycopy      = generate_conjoint_byte_copy(false, \"jbyte_arraycopy\");\n-    StubRoutines::_jshort_arraycopy     = generate_conjoint_short_copy(false, \"jshort_arraycopy\");\n-    StubRoutines::_jint_arraycopy       = generate_conjoint_int_copy(false, \"jint_arraycopy\");\n-    StubRoutines::_jlong_arraycopy      = generate_conjoint_long_copy(false, \"jlong_arraycopy\");\n-    StubRoutines::_oop_arraycopy        = generate_conjoint_oop_copy(false, \"oop_arraycopy\", false);\n-    StubRoutines::_oop_arraycopy_uninit = generate_conjoint_oop_copy(false, \"oop_arraycopy_uninit\", true);\n+    StubRoutines::_jbyte_arraycopy      = generate_conjoint_byte_copy(StubGenStubId::jbyte_arraycopy_id);\n+    StubRoutines::_jshort_arraycopy     = generate_conjoint_short_copy(StubGenStubId::jshort_arraycopy_id);\n+    StubRoutines::_jint_arraycopy       = generate_conjoint_int_copy(StubGenStubId::jint_arraycopy_id);\n+    StubRoutines::_jlong_arraycopy      = generate_conjoint_long_copy(StubGenStubId::jlong_arraycopy_id);\n+    StubRoutines::_oop_arraycopy        = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_id);\n+    StubRoutines::_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_uninit_id);\n@@ -3055,6 +3179,6 @@\n-    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_byte_copy(true, \"arrayof_jbyte_arraycopy\");\n-    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_short_copy(true, \"arrayof_jshort_arraycopy\");\n-    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_int_copy(true, \"arrayof_jint_arraycopy\");\n-    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_long_copy(true, \"arrayof_jlong_arraycopy\");\n-    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy(true, \"arrayof_oop_arraycopy\", false);\n-    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy(true, \"arrayof_oop_arraycopy\", true);\n+    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_byte_copy(StubGenStubId::arrayof_jbyte_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_short_copy(StubGenStubId::arrayof_jshort_arraycopy_id);\n+    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_int_copy(StubGenStubId::arrayof_jint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_long_copy(StubGenStubId::arrayof_jlong_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_id);\n@@ -3063,2 +3187,2 @@\n-    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(\"checkcast_arraycopy\", false);\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", true);\n+    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id);\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id);\n@@ -3066,2 +3190,1 @@\n-    StubRoutines::_unsafe_arraycopy  = generate_unsafe_copy(\"unsafe_arraycopy\",\n-                                                            STUB_ENTRY(jbyte_arraycopy()),\n+    StubRoutines::_unsafe_arraycopy  = generate_unsafe_copy(STUB_ENTRY(jbyte_arraycopy()),\n@@ -3071,2 +3194,1 @@\n-    StubRoutines::_generic_arraycopy = generate_generic_copy(\"generic_arraycopy\",\n-                                                             STUB_ENTRY(jbyte_arraycopy()),\n+    StubRoutines::_generic_arraycopy = generate_generic_copy(STUB_ENTRY(jbyte_arraycopy()),\n@@ -3083,6 +3205,6 @@\n-      StubRoutines::_jbyte_fill          = generate_fill(T_BYTE,  false, \"jbyte_fill\");\n-      StubRoutines::_jshort_fill         = generate_fill(T_SHORT, false, \"jshort_fill\");\n-      StubRoutines::_jint_fill           = generate_fill(T_INT,   false, \"jint_fill\");\n-      StubRoutines::_arrayof_jbyte_fill  = generate_fill(T_BYTE,  true, \"arrayof_jbyte_fill\");\n-      StubRoutines::_arrayof_jshort_fill = generate_fill(T_SHORT, true, \"arrayof_jshort_fill\");\n-      StubRoutines::_arrayof_jint_fill   = generate_fill(T_INT,   true, \"arrayof_jint_fill\");\n+      StubRoutines::_jbyte_fill          = generate_fill(StubGenStubId::jbyte_fill_id);\n+      StubRoutines::_jshort_fill         = generate_fill(StubGenStubId::jshort_fill_id);\n+      StubRoutines::_jint_fill           = generate_fill(StubGenStubId::jint_fill_id);\n+      StubRoutines::_arrayof_jbyte_fill  = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n+      StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n+      StubRoutines::_arrayof_jint_fill   = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n@@ -3106,1 +3228,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"multiplyToLen\");\n+    StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3182,1 +3305,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"mulAdd\");\n+    StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3212,1 +3336,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"squareToLen\");\n+    StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3445,1 +3570,12 @@\n-  address generate_CRC32_updateBytes(bool is_crc32c) {\n+  address generate_CRC32_updateBytes(StubGenStubId stub_id) {\n+    bool is_crc32c;\n+    switch (stub_id) {\n+    case updateBytesCRC32_id:\n+      is_crc32c = false;\n+      break;\n+    case updateBytesCRC32C_id:\n+      is_crc32c = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -3447,1 +3583,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", is_crc32c ? \"CRC32C_updateBytes\" : \"CRC32_updateBytes\");\n+    StubCodeMark mark(this, stub_id);\n@@ -3474,1 +3610,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3571,1 +3708,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"base64_decodeBlock\");\n+    StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4159,1 +4297,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"base64_encodeBlock\");\n+    StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4448,2 +4587,3 @@\n-address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+void generate_lookup_secondary_supers_table_stub() {\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4451,1 +4591,0 @@\n-    address start = __ pc();\n@@ -4461,4 +4600,7 @@\n-    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n-                                     r_array_base, r_array_length, r_array_index,\n-                                     r_bitmap, result, super_klass_index);\n-    __ blr();\n+    for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+      __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n+                                       r_array_base, r_array_length, r_array_index,\n+                                       r_bitmap, result, slot);\n+      __ blr();\n+    }\n@@ -4466,1 +4608,0 @@\n-    return start;\n@@ -4471,1 +4612,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4488,1 +4630,1 @@\n-  address generate_cont_thaw(const char* label, Continuation::thaw_kind kind) {\n+  address generate_cont_thaw(StubGenStubId stub_id) {\n@@ -4491,2 +4633,3 @@\n-    bool return_barrier = Continuation::is_thaw_return_barrier(kind);\n-    bool return_barrier_exception = Continuation::is_thaw_return_barrier_exception(kind);\n+    Continuation::thaw_kind kind;\n+    bool return_barrier;\n+    bool return_barrier_exception;\n@@ -4494,1 +4637,20 @@\n-    StubCodeMark mark(this, \"StubRoutines\", label);\n+    switch (stub_id) {\n+    case cont_thaw_id:\n+      kind = Continuation::thaw_top;\n+      return_barrier = false;\n+      return_barrier_exception = false;\n+      break;\n+    case cont_returnBarrier_id:\n+      kind = Continuation::thaw_return_barrier;\n+      return_barrier = true;\n+      return_barrier_exception = false;\n+      break;\n+    case cont_returnBarrierExc_id:\n+      kind = Continuation::thaw_return_barrier_exception;\n+      return_barrier = true;\n+      return_barrier_exception = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    StubCodeMark mark(this, stub_id);\n@@ -4583,1 +4745,1 @@\n-    return generate_cont_thaw(\"Cont thaw\", Continuation::thaw_top);\n+    return generate_cont_thaw(StubGenStubId::cont_thaw_id);\n@@ -4589,1 +4751,1 @@\n-    return generate_cont_thaw(\"Cont thaw return barrier\", Continuation::thaw_return_barrier);\n+    return generate_cont_thaw(StubGenStubId::cont_returnBarrier_id);\n@@ -4593,1 +4755,1 @@\n-    return generate_cont_thaw(\"Cont thaw return barrier exception\", Continuation::thaw_return_barrier_exception);\n+    return generate_cont_thaw(StubGenStubId::cont_returnBarrierExc_id);\n@@ -4598,1 +4760,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\",\"Continuation preempt stub\");\n+    StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4633,1 +4796,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+    StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4651,1 +4815,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+    StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4691,1 +4856,1 @@\n-      StubRoutines::_updateBytesCRC32 = generate_CRC32_updateBytes(false);\n+      StubRoutines::_updateBytesCRC32 = generate_CRC32_updateBytes(StubGenStubId::updateBytesCRC32_id);\n@@ -4697,1 +4862,1 @@\n-      StubRoutines::_updateBytesCRC32C = generate_CRC32_updateBytes(true);\n+      StubRoutines::_updateBytesCRC32C = generate_CRC32_updateBytes(StubGenStubId::updateBytesCRC32C_id);\n@@ -4733,4 +4898,1 @@\n-        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n-            = generate_lookup_secondary_supers_table_stub(slot);\n-        }\n+        generate_lookup_secondary_supers_table_stub();\n@@ -4779,2 +4941,2 @@\n-      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(false, \"sha256_implCompress\");\n-      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(true,  \"sha256_implCompressMB\");\n+      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n@@ -4783,2 +4945,2 @@\n-      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(false, \"sha512_implCompress\");\n-      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(true, \"sha512_implCompressMB\");\n+      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n@@ -4798,3 +4960,3 @@\n-  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    switch(kind) {\n-    case Initial_stubs:\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+    switch(blob_id) {\n+    case initial_id:\n@@ -4803,1 +4965,1 @@\n-     case Continuation_stubs:\n+     case continuation_id:\n@@ -4806,1 +4968,1 @@\n-    case Compiler_stubs:\n+    case compiler_id:\n@@ -4809,1 +4971,1 @@\n-    case Final_stubs:\n+    case final_id:\n@@ -4813,1 +4975,1 @@\n-      fatal(\"unexpected stubs kind: %d\", kind);\n+      fatal(\"unexpected blob id: %d\", blob_id);\n@@ -4819,2 +4981,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n@@ -4822,0 +4984,1 @@\n+\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":375,"deletions":212,"binary":false,"changes":587,"status":"modified"},{"patch":"@@ -35,0 +35,5 @@\n+\/\/ emit enum used to size per-blob code buffers\n+\n+#define DEFINE_BLOB_SIZE(blob_name, size) \\\n+  _ ## blob_name ## _code_size = size,\n+\n@@ -36,5 +41,1 @@\n-  \/\/ simply increase sizes if too small (assembler will crash if too small)\n-  _initial_stubs_code_size      = 20000,\n-  _continuation_stubs_code_size =  2000,\n-  _compiler_stubs_code_size     = 24000,\n-  _final_stubs_code_size        = 24000\n+  STUBGEN_ARCH_BLOBS_DO(DEFINE_BLOB_SIZE)\n@@ -43,0 +44,2 @@\n+#undef DEFINE_BLOB_SIZE\n+\n","filename":"src\/hotspot\/cpu\/ppc\/stubRoutines_ppc.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights\n+ * reserved.  Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_STUBDECLARATIONS_HPP\n+#define CPU_RISCV_STUBDECLARATIONS_HPP\n+\n+#define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n+  do_arch_blob(initial, 10000)                                          \\\n+\n+\n+#define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \\\n+                                           do_arch_blob,                \\\n+                                           do_arch_entry,               \\\n+                                           do_arch_entry_init)          \\\n+  do_arch_blob(continuation, 2000)                                      \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \\\n+                                       do_arch_blob,                    \\\n+                                       do_arch_entry,                   \\\n+                                       do_arch_entry_init)              \\\n+  do_arch_blob(compiler, 45000)                                         \\\n+  do_stub(compiler, compare_long_string_LL)                             \\\n+  do_arch_entry(riscv, compiler, compare_long_string_LL,                \\\n+                compare_long_string_LL, compare_long_string_LL)         \\\n+  do_stub(compiler, compare_long_string_UU)                             \\\n+  do_arch_entry(riscv, compiler, compare_long_string_UU,                \\\n+                compare_long_string_UU, compare_long_string_UU)         \\\n+  do_stub(compiler, compare_long_string_LU)                             \\\n+  do_arch_entry(riscv, compiler, compare_long_string_LU,                \\\n+                compare_long_string_LU, compare_long_string_LU)         \\\n+  do_stub(compiler, compare_long_string_UL)                             \\\n+  do_arch_entry(riscv, compiler, compare_long_string_UL,                \\\n+                compare_long_string_UL, compare_long_string_UL)         \\\n+  do_stub(compiler, string_indexof_linear_ll)                           \\\n+  do_arch_entry(riscv, compiler, string_indexof_linear_ll,              \\\n+                string_indexof_linear_ll, string_indexof_linear_ll)     \\\n+  do_stub(compiler, string_indexof_linear_uu)                           \\\n+  do_arch_entry(riscv, compiler, string_indexof_linear_uu,              \\\n+                string_indexof_linear_uu, string_indexof_linear_uu)     \\\n+  do_stub(compiler, string_indexof_linear_ul)                           \\\n+  do_arch_entry(riscv, compiler, string_indexof_linear_ul,              \\\n+                string_indexof_linear_ul, string_indexof_linear_ul)     \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \\\n+                                    do_arch_blob,                       \\\n+                                    do_arch_entry,                      \\\n+                                    do_arch_entry_init)                 \\\n+  do_arch_blob(final, 20000 ZGC_ONLY(+10000))                           \\\n+  do_stub(final, copy_byte_f)                                           \\\n+  do_arch_entry(riscv, final, copy_byte_f, copy_byte_f,                 \\\n+                copy_byte_f)                                            \\\n+  do_stub(final, copy_byte_b)                                           \\\n+  do_arch_entry(riscv, final, copy_byte_b, copy_byte_b,                 \\\n+                copy_byte_b)                                            \\\n+  do_stub(final, zero_blocks)                                           \\\n+  do_arch_entry(riscv, final, zero_blocks, zero_blocks,                 \\\n+                zero_blocks)                                            \\\n+\n+\n+#endif \/\/ CPU_RISCV_STUBDECLARATIONS_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/stubDeclarations_riscv.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -211,1 +211,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"call_stub\");\n+    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -479,1 +480,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"catch_exception\");\n+    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -531,1 +533,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"forward exception\");\n+    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -617,1 +620,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"verify_oop\");\n+    StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -678,1 +682,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"zero_blocks\");\n+    StubGenStubId stub_id = StubGenStubId::zero_blocks_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -730,2 +735,16 @@\n-  void generate_copy_longs(Label &start, Register s, Register d, Register count,\n-                           copy_direction direction) {\n+  void generate_copy_longs(StubGenStubId stub_id, Label &start,\n+                           Register s, Register d, Register count) {\n+    BasicType type;\n+    copy_direction direction;\n+    switch (stub_id) {\n+    case copy_byte_f_id:\n+      direction = copy_forwards;\n+      type = T_BYTE;\n+      break;\n+    case copy_byte_b_id:\n+      direction = copy_backwards;\n+      type = T_BYTE;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -745,7 +764,1 @@\n-    const char* stub_name = nullptr;\n-    if (direction == copy_forwards) {\n-      stub_name = \"forward_copy_longs\";\n-    } else {\n-      stub_name = \"backward_copy_longs\";\n-    }\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1086,4 +1099,5 @@\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   is_oop  - true => oop array, so generate store check code\n-  \/\/   name    - stub name string\n+  \/\/   stub_id - is used to name the stub and identify all details of\n+  \/\/             how to perform the copy.\n+  \/\/\n+  \/\/   entry - is assigned to the stub's post push entry point unless\n+  \/\/           it is null\n@@ -1100,3 +1114,3 @@\n-  \/\/ Side Effects:\n-  \/\/   disjoint_int_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_int_oop_copy().\n+  \/\/ Side Effects: entry is set to the (post push) entry point so it\n+  \/\/               can be used by the corresponding conjoint copy\n+  \/\/               method\n@@ -1104,2 +1118,82 @@\n-  address generate_disjoint_copy(size_t size, bool aligned, bool is_oop, address* entry,\n-                                 const char* name, bool dest_uninitialized = false) {\n+  address generate_disjoint_copy(StubGenStubId stub_id, address* entry) {\n+    size_t size;\n+    bool aligned;\n+    bool is_oop;\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case jbyte_disjoint_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jbyte_disjoint_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jshort_disjoint_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jshort_disjoint_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jint_disjoint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jint_disjoint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jlong_disjoint_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case arrayof_jlong_disjoint_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case arrayof_jlong_disjoint_arraycopy_id:\n+      size = sizeof(jlong);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_disjoint_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_disjoint_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+    }\n+\n@@ -1109,1 +1203,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1158,4 +1252,9 @@\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   is_oop  - true => oop array, so generate store check code\n-  \/\/   name    - stub name string\n+  \/\/   stub_id - is used to name the stub and identify all details of\n+  \/\/             how to perform the copy.\n+  \/\/\n+  \/\/   nooverlap_target - identifes the (post push) entry for the\n+  \/\/             corresponding disjoint copy routine which can be\n+  \/\/             jumped to if the ranges do not actually overlap\n+  \/\/\n+  \/\/   entry - is assigned to the stub's post push entry point unless\n+  \/\/           it is null\n@@ -1172,3 +1271,5 @@\n-  address generate_conjoint_copy(size_t size, bool aligned, bool is_oop, address nooverlap_target,\n-                                 address* entry, const char* name,\n-                                 bool dest_uninitialized = false) {\n+  \/\/ Side Effects:\n+  \/\/   entry is set to the no-overlap entry point so it can be used by\n+  \/\/   some other conjoint copy method\n+  \/\/\n+  address generate_conjoint_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n@@ -1177,1 +1278,81 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    int size;\n+    bool aligned;\n+    bool is_oop;\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case jbyte_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jbyte_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jshort_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jshort_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jlong_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case arrayof_jlong_disjoint_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case arrayof_jlong_arraycopy_id:\n+      size = sizeof(jlong);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1231,221 +1412,0 @@\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n-  \/\/ we let the hardware handle it.  The one to eight bytes within words,\n-  \/\/ dwords or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_byte_copy_entry is set to the no-overlap entry point  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n-  \/\/ we let the hardware handle it.  The one to eight bytes within words,\n-  \/\/ dwords or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_byte_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_byte_copy().\n-  \/\/\n-  address generate_disjoint_byte_copy(bool aligned, address* entry, const char* name) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jbyte), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n-  \/\/ we let the hardware handle it.  The one to eight bytes within words,\n-  \/\/ dwords or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  address generate_conjoint_byte_copy(bool aligned, address nooverlap_target,\n-                                      address* entry, const char* name) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jbyte), aligned, not_oop, nooverlap_target, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4- or 2-byte boundaries, we\n-  \/\/ let the hardware handle it.  The two or four words within dwords\n-  \/\/ or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_short_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_short_copy().\n-  \/\/\n-  address generate_disjoint_short_copy(bool aligned,\n-                                       address* entry, const char* name) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jshort), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4- or 2-byte boundaries, we\n-  \/\/ let the hardware handle it.  The two or four words within dwords\n-  \/\/ or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  address generate_conjoint_short_copy(bool aligned, address nooverlap_target,\n-                                       address* entry, const char* name) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jshort), aligned, not_oop, nooverlap_target, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-byte boundaries, we let\n-  \/\/ the hardware handle it.  The two dwords within qwords that span\n-  \/\/ cache line boundaries will still be loaded and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_int_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_int_oop_copy().\n-  \/\/\n-  address generate_disjoint_int_copy(bool aligned, address* entry,\n-                                     const char* name, bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jint), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-byte boundaries, we let\n-  \/\/ the hardware handle it.  The two dwords within qwords that span\n-  \/\/ cache line boundaries will still be loaded and stored atomically.\n-  \/\/\n-  address generate_conjoint_int_copy(bool aligned, address nooverlap_target,\n-                                     address* entry, const char* name,\n-                                     bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jint), aligned, not_oop, nooverlap_target, entry, name);\n-  }\n-\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_oop_copy_entry or disjoint_long_copy_entry is set to the\n-  \/\/   no-overlap entry point used by generate_conjoint_long_oop_copy().\n-  \/\/\n-  address generate_disjoint_long_copy(bool aligned, address* entry,\n-                                      const char* name, bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jlong), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  address generate_conjoint_long_copy(bool aligned,\n-                                      address nooverlap_target, address* entry,\n-                                      const char* name, bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jlong), aligned, not_oop, nooverlap_target, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_oop_copy_entry or disjoint_long_copy_entry is set to the\n-  \/\/   no-overlap entry point used by generate_conjoint_long_oop_copy().\n-  \/\/\n-  address generate_disjoint_oop_copy(bool aligned, address* entry,\n-                                     const char* name, bool dest_uninitialized) {\n-    const bool is_oop = true;\n-    const size_t size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n-    return generate_disjoint_copy(size, aligned, is_oop, entry, name, dest_uninitialized);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  address generate_conjoint_oop_copy(bool aligned,\n-                                     address nooverlap_target, address* entry,\n-                                     const char* name, bool dest_uninitialized) {\n-    const bool is_oop = true;\n-    const size_t size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n-    return generate_conjoint_copy(size, aligned, is_oop, nooverlap_target, entry,\n-                                  name, dest_uninitialized);\n-  }\n-\n@@ -1485,2 +1445,13 @@\n-  address generate_checkcast_copy(const char* name, address* entry,\n-                                  bool dest_uninitialized = false) {\n+  address generate_checkcast_copy(StubGenStubId stub_id, address* entry) {\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case checkcast_arraycopy_id:\n+      dest_uninitialized = false;\n+      break;\n+    case checkcast_arraycopy_uninit_id:\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -1519,1 +1490,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1665,2 +1636,1 @@\n-  address generate_unsafe_copy(const char* name,\n-                               address byte_copy_entry,\n+  address generate_unsafe_copy(address byte_copy_entry,\n@@ -1676,1 +1646,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1721,2 +1692,1 @@\n-  address generate_generic_copy(const char* name,\n-                                address byte_copy_entry, address short_copy_entry,\n+  address generate_generic_copy(address byte_copy_entry, address short_copy_entry,\n@@ -1743,1 +1713,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1999,1 +1970,33 @@\n-  address generate_fill(BasicType t, bool aligned, const char* name) {\n+  address generate_fill(StubGenStubId stub_id) {\n+    BasicType t;\n+    bool aligned;\n+\n+    switch (stub_id) {\n+    case jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = false;\n+      break;\n+    case jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = false;\n+      break;\n+    case jint_fill_id:\n+      t = T_INT;\n+      aligned = false;\n+      break;\n+    case arrayof_jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = true;\n+      break;\n+    case arrayof_jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = true;\n+      break;\n+    case arrayof_jint_fill_id:\n+      t = T_INT;\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    };\n+\n@@ -2001,1 +2004,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2173,2 +2176,2 @@\n-    generate_copy_longs(copy_f, c_rarg0, c_rarg1, t1, copy_forwards);\n-    generate_copy_longs(copy_b, c_rarg0, c_rarg1, t1, copy_backwards);\n+    generate_copy_longs(StubGenStubId::copy_byte_f_id, copy_f, c_rarg0, c_rarg1, t1);\n+    generate_copy_longs(StubGenStubId::copy_byte_b_id, copy_b, c_rarg0, c_rarg1, t1);\n@@ -2180,9 +2183,4 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy          = generate_disjoint_byte_copy(false, &entry,\n-                                                                                   \"jbyte_disjoint_arraycopy\");\n-    StubRoutines::_jbyte_arraycopy                   = generate_conjoint_byte_copy(false, entry,\n-                                                                                   &entry_jbyte_arraycopy,\n-                                                                                   \"jbyte_arraycopy\");\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_disjoint_byte_copy(true, &entry,\n-                                                                                   \"arrayof_jbyte_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jbyte_arraycopy           = generate_conjoint_byte_copy(true, entry, nullptr,\n-                                                                                   \"arrayof_jbyte_arraycopy\");\n+    StubRoutines::_jbyte_disjoint_arraycopy          = generate_disjoint_copy(StubGenStubId::jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jbyte_arraycopy                   = generate_conjoint_copy(StubGenStubId::jbyte_arraycopy_id, entry, &entry_jbyte_arraycopy);\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_disjoint_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jbyte_arraycopy           = generate_conjoint_copy(StubGenStubId::arrayof_jbyte_arraycopy_id, entry, nullptr);\n@@ -2192,9 +2190,4 @@\n-    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_short_copy(false, &entry,\n-                                                                                    \"jshort_disjoint_arraycopy\");\n-    StubRoutines::_jshort_arraycopy                  = generate_conjoint_short_copy(false, entry,\n-                                                                                    &entry_jshort_arraycopy,\n-                                                                                    \"jshort_arraycopy\");\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_short_copy(true, &entry,\n-                                                                                    \"arrayof_jshort_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_short_copy(true, entry, nullptr,\n-                                                                                    \"arrayof_jshort_arraycopy\");\n+    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubGenStubId::jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jshort_arraycopy_id, entry, nullptr);\n@@ -2204,4 +2197,2 @@\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_disjoint_int_copy(true, &entry,\n-                                                                                  \"arrayof_jint_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jint_arraycopy            = generate_conjoint_int_copy(true, entry, &entry_jint_arraycopy,\n-                                                                                  \"arrayof_jint_arraycopy\");\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_disjoint_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jint_arraycopy            = generate_conjoint_copy(StubGenStubId::arrayof_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2210,5 +2201,2 @@\n-    StubRoutines::_jint_disjoint_arraycopy           = generate_disjoint_int_copy(false, &entry,\n-                                                                                  \"jint_disjoint_arraycopy\");\n-    StubRoutines::_jint_arraycopy                    = generate_conjoint_int_copy(false, entry,\n-                                                                                  &entry_jint_arraycopy,\n-                                                                                  \"jint_arraycopy\");\n+    StubRoutines::_jint_disjoint_arraycopy           = generate_disjoint_copy(StubGenStubId::jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubGenStubId::jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2218,6 +2206,4 @@\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy  = generate_disjoint_long_copy(true, &entry,\n-                                                                                   \"arrayof_jlong_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jlong_arraycopy           = generate_conjoint_long_copy(true, entry, &entry_jlong_arraycopy,\n-                                                                                   \"arrayof_jlong_arraycopy\");\n-    StubRoutines::_jlong_disjoint_arraycopy          = StubRoutines::_arrayof_jlong_disjoint_arraycopy;\n-    StubRoutines::_jlong_arraycopy                   = StubRoutines::_arrayof_jlong_arraycopy;\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n+    StubRoutines::_jlong_disjoint_arraycopy         = StubRoutines::_arrayof_jlong_disjoint_arraycopy;\n+    StubRoutines::_jlong_arraycopy                  = StubRoutines::_arrayof_jlong_arraycopy;\n@@ -2226,19 +2212,9 @@\n-    {\n-      \/\/ With compressed oops we need unaligned versions; notice that\n-      \/\/ we overwrite entry_oop_arraycopy.\n-      bool aligned = !UseCompressedOops;\n-\n-      StubRoutines::_arrayof_oop_disjoint_arraycopy\n-        = generate_disjoint_oop_copy(aligned, &entry, \"arrayof_oop_disjoint_arraycopy\",\n-                                     \/*dest_uninitialized*\/false);\n-      StubRoutines::_arrayof_oop_arraycopy\n-        = generate_conjoint_oop_copy(aligned, entry, &entry_oop_arraycopy, \"arrayof_oop_arraycopy\",\n-                                     \/*dest_uninitialized*\/false);\n-      \/\/ Aligned versions without pre-barriers\n-      StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit\n-        = generate_disjoint_oop_copy(aligned, &entry, \"arrayof_oop_disjoint_arraycopy_uninit\",\n-                                     \/*dest_uninitialized*\/true);\n-      StubRoutines::_arrayof_oop_arraycopy_uninit\n-        = generate_conjoint_oop_copy(aligned, entry, nullptr, \"arrayof_oop_arraycopy_uninit\",\n-                                     \/*dest_uninitialized*\/true);\n-    }\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy\n+      = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_oop_arraycopy\n+      = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+    \/\/ Aligned versions without pre-barriers\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit\n+      = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_uninit_id, &entry);\n+    StubRoutines::_arrayof_oop_arraycopy_uninit\n+      = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_uninit_id, entry, nullptr);\n@@ -2251,3 +2227,2 @@\n-    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(\"checkcast_arraycopy\", &entry_checkcast_arraycopy);\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", nullptr,\n-                                                                        \/*dest_uninitialized*\/true);\n+    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id, nullptr);\n@@ -2256,2 +2231,1 @@\n-    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(\"unsafe_arraycopy\",\n-                                                              entry_jbyte_arraycopy,\n+    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(entry_jbyte_arraycopy,\n@@ -2262,2 +2236,1 @@\n-    StubRoutines::_generic_arraycopy   = generate_generic_copy(\"generic_arraycopy\",\n-                                                               entry_jbyte_arraycopy,\n+    StubRoutines::_generic_arraycopy   = generate_generic_copy(entry_jbyte_arraycopy,\n@@ -2270,6 +2243,6 @@\n-    StubRoutines::_jbyte_fill = generate_fill(T_BYTE, false, \"jbyte_fill\");\n-    StubRoutines::_jshort_fill = generate_fill(T_SHORT, false, \"jshort_fill\");\n-    StubRoutines::_jint_fill = generate_fill(T_INT, false, \"jint_fill\");\n-    StubRoutines::_arrayof_jbyte_fill = generate_fill(T_BYTE, true, \"arrayof_jbyte_fill\");\n-    StubRoutines::_arrayof_jshort_fill = generate_fill(T_SHORT, true, \"arrayof_jshort_fill\");\n-    StubRoutines::_arrayof_jint_fill = generate_fill(T_INT, true, \"arrayof_jint_fill\");\n+    StubRoutines::_jbyte_fill = generate_fill(StubGenStubId::jbyte_fill_id);\n+    StubRoutines::_jshort_fill = generate_fill(StubGenStubId::jshort_fill_id);\n+    StubRoutines::_jint_fill = generate_fill(StubGenStubId::jint_fill_id);\n+    StubRoutines::_arrayof_jbyte_fill = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n+    StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n+    StubRoutines::_arrayof_jint_fill = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n@@ -2311,1 +2284,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_encryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2389,1 +2363,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_decryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2489,1 +2464,12 @@\n-  address generate_compare_long_string_different_encoding(bool isLU) {\n+  address generate_compare_long_string_different_encoding(StubGenStubId stub_id) {\n+    bool isLU;\n+    switch (stub_id) {\n+    case compare_long_string_LU_id:\n+      isLU = true;\n+      break;\n+    case compare_long_string_UL_id:\n+      isLU = false;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    };\n@@ -2491,1 +2477,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", isLU ? \"compare_long_string_different_encoding LU\" : \"compare_long_string_different_encoding UL\");\n+    StubCodeMark mark(this, stub_id);\n@@ -2585,1 +2571,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2655,1 +2642,12 @@\n-  address generate_compare_long_string_same_encoding(bool isLL) {\n+  address generate_compare_long_string_same_encoding(StubGenStubId stub_id) {\n+    bool isLL;\n+    switch (stub_id) {\n+    case compare_long_string_LL_id:\n+      isLL = true;\n+      break;\n+    case compare_long_string_UU_id:\n+      isLL = false;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    };\n@@ -2657,2 +2655,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", isLL ?\n-                      \"compare_long_string_same_encoding LL\" : \"compare_long_string_same_encoding UU\");\n+    StubCodeMark mark(this, stub_id);\n@@ -2744,4 +2741,4 @@\n-    StubRoutines::riscv::_compare_long_string_LL = generate_compare_long_string_same_encoding(true);\n-    StubRoutines::riscv::_compare_long_string_UU = generate_compare_long_string_same_encoding(false);\n-    StubRoutines::riscv::_compare_long_string_LU = generate_compare_long_string_different_encoding(true);\n-    StubRoutines::riscv::_compare_long_string_UL = generate_compare_long_string_different_encoding(false);\n+    StubRoutines::riscv::_compare_long_string_LL = generate_compare_long_string_same_encoding(StubGenStubId::compare_long_string_LL_id);\n+    StubRoutines::riscv::_compare_long_string_UU = generate_compare_long_string_same_encoding(StubGenStubId::compare_long_string_UU_id);\n+    StubRoutines::riscv::_compare_long_string_LU = generate_compare_long_string_different_encoding(StubGenStubId::compare_long_string_LU_id);\n+    StubRoutines::riscv::_compare_long_string_UL = generate_compare_long_string_different_encoding(StubGenStubId::compare_long_string_UL_id);\n@@ -2755,1 +2752,1 @@\n-  address generate_string_indexof_linear(bool needle_isL, bool haystack_isL)\n+  address generate_string_indexof_linear(StubGenStubId stub_id)\n@@ -2757,3 +2754,19 @@\n-    const char* stubName = needle_isL\n-           ? (haystack_isL ? \"indexof_linear_ll\" : \"indexof_linear_ul\")\n-           : \"indexof_linear_uu\";\n+    bool needle_isL;\n+    bool haystack_isL;\n+    switch (stub_id) {\n+    case string_indexof_linear_ll_id:\n+      needle_isL = true;\n+      haystack_isL = true;\n+      break;\n+    case string_indexof_linear_ul_id:\n+      needle_isL = true;\n+      haystack_isL = false;\n+      break;\n+    case string_indexof_linear_uu_id:\n+      needle_isL = false;\n+      haystack_isL = false;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    };\n+\n@@ -2761,1 +2774,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stubName);\n+    StubCodeMark mark(this, stub_id);\n@@ -2988,3 +3001,3 @@\n-    StubRoutines::riscv::_string_indexof_linear_ll = generate_string_indexof_linear(true, true);\n-    StubRoutines::riscv::_string_indexof_linear_uu = generate_string_indexof_linear(false, false);\n-    StubRoutines::riscv::_string_indexof_linear_ul = generate_string_indexof_linear(true, false);\n+    StubRoutines::riscv::_string_indexof_linear_ll = generate_string_indexof_linear(StubGenStubId::string_indexof_linear_ll_id);\n+    StubRoutines::riscv::_string_indexof_linear_uu = generate_string_indexof_linear(StubGenStubId::string_indexof_linear_uu_id);\n+    StubRoutines::riscv::_string_indexof_linear_ul = generate_string_indexof_linear(StubGenStubId::string_indexof_linear_ul_id);\n@@ -2994,2 +3007,3 @@\n-  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+  void generate_lookup_secondary_supers_table_stub() {\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2997,1 +3011,0 @@\n-    address start = __ pc();\n@@ -3007,9 +3020,10 @@\n-    Label L_success;\n-    __ enter();\n-    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass, result,\n-                                     r_array_base, r_array_length, r_array_index,\n-                                     r_bitmap, super_klass_index, \/*stub_is_near*\/true);\n-    __ leave();\n-    __ ret();\n-\n-    return start;\n+    for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+      Label L_success;\n+      __ enter();\n+      __ lookup_secondary_supers_table(r_sub_klass, r_super_klass, result,\n+                                       r_array_base, r_array_length, r_array_index,\n+                                       r_bitmap, slot, \/*stub_is_near*\/true);\n+      __ leave();\n+      __ ret();\n+    }\n@@ -3020,1 +3034,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3041,1 +3056,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"mulAdd\");\n+    StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3074,1 +3090,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"multiplyToLen\");\n+    StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3104,1 +3121,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"squareToLen\");\n+    StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3144,1 +3162,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"bigIntegerLeftShiftWorker\");\n+    StubGenStubId stub_id = StubGenStubId::bigIntegerLeftShiftWorker_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3195,1 +3214,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"bigIntegerRightShiftWorker\");\n+    StubGenStubId stub_id = StubGenStubId::bigIntegerRightShiftWorker_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4021,1 +4041,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"Cont thaw\");\n+    StubGenStubId stub_id = StubGenStubId::cont_thaw_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4031,1 +4052,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier\");\n+    StubGenStubId stub_id = StubGenStubId::cont_returnBarrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4042,1 +4064,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier exception handler\");\n+    StubGenStubId stub_id = StubGenStubId::cont_returnBarrierExc_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4052,1 +4075,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\",\"Continuation preempt stub\");\n+    StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4089,2 +4113,2 @@\n-      address generate_sha256_implCompress(bool multi_block) {\n-        return generate_sha2_implCompress(Assembler::e32, multi_block);\n+      address generate_sha256_implCompress(StubGenStubId stub_id) {\n+        return generate_sha2_implCompress(Assembler::e32, stub_id);\n@@ -4092,2 +4116,2 @@\n-      address generate_sha512_implCompress(bool multi_block) {\n-        return generate_sha2_implCompress(Assembler::e64, multi_block);\n+      address generate_sha512_implCompress(StubGenStubId stub_id) {\n+        return generate_sha2_implCompress(Assembler::e64, stub_id);\n@@ -4218,9 +4242,0 @@\n-    const char* stub_name(Assembler::SEW vset_sew, bool multi_block) {\n-      if (vset_sew == Assembler::e32 && !multi_block) return \"sha256_implCompress\";\n-      if (vset_sew == Assembler::e32 &&  multi_block) return \"sha256_implCompressMB\";\n-      if (vset_sew == Assembler::e64 && !multi_block) return \"sha512_implCompress\";\n-      if (vset_sew == Assembler::e64 &&  multi_block) return \"sha512_implCompressMB\";\n-      ShouldNotReachHere();\n-      return \"bad name lookup\";\n-    }\n-\n@@ -4235,1 +4250,1 @@\n-    address generate_sha2_implCompress(Assembler::SEW vset_sew, bool multi_block) {\n+    address generate_sha2_implCompress(Assembler::SEW vset_sew, StubGenStubId stub_id) {\n@@ -4285,0 +4300,21 @@\n+      bool multi_block;\n+      switch (stub_id) {\n+      case sha256_implCompress_id:\n+        assert (vset_sew == Assembler::e32, \"wrong macroassembler for stub\");\n+        multi_block = false;\n+        break;\n+      case sha256_implCompressMB_id:\n+        assert (vset_sew == Assembler::e32, \"wrong macroassembler for stub\");\n+        multi_block = true;\n+        break;\n+      case sha512_implCompress_id:\n+        assert (vset_sew == Assembler::e64, \"wrong macroassembler for stub\");\n+        multi_block = false;\n+        break;\n+      case sha512_implCompressMB_id:\n+        assert (vset_sew == Assembler::e64, \"wrong macroassembler for stub\");\n+        multi_block = true;\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+      };\n@@ -4286,1 +4322,1 @@\n-      StubCodeMark mark(_cgen, \"StubRoutines\", stub_name(vset_sew, multi_block));\n+      StubCodeMark mark(_cgen, stub_id);\n@@ -4633,1 +4669,1 @@\n-  address generate_md5_implCompress(bool multi_block, const char *name) {\n+  address generate_md5_implCompress(StubGenStubId stub_id) {\n@@ -4635,1 +4671,12 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    bool multi_block;\n+    switch (stub_id) {\n+    case md5_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case md5_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    };\n+    StubCodeMark mark(this, stub_id);\n@@ -4889,1 +4936,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+    StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5188,1 +5236,12 @@\n-  address generate_sha1_implCompress(bool multi_block, const char *name) {\n+  address generate_sha1_implCompress(StubGenStubId stub_id) {\n+      bool multi_block;\n+      switch (stub_id) {\n+      case sha1_implCompress_id:\n+        multi_block = false;\n+        break;\n+      case sha1_implCompressMB_id:\n+        multi_block = true;\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+      };\n@@ -5190,1 +5249,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -5400,1 +5459,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"encodeBlock\");\n+    StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5656,1 +5716,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"decodeBlock\");\n+    StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5900,1 +5961,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesAdler32\");\n+    StubGenStubId stub_id = StubGenStubId::updateBytesAdler32_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6158,1 +6220,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"poly1305_processBlocks\");\n+    StubGenStubId stub_id = StubGenStubId::poly1305_processBlocks_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6347,1 +6410,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32\");\n+    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6371,1 +6435,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+    StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6388,1 +6453,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+    StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6463,4 +6529,1 @@\n-        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n-            = generate_lookup_secondary_supers_table_stub(slot);\n-        }\n+        generate_lookup_secondary_supers_table_stub();\n@@ -6492,1 +6555,2 @@\n-      StubCodeMark mark(this, \"StubRoutines\", \"montgomeryMultiply\");\n+      StubGenStubId stub_id = StubGenStubId::montgomeryMultiply_id;\n+      StubCodeMark mark(this, stub_id);\n@@ -6498,1 +6562,2 @@\n-      StubCodeMark mark(this, \"StubRoutines\", \"montgomerySquare\");\n+      StubGenStubId stub_id = StubGenStubId::montgomerySquare_id;\n+      StubCodeMark mark(this, stub_id);\n@@ -6519,2 +6584,2 @@\n-      StubRoutines::_sha256_implCompress   = sha2.generate_sha256_implCompress(false);\n-      StubRoutines::_sha256_implCompressMB = sha2.generate_sha256_implCompress(true);\n+      StubRoutines::_sha256_implCompress   = sha2.generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = sha2.generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n@@ -6525,2 +6590,2 @@\n-      StubRoutines::_sha512_implCompress   = sha2.generate_sha512_implCompress(false);\n-      StubRoutines::_sha512_implCompressMB = sha2.generate_sha512_implCompress(true);\n+      StubRoutines::_sha512_implCompress   = sha2.generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = sha2.generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n@@ -6530,2 +6595,2 @@\n-      StubRoutines::_md5_implCompress   = generate_md5_implCompress(false, \"md5_implCompress\");\n-      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(true,  \"md5_implCompressMB\");\n+      StubRoutines::_md5_implCompress   = generate_md5_implCompress(StubGenStubId::md5_implCompress_id);\n+      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(StubGenStubId::md5_implCompressMB_id);\n@@ -6539,2 +6604,2 @@\n-      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(false, \"sha1_implCompress\");\n-      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(true, \"sha1_implCompressMB\");\n+      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(StubGenStubId::sha1_implCompress_id);\n+      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(StubGenStubId::sha1_implCompressMB_id);\n@@ -6562,3 +6627,3 @@\n-  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    switch(kind) {\n-    case Initial_stubs:\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+    switch(blob_id) {\n+    case initial_id:\n@@ -6567,1 +6632,1 @@\n-     case Continuation_stubs:\n+     case continuation_id:\n@@ -6570,1 +6635,1 @@\n-    case Compiler_stubs:\n+    case compiler_id:\n@@ -6573,1 +6638,1 @@\n-    case Final_stubs:\n+    case final_id:\n@@ -6577,1 +6642,1 @@\n-      fatal(\"unexpected stubs kind: %d\", kind);\n+      fatal(\"unexpected blob id: %d\", blob_id);\n@@ -6583,2 +6648,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":488,"deletions":423,"binary":false,"changes":911,"status":"modified"},{"patch":"@@ -37,8 +37,13 @@\n-address StubRoutines::riscv::_zero_blocks = nullptr;\n-address StubRoutines::riscv::_compare_long_string_LL = nullptr;\n-address StubRoutines::riscv::_compare_long_string_UU = nullptr;\n-address StubRoutines::riscv::_compare_long_string_LU = nullptr;\n-address StubRoutines::riscv::_compare_long_string_UL = nullptr;\n-address StubRoutines::riscv::_string_indexof_linear_ll = nullptr;\n-address StubRoutines::riscv::_string_indexof_linear_uu = nullptr;\n-address StubRoutines::riscv::_string_indexof_linear_ul = nullptr;\n+\n+\/\/ define fields for arch-specific entries\n+\n+#define DEFINE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = nullptr;\n+\n+#define DEFINE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = CAST_FROM_FN_PTR(address, init_function);\n+\n+STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY, DEFINE_ARCH_ENTRY_INIT)\n+\n+#undef DEFINE_ARCH_ENTRY_INIT\n+#undef DEFINE_ARCH_ENTRY\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+\/\/ emit enum used to size per-blob code buffers\n+\n+#define DEFINE_BLOB_SIZE(blob_name, size) \\\n+  _ ## blob_name ## _code_size = size,\n+\n@@ -39,5 +44,1 @@\n-  \/\/ simply increase sizes if too small (assembler will crash if too small)\n-  _initial_stubs_code_size      = 10000,\n-  _continuation_stubs_code_size =  2000,\n-  _compiler_stubs_code_size     = 45000,\n-  _final_stubs_code_size        = 20000 ZGC_ONLY(+10000)\n+  STUBGEN_ARCH_BLOBS_DO(DEFINE_BLOB_SIZE)\n@@ -46,0 +47,2 @@\n+#undef DEFINE_BLOB_SIZE\n+\n@@ -48,0 +51,3 @@\n+#if INCLUDE_JVMCI\n+  friend class JVMCIVMStructs;\n+#endif\n@@ -49,2 +55,1 @@\n- private:\n-  static address _zero_blocks;\n+  \/\/ declare fields for arch-specific entries\n@@ -52,7 +57,2 @@\n-  static address _compare_long_string_LL;\n-  static address _compare_long_string_LU;\n-  static address _compare_long_string_UL;\n-  static address _compare_long_string_UU;\n-  static address _string_indexof_linear_ll;\n-  static address _string_indexof_linear_uu;\n-  static address _string_indexof_linear_ul;\n+#define DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address STUB_FIELD_NAME(field_name) ;\n@@ -60,1 +60,2 @@\n-  static bool _completed;\n+#define DECLARE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name)\n@@ -62,1 +63,2 @@\n- public:\n+private:\n+  STUBGEN_ARCH_ENTRIES_DO(DECLARE_ARCH_ENTRY, DECLARE_ARCH_ENTRY_INIT)\n@@ -64,3 +66,2 @@\n-  static address zero_blocks() {\n-    return _zero_blocks;\n-  }\n+#undef DECLARE_ARCH_ENTRY_INIT\n+#undef DECLARE_ARCH_ENTRY\n@@ -68,3 +69,1 @@\n-  static address compare_long_string_LL() {\n-    return _compare_long_string_LL;\n-  }\n+  static bool _completed;\n@@ -72,3 +71,1 @@\n-  static address compare_long_string_LU() {\n-    return _compare_long_string_LU;\n-  }\n+ public:\n@@ -76,3 +73,1 @@\n-  static address compare_long_string_UL() {\n-    return _compare_long_string_UL;\n-  }\n+  \/\/ declare getters for arch-specific entries\n@@ -80,3 +75,2 @@\n-  static address compare_long_string_UU() {\n-    return _compare_long_string_UU;\n-  }\n+#define DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address getter_name() { return STUB_FIELD_NAME(field_name) ; }\n@@ -84,3 +78,2 @@\n-  static address string_indexof_linear_ul() {\n-    return _string_indexof_linear_ul;\n-  }\n+#define DEFINE_ARCH_ENTRY_GETTER_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name)\n@@ -88,3 +81,1 @@\n-  static address string_indexof_linear_ll() {\n-    return _string_indexof_linear_ll;\n-  }\n+  STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY_GETTER, DEFINE_ARCH_ENTRY_GETTER_INIT)\n@@ -92,3 +83,2 @@\n-  static address string_indexof_linear_uu() {\n-    return _string_indexof_linear_uu;\n-  }\n+#undef DEFINE_ARCH_ENTRY_GETTER_INIT\n+#undef DEFINE_ARCH_ENTRY_GETTER\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.hpp","additions":30,"deletions":40,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights\n+ * reserved.  Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_S390_STUBDECLARATIONS_HPP\n+#define CPU_S390_STUBDECLARATIONS_HPP\n+\n+#define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n+  do_arch_blob(initial, 20000)                                          \\\n+\n+\n+#define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \\\n+                                           do_arch_blob,                \\\n+                                           do_arch_entry,               \\\n+                                           do_arch_entry_init)          \\\n+  do_arch_blob(continuation, 2000)                                      \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \\\n+                                       do_arch_blob,                    \\\n+                                       do_arch_entry,                   \\\n+                                       do_arch_entry_init)              \\\n+  do_arch_blob(compiler, 20000 )                                        \\\n+  do_stub(compiler, partial_subtype_check)                              \\\n+  do_arch_entry(zarch, compiler, partial_subtype_check,                 \\\n+                partial_subtype_check, partial_subtype_check)           \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \\\n+                                    do_arch_blob,                       \\\n+                                    do_arch_entry,                      \\\n+                                    do_arch_entry_init)                 \\\n+  do_arch_blob(final, 20000)                                            \\\n+\n+\n+#endif \/\/ CPU_S390_STUBDECLARATIONS_HPP\n","filename":"src\/hotspot\/cpu\/s390\/stubDeclarations_s390.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -122,1 +122,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"call_stub\");\n+    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -462,1 +463,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"catch_exception\");\n+    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -513,1 +515,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"forward_exception\");\n+    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -593,1 +596,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"partial_subtype_check\");\n+    StubGenStubId stub_id = StubGenStubId::partial_subtype_check_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -625,2 +629,3 @@\n-  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+  void generate_lookup_secondary_supers_table_stub() {\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -636,7 +641,5 @@\n-    address start = __ pc();\n-\n-    __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n-                                           r_array_base, r_array_length, r_array_index,\n-                                           r_bitmap, r_result, super_klass_index);\n-\n-    __ z_br(Z_R14);\n+    for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+      __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n+                                             r_array_base, r_array_length, r_array_index,\n+                                             r_bitmap, r_result, slot);\n@@ -644,1 +647,2 @@\n-    return start;\n+      __ z_br(Z_R14);\n+    }\n@@ -649,1 +653,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1264,37 +1269,40 @@\n-  \/\/ Generate stub for disjoint byte copy. If \"aligned\" is true, the\n-  \/\/ \"from\" and \"to\" addresses are assumed to be heapword aligned.\n-  address generate_disjoint_byte_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-\n-    \/\/ This is the zarch specific stub generator for byte array copy.\n-    \/\/ Refer to generate_disjoint_copy for a list of prereqs and features:\n-    unsigned int start_off = __ offset();  \/\/ Remember stub start address (is rtn value).\n-    generate_disjoint_copy(aligned, 1, false, false);\n-    return __ addr_at(start_off);\n-  }\n-\n-\n-  address generate_disjoint_short_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-    \/\/ This is the zarch specific stub generator for short array copy.\n-    \/\/ Refer to generate_disjoint_copy for a list of prereqs and features:\n-    unsigned int start_off = __ offset();  \/\/ Remember stub start address (is rtn value).\n-    generate_disjoint_copy(aligned, 2, false, false);\n-    return __ addr_at(start_off);\n-  }\n-\n-\n-  address generate_disjoint_int_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-    \/\/ This is the zarch specific stub generator for int array copy.\n-    \/\/ Refer to generate_disjoint_copy for a list of prereqs and features:\n-    unsigned int start_off = __ offset();  \/\/ Remember stub start address (is rtn value).\n-    generate_disjoint_copy(aligned, 4, false, false);\n-    return __ addr_at(start_off);\n-  }\n-\n-\n-  address generate_disjoint_long_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-    \/\/ This is the zarch specific stub generator for long array copy.\n-    \/\/ Refer to generate_disjoint_copy for a list of prereqs and features:\n+  address generate_disjoint_nonoop_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    int element_size;\n+    switch (stub_id) {\n+    case jbyte_disjoint_arraycopy_id:\n+      aligned = false;\n+      element_size = 1;\n+      break;\n+    case arrayof_jbyte_disjoint_arraycopy_id:\n+      aligned = true;\n+      element_size = 1;\n+      break;\n+    case jshort_disjoint_arraycopy_id:\n+      aligned = false;\n+      element_size = 2;\n+      break;\n+    case arrayof_jshort_disjoint_arraycopy_id:\n+      aligned = true;\n+      element_size = 2;\n+      break;\n+    case jint_disjoint_arraycopy_id:\n+      aligned = false;\n+      element_size = 4;\n+      break;\n+    case arrayof_jint_disjoint_arraycopy_id:\n+      aligned = true;\n+      element_size = 4;\n+      break;\n+    case jlong_disjoint_arraycopy_id:\n+      aligned = false;\n+      element_size = 8;\n+      break;\n+    case arrayof_jlong_disjoint_arraycopy_id:\n+      aligned = true;\n+      element_size = 8;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    StubCodeMark mark(this, stub_id);\n@@ -1302,1 +1310,1 @@\n-    generate_disjoint_copy(aligned, 8, false, false);\n+    generate_disjoint_copy(aligned, element_size, false, false);\n@@ -1306,3 +1314,24 @@\n-\n-  address generate_disjoint_oop_copy(bool aligned, const char * name, bool dest_uninitialized) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_disjoint_oop_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case oop_disjoint_arraycopy_id:\n+      aligned = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_id:\n+      aligned = true;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_disjoint_arraycopy_uninit_id:\n+      aligned = false;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+      aligned = true;\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    StubCodeMark mark(this, stub_id);\n@@ -1332,57 +1361,52 @@\n-\n-  address generate_conjoint_byte_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-    \/\/ This is the zarch specific stub generator for overlapping byte array copy.\n-    \/\/ Refer to generate_conjoint_copy for a list of prereqs and features:\n-    unsigned int   start_off = __ offset();  \/\/ Remember stub start address (is rtn value).\n-    address nooverlap_target = aligned ? StubRoutines::arrayof_jbyte_disjoint_arraycopy()\n-                                       : StubRoutines::jbyte_disjoint_arraycopy();\n-\n-    array_overlap_test(nooverlap_target, 0); \/\/ Branch away to nooverlap_target if disjoint.\n-    generate_conjoint_copy(aligned, 1, false);\n-\n-    return __ addr_at(start_off);\n-  }\n-\n-\n-  address generate_conjoint_short_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-    \/\/ This is the zarch specific stub generator for overlapping short array copy.\n-    \/\/ Refer to generate_conjoint_copy for a list of prereqs and features:\n-    unsigned int   start_off = __ offset();  \/\/ Remember stub start address (is rtn value).\n-    address nooverlap_target = aligned ? StubRoutines::arrayof_jshort_disjoint_arraycopy()\n-                                       : StubRoutines::jshort_disjoint_arraycopy();\n-\n-    array_overlap_test(nooverlap_target, 1); \/\/ Branch away to nooverlap_target if disjoint.\n-    generate_conjoint_copy(aligned, 2, false);\n-\n-    return __ addr_at(start_off);\n-  }\n-\n-  address generate_conjoint_int_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-    \/\/ This is the zarch specific stub generator for overlapping int array copy.\n-    \/\/ Refer to generate_conjoint_copy for a list of prereqs and features:\n-\n-    unsigned int   start_off = __ offset();  \/\/ Remember stub start address (is rtn value).\n-    address nooverlap_target = aligned ? StubRoutines::arrayof_jint_disjoint_arraycopy()\n-                                       : StubRoutines::jint_disjoint_arraycopy();\n-\n-    array_overlap_test(nooverlap_target, 2); \/\/ Branch away to nooverlap_target if disjoint.\n-    generate_conjoint_copy(aligned, 4, false);\n-\n-    return __ addr_at(start_off);\n-  }\n-\n-  address generate_conjoint_long_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-    \/\/ This is the zarch specific stub generator for overlapping long array copy.\n-    \/\/ Refer to generate_conjoint_copy for a list of prereqs and features:\n-\n-    unsigned int start_off   = __ offset();  \/\/ Remember stub start address (is rtn value).\n-    address nooverlap_target = aligned ? StubRoutines::arrayof_jlong_disjoint_arraycopy()\n-                                       : StubRoutines::jlong_disjoint_arraycopy();\n-\n-    array_overlap_test(nooverlap_target, 3); \/\/ Branch away to nooverlap_target if disjoint.\n-    generate_conjoint_copy(aligned, 8, false);\n-\n+  address generate_conjoint_nonoop_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    int shift; \/\/ i.e. log2(element size)\n+    address nooverlap_target;\n+    switch (stub_id) {\n+    case jbyte_arraycopy_id:\n+      aligned = false;\n+      shift = 0;\n+      nooverlap_target = StubRoutines::jbyte_disjoint_arraycopy();\n+      break;\n+    case arrayof_jbyte_arraycopy_id:\n+      aligned = true;\n+      shift = 0;\n+      nooverlap_target = StubRoutines::arrayof_jbyte_disjoint_arraycopy();\n+      break;\n+    case jshort_arraycopy_id:\n+      aligned = false;\n+      shift = 1;\n+      nooverlap_target = StubRoutines::jshort_disjoint_arraycopy();\n+      break;\n+    case arrayof_jshort_arraycopy_id:\n+      aligned = true;\n+      shift = 1;\n+      nooverlap_target = StubRoutines::arrayof_jshort_disjoint_arraycopy();\n+      break;\n+    case jint_arraycopy_id:\n+      aligned = false;\n+      shift = 2;\n+      nooverlap_target = StubRoutines::jint_disjoint_arraycopy();\n+      break;\n+    case arrayof_jint_arraycopy_id:\n+      aligned = true;\n+      shift = 2;\n+      nooverlap_target = StubRoutines::arrayof_jint_disjoint_arraycopy();\n+      break;\n+    case jlong_arraycopy_id:\n+      aligned = false;\n+      shift = 3;\n+      nooverlap_target = StubRoutines::jlong_disjoint_arraycopy();\n+      break;\n+    case arrayof_jlong_arraycopy_id:\n+      aligned = true;\n+      shift = 3;\n+      nooverlap_target = StubRoutines::arrayof_jlong_disjoint_arraycopy();\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    StubCodeMark mark(this, stub_id);\n+    unsigned int start_off = __ offset();  \/\/ Remember stub start address (is rtn value).\n+    array_overlap_test(nooverlap_target, shift); \/\/ Branch away to nooverlap_target if disjoint.\n+    generate_conjoint_copy(aligned, 1 << shift, false);\n@@ -1392,2 +1416,29 @@\n-  address generate_conjoint_oop_copy(bool aligned, const char * name, bool dest_uninitialized) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_conjoint_oop_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    bool dest_uninitialized;\n+    address nooverlap_target;\n+    switch (stub_id) {\n+    case oop_arraycopy_id:\n+      aligned = false;\n+      dest_uninitialized = false;\n+      nooverlap_target = StubRoutines::oop_disjoint_arraycopy(dest_uninitialized);\n+      break;\n+    case arrayof_oop_arraycopy_id:\n+      aligned = true;\n+      dest_uninitialized = false;\n+      nooverlap_target = StubRoutines::arrayof_oop_disjoint_arraycopy(dest_uninitialized);\n+      break;\n+    case oop_arraycopy_uninit_id:\n+      aligned = false;\n+      dest_uninitialized = true;\n+      nooverlap_target = StubRoutines::oop_disjoint_arraycopy(dest_uninitialized);\n+      break;\n+    case arrayof_oop_arraycopy_uninit_id:\n+      aligned = true;\n+      dest_uninitialized = true;\n+      nooverlap_target = StubRoutines::arrayof_oop_disjoint_arraycopy(dest_uninitialized);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    StubCodeMark mark(this, stub_id);\n@@ -1400,3 +1451,0 @@\n-    address nooverlap_target = aligned ? StubRoutines::arrayof_oop_disjoint_arraycopy(dest_uninitialized)\n-                                       : StubRoutines::oop_disjoint_arraycopy(dest_uninitialized);\n-\n@@ -1429,27 +1477,27 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy      = generate_disjoint_byte_copy (false, \"jbyte_disjoint_arraycopy\");\n-    StubRoutines::_jshort_disjoint_arraycopy     = generate_disjoint_short_copy(false, \"jshort_disjoint_arraycopy\");\n-    StubRoutines::_jint_disjoint_arraycopy       = generate_disjoint_int_copy  (false, \"jint_disjoint_arraycopy\");\n-    StubRoutines::_jlong_disjoint_arraycopy      = generate_disjoint_long_copy (false, \"jlong_disjoint_arraycopy\");\n-    StubRoutines::_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (false, \"oop_disjoint_arraycopy\", false);\n-    StubRoutines::_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (false, \"oop_disjoint_arraycopy_uninit\", true);\n-\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_byte_copy (true, \"arrayof_jbyte_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_short_copy(true, \"arrayof_jshort_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_int_copy  (true, \"arrayof_jint_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_long_copy (true, \"arrayof_jlong_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (true, \"arrayof_oop_disjoint_arraycopy\", false);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (true, \"arrayof_oop_disjoint_arraycopy_uninit\", true);\n-\n-    StubRoutines::_jbyte_arraycopy           = generate_conjoint_byte_copy (false, \"jbyte_arraycopy\");\n-    StubRoutines::_jshort_arraycopy          = generate_conjoint_short_copy(false, \"jshort_arraycopy\");\n-    StubRoutines::_jint_arraycopy            = generate_conjoint_int_copy  (false, \"jint_arraycopy\");\n-    StubRoutines::_jlong_arraycopy           = generate_conjoint_long_copy (false, \"jlong_arraycopy\");\n-    StubRoutines::_oop_arraycopy             = generate_conjoint_oop_copy  (false, \"oop_arraycopy\", false);\n-    StubRoutines::_oop_arraycopy_uninit      = generate_conjoint_oop_copy  (false, \"oop_arraycopy_uninit\", true);\n-\n-    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_byte_copy (true, \"arrayof_jbyte_arraycopy\");\n-    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_short_copy(true, \"arrayof_jshort_arraycopy\");\n-    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_int_copy  (true, \"arrayof_jint_arraycopy\");\n-    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_long_copy (true, \"arrayof_jlong_arraycopy\");\n-    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy  (true, \"arrayof_oop_arraycopy\", false);\n-    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy  (true, \"arrayof_oop_arraycopy_uninit\", true);\n+    StubRoutines::_jbyte_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_jshort_disjoint_arraycopy     = generate_disjoint_nonoop_copy(StubGenStubId::jshort_disjoint_arraycopy_id);\n+    StubRoutines::_jint_disjoint_arraycopy       = generate_disjoint_nonoop_copy  (StubGenStubId::jint_disjoint_arraycopy_id);\n+    StubRoutines::_jlong_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::jlong_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (StubGenStubId::oop_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (StubGenStubId::oop_disjoint_arraycopy_uninit_id);\n+\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_nonoop_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_nonoop_copy  (StubGenStubId::arrayof_jint_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::arrayof_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (StubGenStubId::arrayof_oop_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (StubGenStubId::arrayof_oop_disjoint_arraycopy_uninit_id);\n+\n+    StubRoutines::_jbyte_arraycopy           = generate_conjoint_nonoop_copy(StubGenStubId::jbyte_arraycopy_id);\n+    StubRoutines::_jshort_arraycopy          = generate_conjoint_nonoop_copy(StubGenStubId::jshort_arraycopy_id);\n+    StubRoutines::_jint_arraycopy            = generate_conjoint_nonoop_copy(StubGenStubId::jint_arraycopy_id);\n+    StubRoutines::_jlong_arraycopy           = generate_conjoint_nonoop_copy(StubGenStubId::jlong_arraycopy_id);\n+    StubRoutines::_oop_arraycopy             = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_id);\n+    StubRoutines::_oop_arraycopy_uninit      = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_uninit_id);\n+\n+    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_nonoop_copy(StubGenStubId::arrayof_jbyte_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_nonoop_copy(StubGenStubId::arrayof_jshort_arraycopy_id);\n+    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_nonoop_copy (StubGenStubId::arrayof_jint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_nonoop_copy(StubGenStubId::arrayof_jlong_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_uninit_id);\n@@ -1737,1 +1785,1 @@\n-  address generate_AES_encryptBlock(const char* name) {\n+  address generate_AES_encryptBlock() {\n@@ -1739,1 +1787,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1748,1 +1797,1 @@\n-  address generate_AES_decryptBlock(const char* name) {\n+  address generate_AES_decryptBlock() {\n@@ -1750,1 +1799,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1808,1 +1858,1 @@\n-  address generate_cipherBlockChaining_AES_encrypt(const char* name) {\n+  address generate_cipherBlockChaining_AES_encrypt() {\n@@ -1810,1 +1860,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1819,1 +1870,1 @@\n-  address generate_cipherBlockChaining_AES_decrypt(const char* name) {\n+  address generate_cipherBlockChaining_AES_decrypt() {\n@@ -1821,1 +1872,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2525,1 +2577,1 @@\n-  address generate_counterMode_AESCrypt(const char* name) {\n+  address generate_counterMode_AESCrypt() {\n@@ -2527,1 +2579,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2540,1 +2593,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"ghash_processBlocks\");\n+    StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2617,1 +2671,12 @@\n-  address generate_SHA1_stub(bool multiBlock, const char* name) {\n+  address generate_SHA1_stub(StubGenStubId stub_id) {\n+    bool multiBlock;\n+    switch (stub_id) {\n+    case sha1_implCompress_id:\n+      multiBlock = false;\n+      break;\n+    case sha1_implCompressMB_id:\n+      multiBlock = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -2619,1 +2684,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2699,1 +2764,12 @@\n-  address generate_SHA256_stub(bool multiBlock, const char* name) {\n+  address generate_SHA256_stub(StubGenStubId stub_id) {\n+    bool multiBlock;\n+    switch (stub_id) {\n+    case sha256_implCompress_id:\n+      multiBlock = false;\n+      break;\n+    case sha256_implCompressMB_id:\n+      multiBlock = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -2701,1 +2777,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2779,1 +2855,12 @@\n-  address generate_SHA512_stub(bool multiBlock, const char* name) {\n+  address generate_SHA512_stub(StubGenStubId stub_id) {\n+    bool multiBlock;\n+    switch (stub_id) {\n+    case sha512_implCompress_id:\n+      multiBlock = false;\n+      break;\n+    case sha512_implCompressMB_id:\n+      multiBlock = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -2781,1 +2868,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2871,1 +2958,1 @@\n-  void generate_CRC_updateBytes(const char* name, Register table, bool invertCRC) {\n+  void generate_CRC_updateBytes(Register table, bool invertCRC) {\n@@ -2902,1 +2989,1 @@\n-  address generate_CRC32_updateBytes(const char* name) {\n+  address generate_CRC32_updateBytes() {\n@@ -2904,1 +2991,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id =  StubGenStubId::updateBytesCRC32_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2907,1 +2995,1 @@\n-    assert(UseCRC32Intrinsics, \"should not generate this stub (%s) with CRC32 intrinsics disabled\", name);\n+    assert(UseCRC32Intrinsics, \"should not generate this stub (%s) with CRC32 intrinsics disabled\", StubRoutines::get_stub_name(stub_id));\n@@ -2913,1 +3001,1 @@\n-    generate_CRC_updateBytes(name, table, true);\n+    generate_CRC_updateBytes(table, true);\n@@ -2921,1 +3009,1 @@\n-  address generate_CRC32C_updateBytes(const char* name) {\n+  address generate_CRC32C_updateBytes() {\n@@ -2923,1 +3011,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id =  StubGenStubId::updateBytesCRC32C_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2926,1 +3015,1 @@\n-    assert(UseCRC32CIntrinsics, \"should not generate this stub (%s) with CRC32C intrinsics disabled\", name);\n+    assert(UseCRC32CIntrinsics, \"should not generate this stub (%s) with CRC32C intrinsics disabled\", StubRoutines::get_stub_name(stub_id));\n@@ -2932,1 +3021,1 @@\n-    generate_CRC_updateBytes(name, table, false);\n+    generate_CRC_updateBytes(table, false);\n@@ -2947,1 +3036,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"multiplyToLen\");\n+    StubGenStubId stub_id =  StubGenStubId::multiplyToLen_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2978,1 +3068,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+    StubGenStubId stub_id =  StubGenStubId::method_entry_barrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3043,1 +3134,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+    StubGenStubId stub_id =  StubGenStubId::upcall_stub_exception_handler_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3060,1 +3152,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+    StubGenStubId stub_id =  StubGenStubId::upcall_stub_load_target_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3097,1 +3190,1 @@\n-      StubRoutines::_updateBytesCRC32  = generate_CRC32_updateBytes(\"CRC32_updateBytes\");\n+      StubRoutines::_updateBytesCRC32  = generate_CRC32_updateBytes();\n@@ -3102,1 +3195,1 @@\n-      StubRoutines::_updateBytesCRC32C = generate_CRC32C_updateBytes(\"CRC32C_updateBytes\");\n+      StubRoutines::_updateBytesCRC32C = generate_CRC32C_updateBytes();\n@@ -3121,2 +3214,0 @@\n-    StubRoutines::zarch::_partial_subtype_check            = generate_partial_subtype_check();\n-\n@@ -3135,0 +3226,9 @@\n+#ifdef COMPILER2\n+    if (UseSecondarySupersTable) {\n+      StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+      if (!InlineSecondarySupersTest) {\n+        generate_lookup_secondary_supers_table_stub();\n+      }\n+    }\n+#endif \/\/ COMPILER2\n+\n@@ -3140,0 +3240,3 @@\n+\n+    StubRoutines::zarch::_partial_subtype_check            = generate_partial_subtype_check();\n+\n@@ -3144,4 +3247,4 @@\n-        StubRoutines::_aescrypt_encryptBlock = generate_AES_encryptBlock(\"AES_encryptBlock\");\n-        StubRoutines::_aescrypt_decryptBlock = generate_AES_decryptBlock(\"AES_decryptBlock\");\n-        StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_AES_encrypt(\"AES_encryptBlock_chaining\");\n-        StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_AES_decrypt(\"AES_decryptBlock_chaining\");\n+        StubRoutines::_aescrypt_encryptBlock = generate_AES_encryptBlock();\n+        StubRoutines::_aescrypt_decryptBlock = generate_AES_decryptBlock();\n+        StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_AES_encrypt();\n+        StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_AES_decrypt();\n@@ -3157,1 +3260,1 @@\n-        StubRoutines::_counterMode_AESCrypt = generate_counterMode_AESCrypt(\"counterMode_AESCrypt\");\n+        StubRoutines::_counterMode_AESCrypt = generate_counterMode_AESCrypt();\n@@ -3172,2 +3275,2 @@\n-      StubRoutines::_sha1_implCompress     = generate_SHA1_stub(false,   \"SHA1_singleBlock\");\n-      StubRoutines::_sha1_implCompressMB   = generate_SHA1_stub(true,    \"SHA1_multiBlock\");\n+      StubRoutines::_sha1_implCompress     = generate_SHA1_stub(StubGenStubId::sha1_implCompress_id);\n+      StubRoutines::_sha1_implCompressMB   = generate_SHA1_stub(StubGenStubId::sha1_implCompressMB_id);\n@@ -3176,2 +3279,2 @@\n-      StubRoutines::_sha256_implCompress   = generate_SHA256_stub(false, \"SHA256_singleBlock\");\n-      StubRoutines::_sha256_implCompressMB = generate_SHA256_stub(true,  \"SHA256_multiBlock\");\n+      StubRoutines::_sha256_implCompress   = generate_SHA256_stub(StubGenStubId::sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = generate_SHA256_stub(StubGenStubId::sha256_implCompressMB_id);\n@@ -3180,2 +3283,2 @@\n-      StubRoutines::_sha512_implCompress   = generate_SHA512_stub(false, \"SHA512_singleBlock\");\n-      StubRoutines::_sha512_implCompressMB = generate_SHA512_stub(true,  \"SHA512_multiBlock\");\n+      StubRoutines::_sha512_implCompress   = generate_SHA512_stub(StubGenStubId::sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = generate_SHA512_stub(StubGenStubId::sha512_implCompressMB_id);\n@@ -3196,8 +3299,0 @@\n-    if (UseSecondarySupersTable) {\n-      StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n-      if (!InlineSecondarySupersTest) {\n-        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-          StubRoutines::_lookup_secondary_supers_table_stubs[slot] = generate_lookup_secondary_supers_table_stub(slot);\n-        }\n-      }\n-    }\n@@ -3209,3 +3304,3 @@\n-  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    switch(kind) {\n-    case Initial_stubs:\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+    switch(blob_id) {\n+    case initial_id:\n@@ -3214,1 +3309,1 @@\n-     case Continuation_stubs:\n+     case continuation_id:\n@@ -3217,1 +3312,1 @@\n-    case Compiler_stubs:\n+    case compiler_id:\n@@ -3220,1 +3315,1 @@\n-    case Final_stubs:\n+    case final_id:\n@@ -3224,1 +3319,1 @@\n-      fatal(\"unexpected stubs kind: %d\", kind);\n+      fatal(\"unexpected blob id: %d\", blob_id);\n@@ -3263,2 +3358,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":302,"deletions":207,"binary":false,"changes":509,"status":"modified"},{"patch":"@@ -36,1 +36,12 @@\n-address StubRoutines::zarch::_partial_subtype_check = nullptr;\n+\/\/ define fields for arch-specific entries\n+\n+#define DEFINE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = nullptr;\n+\n+#define DEFINE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = CAST_FROM_FN_PTR(address, init_function);\n+\n+STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY, DEFINE_ARCH_ENTRY_INIT)\n+\n+#undef DEFINE_ARCH_ENTRY_INIT\n+#undef DEFINE_ARCH_ENTRY\n","filename":"src\/hotspot\/cpu\/s390\/stubRoutines_s390.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,6 +34,7 @@\n-enum { \/\/ Platform dependent constants.\n-  \/\/ simply increase sizes if too small (assembler will crash if too small)\n-  _initial_stubs_code_size      = 20000,\n-  _continuation_stubs_code_size =  2000,\n-  _compiler_stubs_code_size     = 20000,\n-  _final_stubs_code_size        = 20000\n+\/\/ emit enum used to size per-blob code buffers\n+\n+#define DEFINE_BLOB_SIZE(blob_name, size) \\\n+  _ ## blob_name ## _code_size = size,\n+\n+enum platform_dependent_constants {\n+  STUBGEN_ARCH_BLOBS_DO(DEFINE_BLOB_SIZE)\n@@ -42,0 +43,2 @@\n+#undef DEFINE_BLOB_SIZE\n+\n@@ -72,0 +75,14 @@\n+  \/\/ declare fields for arch-specific entries\n+\n+#define DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address STUB_FIELD_NAME(field_name) ;\n+\n+#define DECLARE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name)\n+\n+private:\n+  STUBGEN_ARCH_ENTRIES_DO(DECLARE_ARCH_ENTRY, DECLARE_ARCH_ENTRY_INIT)\n+\n+#undef DECLARE_ARCH_ENTRY_INIT\n+#undef DECLARE_ARCH_ENTRY\n+\n@@ -73,0 +90,1 @@\n+\n@@ -75,1 +93,0 @@\n-  static address _partial_subtype_check;\n@@ -84,0 +101,14 @@\n+\n+  \/\/ declare getters for arch-specific entries\n+\n+#define DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address getter_name() { return STUB_FIELD_NAME(field_name) ; }\n+\n+#define DEFINE_ARCH_ENTRY_GETTER_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name)\n+\n+  STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY_GETTER, DEFINE_ARCH_ENTRY_GETTER_INIT)\n+\n+#undef DEFINE_ARCH_ENTRY_GETTER_INIT\n+#undef DEFINE_ARCH_ENTRY_GETTER\n+\n@@ -95,2 +126,0 @@\n-  static address partial_subtype_check()                  { return _partial_subtype_check; }\n-\n","filename":"src\/hotspot\/cpu\/s390\/stubRoutines_s390.hpp","additions":38,"deletions":9,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -203,1 +203,0 @@\n-  StubCodeMark mark(stubgen, \"StubRoutines\", \"stringIndexOf\");\n@@ -210,0 +209,2 @@\n+  StubGenStubId stub_id = (isLL ?  StubGenStubId::string_indexof_linear_ll_id : (isUL ? StubGenStubId::string_indexof_linear_ul_id : StubGenStubId::string_indexof_linear_uu_id));\n+  StubCodeMark mark(stubgen, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/c2_stubGenerator_x86_64_string.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -9123,2 +9123,2 @@\n-    const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;\n-    const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr+1);\n+    const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::crc32c_table_addr();\n+    const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 1);\n@@ -9126,2 +9126,2 @@\n-    const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);\n-    const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);\n+    const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 2);\n+    const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 3);\n@@ -9129,2 +9129,2 @@\n-    const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);\n-    const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);\n+    const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 4);\n+    const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 5);\n@@ -9203,2 +9203,2 @@\n-    const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;\n-    const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 1);\n+    const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::crc32c_table_addr();\n+    const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 1);\n@@ -9206,2 +9206,2 @@\n-    const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);\n-    const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);\n+    const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 2);\n+    const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 3);\n@@ -9209,2 +9209,2 @@\n-    const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);\n-    const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);\n+    const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 4);\n+    const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 5);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,262 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights\n+ * reserved.  Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_X86_STUBDECLARATIONS_HPP\n+#define CPU_X86_STUBDECLARATIONS_HPP\n+\n+#define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n+  do_arch_blob(initial, 20000 WINDOWS_ONLY(+1000))                      \\\n+  do_stub(initial, verify_mxcsr)                                        \\\n+  do_arch_entry(x86, initial, verify_mxcsr, verify_mxcsr_entry,         \\\n+                verify_mxcsr_entry)                                     \\\n+  LP64_ONLY(                                                            \\\n+    do_stub(initial, get_previous_sp)                                   \\\n+    do_arch_entry(x86, initial, get_previous_sp,                        \\\n+                  get_previous_sp_entry,                                \\\n+                  get_previous_sp_entry)                                \\\n+    do_stub(initial, f2i_fixup)                                         \\\n+    do_arch_entry(x86, initial, f2i_fixup, f2i_fixup, f2i_fixup)        \\\n+    do_stub(initial, f2l_fixup)                                         \\\n+    do_arch_entry(x86, initial, f2l_fixup, f2l_fixup, f2l_fixup)        \\\n+    do_stub(initial, d2i_fixup)                                         \\\n+    do_arch_entry(x86, initial, d2i_fixup, d2i_fixup, d2i_fixup)        \\\n+    do_stub(initial, d2l_fixup)                                         \\\n+    do_arch_entry(x86, initial, d2l_fixup, d2l_fixup, d2l_fixup)        \\\n+    do_stub(initial, float_sign_mask)                                   \\\n+    do_arch_entry(x86, initial, float_sign_mask, float_sign_mask,       \\\n+                  float_sign_mask)                                      \\\n+    do_stub(initial, float_sign_flip)                                   \\\n+    do_arch_entry(x86, initial, float_sign_flip, float_sign_flip,       \\\n+                  float_sign_flip)                                      \\\n+    do_stub(initial, double_sign_mask)                                  \\\n+    do_arch_entry(x86, initial, double_sign_mask, double_sign_mask,     \\\n+                  double_sign_mask)                                     \\\n+    do_stub(initial, double_sign_flip)                                  \\\n+    do_arch_entry(x86, initial, double_sign_flip, double_sign_flip,     \\\n+                  double_sign_flip)                                     \\\n+  )                                                                     \\\n+  NOT_LP64(                                                             \\\n+    do_stub(initial, verify_fpu_cntrl_word)                             \\\n+    do_arch_entry(x86, initial, verify_fpu_cntrl_word,                  \\\n+                  verify_fpu_cntrl_wrd_entry,                           \\\n+                  verify_fpu_cntrl_wrd_entry)                           \\\n+    do_stub(initial, d2i_wrapper)                                       \\\n+    do_arch_entry(x86, initial, d2i_wrapper, d2i_wrapper,               \\\n+                  d2i_wrapper)                                          \\\n+    do_stub(initial, d2l_wrapper)                                       \\\n+    do_arch_entry(x86, initial, d2l_wrapper, d2l_wrapper,               \\\n+                  d2l_wrapper)                                          \\\n+  )                                                                     \\\n+\n+\n+#define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \\\n+                                           do_arch_blob,                \\\n+                                           do_arch_entry,               \\\n+                                           do_arch_entry_init)          \\\n+  do_arch_blob(continuation, 1000 LP64_ONLY(+2000))                     \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \\\n+                                       do_arch_blob,                    \\\n+                                       do_arch_entry,                   \\\n+                                       do_arch_entry_init)              \\\n+  do_arch_blob(compiler, 20000 LP64_ONLY(+52000) WINDOWS_ONLY(+2000))   \\\n+  do_stub(compiler, vector_float_sign_mask)                             \\\n+  do_arch_entry(x86, compiler, vector_float_sign_mask,                  \\\n+                vector_float_sign_mask, vector_float_sign_mask)         \\\n+  do_stub(compiler, vector_float_sign_flip)                             \\\n+  do_arch_entry(x86, compiler, vector_float_sign_flip,                  \\\n+                vector_float_sign_flip, vector_float_sign_flip)         \\\n+  do_stub(compiler, vector_double_sign_mask)                            \\\n+  do_arch_entry(x86, compiler, vector_double_sign_mask,                 \\\n+                vector_double_sign_mask, vector_double_sign_mask)       \\\n+  do_stub(compiler, vector_double_sign_flip)                            \\\n+  do_arch_entry(x86, compiler, vector_double_sign_flip,                 \\\n+                vector_double_sign_flip, vector_double_sign_flip)       \\\n+  do_stub(compiler, vector_all_bits_set)                                \\\n+  do_arch_entry(x86, compiler, vector_all_bits_set,                     \\\n+                vector_all_bits_set, vector_all_bits_set)               \\\n+  do_stub(compiler, vector_int_mask_cmp_bits)                           \\\n+  do_arch_entry(x86, compiler, vector_int_mask_cmp_bits,                \\\n+                vector_int_mask_cmp_bits, vector_int_mask_cmp_bits)     \\\n+  do_stub(compiler, vector_short_to_byte_mask)                          \\\n+  do_arch_entry(x86, compiler, vector_short_to_byte_mask,               \\\n+                vector_short_to_byte_mask, vector_short_to_byte_mask)   \\\n+  do_stub(compiler, vector_byte_perm_mask)                              \\\n+  do_arch_entry(x86, compiler,vector_byte_perm_mask,                    \\\n+                vector_byte_perm_mask, vector_byte_perm_mask)           \\\n+  do_stub(compiler, vector_int_to_byte_mask)                            \\\n+  do_arch_entry(x86, compiler, vector_int_to_byte_mask,                 \\\n+                vector_int_to_byte_mask, vector_int_to_byte_mask)       \\\n+  do_stub(compiler, vector_int_to_short_mask)                           \\\n+  do_arch_entry(x86, compiler, vector_int_to_short_mask,                \\\n+                vector_int_to_short_mask, vector_int_to_short_mask)     \\\n+  do_stub(compiler, vector_32_bit_mask)                                 \\\n+  do_arch_entry(x86, compiler, vector_32_bit_mask,                      \\\n+                vector_32_bit_mask, vector_32_bit_mask)                 \\\n+  do_stub(compiler, vector_64_bit_mask)                                 \\\n+  do_arch_entry(x86, compiler, vector_64_bit_mask,                      \\\n+                vector_64_bit_mask, vector_64_bit_mask)                 \\\n+  do_stub(compiler, vector_byte_shuffle_mask)                           \\\n+  do_arch_entry(x86, compiler, vector_int_shuffle_mask,                 \\\n+                vector_byte_shuffle_mask, vector_byte_shuffle_mask)     \\\n+  do_stub(compiler, vector_short_shuffle_mask)                          \\\n+  do_arch_entry(x86, compiler, vector_int_shuffle_mask,                 \\\n+                vector_short_shuffle_mask, vector_short_shuffle_mask)   \\\n+  do_stub(compiler, vector_int_shuffle_mask)                            \\\n+  do_arch_entry(x86, compiler, vector_int_shuffle_mask,                 \\\n+                vector_int_shuffle_mask, vector_int_shuffle_mask)       \\\n+  do_stub(compiler, vector_long_shuffle_mask)                           \\\n+  do_arch_entry(x86, compiler, vector_long_shuffle_mask,                \\\n+                vector_long_shuffle_mask, vector_long_shuffle_mask)     \\\n+  do_stub(compiler, vector_long_sign_mask)                              \\\n+  do_arch_entry(x86, compiler, vector_long_sign_mask,                   \\\n+                vector_long_sign_mask, vector_long_sign_mask)           \\\n+  do_stub(compiler, vector_iota_indices)                                \\\n+  do_arch_entry(x86, compiler, vector_iota_indices,                     \\\n+                vector_iota_indices, vector_iota_indices)               \\\n+  do_stub(compiler, vector_count_leading_zeros_lut)                     \\\n+  do_arch_entry(x86, compiler, vector_count_leading_zeros_lut,          \\\n+                vector_count_leading_zeros_lut,                         \\\n+                vector_count_leading_zeros_lut)                         \\\n+  do_stub(compiler, vector_reverse_bit_lut)                             \\\n+  do_arch_entry(x86, compiler, vector_reverse_bit_lut,                  \\\n+                vector_reverse_bit_lut, vector_reverse_bit_lut)         \\\n+  do_stub(compiler, vector_reverse_byte_perm_mask_short)                \\\n+  do_arch_entry(x86, compiler, vector_reverse_byte_perm_mask_short,     \\\n+                vector_reverse_byte_perm_mask_short,                    \\\n+                vector_reverse_byte_perm_mask_short)                    \\\n+  do_stub(compiler, vector_reverse_byte_perm_mask_int)                  \\\n+  do_arch_entry(x86, compiler, vector_reverse_byte_perm_mask_int,       \\\n+                vector_reverse_byte_perm_mask_int,                      \\\n+                vector_reverse_byte_perm_mask_int)                      \\\n+  do_stub(compiler, vector_reverse_byte_perm_mask_long)                 \\\n+  do_arch_entry(x86, compiler, vector_reverse_byte_perm_mask_long,      \\\n+                vector_reverse_byte_perm_mask_long,                     \\\n+                vector_reverse_byte_perm_mask_long)                     \\\n+  do_stub(compiler, vector_popcount_lut)                                \\\n+  do_arch_entry(x86, compiler, vector_popcount_lut,                     \\\n+                vector_popcount_lut, vector_popcount_lut)               \\\n+  do_stub(compiler, upper_word_mask)                                    \\\n+  do_arch_entry(x86, compiler, upper_word_mask, upper_word_mask_addr,   \\\n+                upper_word_mask_addr)                                   \\\n+  do_stub(compiler, shuffle_byte_flip_mask)                             \\\n+  do_arch_entry(x86, compiler, shuffle_byte_flip_mask,                  \\\n+                shuffle_byte_flip_mask_addr,                            \\\n+                shuffle_byte_flip_mask_addr)                            \\\n+  do_stub(compiler, pshuffle_byte_flip_mask)                            \\\n+  do_arch_entry(x86, compiler, pshuffle_byte_flip_mask,                 \\\n+                pshuffle_byte_flip_mask_addr,                           \\\n+                pshuffle_byte_flip_mask_addr)                           \\\n+  LP64_ONLY(                                                            \\\n+    \/* x86_64 exposes these 3 stubs via a generic entry array *\/        \\\n+    \/* oher arches use arch-specific entries *\/                         \\\n+    \/* this really needs rationalising *\/                               \\\n+    do_stub(compiler, string_indexof_linear_ll)                         \\\n+    do_stub(compiler, string_indexof_linear_uu)                         \\\n+    do_stub(compiler, string_indexof_linear_ul)                         \\\n+    do_stub(compiler, pshuffle_byte_flip_mask_sha512)                   \\\n+    do_arch_entry(x86, compiler, pshuffle_byte_flip_mask_sha512,        \\\n+                  pshuffle_byte_flip_mask_addr_sha512,                  \\\n+                  pshuffle_byte_flip_mask_addr_sha512)                  \\\n+    do_stub(compiler, compress_perm_table32)                            \\\n+    do_arch_entry(x86, compiler, compress_perm_table32,                 \\\n+                  compress_perm_table32, compress_perm_table32)         \\\n+    do_stub(compiler, compress_perm_table64)                            \\\n+    do_arch_entry(x86, compiler, compress_perm_table64,                 \\\n+                  compress_perm_table64, compress_perm_table64)         \\\n+    do_stub(compiler, expand_perm_table32)                              \\\n+    do_arch_entry(x86, compiler, expand_perm_table32,                   \\\n+                  expand_perm_table32, expand_perm_table32)             \\\n+    do_stub(compiler, expand_perm_table64)                              \\\n+    do_arch_entry(x86, compiler, expand_perm_table64,                   \\\n+                  expand_perm_table64, expand_perm_table64)             \\\n+    do_stub(compiler, avx2_shuffle_base64)                              \\\n+    do_arch_entry(x86, compiler, avx2_shuffle_base64,                   \\\n+                  avx2_shuffle_base64, base64_avx2_shuffle_addr)        \\\n+    do_stub(compiler, avx2_input_mask_base64)                           \\\n+    do_arch_entry(x86, compiler, avx2_input_mask_base64,                \\\n+                  avx2_input_mask_base64,                               \\\n+                  base64_avx2_input_mask_addr)                          \\\n+    do_stub(compiler, avx2_lut_base64)                                  \\\n+    do_arch_entry(x86, compiler, avx2_lut_base64,                       \\\n+                  avx2_lut_base64, base64_avx2_lut_addr)                \\\n+    do_stub(compiler, avx2_decode_tables_base64)                        \\\n+    do_arch_entry(x86, compiler, avx2_decode_tables_base64,             \\\n+                  avx2_decode_tables_base64,                            \\\n+                  base64_AVX2_decode_tables_addr)                       \\\n+    do_stub(compiler, avx2_decode_lut_tables_base64)                    \\\n+    do_arch_entry(x86, compiler, avx2_decode_lut_tables_base64,         \\\n+                  avx2_decode_lut_tables_base64,                        \\\n+                  base64_AVX2_decode_LUT_tables_addr)                   \\\n+    do_stub(compiler, shuffle_base64)                                   \\\n+    do_arch_entry(x86, compiler, shuffle_base64, shuffle_base64,        \\\n+                  base64_shuffle_addr)                                  \\\n+    do_stub(compiler, lookup_lo_base64)                                 \\\n+    do_arch_entry(x86, compiler, lookup_lo_base64, lookup_lo_base64,    \\\n+                  base64_vbmi_lookup_lo_addr)                           \\\n+    do_stub(compiler, lookup_hi_base64)                                 \\\n+    do_arch_entry(x86, compiler, lookup_hi_base64, lookup_hi_base64,    \\\n+                  base64_vbmi_lookup_hi_addr)                           \\\n+    do_stub(compiler, lookup_lo_base64url)                              \\\n+    do_arch_entry(x86, compiler, lookup_lo_base64url,                   \\\n+                  lookup_lo_base64url,                                  \\\n+                  base64_vbmi_lookup_lo_url_addr)                       \\\n+    do_stub(compiler, lookup_hi_base64url)                              \\\n+    do_arch_entry(x86, compiler, lookup_hi_base64url,                   \\\n+                  lookup_hi_base64url,                                  \\\n+                  base64_vbmi_lookup_hi_url_addr)                       \\\n+    do_stub(compiler, pack_vec_base64)                                  \\\n+    do_arch_entry(x86, compiler, pack_vec_base64, pack_vec_base64,      \\\n+                  base64_vbmi_pack_vec_addr)                            \\\n+    do_stub(compiler, join_0_1_base64)                                  \\\n+    do_arch_entry(x86, compiler, join_0_1_base64, join_0_1_base64,      \\\n+                  base64_vbmi_join_0_1_addr)                            \\\n+    do_stub(compiler, join_1_2_base64)                                  \\\n+    do_arch_entry(x86, compiler, join_1_2_base64, join_1_2_base64,      \\\n+                  base64_vbmi_join_1_2_addr)                            \\\n+    do_stub(compiler, join_2_3_base64)                                  \\\n+    do_arch_entry(x86, compiler, join_2_3_base64, join_2_3_base64,      \\\n+                  base64_vbmi_join_2_3_addr)                            \\\n+    do_stub(compiler, encoding_table_base64)                            \\\n+    do_arch_entry(x86, compiler, encoding_table_base64,                 \\\n+                  encoding_table_base64, base64_encoding_table_addr)    \\\n+    do_stub(compiler, decoding_table_base64)                            \\\n+    do_arch_entry(x86, compiler, decoding_table_base64,                 \\\n+                  decoding_table_base64, base64_decoding_table_addr)    \\\n+  )                                                                     \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \\\n+                                    do_arch_blob,                       \\\n+                                    do_arch_entry,                      \\\n+                                    do_arch_entry_init)                 \\\n+  do_arch_blob(final, 11000 LP64_ONLY(+20000)                           \\\n+               WINDOWS_ONLY(+22000) ZGC_ONLY(+20000))                    \\\n+\n+#endif \/\/ CPU_X86_STUBDECLARATIONS_HPP\n","filename":"src\/hotspot\/cpu\/x86\/stubDeclarations_x86.hpp","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"},{"patch":"@@ -141,1 +141,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"call_stub\");\n+    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -343,1 +344,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"catch_exception\");\n+    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -386,1 +388,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"forward exception\");\n+    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -458,1 +461,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"verify_mxcsr\");\n+    StubGenStubId stub_id = StubGenStubId::verify_mxcsr_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -497,1 +501,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"verify_spcw\");\n+    StubGenStubId stub_id = StubGenStubId::verify_fpu_cntrl_word_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -535,1 +540,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"d2i_wrapper\");\n+    StubGenStubId stub_id = StubGenStubId::d2i_wrapper_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -595,1 +601,1 @@\n-  address generate_vector_mask(const char *stub_name, int32_t mask) {\n+  address generate_vector_mask(StubGenStubId stub_id, int32_t mask) {\n@@ -597,1 +603,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubCodeMark mark(this, stub_id);\n@@ -607,1 +613,1 @@\n-  address generate_count_leading_zeros_lut(const char *stub_name) {\n+  address generate_count_leading_zeros_lut() {\n@@ -609,1 +615,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_count_leading_zeros_lut_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -631,1 +638,1 @@\n-  address generate_popcount_avx_lut(const char *stub_name) {\n+  address generate_popcount_avx_lut() {\n@@ -633,1 +640,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_popcount_lut_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -655,1 +663,1 @@\n-  address generate_iota_indices(const char *stub_name) {\n+  address generate_iota_indices() {\n@@ -657,1 +665,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_iota_indices_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -769,1 +778,1 @@\n-  address generate_vector_reverse_bit_lut(const char *stub_name) {\n+  address generate_vector_reverse_bit_lut() {\n@@ -771,1 +780,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_reverse_bit_lut_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -792,1 +802,1 @@\n-  address generate_vector_reverse_byte_perm_mask_long(const char *stub_name) {\n+  address generate_vector_reverse_byte_perm_mask_long() {\n@@ -794,1 +804,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_long_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -815,1 +826,1 @@\n-  address generate_vector_reverse_byte_perm_mask_int(const char *stub_name) {\n+  address generate_vector_reverse_byte_perm_mask_int() {\n@@ -817,1 +828,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_int_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -838,1 +850,1 @@\n-  address generate_vector_reverse_byte_perm_mask_short(const char *stub_name) {\n+  address generate_vector_reverse_byte_perm_mask_short() {\n@@ -840,1 +852,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_short_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -861,1 +874,1 @@\n-  address generate_vector_byte_shuffle_mask(const char *stub_name) {\n+  address generate_vector_byte_shuffle_mask() {\n@@ -863,1 +876,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_byte_shuffle_mask_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -876,1 +890,1 @@\n-  address generate_vector_mask_long_double(const char *stub_name, int32_t maskhi, int32_t masklo) {\n+  address generate_vector_mask_long_double(StubGenStubId stub_id, int32_t maskhi, int32_t masklo) {\n@@ -878,1 +892,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubCodeMark mark(this, stub_id);\n@@ -891,1 +905,1 @@\n-  address generate_vector_byte_perm_mask(const char *stub_name) {\n+  address generate_vector_byte_perm_mask() {\n@@ -893,1 +907,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_byte_perm_mask_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -916,1 +931,1 @@\n-  address generate_vector_custom_i32(const char *stub_name, Assembler::AvxVectorLen len,\n+  address generate_vector_custom_i32(StubGenStubId stub_id, Assembler::AvxVectorLen len,\n@@ -922,1 +937,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubCodeMark mark(this, stub_id);\n@@ -954,1 +969,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"verify_oop\");\n+    StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1086,4 +1102,74 @@\n-  address generate_disjoint_copy(BasicType t, bool aligned,\n-                                 Address::ScaleFactor sf,\n-                                 address* entry, const char *name,\n-                                 bool dest_uninitialized = false) {\n+  address generate_disjoint_copy(StubGenStubId stub_id, address* entry) {\n+    BasicType t;\n+    bool aligned;\n+    Address::ScaleFactor sf;\n+    bool dest_uninitialized;\n+\n+    switch (stub_id) {\n+    case jbyte_disjoint_arraycopy_id:\n+      t = T_BYTE;\n+      aligned = false;\n+      sf = Address::times_1;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jbyte_disjoint_arraycopy_id:\n+      t = T_BYTE;\n+      aligned = true;\n+      sf = Address::times_1;\n+      dest_uninitialized = false;\n+      break;\n+    case jshort_disjoint_arraycopy_id:\n+      t = T_SHORT;\n+      aligned = false;\n+      sf = Address::times_2;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jshort_disjoint_arraycopy_id:\n+      t = T_SHORT;\n+      aligned = true;\n+      sf = Address::times_2;\n+      dest_uninitialized = false;\n+      break;\n+    case jint_disjoint_arraycopy_id:\n+      t = T_INT;\n+      aligned = true;\n+      sf = Address::times_4;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jint_disjoint_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case jint_disjoint_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case jlong_disjoint_arraycopy_id:\n+    case arrayof_jlong_disjoint_arraycopy_id:\n+      \/\/ Handled by a special generator routine on 32 bit\n+      ShouldNotReachHere();\n+      break;\n+    case oop_disjoint_arraycopy_id:\n+      t = T_OBJECT;\n+      aligned = true;\n+      sf = Address::times_ptr;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case oop_disjoint_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case oop_disjoint_arraycopy_uninit_id:\n+      t = T_OBJECT;\n+      aligned = true;\n+      sf = Address::times_ptr;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case oop_disjoint_arraycopy_uninit\n+      ShouldNotReachHere();\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+    }\n+\n@@ -1091,1 +1177,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1234,1 +1320,33 @@\n-  address generate_fill(BasicType t, bool aligned, const char *name) {\n+  address generate_fill(StubGenStubId stub_id) {\n+    BasicType t;\n+    bool aligned;\n+    switch(stub_id) {\n+    case jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = false;\n+      break;\n+    case jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = false;\n+      break;\n+    case jint_fill_id:\n+      t = T_INT;\n+      aligned = false;\n+      break;\n+    case arrayof_jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = true;\n+      break;\n+    case arrayof_jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = true;\n+      break;\n+    case arrayof_jint_fill_id:\n+      t = T_INT;\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+    }\n+\n@@ -1236,1 +1354,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1261,2 +1379,1 @@\n-  address generate_conjoint_copy(BasicType t, bool aligned,\n-                                 Address::ScaleFactor sf,\n+  address generate_conjoint_copy(StubGenStubId stub_id,\n@@ -1264,2 +1381,74 @@\n-                                 address* entry, const char *name,\n-                                 bool dest_uninitialized = false) {\n+                                 address* entry) {\n+    BasicType t;\n+    bool aligned;\n+    Address::ScaleFactor sf;\n+    bool dest_uninitialized;\n+\n+    switch (stub_id) {\n+    case jbyte_arraycopy_id:\n+      t = T_BYTE;\n+      aligned = false;\n+      sf = Address::times_1;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jbyte_arraycopy_id:\n+      t = T_BYTE;\n+      aligned = true;\n+      sf = Address::times_1;\n+      dest_uninitialized = false;\n+      break;\n+    case jshort_arraycopy_id:\n+      t = T_SHORT;\n+      aligned = false;\n+      sf = Address::times_2;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jshort_arraycopy_id:\n+      t = T_SHORT;\n+      aligned = true;\n+      sf = Address::times_2;\n+      dest_uninitialized = false;\n+      break;\n+    case jint_arraycopy_id:\n+      t = T_INT;\n+      aligned = true;\n+      sf = Address::times_4;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jint_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case jint_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case jlong_arraycopy_id:\n+    case arrayof_jlong_arraycopy_id:\n+      \/\/ Handled by a special generator routine on 32 bit\n+      ShouldNotReachHere();\n+      break;\n+    case oop_arraycopy_id:\n+      t = T_OBJECT;\n+      aligned = true;\n+      sf = Address::times_ptr;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case oop_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case oop_arraycopy_uninit_id:\n+      t = T_OBJECT;\n+      aligned = true;\n+      sf = Address::times_ptr;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_arraycopy_uninit_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case oop_arraycopy_uninit\n+      ShouldNotReachHere();\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+    }\n+\n@@ -1267,1 +1456,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1433,1 +1622,1 @@\n-  address generate_disjoint_long_copy(address* entry, const char *name) {\n+  address generate_disjoint_long_copy(address* entry) {\n@@ -1435,1 +1624,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::jlong_disjoint_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1478,2 +1668,1 @@\n-  address generate_conjoint_long_copy(address nooverlap_target,\n-                                      address* entry, const char *name) {\n+  address generate_conjoint_long_copy(address nooverlap_target, address* entry) {\n@@ -1481,1 +1670,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::jlong_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1602,1 +1792,13 @@\n-  address generate_checkcast_copy(const char *name, address* entry, bool dest_uninitialized = false) {\n+  address generate_checkcast_copy(StubGenStubId stub_id, address* entry) {\n+    bool dest_uninitialized;\n+    switch(stub_id) {\n+    case checkcast_arraycopy_id:\n+      dest_uninitialized = false;\n+      break;\n+    case checkcast_arraycopy_uninit_id:\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -1604,1 +1806,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1759,2 +1961,1 @@\n-  address generate_unsafe_copy(const char *name,\n-                               address byte_copy_entry,\n+  address generate_unsafe_copy(address byte_copy_entry,\n@@ -1768,1 +1969,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1865,2 +2067,1 @@\n-  address generate_generic_copy(const char *name,\n-                                address entry_jbyte_arraycopy,\n+  address generate_generic_copy(address entry_jbyte_arraycopy,\n@@ -1880,1 +2081,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2193,2 +2395,1 @@\n-        generate_disjoint_copy(T_BYTE,  true, Address::times_1, &entry,\n-                               \"arrayof_jbyte_disjoint_arraycopy\");\n+        generate_disjoint_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id, &entry);\n@@ -2196,2 +2397,1 @@\n-        generate_conjoint_copy(T_BYTE,  true, Address::times_1,  entry,\n-                               nullptr, \"arrayof_jbyte_arraycopy\");\n+        generate_conjoint_copy(StubGenStubId::arrayof_jbyte_arraycopy_id, entry, nullptr);\n@@ -2199,2 +2399,1 @@\n-        generate_disjoint_copy(T_BYTE, false, Address::times_1, &entry,\n-                               \"jbyte_disjoint_arraycopy\");\n+      generate_disjoint_copy(StubGenStubId::jbyte_disjoint_arraycopy_id, &entry);\n@@ -2202,2 +2401,1 @@\n-        generate_conjoint_copy(T_BYTE, false, Address::times_1,  entry,\n-                               &entry_jbyte_arraycopy, \"jbyte_arraycopy\");\n+        generate_conjoint_copy(StubGenStubId::jbyte_arraycopy_id,  entry, &entry_jbyte_arraycopy);\n@@ -2206,2 +2404,1 @@\n-        generate_disjoint_copy(T_SHORT,  true, Address::times_2, &entry,\n-                               \"arrayof_jshort_disjoint_arraycopy\");\n+        generate_disjoint_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id, &entry);\n@@ -2209,2 +2406,1 @@\n-        generate_conjoint_copy(T_SHORT,  true, Address::times_2,  entry,\n-                               nullptr, \"arrayof_jshort_arraycopy\");\n+        generate_conjoint_copy(StubGenStubId::arrayof_jshort_arraycopy_id, entry, nullptr);\n@@ -2212,2 +2408,1 @@\n-        generate_disjoint_copy(T_SHORT, false, Address::times_2, &entry,\n-                               \"jshort_disjoint_arraycopy\");\n+        generate_disjoint_copy(StubGenStubId::jshort_disjoint_arraycopy_id, &entry);\n@@ -2215,2 +2410,1 @@\n-        generate_conjoint_copy(T_SHORT, false, Address::times_2,  entry,\n-                               &entry_jshort_arraycopy, \"jshort_arraycopy\");\n+        generate_conjoint_copy(StubGenStubId::jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n@@ -2220,2 +2414,1 @@\n-        generate_disjoint_copy(T_INT, true, Address::times_4, &entry,\n-                               \"jint_disjoint_arraycopy\");\n+        generate_disjoint_copy(StubGenStubId::jint_disjoint_arraycopy_id, &entry);\n@@ -2223,2 +2416,1 @@\n-        generate_conjoint_copy(T_INT, true, Address::times_4,  entry,\n-                               &entry_jint_arraycopy, \"jint_arraycopy\");\n+        generate_conjoint_copy(StubGenStubId::jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2227,2 +2419,1 @@\n-        generate_disjoint_copy(T_OBJECT, true, Address::times_ptr, &entry,\n-                               \"oop_disjoint_arraycopy\");\n+        generate_disjoint_copy(StubGenStubId::oop_disjoint_arraycopy_id, &entry);\n@@ -2230,2 +2421,1 @@\n-        generate_conjoint_copy(T_OBJECT, true, Address::times_ptr,  entry,\n-                               &entry_oop_arraycopy, \"oop_arraycopy\");\n+        generate_conjoint_copy(StubGenStubId::oop_arraycopy_id, entry, &entry_oop_arraycopy);\n@@ -2234,3 +2424,1 @@\n-        generate_disjoint_copy(T_OBJECT, true, Address::times_ptr, &entry,\n-                               \"oop_disjoint_arraycopy_uninit\",\n-                               \/*dest_uninitialized*\/true);\n+        generate_disjoint_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id, &entry);\n@@ -2238,3 +2426,1 @@\n-        generate_conjoint_copy(T_OBJECT, true, Address::times_ptr,  entry,\n-                               nullptr, \"oop_arraycopy_uninit\",\n-                               \/*dest_uninitialized*\/true);\n+        generate_conjoint_copy(StubGenStubId::oop_arraycopy_uninit_id, entry, nullptr);\n@@ -2243,1 +2429,1 @@\n-        generate_disjoint_long_copy(&entry, \"jlong_disjoint_arraycopy\");\n+        generate_disjoint_long_copy(&entry);\n@@ -2245,2 +2431,1 @@\n-        generate_conjoint_long_copy(entry, &entry_jlong_arraycopy,\n-                                    \"jlong_arraycopy\");\n+        generate_conjoint_long_copy(entry, &entry_jlong_arraycopy);\n@@ -2248,6 +2433,6 @@\n-    StubRoutines::_jbyte_fill = generate_fill(T_BYTE, false, \"jbyte_fill\");\n-    StubRoutines::_jshort_fill = generate_fill(T_SHORT, false, \"jshort_fill\");\n-    StubRoutines::_jint_fill = generate_fill(T_INT, false, \"jint_fill\");\n-    StubRoutines::_arrayof_jbyte_fill = generate_fill(T_BYTE, true, \"arrayof_jbyte_fill\");\n-    StubRoutines::_arrayof_jshort_fill = generate_fill(T_SHORT, true, \"arrayof_jshort_fill\");\n-    StubRoutines::_arrayof_jint_fill = generate_fill(T_INT, true, \"arrayof_jint_fill\");\n+    StubRoutines::_jbyte_fill = generate_fill(StubGenStubId::jbyte_fill_id);\n+    StubRoutines::_jshort_fill = generate_fill(StubGenStubId::jshort_fill_id);\n+    StubRoutines::_jint_fill = generate_fill(StubGenStubId::jint_fill_id);\n+    StubRoutines::_arrayof_jbyte_fill = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n+    StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n+    StubRoutines::_arrayof_jint_fill = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n@@ -2266,1 +2451,1 @@\n-        generate_checkcast_copy(\"checkcast_arraycopy\", &entry_checkcast_arraycopy);\n+      generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n@@ -2268,1 +2453,1 @@\n-        generate_checkcast_copy(\"checkcast_arraycopy_uninit\", nullptr, \/*dest_uninitialized*\/true);\n+      generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id, nullptr);\n@@ -2271,5 +2456,4 @@\n-        generate_unsafe_copy(\"unsafe_arraycopy\",\n-                               entry_jbyte_arraycopy,\n-                               entry_jshort_arraycopy,\n-                               entry_jint_arraycopy,\n-                               entry_jlong_arraycopy);\n+        generate_unsafe_copy(entry_jbyte_arraycopy,\n+                             entry_jshort_arraycopy,\n+                             entry_jint_arraycopy,\n+                             entry_jlong_arraycopy);\n@@ -2278,2 +2462,1 @@\n-        generate_generic_copy(\"generic_arraycopy\",\n-                               entry_jbyte_arraycopy,\n+        generate_generic_copy( entry_jbyte_arraycopy,\n@@ -2359,1 +2542,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_encryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2458,1 +2642,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_decryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2582,1 +2767,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_encryptAESCrypt\");\n+    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2740,1 +2926,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_decryptAESCrypt\");\n+    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2913,1 +3100,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"counterMode_AESCrypt\");\n+    StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3195,1 +3383,13 @@\n-  address generate_md5_implCompress(bool multi_block, const char *name) {\n+  address generate_md5_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch(stub_id) {\n+    case StubGenStubId::md5_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case StubGenStubId::md5_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -3197,1 +3397,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -3235,1 +3435,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upper_word_mask\");\n+    StubGenStubId stub_id = StubGenStubId::upper_word_mask_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3246,1 +3447,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"shuffle_byte_flip_mask\");\n+    StubGenStubId stub_id = StubGenStubId::shuffle_byte_flip_mask_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3257,1 +3459,13 @@\n-  address generate_sha1_implCompress(bool multi_block, const char *name) {\n+  address generate_sha1_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch(stub_id) {\n+    case StubGenStubId::sha1_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case StubGenStubId::sha1_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -3259,1 +3473,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -3305,1 +3519,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"pshuffle_byte_flip_mask\");\n+    StubGenStubId stub_id = StubGenStubId::pshuffle_byte_flip_mask_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3316,1 +3531,13 @@\n- address generate_sha256_implCompress(bool multi_block, const char *name) {\n+ address generate_sha256_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch(stub_id) {\n+    case StubGenStubId::sha256_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case StubGenStubId::sha256_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -3318,1 +3545,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -3376,1 +3603,3 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"ghash_processBlocks\");\n+    StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+    StubCodeMark mark(this, stub_id);\n+\n@@ -3524,1 +3753,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32\");\n+    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3579,1 +3809,3 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32C\");\n+    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32C_id;\n+    StubCodeMark mark(this, stub_id);\n+\n@@ -3622,1 +3854,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"libmExp\");\n+    StubGenStubId stub_id = StubGenStubId::dexp_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3638,1 +3871,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libmLog\");\n+   StubGenStubId stub_id = StubGenStubId::dlog_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3654,1 +3888,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libmLog10\");\n+   StubGenStubId stub_id = StubGenStubId::dlog10_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3670,1 +3905,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libmPow\");\n+   StubGenStubId stub_id = StubGenStubId::dpow_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3686,1 +3922,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libm_reduce_pi04l\");\n+   StubGenStubId stub_id = StubGenStubId::dlibm_reduce_pi04l_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3698,1 +3935,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libm_sin_cos_huge\");\n+   StubGenStubId stub_id = StubGenStubId::dlibm_sin_cos_huge_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3710,1 +3948,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libmSin\");\n+   StubGenStubId stub_id = StubGenStubId::dsin_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3726,1 +3965,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libmCos\");\n+   StubGenStubId stub_id = StubGenStubId::dcos_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3742,1 +3982,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libm_tan_cot_huge\");\n+   StubGenStubId stub_id = StubGenStubId::dlibm_tan_cot_huge_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3754,1 +3995,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libmTan\");\n+   StubGenStubId stub_id = StubGenStubId::dtan_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3771,1 +4013,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3991,8 +4234,8 @@\n-    StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(\"vector_float_sign_mask\", 0x7FFFFFFF);\n-    StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(\"vector_float_sign_flip\", 0x80000000);\n-    StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask_long_double(\"vector_double_sign_mask\", 0x7FFFFFFF, 0xFFFFFFFF);\n-    StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask_long_double(\"vector_double_sign_flip\", 0x80000000, 0x00000000);\n-    StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(\"vector_short_to_byte_mask\", 0x00ff00ff);\n-    StubRoutines::x86::_vector_int_to_byte_mask = generate_vector_mask(\"vector_int_to_byte_mask\", 0x000000ff);\n-    StubRoutines::x86::_vector_int_to_short_mask = generate_vector_mask(\"vector_int_to_short_mask\", 0x0000ffff);\n-    StubRoutines::x86::_vector_32_bit_mask = generate_vector_custom_i32(\"vector_32_bit_mask\", Assembler::AVX_512bit,\n+    StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(StubGenStubId::vector_float_sign_mask_id, 0x7FFFFFFF);\n+    StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(StubGenStubId::vector_float_sign_flip_id, 0x80000000);\n+    StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask_long_double(StubGenStubId::vector_double_sign_mask_id, 0x7FFFFFFF, 0xFFFFFFFF);\n+    StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask_long_double(StubGenStubId::vector_double_sign_flip_id, 0x80000000, 0x00000000);\n+    StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(StubGenStubId::vector_short_to_byte_mask_id, 0x00ff00ff);\n+    StubRoutines::x86::_vector_int_to_byte_mask = generate_vector_mask(StubGenStubId::vector_int_to_byte_mask_id, 0x000000ff);\n+    StubRoutines::x86::_vector_int_to_short_mask = generate_vector_mask(StubGenStubId::vector_int_to_short_mask_id, 0x0000ffff);\n+    StubRoutines::x86::_vector_32_bit_mask = generate_vector_custom_i32(StubGenStubId::vector_32_bit_mask_id, Assembler::AVX_512bit,\n@@ -4000,1 +4243,1 @@\n-    StubRoutines::x86::_vector_64_bit_mask = generate_vector_custom_i32(\"vector_64_bit_mask\", Assembler::AVX_512bit,\n+    StubRoutines::x86::_vector_64_bit_mask = generate_vector_custom_i32(StubGenStubId::vector_64_bit_mask_id, Assembler::AVX_512bit,\n@@ -4002,14 +4245,14 @@\n-    StubRoutines::x86::_vector_int_shuffle_mask = generate_vector_mask(\"vector_int_shuffle_mask\", 0x03020100);\n-    StubRoutines::x86::_vector_byte_shuffle_mask = generate_vector_byte_shuffle_mask(\"vector_byte_shuffle_mask\");\n-    StubRoutines::x86::_vector_short_shuffle_mask = generate_vector_mask(\"vector_short_shuffle_mask\", 0x01000100);\n-    StubRoutines::x86::_vector_long_shuffle_mask = generate_vector_mask_long_double(\"vector_long_shuffle_mask\", 0x00000001, 0x0);\n-    StubRoutines::x86::_vector_byte_perm_mask = generate_vector_byte_perm_mask(\"vector_byte_perm_mask\");\n-    StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask_long_double(\"vector_long_sign_mask\", 0x80000000, 0x00000000);\n-    StubRoutines::x86::_vector_all_bits_set = generate_vector_mask(\"vector_all_bits_set\", 0xFFFFFFFF);\n-    StubRoutines::x86::_vector_int_mask_cmp_bits = generate_vector_mask(\"vector_int_mask_cmp_bits\", 0x00000001);\n-    StubRoutines::x86::_vector_iota_indices = generate_iota_indices(\"iota_indices\");\n-    StubRoutines::x86::_vector_count_leading_zeros_lut = generate_count_leading_zeros_lut(\"count_leading_zeros_lut\");\n-    StubRoutines::x86::_vector_reverse_bit_lut = generate_vector_reverse_bit_lut(\"reverse_bit_lut\");\n-    StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long(\"perm_mask_long\");\n-    StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int(\"perm_mask_int\");\n-    StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short(\"perm_mask_short\");\n+    StubRoutines::x86::_vector_int_shuffle_mask = generate_vector_mask(StubGenStubId::vector_int_shuffle_mask_id, 0x03020100);\n+    StubRoutines::x86::_vector_byte_shuffle_mask = generate_vector_byte_shuffle_mask();\n+    StubRoutines::x86::_vector_short_shuffle_mask = generate_vector_mask(StubGenStubId::vector_short_shuffle_mask_id, 0x01000100);\n+    StubRoutines::x86::_vector_long_shuffle_mask = generate_vector_mask_long_double(StubGenStubId::vector_long_shuffle_mask_id, 0x00000001, 0x0);\n+    StubRoutines::x86::_vector_byte_perm_mask = generate_vector_byte_perm_mask();\n+    StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask_long_double(StubGenStubId::vector_long_sign_mask_id, 0x80000000, 0x00000000);\n+    StubRoutines::x86::_vector_all_bits_set = generate_vector_mask(StubGenStubId::vector_all_bits_set_id, 0xFFFFFFFF);\n+    StubRoutines::x86::_vector_int_mask_cmp_bits = generate_vector_mask(StubGenStubId::vector_int_mask_cmp_bits_id, 0x00000001);\n+    StubRoutines::x86::_vector_iota_indices = generate_iota_indices();\n+    StubRoutines::x86::_vector_count_leading_zeros_lut = generate_count_leading_zeros_lut();\n+    StubRoutines::x86::_vector_reverse_bit_lut = generate_vector_reverse_bit_lut();\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long();\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int();\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short();\n@@ -4019,1 +4262,1 @@\n-      StubRoutines::x86::_vector_popcount_lut = generate_popcount_avx_lut(\"popcount_lut\");\n+      StubRoutines::x86::_vector_popcount_lut = generate_popcount_avx_lut();\n@@ -4035,2 +4278,2 @@\n-      StubRoutines::_md5_implCompress = generate_md5_implCompress(false, \"md5_implCompress\");\n-      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(true, \"md5_implCompressMB\");\n+      StubRoutines::_md5_implCompress = generate_md5_implCompress(StubGenStubId::md5_implCompress_id);\n+      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(StubGenStubId::md5_implCompressMB_id);\n@@ -4041,2 +4284,2 @@\n-      StubRoutines::_sha1_implCompress = generate_sha1_implCompress(false, \"sha1_implCompress\");\n-      StubRoutines::_sha1_implCompressMB = generate_sha1_implCompress(true, \"sha1_implCompressMB\");\n+      StubRoutines::_sha1_implCompress = generate_sha1_implCompress(StubGenStubId::sha1_implCompress_id);\n+      StubRoutines::_sha1_implCompressMB = generate_sha1_implCompress(StubGenStubId::sha1_implCompressMB_id);\n@@ -4047,2 +4290,2 @@\n-      StubRoutines::_sha256_implCompress = generate_sha256_implCompress(false, \"sha256_implCompress\");\n-      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(true, \"sha256_implCompressMB\");\n+      StubRoutines::_sha256_implCompress = generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n@@ -4060,3 +4303,3 @@\n-  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    switch(kind) {\n-    case Initial_stubs:\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+    switch(blob_id) {\n+    case initial_id:\n@@ -4065,1 +4308,1 @@\n-     case Continuation_stubs:\n+     case continuation_id:\n@@ -4068,1 +4311,1 @@\n-    case Compiler_stubs:\n+    case compiler_id:\n@@ -4071,1 +4314,1 @@\n-    case Final_stubs:\n+    case final_id:\n@@ -4075,1 +4318,1 @@\n-      fatal(\"unexpected stubs kind: %d\", kind);\n+      fatal(\"unexpected blob id: %d\", blob_id);\n@@ -4081,2 +4324,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":414,"deletions":171,"binary":false,"changes":585,"status":"modified"},{"patch":"@@ -191,1 +191,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"call_stub\");\n+  StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -416,1 +417,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"catch_exception\");\n+  StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -471,1 +473,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"forward exception\");\n+  StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -534,1 +537,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"orderaccess_fence\");\n+  StubGenStubId stub_id = StubGenStubId::fence_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -549,1 +553,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"get_previous_sp\");\n+  StubGenStubId stub_id = StubGenStubId::get_previous_sp_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -567,1 +572,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"verify_mxcsr\");\n+  StubGenStubId stub_id = StubGenStubId::verify_mxcsr_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -598,1 +604,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"f2i_fixup\");\n+  StubGenStubId stub_id = StubGenStubId::f2i_fixup_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -636,1 +643,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"f2l_fixup\");\n+  StubGenStubId stub_id = StubGenStubId::f2l_fixup_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -673,1 +681,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"d2i_fixup\");\n+  StubGenStubId stub_id = StubGenStubId::d2i_fixup_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -720,1 +729,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"d2l_fixup\");\n+  StubGenStubId stub_id = StubGenStubId::d2l_fixup_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -766,1 +776,1 @@\n-address StubGenerator::generate_count_leading_zeros_lut(const char *stub_name) {\n+address StubGenerator::generate_count_leading_zeros_lut() {\n@@ -768,1 +778,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_count_leading_zeros_lut_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -783,1 +794,1 @@\n-address StubGenerator::generate_popcount_avx_lut(const char *stub_name) {\n+address StubGenerator::generate_popcount_avx_lut() {\n@@ -785,1 +796,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_popcount_lut_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -800,1 +812,1 @@\n-address StubGenerator::generate_iota_indices(const char *stub_name) {\n+address StubGenerator::generate_iota_indices() {\n@@ -802,1 +814,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_iota_indices_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -861,1 +874,1 @@\n-address StubGenerator::generate_vector_reverse_bit_lut(const char *stub_name) {\n+address StubGenerator::generate_vector_reverse_bit_lut() {\n@@ -863,1 +876,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_reverse_bit_lut_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -878,1 +892,1 @@\n-address StubGenerator::generate_vector_reverse_byte_perm_mask_long(const char *stub_name) {\n+address StubGenerator::generate_vector_reverse_byte_perm_mask_long() {\n@@ -880,1 +894,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_long_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -895,1 +910,1 @@\n-address StubGenerator::generate_vector_reverse_byte_perm_mask_int(const char *stub_name) {\n+address StubGenerator::generate_vector_reverse_byte_perm_mask_int() {\n@@ -897,1 +912,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_int_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -912,1 +928,1 @@\n-address StubGenerator::generate_vector_reverse_byte_perm_mask_short(const char *stub_name) {\n+address StubGenerator::generate_vector_reverse_byte_perm_mask_short() {\n@@ -914,1 +930,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_short_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -929,1 +946,1 @@\n-address StubGenerator::generate_vector_byte_shuffle_mask(const char *stub_name) {\n+address StubGenerator::generate_vector_byte_shuffle_mask() {\n@@ -931,1 +948,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_byte_shuffle_mask_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -942,1 +960,1 @@\n-address StubGenerator::generate_fp_mask(const char *stub_name, int64_t mask) {\n+address StubGenerator::generate_fp_mask(StubGenStubId stub_id, int64_t mask) {\n@@ -944,1 +962,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubCodeMark mark(this, stub_id);\n@@ -953,1 +971,12 @@\n-address StubGenerator::generate_compress_perm_table(const char *stub_name, int32_t esize) {\n+address StubGenerator::generate_compress_perm_table(StubGenStubId stub_id) {\n+  int esize;\n+  switch (stub_id) {\n+  case compress_perm_table32_id:\n+    esize = 32;\n+    break;\n+  case compress_perm_table64_id:\n+    esize = 64;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n@@ -955,1 +984,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubCodeMark mark(this, stub_id);\n@@ -997,1 +1026,12 @@\n-address StubGenerator::generate_expand_perm_table(const char *stub_name, int32_t esize) {\n+address StubGenerator::generate_expand_perm_table(StubGenStubId stub_id) {\n+  int esize;\n+  switch (stub_id) {\n+  case expand_perm_table32_id:\n+    esize = 32;\n+    break;\n+  case expand_perm_table64_id:\n+    esize = 64;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n@@ -999,1 +1039,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1039,1 +1079,1 @@\n-address StubGenerator::generate_vector_mask(const char *stub_name, int64_t mask) {\n+address StubGenerator::generate_vector_mask(StubGenStubId stub_id, int64_t mask) {\n@@ -1041,1 +1081,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1056,1 +1096,1 @@\n-address StubGenerator::generate_vector_byte_perm_mask(const char *stub_name) {\n+address StubGenerator::generate_vector_byte_perm_mask() {\n@@ -1058,1 +1098,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_byte_perm_mask_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1073,1 +1114,1 @@\n-address StubGenerator::generate_vector_fp_mask(const char *stub_name, int64_t mask) {\n+address StubGenerator::generate_vector_fp_mask(StubGenStubId stub_id, int64_t mask) {\n@@ -1075,1 +1116,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1090,1 +1131,1 @@\n-address StubGenerator::generate_vector_custom_i32(const char *stub_name, Assembler::AvxVectorLen len,\n+address StubGenerator::generate_vector_custom_i32(StubGenStubId stub_id, Assembler::AvxVectorLen len,\n@@ -1096,1 +1137,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1140,1 +1181,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"verify_oop\");\n+  StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1337,1 +1379,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"_data_cache_writeback\");\n+  StubGenStubId stub_id = StubGenStubId::data_cache_writeback_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1354,1 +1397,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"_data_cache_writeback_sync\");\n+  StubGenStubId stub_id = StubGenStubId::data_cache_writeback_sync_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1375,1 +1419,12 @@\n-address StubGenerator::generate_md5_implCompress(bool multi_block, const char *name) {\n+address StubGenerator::generate_md5_implCompress(StubGenStubId stub_id) {\n+  bool multi_block;\n+  switch (stub_id) {\n+  case md5_implCompress_id:\n+    multi_block = false;\n+    break;\n+  case md5_implCompressMB_id:\n+    multi_block = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n@@ -1377,1 +1432,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1413,1 +1468,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"upper_word_mask\");\n+  StubGenStubId stub_id = StubGenStubId::upper_word_mask_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1424,1 +1480,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"shuffle_byte_flip_mask\");\n+  StubGenStubId stub_id = StubGenStubId::shuffle_byte_flip_mask_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1435,1 +1492,12 @@\n-address StubGenerator::generate_sha1_implCompress(bool multi_block, const char *name) {\n+address StubGenerator::generate_sha1_implCompress(StubGenStubId stub_id) {\n+  bool multi_block;\n+  switch (stub_id) {\n+  case sha1_implCompress_id:\n+    multi_block = false;\n+    break;\n+  case sha1_implCompressMB_id:\n+    multi_block = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n@@ -1437,1 +1505,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1472,1 +1540,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"pshuffle_byte_flip_mask\");\n+  StubGenStubId stub_id = StubGenStubId::pshuffle_byte_flip_mask_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1499,1 +1568,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"pshuffle_byte_flip_mask_sha512\");\n+  StubGenStubId stub_id = StubGenStubId::pshuffle_byte_flip_mask_sha512_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1518,1 +1588,12 @@\n-address StubGenerator::generate_sha256_implCompress(bool multi_block, const char *name) {\n+address StubGenerator::generate_sha256_implCompress(StubGenStubId stub_id) {\n+  bool multi_block;\n+  switch (stub_id) {\n+  case sha256_implCompress_id:\n+    multi_block = false;\n+    break;\n+  case sha256_implCompressMB_id:\n+    multi_block = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n@@ -1521,1 +1602,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1560,1 +1641,12 @@\n-address StubGenerator::generate_sha512_implCompress(bool multi_block, const char *name) {\n+address StubGenerator::generate_sha512_implCompress(StubGenStubId stub_id) {\n+  bool multi_block;\n+  switch (stub_id) {\n+  case sha512_implCompress_id:\n+    multi_block = false;\n+    break;\n+  case sha512_implCompressMB_id:\n+    multi_block = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n@@ -1564,1 +1656,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1599,1 +1691,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"shuffle_base64\");\n+  StubGenStubId stub_id = StubGenStubId::shuffle_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1618,1 +1711,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"avx2_shuffle_base64\");\n+  StubGenStubId stub_id = StubGenStubId::avx2_shuffle_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1631,1 +1725,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"avx2_input_mask_base64\");\n+  StubGenStubId stub_id = StubGenStubId::avx2_input_mask_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1644,1 +1739,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"avx2_lut_base64\");\n+  StubGenStubId stub_id = StubGenStubId::avx2_lut_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1663,1 +1759,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"encoding_table_base64\");\n+  StubGenStubId stub_id = StubGenStubId::encoding_table_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1696,1 +1793,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"implEncode\");\n+  StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2078,1 +2176,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"lookup_lo_base64\");\n+  StubGenStubId stub_id = StubGenStubId::lookup_lo_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2097,1 +2196,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"lookup_hi_base64\");\n+  StubGenStubId stub_id = StubGenStubId::lookup_hi_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2115,1 +2215,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"lookup_lo_base64url\");\n+  StubGenStubId stub_id = StubGenStubId::lookup_lo_base64url_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2134,1 +2235,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"lookup_hi_base64url\");\n+  StubGenStubId stub_id = StubGenStubId::lookup_hi_base64url_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2153,1 +2255,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"pack_vec_base64\");\n+  StubGenStubId stub_id = StubGenStubId::pack_vec_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2172,1 +2275,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"join_0_1_base64\");\n+  StubGenStubId stub_id = StubGenStubId::join_0_1_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2191,1 +2295,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"join_1_2_base64\");\n+  StubGenStubId stub_id = StubGenStubId::join_1_2_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2210,1 +2315,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"join_2_3_base64\");\n+  StubGenStubId stub_id = StubGenStubId::join_2_3_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2229,1 +2335,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"AVX2_tables_base64\");\n+  StubGenStubId stub_id = StubGenStubId::avx2_decode_tables_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2263,1 +2370,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"AVX2_tables_URL_base64\");\n+  StubGenStubId stub_id = StubGenStubId::avx2_decode_lut_tables_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2302,1 +2410,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"decoding_table_base64\");\n+  StubGenStubId stub_id = StubGenStubId::decoding_table_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2384,1 +2493,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"implDecode\");\n+  StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2917,1 +3027,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32\");\n+  StubGenStubId stub_id = StubGenStubId::updateBytesCRC32_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2973,1 +3084,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32C\");\n+  StubGenStubId stub_id = StubGenStubId::updateBytesCRC32C_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3053,1 +3165,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"multiplyToLen\");\n+  StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3109,1 +3222,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"vectorizedMismatch\");\n+  StubGenStubId stub_id = StubGenStubId::vectorizedMismatch_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3160,1 +3274,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"squareToLen\");\n+  StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3195,1 +3310,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+  StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3284,1 +3400,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"mulAdd\");\n+  StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3325,1 +3442,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"bigIntegerRightShiftWorker\");\n+  StubGenStubId stub_id = StubGenStubId::bigIntegerRightShiftWorker_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3460,1 +3578,2 @@\n-  StubCodeMark mark(this,  \"StubRoutines\", \"bigIntegerLeftShiftWorker\");\n+  StubGenStubId stub_id = StubGenStubId::bigIntegerLeftShiftWorker_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3608,1 +3727,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"float16ToFloat\");\n+  StubGenStubId stub_id = StubGenStubId::hf2f_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3633,1 +3753,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"floatToFloat16\");\n+  StubGenStubId stub_id = StubGenStubId::f2hf_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3648,1 +3769,1 @@\n-address StubGenerator::generate_cont_thaw(const char* label, Continuation::thaw_kind kind) {\n+address StubGenerator::generate_cont_thaw(StubGenStubId stub_id) {\n@@ -3651,4 +3772,24 @@\n-  bool return_barrier = Continuation::is_thaw_return_barrier(kind);\n-  bool return_barrier_exception = Continuation::is_thaw_return_barrier_exception(kind);\n-\n-  StubCodeMark mark(this, \"StubRoutines\", label);\n+  bool return_barrier;\n+  bool return_barrier_exception;\n+  Continuation::thaw_kind kind;\n+\n+  switch (stub_id) {\n+  case cont_thaw_id:\n+    return_barrier = false;\n+    return_barrier_exception = false;\n+    kind = Continuation::thaw_top;\n+    break;\n+  case cont_returnBarrier_id:\n+    return_barrier = true;\n+    return_barrier_exception = false;\n+    kind = Continuation::thaw_return_barrier;\n+    break;\n+  case cont_returnBarrierExc_id:\n+    return_barrier = true;\n+    return_barrier_exception = true;\n+    kind = Continuation::thaw_return_barrier_exception;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+  StubCodeMark mark(this, stub_id);\n@@ -3772,1 +3913,1 @@\n-  return generate_cont_thaw(\"Cont thaw\", Continuation::thaw_top);\n+  return generate_cont_thaw(StubGenStubId::cont_thaw_id);\n@@ -3778,1 +3919,1 @@\n-  return generate_cont_thaw(\"Cont thaw return barrier\", Continuation::thaw_return_barrier);\n+  return generate_cont_thaw(StubGenStubId::cont_returnBarrier_id);\n@@ -3782,1 +3923,1 @@\n-  return generate_cont_thaw(\"Cont thaw return barrier exception\", Continuation::thaw_return_barrier_exception);\n+  return generate_cont_thaw(StubGenStubId::cont_returnBarrierExc_id);\n@@ -3787,1 +3928,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\",\"Continuation preempt stub\");\n+  StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3817,1 +3959,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+  StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3837,1 +3980,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+  StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3855,4 +3999,3 @@\n-address StubGenerator::generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-  StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n-\n-  address start = __ pc();\n+void StubGenerator::generate_lookup_secondary_supers_table_stub() {\n+  StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3865,7 +4008,8 @@\n-  __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n-                                         rdx, rcx, rbx, r11, \/\/ temps\n-                                         result,\n-                                         super_klass_index);\n-  __ ret(0);\n-\n-  return start;\n+  for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+    StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+    __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n+                                           rdx, rcx, rbx, r11, \/\/ temps\n+                                           result,\n+                                           slot);\n+    __ ret(0);\n+  }\n@@ -3876,1 +4020,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+  StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3949,4 +4094,4 @@\n-  StubRoutines::x86::_float_sign_mask       = generate_fp_mask(\"float_sign_mask\",  0x7FFFFFFF7FFFFFFF);\n-  StubRoutines::x86::_float_sign_flip       = generate_fp_mask(\"float_sign_flip\",  0x8000000080000000);\n-  StubRoutines::x86::_double_sign_mask      = generate_fp_mask(\"double_sign_mask\", 0x7FFFFFFFFFFFFFFF);\n-  StubRoutines::x86::_double_sign_flip      = generate_fp_mask(\"double_sign_flip\", 0x8000000000000000);\n+  StubRoutines::x86::_float_sign_mask       = generate_fp_mask(StubGenStubId::float_sign_mask_id,  0x7FFFFFFF7FFFFFFF);\n+  StubRoutines::x86::_float_sign_flip       = generate_fp_mask(StubGenStubId::float_sign_flip_id,  0x8000000080000000);\n+  StubRoutines::x86::_double_sign_mask      = generate_fp_mask(StubGenStubId::double_sign_mask_id, 0x7FFFFFFFFFFFFFFF);\n+  StubRoutines::x86::_double_sign_flip      = generate_fp_mask(StubGenStubId::double_sign_flip_id, 0x8000000000000000);\n@@ -3998,4 +4143,0 @@\n-  \/\/ data cache line writeback\n-  StubRoutines::_data_cache_writeback = generate_data_cache_writeback();\n-  StubRoutines::_data_cache_writeback_sync = generate_data_cache_writeback_sync();\n-\n@@ -4010,0 +4151,9 @@\n+#ifdef COMPILER2\n+  if (UseSecondarySupersTable) {\n+    StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+    if (! InlineSecondarySupersTest) {\n+      generate_lookup_secondary_supers_table_stub();\n+    }\n+  }\n+#endif \/\/ COMPILER2\n+\n@@ -4023,11 +4173,11 @@\n-  StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(\"vector_float_sign_mask\", 0x7FFFFFFF7FFFFFFF);\n-  StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(\"vector_float_sign_flip\", 0x8000000080000000);\n-  StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask(\"vector_double_sign_mask\", 0x7FFFFFFFFFFFFFFF);\n-  StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask(\"vector_double_sign_flip\", 0x8000000000000000);\n-  StubRoutines::x86::_vector_all_bits_set = generate_vector_mask(\"vector_all_bits_set\", 0xFFFFFFFFFFFFFFFF);\n-  StubRoutines::x86::_vector_int_mask_cmp_bits = generate_vector_mask(\"vector_int_mask_cmp_bits\", 0x0000000100000001);\n-  StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(\"vector_short_to_byte_mask\", 0x00ff00ff00ff00ff);\n-  StubRoutines::x86::_vector_byte_perm_mask = generate_vector_byte_perm_mask(\"vector_byte_perm_mask\");\n-  StubRoutines::x86::_vector_int_to_byte_mask = generate_vector_mask(\"vector_int_to_byte_mask\", 0x000000ff000000ff);\n-  StubRoutines::x86::_vector_int_to_short_mask = generate_vector_mask(\"vector_int_to_short_mask\", 0x0000ffff0000ffff);\n-  StubRoutines::x86::_vector_32_bit_mask = generate_vector_custom_i32(\"vector_32_bit_mask\", Assembler::AVX_512bit,\n+  StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(StubGenStubId::vector_float_sign_mask_id, 0x7FFFFFFF7FFFFFFF);\n+  StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(StubGenStubId::vector_float_sign_flip_id, 0x8000000080000000);\n+  StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask(StubGenStubId::vector_double_sign_mask_id, 0x7FFFFFFFFFFFFFFF);\n+  StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask(StubGenStubId::vector_double_sign_flip_id, 0x8000000000000000);\n+  StubRoutines::x86::_vector_all_bits_set = generate_vector_mask(StubGenStubId::vector_all_bits_set_id, 0xFFFFFFFFFFFFFFFF);\n+  StubRoutines::x86::_vector_int_mask_cmp_bits = generate_vector_mask(StubGenStubId::vector_int_mask_cmp_bits_id, 0x0000000100000001);\n+  StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(StubGenStubId::vector_short_to_byte_mask_id, 0x00ff00ff00ff00ff);\n+  StubRoutines::x86::_vector_byte_perm_mask = generate_vector_byte_perm_mask();\n+  StubRoutines::x86::_vector_int_to_byte_mask = generate_vector_mask(StubGenStubId::vector_int_to_byte_mask_id, 0x000000ff000000ff);\n+  StubRoutines::x86::_vector_int_to_short_mask = generate_vector_mask(StubGenStubId::vector_int_to_short_mask_id, 0x0000ffff0000ffff);\n+  StubRoutines::x86::_vector_32_bit_mask = generate_vector_custom_i32(StubGenStubId::vector_32_bit_mask_id, Assembler::AVX_512bit,\n@@ -4035,1 +4185,1 @@\n-  StubRoutines::x86::_vector_64_bit_mask = generate_vector_custom_i32(\"vector_64_bit_mask\", Assembler::AVX_512bit,\n+  StubRoutines::x86::_vector_64_bit_mask = generate_vector_custom_i32(StubGenStubId::vector_64_bit_mask_id, Assembler::AVX_512bit,\n@@ -4037,11 +4187,11 @@\n-  StubRoutines::x86::_vector_int_shuffle_mask = generate_vector_mask(\"vector_int_shuffle_mask\", 0x0302010003020100);\n-  StubRoutines::x86::_vector_byte_shuffle_mask = generate_vector_byte_shuffle_mask(\"vector_byte_shuffle_mask\");\n-  StubRoutines::x86::_vector_short_shuffle_mask = generate_vector_mask(\"vector_short_shuffle_mask\", 0x0100010001000100);\n-  StubRoutines::x86::_vector_long_shuffle_mask = generate_vector_mask(\"vector_long_shuffle_mask\", 0x0000000100000000);\n-  StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask(\"vector_long_sign_mask\", 0x8000000000000000);\n-  StubRoutines::x86::_vector_iota_indices = generate_iota_indices(\"iota_indices\");\n-  StubRoutines::x86::_vector_count_leading_zeros_lut = generate_count_leading_zeros_lut(\"count_leading_zeros_lut\");\n-  StubRoutines::x86::_vector_reverse_bit_lut = generate_vector_reverse_bit_lut(\"reverse_bit_lut\");\n-  StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long(\"perm_mask_long\");\n-  StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int(\"perm_mask_int\");\n-  StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short(\"perm_mask_short\");\n+  StubRoutines::x86::_vector_int_shuffle_mask = generate_vector_mask(StubGenStubId::vector_int_shuffle_mask_id, 0x0302010003020100);\n+  StubRoutines::x86::_vector_byte_shuffle_mask = generate_vector_byte_shuffle_mask();\n+  StubRoutines::x86::_vector_short_shuffle_mask = generate_vector_mask(StubGenStubId::vector_short_shuffle_mask_id, 0x0100010001000100);\n+  StubRoutines::x86::_vector_long_shuffle_mask = generate_vector_mask(StubGenStubId::vector_long_shuffle_mask_id, 0x0000000100000000);\n+  StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask(StubGenStubId::vector_long_sign_mask_id, 0x8000000000000000);\n+  StubRoutines::x86::_vector_iota_indices = generate_iota_indices();\n+  StubRoutines::x86::_vector_count_leading_zeros_lut = generate_count_leading_zeros_lut();\n+  StubRoutines::x86::_vector_reverse_bit_lut = generate_vector_reverse_bit_lut();\n+  StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long();\n+  StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int();\n+  StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short();\n@@ -4050,4 +4200,4 @@\n-    StubRoutines::x86::_compress_perm_table32 = generate_compress_perm_table(\"compress_perm_table32\", 32);\n-    StubRoutines::x86::_compress_perm_table64 = generate_compress_perm_table(\"compress_perm_table64\", 64);\n-    StubRoutines::x86::_expand_perm_table32 = generate_expand_perm_table(\"expand_perm_table32\", 32);\n-    StubRoutines::x86::_expand_perm_table64 = generate_expand_perm_table(\"expand_perm_table64\", 64);\n+    StubRoutines::x86::_compress_perm_table32 = generate_compress_perm_table(StubGenStubId::compress_perm_table32_id);\n+    StubRoutines::x86::_compress_perm_table64 = generate_compress_perm_table(StubGenStubId::compress_perm_table64_id);\n+    StubRoutines::x86::_expand_perm_table32 = generate_expand_perm_table(StubGenStubId::expand_perm_table32_id);\n+    StubRoutines::x86::_expand_perm_table64 = generate_expand_perm_table(StubGenStubId::expand_perm_table64_id);\n@@ -4058,1 +4208,1 @@\n-    StubRoutines::x86::_vector_popcount_lut = generate_popcount_avx_lut(\"popcount_lut\");\n+    StubRoutines::x86::_vector_popcount_lut = generate_popcount_avx_lut();\n@@ -4069,0 +4219,4 @@\n+  \/\/ data cache line writeback\n+  StubRoutines::_data_cache_writeback = generate_data_cache_writeback();\n+  StubRoutines::_data_cache_writeback_sync = generate_data_cache_writeback_sync();\n+\n@@ -4089,2 +4243,2 @@\n-    StubRoutines::_md5_implCompress = generate_md5_implCompress(false, \"md5_implCompress\");\n-    StubRoutines::_md5_implCompressMB = generate_md5_implCompress(true, \"md5_implCompressMB\");\n+    StubRoutines::_md5_implCompress = generate_md5_implCompress(StubGenStubId::md5_implCompress_id);\n+    StubRoutines::_md5_implCompressMB = generate_md5_implCompress(StubGenStubId::md5_implCompressMB_id);\n@@ -4096,2 +4250,2 @@\n-    StubRoutines::_sha1_implCompress = generate_sha1_implCompress(false, \"sha1_implCompress\");\n-    StubRoutines::_sha1_implCompressMB = generate_sha1_implCompress(true, \"sha1_implCompressMB\");\n+    StubRoutines::_sha1_implCompress = generate_sha1_implCompress(StubGenStubId::sha1_implCompress_id);\n+    StubRoutines::_sha1_implCompressMB = generate_sha1_implCompress(StubGenStubId::sha1_implCompressMB_id);\n@@ -4110,2 +4264,2 @@\n-    StubRoutines::_sha256_implCompress = generate_sha256_implCompress(false, \"sha256_implCompress\");\n-    StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(true, \"sha256_implCompressMB\");\n+    StubRoutines::_sha256_implCompress = generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n+    StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n@@ -4117,2 +4271,2 @@\n-    StubRoutines::_sha512_implCompress = generate_sha512_implCompress(false, \"sha512_implCompress\");\n-    StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(true, \"sha512_implCompressMB\");\n+    StubRoutines::_sha512_implCompress = generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n+    StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n@@ -4160,8 +4314,0 @@\n-  if (UseSecondarySupersTable) {\n-    StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n-    if (! InlineSecondarySupersTest) {\n-      for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-        StubRoutines::_lookup_secondary_supers_table_stubs[slot] = generate_lookup_secondary_supers_table_stub(slot);\n-      }\n-    }\n-  }\n@@ -4266,19 +4412,18 @@\n-StubGenerator::StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    DEBUG_ONLY( _regs_in_thread = false; )\n-    switch(kind) {\n-    case Initial_stubs:\n-      generate_initial_stubs();\n-      break;\n-     case Continuation_stubs:\n-      generate_continuation_stubs();\n-      break;\n-    case Compiler_stubs:\n-      generate_compiler_stubs();\n-      break;\n-    case Final_stubs:\n-      generate_final_stubs();\n-      break;\n-    default:\n-      fatal(\"unexpected stubs kind: %d\", kind);\n-      break;\n-    };\n+StubGenerator::StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  switch(blob_id) {\n+  case initial_id:\n+    generate_initial_stubs();\n+    break;\n+  case continuation_id:\n+    generate_continuation_stubs();\n+    break;\n+  case compiler_id:\n+    generate_compiler_stubs();\n+    break;\n+  case final_id:\n+    generate_final_stubs();\n+    break;\n+  default:\n+    fatal(\"unexpected blob id: %d\", blob_id);\n+    break;\n+  };\n@@ -4287,2 +4432,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":325,"deletions":180,"binary":false,"changes":505,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -90,4 +91,4 @@\n-  address generate_count_leading_zeros_lut(const char *stub_name);\n-  address generate_popcount_avx_lut(const char *stub_name);\n-  address generate_iota_indices(const char *stub_name);\n-  address generate_vector_reverse_bit_lut(const char *stub_name);\n+  address generate_count_leading_zeros_lut();\n+  address generate_popcount_avx_lut();\n+  address generate_iota_indices();\n+  address generate_vector_reverse_bit_lut();\n@@ -95,4 +96,4 @@\n-  address generate_vector_reverse_byte_perm_mask_long(const char *stub_name);\n-  address generate_vector_reverse_byte_perm_mask_int(const char *stub_name);\n-  address generate_vector_reverse_byte_perm_mask_short(const char *stub_name);\n-  address generate_vector_byte_shuffle_mask(const char *stub_name);\n+  address generate_vector_reverse_byte_perm_mask_long();\n+  address generate_vector_reverse_byte_perm_mask_int();\n+  address generate_vector_reverse_byte_perm_mask_short();\n+  address generate_vector_byte_shuffle_mask();\n@@ -100,1 +101,1 @@\n-  address generate_fp_mask(const char *stub_name, int64_t mask);\n+  address generate_fp_mask(StubGenStubId stub_id, int64_t mask);\n@@ -102,1 +103,1 @@\n-  address generate_compress_perm_table(const char *stub_name, int32_t esize);\n+  address generate_compress_perm_table(StubGenStubId stub_id);\n@@ -104,1 +105,1 @@\n-  address generate_expand_perm_table(const char *stub_name, int32_t esize);\n+  address generate_expand_perm_table(StubGenStubId stub_id);\n@@ -106,1 +107,1 @@\n-  address generate_vector_mask(const char *stub_name, int64_t mask);\n+  address generate_vector_mask(StubGenStubId stub_id, int64_t mask);\n@@ -108,1 +109,1 @@\n-  address generate_vector_byte_perm_mask(const char *stub_name);\n+  address generate_vector_byte_perm_mask();\n@@ -110,1 +111,1 @@\n-  address generate_vector_fp_mask(const char *stub_name, int64_t mask);\n+  address generate_vector_fp_mask(StubGenStubId stub_id, int64_t mask);\n@@ -112,1 +113,1 @@\n-  address generate_vector_custom_i32(const char *stub_name, Assembler::AvxVectorLen len,\n+  address generate_vector_custom_i32(StubGenStubId stub_id, Assembler::AvxVectorLen len,\n@@ -182,2 +183,1 @@\n-  address generate_disjoint_copy_avx3_masked(address* entry, const char *name, int shift,\n-                                             bool aligned, bool is_oop, bool dest_uninitialized);\n+  address generate_disjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry);\n@@ -185,3 +185,2 @@\n-  address generate_conjoint_copy_avx3_masked(address* entry, const char *name, int shift,\n-                                             address nooverlap_target, bool aligned, bool is_oop,\n-                                             bool dest_uninitialized);\n+  address generate_conjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry,\n+                                             address nooverlap_target);\n@@ -228,1 +227,1 @@\n-  address generate_disjoint_byte_copy(bool aligned, address* entry, const char *name);\n+  address generate_disjoint_byte_copy(address* entry);\n@@ -230,2 +229,1 @@\n-  address generate_conjoint_byte_copy(bool aligned, address nooverlap_target,\n-                                      address* entry, const char *name);\n+  address generate_conjoint_byte_copy(address nooverlap_target, address* entry);\n@@ -233,1 +231,1 @@\n-  address generate_disjoint_short_copy(bool aligned, address *entry, const char *name);\n+  address generate_disjoint_short_copy(address *entry);\n@@ -235,1 +233,1 @@\n-  address generate_fill(BasicType t, bool aligned, const char *name);\n+  address generate_fill(StubGenStubId stub_id);\n@@ -237,12 +235,7 @@\n-  address generate_conjoint_short_copy(bool aligned, address nooverlap_target,\n-                                       address *entry, const char *name);\n-  address generate_disjoint_int_oop_copy(bool aligned, bool is_oop, address* entry,\n-                                         const char *name, bool dest_uninitialized = false);\n-  address generate_conjoint_int_oop_copy(bool aligned, bool is_oop, address nooverlap_target,\n-                                         address *entry, const char *name,\n-                                         bool dest_uninitialized = false);\n-  address generate_disjoint_long_oop_copy(bool aligned, bool is_oop, address *entry,\n-                                          const char *name, bool dest_uninitialized = false);\n-  address generate_conjoint_long_oop_copy(bool aligned, bool is_oop,\n-                                          address nooverlap_target, address *entry,\n-                                          const char *name, bool dest_uninitialized = false);\n+  address generate_conjoint_short_copy(address nooverlap_target, address *entry);\n+  address generate_disjoint_int_oop_copy(StubGenStubId stub_id, address* entry);\n+  address generate_conjoint_int_oop_copy(StubGenStubId stub_id, address nooverlap_target,\n+                                         address *entry);\n+  address generate_disjoint_long_oop_copy(StubGenStubId stub_id, address* entry);\n+  address generate_conjoint_long_oop_copy(StubGenStubId stub_id, address nooverlap_target,\n+                                          address *entry);\n@@ -258,2 +251,1 @@\n-  address generate_checkcast_copy(const char *name, address *entry,\n-                                  bool dest_uninitialized = false);\n+  address generate_checkcast_copy(StubGenStubId stub_id, address *entry);\n@@ -267,2 +259,1 @@\n-  address generate_unsafe_copy(const char *name,\n-                               address byte_copy_entry, address short_copy_entry,\n+  address generate_unsafe_copy(address byte_copy_entry, address short_copy_entry,\n@@ -277,1 +268,1 @@\n-  address generate_unsafe_setmemory(const char *name, address byte_copy_entry);\n+  address generate_unsafe_setmemory(address byte_copy_entry);\n@@ -291,2 +282,1 @@\n-  address generate_generic_copy(const char *name,\n-                                address byte_copy_entry, address short_copy_entry,\n+  address generate_generic_copy(address byte_copy_entry, address short_copy_entry,\n@@ -307,1 +297,1 @@\n-  address generate_md5_implCompress(bool multi_block, const char *name);\n+  address generate_md5_implCompress(StubGenStubId stub_id);\n@@ -314,1 +304,1 @@\n-  address generate_sha1_implCompress(bool multi_block, const char *name);\n+  address generate_sha1_implCompress(StubGenStubId stub_id);\n@@ -318,2 +308,2 @@\n-  address generate_sha256_implCompress(bool multi_block, const char *name);\n-  address generate_sha512_implCompress(bool multi_block, const char *name);\n+  address generate_sha256_implCompress(StubGenStubId stub_id);\n+  address generate_sha512_implCompress(StubGenStubId stub_id);\n@@ -502,1 +492,1 @@\n-  address generate_sha3_implCompress(bool multiBlock, const char *name);\n+  address generate_sha3_implCompress(StubGenStubId stub_id);\n@@ -598,1 +588,1 @@\n-  address generate_cont_thaw(const char* label, Continuation::thaw_kind kind);\n+  address generate_cont_thaw(StubGenStubId stub_id);\n@@ -607,0 +597,2 @@\n+  \/\/ TODO -- delete this as it is not implemented?\n+  \/\/\n@@ -632,1 +624,1 @@\n-  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index);\n+  void generate_lookup_secondary_supers_table_stub();\n@@ -645,2 +637,2 @@\n- public:\n-  StubGenerator(CodeBuffer* code, StubsKind kind);\n+public:\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":45,"deletions":53,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"updateBytesAdler32\");\n+  StubGenStubId stub_id = StubGenStubId::updateBytesAdler32_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_adler.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -253,1 +253,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"galoisCounterMode_AESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::galoisCounterMode_AESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -339,1 +340,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"galoisCounterMode_AESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::galoisCounterMode_AESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -410,1 +412,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"counterMode_AESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -498,1 +501,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"counterMode_AESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -785,1 +789,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_decryptAESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1067,1 +1072,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_encryptBlock\");\n+  StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1161,1 +1167,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_decryptBlock\");\n+  StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1262,1 +1269,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_encryptAESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1413,1 +1421,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_decryptAESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1655,1 +1664,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"electronicCodeBook_encryptAESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::electronicCodeBook_encryptAESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1675,1 +1685,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"electronicCodeBook_decryptAESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::electronicCodeBook_decryptAESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_aes.cpp","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -88,19 +88,11 @@\n-  StubRoutines::_jbyte_disjoint_arraycopy  = generate_disjoint_byte_copy(false, &entry,\n-                                                                         \"jbyte_disjoint_arraycopy\");\n-  StubRoutines::_jbyte_arraycopy           = generate_conjoint_byte_copy(false, entry, &entry_jbyte_arraycopy,\n-                                                                         \"jbyte_arraycopy\");\n-\n-  StubRoutines::_jshort_disjoint_arraycopy = generate_disjoint_short_copy(false, &entry,\n-                                                                          \"jshort_disjoint_arraycopy\");\n-  StubRoutines::_jshort_arraycopy          = generate_conjoint_short_copy(false, entry, &entry_jshort_arraycopy,\n-                                                                          \"jshort_arraycopy\");\n-\n-  StubRoutines::_jint_disjoint_arraycopy   = generate_disjoint_int_oop_copy(false, false, &entry,\n-                                                                            \"jint_disjoint_arraycopy\");\n-  StubRoutines::_jint_arraycopy            = generate_conjoint_int_oop_copy(false, false, entry,\n-                                                                            &entry_jint_arraycopy, \"jint_arraycopy\");\n-\n-  StubRoutines::_jlong_disjoint_arraycopy  = generate_disjoint_long_oop_copy(false, false, &entry,\n-                                                                             \"jlong_disjoint_arraycopy\");\n-  StubRoutines::_jlong_arraycopy           = generate_conjoint_long_oop_copy(false, false, entry,\n-                                                                             &entry_jlong_arraycopy, \"jlong_arraycopy\");\n+  StubRoutines::_jbyte_disjoint_arraycopy  = generate_disjoint_byte_copy(&entry);\n+  StubRoutines::_jbyte_arraycopy           = generate_conjoint_byte_copy(entry, &entry_jbyte_arraycopy);\n+\n+  StubRoutines::_jshort_disjoint_arraycopy = generate_disjoint_short_copy(&entry);\n+  StubRoutines::_jshort_arraycopy          = generate_conjoint_short_copy(entry, &entry_jshort_arraycopy);\n+\n+  StubRoutines::_jint_disjoint_arraycopy   = generate_disjoint_int_oop_copy(StubGenStubId::jint_disjoint_arraycopy_id, &entry);\n+  StubRoutines::_jint_arraycopy            = generate_conjoint_int_oop_copy(StubGenStubId::jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+\n+  StubRoutines::_jlong_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubGenStubId::jlong_disjoint_arraycopy_id, &entry);\n+  StubRoutines::_jlong_arraycopy           = generate_conjoint_long_oop_copy(StubGenStubId::jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n@@ -108,10 +100,4 @@\n-    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_int_oop_copy(false, true, &entry,\n-                                                                            \"oop_disjoint_arraycopy\");\n-    StubRoutines::_oop_arraycopy           = generate_conjoint_int_oop_copy(false, true, entry,\n-                                                                            &entry_oop_arraycopy, \"oop_arraycopy\");\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_int_oop_copy(false, true, &entry,\n-                                                                                   \"oop_disjoint_arraycopy_uninit\",\n-                                                                                   \/*dest_uninitialized*\/true);\n-    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_int_oop_copy(false, true, entry,\n-                                                                                   nullptr, \"oop_arraycopy_uninit\",\n-                                                                                   \/*dest_uninitialized*\/true);\n+    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_int_oop_copy(StubGenStubId::oop_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_oop_arraycopy           = generate_conjoint_int_oop_copy(StubGenStubId::oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_int_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id, &entry);\n+    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_int_oop_copy(StubGenStubId::oop_arraycopy_uninit_id, entry, nullptr);\n@@ -119,18 +105,10 @@\n-    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_long_oop_copy(false, true, &entry,\n-                                                                             \"oop_disjoint_arraycopy\");\n-    StubRoutines::_oop_arraycopy           = generate_conjoint_long_oop_copy(false, true, entry,\n-                                                                             &entry_oop_arraycopy, \"oop_arraycopy\");\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_long_oop_copy(false, true, &entry,\n-                                                                                    \"oop_disjoint_arraycopy_uninit\",\n-                                                                                    \/*dest_uninitialized*\/true);\n-    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_long_oop_copy(false, true, entry,\n-                                                                                    nullptr, \"oop_arraycopy_uninit\",\n-                                                                                    \/*dest_uninitialized*\/true);\n-  }\n-\n-  StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(\"checkcast_arraycopy\", &entry_checkcast_arraycopy);\n-  StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", nullptr,\n-                                                                      \/*dest_uninitialized*\/true);\n-\n-  StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(\"unsafe_arraycopy\",\n-                                                            entry_jbyte_arraycopy,\n+    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubGenStubId::oop_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_oop_arraycopy           = generate_conjoint_long_oop_copy(StubGenStubId::oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_long_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id, &entry);\n+    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_long_oop_copy(StubGenStubId::oop_arraycopy_uninit_id, entry, nullptr);\n+  }\n+\n+  StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+  StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id, nullptr);\n+\n+  StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(entry_jbyte_arraycopy,\n@@ -140,2 +118,1 @@\n-  StubRoutines::_generic_arraycopy   = generate_generic_copy(\"generic_arraycopy\",\n-                                                             entry_jbyte_arraycopy,\n+  StubRoutines::_generic_arraycopy   = generate_generic_copy(entry_jbyte_arraycopy,\n@@ -148,6 +125,6 @@\n-  StubRoutines::_jbyte_fill = generate_fill(T_BYTE, false, \"jbyte_fill\");\n-  StubRoutines::_jshort_fill = generate_fill(T_SHORT, false, \"jshort_fill\");\n-  StubRoutines::_jint_fill = generate_fill(T_INT, false, \"jint_fill\");\n-  StubRoutines::_arrayof_jbyte_fill = generate_fill(T_BYTE, true, \"arrayof_jbyte_fill\");\n-  StubRoutines::_arrayof_jshort_fill = generate_fill(T_SHORT, true, \"arrayof_jshort_fill\");\n-  StubRoutines::_arrayof_jint_fill = generate_fill(T_INT, true, \"arrayof_jint_fill\");\n+  StubRoutines::_jbyte_fill = generate_fill(StubGenStubId::jbyte_fill_id);\n+  StubRoutines::_jshort_fill = generate_fill(StubGenStubId::jshort_fill_id);\n+  StubRoutines::_jint_fill = generate_fill(StubGenStubId::jint_fill_id);\n+  StubRoutines::_arrayof_jbyte_fill = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n+  StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n+  StubRoutines::_arrayof_jint_fill = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n@@ -155,1 +132,1 @@\n-  StubRoutines::_unsafe_setmemory = generate_unsafe_setmemory(\"unsafe_setmemory\", StubRoutines::_jbyte_fill);\n+  StubRoutines::_unsafe_setmemory = generate_unsafe_setmemory(StubRoutines::_jbyte_fill);\n@@ -511,3 +488,42 @@\n-address StubGenerator::generate_disjoint_copy_avx3_masked(address* entry, const char *name,\n-                                                          int shift, bool aligned, bool is_oop,\n-                                                          bool dest_uninitialized) {\n+address StubGenerator::generate_disjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry) {\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n+  int shift;\n+  bool is_oop;\n+  bool dest_uninitialized;\n+\n+  switch (stub_id) {\n+  case jbyte_disjoint_arraycopy_id:\n+    shift = 0;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case jshort_disjoint_arraycopy_id:\n+    shift = 1;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case jint_disjoint_arraycopy_id:\n+    shift = 2;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case jlong_disjoint_arraycopy_id:\n+    shift = 3;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case oop_disjoint_arraycopy_id:\n+    shift = (UseCompressedOops ? 2 : 3);\n+    is_oop = true;\n+    dest_uninitialized = false;\n+    break;\n+  case oop_disjoint_arraycopy_uninit_id:\n+    shift = (UseCompressedOops ? 2 : 3);\n+    is_oop = true;\n+    dest_uninitialized = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -515,1 +531,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -810,3 +826,42 @@\n-address StubGenerator::generate_conjoint_copy_avx3_masked(address* entry, const char *name, int shift,\n-                                                          address nooverlap_target, bool aligned,\n-                                                          bool is_oop, bool dest_uninitialized) {\n+address StubGenerator::generate_conjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry, address nooverlap_target) {\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n+  int shift;\n+  bool is_oop;\n+  bool dest_uninitialized;\n+\n+  switch (stub_id) {\n+  case jbyte_arraycopy_id:\n+    shift = 0;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case jshort_arraycopy_id:\n+    shift = 1;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case jint_arraycopy_id:\n+    shift = 2;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case jlong_arraycopy_id:\n+    shift = 3;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case oop_arraycopy_id:\n+    shift = (UseCompressedOops ? 2 : 3);\n+    is_oop = true;\n+    dest_uninitialized = false;\n+    break;\n+  case oop_arraycopy_uninit_id:\n+    shift = (UseCompressedOops ? 2 : 3);\n+    is_oop = true;\n+    dest_uninitialized = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -814,1 +869,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1266,3 +1321,1 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   name    - stub name string\n+\/\/   entry     - location for return of (post-push) entry\n@@ -1281,1 +1334,1 @@\n-\/\/   disjoint_byte_copy_entry is set to the no-overlap entry point\n+\/\/   entry is set to the no-overlap entry point\n@@ -1284,1 +1337,4 @@\n-address StubGenerator::generate_disjoint_byte_copy(bool aligned, address* entry, const char *name) {\n+address StubGenerator::generate_disjoint_byte_copy(address* entry) {\n+  StubGenStubId stub_id = StubGenStubId::jbyte_disjoint_arraycopy_id;\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n@@ -1287,2 +1343,1 @@\n-     return generate_disjoint_copy_avx3_masked(entry, \"jbyte_disjoint_arraycopy_avx3\", 0,\n-                                               aligned, false, false);\n+    return generate_disjoint_copy_avx3_masked(stub_id, entry);\n@@ -1292,1 +1347,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1387,3 +1442,2 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   name    - stub name string\n+\/\/   entry     - location for return of (post-push) entry\n+\/\/   nooverlap_target - entry to branch to if no overlap detected\n@@ -1401,2 +1455,4 @@\n-address StubGenerator::generate_conjoint_byte_copy(bool aligned, address nooverlap_target,\n-                                                   address* entry, const char *name) {\n+address StubGenerator::generate_conjoint_byte_copy(address nooverlap_target, address* entry) {\n+  StubGenStubId stub_id = StubGenStubId::jbyte_arraycopy_id;\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n@@ -1405,2 +1461,1 @@\n-     return generate_conjoint_copy_avx3_masked(entry, \"jbyte_conjoint_arraycopy_avx3\", 0,\n-                                               nooverlap_target, aligned, false, false);\n+    return generate_conjoint_copy_avx3_masked(stub_id, entry, nooverlap_target);\n@@ -1410,1 +1465,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1497,3 +1552,1 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   name    - stub name string\n+\/\/   entry     - location for return of (post-push) entry\n@@ -1512,1 +1565,1 @@\n-\/\/   disjoint_short_copy_entry is set to the no-overlap entry point\n+\/\/   entry is set to the no-overlap entry point\n@@ -1515,1 +1568,4 @@\n-address StubGenerator::generate_disjoint_short_copy(bool aligned, address *entry, const char *name) {\n+address StubGenerator::generate_disjoint_short_copy(address *entry) {\n+  StubGenStubId stub_id = StubGenStubId::jshort_disjoint_arraycopy_id;\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n@@ -1518,2 +1574,1 @@\n-     return generate_disjoint_copy_avx3_masked(entry, \"jshort_disjoint_arraycopy_avx3\", 1,\n-                                               aligned, false, false);\n+    return generate_disjoint_copy_avx3_masked(stub_id, entry);\n@@ -1524,1 +1579,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1611,1 +1666,33 @@\n-address StubGenerator::generate_fill(BasicType t, bool aligned, const char *name) {\n+address StubGenerator::generate_fill(StubGenStubId stub_id) {\n+  BasicType t;\n+  bool aligned;\n+\n+  switch (stub_id) {\n+  case jbyte_fill_id:\n+    t = T_BYTE;\n+    aligned = false;\n+    break;\n+  case jshort_fill_id:\n+    t = T_SHORT;\n+    aligned = false;\n+    break;\n+  case jint_fill_id:\n+    t = T_INT;\n+    aligned = false;\n+    break;\n+  case arrayof_jbyte_fill_id:\n+    t = T_BYTE;\n+    aligned = true;\n+    break;\n+  case arrayof_jshort_fill_id:\n+    t = T_SHORT;\n+    aligned = true;\n+    break;\n+  case arrayof_jint_fill_id:\n+    t = T_INT;\n+    aligned = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -1613,1 +1700,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1640,3 +1727,2 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   name    - stub name string\n+\/\/   entry     - location for return of (post-push) entry\n+\/\/   nooverlap_target - entry to branch to if no overlap detected\n@@ -1654,2 +1740,4 @@\n-address StubGenerator::generate_conjoint_short_copy(bool aligned, address nooverlap_target,\n-                                                    address *entry, const char *name) {\n+address StubGenerator::generate_conjoint_short_copy(address nooverlap_target, address *entry) {\n+  StubGenStubId stub_id = StubGenStubId::jshort_arraycopy_id;\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n@@ -1658,2 +1746,1 @@\n-     return generate_conjoint_copy_avx3_masked(entry, \"jshort_conjoint_arraycopy_avx3\", 1,\n-                                               nooverlap_target, aligned, false, false);\n+    return generate_conjoint_copy_avx3_masked(stub_id, entry, nooverlap_target);\n@@ -1662,0 +1749,1 @@\n+\n@@ -1663,1 +1751,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1742,4 +1830,3 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   is_oop  - true => oop array, so generate store check code\n-\/\/   name    - stub name string\n+\/\/   stub_id   - unqiue id for stub to generate\n+\/\/   entry     - location for return of (post-push) entry\n+\/\/   is_oop    - true => oop array, so generate store check code\n@@ -1760,2 +1847,24 @@\n-address StubGenerator::generate_disjoint_int_oop_copy(bool aligned, bool is_oop, address* entry,\n-                                                      const char *name, bool dest_uninitialized) {\n+address StubGenerator::generate_disjoint_int_oop_copy(StubGenStubId stub_id, address* entry) {\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n+  bool is_oop;\n+  bool dest_uninitialized;\n+  switch (stub_id) {\n+  case StubGenStubId::jint_disjoint_arraycopy_id:\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_disjoint_arraycopy_id:\n+    assert(UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_disjoint_arraycopy_uninit_id:\n+    assert(UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -1765,2 +1874,1 @@\n-     return generate_disjoint_copy_avx3_masked(entry, \"jint_disjoint_arraycopy_avx3\", 2,\n-                                               aligned, is_oop, dest_uninitialized);\n+    return generate_disjoint_copy_avx3_masked(stub_id, entry);\n@@ -1771,1 +1879,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1857,2 +1965,2 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n+\/\/   entry     - location for return of (post-push) entry\n+\/\/   nooverlap_target - entry to branch to if no overlap detected\n@@ -1860,1 +1968,0 @@\n-\/\/   name    - stub name string\n@@ -1871,3 +1978,24 @@\n-address StubGenerator::generate_conjoint_int_oop_copy(bool aligned, bool is_oop, address nooverlap_target,\n-                                                      address *entry, const char *name,\n-                                                      bool dest_uninitialized) {\n+address StubGenerator::generate_conjoint_int_oop_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n+  bool is_oop;\n+  bool dest_uninitialized;\n+  switch (stub_id) {\n+  case StubGenStubId::jint_arraycopy_id:\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_arraycopy_id:\n+    assert(UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_arraycopy_uninit_id:\n+    assert(UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -1877,2 +2005,1 @@\n-     return generate_conjoint_copy_avx3_masked(entry, \"jint_conjoint_arraycopy_avx3\", 2,\n-                                               nooverlap_target, aligned, is_oop, dest_uninitialized);\n+    return generate_conjoint_copy_avx3_masked(stub_id, entry, nooverlap_target);\n@@ -1881,0 +2008,1 @@\n+\n@@ -1882,1 +2010,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1972,4 +2100,1 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-\/\/             ignored\n-\/\/   is_oop  - true => oop array, so generate store check code\n-\/\/   name    - stub name string\n+\/\/   entry     - location for return of (post-push) entry\n@@ -1986,2 +2111,24 @@\n-address StubGenerator::generate_disjoint_long_oop_copy(bool aligned, bool is_oop, address *entry,\n-                                                       const char *name, bool dest_uninitialized) {\n+address StubGenerator::generate_disjoint_long_oop_copy(StubGenStubId stub_id, address *entry) {\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n+  bool is_oop;\n+  bool dest_uninitialized;\n+  switch (stub_id) {\n+  case StubGenStubId::jlong_disjoint_arraycopy_id:\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_disjoint_arraycopy_id:\n+    assert(!UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_disjoint_arraycopy_uninit_id:\n+    assert(!UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -1991,2 +2138,1 @@\n-     return generate_disjoint_copy_avx3_masked(entry, \"jlong_disjoint_arraycopy_avx3\", 3,\n-                                               aligned, is_oop, dest_uninitialized);\n+    return generate_disjoint_copy_avx3_masked(stub_id, entry);\n@@ -1995,0 +2141,1 @@\n+\n@@ -1996,1 +2143,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -2088,2 +2235,2 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-\/\/             ignored\n+\/\/   entry     - location for return of (post-push) entry\n+\/\/   nooverlap_target - entry to branch to if no overlap detected\n@@ -2091,1 +2238,0 @@\n-\/\/   name    - stub name string\n@@ -2098,3 +2244,24 @@\n-address StubGenerator::generate_conjoint_long_oop_copy(bool aligned, bool is_oop, address nooverlap_target,\n-                                                       address *entry, const char *name,\n-                                                       bool dest_uninitialized) {\n+address StubGenerator::generate_conjoint_long_oop_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n+  bool is_oop;\n+  bool dest_uninitialized;\n+  switch (stub_id) {\n+  case StubGenStubId::jlong_arraycopy_id:\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_arraycopy_id:\n+    assert(!UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_arraycopy_uninit_id:\n+    assert(!UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -2104,2 +2271,1 @@\n-     return generate_conjoint_copy_avx3_masked(entry, \"jlong_conjoint_arraycopy_avx3\", 3,\n-                                               nooverlap_target, aligned, is_oop, dest_uninitialized);\n+    return generate_conjoint_copy_avx3_masked(stub_id, entry, nooverlap_target);\n@@ -2108,0 +2274,1 @@\n+\n@@ -2109,1 +2276,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -2228,1 +2395,13 @@\n-address StubGenerator::generate_checkcast_copy(const char *name, address *entry, bool dest_uninitialized) {\n+address StubGenerator::generate_checkcast_copy(StubGenStubId stub_id, address *entry) {\n+\n+  bool dest_uninitialized;\n+  switch (stub_id) {\n+  case StubGenStubId::checkcast_arraycopy_id:\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::checkcast_arraycopy_uninit_id:\n+    dest_uninitialized = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n@@ -2258,1 +2437,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -2434,2 +2613,1 @@\n-address StubGenerator::generate_unsafe_copy(const char *name,\n-                                            address byte_copy_entry, address short_copy_entry,\n+address StubGenerator::generate_unsafe_copy(address byte_copy_entry, address short_copy_entry,\n@@ -2449,1 +2627,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2582,2 +2761,1 @@\n-address StubGenerator::generate_unsafe_setmemory(const char *name,\n-                                                 address unsafe_byte_fill) {\n+address StubGenerator::generate_unsafe_setmemory(address unsafe_byte_fill) {\n@@ -2585,1 +2763,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubGenStubId stub_id = StubGenStubId::unsafe_setmemory_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2728,2 +2907,1 @@\n-address StubGenerator::generate_generic_copy(const char *name,\n-                                             address byte_copy_entry, address short_copy_entry,\n+address StubGenerator::generate_generic_copy(address byte_copy_entry, address short_copy_entry,\n@@ -2755,1 +2933,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":324,"deletions":145,"binary":false,"changes":469,"status":"modified"},{"patch":"@@ -117,1 +117,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+  StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -305,1 +306,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+  StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_chacha.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -177,1 +177,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmCos\");\n+  StubGenStubId stub_id = StubGenStubId::dcos_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_cos.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -169,1 +169,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmExp\");\n+  StubGenStubId stub_id = StubGenStubId::dexp_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_exp.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -77,1 +77,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmFmod\");\n+  StubGenStubId stub_id = StubGenStubId::fmod_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_fmod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -87,1 +87,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"ghash_processBlocks\");\n+  StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -223,1 +224,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"ghash_processBlocks\");\n+  StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_ghash.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -180,1 +180,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmLog\");\n+  StubGenStubId stub_id = StubGenStubId::dlog_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -518,1 +519,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmLog10\");\n+  StubGenStubId stub_id = StubGenStubId::dlog10_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_log.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -914,1 +914,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"poly1305_processBlocks\");\n+  StubGenStubId stub_id = StubGenStubId::poly1305_processBlocks_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly1305.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -241,1 +241,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"intpoly_montgomeryMult_P256\");\n+  StubGenStubId stub_id = StubGenStubId::intpoly_montgomeryMult_P256_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -299,1 +300,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"intpoly_assign\");\n+  StubGenStubId stub_id = StubGenStubId::intpoly_assign_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly_mont.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -763,1 +763,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmPow\");\n+  StubGenStubId stub_id = StubGenStubId::dpow_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_pow.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,2 +85,2 @@\n-    StubRoutines::_sha3_implCompress   = generate_sha3_implCompress(false,\"sha3_implCompress\");\n-    StubRoutines::_sha3_implCompressMB = generate_sha3_implCompress(true, \"sha3_implCompressMB\");\n+    StubRoutines::_sha3_implCompress   = generate_sha3_implCompress(StubGenStubId::sha3_implCompress_id);\n+    StubRoutines::_sha3_implCompressMB = generate_sha3_implCompress(StubGenStubId::sha3_implCompressMB_id);\n@@ -99,1 +99,13 @@\n-address StubGenerator::generate_sha3_implCompress(bool multiBlock, const char *name) {\n+address StubGenerator::generate_sha3_implCompress(StubGenStubId stub_id) {\n+  bool multiBlock;\n+  switch(stub_id) {\n+  case sha3_implCompress_id:\n+    multiBlock = false;\n+    break;\n+  case sha3_implCompressMB_id:\n+    multiBlock = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -101,1 +113,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_sha3.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -184,1 +184,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmSin\");\n+  StubGenStubId stub_id = StubGenStubId::dsin_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_sin.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -459,1 +459,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmTan\");\n+  StubGenStubId stub_id = StubGenStubId::dtan_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_tan.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -306,1 +306,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmTanh\");\n+  StubGenStubId stub_id = StubGenStubId::dtanh_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_tanh.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,3 +36,13 @@\n-address StubRoutines::x86::_verify_mxcsr_entry = nullptr;\n-address StubRoutines::x86::_upper_word_mask_addr = nullptr;\n-address StubRoutines::x86::_shuffle_byte_flip_mask_addr = nullptr;\n+\/\/ define fields for arch-specific entries\n+\n+#define DEFINE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = nullptr;\n+\n+#define DEFINE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = CAST_FROM_FN_PTR(address, init_function);\n+\n+STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY, DEFINE_ARCH_ENTRY_INIT)\n+\n+#undef DEFINE_ARCH_ENTRY_INIT\n+#undef DEFINE_ARCH_ENTRY\n+\n@@ -40,24 +50,0 @@\n-address StubRoutines::x86::_vector_short_to_byte_mask = nullptr;\n-address StubRoutines::x86::_vector_int_to_byte_mask = nullptr;\n-address StubRoutines::x86::_vector_int_to_short_mask = nullptr;\n-address StubRoutines::x86::_vector_all_bits_set = nullptr;\n-address StubRoutines::x86::_vector_byte_shuffle_mask = nullptr;\n-address StubRoutines::x86::_vector_int_mask_cmp_bits = nullptr;\n-address StubRoutines::x86::_vector_short_shuffle_mask = nullptr;\n-address StubRoutines::x86::_vector_int_shuffle_mask = nullptr;\n-address StubRoutines::x86::_vector_long_shuffle_mask = nullptr;\n-address StubRoutines::x86::_vector_float_sign_mask = nullptr;\n-address StubRoutines::x86::_vector_float_sign_flip = nullptr;\n-address StubRoutines::x86::_vector_double_sign_mask = nullptr;\n-address StubRoutines::x86::_vector_double_sign_flip = nullptr;\n-address StubRoutines::x86::_vector_byte_perm_mask = nullptr;\n-address StubRoutines::x86::_vector_long_sign_mask = nullptr;\n-address StubRoutines::x86::_vector_iota_indices = nullptr;\n-address StubRoutines::x86::_vector_reverse_bit_lut = nullptr;\n-address StubRoutines::x86::_vector_reverse_byte_perm_mask_long = nullptr;\n-address StubRoutines::x86::_vector_reverse_byte_perm_mask_int = nullptr;\n-address StubRoutines::x86::_vector_reverse_byte_perm_mask_short = nullptr;\n-address StubRoutines::x86::_vector_popcount_lut = nullptr;\n-address StubRoutines::x86::_vector_count_leading_zeros_lut = nullptr;\n-address StubRoutines::x86::_vector_32_bit_mask = nullptr;\n-address StubRoutines::x86::_vector_64_bit_mask = nullptr;\n@@ -67,22 +53,0 @@\n-address StubRoutines::x86::_pshuffle_byte_flip_mask_addr_sha512 = nullptr;\n-\/\/ Base64 masks\n-address StubRoutines::x86::_encoding_table_base64 = nullptr;\n-address StubRoutines::x86::_shuffle_base64 = nullptr;\n-address StubRoutines::x86::_avx2_shuffle_base64 = nullptr;\n-address StubRoutines::x86::_avx2_input_mask_base64 = nullptr;\n-address StubRoutines::x86::_avx2_lut_base64 = nullptr;\n-address StubRoutines::x86::_avx2_decode_tables_base64 = nullptr;\n-address StubRoutines::x86::_avx2_decode_lut_tables_base64 = nullptr;\n-address StubRoutines::x86::_lookup_lo_base64 = nullptr;\n-address StubRoutines::x86::_lookup_hi_base64 = nullptr;\n-address StubRoutines::x86::_lookup_lo_base64url = nullptr;\n-address StubRoutines::x86::_lookup_hi_base64url = nullptr;\n-address StubRoutines::x86::_pack_vec_base64 = nullptr;\n-address StubRoutines::x86::_join_0_1_base64 = nullptr;\n-address StubRoutines::x86::_join_1_2_base64 = nullptr;\n-address StubRoutines::x86::_join_2_3_base64 = nullptr;\n-address StubRoutines::x86::_decoding_table_base64 = nullptr;\n-address StubRoutines::x86::_compress_perm_table32 = nullptr;\n-address StubRoutines::x86::_compress_perm_table64 = nullptr;\n-address StubRoutines::x86::_expand_perm_table32 = nullptr;\n-address StubRoutines::x86::_expand_perm_table64 = nullptr;\n@@ -90,1 +54,0 @@\n-address StubRoutines::x86::_pshuffle_byte_flip_mask_addr = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":13,"deletions":50,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -34,0 +34,5 @@\n+\/\/ emit enum used to size per-blob code buffers\n+\n+#define DEFINE_BLOB_SIZE(blob_name, size) \\\n+  _ ## blob_name ## _code_size = size,\n+\n@@ -35,7 +40,1 @@\n-  \/\/ simply increase sizes if too small (assembler will crash if too small)\n-  _initial_stubs_code_size      = 20000 WINDOWS_ONLY(+1000),\n-  _continuation_stubs_code_size =  1000 LP64_ONLY(+2000),\n-  \/\/ AVX512 intrinsics add more code in 64-bit VM,\n-  \/\/ Windows have more code to save\/restore registers\n-  _compiler_stubs_code_size     = 20000 LP64_ONLY(+47000) WINDOWS_ONLY(+2000),\n-  _final_stubs_code_size        = 10000 LP64_ONLY(+20000) WINDOWS_ONLY(+22000) ZGC_ONLY(+20000)\n+  STUBGEN_ARCH_BLOBS_DO(DEFINE_BLOB_SIZE)\n@@ -44,0 +43,2 @@\n+#undef DEFINE_BLOB_SIZE\n+\n@@ -48,8 +49,1 @@\n-#ifdef _LP64\n- private:\n-  static address _get_previous_sp_entry;\n-\n-  static address _f2i_fixup;\n-  static address _f2l_fixup;\n-  static address _d2i_fixup;\n-  static address _d2l_fixup;\n+  \/\/ declare fields for arch-specific entries\n@@ -57,8 +51,2 @@\n-  static address _float_sign_mask;\n-  static address _float_sign_flip;\n-  static address _double_sign_mask;\n-  static address _double_sign_flip;\n-  static address _compress_perm_table32;\n-  static address _compress_perm_table64;\n-  static address _expand_perm_table32;\n-  static address _expand_perm_table64;\n+#define DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address STUB_FIELD_NAME(field_name) ;\n@@ -66,1 +54,2 @@\n- public:\n+#define DECLARE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name)\n@@ -68,3 +57,2 @@\n-  static address get_previous_sp_entry() {\n-    return _get_previous_sp_entry;\n-  }\n+private:\n+  STUBGEN_ARCH_ENTRIES_DO(DECLARE_ARCH_ENTRY, DECLARE_ARCH_ENTRY_INIT)\n@@ -72,3 +60,2 @@\n-  static address f2i_fixup() {\n-    return _f2i_fixup;\n-  }\n+#undef DECLARE_ARCH_ENTRY_INIT\n+#undef DECLARE_ARCH_ENTRY\n@@ -76,3 +63,0 @@\n-  static address f2l_fixup() {\n-    return _f2l_fixup;\n-  }\n@@ -80,3 +64,1 @@\n-  static address d2i_fixup() {\n-    return _d2i_fixup;\n-  }\n+  \/\/ define getters for arch-specific entries\n@@ -84,3 +66,2 @@\n-  static address d2l_fixup() {\n-    return _d2l_fixup;\n-  }\n+#define DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address getter_name() { return STUB_FIELD_NAME(field_name); }\n@@ -88,3 +69,2 @@\n-  static address float_sign_mask() {\n-    return _float_sign_mask;\n-  }\n+#define DEFINE_ARCH_ENTRY_GETTER_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name)\n@@ -92,3 +72,2 @@\n-  static address float_sign_flip() {\n-    return _float_sign_flip;\n-  }\n+public:\n+  STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY_GETTER, DEFINE_ARCH_ENTRY_GETTER_INIT)\n@@ -96,3 +75,2 @@\n-  static address double_sign_mask() {\n-    return _double_sign_mask;\n-  }\n+#undef DEFINE_ARCH_ENTRY_GETTER_INIT\n+#undef DEFINE_ARCH_GETTER_ENTRY\n@@ -100,3 +78,0 @@\n-  static address double_sign_flip() {\n-    return _double_sign_flip;\n-  }\n@@ -104,6 +79,1 @@\n-#else \/\/ !LP64\n-\n- private:\n-  static address _verify_fpu_cntrl_wrd_entry;\n-  static address _d2i_wrapper;\n-  static address _d2l_wrapper;\n+#ifndef _LP64\n@@ -118,4 +88,0 @@\n- public:\n-  static address verify_fpu_cntrl_wrd_entry() { return _verify_fpu_cntrl_wrd_entry; }\n-  static address d2i_wrapper()                { return _d2i_wrapper; }\n-  static address d2l_wrapper()                { return _d2l_wrapper; }\n@@ -136,3 +102,0 @@\n-\n-  static address _verify_mxcsr_entry;\n-\n@@ -152,6 +115,0 @@\n-\n-  \/\/ upper word mask for sha1\n-  static address _upper_word_mask_addr;\n-  \/\/ byte flip mask for sha1\n-  static address _shuffle_byte_flip_mask_addr;\n-\n@@ -161,24 +118,0 @@\n-  static address _vector_short_to_byte_mask;\n-  static address _vector_float_sign_mask;\n-  static address _vector_float_sign_flip;\n-  static address _vector_double_sign_mask;\n-  static address _vector_double_sign_flip;\n-  static address _vector_long_sign_mask;\n-  static address _vector_all_bits_set;\n-  static address _vector_int_mask_cmp_bits;\n-  static address _vector_byte_perm_mask;\n-  static address _vector_int_to_byte_mask;\n-  static address _vector_int_to_short_mask;\n-  static address _vector_32_bit_mask;\n-  static address _vector_64_bit_mask;\n-  static address _vector_int_shuffle_mask;\n-  static address _vector_byte_shuffle_mask;\n-  static address _vector_short_shuffle_mask;\n-  static address _vector_long_shuffle_mask;\n-  static address _vector_iota_indices;\n-  static address _vector_popcount_lut;\n-  static address _vector_count_leading_zeros_lut;\n-  static address _vector_reverse_bit_lut;\n-  static address _vector_reverse_byte_perm_mask_long;\n-  static address _vector_reverse_byte_perm_mask_int;\n-  static address _vector_reverse_byte_perm_mask_short;\n@@ -190,19 +123,0 @@\n-  \/\/ byte flip mask for sha512\n-  static address _pshuffle_byte_flip_mask_addr_sha512;\n-  \/\/ Masks for base64\n-  static address _encoding_table_base64;\n-  static address _shuffle_base64;\n-  static address _avx2_shuffle_base64;\n-  static address _avx2_input_mask_base64;\n-  static address _avx2_lut_base64;\n-  static address _avx2_decode_tables_base64;\n-  static address _avx2_decode_lut_tables_base64;\n-  static address _lookup_lo_base64;\n-  static address _lookup_hi_base64;\n-  static address _lookup_lo_base64url;\n-  static address _lookup_hi_base64url;\n-  static address _pack_vec_base64;\n-  static address _join_0_1_base64;\n-  static address _join_1_2_base64;\n-  static address _join_2_3_base64;\n-  static address _decoding_table_base64;\n@@ -210,2 +124,0 @@\n-  \/\/ byte flip mask for sha256\n-  static address _pshuffle_byte_flip_mask_addr;\n@@ -218,1 +130,0 @@\n-  static address verify_mxcsr_entry()    { return _verify_mxcsr_entry; }\n@@ -226,2 +137,0 @@\n-  static address upper_word_mask_addr() { return _upper_word_mask_addr; }\n-  static address shuffle_byte_flip_mask_addr() { return _shuffle_byte_flip_mask_addr; }\n@@ -229,96 +138,0 @@\n-  static address method_entry_barrier() { return _method_entry_barrier; }\n-\n-  static address vector_short_to_byte_mask() {\n-    return _vector_short_to_byte_mask;\n-  }\n-  static address vector_float_sign_mask() {\n-    return _vector_float_sign_mask;\n-  }\n-\n-  static address vector_float_sign_flip() {\n-    return _vector_float_sign_flip;\n-  }\n-\n-  static address vector_double_sign_mask() {\n-    return _vector_double_sign_mask;\n-  }\n-\n-  static address vector_double_sign_flip() {\n-    return _vector_double_sign_flip;\n-  }\n-\n-  static address vector_all_bits_set() {\n-    return _vector_all_bits_set;\n-  }\n-\n-  static address vector_int_mask_cmp_bits() {\n-    return _vector_int_mask_cmp_bits;\n-  }\n-\n-  static address vector_byte_perm_mask() {\n-    return _vector_byte_perm_mask;\n-  }\n-\n-  static address vector_int_to_byte_mask() {\n-    return _vector_int_to_byte_mask;\n-  }\n-\n-  static address vector_int_to_short_mask() {\n-    return _vector_int_to_short_mask;\n-  }\n-\n-  static address vector_32_bit_mask() {\n-    return _vector_32_bit_mask;\n-  }\n-\n-  static address vector_64_bit_mask() {\n-    return _vector_64_bit_mask;\n-  }\n-\n-  static address vector_int_shuffle_mask() {\n-    return _vector_int_shuffle_mask;\n-  }\n-\n-  static address vector_byte_shuffle_mask() {\n-    return _vector_byte_shuffle_mask;\n-  }\n-\n-  static address vector_short_shuffle_mask() {\n-    return _vector_short_shuffle_mask;\n-  }\n-\n-  static address vector_long_shuffle_mask() {\n-    return _vector_long_shuffle_mask;\n-  }\n-\n-  static address vector_long_sign_mask() {\n-    return _vector_long_sign_mask;\n-  }\n-\n-  static address vector_iota_indices() {\n-    return _vector_iota_indices;\n-  }\n-\n-  static address vector_count_leading_zeros_lut() {\n-    return _vector_count_leading_zeros_lut;\n-  }\n-\n-  static address vector_reverse_bit_lut() {\n-    return _vector_reverse_bit_lut;\n-  }\n-\n-  static address vector_reverse_byte_perm_mask_long() {\n-    return _vector_reverse_byte_perm_mask_long;\n-  }\n-\n-  static address vector_reverse_byte_perm_mask_int() {\n-    return _vector_reverse_byte_perm_mask_int;\n-  }\n-\n-  static address vector_reverse_byte_perm_mask_short() {\n-    return _vector_reverse_byte_perm_mask_short;\n-  }\n-\n-  static address vector_popcount_lut() {\n-    return _vector_popcount_lut;\n-  }\n@@ -328,21 +141,0 @@\n-  static address pshuffle_byte_flip_mask_addr_sha512() { return _pshuffle_byte_flip_mask_addr_sha512; }\n-  static address base64_encoding_table_addr() { return _encoding_table_base64; }\n-  static address base64_shuffle_addr() { return _shuffle_base64; }\n-  static address base64_avx2_shuffle_addr() { return _avx2_shuffle_base64; }\n-  static address base64_avx2_input_mask_addr() { return _avx2_input_mask_base64; }\n-  static address base64_avx2_lut_addr() { return _avx2_lut_base64; }\n-  static address base64_vbmi_lookup_lo_addr() { return _lookup_lo_base64; }\n-  static address base64_vbmi_lookup_hi_addr() { return _lookup_hi_base64; }\n-  static address base64_vbmi_lookup_lo_url_addr() { return _lookup_lo_base64url; }\n-  static address base64_vbmi_lookup_hi_url_addr() { return _lookup_hi_base64url; }\n-  static address base64_vbmi_pack_vec_addr() { return _pack_vec_base64; }\n-  static address base64_vbmi_join_0_1_addr() { return _join_0_1_base64; }\n-  static address base64_vbmi_join_1_2_addr() { return _join_1_2_base64; }\n-  static address base64_vbmi_join_2_3_addr() { return _join_2_3_base64; }\n-  static address base64_decoding_table_addr() { return _decoding_table_base64; }\n-  static address base64_AVX2_decode_tables_addr() { return _avx2_decode_tables_base64; }\n-  static address base64_AVX2_decode_LUT_tables_addr() { return _avx2_decode_lut_tables_base64; }\n-  static address compress_perm_table32() { return _compress_perm_table32; }\n-  static address compress_perm_table64() { return _compress_perm_table64; }\n-  static address expand_perm_table32() { return _expand_perm_table32; }\n-  static address expand_perm_table64() { return _expand_perm_table64; }\n@@ -350,1 +142,1 @@\n-  static address pshuffle_byte_flip_mask_addr() { return _pshuffle_byte_flip_mask_addr; }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":28,"deletions":236,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -34,5 +34,0 @@\n-address StubRoutines::x86::_verify_fpu_cntrl_wrd_entry = nullptr;\n-\n-address StubRoutines::x86::_d2i_wrapper = nullptr;\n-address StubRoutines::x86::_d2l_wrapper = nullptr;\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86_32.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,11 +36,0 @@\n-\n-address StubRoutines::x86::_get_previous_sp_entry = nullptr;\n-\n-address StubRoutines::x86::_f2i_fixup = nullptr;\n-address StubRoutines::x86::_f2l_fixup = nullptr;\n-address StubRoutines::x86::_d2i_fixup = nullptr;\n-address StubRoutines::x86::_d2l_fixup = nullptr;\n-address StubRoutines::x86::_float_sign_mask = nullptr;\n-address StubRoutines::x86::_float_sign_flip = nullptr;\n-address StubRoutines::x86::_double_sign_mask = nullptr;\n-address StubRoutines::x86::_double_sign_flip = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86_64.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights\n+ * reserved.  Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ZERO_STUBDECLARATIONS_HPP\n+#define CPU_ZERO_STUBDECLARATIONS_HPP\n+\n+#define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n+  do_arch_blob(initial, 0)                                              \\\n+\n+\n+#define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \\\n+                                           do_arch_blob,                \\\n+                                           do_arch_entry,               \\\n+                                           do_arch_entry_init)          \\\n+  do_arch_blob(continuation, 0)                                         \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \\\n+                                       do_arch_blob,                    \\\n+                                       do_arch_entry,                   \\\n+                                       do_arch_entry_init)              \\\n+  do_arch_blob(compiler, 0)                                             \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \\\n+                                    do_arch_blob,                       \\\n+                                    do_arch_entry,                      \\\n+                                    do_arch_entry_init)                 \\\n+  do_arch_blob(final, 0)                                                \\\n+\n+\n+#endif \/\/ CPU_ZERO_STUBDECLARATIONS_HPP\n","filename":"src\/hotspot\/cpu\/zero\/stubDeclarations_zero.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -183,2 +183,0 @@\n-    \/\/ Generates all stubs and initializes the entry points\n-\n@@ -203,2 +201,3 @@\n-  void generate_final_stubs() {\n-    \/\/ Generates all stubs and initializes the entry points\n+  void generate_continuation_stubs() {\n+    \/\/ do nothing\n+  }\n@@ -206,0 +205,5 @@\n+  void generate_compiler_stubs() {\n+    \/\/ do nothing\n+  }\n+\n+  void generate_final_stubs() {\n@@ -212,2 +216,3 @@\n-  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    if (kind == Initial_stubs) {\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+    switch(blob_id) {\n+    case initial_id:\n@@ -215,1 +220,8 @@\n-    } else if (kind == Final_stubs) {\n+      break;\n+     case continuation_id:\n+       generate_continuation_stubs();\n+      break;\n+    case compiler_id:\n+       \/\/ do nothing\n+      break;\n+    case final_id:\n@@ -217,1 +229,5 @@\n-    }\n+      break;\n+    default:\n+      fatal(\"unexpected blob id: %d\", blob_id);\n+      break;\n+    };\n@@ -221,2 +237,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+\n+\/\/ zero has no arch-specific stubs nor any associated entries\n","filename":"src\/hotspot\/cpu\/zero\/stubRoutines_zero.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,8 +42,12 @@\n-  enum platform_dependent_constants {\n-    \/\/ The assembler will fail with a guarantee if these are too small.\n-    \/\/ Simply increase them if that happens.\n-    _initial_stubs_code_size      = 0,\n-    _continuation_stubs_code_size = 0,\n-    _compiler_stubs_code_size     = 0,\n-    _final_stubs_code_size        = 0\n-  };\n+\/\/ emit enum used to size per-blob code buffers\n+\n+#define DEFINE_BLOB_SIZE(blob_name, size) \\\n+  _ ## blob_name ## _code_size = size,\n+\n+enum platform_dependent_constants {\n+  STUBGEN_ARCH_BLOBS_DO(DEFINE_BLOB_SIZE)\n+};\n+\n+#undef DEFINE_BLOB_SIZE\n+\n+\/\/ zero has no arch-specific stubs nor any associated entries\n","filename":"src\/hotspot\/cpu\/zero\/stubRoutines_zero.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -541,1 +541,1 @@\n-  load_long_func_t func = CAST_TO_FN_PTR(load_long_func_t, StubRoutines::atomic_load_long_entry());\n+  load_long_func_t func = CAST_TO_FN_PTR(load_long_func_t, StubRoutines::Arm::atomic_load_long_entry());\n@@ -555,1 +555,1 @@\n-  store_long_func_t func = CAST_TO_FN_PTR(store_long_func_t, StubRoutines::atomic_store_long_entry());\n+  store_long_func_t func = CAST_TO_FN_PTR(store_long_func_t, StubRoutines::Arm::atomic_store_long_entry());\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -72,0 +73,7 @@\n+  _blob_id = StubGenBlobId::NO_BLOBID;\n+  _print_code = PrintStubCode || print_code;\n+}\n+\n+StubCodeGenerator::StubCodeGenerator(CodeBuffer* code, StubGenBlobId blob_id, bool print_code) {\n+  _masm = new MacroAssembler(code);\n+  _blob_id = blob_id;\n@@ -114,0 +122,5 @@\n+#ifdef ASSERT\n+void StubCodeGenerator::verify_stub(StubGenStubId stub_id) {\n+  assert(StubRoutines::stub_to_blob(stub_id) == blob_id(), \"wrong blob %s for generation of stub %s\", StubRoutines::get_blob_name(blob_id()), StubRoutines::get_stub_name(stub_id));\n+}\n+#endif\n@@ -125,0 +138,6 @@\n+StubCodeMark::StubCodeMark(StubCodeGenerator* cgen, StubGenStubId stub_id) : StubCodeMark(cgen, \"StubRoutines\", StubRoutines::get_stub_name(stub_id)) {\n+#ifdef ASSERT\n+  cgen->verify_stub(stub_id);\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -99,0 +99,5 @@\n+\/\/ forward declare blob and stub id enums\n+\n+enum StubGenBlobId : int;\n+enum StubGenStubId : int;\n+\n@@ -105,1 +110,1 @@\n-\n+  StubGenBlobId _blob_id;\n@@ -111,0 +116,1 @@\n+  StubCodeGenerator(CodeBuffer* code, StubGenBlobId blob_id, bool print_code = false);\n@@ -114,0 +120,1 @@\n+  StubGenBlobId blob_id()                        { return _blob_id; }\n@@ -118,14 +125,3 @@\n-  enum StubsKind {\n-    Initial_stubs,       \/\/ Stubs used by Runtime, Interpreter and compiled code.\n-                         \/\/ Have to be generated very early during VM startup.\n-\n-    Continuation_stubs,  \/\/ Stubs used by virtual threads.\n-                         \/\/ Generated after GC barriers initialization but before\n-                         \/\/ Interpreter initialization.\n-\n-    Compiler_stubs,      \/\/ Intrinsics and other stubs used only by compiled code.\n-                         \/\/ Can be generated by compiler (C2\/JVMCI) thread based on\n-                         \/\/ DelayCompilerStubsGeneration flag.\n-\n-    Final_stubs          \/\/ The rest of stubs. Generated at the end of VM init.\n-  };\n+#ifdef ASSERT\n+  void verify_stub(StubGenStubId stub_id);\n+#endif\n@@ -134,1 +130,0 @@\n-\n@@ -147,0 +142,1 @@\n+  StubCodeMark(StubCodeGenerator* cgen, StubGenStubId stub_id);\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.hpp","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+\/\/ client macro to operate on shared stubs\n+\/\/\n@@ -76,0 +78,2 @@\n+\/\/ client macro to operate on c1 stubs\n+\/\/\n@@ -138,0 +142,2 @@\n+\/\/ client macro to operate on c2 stubs\n+\/\/\n@@ -168,1 +174,748 @@\n-\/\/ generate a stub or blob id enum tag from a name\n+\/\/ Stub Generator Blobs and Stubs Overview\n+\/\/\n+\/\/ StubGenerator stubs do not require their own individual blob. They\n+\/\/ are generated in batches into one of four distinct BufferBlobs:\n+\/\/\n+\/\/ 1) Initial stubs\n+\/\/ 2) Continuation stubs\n+\/\/ 3) Compiler stubs\n+\/\/ 4) Final stubs\n+\/\/\n+\/\/ Creation of each successive BufferBlobs is staged to ensure that\n+\/\/ specific VM subsystems required by those stubs are suitably\n+\/\/ initialized before generated code attempt to reference data or\n+\/\/ addresses exported by those subsystems. The sequencing of\n+\/\/ initialization must be taken into account when adding a new stub\n+\/\/ declaration.\n+\/\/\n+\/\/ StubGenerator stubs are declared using template macros, one set of\n+\/\/ declarations per blob (see below), with arch-specific stubs for any\n+\/\/ gven blob declared after generic stubs for that blob. Blobs are\n+\/\/ created in a fixed order during startup, which is reflected in the\n+\/\/ order of the declaration set. Stubs within a blob are currently\n+\/\/ created in an order determined by the arch-specific generator code\n+\/\/ which may not reflect the order of stub declarations. It is not\n+\/\/ straightforward to enforce a strict ordering. not least because\n+\/\/ arch-specific stub creation may need to be interleaved with generic\n+\/\/ stub creation.\n+\/\/\n+\/\/ Blob and stub declaration templates are used to generate a variety\n+\/\/ of C++ code elements needed to manage stubs.\n+\/\/\n+\/\/ Blob identifiers:\n+\/\/\n+\/\/ public enum StubGenBlobId is generated to identify each of the\n+\/\/ StubGenerator blobs in blob declaration order. This enum is\n+\/\/ provided for use by client code to identify a specific blob. For a\n+\/\/ blob declared with name <blob_name> the associated enum value is\n+\/\/ StubGenBlobId::<blob_name>_id.\n+\/\/\n+\/\/ Global stub identifiers:\n+\/\/\n+\/\/ public enum StubGenStubId is generated to identify all declared\n+\/\/ stubs across all blobs, sorted first by blob declaration order and\n+\/\/ then within a blob by stub declaration order, generic stubs before\n+\/\/ arch-specific stubs. This enum is provided for use by client code\n+\/\/ to identify a specific stub, independent of the blob it belongs to.\n+\/\/ For a stub declared with name <stub_name> the associated enum value\n+\/\/ is StubGenStubId::<stub_name>_id.\n+\/\/\n+\/\/ Blob-local stub identifiers:\n+\/\/\n+\/\/ For each blob <blob_name>, public enum StubGenStubId_<blob_name> is\n+\/\/ generated to enumerate all stubs within the blob in stub\n+\/\/ declaration order, generic stubs before arch-specific stubs. This\n+\/\/ enum is provided only in a non-product build and is intended for\n+\/\/ internal use by class StubRoutines to validate stub declarations.\n+\/\/ For a stub declared with name <stub_name> belonging to blob\n+\/\/ <blob_name> the associated enum value is\n+\/\/ StubGenStubId::<blob_name>_<stub_name>_id.\n+\/\/\n+\/\/ Stub names and associated getters:\n+\/\/\n+\/\/ Two private static fields are generated to hold the names of the\n+\/\/ four generated blobs and all the generated stubs.\n+\/\/\n+\/\/  const char* StubRoutines::_blob_names[];\n+\/\/  const char* StubRoutines::_stub_names[];\n+\/\/\n+\/\/ The entry in _blob_names for a blob declared with name <blob_name>\n+\/\/ will be \"<blob_name>\".\n+\/\/\n+\/\/ The entry in _stub_names for a stub declared with name <stub_name>\n+\/\/ will be \"<stub_name>\".\n+\/\/\n+\/\/ Corresponding public static lookup methods are generated to allow\n+\/\/ names to be looked up by blob or global stub id.\n+\/\/\n+\/\/  const char* StubRoutines::get_blob_name(StubGenBlobId id)\n+\/\/  const char* StubRoutines::get_stub_name(StubGenStubId id)\n+\/\/\n+\/\/ These name lookup methods should be used by generic and\n+\/\/ cpu-specific client code to ensure that blobs and stubs are\n+\/\/ identified consistently.\n+\/\/\n+\/\/ Blob code buffer sizes:\n+\/\/\n+\/\/ An enumeration enum platform_dependent_constants is generated in\n+\/\/ the architecture specific StubRoutines header. For each blob named\n+\/\/ <nnn> an associated enum tag is generated which defines the\n+\/\/ relevant size\n+\/\/\n+\/\/  _<nnn>_stubs_code_size      = <size>,\n+\/\/\n+\/\/ For example,\n+\/\/\n+\/\/ enum platform_dependent_constants {\n+\/\/   _initial_stubs_code_size      = 10000,\n+\/\/   _continuation_stubs_code_size =  2000,\n+\/\/   . . .\n+\/\/\n+\/\/ Blob fields and associated getters:\n+\/\/\n+\/\/ For each blob named <nnn> a private field declaration will be\n+\/\/ generated: static field address StubRoutines::_<nnn>_stubs_code and\n+\/\/ a declaration provided to initialise it to nullptr. A corresponding\n+\/\/ public getter method address StubRoutines::_<nnn>_stubs_code() will\n+\/\/ be generated.\n+\/\/\n+\/\/ Blob initialization routines:\n+\/\/\n+\/\/ For each blob named <nnn> an initalization function is defined\n+\/\/ which allows clients to schedule blob and stub generation during\n+\/\/ JVM bootstrap:\n+\/\/\n+\/\/ void <nnn>_stubs_init() { StubRoutines::initialize_<nnn>_stubs(); }\n+\/\/\n+\/\/ A declaration and definition of each underlying implementation\n+\/\/ method StubRoutines::initialize_<nnn>_stubs() is also generated.\n+\/\/\n+\/\/ Stub entry points and associated getters:\n+\/\/\n+\/\/ Some generated stubs require their main entry point and, possibly,\n+\/\/ auxiliary entry points to be stored in fields declared either as\n+\/\/ members of class SharedRuntime. For stubs that are specific to a\n+\/\/ given cpu, the field needs to be declared in an arch-specific inner\n+\/\/ class of SharedRuntime.\n+\/\/\n+\/\/ For a generic stub named <nnn> the corresponding main entry usually\n+\/\/ has the same name: static field address StubRoutines::_<nnn> modulo\n+\/\/ an _ prefix.  An associated getter method is also generated, again\n+\/\/ normally using the same name: address StubRoutines::<nnn>() e.g.\n+\/\/\n+\/\/  class StubRoutines {\n+\/\/    . . .\n+\/\/    static address _aescrypt_encryptBlock;\n+\/\/    . . .\n+\/\/    address aescrypt_encryptBlock() { return _aescrypt_encryptBlock; }\n+\/\/\n+\/\/ Multiple fields and getters may be generated where a stub has more\n+\/\/ than one entry point, each provided with their own unique field and\n+\/\/ getter name e.g.\n+\/\/\n+\/\/    . . .\n+\/\/    static address _call_stub;\n+\/\/    static address _call_stub_return_address;\n+\/\/    . . .\n+\/\/    static address call_stub_entry() { return _call_stub; }\n+\/\/    static address call_stub_return_address() { return _call_stub_return_address; }\n+\/\/\n+\/\/ In special cases a stub may declare a (compile-time) fixed size\n+\/\/ array of entries, in which case an address array field is\n+\/\/ generated,along with a getter that accepts an index as argument:\n+\/\/\n+\/\/    . . .\n+\/\/   static address _lookup_secondary_supers_table[Klass::SECONDARY_SUPERS_TABLE_SIZE];\n+\/\/   . . .\n+\/\/   static address lookup_secondary_supers_table(int i);\n+\/\/\n+\/\/ CPU-specific stub entry points and associated getters:\n+\/\/\n+\/\/ For an arch-specific stub with name <nnn> belonging to architecture\n+\/\/ <arch> private field address StubRoutines::<arch>::_<nnn> is\n+\/\/ generated to hold the entry address. An associated public getter\n+\/\/ method address StubRoutines::<arch>::<nnn>() is also generated e.g.\n+\/\/\n+\/\/  class StubRoutines {\n+\/\/    . . .\n+\/\/    class x86 {\n+\/\/      . . .\n+\/\/      static address _f2i_fixup;\n+\/\/      . . .\n+\/\/      static address f2i_fixup() { return _f2i_fixup; }\n+\/\/      static void set_f2i_fixup(address a) { _f2i_fixup = a; }\n+\/\/\n+\n+\n+\/\/--------------------------------------------------\n+\/\/ Stub Generator Blob, Stub and Entry Declarations\n+\/\/ -------------------------------------------------\n+\/\/\n+\/\/ The formal declarations of blobs, stubs and entries provided below\n+\/\/ are used to schedule application of template macros that either\n+\/\/ declare or define the C++ code we need to manage those blobs, stubs\n+\/\/ and entries.\n+\/\/\n+\/\/ All ports employ the same blobs. However, the organization of the\n+\/\/ stubs and entry points in a blob can vary from one port to the\n+\/\/ next. A template macro is provided to specify the details of each\n+\/\/ blob, including generic and arch-specific variations.\n+\/\/\n+\/\/ If you want to define a new stub or entry then you can do so by\n+\/\/ adding suitable declarations within the scope of the relevant blob.\n+\/\/ For the blob with name BLOB_NAME add your declarations to macro\n+\/\/ STUBGEN_<BLOB_NAME>_STUBS_DO. Generic stubs and entries are\n+\/\/ declared using the do_stub, do_entry and do_entry_init and\n+\/\/ array_entry templates (see below for full details). The do_blob\n+\/\/ and end_blob templates should never need to be modified.\n+\/\/\n+\/\/ Some stubs and their associated entries are architecture-specific.\n+\/\/ They need to be declared in the architecture-specific header file\n+\/\/ src\/cpu\/<arch>stubDecolaration_<arch>.cpp. For the blob with name\n+\/\/ BLOB_NAME the correspnding declarations macro are provided by macro\n+\/\/ STUBGEN_<BLOB_NAME>_STUBS_ARCH_DO. Arch-specific stubs and entries\n+\/\/ are declared using the do_stub, do_arch_entry and\n+\/\/ do_arch_entry_init templates (see below for details). An\n+\/\/ architecure also needs to specify architecture parameters used when\n+\/\/ creating each blob. These are defined using the do_arch_blob\n+\/\/ template (see below).\n+\/\/\n+\/\/ Note, the client macro STUBGEN_ALL_DO is provided to allow client\n+\/\/ code to iterate over all blob, stub or entry declarations. It has\n+\/\/ only been split into separate per-blob generic submacros,\n+\/\/ STUBGEN_<BLOB_NAME>_BLOBS_DO and arch-specific per-blob submacros\n+\/\/ STUBGEN_<BLOB_NAME>_BLOBS_ARCH_DO for convenience, to make it\n+\/\/ easier to manage definitions. The blob_specific sub-macros should\n+\/\/ not be called directly by client code (in class StubRoutines and\n+\/\/ StubGenerator),\n+\/\/\n+\/\/ A client wishing to generate blob, stub or entry code elements is\n+\/\/ expected to pass template macros as arguments to STUBGEN_ALL_DO.\n+\/\/ This will schedule code generation code for whatever C++ code\n+\/\/ elements are required to implement a declaration or definition\n+\/\/ relevant to each blob, stub or entry. Alternatively, a client can\n+\/\/ operate on a subset of the declarations by calling macros\n+\/\/ STUBGEN_BLOBS_DO, STUBGEN_STUBS_DO, STUBGEN_BLOBS_STUBS_DO,\n+\/\/ STUBGEN_ENTRIES_DO and STUBGEN_ARCH_ENTRIES_DO.\n+\/\/\n+\/\/ The do_blob and end_blob templates receive a blob name as argument.\n+\/\/\n+\/\/ do_blob(blob_name)\n+\/\/ end_blob(blob_name)\n+\/\/\n+\/\/ do_blob is primarily used to define a global enum tag for a blob\n+\/\/ and an associated constant string name, both for use by client\n+\/\/ code.\n+\/\/\n+\/\/ end_blob is provided for use in combination with do_blob to to open\n+\/\/ and close a blob-local enum type identifying all stubs within a\n+\/\/ given blob. This enum is private to the stub management code and\n+\/\/ used to validate correct use of stubs within a given blob.\n+\/\/\n+\/\/ The do_stub template receives a blob name and stub name as argument.\n+\/\/\n+\/\/ do_stub(blob_name, stub_name)\n+\/\/\n+\/\/ do_stub is primarily used to define a global enum tag for a stub\n+\/\/ and a constant string name, both for use by client code. It is also\n+\/\/ used to declare a tag within the blob-local enum type used to\n+\/\/ validate correct use of stubs within their declared blob. Finally,\n+\/\/ it is also used to declare a name for each stub.\n+\/\/\n+\/\/ The do_entry and do_entry_array templates receive 4 or 5 arguments\n+\/\/\n+\/\/ do_entry(blob_name, stub_name, field_name, getter_name)\n+\/\/\n+\/\/ do_entry_init(blob_name, stub_name, field_name, getter_name, init_function)\n+\/\/\n+\/\/ do_entry_array(blob_name, stub_name, field_name, getter_name, count)\n+\/\/\n+\/\/ do_entry is used to declare or define a static field of class\n+\/\/ StubRoutines with type address that stores a specific entry point\n+\/\/ for a given stub. n.b. the number of entries associated with a stub\n+\/\/ is often one but it can be more than one and, in a few special\n+\/\/ cases, it is zero. do_entry is also used to declare and define an\n+\/\/ associated getter method for the field. do_entry is used to declare\n+\/\/ fields that should be initialized to nullptr.\n+\/\/\n+\/\/ do_entry_init is used when the field needs to be initialized a\n+\/\/ specific function or method .\n+\/\/\n+\/\/ do_entry_array is used for the special case where a stub employs an\n+\/\/ array to store multiple entries which are stored at generate time\n+\/\/ and subsequently accessed using an associated index (e.g. the\n+\/\/ secondary supers table stub which has 63 qassociated entries).\n+\/\/ Note that this distinct from the case where a stub generates\n+\/\/ multiple entries each of them stored in its own named field with\n+\/\/ its own named getter. In the latter case multiple do_entry or\n+\/\/ do_entry_init declarations are associated with the stub.\n+\/\/\n+\/\/ blob_name and stub_name are the names of the blob and stub to which\n+\/\/ the entry belongs.\n+\/\/\n+\/\/ field_name is prefixed with a leading '_' to produce the name of\n+\/\/ the field used to store an entry address for the stub. For stubs\n+\/\/ with one entry field_name is normally, but not always, the same as\n+\/\/ stub_name.  Obviously when a stub has multiple entries secondary\n+\/\/ names must be different to stub_name. For normal entry declarations\n+\/\/ the field type is address. For do_entry_array declarations the field\n+\/\/ type is an address[] whose size is defined by then parameter.\n+\/\/\n+\/\/ getter_name is the name of a getter that is generated to allow\n+\/\/ access to the field. It is normally, but not always, the same as\n+\/\/ stub_name. For normal entry declarations the getter signature is\n+\/\/ (void).  For do_entry_array declarations the getter signature is\n+\/\/ (int).\n+\/\/\n+\/\/ init_function is the name of an function or method which should be\n+\/\/ assigned to the field as a default value (n.b. fields declared\n+\/\/ using do_entry are intialised to nullptr, array fields declared\n+\/\/ using do_entry_array have their elements initalized to nullptr).\n+\/\/\n+\/\/ Architecture-specific blob details need to be specified using the\n+\/\/ do_arch_blob template\n+\/\/\n+\/\/ do_arch_blob(blob_name, size)\n+\/\/\n+\/\/ Currently, the do_arch_blob macro is only used to define the size\n+\/\/ of the code buffer into which blob-specific stub code is to be\n+\/\/ generated.\n+\/\/\n+\/\/ Architecture-specific entries need to be declared using the\n+\/\/ do_arch_entry template\n+\/\/\n+\/\/ do_arch_entry(arch, blob_name, stub_name, field_name, getter_name)\n+\/\/\n+\/\/ do_arch_entry_init(arch, blob_name, stub_name, field_name,\n+\/\/                    getter_name, init_function)\n+\/\/\n+\/\/ The only difference between these templates and the generic ones is\n+\/\/ that they receive an extra argument which identifies the current\n+\/\/ architecture e.g. x86, aarch64 etc.\n+\/\/\n+\/\/ Currently there is no support for a do_arch_array_entry template.\n+\n+\/\/ Include arch-specific stub and entry declarations and make sure the\n+\/\/ relevant template macros ahve been defined\n+\n+#include CPU_HEADER(stubDeclarations)\n+\n+#ifndef STUBGEN_INITIAL_BLOBS_ARCH_DO\n+#error \"Arch-specific directory failed to declare required initial stubs and entries\"\n+#endif\n+\n+#ifndef STUBGEN_CONTINUATION_BLOBS_ARCH_DO\n+#error \"Arch-specific directory failed to declare required continuation stubs and entries\"\n+#endif\n+\n+#ifndef STUBGEN_COMPILER_BLOBS_ARCH_DO\n+#error \"Arch-specific directory failed to declare required compiler stubs and entries\"\n+#endif\n+\n+#ifndef STUBGEN_FINAL_BLOBS_ARCH_DO\n+#error \"Arch-specific directory failed to declare required final stubs and entries\"\n+#endif\n+\n+\/\/ Iterator macros to apply templates to all relevant blobs, stubs and\n+\/\/ entries. Clients should use STUBGEN_ALL_DO, STUBGEN_BLOBS_DO,\n+\/\/ STUBGEN_STUBS_DO, STUBGEN_BLOBS_STUBS_DO, STUBGEN_ENTRIES_DO,\n+\/\/ STUBGEN_ARCH_BLOBS_DO and STUBGEN_ARCH_ENTRIES_DO.\n+\/\/\n+\/\/ n.b. Client macros appear after the STUBGEN_<BLOB_NAME>_BLOBS_DO\n+\/\/ submacros which follow next. These submacros are not intended to be\n+\/\/ called directly. They serve to define the main client macro\n+\/\/ STUBGEN_ALL_DO and, from there, the other more specific client\n+\/\/ macros. n.b. multiple, 'per-blob' submacros are used to declare\n+\/\/ each group of stubs and entries, because that makes it simpler to\n+\/\/ lookup and update related elements. If you need to update these\n+\/\/ submacros to change the list of stubs or entries be sure to locate\n+\/\/ stubs within the correct blob and locate entry declarations\n+\/\/ immediately after their associated stub declaration.\n+\n+#define STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                     \\\n+                                 do_stub,                               \\\n+                                 do_entry, do_entry_init,               \\\n+                                 do_entry_array,                        \\\n+                                 do_arch_blob,                          \\\n+                                 do_arch_entry, do_arch_entry_init)     \\\n+  do_blob(initial)                                                      \\\n+  do_stub(initial, call_stub)                                           \\\n+  do_entry(initial, call_stub, call_stub_entry, call_stub_entry)        \\\n+  do_entry(initial, call_stub, call_stub_return_address,                \\\n+           call_stub_return_address)                                    \\\n+  do_stub(initial, forward_exception)                                   \\\n+  do_entry(initial, forward_exception, forward_exception_entry,         \\\n+           forward_exception_entry)                                     \\\n+  do_stub(initial, catch_exception)                                     \\\n+  do_entry(initial, catch_exception, catch_exception_entry,             \\\n+           catch_exception_entry)                                       \\\n+  do_stub(initial, fence)                                               \\\n+  do_entry(initial, fence, fence_entry, fence_entry)                    \\\n+  do_stub(initial, atomic_xchg)                                         \\\n+  do_entry(initial, atomic_xchg, atomic_xchg_entry, atomic_xchg_entry)  \\\n+  do_stub(initial, atomic_cmpxchg)                                      \\\n+  do_entry(initial, atomic_cmpxchg, atomic_cmpxchg_entry,               \\\n+           atomic_cmpxchg_entry)                                        \\\n+  do_stub(initial, atomic_cmpxchg_long)                                 \\\n+  do_entry(initial, atomic_cmpxchg_long, atomic_cmpxchg_long_entry,     \\\n+           atomic_cmpxchg_long_entry)                                   \\\n+  do_stub(initial, updateBytesCRC32)                                    \\\n+  do_entry(initial, updateBytesCRC32, updateBytesCRC32,                 \\\n+           updateBytesCRC32)                                            \\\n+  do_entry(initial, updateBytesCRC32, crc_table_adr, crc_table_addr)    \\\n+  do_stub(initial, updateBytesCRC32C)                                   \\\n+  do_entry(initial, updateBytesCRC32C, updateBytesCRC32C,               \\\n+           updateBytesCRC32C)                                           \\\n+  do_entry(initial, updateBytesCRC32C, crc32c_table_addr,               \\\n+           crc32c_table_addr)                                           \\\n+  do_stub(initial, f2hf)                                                \\\n+  do_entry(initial, f2hf, f2hf, f2hf_adr)                               \\\n+  do_stub(initial, hf2f)                                                \\\n+  do_entry(initial, hf2f, hf2f, hf2f_adr)                               \\\n+  do_stub(initial, dexp)                                                \\\n+  do_entry(initial, dexp, dexp, dexp)                                   \\\n+  do_stub(initial, dlog)                                                \\\n+  do_entry(initial, dlog, dlog, dlog)                                   \\\n+  do_stub(initial, dlog10)                                              \\\n+  do_entry(initial, dlog10, dlog10, dlog10)                             \\\n+  do_stub(initial, dpow)                                                \\\n+  do_entry(initial, dpow, dpow, dpow)                                   \\\n+  do_stub(initial, dsin)                                                \\\n+  do_entry(initial, dsin, dsin, dsin)                                   \\\n+  do_stub(initial, dcos)                                                \\\n+  do_entry(initial, dcos, dcos, dcos)                                   \\\n+  do_stub(initial, dtan)                                                \\\n+  do_entry(initial, dtan, dtan, dtan)                                   \\\n+  do_stub(initial, dtanh)                                               \\\n+  do_entry(initial, dtanh, dtanh, dtanh)                                \\\n+  do_stub(initial, fmod)                                                \\\n+  do_entry(initial, fmod, fmod, fmod)                                   \\\n+  \/* following generic entries should really be x86_32 only *\/          \\\n+  do_stub(initial, dlibm_sin_cos_huge)                                  \\\n+  do_entry(initial, dlibm_sin_cos_huge, dlibm_sin_cos_huge,             \\\n+           dlibm_sin_cos_huge)                                          \\\n+  do_stub(initial, dlibm_reduce_pi04l)                                  \\\n+  do_entry(initial, dlibm_reduce_pi04l, dlibm_reduce_pi04l,             \\\n+           dlibm_reduce_pi04l)                                          \\\n+  do_stub(initial, dlibm_tan_cot_huge)                                  \\\n+  do_entry(initial, dlibm_tan_cot_huge, dlibm_tan_cot_huge,             \\\n+           dlibm_tan_cot_huge)                                          \\\n+  \/* merge in stubs and entries declared in arch header *\/              \\\n+  STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub, do_arch_blob,                  \\\n+                                do_arch_entry, do_arch_entry_init)      \\\n+  end_blob(initial)                                                     \\\n+\n+\n+#define STUBGEN_CONTINUATION_BLOBS_DO(do_blob, end_blob,                \\\n+                                      do_stub,                          \\\n+                                      do_entry, do_entry_init,          \\\n+                                      do_entry_array,                   \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry, do_arch_entry_init) \\\n+  do_blob(continuation)                                                 \\\n+  do_stub(continuation, cont_thaw)                                      \\\n+  do_entry(continuation, cont_thaw, cont_thaw, cont_thaw)               \\\n+  do_stub(continuation, cont_preempt)                                   \\\n+  do_entry(continuation, cont_prempt, cont_preempt_stub,                \\\n+           cont_preempt_stub)                                           \\\n+  do_stub(continuation, cont_returnBarrier)                             \\\n+  do_entry(continuation, cont_returnBarrier, cont_returnBarrier,        \\\n+           cont_returnBarrier)                                          \\\n+  do_stub(continuation, cont_returnBarrierExc)                          \\\n+  do_entry(continuation, cont_returnBarrierExc, cont_returnBarrierExc,  \\\n+           cont_returnBarrierExc)                                       \\\n+  \/* merge in stubs and entries declared in arch header *\/              \\\n+  STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,  do_arch_blob,            \\\n+                                     do_arch_entry, do_arch_entry_init) \\\n+  end_blob(continuation)                                                \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_DO(do_blob, end_blob,                    \\\n+                                  do_stub,                              \\\n+                                  do_entry, do_entry_init,              \\\n+                                  do_entry_array,                       \\\n+                                  do_arch_blob,                         \\\n+                                  do_arch_entry, do_arch_entry_init)    \\\n+  do_blob(compiler)                                                     \\\n+  do_stub(compiler, atomic_add)                                         \\\n+  do_entry(compiler, atomic_add, atomic_add_entry, atomic_add_entry)    \\\n+  do_stub(compiler, array_sort)                                         \\\n+  do_entry(compiler, array_sort, array_sort, select_arraysort_function) \\\n+  do_stub(compiler, array_partition)                                    \\\n+  do_entry(compiler, array_partition, array_partition,                  \\\n+           select_array_partition_function)                             \\\n+  do_stub(compiler, aescrypt_encryptBlock)                              \\\n+  do_entry(compiler, aescrypt_encryptBlock, aescrypt_encryptBlock,      \\\n+           aescrypt_encryptBlock)                                       \\\n+  do_stub(compiler, aescrypt_decryptBlock)                              \\\n+  do_entry(compiler, aescrypt_decryptBlock, aescrypt_decryptBlock,      \\\n+           aescrypt_decryptBlock)                                       \\\n+  do_stub(compiler, cipherBlockChaining_encryptAESCrypt)                \\\n+  do_entry(compiler, cipherBlockChaining_encryptAESCrypt,               \\\n+           cipherBlockChaining_encryptAESCrypt,                         \\\n+           cipherBlockChaining_encryptAESCrypt)                         \\\n+  do_stub(compiler, cipherBlockChaining_decryptAESCrypt)                \\\n+  do_entry(compiler, cipherBlockChaining_decryptAESCrypt,               \\\n+           cipherBlockChaining_decryptAESCrypt,                         \\\n+           cipherBlockChaining_decryptAESCrypt)                         \\\n+  do_stub(compiler, electronicCodeBook_encryptAESCrypt)                 \\\n+  do_entry(compiler, electronicCodeBook_encryptAESCrypt,                \\\n+           electronicCodeBook_encryptAESCrypt,                          \\\n+           electronicCodeBook_encryptAESCrypt)                          \\\n+  do_stub(compiler, electronicCodeBook_decryptAESCrypt)                 \\\n+  do_entry(compiler, electronicCodeBook_decryptAESCrypt,                \\\n+           electronicCodeBook_decryptAESCrypt,                          \\\n+           electronicCodeBook_decryptAESCrypt)                          \\\n+  do_stub(compiler, counterMode_AESCrypt)                               \\\n+  do_entry(compiler, counterMode_AESCrypt, counterMode_AESCrypt,        \\\n+           counterMode_AESCrypt)                                        \\\n+  do_stub(compiler, galoisCounterMode_AESCrypt)                         \\\n+  do_entry(compiler, galoisCounterMode_AESCrypt,                        \\\n+           galoisCounterMode_AESCrypt, galoisCounterMode_AESCrypt)      \\\n+  do_stub(compiler, ghash_processBlocks)                                \\\n+  do_entry(compiler, ghash_processBlocks, ghash_processBlocks,          \\\n+           ghash_processBlocks)                                         \\\n+  do_stub(compiler, chacha20Block)                                      \\\n+  do_entry(compiler, chacha20Block, chacha20Block, chacha20Block)       \\\n+  do_stub(compiler, data_cache_writeback)                               \\\n+  do_entry(compiler, data_cache_writeback, data_cache_writeback,        \\\n+           data_cache_writeback)                                        \\\n+  do_stub(compiler, data_cache_writeback_sync)                          \\\n+  do_entry(compiler, data_cache_writeback_sync,                         \\\n+           data_cache_writeback_sync, data_cache_writeback_sync)        \\\n+  do_stub(compiler, base64_encodeBlock)                                 \\\n+  do_entry(compiler, base64_encodeBlock, base64_encodeBlock,            \\\n+           base64_encodeBlock)                                          \\\n+  do_stub(compiler, base64_decodeBlock)                                 \\\n+  do_entry(compiler, base64_decodeBlock, base64_decodeBlock,            \\\n+           base64_decodeBlock)                                          \\\n+  do_stub(compiler, poly1305_processBlocks)                             \\\n+  do_entry(compiler, poly1305_processBlocks, poly1305_processBlocks,    \\\n+           poly1305_processBlocks)                                      \\\n+  do_stub(compiler, intpoly_montgomeryMult_P256)                        \\\n+  do_entry(compiler, intpoly_montgomeryMult_P256,                       \\\n+           intpoly_montgomeryMult_P256, intpoly_montgomeryMult_P256)    \\\n+  do_stub(compiler, intpoly_assign)                                     \\\n+  do_entry(compiler, intpoly_assign, intpoly_assign, intpoly_assign)    \\\n+  do_stub(compiler, md5_implCompress)                                   \\\n+  do_entry(compiler, md5_implCompress, md5_implCompress,                \\\n+           md5_implCompress)                                            \\\n+  do_stub(compiler, md5_implCompressMB)                                 \\\n+  do_entry(compiler, md5_implCompressMB, md5_implCompressMB,            \\\n+           md5_implCompressMB)                                          \\\n+  do_stub(compiler, sha1_implCompress)                                  \\\n+  do_entry(compiler, sha1_implCompress, sha1_implCompress,              \\\n+           sha1_implCompress)                                           \\\n+  do_stub(compiler, sha1_implCompressMB)                                \\\n+  do_entry(compiler, sha1_implCompressMB, sha1_implCompressMB,          \\\n+           sha1_implCompressMB)                                         \\\n+  do_stub(compiler, sha256_implCompress)                                \\\n+  do_entry(compiler, sha256_implCompress, sha256_implCompress,          \\\n+           sha256_implCompress)                                         \\\n+  do_stub(compiler, sha256_implCompressMB)                              \\\n+  do_entry(compiler, sha256_implCompressMB, sha256_implCompressMB,      \\\n+           sha256_implCompressMB)                                       \\\n+  do_stub(compiler, sha512_implCompress)                                \\\n+  do_entry(compiler, sha512_implCompress, sha512_implCompress,          \\\n+           sha512_implCompress)                                         \\\n+  do_stub(compiler, sha512_implCompressMB)                              \\\n+  do_entry(compiler, sha512_implCompressMB, sha512_implCompressMB,      \\\n+           sha512_implCompressMB)                                       \\\n+  do_stub(compiler, sha3_implCompress)                                  \\\n+  do_entry(compiler, sha3_implCompress, sha3_implCompress,              \\\n+           sha3_implCompress)                                           \\\n+  do_stub(compiler, sha3_implCompressMB)                                \\\n+  do_entry(compiler, sha3_implCompressMB, sha3_implCompressMB,          \\\n+           sha3_implCompressMB)                                         \\\n+  do_stub(compiler, updateBytesAdler32)                                 \\\n+  do_entry(compiler, updateBytesAdler32, updateBytesAdler32,            \\\n+           updateBytesAdler32)                                          \\\n+  do_stub(compiler, multiplyToLen)                                      \\\n+  do_entry(compiler, multiplyToLen, multiplyToLen, multiplyToLen)       \\\n+  do_stub(compiler, squareToLen)                                        \\\n+  do_entry(compiler, squareToLen, squareToLen, squareToLen)             \\\n+  do_stub(compiler, mulAdd)                                             \\\n+  do_entry(compiler, mulAdd, mulAdd, mulAdd)                            \\\n+  do_stub(compiler, montgomeryMultiply)                                 \\\n+  do_entry(compiler, montgomeryMultiply, montgomeryMultiply,            \\\n+           montgomeryMultiply)                                          \\\n+  do_stub(compiler, montgomerySquare)                                   \\\n+  do_entry(compiler, montgomerySquare, montgomerySquare,                \\\n+           montgomerySquare)                                            \\\n+  do_stub(compiler, bigIntegerRightShiftWorker)                         \\\n+  do_entry(compiler, bigIntegerRightShiftWorker,                        \\\n+           bigIntegerRightShiftWorker, bigIntegerRightShift)            \\\n+  do_stub(compiler, bigIntegerLeftShiftWorker)                          \\\n+  do_entry(compiler, bigIntegerLeftShiftWorker,                         \\\n+           bigIntegerLeftShiftWorker, bigIntegerLeftShift)              \\\n+  \/* merge in stubs and entries declared in arch header *\/              \\\n+  STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,  do_arch_blob,                \\\n+                                     do_arch_entry, do_arch_entry_init) \\\n+  end_blob(compiler)                                                    \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_DO(do_blob, end_blob,                       \\\n+                               do_stub,                                 \\\n+                               do_entry, do_entry_init,                 \\\n+                               do_entry_array,                          \\\n+                               do_arch_blob,                            \\\n+                               do_arch_entry, do_arch_entry_init)       \\\n+  do_blob(final)                                                        \\\n+  do_stub(final, verify_oop)                                            \\\n+  do_entry(final, verify_oop, verify_oop_subroutine_entry,              \\\n+           verify_oop_subroutine_entry)                                 \\\n+  do_stub(final, jbyte_arraycopy)                                       \\\n+  do_entry_init(final, jbyte_arraycopy, jbyte_arraycopy,                \\\n+                jbyte_arraycopy, StubRoutines::jbyte_copy)              \\\n+  do_stub(final, jshort_arraycopy)                                      \\\n+  do_entry_init(final, jshort_arraycopy, jshort_arraycopy,              \\\n+                jshort_arraycopy, StubRoutines::jshort_copy)            \\\n+  do_stub(final, jint_arraycopy)                                        \\\n+  do_entry_init(final, jint_arraycopy, jint_arraycopy,                  \\\n+                jint_arraycopy, StubRoutines::jint_copy)                \\\n+  do_stub(final, jlong_arraycopy)                                       \\\n+  do_entry_init(final, jlong_arraycopy, jlong_arraycopy,                \\\n+                jlong_arraycopy, StubRoutines::jlong_copy)              \\\n+  do_stub(final, oop_arraycopy)                                         \\\n+  do_entry_init(final, oop_arraycopy, oop_arraycopy,                    \\\n+                oop_arraycopy_entry, StubRoutines::oop_copy)            \\\n+  do_stub(final, oop_arraycopy_uninit)                                  \\\n+  do_entry_init(final, oop_arraycopy_uninit, oop_arraycopy_uninit,      \\\n+                oop_arraycopy_uninit_entry,                             \\\n+                StubRoutines::oop_copy_uninit)                          \\\n+  do_stub(final, jbyte_disjoint_arraycopy)                              \\\n+  do_entry_init(final, jbyte_disjoint_arraycopy,                        \\\n+                jbyte_disjoint_arraycopy, jbyte_disjoint_arraycopy,     \\\n+                StubRoutines::jbyte_copy)                               \\\n+  do_stub(final, jshort_disjoint_arraycopy)                             \\\n+  do_entry_init(final, jshort_disjoint_arraycopy,                       \\\n+                jshort_disjoint_arraycopy, jshort_disjoint_arraycopy,   \\\n+                StubRoutines::jshort_copy)                              \\\n+  do_stub(final, jint_disjoint_arraycopy)                               \\\n+  do_entry_init(final, jint_disjoint_arraycopy,                         \\\n+                jint_disjoint_arraycopy, jint_disjoint_arraycopy,       \\\n+                StubRoutines::jint_copy)                                \\\n+  do_stub(final, jlong_disjoint_arraycopy)                              \\\n+  do_entry_init(final, jlong_disjoint_arraycopy,                        \\\n+                jlong_disjoint_arraycopy, jlong_disjoint_arraycopy,     \\\n+                StubRoutines::jlong_copy)                               \\\n+  do_stub(final, oop_disjoint_arraycopy)                                \\\n+  do_entry_init(final, oop_disjoint_arraycopy, oop_disjoint_arraycopy,  \\\n+                oop_disjoint_arraycopy_entry, StubRoutines::oop_copy)   \\\n+  do_stub(final, oop_disjoint_arraycopy_uninit)                         \\\n+  do_entry_init(final, oop_disjoint_arraycopy_uninit,                   \\\n+                oop_disjoint_arraycopy_uninit,                          \\\n+                oop_disjoint_arraycopy_uninit_entry,                    \\\n+                StubRoutines::oop_copy_uninit)                          \\\n+  do_stub(final, arrayof_jbyte_arraycopy)                               \\\n+  do_entry_init(final, arrayof_jbyte_arraycopy,                         \\\n+                arrayof_jbyte_arraycopy, arrayof_jbyte_arraycopy,       \\\n+                StubRoutines::arrayof_jbyte_copy)                       \\\n+  do_stub(final, arrayof_jshort_arraycopy)                              \\\n+  do_entry_init(final, arrayof_jshort_arraycopy,                        \\\n+                arrayof_jshort_arraycopy, arrayof_jshort_arraycopy,     \\\n+                StubRoutines::arrayof_jshort_copy)                      \\\n+  do_stub(final, arrayof_jint_arraycopy)                                \\\n+  do_entry_init(final, arrayof_jint_arraycopy, arrayof_jint_arraycopy,  \\\n+                arrayof_jint_arraycopy,                                 \\\n+                StubRoutines::arrayof_jint_copy)                        \\\n+  do_stub(final, arrayof_jlong_arraycopy)                               \\\n+  do_entry_init(final, arrayof_jlong_arraycopy,                         \\\n+                arrayof_jlong_arraycopy, arrayof_jlong_arraycopy,       \\\n+                StubRoutines::arrayof_jlong_copy)                       \\\n+  do_stub(final, arrayof_oop_arraycopy)                                 \\\n+  do_entry_init(final, arrayof_oop_arraycopy, arrayof_oop_arraycopy,    \\\n+                arrayof_oop_arraycopy, StubRoutines::arrayof_oop_copy)  \\\n+  do_stub(final, arrayof_oop_arraycopy_uninit)                          \\\n+  do_entry_init(final, arrayof_oop_arraycopy_uninit,                    \\\n+                arrayof_oop_arraycopy_uninit,                           \\\n+                arrayof_oop_arraycopy_uninit,                           \\\n+                StubRoutines::arrayof_oop_copy_uninit)                  \\\n+  do_stub(final, arrayof_jbyte_disjoint_arraycopy)                      \\\n+  do_entry_init(final, arrayof_jbyte_disjoint_arraycopy,                \\\n+                arrayof_jbyte_disjoint_arraycopy,                       \\\n+                arrayof_jbyte_disjoint_arraycopy,                       \\\n+                StubRoutines::arrayof_jbyte_copy)                       \\\n+  do_stub(final, arrayof_jshort_disjoint_arraycopy)                     \\\n+  do_entry_init(final, arrayof_jshort_disjoint_arraycopy,               \\\n+                arrayof_jshort_disjoint_arraycopy,                      \\\n+                arrayof_jshort_disjoint_arraycopy,                      \\\n+                StubRoutines::arrayof_jshort_copy)                      \\\n+  do_stub(final, arrayof_jint_disjoint_arraycopy)                       \\\n+  do_entry_init(final, arrayof_jint_disjoint_arraycopy,                 \\\n+                arrayof_jint_disjoint_arraycopy,                        \\\n+                arrayof_jint_disjoint_arraycopy,                        \\\n+                StubRoutines::arrayof_jint_copy)                        \\\n+  do_stub(final, arrayof_jlong_disjoint_arraycopy)                      \\\n+  do_entry_init(final, arrayof_jlong_disjoint_arraycopy,                \\\n+                arrayof_jlong_disjoint_arraycopy,                       \\\n+                arrayof_jlong_disjoint_arraycopy,                       \\\n+                StubRoutines::arrayof_jlong_copy)                       \\\n+  do_stub(final, arrayof_oop_disjoint_arraycopy)                        \\\n+  do_entry_init(final, arrayof_oop_disjoint_arraycopy,                  \\\n+                arrayof_oop_disjoint_arraycopy,                         \\\n+                arrayof_oop_disjoint_arraycopy_entry,                   \\\n+                StubRoutines::arrayof_oop_copy)                         \\\n+  do_stub(final, arrayof_oop_disjoint_arraycopy_uninit)                 \\\n+  do_entry_init(final, arrayof_oop_disjoint_arraycopy_uninit,           \\\n+                arrayof_oop_disjoint_arraycopy_uninit,                  \\\n+                arrayof_oop_disjoint_arraycopy_uninit_entry,            \\\n+                StubRoutines::arrayof_oop_copy_uninit)                  \\\n+  do_stub(final, checkcast_arraycopy)                                   \\\n+  do_entry(final, checkcast_arraycopy, checkcast_arraycopy,             \\\n+           checkcast_arraycopy_entry)                                   \\\n+  do_stub(final, checkcast_arraycopy_uninit)                            \\\n+  do_entry(final, checkcast_arraycopy_uninit,                           \\\n+           checkcast_arraycopy_uninit,                                  \\\n+           checkcast_arraycopy_uninit_entry)                            \\\n+  do_stub(final, unsafe_arraycopy)                                      \\\n+  do_entry(final, unsafe_arraycopy, unsafe_arraycopy, unsafe_arraycopy) \\\n+  do_stub(final, generic_arraycopy)                                     \\\n+  do_entry(final, generic_arraycopy, generic_arraycopy,                 \\\n+           generic_arraycopy)                                           \\\n+  do_stub(final, unsafe_setmemory)                                      \\\n+  do_entry(final, unsafe_setmemory, unsafe_setmemory, unsafe_setmemory) \\\n+  do_stub(final, jbyte_fill)                                            \\\n+  do_entry(final, jbyte_fill, jbyte_fill, jbyte_fill)                   \\\n+  do_stub(final, jshort_fill)                                           \\\n+  do_entry(final, jshort_fill, jshort_fill, jshort_fill)                \\\n+  do_stub(final, jint_fill)                                             \\\n+  do_entry(final, jint_fill, jint_fill, jint_fill)                      \\\n+  do_stub(final, arrayof_jbyte_fill)                                    \\\n+  do_entry(final, arrayof_jbyte_fill, arrayof_jbyte_fill,               \\\n+           arrayof_jbyte_fill)                                          \\\n+  do_stub(final, arrayof_jshort_fill)                                   \\\n+  do_entry(final, arrayof_jshort_fill, arrayof_jshort_fill,             \\\n+           arrayof_jshort_fill)                                         \\\n+  do_stub(final, arrayof_jint_fill)                                     \\\n+  do_entry(final, arrayof_jint_fill, arrayof_jint_fill,                 \\\n+           arrayof_jint_fill)                                           \\\n+  do_stub(final, method_entry_barrier)                                  \\\n+  do_entry(final, method_entry_barrier, method_entry_barrier,           \\\n+           method_entry_barrier)                                        \\\n+  do_stub(final, vectorizedMismatch) \/* only used by x86! *\/            \\\n+  do_entry(final, vectorizedMismatch, vectorizedMismatch,               \\\n+           vectorizedMismatch)                                          \\\n+  do_stub(final, upcall_stub_exception_handler)                         \\\n+  do_entry(final, upcall_stub_exception_handler,                        \\\n+           upcall_stub_exception_handler,                               \\\n+           upcall_stub_exception_handler)                               \\\n+  do_stub(final, upcall_stub_load_target)                               \\\n+  do_entry(final, upcall_stub_load_target, upcall_stub_load_target,     \\\n+           upcall_stub_load_target)                                     \\\n+  do_stub(final, lookup_secondary_supers_table)                         \\\n+  do_entry_array(final, lookup_secondary_supers_table,                  \\\n+                 lookup_secondary_supers_table_stubs,                   \\\n+                 lookup_secondary_supers_table_stub,                    \\\n+                 Klass::SECONDARY_SUPERS_TABLE_SIZE)                    \\\n+  do_stub(final, lookup_secondary_supers_table_slow_path)               \\\n+  do_entry(final, lookup_secondary_supers_table_slow_path,              \\\n+           lookup_secondary_supers_table_slow_path_stub,                \\\n+           lookup_secondary_supers_table_slow_path_stub)                \\\n+  \/* merge in stubs and entries declared in arch header *\/              \\\n+  STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,  do_arch_blob,                   \\\n+                              do_arch_entry, do_arch_entry_init)        \\\n+  end_blob(final)                                                       \\\n+\n+\n+\/\/ Convenience macros for use by template implementations\n@@ -172,1 +925,1 @@\n-\/\/ generate a stub field name\n+\/\/ emit a runtime or stubgen stub field name\n@@ -176,1 +929,1 @@\n-\/\/ generate a blob field name\n+\/\/ emit a runtime blob field name\n@@ -180,0 +933,133 @@\n+\/\/ emit a stubgen blob field name\n+\n+#define STUBGEN_BLOB_FIELD_NAME(base) _ ## base ## _stubs_code\n+\n+\/\/ Convenience templates that emit nothing\n+\n+\/\/ ignore do_blob(blob_name, type) declarations\n+#define DO_BLOB_EMPTY2(blob_name, type)\n+\n+\/\/ ignore do_blob(blob_name) and end_blob(blob_name) declarations\n+#define DO_BLOB_EMPTY1(blob_name)\n+\n+\/\/ ignore do_stub(name, fancy_jump, pass_tls, return_pc) declarations\n+#define DO_STUB_EMPTY4(name, fancy_jump, pass_tls, return_pc)\n+\n+\/\/ ignore do_jvmti_stub(name) declarations\n+#define DO_JVMTI_STUB_EMPTY1(stub_name)\n+\n+\/\/ ignore do_stub(blob_name, stub_name) declarations\n+#define DO_STUB_EMPTY2(blob_name, stub_name)\n+\n+\/\/ ignore do_entry(blob_name, stub_name, fieldname, getter_name) declarations\n+#define DO_ENTRY_EMPTY4(blob_name, stub_name, fieldname, getter_name)\n+\n+\/\/ ignore do_entry(blob_name, stub_name, fieldname, getter_name, init_function) and\n+\/\/ do_entry_array(blob_name, stub_name, fieldname, getter_name, count) declarations\n+#define DO_ENTRY_EMPTY5(blob_name, stub_name, fieldname, getter_name, init_function)\n+\n+\/\/ ignore do_arch_blob(blob_name, size) declarations\n+#define DO_ARCH_BLOB_EMPTY2(arch, size)\n+\n+\/\/ ignore do_arch_entry(arch, blob_name, stub_name, fieldname, getter_name) declarations\n+#define DO_ARCH_ENTRY_EMPTY5(arch, blob_name, stub_name, field_name, getter_name)\n+\n+\/\/ ignore do_arch_entry(arch, blob_name, stub_name, fieldname, getter_name, init_function) declarations\n+#define DO_ARCH_ENTRY_EMPTY6(arch, blob_name, stub_name, field_name, getter_name, init_function)\n+\n+\/\/ The whole shebang!\n+\/\/\n+\/\/ client macro for emitting StubGenerator blobs, stubs and entries\n+\n+#define STUBGEN_ALL_DO(do_blob, end_blob,                               \\\n+                       do_stub,                                         \\\n+                       do_entry, do_entry_init,                         \\\n+                       do_entry_array,                                  \\\n+                       do_arch_blob,                                    \\\n+                       do_arch_entry, do_arch_entry_init)               \\\n+  STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                           \\\n+                           do_stub,                                     \\\n+                           do_entry, do_entry_init,                     \\\n+                           do_entry_array,                              \\\n+                           do_arch_blob,                                \\\n+                           do_arch_entry, do_arch_entry_init)           \\\n+  STUBGEN_CONTINUATION_BLOBS_DO(do_blob, end_blob,                      \\\n+                                do_stub,                                \\\n+                                do_entry, do_entry_init,                \\\n+                                do_entry_array,                         \\\n+                                do_arch_blob,                           \\\n+                                do_arch_entry, do_arch_entry_init)      \\\n+  STUBGEN_COMPILER_BLOBS_DO(do_blob, end_blob,                          \\\n+                            do_stub,                                    \\\n+                            do_entry, do_entry_init,                    \\\n+                            do_entry_array,                             \\\n+                            do_arch_blob,                               \\\n+                            do_arch_entry, do_arch_entry_init)          \\\n+  STUBGEN_FINAL_BLOBS_DO(do_blob, end_blob,                             \\\n+                         do_stub,                                       \\\n+                         do_entry, do_entry_init,                       \\\n+                         do_entry_array,                                \\\n+                         do_arch_blob,                                  \\\n+                         do_arch_entry, do_arch_entry_init)             \\\n+\n+\/\/ client macro to operate only on StubGenerator blobs\n+\n+#define STUBGEN_BLOBS_DO(do_blob)                                       \\\n+  STUBGEN_ALL_DO(do_blob, DO_BLOB_EMPTY1,                               \\\n+                 DO_STUB_EMPTY2,                                        \\\n+                 DO_ENTRY_EMPTY4, DO_ENTRY_EMPTY5,                      \\\n+                 DO_ENTRY_EMPTY5,                                       \\\n+                 DO_ARCH_BLOB_EMPTY2,                                   \\\n+                 DO_ARCH_ENTRY_EMPTY5, DO_ARCH_ENTRY_EMPTY6)            \\\n+\n+\/\/ client macro to operate only on StubGenerator stubs\n+\n+#define STUBGEN_STUBS_DO(do_stub)                                       \\\n+  STUBGEN_ALL_DO(DO_BLOB_EMPTY1, DO_BLOB_EMPTY1,                        \\\n+                 do_stub,                                               \\\n+                 DO_ENTRY_EMPTY4, DO_ENTRY_EMPTY5,                      \\\n+                 DO_ENTRY_EMPTY5,                                       \\\n+                 DO_ARCH_BLOB_EMPTY2,                                   \\\n+                 DO_ARCH_ENTRY_EMPTY5, DO_ARCH_ENTRY_EMPTY6)            \\\n+\n+\/\/ client macro to operate only on StubGenerator blobs and stubs\n+\n+#define STUBGEN_BLOBS_STUBS_DO(do_blob, end_blob, do_stub)              \\\n+  STUBGEN_ALL_DO(do_blob, end_blob,                                     \\\n+                 do_stub,                                               \\\n+                 DO_ENTRY_EMPTY4, DO_ENTRY_EMPTY5,                      \\\n+                 DO_ENTRY_EMPTY5,                                       \\\n+                 DO_ARCH_BLOB_EMPTY2,                                   \\\n+                 DO_ARCH_ENTRY_EMPTY5,DO_ARCH_ENTRY_EMPTY6)             \\\n+\n+\/\/ client macro to operate only on StubGenerator entries\n+\n+#define STUBGEN_ENTRIES_DO(do_entry, do_entry_init, do_entry_array)     \\\n+  STUBGEN_ALL_DO(DO_BLOB_EMPTY1, DO_BLOB_EMPTY1,                        \\\n+                 DO_STUB_EMPTY2,                                        \\\n+                 do_entry, do_entry_init,                               \\\n+                 do_entry_array,                                        \\\n+                 DO_ARCH_BLOB_EMPTY2,                                   \\\n+                 DO_ARCH_ENTRY_EMPTY5, DO_ARCH_ENTRY_EMPTY6)            \\\n+\n+\n+\/\/ client macro to operate only on StubGenerator arch blobs\n+\n+#define STUBGEN_ARCH_BLOBS_DO(do_arch_blob)                             \\\n+  STUBGEN_ALL_DO(DO_BLOB_EMPTY1, DO_BLOB_EMPTY1,                        \\\n+                 DO_STUB_EMPTY2,                                        \\\n+                 DO_ENTRY_EMPTY4, DO_ENTRY_EMPTY5,                      \\\n+                 DO_ENTRY_EMPTY5,                                       \\\n+                 do_arch_blob,                                          \\\n+                 DO_ARCH_ENTRY_EMPTY5, DO_ARCH_ENTRY_EMPTY6)            \\\n+\n+\/\/ client macro to operate only on StubGenerator arch entries\n+\n+#define STUBGEN_ARCH_ENTRIES_DO(do_arch_entry, do_arch_entry_init)      \\\n+  STUBGEN_ALL_DO(DO_BLOB_EMPTY1, DO_BLOB_EMPTY1,                        \\\n+                 DO_STUB_EMPTY2,                                        \\\n+                 DO_ENTRY_EMPTY4, DO_ENTRY_EMPTY5,                      \\\n+                 DO_ENTRY_EMPTY5,                                       \\\n+                 DO_ARCH_BLOB_EMPTY2,                                   \\\n+                 do_arch_entry, do_arch_entry_init)                     \\\n+\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":889,"deletions":3,"binary":false,"changes":892,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-\/\/ Implementation of StubRoutines - for a description\n-\/\/ of how to extend it, see the header file.\n+\/\/ Implementation of StubRoutines - for a description of how to\n+\/\/ declare new blobs, stubs and entries , see stubDefinitions.hpp.\n@@ -52,1 +52,1 @@\n-\/\/ Class Variables\n+\/\/ define arrays to hold stub and blob names\n@@ -54,4 +54,1 @@\n-BufferBlob* StubRoutines::_initial_stubs_code                   = nullptr;\n-BufferBlob* StubRoutines::_final_stubs_code                     = nullptr;\n-BufferBlob* StubRoutines::_compiler_stubs_code                  = nullptr;\n-BufferBlob* StubRoutines::_continuation_stubs_code              = nullptr;\n+\/\/ use a template to generate the initializer for the blob names array\n@@ -59,2 +56,2 @@\n-address StubRoutines::_call_stub_return_address                 = nullptr;\n-address StubRoutines::_call_stub_entry                          = nullptr;\n+#define DEFINE_BLOB_NAME(blob_name)             \\\n+  # blob_name,\n@@ -62,84 +59,3 @@\n-address StubRoutines::_catch_exception_entry                    = nullptr;\n-address StubRoutines::_forward_exception_entry                  = nullptr;\n-jint    StubRoutines::_verify_oop_count                         = 0;\n-address StubRoutines::_verify_oop_subroutine_entry              = nullptr;\n-address StubRoutines::_atomic_xchg_entry                        = nullptr;\n-address StubRoutines::_atomic_cmpxchg_entry                     = nullptr;\n-address StubRoutines::_atomic_cmpxchg_long_entry                = nullptr;\n-address StubRoutines::_atomic_add_entry                         = nullptr;\n-address StubRoutines::_fence_entry                              = nullptr;\n-\n-\/\/ Compiled code entry points default values\n-\/\/ The default functions don't have separate disjoint versions.\n-address StubRoutines::_jbyte_arraycopy          = CAST_FROM_FN_PTR(address, StubRoutines::jbyte_copy);\n-address StubRoutines::_jshort_arraycopy         = CAST_FROM_FN_PTR(address, StubRoutines::jshort_copy);\n-address StubRoutines::_jint_arraycopy           = CAST_FROM_FN_PTR(address, StubRoutines::jint_copy);\n-address StubRoutines::_jlong_arraycopy          = CAST_FROM_FN_PTR(address, StubRoutines::jlong_copy);\n-address StubRoutines::_oop_arraycopy            = CAST_FROM_FN_PTR(address, StubRoutines::oop_copy);\n-address StubRoutines::_oop_arraycopy_uninit     = CAST_FROM_FN_PTR(address, StubRoutines::oop_copy_uninit);\n-address StubRoutines::_jbyte_disjoint_arraycopy          = CAST_FROM_FN_PTR(address, StubRoutines::jbyte_copy);\n-address StubRoutines::_jshort_disjoint_arraycopy         = CAST_FROM_FN_PTR(address, StubRoutines::jshort_copy);\n-address StubRoutines::_jint_disjoint_arraycopy           = CAST_FROM_FN_PTR(address, StubRoutines::jint_copy);\n-address StubRoutines::_jlong_disjoint_arraycopy          = CAST_FROM_FN_PTR(address, StubRoutines::jlong_copy);\n-address StubRoutines::_oop_disjoint_arraycopy            = CAST_FROM_FN_PTR(address, StubRoutines::oop_copy);\n-address StubRoutines::_oop_disjoint_arraycopy_uninit     = CAST_FROM_FN_PTR(address, StubRoutines::oop_copy_uninit);\n-\n-address StubRoutines::_arrayof_jbyte_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jbyte_copy);\n-address StubRoutines::_arrayof_jshort_arraycopy = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jshort_copy);\n-address StubRoutines::_arrayof_jint_arraycopy   = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jint_copy);\n-address StubRoutines::_arrayof_jlong_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jlong_copy);\n-address StubRoutines::_arrayof_oop_arraycopy    = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy);\n-address StubRoutines::_arrayof_oop_arraycopy_uninit      = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy_uninit);\n-address StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jbyte_copy);\n-address StubRoutines::_arrayof_jshort_disjoint_arraycopy = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jshort_copy);\n-address StubRoutines::_arrayof_jint_disjoint_arraycopy   = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jint_copy);\n-address StubRoutines::_arrayof_jlong_disjoint_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jlong_copy);\n-address StubRoutines::_arrayof_oop_disjoint_arraycopy    = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy);\n-address StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy_uninit);\n-\n-address StubRoutines::_data_cache_writeback              = nullptr;\n-address StubRoutines::_data_cache_writeback_sync         = nullptr;\n-\n-address StubRoutines::_checkcast_arraycopy               = nullptr;\n-address StubRoutines::_checkcast_arraycopy_uninit        = nullptr;\n-address StubRoutines::_unsafe_arraycopy                  = nullptr;\n-address StubRoutines::_generic_arraycopy                 = nullptr;\n-\n-address StubRoutines::_unsafe_setmemory                  = nullptr;\n-\n-address StubRoutines::_jbyte_fill;\n-address StubRoutines::_jshort_fill;\n-address StubRoutines::_jint_fill;\n-address StubRoutines::_arrayof_jbyte_fill;\n-address StubRoutines::_arrayof_jshort_fill;\n-address StubRoutines::_arrayof_jint_fill;\n-\n-address StubRoutines::_aescrypt_encryptBlock               = nullptr;\n-address StubRoutines::_aescrypt_decryptBlock               = nullptr;\n-address StubRoutines::_cipherBlockChaining_encryptAESCrypt = nullptr;\n-address StubRoutines::_cipherBlockChaining_decryptAESCrypt = nullptr;\n-address StubRoutines::_electronicCodeBook_encryptAESCrypt  = nullptr;\n-address StubRoutines::_electronicCodeBook_decryptAESCrypt  = nullptr;\n-address StubRoutines::_counterMode_AESCrypt                = nullptr;\n-address StubRoutines::_galoisCounterMode_AESCrypt          = nullptr;\n-address StubRoutines::_ghash_processBlocks                 = nullptr;\n-address StubRoutines::_chacha20Block                       = nullptr;\n-address StubRoutines::_base64_encodeBlock                  = nullptr;\n-address StubRoutines::_base64_decodeBlock                  = nullptr;\n-address StubRoutines::_poly1305_processBlocks              = nullptr;\n-address StubRoutines::_intpoly_montgomeryMult_P256         = nullptr;\n-address StubRoutines::_intpoly_assign                      = nullptr;\n-\n-address StubRoutines::_md5_implCompress      = nullptr;\n-address StubRoutines::_md5_implCompressMB    = nullptr;\n-address StubRoutines::_sha1_implCompress     = nullptr;\n-address StubRoutines::_sha1_implCompressMB   = nullptr;\n-address StubRoutines::_sha256_implCompress   = nullptr;\n-address StubRoutines::_sha256_implCompressMB = nullptr;\n-address StubRoutines::_sha512_implCompress   = nullptr;\n-address StubRoutines::_sha512_implCompressMB = nullptr;\n-address StubRoutines::_sha3_implCompress     = nullptr;\n-address StubRoutines::_sha3_implCompressMB   = nullptr;\n-\n-address StubRoutines::_updateBytesCRC32 = nullptr;\n-address StubRoutines::_crc_table_adr =    nullptr;\n+const char* StubRoutines::_blob_names[StubGenBlobId::NUM_BLOBIDS] = {\n+  STUBGEN_BLOBS_DO(DEFINE_BLOB_NAME)\n+};\n@@ -147,1 +63,22 @@\n-address StubRoutines::_string_indexof_array[4]   =    { nullptr };\n+#undef DEFINE_BLOB_NAME\n+\n+#define DEFINE_STUB_NAME(blob_name, stub_name)          \\\n+  # stub_name ,                                         \\\n+\n+\/\/ use a template to generate the initializer for the stub names array\n+const char* StubRoutines::_stub_names[StubGenStubId::NUM_STUBIDS] = {\n+  STUBGEN_STUBS_DO(DEFINE_STUB_NAME)\n+};\n+\n+#undef DEFINE_STUB_NAME\n+\n+\/\/ Define fields used to store blobs\n+\n+#define DEFINE_BLOB_FIELD(blob_name) \\\n+  BufferBlob* StubRoutines:: STUBGEN_BLOB_FIELD_NAME(blob_name) = nullptr;\n+\n+STUBGEN_BLOBS_DO(DEFINE_BLOB_FIELD)\n+\n+#undef DEFINE_BLOB_FIELD\n+\n+\/\/ Define fields used to store stub entries\n@@ -149,29 +86,2 @@\n-address StubRoutines::_crc32c_table_addr = nullptr;\n-address StubRoutines::_updateBytesCRC32C = nullptr;\n-address StubRoutines::_updateBytesAdler32 = nullptr;\n-\n-address StubRoutines::_multiplyToLen = nullptr;\n-address StubRoutines::_squareToLen = nullptr;\n-address StubRoutines::_mulAdd = nullptr;\n-address StubRoutines::_montgomeryMultiply = nullptr;\n-address StubRoutines::_montgomerySquare = nullptr;\n-address StubRoutines::_bigIntegerRightShiftWorker = nullptr;\n-address StubRoutines::_bigIntegerLeftShiftWorker = nullptr;\n-\n-address StubRoutines::_vectorizedMismatch = nullptr;\n-\n-address StubRoutines::_dexp = nullptr;\n-address StubRoutines::_dlog = nullptr;\n-address StubRoutines::_dlog10 = nullptr;\n-address StubRoutines::_fmod = nullptr;\n-address StubRoutines::_dpow = nullptr;\n-address StubRoutines::_dsin = nullptr;\n-address StubRoutines::_dcos = nullptr;\n-address StubRoutines::_dlibm_sin_cos_huge = nullptr;\n-address StubRoutines::_dlibm_reduce_pi04l = nullptr;\n-address StubRoutines::_dlibm_tan_cot_huge = nullptr;\n-address StubRoutines::_dtan = nullptr;\n-address StubRoutines::_dtanh = nullptr;\n-\n-address StubRoutines::_f2hf = nullptr;\n-address StubRoutines::_hf2f = nullptr;\n+#define DEFINE_ENTRY_FIELD(blob_name, stub_name, field_name, getter_name) \\\n+  address StubRoutines:: STUB_FIELD_NAME(field_name) = nullptr;\n@@ -179,0 +89,15 @@\n+#define DEFINE_ENTRY_FIELD_INIT(blob_name, stub_name, field_name, getter_name, init_function) \\\n+  address StubRoutines:: STUB_FIELD_NAME(field_name) = CAST_FROM_FN_PTR(address, init_function);\n+\n+#define DEFINE_ENTRY_FIELD_ARRAY(blob_name, stub_name, field_name, getter_name, count) \\\n+  address StubRoutines:: STUB_FIELD_NAME(field_name)[count] = { nullptr };\n+\n+STUBGEN_ENTRIES_DO(DEFINE_ENTRY_FIELD, DEFINE_ENTRY_FIELD_INIT, DEFINE_ENTRY_FIELD_ARRAY)\n+\n+#undef DEFINE_ENTRY_FIELD_ARRAY\n+#undef DEFINE_ENTRY_FIELD_INIT\n+#undef DEFINE_ENTRY_FIELD\n+\n+jint    StubRoutines::_verify_oop_count                         = 0;\n+\n+address StubRoutines::_string_indexof_array[4]   =    { nullptr };\n@@ -182,3 +107,55 @@\n-address StubRoutines::_method_entry_barrier = nullptr;\n-address StubRoutines::_array_sort = nullptr;\n-address StubRoutines::_array_partition  = nullptr;\n+const char* StubRoutines::get_blob_name(StubGenBlobId id) {\n+  assert(0 <= id && id < StubGenBlobId::NUM_BLOBIDS, \"invalid blob id\");\n+  return _blob_names[id];\n+}\n+\n+const char* StubRoutines::get_stub_name(StubGenStubId id) {\n+  assert(0 <= id && id < StubGenStubId::NUM_STUBIDS, \"invalid stub id\");\n+  return _stub_names[id];\n+}\n+\n+#ifdef ASSERT\n+\n+\/\/ array holding start and end indices for stub ids associated with a\n+\/\/ given blob. Given a blob with id (StubGenBlobId) blob_id for any\n+\/\/ stub with id (StubGenStubId) stub_id declared within the blob:\n+\/\/ _blob_offsets[blob_id] <= stub_id < _blob_offsets[blob_id+1]\n+\n+static int _blob_limits[StubGenBlobId::NUM_BLOBIDS + 1];\n+\n+\/\/ macro used to compute blob limits\n+#define BLOB_COUNT(blob_name)                                           \\\n+  counter += StubGenStubId_ ## blob_name :: NUM_STUBIDS_ ## blob_name;  \\\n+  _blob_limits[++index] = counter;                                      \\\n+\n+\/\/ macro that checks stubs are associated with the correct blobs\n+#define STUB_VERIFY(blob_name, stub_name)                               \\\n+  localStubId = (int) (StubGenStubId_ ## blob_name :: blob_name ## _ ## stub_name ## _id); \\\n+  globalStubId = (int) (StubGenStubId:: stub_name ## _id);              \\\n+  blobId = (int) (StubGenBlobId:: blob_name ## _id);                    \\\n+  assert((globalStubId >= _blob_limits[blobId] &&                       \\\n+          globalStubId < _blob_limits[blobId+1]),                       \\\n+         \"stub \" # stub_name \" uses incorrect blob name \" # blob_name); \\\n+  assert(globalStubId == _blob_limits[blobId] + localStubId,            \\\n+         \"stub \" # stub_name \" id found at wrong offset!\");             \\\n+\n+bool verifyStubIds() {\n+  \/\/ first compute the blob limits\n+  int counter = 0;\n+  int index = 0;\n+  \/\/ populate offsets table with cumulative total of local enum counts\n+  STUBGEN_BLOBS_DO(BLOB_COUNT);\n+\n+  \/\/ ensure 1) global stub ids lie in the range of the associated blob\n+  \/\/ and 2) each blob's base + local stub id == global stub id\n+  int globalStubId, blobId, localStubId;\n+  STUBGEN_STUBS_DO(STUB_VERIFY);\n+  return true;\n+}\n+\n+#undef BLOB_COUNT\n+#undef STUB_VERIFY\n+\n+\/\/ ensure we verify the blob ids when this compile unit is first entered\n+bool _verified_stub_ids = verifyStubIds();\n+\n@@ -186,4 +163,1 @@\n-address StubRoutines::_cont_thaw          = nullptr;\n-address StubRoutines::_cont_returnBarrier = nullptr;\n-address StubRoutines::_cont_returnBarrierExc = nullptr;\n-address StubRoutines::_cont_preempt_stub = nullptr;\n+\/\/ macro used by stub to blob translation\n@@ -191,2 +165,3 @@\n-address StubRoutines::_upcall_stub_exception_handler = nullptr;\n-address StubRoutines::_upcall_stub_load_target = nullptr;\n+#define BLOB_CHECK_OFFSET(blob_name)                                \\\n+  if (id < _blob_limits[((int)blobId) + 1]) { return blobId; }      \\\n+  blobId = StubGenBlobId:: blob_name ## _id;                        \\\n@@ -194,2 +169,2 @@\n-address StubRoutines::_lookup_secondary_supers_table_slow_path_stub = nullptr;\n-address StubRoutines::_lookup_secondary_supers_table_stubs[Klass::SECONDARY_SUPERS_TABLE_SIZE] = { nullptr };\n+\/\/ translate a global stub id to an associated blob id based on the\n+\/\/ computed blob limits\n@@ -197,0 +172,12 @@\n+StubGenBlobId StubRoutines::stub_to_blob(StubGenStubId stubId) {\n+  int id = (int)stubId;\n+  assert(id > ((int)StubGenStubId::NO_STUBID) && id < ((int)StubGenStubId::NUM_STUBIDS), \"stub id out of range!\");\n+  \/\/ start with no blob to catch stub id == -1\n+  StubGenBlobId blobId = StubGenBlobId::NO_BLOBID;\n+  STUBGEN_BLOBS_DO(BLOB_CHECK_OFFSET);\n+  \/\/ if we reach here we should have the last blob id\n+  assert(blobId == StubGenBlobId::NUM_BLOBIDS - 1, \"unexpected blob id\");\n+  return blobId;\n+}\n+\n+#endif \/\/ ASSERT\n@@ -204,1 +191,1 @@\n-extern void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind); \/\/ only interface to generators\n+extern void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id); \/\/ only interface to generators\n@@ -232,1 +219,1 @@\n-static BufferBlob* initialize_stubs(StubCodeGenerator::StubsKind kind,\n+static BufferBlob* initialize_stubs(StubGenBlobId blob_id,\n@@ -246,1 +233,1 @@\n-  StubGenerator_generate(&buffer, kind);\n+  StubGenerator_generate(&buffer, blob_id);\n@@ -261,7 +248,13 @@\n-void StubRoutines::initialize_initial_stubs() {\n-  if (_initial_stubs_code == nullptr) {\n-    _initial_stubs_code = initialize_stubs(StubCodeGenerator::Initial_stubs,\n-                                           _initial_stubs_code_size, 10,\n-                                           \"StubRoutines generation initial stubs\",\n-                                           \"StubRoutines (initial stubs)\",\n-                                           \"_initial_stubs_code_size\");\n+#define DEFINE_BLOB_INIT_METHOD(blob_name)                              \\\n+  void StubRoutines::initialize_ ## blob_name ## _stubs() {             \\\n+    if (STUBGEN_BLOB_FIELD_NAME(blob_name) == nullptr) {                \\\n+      StubGenBlobId blob_id = StubGenBlobId:: STUB_ID_NAME(blob_name);  \\\n+      int size = _ ## blob_name ## _code_size;                          \\\n+      int max_aligned_size = 10;                                        \\\n+      const char* timer_msg = \"StubRoutines generation \" # blob_name \" stubs\"; \\\n+      const char* name = \"StubRoutines (\" # blob_name \"stubs)\";         \\\n+      const char* assert_msg = \"_\" # blob_name \"_code_size\";            \\\n+      STUBGEN_BLOB_FIELD_NAME(blob_name) =                              \\\n+        initialize_stubs(blob_id, size, max_aligned_size, timer_msg,    \\\n+                         name, assert_msg);                             \\\n+    }                                                                   \\\n@@ -269,1 +262,0 @@\n-}\n@@ -271,9 +263,0 @@\n-void StubRoutines::initialize_continuation_stubs() {\n-  if (_continuation_stubs_code == nullptr) {\n-    _continuation_stubs_code = initialize_stubs(StubCodeGenerator::Continuation_stubs,\n-                                           _continuation_stubs_code_size, 10,\n-                                           \"StubRoutines generation continuation stubs\",\n-                                           \"StubRoutines (continuation stubs)\",\n-                                           \"_continuation_stubs_code_size\");\n-  }\n-}\n@@ -281,9 +264,1 @@\n-void StubRoutines::initialize_compiler_stubs() {\n-  if (_compiler_stubs_code == nullptr) {\n-    _compiler_stubs_code = initialize_stubs(StubCodeGenerator::Compiler_stubs,\n-                                           _compiler_stubs_code_size, 100,\n-                                           \"StubRoutines generation compiler stubs\",\n-                                           \"StubRoutines (compiler stubs)\",\n-                                           \"_compiler_stubs_code_size\");\n-  }\n-}\n+STUBGEN_BLOBS_DO(DEFINE_BLOB_INIT_METHOD)\n@@ -291,8 +266,6 @@\n-void StubRoutines::initialize_final_stubs() {\n-  if (_final_stubs_code == nullptr) {\n-    _final_stubs_code = initialize_stubs(StubCodeGenerator::Final_stubs,\n-                                         _final_stubs_code_size, 10,\n-                                         \"StubRoutines generation final stubs\",\n-                                         \"StubRoutines (final stubs)\",\n-                                         \"_final_stubs_code_size\");\n-  }\n+#undef DEFINE_BLOB_INIT_METHOD\n+\n+\n+#define DEFINE_BLOB_INIT_FUNCTION(blob_name)            \\\n+void blob_name ## _stubs_init()  {                      \\\n+  StubRoutines::initialize_ ## blob_name ## _stubs();   \\\n@@ -301,3 +274,10 @@\n-void initial_stubs_init()      { StubRoutines::initialize_initial_stubs(); }\n-void continuation_stubs_init() { StubRoutines::initialize_continuation_stubs(); }\n-void final_stubs_init()        { StubRoutines::initialize_final_stubs(); }\n+STUBGEN_BLOBS_DO(DEFINE_BLOB_INIT_FUNCTION)\n+\n+#undef DEFINE_BLOB_INIT_FUNCTION\n+\n+\/*\n+ * we generate the underlying driver method but this wrapper is needed\n+ * to perform special handling depending on where the compiler init\n+ * gets called from. it ought to be possible to remove this at some\n+ * point and have adeterminate ordered init.\n+ *\/\n@@ -320,0 +300,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":155,"deletions":174,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/stubDeclarations.hpp\"\n@@ -153,0 +154,45 @@\n+\/\/ declare stubgen blob id enum\n+\n+#define BLOB_ENUM_DECLARE(blob_name) \\\n+  STUB_ID_NAME(blob_name),\n+\n+enum StubGenBlobId : int {\n+  NO_BLOBID = -1,\n+  STUBGEN_BLOBS_DO(BLOB_ENUM_DECLARE)\n+  NUM_BLOBIDS\n+};\n+\n+#undef BLOB_ENUM_DECLARE\n+\n+\/\/ declare blob local stub id enums\n+\n+#define BLOB_LOCAL_ENUM_START(blob_name)        \\\n+  enum StubGenStubId_ ## blob_name {            \\\n+    NO_STUBID_ ## blob_name = -1,\n+\n+#define BLOB_LOCAL_ENUM_END(blob_name)   \\\n+    NUM_STUBIDS_ ## blob_name            \\\n+  };\n+\n+#define BLOB_LOCAL_STUB_ENUM_DECLARE(blob_name, stub_name) \\\n+  blob_name ## _ ## stub_name ## _id,\n+\n+STUBGEN_BLOBS_STUBS_DO(BLOB_LOCAL_ENUM_START, BLOB_LOCAL_ENUM_END, BLOB_LOCAL_STUB_ENUM_DECLARE)\n+\n+#undef BLOB_LOCAL_ENUM_START\n+#undef BLOB_LOCAL_ENUM_END\n+#undef BLOB_LOCAL_STUB_ENUM_DECLARE\n+\n+\/\/ declare global stub id enum\n+\n+#define STUB_ENUM_DECLARE(blob_name, stub_name) \\\n+  STUB_ID_NAME(stub_name) ,\n+\n+enum StubGenStubId : int {\n+  NO_STUBID = -1,\n+  STUBGEN_STUBS_DO(STUB_ENUM_DECLARE)\n+  NUM_STUBIDS\n+};\n+\n+#undef STUB_ENUM_DECLARE\n+\n@@ -155,1 +201,1 @@\n- public:\n+public:\n@@ -158,0 +204,4 @@\n+  friend class VMStructs;\n+#if INCLUDE_JVMCI\n+  friend class JVMCIVMStructs;\n+#endif\n@@ -161,96 +211,1 @@\n-  static jint    _verify_oop_count;\n-  static address _verify_oop_subroutine_entry;\n-\n-  static address _call_stub_return_address;                \/\/ the return PC, when returning to a call stub\n-  static address _call_stub_entry;\n-  static address _forward_exception_entry;\n-  static address _catch_exception_entry;\n-\n-  static address _atomic_xchg_entry;\n-  static address _atomic_cmpxchg_entry;\n-  static address _atomic_cmpxchg_long_entry;\n-  static address _atomic_add_entry;\n-  static address _fence_entry;\n-\n-  static BufferBlob* _initial_stubs_code;                  \/\/ code buffer for initial routines\n-  static BufferBlob* _continuation_stubs_code;             \/\/ code buffer for continuation stubs\n-  static BufferBlob* _compiler_stubs_code;                 \/\/ code buffer for C2 intrinsics\n-  static BufferBlob* _final_stubs_code;                    \/\/ code buffer for all other routines\n-\n-  static address _array_sort;\n-  static address _array_partition;\n-  \/\/ Leaf routines which implement arraycopy and their addresses\n-  \/\/ arraycopy operands aligned on element type boundary\n-  static address _jbyte_arraycopy;\n-  static address _jshort_arraycopy;\n-  static address _jint_arraycopy;\n-  static address _jlong_arraycopy;\n-  static address _oop_arraycopy, _oop_arraycopy_uninit;\n-  static address _jbyte_disjoint_arraycopy;\n-  static address _jshort_disjoint_arraycopy;\n-  static address _jint_disjoint_arraycopy;\n-  static address _jlong_disjoint_arraycopy;\n-  static address _oop_disjoint_arraycopy, _oop_disjoint_arraycopy_uninit;\n-\n-  \/\/ arraycopy operands aligned on zero'th element boundary\n-  \/\/ These are identical to the ones aligned aligned on an\n-  \/\/ element type boundary, except that they assume that both\n-  \/\/ source and destination are HeapWord aligned.\n-  static address _arrayof_jbyte_arraycopy;\n-  static address _arrayof_jshort_arraycopy;\n-  static address _arrayof_jint_arraycopy;\n-  static address _arrayof_jlong_arraycopy;\n-  static address _arrayof_oop_arraycopy, _arrayof_oop_arraycopy_uninit;\n-  static address _arrayof_jbyte_disjoint_arraycopy;\n-  static address _arrayof_jshort_disjoint_arraycopy;\n-  static address _arrayof_jint_disjoint_arraycopy;\n-  static address _arrayof_jlong_disjoint_arraycopy;\n-  static address _arrayof_oop_disjoint_arraycopy, _arrayof_oop_disjoint_arraycopy_uninit;\n-\n-  \/\/ cache line writeback\n-  static address _data_cache_writeback;\n-  static address _data_cache_writeback_sync;\n-\n-  \/\/ these are recommended but optional:\n-  static address _checkcast_arraycopy, _checkcast_arraycopy_uninit;\n-  static address _unsafe_arraycopy;\n-  static address _generic_arraycopy;\n-\n-  static address _unsafe_setmemory;\n-\n-  static address _jbyte_fill;\n-  static address _jshort_fill;\n-  static address _jint_fill;\n-  static address _arrayof_jbyte_fill;\n-  static address _arrayof_jshort_fill;\n-  static address _arrayof_jint_fill;\n-\n-  static address _aescrypt_encryptBlock;\n-  static address _aescrypt_decryptBlock;\n-  static address _cipherBlockChaining_encryptAESCrypt;\n-  static address _cipherBlockChaining_decryptAESCrypt;\n-  static address _electronicCodeBook_encryptAESCrypt;\n-  static address _electronicCodeBook_decryptAESCrypt;\n-  static address _counterMode_AESCrypt;\n-  static address _galoisCounterMode_AESCrypt;\n-  static address _ghash_processBlocks;\n-  static address _chacha20Block;\n-  static address _base64_encodeBlock;\n-  static address _base64_decodeBlock;\n-  static address _poly1305_processBlocks;\n-  static address _intpoly_montgomeryMult_P256;\n-  static address _intpoly_assign;\n-\n-  static address _md5_implCompress;\n-  static address _md5_implCompressMB;\n-  static address _sha1_implCompress;\n-  static address _sha1_implCompressMB;\n-  static address _sha256_implCompress;\n-  static address _sha256_implCompressMB;\n-  static address _sha512_implCompress;\n-  static address _sha512_implCompressMB;\n-  static address _sha3_implCompress;\n-  static address _sha3_implCompressMB;\n-\n-  static address _updateBytesCRC32;\n-  static address _crc_table_adr;\n+\/\/ declare blob and stub name storage and associated lookup methods\n@@ -258,1 +213,4 @@\n-  static address _string_indexof_array[4];\n+private:\n+  static bool _inited_names;\n+  static const char* _blob_names[StubGenBlobId::NUM_BLOBIDS];\n+  static const char* _stub_names[StubGenStubId::NUM_STUBIDS];\n@@ -260,36 +218,4 @@\n-  static address _crc32c_table_addr;\n-  static address _updateBytesCRC32C;\n-  static address _updateBytesAdler32;\n-\n-  static address _multiplyToLen;\n-  static address _squareToLen;\n-  static address _mulAdd;\n-  static address _montgomeryMultiply;\n-  static address _montgomerySquare;\n-  static address _bigIntegerRightShiftWorker;\n-  static address _bigIntegerLeftShiftWorker;\n-\n-  static address _vectorizedMismatch;\n-\n-  static address _dexp;\n-  static address _dlog;\n-  static address _dlog10;\n-  static address _dpow;\n-  static address _dsin;\n-  static address _dcos;\n-  static address _dlibm_sin_cos_huge;\n-  static address _dlibm_reduce_pi04l;\n-  static address _dlibm_tan_cot_huge;\n-  static address _dtan;\n-  static address _dtanh;\n-  static address _fmod;\n-\n-  static address _f2hf;\n-  static address _hf2f;\n-\n-  static address _method_entry_barrier;\n-\n-  static address _cont_thaw;\n-  static address _cont_returnBarrier;\n-  static address _cont_returnBarrierExc;\n-  static address _cont_preempt_stub;\n+public:\n+  static bool init_names();\n+  static const char* get_blob_name(StubGenBlobId id);\n+  static const char* get_stub_name(StubGenStubId id);\n@@ -297,3 +223,1 @@\n-  \/\/ Vector Math Routines\n-  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n-  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n+\/\/ declare blob fields\n@@ -301,2 +225,2 @@\n-  static address _upcall_stub_exception_handler;\n-  static address _upcall_stub_load_target;\n+#define DECLARE_BLOB_FIELD(blob_name) \\\n+  static BufferBlob* STUBGEN_BLOB_FIELD_NAME(blob_name);\n@@ -304,2 +228,2 @@\n-  static address _lookup_secondary_supers_table_stubs[];\n-  static address _lookup_secondary_supers_table_slow_path_stub;\n+private:\n+  STUBGEN_BLOBS_DO(DECLARE_BLOB_FIELD);\n@@ -307,6 +231,1 @@\n- public:\n-  \/\/ Initialization\/Testing\n-  static void    initialize_initial_stubs();               \/\/ must happen before universe::genesis\n-  static void    initialize_continuation_stubs();          \/\/ must happen after  universe::genesis\n-  static void    initialize_compiler_stubs();              \/\/ must happen after  universe::genesis\n-  static void    initialize_final_stubs();                 \/\/ must happen after  universe::genesis\n+#undef DECLARE_BLOB_FIELD\n@@ -314,1 +233,1 @@\n-  static bool is_stub_code(address addr)                   { return contains(addr); }\n+\/\/ declare fields to store entry addresses\n@@ -316,7 +235,2 @@\n-  static bool contains(address addr) {\n-    return\n-      (_initial_stubs_code      != nullptr && _initial_stubs_code->blob_contains(addr))  ||\n-      (_continuation_stubs_code != nullptr && _continuation_stubs_code->blob_contains(addr)) ||\n-      (_compiler_stubs_code     != nullptr && _compiler_stubs_code->blob_contains(addr)) ||\n-      (_final_stubs_code        != nullptr && _final_stubs_code->blob_contains(addr)) ;\n-  }\n+#define DECLARE_ENTRY_FIELD(blob_name, stub_name, field_name, getter_name) \\\n+  static address STUB_FIELD_NAME(field_name);\n@@ -324,4 +238,2 @@\n-  static RuntimeBlob* initial_stubs_code()      { return _initial_stubs_code; }\n-  static RuntimeBlob* continuation_stubs_code() { return _continuation_stubs_code; }\n-  static RuntimeBlob* compiler_stubs_code()     { return _compiler_stubs_code; }\n-  static RuntimeBlob* final_stubs_code()        { return _final_stubs_code; }\n+#define DECLARE_ENTRY_FIELD_INIT(blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DECLARE_ENTRY_FIELD(blob_name, stub_name, field_name, getter_name)\n@@ -329,5 +241,39 @@\n-  \/\/ Debugging\n-  static jint    verify_oop_count()                        { return _verify_oop_count; }\n-  static jint*   verify_oop_count_addr()                   { return &_verify_oop_count; }\n-  \/\/ a subroutine for debugging the GC\n-  static address verify_oop_subroutine_entry_address()     { return (address)&_verify_oop_subroutine_entry; }\n+#define DECLARE_ENTRY_FIELD_ARRAY(blob_name, stub_name, field_name, getter_name, count) \\\n+  static address STUB_FIELD_NAME(field_name)[count];\n+\n+private:\n+  STUBGEN_ENTRIES_DO(DECLARE_ENTRY_FIELD, DECLARE_ENTRY_FIELD_INIT, DECLARE_ENTRY_FIELD_ARRAY);\n+\n+#undef DECLARE_ENTRY_FIELD_ARRAY\n+#undef DECLARE_ENTRY_FIELD_INIT\n+#undef DECLARE_ENTRY_FIELD\n+\n+\/\/ declare getters and setters for entry addresses\n+\n+#define DEFINE_ENTRY_GETTER(blob_name, stub_name, field_name, getter_name) \\\n+  static address getter_name() { return STUB_FIELD_NAME(field_name); } \\\n+\n+#define DEFINE_ENTRY_GETTER_INIT(blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DEFINE_ENTRY_GETTER(blob_name, stub_name, field_name, getter_name)\n+\n+#define DEFINE_ENTRY_GETTER_ARRAY(blob_name, stub_name, field_name, getter_name, count) \\\n+  static address getter_name(int idx) {                                 \\\n+    assert(idx < count, \"out of bounds\");                               \\\n+    return STUB_FIELD_NAME(field_name)[idx];                            \\\n+  }                                                                     \\\n+\n+public:\n+  STUBGEN_ENTRIES_DO(DEFINE_ENTRY_GETTER, DEFINE_ENTRY_GETTER_INIT, DEFINE_ENTRY_GETTER_ARRAY);\n+\n+#undef DEFINE_ENTRY_GETTER_ARRAY\n+#undef DEFINE_ENTRY_GETTER_INIT\n+#undef DEFINE_ENTRY_GETTER\n+\n+public:\n+\n+#define DECLARE_BLOB_INIT_METHOD(blob_name)     \\\n+  static void initialize_ ## blob_name ## _stubs();\n+\n+  STUBGEN_BLOBS_DO(DECLARE_BLOB_INIT_METHOD)\n+\n+#undef DECLARE_BLOB_INIT_METHOD\n@@ -335,1 +281,1 @@\n-  static address catch_exception_entry()                   { return _catch_exception_entry; }\n+public:\n@@ -349,1 +295,32 @@\n-  static CallStub call_stub()                              { return CAST_TO_FN_PTR(CallStub, _call_stub_entry); }\n+  static jint    _verify_oop_count;\n+\n+public:\n+  \/\/ this is used by x86_64 to expose string index stubs to the opto\n+  \/\/ library as a target to a call planted before back end lowering.\n+  \/\/ all other arches plant the call to the stub during back end\n+  \/\/ lowering and use arch-specific entries. we really need to\n+  \/\/ rationalise this at some point.\n+\n+  static address _string_indexof_array[4];\n+\n+  \/* special case: stub employs array of entries *\/\n+\n+  \/\/ Vector Math Routines\n+  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n+  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n+\n+  static bool is_stub_code(address addr)                   { return contains(addr); }\n+\n+  \/\/ generate code to implement method contains\n+\n+#define CHECK_ADDRESS_IN_BLOB(blob_name) \\\n+  blob = STUBGEN_BLOB_FIELD_NAME(blob_name); \\\n+  if (blob != nullptr && blob->blob_contains(addr)) { return true; }\n+\n+  static bool contains(address addr) {\n+    BufferBlob *blob;\n+    STUBGEN_BLOBS_DO(CHECK_ADDRESS_IN_BLOB)\n+    return false;\n+  }\n+#undef CHECK_ADDRESS_IN_BLOB\n+\/\/ define getters for stub code blobs\n@@ -351,2 +328,2 @@\n-  \/\/ Exceptions\n-  static address forward_exception_entry()                 { return _forward_exception_entry; }\n+#define DEFINE_BLOB_GETTER(blob_name) \\\n+  static RuntimeBlob* blob_name ## _stubs_code() { return _ ## blob_name ## _stubs_code; }\n@@ -354,5 +331,16 @@\n-  static address atomic_xchg_entry()                       { return _atomic_xchg_entry; }\n-  static address atomic_cmpxchg_entry()                    { return _atomic_cmpxchg_entry; }\n-  static address atomic_cmpxchg_long_entry()               { return _atomic_cmpxchg_long_entry; }\n-  static address atomic_add_entry()                        { return _atomic_add_entry; }\n-  static address fence_entry()                             { return _fence_entry; }\n+  STUBGEN_BLOBS_DO(DEFINE_BLOB_GETTER);\n+\n+#undef DEFINE_BLOB_GETTER\n+\n+#ifdef ASSERT\n+  \/\/ provide a translation from stub id to its associated blob id\n+  static StubGenBlobId stub_to_blob(StubGenStubId stubId);\n+#endif\n+\n+  \/\/ Debugging\n+  static jint    verify_oop_count()                        { return _verify_oop_count; }\n+  static jint*   verify_oop_count_addr()                   { return &_verify_oop_count; }\n+  \/\/ a subroutine for debugging the GC\n+  static address verify_oop_subroutine_entry_address()     { return (address)&_verify_oop_subroutine_entry; }\n+\n+  static CallStub call_stub()                              { return CAST_TO_FN_PTR(CallStub, _call_stub_entry); }\n@@ -362,4 +350,0 @@\n-  static address jbyte_arraycopy()  { return _jbyte_arraycopy; }\n-  static address jshort_arraycopy() { return _jshort_arraycopy; }\n-  static address jint_arraycopy()   { return _jint_arraycopy; }\n-  static address jlong_arraycopy()  { return _jlong_arraycopy; }\n@@ -369,4 +353,1 @@\n-  static address jbyte_disjoint_arraycopy()  { return _jbyte_disjoint_arraycopy; }\n-  static address jshort_disjoint_arraycopy() { return _jshort_disjoint_arraycopy; }\n-  static address jint_disjoint_arraycopy()   { return _jint_disjoint_arraycopy; }\n-  static address jlong_disjoint_arraycopy()  { return _jlong_disjoint_arraycopy; }\n+\n@@ -377,4 +358,0 @@\n-  static address arrayof_jbyte_arraycopy()  { return _arrayof_jbyte_arraycopy; }\n-  static address arrayof_jshort_arraycopy() { return _arrayof_jshort_arraycopy; }\n-  static address arrayof_jint_arraycopy()   { return _arrayof_jint_arraycopy; }\n-  static address arrayof_jlong_arraycopy()  { return _arrayof_jlong_arraycopy; }\n@@ -385,4 +362,0 @@\n-  static address arrayof_jbyte_disjoint_arraycopy()  { return _arrayof_jbyte_disjoint_arraycopy; }\n-  static address arrayof_jshort_disjoint_arraycopy() { return _arrayof_jshort_disjoint_arraycopy; }\n-  static address arrayof_jint_disjoint_arraycopy()   { return _arrayof_jint_disjoint_arraycopy; }\n-  static address arrayof_jlong_disjoint_arraycopy()  { return _arrayof_jlong_disjoint_arraycopy; }\n@@ -392,2 +365,0 @@\n-  static address data_cache_writeback()              { return _data_cache_writeback; }\n-  static address data_cache_writeback_sync()         { return _data_cache_writeback_sync; }\n@@ -403,1 +374,0 @@\n-  static address unsafe_arraycopy()     { return _unsafe_arraycopy; }\n@@ -408,2 +378,0 @@\n-  static address unsafe_setmemory()     { return _unsafe_setmemory; }\n-\n@@ -413,74 +381,0 @@\n-  static address generic_arraycopy()   { return _generic_arraycopy; }\n-  static address select_arraysort_function() { return _array_sort; }\n-  static address select_array_partition_function() { return _array_partition; }\n-\n-  static address jbyte_fill()          { return _jbyte_fill; }\n-  static address jshort_fill()         { return _jshort_fill; }\n-  static address jint_fill()           { return _jint_fill; }\n-  static address arrayof_jbyte_fill()  { return _arrayof_jbyte_fill; }\n-  static address arrayof_jshort_fill() { return _arrayof_jshort_fill; }\n-  static address arrayof_jint_fill()   { return _arrayof_jint_fill; }\n-\n-  static address aescrypt_encryptBlock()                { return _aescrypt_encryptBlock; }\n-  static address aescrypt_decryptBlock()                { return _aescrypt_decryptBlock; }\n-  static address cipherBlockChaining_encryptAESCrypt()  { return _cipherBlockChaining_encryptAESCrypt; }\n-  static address cipherBlockChaining_decryptAESCrypt()  { return _cipherBlockChaining_decryptAESCrypt; }\n-  static address electronicCodeBook_encryptAESCrypt()   { return _electronicCodeBook_encryptAESCrypt; }\n-  static address electronicCodeBook_decryptAESCrypt()   { return _electronicCodeBook_decryptAESCrypt; }\n-  static address poly1305_processBlocks()               { return _poly1305_processBlocks; }\n-  static address intpoly_montgomeryMult_P256()          { return _intpoly_montgomeryMult_P256; }\n-  static address intpoly_assign()        { return _intpoly_assign; }\n-  static address counterMode_AESCrypt()  { return _counterMode_AESCrypt; }\n-  static address ghash_processBlocks()   { return _ghash_processBlocks; }\n-  static address chacha20Block()         { return _chacha20Block; }\n-  static address base64_encodeBlock()    { return _base64_encodeBlock; }\n-  static address base64_decodeBlock()    { return _base64_decodeBlock; }\n-  static address md5_implCompress()      { return _md5_implCompress; }\n-  static address md5_implCompressMB()    { return _md5_implCompressMB; }\n-  static address sha1_implCompress()     { return _sha1_implCompress; }\n-  static address sha1_implCompressMB()   { return _sha1_implCompressMB; }\n-  static address sha256_implCompress()   { return _sha256_implCompress; }\n-  static address sha256_implCompressMB() { return _sha256_implCompressMB; }\n-  static address sha512_implCompress()   { return _sha512_implCompress; }\n-  static address sha512_implCompressMB() { return _sha512_implCompressMB; }\n-  static address sha3_implCompress()     { return _sha3_implCompress; }\n-  static address sha3_implCompressMB()   { return _sha3_implCompressMB; }\n-\n-  static address updateBytesCRC32()    { return _updateBytesCRC32; }\n-  static address crc_table_addr()      { return _crc_table_adr; }\n-\n-  static address crc32c_table_addr()   { return _crc32c_table_addr; }\n-  static address updateBytesCRC32C()   { return _updateBytesCRC32C; }\n-  static address updateBytesAdler32()  { return _updateBytesAdler32; }\n-\n-  static address multiplyToLen()       { return _multiplyToLen; }\n-  static address squareToLen()         { return _squareToLen; }\n-  static address mulAdd()              { return _mulAdd; }\n-  static address montgomeryMultiply()  { return _montgomeryMultiply; }\n-  static address montgomerySquare()    { return _montgomerySquare; }\n-  static address bigIntegerRightShift() { return _bigIntegerRightShiftWorker; }\n-  static address bigIntegerLeftShift()  { return _bigIntegerLeftShiftWorker; }\n-  static address galoisCounterMode_AESCrypt()   { return _galoisCounterMode_AESCrypt; }\n-\n-  static address vectorizedMismatch()  { return _vectorizedMismatch; }\n-\n-  static address dexp()                { return _dexp; }\n-  static address dlog()                { return _dlog; }\n-  static address dlog10()              { return _dlog10; }\n-  static address dpow()                { return _dpow; }\n-  static address fmod()                { return _fmod; }\n-  static address dsin()                { return _dsin; }\n-  static address dcos()                { return _dcos; }\n-  static address dlibm_reduce_pi04l()  { return _dlibm_reduce_pi04l; }\n-  static address dlibm_sin_cos_huge()  { return _dlibm_sin_cos_huge; }\n-  static address dlibm_tan_cot_huge()  { return _dlibm_tan_cot_huge; }\n-  static address dtan()                { return _dtan; }\n-  static address dtanh()               { return _dtanh; }\n-\n-  \/\/ These are versions of the java.lang.Float::floatToFloat16() and float16ToFloat()\n-  \/\/ methods which perform the same operations as the intrinsic version.\n-  \/\/ They are used for constant folding in JIT compiler to ensure equivalence.\n-  \/\/\n-  static address f2hf_adr()            { return _f2hf; }\n-  static address hf2f_adr()            { return _hf2f; }\n-\n@@ -500,28 +394,0 @@\n-  static address method_entry_barrier() { return _method_entry_barrier; }\n-\n-  static address cont_thaw()           { return _cont_thaw; }\n-  static address cont_returnBarrier()  { return _cont_returnBarrier; }\n-  static address cont_returnBarrierExc(){return _cont_returnBarrierExc; }\n-  static address cont_preempt_stub()   { return _cont_preempt_stub; }\n-\n-  static address upcall_stub_exception_handler() {\n-    assert(_upcall_stub_exception_handler != nullptr, \"not implemented\");\n-    return _upcall_stub_exception_handler;\n-  }\n-\n-  static address upcall_stub_load_target() {\n-    assert(_upcall_stub_load_target != nullptr, \"not implemented\");\n-    return _upcall_stub_load_target;\n-  }\n-\n-  static address lookup_secondary_supers_table_stub(u1 slot) {\n-    assert(slot < Klass::SECONDARY_SUPERS_TABLE_SIZE, \"out of bounds\");\n-    assert(_lookup_secondary_supers_table_stubs[slot] != nullptr, \"not implemented\");\n-    return _lookup_secondary_supers_table_stubs[slot];\n-  }\n-\n-  static address lookup_secondary_supers_table_slow_path_stub() {\n-    assert(_lookup_secondary_supers_table_slow_path_stub != nullptr, \"not implemented\");\n-    return _lookup_secondary_supers_table_slow_path_stub;\n-  }\n-\n@@ -530,3 +396,2 @@\n-  \/\/\n-  \/\/ Default versions of the above arraycopy functions for platforms which do\n-  \/\/ not have specialized versions\n+  \/\/ Default versions of some of the arraycopy functions for platforms\n+  \/\/ which do not have specialized versions\n@@ -547,0 +412,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":165,"deletions":299,"binary":false,"changes":464,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  if (StubRoutines::_##type##_fill != nullptr) {                                             \\\n+  if (StubRoutines::type##_fill() != nullptr) {                         \\\n@@ -128,1 +128,1 @@\n-            ((void (*)(type*, int, int))StubRoutines::_arrayof_##type##_fill)(start, v, 80); \\\n+            ((void (*)(type*, int, int))StubRoutines::arrayof_##type##_fill())(start, v, 80); \\\n@@ -133,1 +133,1 @@\n-          ((void (*)(type*, int, int))StubRoutines::_##type##_fill)(start, v, 80);           \\\n+          ((void (*)(type*, int, int))StubRoutines::type##_fill())(start, v, 80); \\\n","filename":"test\/hotspot\/gtest\/runtime\/test_stubRoutines.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}