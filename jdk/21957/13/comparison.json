{"files":[{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_AARCH64_STUBDECLARATIONS_HPP\n+#define CPU_AARCH64_STUBDECLARATIONS_HPP\n+\n+#define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n+  do_arch_blob(initial, 10000)                                          \\\n+\n+\n+#define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \\\n+                                           do_arch_blob,                \\\n+                                           do_arch_entry,               \\\n+                                           do_arch_entry_init)          \\\n+  do_arch_blob(continuation, 2000)                                      \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \\\n+                                       do_arch_blob,                    \\\n+                                       do_arch_entry,                   \\\n+                                       do_arch_entry_init)              \\\n+  do_arch_blob(compiler, 30000 ZGC_ONLY(+10000))                        \\\n+  do_stub(compiler, vector_iota_indices)                                \\\n+  do_arch_entry(aarch64, compiler, vector_iota_indices,                 \\\n+                vector_iota_indices, vector_iota_indices)               \\\n+  do_stub(compiler, large_array_equals)                                 \\\n+  do_arch_entry(aarch64, compiler, large_array_equals,                  \\\n+                large_array_equals, large_array_equals)                 \\\n+  do_stub(compiler, large_arrays_hashcode_boolean)                      \\\n+  do_arch_entry(aarch64, compiler, large_arrays_hashcode_boolean,       \\\n+                large_arrays_hashcode_boolean,                          \\\n+                large_arrays_hashcode_boolean)                          \\\n+  do_stub(compiler, large_arrays_hashcode_byte)                         \\\n+  do_arch_entry(aarch64, compiler, large_arrays_hashcode_byte,          \\\n+                large_arrays_hashcode_byte,                             \\\n+                large_arrays_hashcode_byte)                             \\\n+  do_stub(compiler, large_arrays_hashcode_char)                         \\\n+  do_arch_entry(aarch64, compiler, large_arrays_hashcode_char,          \\\n+                large_arrays_hashcode_char,                             \\\n+                large_arrays_hashcode_char)                             \\\n+  do_stub(compiler, large_arrays_hashcode_short)                        \\\n+  do_arch_entry(aarch64, compiler, large_arrays_hashcode_short,         \\\n+                large_arrays_hashcode_short,                            \\\n+                large_arrays_hashcode_short)                            \\\n+  do_stub(compiler, large_arrays_hashcode_int)                          \\\n+  do_arch_entry(aarch64, compiler, large_arrays_hashcode_int,           \\\n+                large_arrays_hashcode_int,                              \\\n+                large_arrays_hashcode_int)                              \\\n+  do_stub(compiler, large_byte_array_inflate)                           \\\n+  do_arch_entry(aarch64, compiler, large_byte_array_inflate,            \\\n+                large_byte_array_inflate, large_byte_array_inflate)     \\\n+  do_stub(compiler, count_positives)                                    \\\n+  do_arch_entry(aarch64, compiler, count_positives, count_positives,    \\\n+                count_positives)                                        \\\n+  do_stub(compiler, count_positives_long)                               \\\n+  do_arch_entry(aarch64, compiler, count_positives_long,                \\\n+                count_positives_long, count_positives_long)             \\\n+  do_stub(compiler, compare_long_string_LL)                             \\\n+  do_arch_entry(aarch64, compiler, compare_long_string_LL,              \\\n+                compare_long_string_LL, compare_long_string_LL)         \\\n+  do_stub(compiler, compare_long_string_UU)                             \\\n+  do_arch_entry(aarch64, compiler, compare_long_string_UU,              \\\n+                compare_long_string_UU, compare_long_string_UU)         \\\n+  do_stub(compiler, compare_long_string_LU)                             \\\n+  do_arch_entry(aarch64, compiler, compare_long_string_LU,              \\\n+                compare_long_string_LU, compare_long_string_LU)         \\\n+  do_stub(compiler, compare_long_string_UL)                             \\\n+  do_arch_entry(aarch64, compiler, compare_long_string_UL,              \\\n+                compare_long_string_UL, compare_long_string_UL)         \\\n+  do_stub(compiler, string_indexof_linear_ll)                           \\\n+  do_arch_entry(aarch64, compiler, string_indexof_linear_ll,            \\\n+                string_indexof_linear_ll, string_indexof_linear_ll)     \\\n+  do_stub(compiler, string_indexof_linear_uu)                           \\\n+  do_arch_entry(aarch64, compiler, string_indexof_linear_uu,            \\\n+                string_indexof_linear_uu, string_indexof_linear_uu)     \\\n+  do_stub(compiler, string_indexof_linear_ul)                           \\\n+  do_arch_entry(aarch64, compiler, string_indexof_linear_ul,            \\\n+                string_indexof_linear_ul, string_indexof_linear_ul)     \\\n+  \/* this uses the entry for ghash_processBlocks *\/                     \\\n+  do_stub(compiler, ghash_processBlocks_wide)                           \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \\\n+                                    do_arch_blob,                       \\\n+                                    do_arch_entry,                      \\\n+                                    do_arch_entry_init)                 \\\n+  do_arch_blob(final, 20000 ZGC_ONLY(+100000))                          \\\n+  do_stub(final, copy_byte_f)                                           \\\n+  do_arch_entry(aarch64, final, copy_byte_f, copy_byte_f,               \\\n+                copy_byte_f)                                            \\\n+  do_stub(final, copy_byte_b)                                           \\\n+  do_arch_entry(aarch64, final, copy_byte_b, copy_byte_b,               \\\n+                  copy_byte_b)                                          \\\n+  do_stub(final, copy_oop_f)                                            \\\n+  do_arch_entry(aarch64, final, copy_oop_f, copy_oop_f, copy_oop_f)     \\\n+  do_stub(final, copy_oop_b)                                            \\\n+  do_arch_entry(aarch64, final, copy_oop_b, copy_oop_b, copy_oop_b)     \\\n+  do_stub(final, copy_oop_uninit_f)                                     \\\n+  do_arch_entry(aarch64, final, copy_oop_uninit_f, copy_oop_uninit_f,   \\\n+                copy_oop_uninit_f)                                      \\\n+  do_stub(final, copy_oop_uninit_b)                                     \\\n+  do_arch_entry(aarch64, final, copy_oop_uninit_b, copy_oop_uninit_b,   \\\n+                copy_oop_uninit_b)                                      \\\n+  do_stub(final, zero_blocks)                                           \\\n+  do_arch_entry(aarch64, final, zero_blocks, zero_blocks,               \\\n+                zero_blocks)                                            \\\n+  do_stub(final, spin_wait)                                             \\\n+  do_arch_entry_init(aarch64, final, spin_wait, spin_wait,              \\\n+                     spin_wait, empty_spin_wait)                        \\\n+  \/* stub only -- entries are not stored in StubRoutines::aarch64 *\/    \\\n+  \/* n.b. these are not the same as the generic atomic stubs *\/         \\\n+  do_stub(final, atomic_entry_points)                                   \\\n+\n+\n+#endif \/\/ CPU_AARCH64_STUBDECLARATIONS_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/stubDeclarations_aarch64.hpp","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -3,0 +3,3 @@\n+<<<<<<< HEAD\n+ * Copyright (c) 2014, 2025, Red Hat Inc. All rights reserved.\n+=======\n@@ -4,0 +7,1 @@\n+>>>>>>> master\n@@ -205,1 +209,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"call_stub\");\n+    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -424,1 +429,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"catch_exception\");\n+    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -479,1 +485,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"forward exception\");\n+    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -568,2 +575,2 @@\n-\n-    StubCodeMark mark(this, \"StubRoutines\", \"verify_oop\");\n+    StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -617,1 +624,1 @@\n-  address generate_iota_indices(const char *stub_name) {\n+  address generate_iota_indices(StubGenStubId stub_id) {\n@@ -619,1 +626,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubCodeMark mark(this, stub_id);\n@@ -662,1 +669,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"zero_blocks\");\n+    StubGenStubId stub_id = StubGenStubId::zero_blocks_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -801,2 +809,33 @@\n-  void generate_copy_longs(DecoratorSet decorators, BasicType type, Label &start, Register s, Register d, Register count,\n-                           copy_direction direction) {\n+  void generate_copy_longs(StubGenStubId stub_id, DecoratorSet decorators, Label &start, Register s, Register d, Register count) {\n+    BasicType type;\n+    copy_direction direction;\n+\n+    switch (stub_id) {\n+    case copy_byte_f_id:\n+      direction = copy_forwards;\n+      type = T_BYTE;\n+      break;\n+    case copy_byte_b_id:\n+      direction = copy_backwards;\n+      type = T_BYTE;\n+      break;\n+    case copy_oop_f_id:\n+      direction = copy_forwards;\n+      type = T_OBJECT;\n+      break;\n+    case copy_oop_b_id:\n+      direction = copy_backwards;\n+      type = T_OBJECT;\n+      break;\n+    case copy_oop_uninit_f_id:\n+      direction = copy_forwards;\n+      type = T_OBJECT;\n+      break;\n+    case copy_oop_uninit_b_id:\n+      direction = copy_backwards;\n+      type = T_OBJECT;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -817,5 +856,0 @@\n-    const char *stub_name;\n-    if (direction == copy_forwards)\n-      stub_name = \"forward_copy_longs\";\n-    else\n-      stub_name = \"backward_copy_longs\";\n@@ -825,1 +859,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1480,4 +1514,5 @@\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   is_oop  - true => oop array, so generate store check code\n-  \/\/   name    - stub name string\n+  \/\/   stub_id - is used to name the stub and identify all details of\n+  \/\/             how to perform the copy.\n+  \/\/\n+  \/\/   entry - is assigned to the stub's post push entry point unless\n+  \/\/           it is null\n@@ -1494,3 +1529,3 @@\n-  \/\/ Side Effects:\n-  \/\/   disjoint_int_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_int_oop_copy().\n+  \/\/ Side Effects: entry is set to the (post push) entry point so it\n+  \/\/               can be used by the corresponding conjoint copy\n+  \/\/               method\n@@ -1498,2 +1533,1 @@\n-  address generate_disjoint_copy(int size, bool aligned, bool is_oop, address *entry,\n-                                  const char *name, bool dest_uninitialized = false) {\n+  address generate_disjoint_copy(StubGenStubId stub_id, address *entry) {\n@@ -1502,0 +1536,81 @@\n+    int size;\n+    bool aligned;\n+    bool is_oop;\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case jbyte_disjoint_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jbyte_disjoint_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jshort_disjoint_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jshort_disjoint_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jint_disjoint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jint_disjoint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jlong_disjoint_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case arrayof_jlong_disjoint_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case arrayof_jlong_disjoint_arraycopy_id:\n+      size = sizeof(jlong);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_disjoint_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_disjoint_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+    }\n+\n@@ -1503,1 +1618,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1550,4 +1665,10 @@\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   is_oop  - true => oop array, so generate store check code\n-  \/\/   name    - stub name string\n+  \/\/   stub_id - is used to name the stub and identify all details of\n+  \/\/             how to perform the copy.\n+  \/\/\n+  \/\/   nooverlap_target - identifes the (post push) entry for the\n+  \/\/             corresponding disjoint copy routine which can be\n+  \/\/             jumped to if the ranges do not actually overlap\n+  \/\/\n+  \/\/   entry - is assigned to the stub's post push entry point unless\n+  \/\/           it is null\n+  \/\/\n@@ -1564,3 +1685,5 @@\n-  address generate_conjoint_copy(int size, bool aligned, bool is_oop, address nooverlap_target,\n-                                 address *entry, const char *name,\n-                                 bool dest_uninitialized = false) {\n+  \/\/ Side Effects:\n+  \/\/   entry is set to the no-overlap entry point so it can be used by\n+  \/\/   some other conjoint copy method\n+  \/\/\n+  address generate_conjoint_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n@@ -1569,1 +1692,81 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    int size;\n+    bool aligned;\n+    bool is_oop;\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case jbyte_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jbyte_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jshort_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jshort_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jlong_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case arrayof_jlong_disjoint_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case arrayof_jlong_arraycopy_id:\n+      size = sizeof(jlong);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1615,181 +1818,0 @@\n-}\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n-  \/\/ we let the hardware handle it.  The one to eight bytes within words,\n-  \/\/ dwords or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_byte_copy_entry is set to the no-overlap entry point  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n-  \/\/ we let the hardware handle it.  The one to eight bytes within words,\n-  \/\/ dwords or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_byte_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_byte_copy().\n-  \/\/\n-  address generate_disjoint_byte_copy(bool aligned, address* entry, const char *name) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jbyte), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n-  \/\/ we let the hardware handle it.  The one to eight bytes within words,\n-  \/\/ dwords or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  address generate_conjoint_byte_copy(bool aligned, address nooverlap_target,\n-                                      address* entry, const char *name) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jbyte), aligned, not_oop, nooverlap_target, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4- or 2-byte boundaries, we\n-  \/\/ let the hardware handle it.  The two or four words within dwords\n-  \/\/ or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_short_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_short_copy().\n-  \/\/\n-  address generate_disjoint_short_copy(bool aligned,\n-                                       address* entry, const char *name) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jshort), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4- or 2-byte boundaries, we\n-  \/\/ let the hardware handle it.  The two or four words within dwords\n-  \/\/ or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  address generate_conjoint_short_copy(bool aligned, address nooverlap_target,\n-                                       address *entry, const char *name) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jshort), aligned, not_oop, nooverlap_target, entry, name);\n-\n-  }\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-byte boundaries, we let\n-  \/\/ the hardware handle it.  The two dwords within qwords that span\n-  \/\/ cache line boundaries will still be loaded and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_int_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_int_oop_copy().\n-  \/\/\n-  address generate_disjoint_int_copy(bool aligned, address *entry,\n-                                         const char *name, bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jint), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-byte boundaries, we let\n-  \/\/ the hardware handle it.  The two dwords within qwords that span\n-  \/\/ cache line boundaries will still be loaded and stored atomically.\n-  \/\/\n-  address generate_conjoint_int_copy(bool aligned, address nooverlap_target,\n-                                     address *entry, const char *name,\n-                                     bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jint), aligned, not_oop, nooverlap_target, entry, name);\n-  }\n-\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_oop_copy_entry or disjoint_long_copy_entry is set to the\n-  \/\/   no-overlap entry point used by generate_conjoint_long_oop_copy().\n-  \/\/\n-  address generate_disjoint_long_copy(bool aligned, address *entry,\n-                                          const char *name, bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jlong), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  address generate_conjoint_long_copy(bool aligned,\n-                                      address nooverlap_target, address *entry,\n-                                      const char *name, bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jlong), aligned, not_oop, nooverlap_target, entry, name);\n@@ -1798,41 +1820,0 @@\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_oop_copy_entry or disjoint_long_copy_entry is set to the\n-  \/\/   no-overlap entry point used by generate_conjoint_long_oop_copy().\n-  \/\/\n-  address generate_disjoint_oop_copy(bool aligned, address *entry,\n-                                     const char *name, bool dest_uninitialized) {\n-    const bool is_oop = true;\n-    const int size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n-    return generate_disjoint_copy(size, aligned, is_oop, entry, name, dest_uninitialized);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  address generate_conjoint_oop_copy(bool aligned,\n-                                     address nooverlap_target, address *entry,\n-                                     const char *name, bool dest_uninitialized) {\n-    const bool is_oop = true;\n-    const int size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n-    return generate_conjoint_copy(size, aligned, is_oop, nooverlap_target, entry,\n-                                  name, dest_uninitialized);\n-  }\n-\n-\n@@ -1876,2 +1857,12 @@\n-  address generate_checkcast_copy(const char *name, address *entry,\n-                                  bool dest_uninitialized = false) {\n+  address generate_checkcast_copy(StubGenStubId stub_id, address *entry) {\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case checkcast_arraycopy_id:\n+      dest_uninitialized = false;\n+      break;\n+    case checkcast_arraycopy_uninit_id:\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -1911,1 +1902,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2083,2 +2074,1 @@\n-  address generate_unsafe_copy(const char *name,\n-                               address byte_copy_entry,\n+  address generate_unsafe_copy(address byte_copy_entry,\n@@ -2088,0 +2078,2 @@\n+    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+\n@@ -2092,1 +2084,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2136,2 +2128,1 @@\n-  address generate_generic_copy(const char *name,\n-                                address byte_copy_entry, address short_copy_entry,\n+  address generate_generic_copy(address byte_copy_entry, address short_copy_entry,\n@@ -2140,0 +2131,1 @@\n+    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n@@ -2157,1 +2149,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2410,1 +2402,33 @@\n-  address generate_fill(BasicType t, bool aligned, const char *name) {\n+  address generate_fill(StubGenStubId stub_id) {\n+    BasicType t;\n+    bool aligned;\n+\n+    switch (stub_id) {\n+    case jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = false;\n+      break;\n+    case jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = false;\n+      break;\n+    case jint_fill_id:\n+      t = T_INT;\n+      aligned = false;\n+      break;\n+    case arrayof_jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = true;\n+      break;\n+    case arrayof_jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = true;\n+      break;\n+    case arrayof_jint_fill_id:\n+      t = T_INT;\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    };\n+\n@@ -2412,1 +2436,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2554,1 +2578,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"_data_cache_writeback\");\n+    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2570,1 +2595,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"_data_cache_writeback_sync\");\n+    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_sync_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2596,2 +2622,2 @@\n-    generate_copy_longs(IN_HEAP | IS_ARRAY, T_BYTE, copy_f, r0, r1, r15, copy_forwards);\n-    generate_copy_longs(IN_HEAP | IS_ARRAY, T_BYTE, copy_b, r0, r1, r15, copy_backwards);\n+    generate_copy_longs(StubGenStubId::copy_byte_f_id, IN_HEAP | IS_ARRAY, copy_f, r0, r1, r15);\n+    generate_copy_longs(StubGenStubId::copy_byte_b_id, IN_HEAP | IS_ARRAY, copy_b, r0, r1, r15);\n@@ -2599,2 +2625,2 @@\n-    generate_copy_longs(IN_HEAP | IS_ARRAY, T_OBJECT, copy_obj_f, r0, r1, r15, copy_forwards);\n-    generate_copy_longs(IN_HEAP | IS_ARRAY, T_OBJECT, copy_obj_b, r0, r1, r15, copy_backwards);\n+    generate_copy_longs(StubGenStubId::copy_oop_f_id, IN_HEAP | IS_ARRAY, copy_obj_f, r0, r1, r15);\n+    generate_copy_longs(StubGenStubId::copy_oop_b_id, IN_HEAP | IS_ARRAY, copy_obj_b, r0, r1, r15);\n@@ -2602,2 +2628,2 @@\n-    generate_copy_longs(IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, T_OBJECT, copy_obj_uninit_f, r0, r1, r15, copy_forwards);\n-    generate_copy_longs(IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, T_OBJECT, copy_obj_uninit_b, r0, r1, r15, copy_backwards);\n+    generate_copy_longs(StubGenStubId::copy_oop_uninit_f_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, copy_obj_uninit_f, r0, r1, r15);\n+    generate_copy_longs(StubGenStubId::copy_oop_uninit_b_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, copy_obj_uninit_b, r0, r1, r15);\n@@ -2609,9 +2635,4 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy         = generate_disjoint_byte_copy(false, &entry,\n-                                                                                  \"jbyte_disjoint_arraycopy\");\n-    StubRoutines::_jbyte_arraycopy                  = generate_conjoint_byte_copy(false, entry,\n-                                                                                  &entry_jbyte_arraycopy,\n-                                                                                  \"jbyte_arraycopy\");\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy = generate_disjoint_byte_copy(true, &entry,\n-                                                                                  \"arrayof_jbyte_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jbyte_arraycopy          = generate_conjoint_byte_copy(true, entry, nullptr,\n-                                                                                  \"arrayof_jbyte_arraycopy\");\n+    StubRoutines::_jbyte_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jbyte_arraycopy                  = generate_conjoint_copy(StubGenStubId::jbyte_arraycopy_id, entry, &entry_jbyte_arraycopy);\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jbyte_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jbyte_arraycopy_id, entry, nullptr);\n@@ -2621,9 +2642,4 @@\n-    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_short_copy(false, &entry,\n-                                                                                    \"jshort_disjoint_arraycopy\");\n-    StubRoutines::_jshort_arraycopy                  = generate_conjoint_short_copy(false, entry,\n-                                                                                    &entry_jshort_arraycopy,\n-                                                                                    \"jshort_arraycopy\");\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_short_copy(true, &entry,\n-                                                                                    \"arrayof_jshort_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_short_copy(true, entry, nullptr,\n-                                                                                    \"arrayof_jshort_arraycopy\");\n+    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubGenStubId::jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jshort_arraycopy_id, entry, nullptr);\n@@ -2633,4 +2649,2 @@\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy = generate_disjoint_int_copy(true, &entry,\n-                                                                                \"arrayof_jint_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jint_arraycopy          = generate_conjoint_int_copy(true, entry, &entry_jint_arraycopy,\n-                                                                                \"arrayof_jint_arraycopy\");\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jint_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2639,5 +2653,2 @@\n-    StubRoutines::_jint_disjoint_arraycopy         = generate_disjoint_int_copy(false, &entry,\n-                                                                                \"jint_disjoint_arraycopy\");\n-    StubRoutines::_jint_arraycopy                  = generate_conjoint_int_copy(false, entry,\n-                                                                                &entry_jint_arraycopy,\n-                                                                                \"jint_arraycopy\");\n+    StubRoutines::_jint_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubGenStubId::jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2647,4 +2658,2 @@\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_long_copy(true, &entry,\n-                                                                                  \"arrayof_jlong_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_long_copy(true, entry, &entry_jlong_arraycopy,\n-                                                                                  \"arrayof_jlong_arraycopy\");\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n@@ -2661,2 +2670,1 @@\n-        = generate_disjoint_oop_copy(aligned, &entry, \"arrayof_oop_disjoint_arraycopy\",\n-                                     \/*dest_uninitialized*\/false);\n+        = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_id, &entry);\n@@ -2664,2 +2672,1 @@\n-        = generate_conjoint_oop_copy(aligned, entry, &entry_oop_arraycopy, \"arrayof_oop_arraycopy\",\n-                                     \/*dest_uninitialized*\/false);\n+        = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n@@ -2668,2 +2675,1 @@\n-        = generate_disjoint_oop_copy(aligned, &entry, \"arrayof_oop_disjoint_arraycopy_uninit\",\n-                                     \/*dest_uninitialized*\/true);\n+        = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_uninit_id, &entry);\n@@ -2671,2 +2677,1 @@\n-        = generate_conjoint_oop_copy(aligned, entry, nullptr, \"arrayof_oop_arraycopy_uninit\",\n-                                     \/*dest_uninitialized*\/true);\n+        = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_uninit_id, entry, nullptr);\n@@ -2680,3 +2685,2 @@\n-    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(\"checkcast_arraycopy\", &entry_checkcast_arraycopy);\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", nullptr,\n-                                                                        \/*dest_uninitialized*\/true);\n+    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id, nullptr);\n@@ -2684,2 +2688,1 @@\n-    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(\"unsafe_arraycopy\",\n-                                                              entry_jbyte_arraycopy,\n+    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(entry_jbyte_arraycopy,\n@@ -2690,2 +2693,1 @@\n-    StubRoutines::_generic_arraycopy   = generate_generic_copy(\"generic_arraycopy\",\n-                                                               entry_jbyte_arraycopy,\n+    StubRoutines::_generic_arraycopy   = generate_generic_copy(entry_jbyte_arraycopy,\n@@ -2698,6 +2700,6 @@\n-    StubRoutines::_jbyte_fill = generate_fill(T_BYTE, false, \"jbyte_fill\");\n-    StubRoutines::_jshort_fill = generate_fill(T_SHORT, false, \"jshort_fill\");\n-    StubRoutines::_jint_fill = generate_fill(T_INT, false, \"jint_fill\");\n-    StubRoutines::_arrayof_jbyte_fill = generate_fill(T_BYTE, true, \"arrayof_jbyte_fill\");\n-    StubRoutines::_arrayof_jshort_fill = generate_fill(T_SHORT, true, \"arrayof_jshort_fill\");\n-    StubRoutines::_arrayof_jint_fill = generate_fill(T_INT, true, \"arrayof_jint_fill\");\n+    StubRoutines::_jbyte_fill = generate_fill(StubGenStubId::jbyte_fill_id);\n+    StubRoutines::_jshort_fill = generate_fill(StubGenStubId::jshort_fill_id);\n+    StubRoutines::_jint_fill = generate_fill(StubGenStubId::jint_fill_id);\n+    StubRoutines::_arrayof_jbyte_fill = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n+    StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n+    StubRoutines::_arrayof_jint_fill = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n@@ -2717,1 +2719,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_encryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2750,1 +2753,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_decryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2788,1 +2792,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_encryptAESCrypt\");\n+    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2892,1 +2897,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_decryptAESCrypt\");\n+    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3078,1 +3084,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"counterMode_AESCrypt\");\n+    StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3287,1 +3294,2 @@\n-     StubCodeMark mark(this, \"StubRoutines\", \"galoisCounterMode_AESCrypt\");\n+    StubGenStubId stub_id = StubGenStubId::galoisCounterMode_AESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3496,1 +3504,12 @@\n-  address generate_md5_implCompress(bool multi_block, const char *name) {\n+  address generate_md5_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch (stub_id) {\n+    case md5_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case md5_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -3498,1 +3517,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -3637,1 +3657,13 @@\n-  address generate_sha1_implCompress(bool multi_block, const char *name) {\n+  address generate_sha1_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch (stub_id) {\n+    case sha1_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case sha1_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -3639,1 +3671,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -3729,1 +3762,13 @@\n-  address generate_sha256_implCompress(bool multi_block, const char *name) {\n+  address generate_sha256_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch (stub_id) {\n+    case sha256_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case sha256_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -3748,0 +3793,1 @@\n+\n@@ -3749,1 +3795,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -3871,1 +3918,13 @@\n-  address generate_sha512_implCompress(bool multi_block, const char *name) {\n+  address generate_sha512_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch (stub_id) {\n+    case sha512_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case sha512_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -3903,1 +3962,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -4019,1 +4079,13 @@\n-  address generate_sha3_implCompress(bool multi_block, const char *name) {\n+  address generate_sha3_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch (stub_id) {\n+    case sha3_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case sha3_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -4032,1 +4104,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -4249,1 +4322,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32\");\n+    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4294,1 +4368,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+    StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4416,1 +4491,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32C\");\n+    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32C_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4454,1 +4530,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesAdler32\");\n+    StubGenStubId stub_id = StubGenStubId::updateBytesAdler32_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4675,1 +4752,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"multiplyToLen\");\n+    StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4707,1 +4785,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"squareToLen\");\n+    StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4740,1 +4819,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"mulAdd\");\n+    StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4770,1 +4850,2 @@\n-    StubCodeMark mark(this,  \"StubRoutines\", \"bigIntegerRightShiftWorker\");\n+    StubGenStubId stub_id = StubGenStubId::bigIntegerRightShiftWorker_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4892,1 +4973,2 @@\n-    StubCodeMark mark(this,  \"StubRoutines\", \"bigIntegerLeftShiftWorker\");\n+    StubGenStubId stub_id = StubGenStubId::bigIntegerLeftShiftWorker_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5000,1 +5082,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"count_positives\");\n+    StubGenStubId stub_id = StubGenStubId::count_positives_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5261,1 +5344,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"large_array_equals\");\n+    StubGenStubId stub_id = StubGenStubId::large_array_equals_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5386,1 +5470,1 @@\n-    const char *mark_name = \"\";\n+    StubGenStubId stub_id;\n@@ -5389,1 +5473,1 @@\n-      mark_name = \"_large_arrays_hashcode_boolean\";\n+      stub_id = StubGenStubId::large_arrays_hashcode_boolean_id;\n@@ -5392,1 +5476,1 @@\n-      mark_name = \"_large_arrays_hashcode_byte\";\n+      stub_id = StubGenStubId::large_arrays_hashcode_byte_id;\n@@ -5395,1 +5479,1 @@\n-      mark_name = \"_large_arrays_hashcode_char\";\n+      stub_id = StubGenStubId::large_arrays_hashcode_char_id;\n@@ -5398,1 +5482,1 @@\n-      mark_name = \"_large_arrays_hashcode_short\";\n+      stub_id = StubGenStubId::large_arrays_hashcode_short_id;\n@@ -5401,1 +5485,1 @@\n-      mark_name = \"_large_arrays_hashcode_int\";\n+      stub_id = StubGenStubId::large_arrays_hashcode_int_id;\n@@ -5404,2 +5488,2 @@\n-      mark_name = \"_large_arrays_hashcode_incorrect_type\";\n-      __ should_not_reach_here();\n+      stub_id = StubGenStubId::NO_STUBID;\n+      ShouldNotReachHere();\n@@ -5408,1 +5492,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", mark_name);\n+    StubCodeMark mark(this, stub_id);\n@@ -5641,1 +5725,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", isCos ? \"libmDcos\" : \"libmDsin\");\n+    StubGenStubId stub_id = (isCos ? StubGenStubId::dcos_id : StubGenStubId::dsin_id);\n+    StubCodeMark mark(this, stub_id);\n@@ -5692,3 +5777,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", isLU\n-        ? \"compare_long_string_different_encoding LU\"\n-        : \"compare_long_string_different_encoding UL\");\n+    StubGenStubId stub_id = (isLU ? StubGenStubId::compare_long_string_LU_id : StubGenStubId::compare_long_string_UL_id);\n+    StubCodeMark mark(this, stub_id);\n@@ -5803,1 +5887,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"float16ToFloat\");\n+    StubGenStubId stub_id = StubGenStubId::hf2f_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5816,1 +5901,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"floatToFloat16\");\n+    StubGenStubId stub_id = StubGenStubId::f2hf_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5826,1 +5912,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5891,3 +5978,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", isLL\n-        ? \"compare_long_string_same_encoding LL\"\n-        : \"compare_long_string_same_encoding UU\");\n+    StubGenStubId stub_id = (isLL ? StubGenStubId::compare_long_string_LL_id : StubGenStubId::compare_long_string_UU_id);\n+    StubCodeMark mark(this, stub_id);\n@@ -6023,0 +6109,9 @@\n+    StubGenStubId stub_id;\n+    switch (mode) {\n+      case LL: stub_id = StubGenStubId::compare_long_string_LL_id;  break;\n+      case LU: stub_id = StubGenStubId::compare_long_string_LU_id; break;\n+      case UL: stub_id = StubGenStubId::compare_long_string_UL_id; break;\n+      case UU: stub_id = StubGenStubId::compare_long_string_UU_id; break;\n+      default: ShouldNotReachHere();\n+    }\n+\n@@ -6058,10 +6153,1 @@\n-    const char* stubname;\n-    switch (mode) {\n-      case LL: stubname = \"compare_long_string_same_encoding LL\";      break;\n-      case LU: stubname = \"compare_long_string_different_encoding LU\"; break;\n-      case UL: stubname = \"compare_long_string_different_encoding UL\"; break;\n-      case UU: stubname = \"compare_long_string_same_encoding UU\";      break;\n-      default: ShouldNotReachHere();\n-    }\n-\n-    StubCodeMark mark(this, \"StubRoutines\", stubname);\n+    StubCodeMark mark(this, stub_id);\n@@ -6159,3 +6245,14 @@\n-    const char* stubName = str1_isL\n-        ? (str2_isL ? \"indexof_linear_ll\" : \"indexof_linear_ul\")\n-        : \"indexof_linear_uu\";\n+    StubGenStubId stub_id;\n+    if (str1_isL) {\n+      if (str2_isL) {\n+        stub_id = StubGenStubId::string_indexof_linear_ll_id;\n+      } else {\n+        stub_id = StubGenStubId::string_indexof_linear_ul_id;\n+      }\n+    } else {\n+      if (str2_isL) {\n+        ShouldNotReachHere();\n+      } else {\n+        stub_id = StubGenStubId::string_indexof_linear_uu_id;\n+      }\n+    }\n@@ -6163,1 +6260,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stubName);\n+    StubCodeMark mark(this, stub_id);\n@@ -6461,1 +6558,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"large_byte_array_inflate\");\n+    StubGenStubId stub_id = StubGenStubId::large_byte_array_inflate_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6526,1 +6624,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"ghash_processBlocks\");\n+    StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6592,1 +6691,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"ghash_processBlocks_wide\");\n+    StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_wide_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6703,1 +6803,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"encodeBlock\");\n+    StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6971,1 +7072,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"decodeBlock\");\n+    StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7087,1 +7189,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"spin_wait\");\n+    StubGenStubId stub_id = StubGenStubId::spin_wait_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7096,2 +7199,3 @@\n-  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+  void generate_lookup_secondary_supers_table_stub() {\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7099,1 +7203,0 @@\n-    address start = __ pc();\n@@ -7111,10 +7214,11 @@\n-    Label L_success;\n-    __ enter();\n-    __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n-                                           r_array_base, r_array_length, r_array_index,\n-                                           vtemp, result, super_klass_index,\n-                                           \/*stub_is_near*\/true);\n-    __ leave();\n-    __ ret(lr);\n-\n-    return start;\n+    for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+      Label L_success;\n+      __ enter();\n+      __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n+                                             r_array_base, r_array_length, r_array_index,\n+                                             vtemp, result, slot,\n+                                             \/*stub_is_near*\/true);\n+      __ leave();\n+      __ ret(lr);\n+    }\n@@ -7125,1 +7229,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7278,1 +7383,0 @@\n-\n@@ -7280,1 +7384,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic entry points\");\n+    StubGenStubId stub_id = StubGenStubId::atomic_entry_points_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7439,1 +7544,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"Cont thaw\");\n+    StubGenStubId stub_id = StubGenStubId::cont_thaw_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7449,1 +7555,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier\");\n+    StubGenStubId stub_id = StubGenStubId::cont_returnBarrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7460,1 +7567,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier exception handler\");\n+    StubGenStubId stub_id = StubGenStubId::cont_returnBarrierExc_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7470,1 +7578,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\",\"Continuation preempt stub\");\n+    StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7552,1 +7661,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"poly1305_processBlocks\");\n+    StubGenStubId stub_id = StubGenStubId::poly1305_processBlocks_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7666,1 +7776,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+    StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -7683,1 +7794,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+    StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -8672,3 +8784,2 @@\n-    if (UsePoly1305Intrinsics) {\n-      StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n-    }\n+    StubRoutines::_upcall_stub_exception_handler = generate_upcall_stub_exception_handler();\n+    StubRoutines::_upcall_stub_load_target = generate_upcall_stub_load_target();\n@@ -8686,4 +8797,1 @@\n-        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n-            = generate_lookup_secondary_supers_table_stub(slot);\n-        }\n+        generate_lookup_secondary_supers_table_stub();\n@@ -8694,3 +8802,0 @@\n-    StubRoutines::_upcall_stub_exception_handler = generate_upcall_stub_exception_handler();\n-    StubRoutines::_upcall_stub_load_target = generate_upcall_stub_load_target();\n-\n@@ -8704,1 +8809,1 @@\n-      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(\"iota_indices\");\n+      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(StubGenStubId::vector_iota_indices_id);\n@@ -8748,1 +8853,2 @@\n-      StubCodeMark mark(this, \"StubRoutines\", \"montgomeryMultiply\");\n+      StubGenStubId stub_id = StubGenStubId::montgomeryMultiply_id;\n+      StubCodeMark mark(this, stub_id);\n@@ -8754,1 +8860,2 @@\n-      StubCodeMark mark(this, \"StubRoutines\", \"montgomerySquare\");\n+      StubGenStubId stub_id = StubGenStubId::montgomerySquare_id;\n+      StubCodeMark mark(this, stub_id);\n@@ -8794,2 +8901,2 @@\n-      StubRoutines::_md5_implCompress      = generate_md5_implCompress(false,    \"md5_implCompress\");\n-      StubRoutines::_md5_implCompressMB    = generate_md5_implCompress(true,     \"md5_implCompressMB\");\n+      StubRoutines::_md5_implCompress      = generate_md5_implCompress(StubGenStubId::md5_implCompress_id);\n+      StubRoutines::_md5_implCompressMB    = generate_md5_implCompress(StubGenStubId::md5_implCompressMB_id);\n@@ -8798,2 +8905,2 @@\n-      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(false,   \"sha1_implCompress\");\n-      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(true,    \"sha1_implCompressMB\");\n+      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(StubGenStubId::sha1_implCompress_id);\n+      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(StubGenStubId::sha1_implCompressMB_id);\n@@ -8802,2 +8909,2 @@\n-      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(false, \"sha256_implCompress\");\n-      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(true,  \"sha256_implCompressMB\");\n+      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n@@ -8806,2 +8913,2 @@\n-      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(false, \"sha512_implCompress\");\n-      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(true,  \"sha512_implCompressMB\");\n+      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n@@ -8810,2 +8917,6 @@\n-      StubRoutines::_sha3_implCompress     = generate_sha3_implCompress(false,   \"sha3_implCompress\");\n-      StubRoutines::_sha3_implCompressMB   = generate_sha3_implCompress(true,    \"sha3_implCompressMB\");\n+      StubRoutines::_sha3_implCompress     = generate_sha3_implCompress(StubGenStubId::sha3_implCompress_id);\n+      StubRoutines::_sha3_implCompressMB   = generate_sha3_implCompress(StubGenStubId::sha3_implCompressMB_id);\n+    }\n+\n+    if (UsePoly1305Intrinsics) {\n+      StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n@@ -8823,3 +8934,3 @@\n-  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    switch(kind) {\n-    case Initial_stubs:\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+    switch(blob_id) {\n+    case initial_id:\n@@ -8828,1 +8939,1 @@\n-     case Continuation_stubs:\n+     case continuation_id:\n@@ -8831,1 +8942,1 @@\n-    case Compiler_stubs:\n+    case compiler_id:\n@@ -8834,1 +8945,1 @@\n-    case Final_stubs:\n+    case final_id:\n@@ -8838,1 +8949,1 @@\n-      fatal(\"unexpected stubs kind: %d\", kind);\n+      fatal(\"unexpected blob id: %d\", blob_id);\n@@ -8844,2 +8955,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":559,"deletions":448,"binary":false,"changes":1007,"status":"modified"},{"patch":"@@ -32,2 +32,1 @@\n-\/\/ Implementation of the platform-specific part of StubRoutines - for\n-\/\/ a description of how to extend it, see the stubRoutines.hpp file.\n+\/\/ function used as default for spin_wait stub\n@@ -35,1 +34,1 @@\n-address StubRoutines::aarch64::_get_previous_sp_entry = nullptr;\n+static void empty_spin_wait() { }\n@@ -37,26 +36,1 @@\n-address StubRoutines::aarch64::_f2i_fixup = nullptr;\n-address StubRoutines::aarch64::_f2l_fixup = nullptr;\n-address StubRoutines::aarch64::_d2i_fixup = nullptr;\n-address StubRoutines::aarch64::_d2l_fixup = nullptr;\n-address StubRoutines::aarch64::_vector_iota_indices = nullptr;\n-address StubRoutines::aarch64::_float_sign_mask = nullptr;\n-address StubRoutines::aarch64::_float_sign_flip = nullptr;\n-address StubRoutines::aarch64::_double_sign_mask = nullptr;\n-address StubRoutines::aarch64::_double_sign_flip = nullptr;\n-address StubRoutines::aarch64::_zero_blocks = nullptr;\n-address StubRoutines::aarch64::_count_positives = nullptr;\n-address StubRoutines::aarch64::_count_positives_long = nullptr;\n-address StubRoutines::aarch64::_large_array_equals = nullptr;\n-address StubRoutines::aarch64::_large_arrays_hashcode_boolean = nullptr;\n-address StubRoutines::aarch64::_large_arrays_hashcode_byte = nullptr;\n-address StubRoutines::aarch64::_large_arrays_hashcode_char = nullptr;\n-address StubRoutines::aarch64::_large_arrays_hashcode_int = nullptr;\n-address StubRoutines::aarch64::_large_arrays_hashcode_short = nullptr;\n-address StubRoutines::aarch64::_compare_long_string_LL = nullptr;\n-address StubRoutines::aarch64::_compare_long_string_UU = nullptr;\n-address StubRoutines::aarch64::_compare_long_string_LU = nullptr;\n-address StubRoutines::aarch64::_compare_long_string_UL = nullptr;\n-address StubRoutines::aarch64::_string_indexof_linear_ll = nullptr;\n-address StubRoutines::aarch64::_string_indexof_linear_uu = nullptr;\n-address StubRoutines::aarch64::_string_indexof_linear_ul = nullptr;\n-address StubRoutines::aarch64::_large_byte_array_inflate = nullptr;\n+\/\/ define fields for arch-specific entries\n@@ -64,2 +38,10 @@\n-static void empty_spin_wait() { }\n-address StubRoutines::aarch64::_spin_wait = CAST_FROM_FN_PTR(address, empty_spin_wait);\n+#define DEFINE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = nullptr;\n+\n+#define DEFINE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = CAST_FROM_FN_PTR(address, init_function);\n+\n+STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY, DEFINE_ARCH_ENTRY_INIT)\n+\n+#undef DEFINE_ARCH_ENTRY_INIT\n+#undef DEFINE_ARCH_ENTRY\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":13,"deletions":31,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -37,0 +37,5 @@\n+\/\/ emit enum used to size per-blob code buffers\n+\n+#define DEFINE_BLOB_SIZE(blob_name, size) \\\n+  _ ## blob_name ## _code_size = size,\n+\n@@ -38,5 +43,1 @@\n-  \/\/ simply increase sizes if too small (assembler will crash if too small)\n-  _initial_stubs_code_size      = 10000,\n-  _continuation_stubs_code_size =  2000,\n-  _compiler_stubs_code_size     = 30000 ZGC_ONLY(+10000),\n-  _final_stubs_code_size        = 20000 ZGC_ONLY(+100000)\n+  STUBGEN_ARCH_BLOBS_DO(DEFINE_BLOB_SIZE)\n@@ -45,0 +46,2 @@\n+#undef DEFINE_BLOB_SIZE\n+\n@@ -47,0 +50,3 @@\n+#if INCLUDE_JVMCI\n+  friend class JVMCIVMStructs;\n+#endif\n@@ -48,44 +54,1 @@\n- private:\n-  static address _get_previous_sp_entry;\n-\n-  static address _f2i_fixup;\n-  static address _f2l_fixup;\n-  static address _d2i_fixup;\n-  static address _d2l_fixup;\n-\n-  static address _vector_iota_indices;\n-  static address _float_sign_mask;\n-  static address _float_sign_flip;\n-  static address _double_sign_mask;\n-  static address _double_sign_flip;\n-\n-  static address _zero_blocks;\n-\n-  static address _large_array_equals;\n-  static address _large_arrays_hashcode_boolean;\n-  static address _large_arrays_hashcode_byte;\n-  static address _large_arrays_hashcode_char;\n-  static address _large_arrays_hashcode_int;\n-  static address _large_arrays_hashcode_short;\n-  static address _compare_long_string_LL;\n-  static address _compare_long_string_LU;\n-  static address _compare_long_string_UL;\n-  static address _compare_long_string_UU;\n-  static address _string_indexof_linear_ll;\n-  static address _string_indexof_linear_uu;\n-  static address _string_indexof_linear_ul;\n-  static address _large_byte_array_inflate;\n-\n-  static address _spin_wait;\n-\n-  static bool _completed;\n-\n- public:\n-\n-  static address _count_positives;\n-  static address _count_positives_long;\n-\n-  static address get_previous_sp_entry()\n-  {\n-    return _get_previous_sp_entry;\n-  }\n+  \/\/ declare fields for arch-specific entries\n@@ -93,4 +56,2 @@\n-  static address f2i_fixup()\n-  {\n-    return _f2i_fixup;\n-  }\n+#define DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address STUB_FIELD_NAME(field_name) ;\n@@ -98,4 +59,2 @@\n-  static address f2l_fixup()\n-  {\n-    return _f2l_fixup;\n-  }\n+#define DECLARE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name)\n@@ -103,9 +62,2 @@\n-  static address d2i_fixup()\n-  {\n-    return _d2i_fixup;\n-  }\n-\n-  static address d2l_fixup()\n-  {\n-    return _d2l_fixup;\n-  }\n+private:\n+  STUBGEN_ARCH_ENTRIES_DO(DECLARE_ARCH_ENTRY, DECLARE_ARCH_ENTRY_INIT)\n@@ -113,3 +65,2 @@\n-  static address vector_iota_indices() {\n-    return _vector_iota_indices;\n-  }\n+#undef DECLARE_ARCH_ENTRY_INIT\n+#undef DECLARE_ARCH_ENTRY\n@@ -117,9 +68,1 @@\n-  static address float_sign_mask()\n-  {\n-    return _float_sign_mask;\n-  }\n-\n-  static address float_sign_flip()\n-  {\n-    return _float_sign_flip;\n-  }\n+  static bool _completed;\n@@ -127,4 +70,1 @@\n-  static address double_sign_mask()\n-  {\n-    return _double_sign_mask;\n-  }\n+ public:\n@@ -132,4 +72,1 @@\n-  static address double_sign_flip()\n-  {\n-    return _double_sign_flip;\n-  }\n+  \/\/ declare getters for arch-specific entries\n@@ -137,3 +74,2 @@\n-  static address zero_blocks() {\n-    return _zero_blocks;\n-  }\n+#define DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address getter_name() { return STUB_FIELD_NAME(field_name) ; }\n@@ -141,3 +77,2 @@\n-  static address count_positives() {\n-    return _count_positives;\n-  }\n+#define DEFINE_ARCH_ENTRY_GETTER_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name)\n@@ -145,3 +80,1 @@\n-  static address count_positives_long() {\n-      return _count_positives_long;\n-  }\n+  STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY_GETTER, DEFINE_ARCH_ENTRY_GETTER_INIT)\n@@ -149,3 +82,2 @@\n-  static address large_array_equals() {\n-      return _large_array_equals;\n-  }\n+#undef DEFINE_ARCH_ENTRY_GETTER_INIT\n+#undef DEFINE_ARCH_ENTRY_GETTER\n@@ -156,1 +88,1 @@\n-      return _large_arrays_hashcode_boolean;\n+      return large_arrays_hashcode_boolean();\n@@ -158,1 +90,1 @@\n-      return _large_arrays_hashcode_byte;\n+      return large_arrays_hashcode_byte();\n@@ -160,1 +92,1 @@\n-      return _large_arrays_hashcode_char;\n+      return large_arrays_hashcode_char();\n@@ -162,1 +94,1 @@\n-      return _large_arrays_hashcode_short;\n+      return large_arrays_hashcode_short();\n@@ -164,1 +96,1 @@\n-      return _large_arrays_hashcode_int;\n+      return large_arrays_hashcode_int();\n@@ -172,36 +104,0 @@\n-  static address compare_long_string_LL() {\n-      return _compare_long_string_LL;\n-  }\n-\n-  static address compare_long_string_LU() {\n-      return _compare_long_string_LU;\n-  }\n-\n-  static address compare_long_string_UL() {\n-      return _compare_long_string_UL;\n-  }\n-\n-  static address compare_long_string_UU() {\n-      return _compare_long_string_UU;\n-  }\n-\n-  static address string_indexof_linear_ul() {\n-      return _string_indexof_linear_ul;\n-  }\n-\n-  static address string_indexof_linear_ll() {\n-      return _string_indexof_linear_ll;\n-  }\n-\n-  static address string_indexof_linear_uu() {\n-      return _string_indexof_linear_uu;\n-  }\n-\n-  static address large_byte_array_inflate() {\n-      return _large_byte_array_inflate;\n-  }\n-\n-  static address spin_wait() {\n-    return _spin_wait;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.hpp","additions":35,"deletions":139,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ARM_STUBDECLARATIONS_HPP\n+#define CPU_ARM_STUBDECLARATIONS_HPP\n+\n+#define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n+  do_arch_blob(initial, 9000)                                           \\\n+  do_stub(initial, idiv_irem)                                           \\\n+  do_arch_entry(Arm, initial, idiv_irem,                                \\\n+                idiv_irem_entry, idiv_irem_entry)                       \\\n+  do_stub(initial, atomic_load_long)                                    \\\n+  do_arch_entry(Arm, initial, atomic_load_long,                         \\\n+                atomic_load_long_entry, atomic_load_long_entry)         \\\n+  do_stub(initial, atomic_store_long)                                   \\\n+  do_arch_entry(Arm, initial, atomic_load_long,                         \\\n+                atomic_store_long_entry, atomic_store_long_entry)       \\\n+\n+#define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \\\n+                                           do_arch_blob,                \\\n+                                           do_arch_entry,               \\\n+                                           do_arch_entry_init)          \\\n+  do_arch_blob(continuation, 2000)                                      \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \\\n+                                       do_arch_blob,                    \\\n+                                       do_arch_entry,                   \\\n+                                       do_arch_entry_init)              \\\n+  do_arch_blob(compiler, 22000)                                         \\\n+  do_stub(compiler, partial_subtype_check)                              \\\n+  do_arch_entry(Arm, compiler, partial_subtype_check,                   \\\n+                partial_subtype_check, partial_subtype_check)           \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \\\n+                                    do_arch_blob,                       \\\n+                                    do_arch_entry,                      \\\n+                                    do_arch_entry_init)                 \\\n+  do_arch_blob(final, 22000)                                            \\\n+\n+\n+#endif \/\/ CPU_ARM_STUBDECLARATIONS_HPP\n","filename":"src\/hotspot\/cpu\/arm\/stubDeclarations_arm.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -175,1 +175,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"call_stub\");\n+    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -254,1 +255,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"catch_exception\");\n+    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -266,1 +268,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"forward exception\");\n+    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -315,0 +318,2 @@\n+    StubGenStubId stub_id = StubGenStubId::idiv_irem_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -456,1 +461,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_add\");\n+    StubGenStubId stub_id = StubGenStubId::atomic_add_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -507,1 +513,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_xchg\");\n+    StubGenStubId stub_id = StubGenStubId::atomic_xchg_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -557,1 +564,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_cmpxchg\");\n+    StubGenStubId stub_id = StubGenStubId::atomic_cmpxchg_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -595,1 +603,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_cmpxchg_long\");\n+    StubGenStubId stub_id = StubGenStubId::atomic_cmpxchg_long_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -632,1 +641,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_load_long\");\n+    StubGenStubId stub_id = StubGenStubId::atomic_load_long_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -656,1 +666,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_store_long\");\n+    StubGenStubId stub_id = StubGenStubId::atomic_store_long_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -698,1 +709,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"partial_subtype_check\");\n+    StubGenStubId stub_id = StubGenStubId::partial_subtype_check_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -787,1 +799,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"verify_oop\");\n+    StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1988,0 +2001,17 @@\n+  \/* Internal development flag                     *\/\n+  \/* enabled by defining TEST_C2_GENERIC_ARRAYCOPY *\/\n+\n+  \/\/ With this flag, the C2 stubs are tested by generating calls to\n+  \/\/ generic_arraycopy instead of Runtime1::arraycopy\n+\n+  \/\/ Runtime1::arraycopy return a status in R0 (0 if OK, else ~copied)\n+  \/\/ and the result is tested to see whether the arraycopy stub should\n+  \/\/ be called.\n+\n+  \/\/ When we test arraycopy this way, we must generate extra code in the\n+  \/\/ arraycopy methods callable from C2 generic_arraycopy to set the\n+  \/\/ status to 0 for those who always succeed (calling the slow path stub might\n+  \/\/ lead to errors since the copy has already been performed).\n+\n+  static const bool set_status;\n+\n@@ -2000,1 +2030,101 @@\n-  address generate_primitive_copy(bool aligned, const char * name, bool status, int bytes_per_count, bool disjoint, address nooverlap_target = nullptr) {\n+  address generate_primitive_copy(StubGenStubId stub_id, address nooverlap_target = nullptr) {\n+    bool aligned;\n+    bool status;\n+    int bytes_per_count;\n+    bool disjoint;\n+\n+    switch (stub_id) {\n+    case jbyte_disjoint_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 1;\n+      disjoint = true;\n+      break;\n+    case jshort_disjoint_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 2;\n+      disjoint = true;\n+      break;\n+    case jint_disjoint_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 4;\n+      disjoint = true;\n+      break;\n+    case jlong_disjoint_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 8;\n+      disjoint = true;\n+      break;\n+    case arrayof_jbyte_disjoint_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      bytes_per_count = 1;\n+      disjoint = true;\n+      break;\n+    case arrayof_jshort_disjoint_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      bytes_per_count = 2;\n+      disjoint = true;\n+      break;\n+    case arrayof_jint_disjoint_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      bytes_per_count = 4;\n+      disjoint = true;\n+      break;\n+    case arrayof_jlong_disjoint_arraycopy_id:\n+      aligned = false;\n+      status = set_status;\n+      bytes_per_count = 8;\n+      disjoint = true;\n+      break;\n+    case jbyte_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 1;\n+      disjoint = false;\n+      break;\n+    case jshort_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 2;\n+      disjoint = false;\n+      break;\n+    case jint_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 4;\n+      disjoint = false;\n+      break;\n+    case jlong_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      bytes_per_count = 8;\n+      disjoint = false;\n+      break;\n+    case arrayof_jbyte_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      bytes_per_count = 1;\n+      disjoint = false;\n+      break;\n+    case arrayof_jshort_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      bytes_per_count = 2;\n+      disjoint = false;\n+      break;\n+    case arrayof_jint_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      bytes_per_count = 4;\n+      disjoint = false;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -2002,1 +2132,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2174,1 +2304,30 @@\n-  address generate_oop_copy(bool aligned, const char * name, bool status, bool disjoint, address nooverlap_target = nullptr) {\n+  address generate_oop_copy(StubGenStubId stub_id, address nooverlap_target = nullptr) {\n+    bool aligned;\n+    bool status;\n+    bool disjoint;\n+\n+    switch (stub_id) {\n+    case oop_disjoint_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      disjoint = true;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      disjoint = true;\n+      break;\n+    case oop_arraycopy_id:\n+      aligned = false;\n+      status = true;\n+      disjoint = false;\n+      break;\n+    case arrayof_oop_arraycopy_id:\n+      aligned = true;\n+      status = set_status;\n+      disjoint = false;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -2176,1 +2335,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2311,1 +2470,1 @@\n-  address generate_unsafe_copy(const char* name) {\n+  address generate_unsafe_copy() {\n@@ -2320,1 +2479,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2445,1 +2605,1 @@\n-  address generate_checkcast_copy(const char * name) {\n+  address generate_checkcast_copy() {\n@@ -2447,1 +2607,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::checkcast_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2598,1 +2759,1 @@\n-  address generate_generic_copy(const char *name) {\n+  address generate_generic_copy() {\n@@ -2614,1 +2775,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2845,18 +3007,0 @@\n-    bool status = false; \/\/ non failing C2 stubs need not return a status in R0\n-\n-#ifdef TEST_C2_GENERIC_ARRAYCOPY \/* Internal development flag *\/\n-    \/\/ With this flag, the C2 stubs are tested by generating calls to\n-    \/\/ generic_arraycopy instead of Runtime1::arraycopy\n-\n-    \/\/ Runtime1::arraycopy return a status in R0 (0 if OK, else ~copied)\n-    \/\/ and the result is tested to see whether the arraycopy stub should\n-    \/\/ be called.\n-\n-    \/\/ When we test arraycopy this way, we must generate extra code in the\n-    \/\/ arraycopy methods callable from C2 generic_arraycopy to set the\n-    \/\/ status to 0 for those who always succeed (calling the slow path stub might\n-    \/\/ lead to errors since the copy has already been performed).\n-\n-    status = true; \/\/ generate a status compatible with C1 calls\n-#endif\n-\n@@ -2867,11 +3011,11 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy  = generate_primitive_copy(false, \"jbyte_disjoint_arraycopy\",  true, 1, true);\n-    StubRoutines::_jshort_disjoint_arraycopy = generate_primitive_copy(false, \"jshort_disjoint_arraycopy\", true, 2, true);\n-    StubRoutines::_jint_disjoint_arraycopy   = generate_primitive_copy(false, \"jint_disjoint_arraycopy\",   true, 4, true);\n-    StubRoutines::_jlong_disjoint_arraycopy  = generate_primitive_copy(false, \"jlong_disjoint_arraycopy\",  true, 8, true);\n-    StubRoutines::_oop_disjoint_arraycopy    = generate_oop_copy      (false, \"oop_disjoint_arraycopy\",    true,    true);\n-\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_primitive_copy(true, \"arrayof_jbyte_disjoint_arraycopy\", status, 1, true);\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_primitive_copy(true, \"arrayof_jshort_disjoint_arraycopy\",status, 2, true);\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_primitive_copy(true, \"arrayof_jint_disjoint_arraycopy\",  status, 4, true);\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy  = generate_primitive_copy(true, \"arrayof_jlong_disjoint_arraycopy\", status, 8, true);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy    = generate_oop_copy      (true, \"arrayof_oop_disjoint_arraycopy\",   status,    true);\n+    StubRoutines::_jbyte_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_jshort_disjoint_arraycopy = generate_primitive_copy(StubGenStubId::jshort_disjoint_arraycopy_id);\n+    StubRoutines::_jint_disjoint_arraycopy   = generate_primitive_copy(StubGenStubId::jint_disjoint_arraycopy_id);\n+    StubRoutines::_jlong_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::jlong_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy    = generate_oop_copy      (StubGenStubId::oop_disjoint_arraycopy_id);\n+\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_primitive_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_primitive_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy  = generate_primitive_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy    = generate_oop_copy      (StubGenStubId::arrayof_oop_disjoint_arraycopy_id);\n@@ -2880,8 +3024,8 @@\n-    StubRoutines::_jbyte_arraycopy  = generate_primitive_copy(false, \"jbyte_arraycopy\",  true, 1, false, StubRoutines::_jbyte_disjoint_arraycopy);\n-    StubRoutines::_jshort_arraycopy = generate_primitive_copy(false, \"jshort_arraycopy\", true, 2, false, StubRoutines::_jshort_disjoint_arraycopy);\n-    StubRoutines::_jint_arraycopy   = generate_primitive_copy(false, \"jint_arraycopy\",   true, 4, false, StubRoutines::_jint_disjoint_arraycopy);\n-    StubRoutines::_jlong_arraycopy  = generate_primitive_copy(false, \"jlong_arraycopy\",  true, 8, false, StubRoutines::_jlong_disjoint_arraycopy);\n-    StubRoutines::_oop_arraycopy    = generate_oop_copy      (false, \"oop_arraycopy\",    true,    false, StubRoutines::_oop_disjoint_arraycopy);\n-\n-    StubRoutines::_arrayof_jbyte_arraycopy    = generate_primitive_copy(true, \"arrayof_jbyte_arraycopy\",  status, 1, false, StubRoutines::_arrayof_jbyte_disjoint_arraycopy);\n-    StubRoutines::_arrayof_jshort_arraycopy   = generate_primitive_copy(true, \"arrayof_jshort_arraycopy\", status, 2, false, StubRoutines::_arrayof_jshort_disjoint_arraycopy);\n+    StubRoutines::_jbyte_arraycopy  = generate_primitive_copy(StubGenStubId::jbyte_arraycopy_id, StubRoutines::_jbyte_disjoint_arraycopy);\n+    StubRoutines::_jshort_arraycopy = generate_primitive_copy(StubGenStubId::jshort_arraycopy_id, StubRoutines::_jshort_disjoint_arraycopy);\n+    StubRoutines::_jint_arraycopy   = generate_primitive_copy(StubGenStubId::jint_arraycopy_id, StubRoutines::_jint_disjoint_arraycopy);\n+    StubRoutines::_jlong_arraycopy  = generate_primitive_copy(StubGenStubId::jlong_arraycopy_id, StubRoutines::_jlong_disjoint_arraycopy);\n+    StubRoutines::_oop_arraycopy    = generate_oop_copy      (StubGenStubId::oop_arraycopy_id, StubRoutines::_oop_disjoint_arraycopy);\n+\n+    StubRoutines::_arrayof_jbyte_arraycopy    = generate_primitive_copy(StubGenStubId::arrayof_jbyte_arraycopy_id, StubRoutines::_arrayof_jbyte_disjoint_arraycopy);\n+    StubRoutines::_arrayof_jshort_arraycopy   = generate_primitive_copy(StubGenStubId::arrayof_jshort_arraycopy_id, StubRoutines::_arrayof_jshort_disjoint_arraycopy);\n@@ -2890,1 +3034,1 @@\n-    StubRoutines::_arrayof_jint_arraycopy     = generate_primitive_copy(true, \"arrayof_jint_arraycopy\",   status, 4, false, StubRoutines::_arrayof_jint_disjoint_arraycopy);\n+    StubRoutines::_arrayof_jint_arraycopy     = generate_primitive_copy(StubGenStubId::arrayof_jint_arraycopy_id, StubRoutines::_arrayof_jint_disjoint_arraycopy);\n@@ -2895,1 +3039,1 @@\n-      StubRoutines::_arrayof_oop_arraycopy    = generate_oop_copy      (true, \"arrayof_oop_arraycopy\",    status,    false, StubRoutines::_arrayof_oop_disjoint_arraycopy);\n+      StubRoutines::_arrayof_oop_arraycopy    = generate_oop_copy      (StubGenStubId::arrayof_oop_arraycopy_id, StubRoutines::_arrayof_oop_disjoint_arraycopy);\n@@ -2901,3 +3045,3 @@\n-    StubRoutines::_checkcast_arraycopy = generate_checkcast_copy(\"checkcast_arraycopy\");\n-    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(\"unsafe_arraycopy\");\n-    StubRoutines::_generic_arraycopy   = generate_generic_copy(\"generic_arraycopy\");\n+    StubRoutines::_checkcast_arraycopy = generate_checkcast_copy();\n+    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy();\n+    StubRoutines::_generic_arraycopy   = generate_generic_copy();\n@@ -2910,1 +3054,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2963,1 +3108,1 @@\n-  address generate_cont_thaw(const char* label, Continuation::thaw_kind kind) {\n+  address generate_cont_thaw(StubGenStubId stub_id) {\n@@ -2970,1 +3115,1 @@\n-    return generate_cont_thaw(\"Cont thaw\", Continuation::thaw_top);\n+    return generate_cont_thaw(StubGenStubId::cont_thaw_id);\n@@ -2974,1 +3119,1 @@\n-    return generate_cont_thaw(\"Cont thaw return barrier\", Continuation::thaw_return_barrier);\n+    return generate_cont_thaw(StubGenStubId::cont_returnBarrier_id);\n@@ -2978,1 +3123,1 @@\n-    return generate_cont_thaw(\"Cont thaw return barrier exception\", Continuation::thaw_return_barrier_exception);\n+    return generate_cont_thaw(StubGenStubId::cont_returnBarrierExc_id);\n@@ -3010,2 +3155,2 @@\n-    StubRoutines::_atomic_load_long_entry = generate_atomic_load_long();\n-    StubRoutines::_atomic_store_long_entry = generate_atomic_store_long();\n+    StubRoutines::Arm::_atomic_load_long_entry = generate_atomic_load_long();\n+    StubRoutines::Arm::_atomic_store_long_entry = generate_atomic_store_long();\n@@ -3061,3 +3206,3 @@\n-  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    switch(kind) {\n-    case Initial_stubs:\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+    switch(blob_id) {\n+    case initial_id:\n@@ -3066,1 +3211,1 @@\n-     case Continuation_stubs:\n+     case continuation_id:\n@@ -3069,1 +3214,1 @@\n-    case Compiler_stubs:\n+    case compiler_id:\n@@ -3072,1 +3217,1 @@\n-    case Final_stubs:\n+    case final_id:\n@@ -3076,1 +3221,1 @@\n-      fatal(\"unexpected stubs kind: %d\", kind);\n+      fatal(\"unexpected blob id: %d\", blob_id);\n@@ -3082,2 +3227,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n@@ -3085,0 +3230,9 @@\n+\n+\/\/ implementation of internal development flag\n+\n+#ifdef TEST_C2_GENERIC_ARRAYCOPY\n+const bool StubGenerator::set_status = true; \/\/ generate a status compatible with C1 calls\n+#else\n+const bool StubGenerator::set_status = false; \/\/ non failing C2 stubs need not return a status in R0\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":233,"deletions":79,"binary":false,"changes":312,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"aesencryptBlock\");\n+  StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -319,1 +320,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"aesdecryptBlock\");\n+  StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -539,1 +541,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_encryptAESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -604,1 +607,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_decryptAESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/arm\/stubRoutinesCrypto_arm.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,0 +2,3 @@\n+<<<<<<< HEAD\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+=======\n@@ -3,0 +6,1 @@\n+>>>>>>> master\n@@ -29,1 +33,2 @@\n-address StubRoutines::Arm::_idiv_irem_entry = nullptr;\n+#define DEFINE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = nullptr;\n@@ -31,1 +36,2 @@\n-address StubRoutines::Arm::_partial_subtype_check = nullptr;\n+#define DEFINE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = CAST_FROM_FN_PTR(address, init_function);\n@@ -33,2 +39,4 @@\n-address StubRoutines::_atomic_load_long_entry = nullptr;\n-address StubRoutines::_atomic_store_long_entry = nullptr;\n+STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY, DEFINE_ARCH_ENTRY_INIT)\n+\n+#undef DEFINE_ARCH_ENTRY_INIT\n+#undef DEFINE_ARCH_ENTRY\n","filename":"src\/hotspot\/cpu\/arm\/stubRoutines_arm.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,5 @@\n+\/\/ emit enum used to size per-blob code buffers\n+\n+#define DEFINE_BLOB_SIZE(blob_name, size) \\\n+  _ ## blob_name ## _code_size = size,\n+\n@@ -33,5 +38,1 @@\n-  \/\/ simply increase sizes if too small (assembler will crash if too small)\n-  _initial_stubs_code_size      =  9000,\n-  _continuation_stubs_code_size =  2000,\n-  _compiler_stubs_code_size     = 22000,\n-  _final_stubs_code_size        = 22000\n+  STUBGEN_ARCH_BLOBS_DO(DEFINE_BLOB_SIZE)\n@@ -40,0 +41,7 @@\n+#undef DEFINE_BLOB_SIZE\n+\n+public:\n+  static bool returns_to_call_stub(address return_pc) {\n+    return return_pc == _call_stub_return_address;\n+  }\n+\n@@ -44,1 +52,2 @@\n- private:\n+#define DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address STUB_FIELD_NAME(field_name) ;\n@@ -46,2 +55,2 @@\n-  static address _idiv_irem_entry;\n-  static address _partial_subtype_check;\n+#define DECLARE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name)\n@@ -49,1 +58,2 @@\n- public:\n+private:\n+  STUBGEN_ARCH_ENTRIES_DO(DECLARE_ARCH_ENTRY, DECLARE_ARCH_ENTRY_INIT)\n@@ -51,3 +61,2 @@\n-  static address idiv_irem_entry() { return _idiv_irem_entry; }\n-  static address partial_subtype_check() { return _partial_subtype_check; }\n-};\n+#undef DECLARE_ARCH_ENTRY_INIT\n+#undef DECLARE_ARCH_ENTRY\n@@ -55,3 +64,3 @@\n-  static bool returns_to_call_stub(address return_pc) {\n-    return return_pc == _call_stub_return_address;\n-  }\n+public:\n+\n+  \/\/ declare getters for arch-specific entries\n@@ -59,2 +68,2 @@\n-  static address _atomic_load_long_entry;\n-  static address _atomic_store_long_entry;\n+#define DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address getter_name() { return STUB_FIELD_NAME(field_name) ; }\n@@ -62,2 +71,2 @@\n-  static address atomic_load_long_entry()                  { return _atomic_load_long_entry; }\n-  static address atomic_store_long_entry()                 { return _atomic_store_long_entry; }\n+#define DEFINE_ARCH_ENTRY_GETTER_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name)\n@@ -65,0 +74,6 @@\n+  STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY_GETTER, DEFINE_ARCH_ENTRY_GETTER_INIT)\n+\n+#undef DEFINE_ARCH_ENTRY_GETTER_INIT\n+#undef DEFINE_ARCH_ENTRY_GETTER\n+\n+};\n","filename":"src\/hotspot\/cpu\/arm\/stubRoutines_arm.hpp","additions":35,"deletions":20,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_PPC_STUBDECLARATIONS_HPP\n+#define CPU_PPC_STUBDECLARATIONS_HPP\n+\n+#define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n+  do_arch_blob(initial, 20000)                                          \\\n+\n+\n+#define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \\\n+                                           do_arch_blob,                \\\n+                                           do_arch_entry,               \\\n+                                           do_arch_entry_init)          \\\n+  do_arch_blob(continuation, 2000)                                      \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \\\n+                                       do_arch_blob,                    \\\n+                                       do_arch_entry,                   \\\n+                                       do_arch_entry_init)              \\\n+  do_arch_blob(compiler, 24000)                                         \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \\\n+                                    do_arch_blob,                       \\\n+                                    do_arch_entry,                      \\\n+                                    do_arch_entry_init)                 \\\n+  do_arch_blob(final, 24000)                                            \\\n+\n+\n+#endif \/\/ CPU_PPC_STUBDECLARATIONS_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/stubDeclarations_ppc.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -3,0 +3,3 @@\n+<<<<<<< HEAD\n+ * Copyright (c) 2012, 2025 SAP SE. All rights reserved.\n+=======\n@@ -4,0 +7,1 @@\n+>>>>>>> master\n@@ -92,1 +96,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"call_stub\");\n+    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -395,1 +400,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"catch_exception\");\n+    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -450,1 +456,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"forward_exception\");\n+    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -520,87 +527,0 @@\n-\n-  \/\/ Support for void zero_words_aligned8(HeapWord* to, size_t count)\n-  \/\/\n-  \/\/ Arguments:\n-  \/\/   to:\n-  \/\/   count:\n-  \/\/\n-  \/\/ Destroys:\n-  \/\/\n-  address generate_zero_words_aligned8() {\n-    StubCodeMark mark(this, \"StubRoutines\", \"zero_words_aligned8\");\n-\n-    \/\/ Implemented as in ClearArray.\n-    address start = __ function_entry();\n-\n-    Register base_ptr_reg   = R3_ARG1; \/\/ tohw (needs to be 8b aligned)\n-    Register cnt_dwords_reg = R4_ARG2; \/\/ count (in dwords)\n-    Register tmp1_reg       = R5_ARG3;\n-    Register tmp2_reg       = R6_ARG4;\n-    Register zero_reg       = R7_ARG5;\n-\n-    \/\/ Procedure for large arrays (uses data cache block zero instruction).\n-    Label dwloop, fast, fastloop, restloop, lastdword, done;\n-    int cl_size = VM_Version::L1_data_cache_line_size();\n-    int cl_dwords = cl_size >> 3;\n-    int cl_dwordaddr_bits = exact_log2(cl_dwords);\n-    int min_dcbz = 2; \/\/ Needs to be positive, apply dcbz only to at least min_dcbz cache lines.\n-\n-    \/\/ Clear up to 128byte boundary if long enough, dword_cnt=(16-(base>>3))%16.\n-    __ dcbtst(base_ptr_reg);                    \/\/ Indicate write access to first cache line ...\n-    __ andi(tmp2_reg, cnt_dwords_reg, 1);       \/\/ to check if number of dwords is even.\n-    __ srdi_(tmp1_reg, cnt_dwords_reg, 1);      \/\/ number of double dwords\n-    __ load_const_optimized(zero_reg, 0L);      \/\/ Use as zero register.\n-\n-    __ cmpdi(CCR1, tmp2_reg, 0);                \/\/ cnt_dwords even?\n-    __ beq(CCR0, lastdword);                    \/\/ size <= 1\n-    __ mtctr(tmp1_reg);                         \/\/ Speculatively preload counter for rest loop (>0).\n-    __ cmpdi(CCR0, cnt_dwords_reg, (min_dcbz+1)*cl_dwords-1); \/\/ Big enough to ensure >=min_dcbz cache lines are included?\n-    __ neg(tmp1_reg, base_ptr_reg);             \/\/ bit 0..58: bogus, bit 57..60: (16-(base>>3))%16, bit 61..63: 000\n-\n-    __ blt(CCR0, restloop);                     \/\/ Too small. (<31=(2*cl_dwords)-1 is sufficient, but bigger performs better.)\n-    __ rldicl_(tmp1_reg, tmp1_reg, 64-3, 64-cl_dwordaddr_bits); \/\/ Extract number of dwords to 128byte boundary=(16-(base>>3))%16.\n-\n-    __ beq(CCR0, fast);                         \/\/ already 128byte aligned\n-    __ mtctr(tmp1_reg);                         \/\/ Set ctr to hit 128byte boundary (0<ctr<cnt).\n-    __ subf(cnt_dwords_reg, tmp1_reg, cnt_dwords_reg); \/\/ rest (>0 since size>=256-8)\n-\n-    \/\/ Clear in first cache line dword-by-dword if not already 128byte aligned.\n-    __ bind(dwloop);\n-      __ std(zero_reg, 0, base_ptr_reg);        \/\/ Clear 8byte aligned block.\n-      __ addi(base_ptr_reg, base_ptr_reg, 8);\n-    __ bdnz(dwloop);\n-\n-    \/\/ clear 128byte blocks\n-    __ bind(fast);\n-    __ srdi(tmp1_reg, cnt_dwords_reg, cl_dwordaddr_bits); \/\/ loop count for 128byte loop (>0 since size>=256-8)\n-    __ andi(tmp2_reg, cnt_dwords_reg, 1);       \/\/ to check if rest even\n-\n-    __ mtctr(tmp1_reg);                         \/\/ load counter\n-    __ cmpdi(CCR1, tmp2_reg, 0);                \/\/ rest even?\n-    __ rldicl_(tmp1_reg, cnt_dwords_reg, 63, 65-cl_dwordaddr_bits); \/\/ rest in double dwords\n-\n-    __ bind(fastloop);\n-      __ dcbz(base_ptr_reg);                    \/\/ Clear 128byte aligned block.\n-      __ addi(base_ptr_reg, base_ptr_reg, cl_size);\n-    __ bdnz(fastloop);\n-\n-    \/\/__ dcbtst(base_ptr_reg);                  \/\/ Indicate write access to last cache line.\n-    __ beq(CCR0, lastdword);                    \/\/ rest<=1\n-    __ mtctr(tmp1_reg);                         \/\/ load counter\n-\n-    \/\/ Clear rest.\n-    __ bind(restloop);\n-      __ std(zero_reg, 0, base_ptr_reg);        \/\/ Clear 8byte aligned block.\n-      __ std(zero_reg, 8, base_ptr_reg);        \/\/ Clear 8byte aligned block.\n-      __ addi(base_ptr_reg, base_ptr_reg, 16);\n-    __ bdnz(restloop);\n-\n-    __ bind(lastdword);\n-    __ beq(CCR1, done);\n-    __ std(zero_reg, 0, base_ptr_reg);\n-    __ bind(done);\n-    __ blr();                                   \/\/ return\n-\n-    return start;\n-  }\n-\n@@ -650,2 +570,34 @@\n-  address generate_fill(BasicType t, bool aligned, const char* name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_fill(StubGenStubId stub_id) {\n+    BasicType t;\n+    bool aligned;\n+\n+    switch (stub_id) {\n+    case jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = false;\n+      break;\n+    case jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = false;\n+      break;\n+    case jint_fill_id:\n+      t = T_INT;\n+      aligned = false;\n+      break;\n+    case arrayof_jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = true;\n+      break;\n+    case arrayof_jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = true;\n+      break;\n+    case arrayof_jint_fill_id:\n+      t = T_INT;\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -896,2 +848,14 @@\n-  address generate_disjoint_byte_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_disjoint_byte_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jbyte_disjoint_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jbyte_disjoint_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1075,2 +1039,14 @@\n-  address generate_conjoint_byte_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_conjoint_byte_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jbyte_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jbyte_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1164,2 +1140,14 @@\n-  address generate_disjoint_short_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_disjoint_short_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jshort_disjoint_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jshort_disjoint_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1347,2 +1335,14 @@\n-  address generate_conjoint_short_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_conjoint_short_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jshort_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jshort_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1518,2 +1518,14 @@\n-  address generate_disjoint_int_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_disjoint_int_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jint_disjoint_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jint_disjoint_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1665,2 +1677,14 @@\n-  address generate_conjoint_int_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_conjoint_int_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jint_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jint_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1796,2 +1820,14 @@\n-  address generate_disjoint_long_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_disjoint_long_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jlong_disjoint_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jlong_disjoint_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1922,2 +1958,14 @@\n-  address generate_conjoint_long_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_conjoint_long_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    switch (stub_id) {\n+    case jlong_arraycopy_id:\n+      aligned = false;\n+      break;\n+    case arrayof_jlong_arraycopy_id:\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1951,2 +1999,23 @@\n-  address generate_conjoint_oop_copy(bool aligned, const char * name, bool dest_uninitialized) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_conjoint_oop_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case oop_arraycopy_id:\n+      aligned = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_arraycopy_id:\n+      aligned = true;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_arraycopy_uninit_id:\n+      aligned = false;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_arraycopy_uninit_id:\n+      aligned = true;\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -1954,0 +2023,1 @@\n+    StubCodeMark mark(this, stub_id);\n@@ -2000,2 +2070,25 @@\n-  address generate_disjoint_oop_copy(bool aligned, const char * name, bool dest_uninitialized) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_disjoint_oop_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case oop_disjoint_arraycopy_id:\n+      aligned = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_id:\n+      aligned = true;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_disjoint_arraycopy_uninit_id:\n+      aligned = false;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+      aligned = true;\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -2069,2 +2162,1 @@\n-  address generate_checkcast_copy(const char *name, bool dest_uninitialized) {\n-\n+  address generate_checkcast_copy(StubGenStubId stub_id) {\n@@ -2084,0 +2176,11 @@\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case checkcast_arraycopy_id:\n+      dest_uninitialized = false;\n+      break;\n+    case checkcast_arraycopy_uninit_id:\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -2085,1 +2188,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2204,2 +2307,1 @@\n-  address generate_unsafe_copy(const char* name,\n-                               address byte_copy_entry,\n+  address generate_unsafe_copy(address byte_copy_entry,\n@@ -2218,1 +2320,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2301,2 +2404,1 @@\n-  address generate_generic_copy(const char *name,\n-                                address entry_jbyte_arraycopy,\n+  address generate_generic_copy(address entry_jbyte_arraycopy,\n@@ -2325,1 +2427,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2527,1 +2630,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_encryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2734,1 +2838,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_decryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2971,1 +3076,1 @@\n-  address generate_sha256_implCompress(bool multi_block, const char *name) {\n+  address generate_sha256_implCompress(StubGenStubId stub_id) {\n@@ -2973,1 +3078,12 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    bool multi_block;\n+    switch (stub_id) {\n+    case sha256_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case sha256_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    StubCodeMark mark(this, stub_id);\n@@ -2982,1 +3098,1 @@\n-  address generate_sha512_implCompress(bool multi_block, const char *name) {\n+  address generate_sha512_implCompress(StubGenStubId stub_id) {\n@@ -2984,1 +3100,12 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    bool multi_block;\n+    switch (stub_id) {\n+    case sha512_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case sha512_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    StubCodeMark mark(this, stub_id);\n@@ -2995,1 +3122,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"_data_cache_writeback\");\n+    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3008,2 +3136,2 @@\n-\n-    StubCodeMark mark(this, \"StubRoutines\", \"_data_cache_writeback_sync\");\n+    StubGenStubId stub_id = StubGenStubId::data_cache_writeback_sync_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3029,6 +3157,6 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy       = generate_disjoint_byte_copy(false, \"jbyte_disjoint_arraycopy\");\n-    StubRoutines::_jshort_disjoint_arraycopy      = generate_disjoint_short_copy(false, \"jshort_disjoint_arraycopy\");\n-    StubRoutines::_jint_disjoint_arraycopy        = generate_disjoint_int_copy(false, \"jint_disjoint_arraycopy\");\n-    StubRoutines::_jlong_disjoint_arraycopy       = generate_disjoint_long_copy(false, \"jlong_disjoint_arraycopy\");\n-    StubRoutines::_oop_disjoint_arraycopy         = generate_disjoint_oop_copy(false, \"oop_disjoint_arraycopy\", false);\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_oop_copy(false, \"oop_disjoint_arraycopy_uninit\", true);\n+    StubRoutines::_jbyte_disjoint_arraycopy       = generate_disjoint_byte_copy(StubGenStubId::jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_jshort_disjoint_arraycopy      = generate_disjoint_short_copy(StubGenStubId::jshort_disjoint_arraycopy_id);\n+    StubRoutines::_jint_disjoint_arraycopy        = generate_disjoint_int_copy(StubGenStubId::jint_disjoint_arraycopy_id);\n+    StubRoutines::_jlong_disjoint_arraycopy       = generate_disjoint_long_copy(StubGenStubId::jlong_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy         = generate_disjoint_oop_copy(StubGenStubId::oop_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id);\n@@ -3037,6 +3165,6 @@\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_byte_copy(true, \"arrayof_jbyte_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_short_copy(true, \"arrayof_jshort_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_int_copy(true, \"arrayof_jint_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_long_copy(true, \"arrayof_jlong_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy(true, \"arrayof_oop_disjoint_arraycopy\", false);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy(true, \"oop_disjoint_arraycopy_uninit\", true);\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_byte_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_short_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_int_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_long_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id);\n@@ -3045,6 +3173,6 @@\n-    StubRoutines::_jbyte_arraycopy      = generate_conjoint_byte_copy(false, \"jbyte_arraycopy\");\n-    StubRoutines::_jshort_arraycopy     = generate_conjoint_short_copy(false, \"jshort_arraycopy\");\n-    StubRoutines::_jint_arraycopy       = generate_conjoint_int_copy(false, \"jint_arraycopy\");\n-    StubRoutines::_jlong_arraycopy      = generate_conjoint_long_copy(false, \"jlong_arraycopy\");\n-    StubRoutines::_oop_arraycopy        = generate_conjoint_oop_copy(false, \"oop_arraycopy\", false);\n-    StubRoutines::_oop_arraycopy_uninit = generate_conjoint_oop_copy(false, \"oop_arraycopy_uninit\", true);\n+    StubRoutines::_jbyte_arraycopy      = generate_conjoint_byte_copy(StubGenStubId::jbyte_arraycopy_id);\n+    StubRoutines::_jshort_arraycopy     = generate_conjoint_short_copy(StubGenStubId::jshort_arraycopy_id);\n+    StubRoutines::_jint_arraycopy       = generate_conjoint_int_copy(StubGenStubId::jint_arraycopy_id);\n+    StubRoutines::_jlong_arraycopy      = generate_conjoint_long_copy(StubGenStubId::jlong_arraycopy_id);\n+    StubRoutines::_oop_arraycopy        = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_id);\n+    StubRoutines::_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_uninit_id);\n@@ -3053,6 +3181,6 @@\n-    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_byte_copy(true, \"arrayof_jbyte_arraycopy\");\n-    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_short_copy(true, \"arrayof_jshort_arraycopy\");\n-    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_int_copy(true, \"arrayof_jint_arraycopy\");\n-    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_long_copy(true, \"arrayof_jlong_arraycopy\");\n-    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy(true, \"arrayof_oop_arraycopy\", false);\n-    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy(true, \"arrayof_oop_arraycopy\", true);\n+    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_byte_copy(StubGenStubId::arrayof_jbyte_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_short_copy(StubGenStubId::arrayof_jshort_arraycopy_id);\n+    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_int_copy(StubGenStubId::arrayof_jint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_long_copy(StubGenStubId::arrayof_jlong_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_id);\n@@ -3061,2 +3189,2 @@\n-    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(\"checkcast_arraycopy\", false);\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", true);\n+    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id);\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id);\n@@ -3064,2 +3192,1 @@\n-    StubRoutines::_unsafe_arraycopy  = generate_unsafe_copy(\"unsafe_arraycopy\",\n-                                                            STUB_ENTRY(jbyte_arraycopy()),\n+    StubRoutines::_unsafe_arraycopy  = generate_unsafe_copy(STUB_ENTRY(jbyte_arraycopy()),\n@@ -3069,2 +3196,1 @@\n-    StubRoutines::_generic_arraycopy = generate_generic_copy(\"generic_arraycopy\",\n-                                                             STUB_ENTRY(jbyte_arraycopy()),\n+    StubRoutines::_generic_arraycopy = generate_generic_copy(STUB_ENTRY(jbyte_arraycopy()),\n@@ -3081,6 +3207,6 @@\n-      StubRoutines::_jbyte_fill          = generate_fill(T_BYTE,  false, \"jbyte_fill\");\n-      StubRoutines::_jshort_fill         = generate_fill(T_SHORT, false, \"jshort_fill\");\n-      StubRoutines::_jint_fill           = generate_fill(T_INT,   false, \"jint_fill\");\n-      StubRoutines::_arrayof_jbyte_fill  = generate_fill(T_BYTE,  true, \"arrayof_jbyte_fill\");\n-      StubRoutines::_arrayof_jshort_fill = generate_fill(T_SHORT, true, \"arrayof_jshort_fill\");\n-      StubRoutines::_arrayof_jint_fill   = generate_fill(T_INT,   true, \"arrayof_jint_fill\");\n+      StubRoutines::_jbyte_fill          = generate_fill(StubGenStubId::jbyte_fill_id);\n+      StubRoutines::_jshort_fill         = generate_fill(StubGenStubId::jshort_fill_id);\n+      StubRoutines::_jint_fill           = generate_fill(StubGenStubId::jint_fill_id);\n+      StubRoutines::_arrayof_jbyte_fill  = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n+      StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n+      StubRoutines::_arrayof_jint_fill   = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n@@ -3104,1 +3230,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"multiplyToLen\");\n+    StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3180,1 +3307,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"mulAdd\");\n+    StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3210,1 +3338,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"squareToLen\");\n+    StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3443,1 +3572,12 @@\n-  address generate_CRC32_updateBytes(bool is_crc32c) {\n+  address generate_CRC32_updateBytes(StubGenStubId stub_id) {\n+    bool is_crc32c;\n+    switch (stub_id) {\n+    case updateBytesCRC32_id:\n+      is_crc32c = false;\n+      break;\n+    case updateBytesCRC32C_id:\n+      is_crc32c = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -3445,1 +3585,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", is_crc32c ? \"CRC32C_updateBytes\" : \"CRC32_updateBytes\");\n+    StubCodeMark mark(this, stub_id);\n@@ -3472,1 +3612,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3569,1 +3710,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"base64_decodeBlock\");\n+    StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4157,1 +4299,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"base64_encodeBlock\");\n+    StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4446,2 +4589,3 @@\n-address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+void generate_lookup_secondary_supers_table_stub() {\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4449,1 +4593,0 @@\n-    address start = __ pc();\n@@ -4459,0 +4602,9 @@\n+<<<<<<< HEAD\n+    for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+      __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n+                                       r_array_base, r_array_length, r_array_index,\n+                                       r_bitmap, result, slot);\n+      __ blr();\n+    }\n+=======\n@@ -4463,0 +4615,1 @@\n+>>>>>>> master\n@@ -4464,1 +4617,0 @@\n-    return start;\n@@ -4469,1 +4621,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4486,1 +4639,1 @@\n-  address generate_cont_thaw(const char* label, Continuation::thaw_kind kind) {\n+  address generate_cont_thaw(StubGenStubId stub_id) {\n@@ -4489,2 +4642,3 @@\n-    bool return_barrier = Continuation::is_thaw_return_barrier(kind);\n-    bool return_barrier_exception = Continuation::is_thaw_return_barrier_exception(kind);\n+    Continuation::thaw_kind kind;\n+    bool return_barrier;\n+    bool return_barrier_exception;\n@@ -4492,1 +4646,20 @@\n-    StubCodeMark mark(this, \"StubRoutines\", label);\n+    switch (stub_id) {\n+    case cont_thaw_id:\n+      kind = Continuation::thaw_top;\n+      return_barrier = false;\n+      return_barrier_exception = false;\n+      break;\n+    case cont_returnBarrier_id:\n+      kind = Continuation::thaw_return_barrier;\n+      return_barrier = true;\n+      return_barrier_exception = false;\n+      break;\n+    case cont_returnBarrierExc_id:\n+      kind = Continuation::thaw_return_barrier_exception;\n+      return_barrier = true;\n+      return_barrier_exception = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    StubCodeMark mark(this, stub_id);\n@@ -4581,1 +4754,1 @@\n-    return generate_cont_thaw(\"Cont thaw\", Continuation::thaw_top);\n+    return generate_cont_thaw(StubGenStubId::cont_thaw_id);\n@@ -4587,1 +4760,1 @@\n-    return generate_cont_thaw(\"Cont thaw return barrier\", Continuation::thaw_return_barrier);\n+    return generate_cont_thaw(StubGenStubId::cont_returnBarrier_id);\n@@ -4591,1 +4764,1 @@\n-    return generate_cont_thaw(\"Cont thaw return barrier exception\", Continuation::thaw_return_barrier_exception);\n+    return generate_cont_thaw(StubGenStubId::cont_returnBarrierExc_id);\n@@ -4596,1 +4769,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\",\"Continuation preempt stub\");\n+    StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4631,1 +4805,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+    StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4649,1 +4824,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+    StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4689,1 +4865,1 @@\n-      StubRoutines::_updateBytesCRC32 = generate_CRC32_updateBytes(false);\n+      StubRoutines::_updateBytesCRC32 = generate_CRC32_updateBytes(StubGenStubId::updateBytesCRC32_id);\n@@ -4695,1 +4871,1 @@\n-      StubRoutines::_updateBytesCRC32C = generate_CRC32_updateBytes(true);\n+      StubRoutines::_updateBytesCRC32C = generate_CRC32_updateBytes(StubGenStubId::updateBytesCRC32C_id);\n@@ -4731,4 +4907,1 @@\n-        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n-            = generate_lookup_secondary_supers_table_stub(slot);\n-        }\n+        generate_lookup_secondary_supers_table_stub();\n@@ -4777,2 +4950,2 @@\n-      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(false, \"sha256_implCompress\");\n-      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(true,  \"sha256_implCompressMB\");\n+      StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n@@ -4781,2 +4954,2 @@\n-      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(false, \"sha512_implCompress\");\n-      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(true, \"sha512_implCompressMB\");\n+      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n@@ -4796,3 +4969,3 @@\n-  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    switch(kind) {\n-    case Initial_stubs:\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+    switch(blob_id) {\n+    case initial_id:\n@@ -4801,1 +4974,1 @@\n-     case Continuation_stubs:\n+     case continuation_id:\n@@ -4804,1 +4977,1 @@\n-    case Compiler_stubs:\n+    case compiler_id:\n@@ -4807,1 +4980,1 @@\n-    case Final_stubs:\n+    case final_id:\n@@ -4811,1 +4984,1 @@\n-      fatal(\"unexpected stubs kind: %d\", kind);\n+      fatal(\"unexpected blob id: %d\", blob_id);\n@@ -4817,2 +4990,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n@@ -4820,0 +4993,1 @@\n+\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":382,"deletions":208,"binary":false,"changes":590,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,5 @@\n+\/\/ emit enum used to size per-blob code buffers\n+\n+#define DEFINE_BLOB_SIZE(blob_name, size) \\\n+  _ ## blob_name ## _code_size = size,\n+\n@@ -36,5 +41,1 @@\n-  \/\/ simply increase sizes if too small (assembler will crash if too small)\n-  _initial_stubs_code_size      = 20000,\n-  _continuation_stubs_code_size =  2000,\n-  _compiler_stubs_code_size     = 24000,\n-  _final_stubs_code_size        = 24000\n+  STUBGEN_ARCH_BLOBS_DO(DEFINE_BLOB_SIZE)\n@@ -43,0 +44,2 @@\n+#undef DEFINE_BLOB_SIZE\n+\n","filename":"src\/hotspot\/cpu\/ppc\/stubRoutines_ppc.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_STUBDECLARATIONS_HPP\n+#define CPU_RISCV_STUBDECLARATIONS_HPP\n+\n+#define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n+  do_arch_blob(initial, 10000)                                          \\\n+\n+\n+#define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \\\n+                                           do_arch_blob,                \\\n+                                           do_arch_entry,               \\\n+                                           do_arch_entry_init)          \\\n+  do_arch_blob(continuation, 2000)                                      \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \\\n+                                       do_arch_blob,                    \\\n+                                       do_arch_entry,                   \\\n+                                       do_arch_entry_init)              \\\n+  do_arch_blob(compiler, 45000)                                         \\\n+  do_stub(compiler, compare_long_string_LL)                             \\\n+  do_arch_entry(riscv, compiler, compare_long_string_LL,                \\\n+                compare_long_string_LL, compare_long_string_LL)         \\\n+  do_stub(compiler, compare_long_string_UU)                             \\\n+  do_arch_entry(riscv, compiler, compare_long_string_UU,                \\\n+                compare_long_string_UU, compare_long_string_UU)         \\\n+  do_stub(compiler, compare_long_string_LU)                             \\\n+  do_arch_entry(riscv, compiler, compare_long_string_LU,                \\\n+                compare_long_string_LU, compare_long_string_LU)         \\\n+  do_stub(compiler, compare_long_string_UL)                             \\\n+  do_arch_entry(riscv, compiler, compare_long_string_UL,                \\\n+                compare_long_string_UL, compare_long_string_UL)         \\\n+  do_stub(compiler, string_indexof_linear_ll)                           \\\n+  do_arch_entry(riscv, compiler, string_indexof_linear_ll,              \\\n+                string_indexof_linear_ll, string_indexof_linear_ll)     \\\n+  do_stub(compiler, string_indexof_linear_uu)                           \\\n+  do_arch_entry(riscv, compiler, string_indexof_linear_uu,              \\\n+                string_indexof_linear_uu, string_indexof_linear_uu)     \\\n+  do_stub(compiler, string_indexof_linear_ul)                           \\\n+  do_arch_entry(riscv, compiler, string_indexof_linear_ul,              \\\n+                string_indexof_linear_ul, string_indexof_linear_ul)     \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \\\n+                                    do_arch_blob,                       \\\n+                                    do_arch_entry,                      \\\n+                                    do_arch_entry_init)                 \\\n+  do_arch_blob(final, 20000 ZGC_ONLY(+10000))                           \\\n+  do_stub(final, copy_byte_f)                                           \\\n+  do_arch_entry(riscv, final, copy_byte_f, copy_byte_f,                 \\\n+                copy_byte_f)                                            \\\n+  do_stub(final, copy_byte_b)                                           \\\n+  do_arch_entry(riscv, final, copy_byte_b, copy_byte_b,                 \\\n+                copy_byte_b)                                            \\\n+  do_stub(final, zero_blocks)                                           \\\n+  do_arch_entry(riscv, final, zero_blocks, zero_blocks,                 \\\n+                zero_blocks)                                            \\\n+\n+\n+#endif \/\/ CPU_RISCV_STUBDECLARATIONS_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/stubDeclarations_riscv.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -3,0 +3,3 @@\n+<<<<<<< HEAD\n+ * Copyright (c) 2014, 2025, Red Hat Inc. All rights reserved.\n+=======\n@@ -4,0 +7,1 @@\n+>>>>>>> master\n@@ -210,1 +214,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"call_stub\");\n+    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -478,1 +483,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"catch_exception\");\n+    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -530,1 +536,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"forward exception\");\n+    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -616,1 +623,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"verify_oop\");\n+    StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -677,1 +685,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"zero_blocks\");\n+    StubGenStubId stub_id = StubGenStubId::zero_blocks_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -729,2 +738,16 @@\n-  void generate_copy_longs(Label &start, Register s, Register d, Register count,\n-                           copy_direction direction) {\n+  void generate_copy_longs(StubGenStubId stub_id, Label &start,\n+                           Register s, Register d, Register count) {\n+    BasicType type;\n+    copy_direction direction;\n+    switch (stub_id) {\n+    case copy_byte_f_id:\n+      direction = copy_forwards;\n+      type = T_BYTE;\n+      break;\n+    case copy_byte_b_id:\n+      direction = copy_backwards;\n+      type = T_BYTE;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -744,7 +767,1 @@\n-    const char* stub_name = nullptr;\n-    if (direction == copy_forwards) {\n-      stub_name = \"forward_copy_longs\";\n-    } else {\n-      stub_name = \"backward_copy_longs\";\n-    }\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1085,4 +1102,5 @@\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   is_oop  - true => oop array, so generate store check code\n-  \/\/   name    - stub name string\n+  \/\/   stub_id - is used to name the stub and identify all details of\n+  \/\/             how to perform the copy.\n+  \/\/\n+  \/\/   entry - is assigned to the stub's post push entry point unless\n+  \/\/           it is null\n@@ -1099,3 +1117,3 @@\n-  \/\/ Side Effects:\n-  \/\/   disjoint_int_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_int_oop_copy().\n+  \/\/ Side Effects: entry is set to the (post push) entry point so it\n+  \/\/               can be used by the corresponding conjoint copy\n+  \/\/               method\n@@ -1103,2 +1121,82 @@\n-  address generate_disjoint_copy(size_t size, bool aligned, bool is_oop, address* entry,\n-                                 const char* name, bool dest_uninitialized = false) {\n+  address generate_disjoint_copy(StubGenStubId stub_id, address* entry) {\n+    size_t size;\n+    bool aligned;\n+    bool is_oop;\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case jbyte_disjoint_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jbyte_disjoint_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jshort_disjoint_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jshort_disjoint_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jint_disjoint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jint_disjoint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jlong_disjoint_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case arrayof_jlong_disjoint_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case arrayof_jlong_disjoint_arraycopy_id:\n+      size = sizeof(jlong);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_disjoint_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_disjoint_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+    }\n+\n@@ -1108,1 +1206,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1157,4 +1255,9 @@\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   is_oop  - true => oop array, so generate store check code\n-  \/\/   name    - stub name string\n+  \/\/   stub_id - is used to name the stub and identify all details of\n+  \/\/             how to perform the copy.\n+  \/\/\n+  \/\/   nooverlap_target - identifes the (post push) entry for the\n+  \/\/             corresponding disjoint copy routine which can be\n+  \/\/             jumped to if the ranges do not actually overlap\n+  \/\/\n+  \/\/   entry - is assigned to the stub's post push entry point unless\n+  \/\/           it is null\n@@ -1171,3 +1274,5 @@\n-  address generate_conjoint_copy(size_t size, bool aligned, bool is_oop, address nooverlap_target,\n-                                 address* entry, const char* name,\n-                                 bool dest_uninitialized = false) {\n+  \/\/ Side Effects:\n+  \/\/   entry is set to the no-overlap entry point so it can be used by\n+  \/\/   some other conjoint copy method\n+  \/\/\n+  address generate_conjoint_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n@@ -1176,1 +1281,81 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    int size;\n+    bool aligned;\n+    bool is_oop;\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case jbyte_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jbyte_arraycopy_id:\n+      size = sizeof(jbyte);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jshort_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jshort_arraycopy_id:\n+      size = sizeof(jshort);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = false;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jint_arraycopy_id:\n+      size = sizeof(jint);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case jlong_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case arrayof_jlong_disjoint_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case arrayof_jlong_arraycopy_id:\n+      size = sizeof(jlong);\n+      aligned = true;\n+      is_oop = false;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_arraycopy_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_arraycopy_uninit_id:\n+      size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+      aligned = !UseCompressedOops;\n+      is_oop = true;\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    StubCodeMark mark(this, stub_id);\n@@ -1230,221 +1415,0 @@\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n-  \/\/ we let the hardware handle it.  The one to eight bytes within words,\n-  \/\/ dwords or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_byte_copy_entry is set to the no-overlap entry point  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n-  \/\/ we let the hardware handle it.  The one to eight bytes within words,\n-  \/\/ dwords or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_byte_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_byte_copy().\n-  \/\/\n-  address generate_disjoint_byte_copy(bool aligned, address* entry, const char* name) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jbyte), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n-  \/\/ we let the hardware handle it.  The one to eight bytes within words,\n-  \/\/ dwords or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  address generate_conjoint_byte_copy(bool aligned, address nooverlap_target,\n-                                      address* entry, const char* name) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jbyte), aligned, not_oop, nooverlap_target, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4- or 2-byte boundaries, we\n-  \/\/ let the hardware handle it.  The two or four words within dwords\n-  \/\/ or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_short_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_short_copy().\n-  \/\/\n-  address generate_disjoint_short_copy(bool aligned,\n-                                       address* entry, const char* name) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jshort), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4- or 2-byte boundaries, we\n-  \/\/ let the hardware handle it.  The two or four words within dwords\n-  \/\/ or qwords that span cache line boundaries will still be loaded\n-  \/\/ and stored atomically.\n-  \/\/\n-  address generate_conjoint_short_copy(bool aligned, address nooverlap_target,\n-                                       address* entry, const char* name) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jshort), aligned, not_oop, nooverlap_target, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-byte boundaries, we let\n-  \/\/ the hardware handle it.  The two dwords within qwords that span\n-  \/\/ cache line boundaries will still be loaded and stored atomically.\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_int_copy_entry is set to the no-overlap entry point\n-  \/\/   used by generate_conjoint_int_oop_copy().\n-  \/\/\n-  address generate_disjoint_int_copy(bool aligned, address* entry,\n-                                     const char* name, bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jint), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-  \/\/\n-  \/\/ If 'from' and\/or 'to' are aligned on 4-byte boundaries, we let\n-  \/\/ the hardware handle it.  The two dwords within qwords that span\n-  \/\/ cache line boundaries will still be loaded and stored atomically.\n-  \/\/\n-  address generate_conjoint_int_copy(bool aligned, address nooverlap_target,\n-                                     address* entry, const char* name,\n-                                     bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jint), aligned, not_oop, nooverlap_target, entry, name);\n-  }\n-\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_oop_copy_entry or disjoint_long_copy_entry is set to the\n-  \/\/   no-overlap entry point used by generate_conjoint_long_oop_copy().\n-  \/\/\n-  address generate_disjoint_long_copy(bool aligned, address* entry,\n-                                      const char* name, bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_disjoint_copy(sizeof (jlong), aligned, not_oop, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  address generate_conjoint_long_copy(bool aligned,\n-                                      address nooverlap_target, address* entry,\n-                                      const char* name, bool dest_uninitialized = false) {\n-    const bool not_oop = false;\n-    return generate_conjoint_copy(sizeof (jlong), aligned, not_oop, nooverlap_target, entry, name);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  \/\/ Side Effects:\n-  \/\/   disjoint_oop_copy_entry or disjoint_long_copy_entry is set to the\n-  \/\/   no-overlap entry point used by generate_conjoint_long_oop_copy().\n-  \/\/\n-  address generate_disjoint_oop_copy(bool aligned, address* entry,\n-                                     const char* name, bool dest_uninitialized) {\n-    const bool is_oop = true;\n-    const size_t size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n-    return generate_disjoint_copy(size, aligned, is_oop, entry, name, dest_uninitialized);\n-  }\n-\n-  \/\/ Arguments:\n-  \/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-  \/\/             ignored\n-  \/\/   name    - stub name string\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source array address\n-  \/\/   c_rarg1   - destination array address\n-  \/\/   c_rarg2   - element count, treated as size_t, can be zero\n-  \/\/\n-  address generate_conjoint_oop_copy(bool aligned,\n-                                     address nooverlap_target, address* entry,\n-                                     const char* name, bool dest_uninitialized) {\n-    const bool is_oop = true;\n-    const size_t size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n-    return generate_conjoint_copy(size, aligned, is_oop, nooverlap_target, entry,\n-                                  name, dest_uninitialized);\n-  }\n-\n@@ -1487,2 +1451,13 @@\n-  address generate_checkcast_copy(const char* name, address* entry,\n-                                  bool dest_uninitialized = false) {\n+  address generate_checkcast_copy(StubGenStubId stub_id, address* entry) {\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case checkcast_arraycopy_id:\n+      dest_uninitialized = false;\n+      break;\n+    case checkcast_arraycopy_uninit_id:\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -1521,1 +1496,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1678,2 +1653,1 @@\n-  address generate_unsafe_copy(const char* name,\n-                               address byte_copy_entry,\n+  address generate_unsafe_copy(address byte_copy_entry,\n@@ -1689,1 +1663,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1734,2 +1709,1 @@\n-  address generate_generic_copy(const char* name,\n-                                address byte_copy_entry, address short_copy_entry,\n+  address generate_generic_copy(address byte_copy_entry, address short_copy_entry,\n@@ -1756,1 +1730,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2012,1 +1987,33 @@\n-  address generate_fill(BasicType t, bool aligned, const char* name) {\n+  address generate_fill(StubGenStubId stub_id) {\n+    BasicType t;\n+    bool aligned;\n+\n+    switch (stub_id) {\n+    case jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = false;\n+      break;\n+    case jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = false;\n+      break;\n+    case jint_fill_id:\n+      t = T_INT;\n+      aligned = false;\n+      break;\n+    case arrayof_jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = true;\n+      break;\n+    case arrayof_jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = true;\n+      break;\n+    case arrayof_jint_fill_id:\n+      t = T_INT;\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    };\n+\n@@ -2014,1 +2021,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2186,2 +2193,2 @@\n-    generate_copy_longs(copy_f, c_rarg0, c_rarg1, t1, copy_forwards);\n-    generate_copy_longs(copy_b, c_rarg0, c_rarg1, t1, copy_backwards);\n+    generate_copy_longs(StubGenStubId::copy_byte_f_id, copy_f, c_rarg0, c_rarg1, t1);\n+    generate_copy_longs(StubGenStubId::copy_byte_b_id, copy_b, c_rarg0, c_rarg1, t1);\n@@ -2193,9 +2200,4 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy          = generate_disjoint_byte_copy(false, &entry,\n-                                                                                   \"jbyte_disjoint_arraycopy\");\n-    StubRoutines::_jbyte_arraycopy                   = generate_conjoint_byte_copy(false, entry,\n-                                                                                   &entry_jbyte_arraycopy,\n-                                                                                   \"jbyte_arraycopy\");\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_disjoint_byte_copy(true, &entry,\n-                                                                                   \"arrayof_jbyte_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jbyte_arraycopy           = generate_conjoint_byte_copy(true, entry, nullptr,\n-                                                                                   \"arrayof_jbyte_arraycopy\");\n+    StubRoutines::_jbyte_disjoint_arraycopy          = generate_disjoint_copy(StubGenStubId::jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jbyte_arraycopy                   = generate_conjoint_copy(StubGenStubId::jbyte_arraycopy_id, entry, &entry_jbyte_arraycopy);\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_disjoint_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jbyte_arraycopy           = generate_conjoint_copy(StubGenStubId::arrayof_jbyte_arraycopy_id, entry, nullptr);\n@@ -2205,9 +2207,4 @@\n-    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_short_copy(false, &entry,\n-                                                                                    \"jshort_disjoint_arraycopy\");\n-    StubRoutines::_jshort_arraycopy                  = generate_conjoint_short_copy(false, entry,\n-                                                                                    &entry_jshort_arraycopy,\n-                                                                                    \"jshort_arraycopy\");\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_short_copy(true, &entry,\n-                                                                                    \"arrayof_jshort_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_short_copy(true, entry, nullptr,\n-                                                                                    \"arrayof_jshort_arraycopy\");\n+    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubGenStubId::jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubGenStubId::jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jshort_arraycopy_id, entry, nullptr);\n@@ -2217,4 +2214,2 @@\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_disjoint_int_copy(true, &entry,\n-                                                                                  \"arrayof_jint_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jint_arraycopy            = generate_conjoint_int_copy(true, entry, &entry_jint_arraycopy,\n-                                                                                  \"arrayof_jint_arraycopy\");\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_disjoint_copy(StubGenStubId::arrayof_jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jint_arraycopy            = generate_conjoint_copy(StubGenStubId::arrayof_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2223,5 +2218,2 @@\n-    StubRoutines::_jint_disjoint_arraycopy           = generate_disjoint_int_copy(false, &entry,\n-                                                                                  \"jint_disjoint_arraycopy\");\n-    StubRoutines::_jint_arraycopy                    = generate_conjoint_int_copy(false, entry,\n-                                                                                  &entry_jint_arraycopy,\n-                                                                                  \"jint_arraycopy\");\n+    StubRoutines::_jint_disjoint_arraycopy           = generate_disjoint_copy(StubGenStubId::jint_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubGenStubId::jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2231,6 +2223,4 @@\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy  = generate_disjoint_long_copy(true, &entry,\n-                                                                                   \"arrayof_jlong_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jlong_arraycopy           = generate_conjoint_long_copy(true, entry, &entry_jlong_arraycopy,\n-                                                                                   \"arrayof_jlong_arraycopy\");\n-    StubRoutines::_jlong_disjoint_arraycopy          = StubRoutines::_arrayof_jlong_disjoint_arraycopy;\n-    StubRoutines::_jlong_arraycopy                   = StubRoutines::_arrayof_jlong_arraycopy;\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubGenStubId::arrayof_jlong_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubGenStubId::arrayof_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n+    StubRoutines::_jlong_disjoint_arraycopy         = StubRoutines::_arrayof_jlong_disjoint_arraycopy;\n+    StubRoutines::_jlong_arraycopy                  = StubRoutines::_arrayof_jlong_arraycopy;\n@@ -2239,19 +2229,9 @@\n-    {\n-      \/\/ With compressed oops we need unaligned versions; notice that\n-      \/\/ we overwrite entry_oop_arraycopy.\n-      bool aligned = !UseCompressedOops;\n-\n-      StubRoutines::_arrayof_oop_disjoint_arraycopy\n-        = generate_disjoint_oop_copy(aligned, &entry, \"arrayof_oop_disjoint_arraycopy\",\n-                                     \/*dest_uninitialized*\/false);\n-      StubRoutines::_arrayof_oop_arraycopy\n-        = generate_conjoint_oop_copy(aligned, entry, &entry_oop_arraycopy, \"arrayof_oop_arraycopy\",\n-                                     \/*dest_uninitialized*\/false);\n-      \/\/ Aligned versions without pre-barriers\n-      StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit\n-        = generate_disjoint_oop_copy(aligned, &entry, \"arrayof_oop_disjoint_arraycopy_uninit\",\n-                                     \/*dest_uninitialized*\/true);\n-      StubRoutines::_arrayof_oop_arraycopy_uninit\n-        = generate_conjoint_oop_copy(aligned, entry, nullptr, \"arrayof_oop_arraycopy_uninit\",\n-                                     \/*dest_uninitialized*\/true);\n-    }\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy\n+      = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_arrayof_oop_arraycopy\n+      = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+    \/\/ Aligned versions without pre-barriers\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit\n+      = generate_disjoint_copy(StubGenStubId::arrayof_oop_disjoint_arraycopy_uninit_id, &entry);\n+    StubRoutines::_arrayof_oop_arraycopy_uninit\n+      = generate_conjoint_copy(StubGenStubId::arrayof_oop_arraycopy_uninit_id, entry, nullptr);\n@@ -2264,3 +2244,2 @@\n-    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(\"checkcast_arraycopy\", &entry_checkcast_arraycopy);\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", nullptr,\n-                                                                        \/*dest_uninitialized*\/true);\n+    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id, nullptr);\n@@ -2269,2 +2248,1 @@\n-    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(\"unsafe_arraycopy\",\n-                                                              entry_jbyte_arraycopy,\n+    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(entry_jbyte_arraycopy,\n@@ -2275,2 +2253,1 @@\n-    StubRoutines::_generic_arraycopy   = generate_generic_copy(\"generic_arraycopy\",\n-                                                               entry_jbyte_arraycopy,\n+    StubRoutines::_generic_arraycopy   = generate_generic_copy(entry_jbyte_arraycopy,\n@@ -2283,6 +2260,6 @@\n-    StubRoutines::_jbyte_fill = generate_fill(T_BYTE, false, \"jbyte_fill\");\n-    StubRoutines::_jshort_fill = generate_fill(T_SHORT, false, \"jshort_fill\");\n-    StubRoutines::_jint_fill = generate_fill(T_INT, false, \"jint_fill\");\n-    StubRoutines::_arrayof_jbyte_fill = generate_fill(T_BYTE, true, \"arrayof_jbyte_fill\");\n-    StubRoutines::_arrayof_jshort_fill = generate_fill(T_SHORT, true, \"arrayof_jshort_fill\");\n-    StubRoutines::_arrayof_jint_fill = generate_fill(T_INT, true, \"arrayof_jint_fill\");\n+    StubRoutines::_jbyte_fill = generate_fill(StubGenStubId::jbyte_fill_id);\n+    StubRoutines::_jshort_fill = generate_fill(StubGenStubId::jshort_fill_id);\n+    StubRoutines::_jint_fill = generate_fill(StubGenStubId::jint_fill_id);\n+    StubRoutines::_arrayof_jbyte_fill = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n+    StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n+    StubRoutines::_arrayof_jint_fill = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n@@ -2324,1 +2301,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_encryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2402,1 +2380,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_decryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2502,1 +2481,12 @@\n-  address generate_compare_long_string_different_encoding(bool isLU) {\n+  address generate_compare_long_string_different_encoding(StubGenStubId stub_id) {\n+    bool isLU;\n+    switch (stub_id) {\n+    case compare_long_string_LU_id:\n+      isLU = true;\n+      break;\n+    case compare_long_string_UL_id:\n+      isLU = false;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    };\n@@ -2504,1 +2494,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", isLU ? \"compare_long_string_different_encoding LU\" : \"compare_long_string_different_encoding UL\");\n+    StubCodeMark mark(this, stub_id);\n@@ -2598,1 +2588,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2668,1 +2659,12 @@\n-  address generate_compare_long_string_same_encoding(bool isLL) {\n+  address generate_compare_long_string_same_encoding(StubGenStubId stub_id) {\n+    bool isLL;\n+    switch (stub_id) {\n+    case compare_long_string_LL_id:\n+      isLL = true;\n+      break;\n+    case compare_long_string_UU_id:\n+      isLL = false;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    };\n@@ -2670,2 +2672,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", isLL ?\n-                      \"compare_long_string_same_encoding LL\" : \"compare_long_string_same_encoding UU\");\n+    StubCodeMark mark(this, stub_id);\n@@ -2757,4 +2758,4 @@\n-    StubRoutines::riscv::_compare_long_string_LL = generate_compare_long_string_same_encoding(true);\n-    StubRoutines::riscv::_compare_long_string_UU = generate_compare_long_string_same_encoding(false);\n-    StubRoutines::riscv::_compare_long_string_LU = generate_compare_long_string_different_encoding(true);\n-    StubRoutines::riscv::_compare_long_string_UL = generate_compare_long_string_different_encoding(false);\n+    StubRoutines::riscv::_compare_long_string_LL = generate_compare_long_string_same_encoding(StubGenStubId::compare_long_string_LL_id);\n+    StubRoutines::riscv::_compare_long_string_UU = generate_compare_long_string_same_encoding(StubGenStubId::compare_long_string_UU_id);\n+    StubRoutines::riscv::_compare_long_string_LU = generate_compare_long_string_different_encoding(StubGenStubId::compare_long_string_LU_id);\n+    StubRoutines::riscv::_compare_long_string_UL = generate_compare_long_string_different_encoding(StubGenStubId::compare_long_string_UL_id);\n@@ -2768,1 +2769,1 @@\n-  address generate_string_indexof_linear(bool needle_isL, bool haystack_isL)\n+  address generate_string_indexof_linear(StubGenStubId stub_id)\n@@ -2770,3 +2771,19 @@\n-    const char* stubName = needle_isL\n-           ? (haystack_isL ? \"indexof_linear_ll\" : \"indexof_linear_ul\")\n-           : \"indexof_linear_uu\";\n+    bool needle_isL;\n+    bool haystack_isL;\n+    switch (stub_id) {\n+    case string_indexof_linear_ll_id:\n+      needle_isL = true;\n+      haystack_isL = true;\n+      break;\n+    case string_indexof_linear_ul_id:\n+      needle_isL = true;\n+      haystack_isL = false;\n+      break;\n+    case string_indexof_linear_uu_id:\n+      needle_isL = false;\n+      haystack_isL = false;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    };\n+\n@@ -2774,1 +2791,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stubName);\n+    StubCodeMark mark(this, stub_id);\n@@ -3001,3 +3018,3 @@\n-    StubRoutines::riscv::_string_indexof_linear_ll = generate_string_indexof_linear(true, true);\n-    StubRoutines::riscv::_string_indexof_linear_uu = generate_string_indexof_linear(false, false);\n-    StubRoutines::riscv::_string_indexof_linear_ul = generate_string_indexof_linear(true, false);\n+    StubRoutines::riscv::_string_indexof_linear_ll = generate_string_indexof_linear(StubGenStubId::string_indexof_linear_ll_id);\n+    StubRoutines::riscv::_string_indexof_linear_uu = generate_string_indexof_linear(StubGenStubId::string_indexof_linear_uu_id);\n+    StubRoutines::riscv::_string_indexof_linear_ul = generate_string_indexof_linear(StubGenStubId::string_indexof_linear_ul_id);\n@@ -3007,2 +3024,3 @@\n-  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+  void generate_lookup_secondary_supers_table_stub() {\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3010,1 +3028,0 @@\n-    address start = __ pc();\n@@ -3020,0 +3037,12 @@\n+<<<<<<< HEAD\n+    for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+      Label L_success;\n+      __ enter();\n+      __ lookup_secondary_supers_table(r_sub_klass, r_super_klass, result,\n+                                       r_array_base, r_array_length, r_array_index,\n+                                       r_bitmap, slot, \/*stub_is_near*\/true);\n+      __ leave();\n+      __ ret();\n+    }\n+=======\n@@ -3029,0 +3058,1 @@\n+>>>>>>> master\n@@ -3033,1 +3063,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3054,1 +3085,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"mulAdd\");\n+    StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3087,1 +3119,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"multiplyToLen\");\n+    StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3117,1 +3150,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"squareToLen\");\n+    StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3157,1 +3191,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"bigIntegerLeftShiftWorker\");\n+    StubGenStubId stub_id = StubGenStubId::bigIntegerLeftShiftWorker_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3208,1 +3243,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"bigIntegerRightShiftWorker\");\n+    StubGenStubId stub_id = StubGenStubId::bigIntegerRightShiftWorker_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4034,1 +4070,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"Cont thaw\");\n+    StubGenStubId stub_id = StubGenStubId::cont_thaw_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4044,1 +4081,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier\");\n+    StubGenStubId stub_id = StubGenStubId::cont_returnBarrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4055,1 +4093,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier exception handler\");\n+    StubGenStubId stub_id = StubGenStubId::cont_returnBarrierExc_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4065,1 +4104,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\",\"Continuation preempt stub\");\n+    StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -4102,2 +4142,2 @@\n-      address generate_sha256_implCompress(bool multi_block) {\n-        return generate_sha2_implCompress(Assembler::e32, multi_block);\n+      address generate_sha256_implCompress(StubGenStubId stub_id) {\n+        return generate_sha2_implCompress(Assembler::e32, stub_id);\n@@ -4105,2 +4145,2 @@\n-      address generate_sha512_implCompress(bool multi_block) {\n-        return generate_sha2_implCompress(Assembler::e64, multi_block);\n+      address generate_sha512_implCompress(StubGenStubId stub_id) {\n+        return generate_sha2_implCompress(Assembler::e64, stub_id);\n@@ -4231,9 +4271,0 @@\n-    const char* stub_name(Assembler::SEW vset_sew, bool multi_block) {\n-      if (vset_sew == Assembler::e32 && !multi_block) return \"sha256_implCompress\";\n-      if (vset_sew == Assembler::e32 &&  multi_block) return \"sha256_implCompressMB\";\n-      if (vset_sew == Assembler::e64 && !multi_block) return \"sha512_implCompress\";\n-      if (vset_sew == Assembler::e64 &&  multi_block) return \"sha512_implCompressMB\";\n-      ShouldNotReachHere();\n-      return \"bad name lookup\";\n-    }\n-\n@@ -4248,1 +4279,1 @@\n-    address generate_sha2_implCompress(Assembler::SEW vset_sew, bool multi_block) {\n+    address generate_sha2_implCompress(Assembler::SEW vset_sew, StubGenStubId stub_id) {\n@@ -4298,0 +4329,21 @@\n+      bool multi_block;\n+      switch (stub_id) {\n+      case sha256_implCompress_id:\n+        assert (vset_sew == Assembler::e32, \"wrong macroassembler for stub\");\n+        multi_block = false;\n+        break;\n+      case sha256_implCompressMB_id:\n+        assert (vset_sew == Assembler::e32, \"wrong macroassembler for stub\");\n+        multi_block = true;\n+        break;\n+      case sha512_implCompress_id:\n+        assert (vset_sew == Assembler::e64, \"wrong macroassembler for stub\");\n+        multi_block = false;\n+        break;\n+      case sha512_implCompressMB_id:\n+        assert (vset_sew == Assembler::e64, \"wrong macroassembler for stub\");\n+        multi_block = true;\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+      };\n@@ -4299,1 +4351,1 @@\n-      StubCodeMark mark(_cgen, \"StubRoutines\", stub_name(vset_sew, multi_block));\n+      StubCodeMark mark(_cgen, stub_id);\n@@ -4646,1 +4698,1 @@\n-  address generate_md5_implCompress(bool multi_block, const char *name) {\n+  address generate_md5_implCompress(StubGenStubId stub_id) {\n@@ -4648,1 +4700,12 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    bool multi_block;\n+    switch (stub_id) {\n+    case md5_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case md5_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    };\n+    StubCodeMark mark(this, stub_id);\n@@ -4902,1 +4965,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+    StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5201,1 +5265,12 @@\n-  address generate_sha1_implCompress(bool multi_block, const char *name) {\n+  address generate_sha1_implCompress(StubGenStubId stub_id) {\n+      bool multi_block;\n+      switch (stub_id) {\n+      case sha1_implCompress_id:\n+        multi_block = false;\n+        break;\n+      case sha1_implCompressMB_id:\n+        multi_block = true;\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+      };\n@@ -5203,1 +5278,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -5413,1 +5488,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"encodeBlock\");\n+    StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5669,1 +5745,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"decodeBlock\");\n+    StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -5913,1 +5990,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesAdler32\");\n+    StubGenStubId stub_id = StubGenStubId::updateBytesAdler32_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6171,1 +6249,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"poly1305_processBlocks\");\n+    StubGenStubId stub_id = StubGenStubId::poly1305_processBlocks_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6360,1 +6439,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32\");\n+    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6384,1 +6464,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+    StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6401,1 +6482,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+    StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -6476,4 +6558,1 @@\n-        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n-            = generate_lookup_secondary_supers_table_stub(slot);\n-        }\n+        generate_lookup_secondary_supers_table_stub();\n@@ -6505,1 +6584,2 @@\n-      StubCodeMark mark(this, \"StubRoutines\", \"montgomeryMultiply\");\n+      StubGenStubId stub_id = StubGenStubId::montgomeryMultiply_id;\n+      StubCodeMark mark(this, stub_id);\n@@ -6511,1 +6591,2 @@\n-      StubCodeMark mark(this, \"StubRoutines\", \"montgomerySquare\");\n+      StubGenStubId stub_id = StubGenStubId::montgomerySquare_id;\n+      StubCodeMark mark(this, stub_id);\n@@ -6532,2 +6613,2 @@\n-      StubRoutines::_sha256_implCompress   = sha2.generate_sha256_implCompress(false);\n-      StubRoutines::_sha256_implCompressMB = sha2.generate_sha256_implCompress(true);\n+      StubRoutines::_sha256_implCompress   = sha2.generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = sha2.generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n@@ -6538,2 +6619,2 @@\n-      StubRoutines::_sha512_implCompress   = sha2.generate_sha512_implCompress(false);\n-      StubRoutines::_sha512_implCompressMB = sha2.generate_sha512_implCompress(true);\n+      StubRoutines::_sha512_implCompress   = sha2.generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = sha2.generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n@@ -6543,2 +6624,2 @@\n-      StubRoutines::_md5_implCompress   = generate_md5_implCompress(false, \"md5_implCompress\");\n-      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(true,  \"md5_implCompressMB\");\n+      StubRoutines::_md5_implCompress   = generate_md5_implCompress(StubGenStubId::md5_implCompress_id);\n+      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(StubGenStubId::md5_implCompressMB_id);\n@@ -6552,2 +6633,2 @@\n-      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(false, \"sha1_implCompress\");\n-      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(true, \"sha1_implCompressMB\");\n+      StubRoutines::_sha1_implCompress     = generate_sha1_implCompress(StubGenStubId::sha1_implCompress_id);\n+      StubRoutines::_sha1_implCompressMB   = generate_sha1_implCompress(StubGenStubId::sha1_implCompressMB_id);\n@@ -6575,3 +6656,3 @@\n-  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    switch(kind) {\n-    case Initial_stubs:\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+    switch(blob_id) {\n+    case initial_id:\n@@ -6580,1 +6661,1 @@\n-     case Continuation_stubs:\n+     case continuation_id:\n@@ -6583,1 +6664,1 @@\n-    case Compiler_stubs:\n+    case compiler_id:\n@@ -6586,1 +6667,1 @@\n-    case Final_stubs:\n+    case final_id:\n@@ -6590,1 +6671,1 @@\n-      fatal(\"unexpected stubs kind: %d\", kind);\n+      fatal(\"unexpected blob id: %d\", blob_id);\n@@ -6596,2 +6677,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":495,"deletions":414,"binary":false,"changes":909,"status":"modified"},{"patch":"@@ -2,0 +2,4 @@\n+<<<<<<< HEAD\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n+=======\n@@ -4,0 +8,1 @@\n+>>>>>>> master\n@@ -36,8 +41,13 @@\n-address StubRoutines::riscv::_zero_blocks = nullptr;\n-address StubRoutines::riscv::_compare_long_string_LL = nullptr;\n-address StubRoutines::riscv::_compare_long_string_UU = nullptr;\n-address StubRoutines::riscv::_compare_long_string_LU = nullptr;\n-address StubRoutines::riscv::_compare_long_string_UL = nullptr;\n-address StubRoutines::riscv::_string_indexof_linear_ll = nullptr;\n-address StubRoutines::riscv::_string_indexof_linear_uu = nullptr;\n-address StubRoutines::riscv::_string_indexof_linear_ul = nullptr;\n+\n+\/\/ define fields for arch-specific entries\n+\n+#define DEFINE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = nullptr;\n+\n+#define DEFINE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = CAST_FROM_FN_PTR(address, init_function);\n+\n+STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY, DEFINE_ARCH_ENTRY_INIT)\n+\n+#undef DEFINE_ARCH_ENTRY_INIT\n+#undef DEFINE_ARCH_ENTRY\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.cpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+\/\/ emit enum used to size per-blob code buffers\n+\n+#define DEFINE_BLOB_SIZE(blob_name, size) \\\n+  _ ## blob_name ## _code_size = size,\n+\n@@ -39,5 +44,1 @@\n-  \/\/ simply increase sizes if too small (assembler will crash if too small)\n-  _initial_stubs_code_size      = 10000,\n-  _continuation_stubs_code_size =  2000,\n-  _compiler_stubs_code_size     = 45000,\n-  _final_stubs_code_size        = 20000 ZGC_ONLY(+10000)\n+  STUBGEN_ARCH_BLOBS_DO(DEFINE_BLOB_SIZE)\n@@ -46,0 +47,2 @@\n+#undef DEFINE_BLOB_SIZE\n+\n@@ -48,0 +51,3 @@\n+#if INCLUDE_JVMCI\n+  friend class JVMCIVMStructs;\n+#endif\n@@ -49,2 +55,1 @@\n- private:\n-  static address _zero_blocks;\n+  \/\/ declare fields for arch-specific entries\n@@ -52,7 +57,2 @@\n-  static address _compare_long_string_LL;\n-  static address _compare_long_string_LU;\n-  static address _compare_long_string_UL;\n-  static address _compare_long_string_UU;\n-  static address _string_indexof_linear_ll;\n-  static address _string_indexof_linear_uu;\n-  static address _string_indexof_linear_ul;\n+#define DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address STUB_FIELD_NAME(field_name) ;\n@@ -60,1 +60,2 @@\n-  static bool _completed;\n+#define DECLARE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name)\n@@ -62,1 +63,2 @@\n- public:\n+private:\n+  STUBGEN_ARCH_ENTRIES_DO(DECLARE_ARCH_ENTRY, DECLARE_ARCH_ENTRY_INIT)\n@@ -64,3 +66,2 @@\n-  static address zero_blocks() {\n-    return _zero_blocks;\n-  }\n+#undef DECLARE_ARCH_ENTRY_INIT\n+#undef DECLARE_ARCH_ENTRY\n@@ -68,3 +69,1 @@\n-  static address compare_long_string_LL() {\n-    return _compare_long_string_LL;\n-  }\n+  static bool _completed;\n@@ -72,3 +71,1 @@\n-  static address compare_long_string_LU() {\n-    return _compare_long_string_LU;\n-  }\n+ public:\n@@ -76,3 +73,1 @@\n-  static address compare_long_string_UL() {\n-    return _compare_long_string_UL;\n-  }\n+  \/\/ declare getters for arch-specific entries\n@@ -80,3 +75,2 @@\n-  static address compare_long_string_UU() {\n-    return _compare_long_string_UU;\n-  }\n+#define DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address getter_name() { return STUB_FIELD_NAME(field_name) ; }\n@@ -84,3 +78,2 @@\n-  static address string_indexof_linear_ul() {\n-    return _string_indexof_linear_ul;\n-  }\n+#define DEFINE_ARCH_ENTRY_GETTER_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name)\n@@ -88,3 +81,1 @@\n-  static address string_indexof_linear_ll() {\n-    return _string_indexof_linear_ll;\n-  }\n+  STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY_GETTER, DEFINE_ARCH_ENTRY_GETTER_INIT)\n@@ -92,3 +83,2 @@\n-  static address string_indexof_linear_uu() {\n-    return _string_indexof_linear_uu;\n-  }\n+#undef DEFINE_ARCH_ENTRY_GETTER_INIT\n+#undef DEFINE_ARCH_ENTRY_GETTER\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.hpp","additions":30,"deletions":40,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_S390_STUBDECLARATIONS_HPP\n+#define CPU_S390_STUBDECLARATIONS_HPP\n+\n+#define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n+  do_arch_blob(initial, 20000)                                          \\\n+\n+\n+#define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \\\n+                                           do_arch_blob,                \\\n+                                           do_arch_entry,               \\\n+                                           do_arch_entry_init)          \\\n+  do_arch_blob(continuation, 2000)                                      \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \\\n+                                       do_arch_blob,                    \\\n+                                       do_arch_entry,                   \\\n+                                       do_arch_entry_init)              \\\n+  do_arch_blob(compiler, 20000 )                                        \\\n+  do_stub(compiler, partial_subtype_check)                              \\\n+  do_arch_entry(zarch, compiler, partial_subtype_check,                 \\\n+                partial_subtype_check, partial_subtype_check)           \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \\\n+                                    do_arch_blob,                       \\\n+                                    do_arch_entry,                      \\\n+                                    do_arch_entry_init)                 \\\n+  do_arch_blob(final, 20000)                                            \\\n+\n+\n+#endif \/\/ CPU_S390_STUBDECLARATIONS_HPP\n","filename":"src\/hotspot\/cpu\/s390\/stubDeclarations_s390.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -121,1 +121,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"call_stub\");\n+    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -461,1 +462,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"catch_exception\");\n+    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -512,1 +514,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"forward_exception\");\n+    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -592,1 +595,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"partial_subtype_check\");\n+    StubGenStubId stub_id = StubGenStubId::partial_subtype_check_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -624,2 +628,3 @@\n-  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+  void generate_lookup_secondary_supers_table_stub() {\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -635,7 +640,5 @@\n-    address start = __ pc();\n-\n-    __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n-                                           r_array_base, r_array_length, r_array_index,\n-                                           r_bitmap, r_result, super_klass_index);\n-\n-    __ z_br(Z_R14);\n+    for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+      __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n+                                             r_array_base, r_array_length, r_array_index,\n+                                             r_bitmap, r_result, slot);\n@@ -643,1 +646,2 @@\n-    return start;\n+      __ z_br(Z_R14);\n+    }\n@@ -648,1 +652,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1263,37 +1268,40 @@\n-  \/\/ Generate stub for disjoint byte copy. If \"aligned\" is true, the\n-  \/\/ \"from\" and \"to\" addresses are assumed to be heapword aligned.\n-  address generate_disjoint_byte_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-\n-    \/\/ This is the zarch specific stub generator for byte array copy.\n-    \/\/ Refer to generate_disjoint_copy for a list of prereqs and features:\n-    unsigned int start_off = __ offset();  \/\/ Remember stub start address (is rtn value).\n-    generate_disjoint_copy(aligned, 1, false, false);\n-    return __ addr_at(start_off);\n-  }\n-\n-\n-  address generate_disjoint_short_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-    \/\/ This is the zarch specific stub generator for short array copy.\n-    \/\/ Refer to generate_disjoint_copy for a list of prereqs and features:\n-    unsigned int start_off = __ offset();  \/\/ Remember stub start address (is rtn value).\n-    generate_disjoint_copy(aligned, 2, false, false);\n-    return __ addr_at(start_off);\n-  }\n-\n-\n-  address generate_disjoint_int_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-    \/\/ This is the zarch specific stub generator for int array copy.\n-    \/\/ Refer to generate_disjoint_copy for a list of prereqs and features:\n-    unsigned int start_off = __ offset();  \/\/ Remember stub start address (is rtn value).\n-    generate_disjoint_copy(aligned, 4, false, false);\n-    return __ addr_at(start_off);\n-  }\n-\n-\n-  address generate_disjoint_long_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-    \/\/ This is the zarch specific stub generator for long array copy.\n-    \/\/ Refer to generate_disjoint_copy for a list of prereqs and features:\n+  address generate_disjoint_nonoop_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    int element_size;\n+    switch (stub_id) {\n+    case jbyte_disjoint_arraycopy_id:\n+      aligned = false;\n+      element_size = 1;\n+      break;\n+    case arrayof_jbyte_disjoint_arraycopy_id:\n+      aligned = true;\n+      element_size = 1;\n+      break;\n+    case jshort_disjoint_arraycopy_id:\n+      aligned = false;\n+      element_size = 2;\n+      break;\n+    case arrayof_jshort_disjoint_arraycopy_id:\n+      aligned = true;\n+      element_size = 2;\n+      break;\n+    case jint_disjoint_arraycopy_id:\n+      aligned = false;\n+      element_size = 4;\n+      break;\n+    case arrayof_jint_disjoint_arraycopy_id:\n+      aligned = true;\n+      element_size = 4;\n+      break;\n+    case jlong_disjoint_arraycopy_id:\n+      aligned = false;\n+      element_size = 8;\n+      break;\n+    case arrayof_jlong_disjoint_arraycopy_id:\n+      aligned = true;\n+      element_size = 8;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    StubCodeMark mark(this, stub_id);\n@@ -1301,1 +1309,1 @@\n-    generate_disjoint_copy(aligned, 8, false, false);\n+    generate_disjoint_copy(aligned, element_size, false, false);\n@@ -1305,3 +1313,24 @@\n-\n-  address generate_disjoint_oop_copy(bool aligned, const char * name, bool dest_uninitialized) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_disjoint_oop_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    bool dest_uninitialized;\n+    switch (stub_id) {\n+    case oop_disjoint_arraycopy_id:\n+      aligned = false;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_id:\n+      aligned = true;\n+      dest_uninitialized = false;\n+      break;\n+    case oop_disjoint_arraycopy_uninit_id:\n+      aligned = false;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+      aligned = true;\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    StubCodeMark mark(this, stub_id);\n@@ -1331,57 +1360,52 @@\n-\n-  address generate_conjoint_byte_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-    \/\/ This is the zarch specific stub generator for overlapping byte array copy.\n-    \/\/ Refer to generate_conjoint_copy for a list of prereqs and features:\n-    unsigned int   start_off = __ offset();  \/\/ Remember stub start address (is rtn value).\n-    address nooverlap_target = aligned ? StubRoutines::arrayof_jbyte_disjoint_arraycopy()\n-                                       : StubRoutines::jbyte_disjoint_arraycopy();\n-\n-    array_overlap_test(nooverlap_target, 0); \/\/ Branch away to nooverlap_target if disjoint.\n-    generate_conjoint_copy(aligned, 1, false);\n-\n-    return __ addr_at(start_off);\n-  }\n-\n-\n-  address generate_conjoint_short_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-    \/\/ This is the zarch specific stub generator for overlapping short array copy.\n-    \/\/ Refer to generate_conjoint_copy for a list of prereqs and features:\n-    unsigned int   start_off = __ offset();  \/\/ Remember stub start address (is rtn value).\n-    address nooverlap_target = aligned ? StubRoutines::arrayof_jshort_disjoint_arraycopy()\n-                                       : StubRoutines::jshort_disjoint_arraycopy();\n-\n-    array_overlap_test(nooverlap_target, 1); \/\/ Branch away to nooverlap_target if disjoint.\n-    generate_conjoint_copy(aligned, 2, false);\n-\n-    return __ addr_at(start_off);\n-  }\n-\n-  address generate_conjoint_int_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-    \/\/ This is the zarch specific stub generator for overlapping int array copy.\n-    \/\/ Refer to generate_conjoint_copy for a list of prereqs and features:\n-\n-    unsigned int   start_off = __ offset();  \/\/ Remember stub start address (is rtn value).\n-    address nooverlap_target = aligned ? StubRoutines::arrayof_jint_disjoint_arraycopy()\n-                                       : StubRoutines::jint_disjoint_arraycopy();\n-\n-    array_overlap_test(nooverlap_target, 2); \/\/ Branch away to nooverlap_target if disjoint.\n-    generate_conjoint_copy(aligned, 4, false);\n-\n-    return __ addr_at(start_off);\n-  }\n-\n-  address generate_conjoint_long_copy(bool aligned, const char * name) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-    \/\/ This is the zarch specific stub generator for overlapping long array copy.\n-    \/\/ Refer to generate_conjoint_copy for a list of prereqs and features:\n-\n-    unsigned int start_off   = __ offset();  \/\/ Remember stub start address (is rtn value).\n-    address nooverlap_target = aligned ? StubRoutines::arrayof_jlong_disjoint_arraycopy()\n-                                       : StubRoutines::jlong_disjoint_arraycopy();\n-\n-    array_overlap_test(nooverlap_target, 3); \/\/ Branch away to nooverlap_target if disjoint.\n-    generate_conjoint_copy(aligned, 8, false);\n-\n+  address generate_conjoint_nonoop_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    int shift; \/\/ i.e. log2(element size)\n+    address nooverlap_target;\n+    switch (stub_id) {\n+    case jbyte_arraycopy_id:\n+      aligned = false;\n+      shift = 0;\n+      nooverlap_target = StubRoutines::jbyte_disjoint_arraycopy();\n+      break;\n+    case arrayof_jbyte_arraycopy_id:\n+      aligned = true;\n+      shift = 0;\n+      nooverlap_target = StubRoutines::arrayof_jbyte_disjoint_arraycopy();\n+      break;\n+    case jshort_arraycopy_id:\n+      aligned = false;\n+      shift = 1;\n+      nooverlap_target = StubRoutines::jshort_disjoint_arraycopy();\n+      break;\n+    case arrayof_jshort_arraycopy_id:\n+      aligned = true;\n+      shift = 1;\n+      nooverlap_target = StubRoutines::arrayof_jshort_disjoint_arraycopy();\n+      break;\n+    case jint_arraycopy_id:\n+      aligned = false;\n+      shift = 2;\n+      nooverlap_target = StubRoutines::jint_disjoint_arraycopy();\n+      break;\n+    case arrayof_jint_arraycopy_id:\n+      aligned = true;\n+      shift = 2;\n+      nooverlap_target = StubRoutines::arrayof_jint_disjoint_arraycopy();\n+      break;\n+    case jlong_arraycopy_id:\n+      aligned = false;\n+      shift = 3;\n+      nooverlap_target = StubRoutines::jlong_disjoint_arraycopy();\n+      break;\n+    case arrayof_jlong_arraycopy_id:\n+      aligned = true;\n+      shift = 3;\n+      nooverlap_target = StubRoutines::arrayof_jlong_disjoint_arraycopy();\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    StubCodeMark mark(this, stub_id);\n+    unsigned int start_off = __ offset();  \/\/ Remember stub start address (is rtn value).\n+    array_overlap_test(nooverlap_target, shift); \/\/ Branch away to nooverlap_target if disjoint.\n+    generate_conjoint_copy(aligned, 1 << shift, false);\n@@ -1391,2 +1415,29 @@\n-  address generate_conjoint_oop_copy(bool aligned, const char * name, bool dest_uninitialized) {\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+  address generate_conjoint_oop_copy(StubGenStubId stub_id) {\n+    bool aligned;\n+    bool dest_uninitialized;\n+    address nooverlap_target;\n+    switch (stub_id) {\n+    case oop_arraycopy_id:\n+      aligned = false;\n+      dest_uninitialized = false;\n+      nooverlap_target = StubRoutines::oop_disjoint_arraycopy(dest_uninitialized);\n+      break;\n+    case arrayof_oop_arraycopy_id:\n+      aligned = true;\n+      dest_uninitialized = false;\n+      nooverlap_target = StubRoutines::arrayof_oop_disjoint_arraycopy(dest_uninitialized);\n+      break;\n+    case oop_arraycopy_uninit_id:\n+      aligned = false;\n+      dest_uninitialized = true;\n+      nooverlap_target = StubRoutines::oop_disjoint_arraycopy(dest_uninitialized);\n+      break;\n+    case arrayof_oop_arraycopy_uninit_id:\n+      aligned = true;\n+      dest_uninitialized = true;\n+      nooverlap_target = StubRoutines::arrayof_oop_disjoint_arraycopy(dest_uninitialized);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    StubCodeMark mark(this, stub_id);\n@@ -1399,3 +1450,0 @@\n-    address nooverlap_target = aligned ? StubRoutines::arrayof_oop_disjoint_arraycopy(dest_uninitialized)\n-                                       : StubRoutines::oop_disjoint_arraycopy(dest_uninitialized);\n-\n@@ -1428,27 +1476,27 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy      = generate_disjoint_byte_copy (false, \"jbyte_disjoint_arraycopy\");\n-    StubRoutines::_jshort_disjoint_arraycopy     = generate_disjoint_short_copy(false, \"jshort_disjoint_arraycopy\");\n-    StubRoutines::_jint_disjoint_arraycopy       = generate_disjoint_int_copy  (false, \"jint_disjoint_arraycopy\");\n-    StubRoutines::_jlong_disjoint_arraycopy      = generate_disjoint_long_copy (false, \"jlong_disjoint_arraycopy\");\n-    StubRoutines::_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (false, \"oop_disjoint_arraycopy\", false);\n-    StubRoutines::_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (false, \"oop_disjoint_arraycopy_uninit\", true);\n-\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_byte_copy (true, \"arrayof_jbyte_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_short_copy(true, \"arrayof_jshort_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_int_copy  (true, \"arrayof_jint_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_long_copy (true, \"arrayof_jlong_disjoint_arraycopy\");\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (true, \"arrayof_oop_disjoint_arraycopy\", false);\n-    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (true, \"arrayof_oop_disjoint_arraycopy_uninit\", true);\n-\n-    StubRoutines::_jbyte_arraycopy           = generate_conjoint_byte_copy (false, \"jbyte_arraycopy\");\n-    StubRoutines::_jshort_arraycopy          = generate_conjoint_short_copy(false, \"jshort_arraycopy\");\n-    StubRoutines::_jint_arraycopy            = generate_conjoint_int_copy  (false, \"jint_arraycopy\");\n-    StubRoutines::_jlong_arraycopy           = generate_conjoint_long_copy (false, \"jlong_arraycopy\");\n-    StubRoutines::_oop_arraycopy             = generate_conjoint_oop_copy  (false, \"oop_arraycopy\", false);\n-    StubRoutines::_oop_arraycopy_uninit      = generate_conjoint_oop_copy  (false, \"oop_arraycopy_uninit\", true);\n-\n-    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_byte_copy (true, \"arrayof_jbyte_arraycopy\");\n-    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_short_copy(true, \"arrayof_jshort_arraycopy\");\n-    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_int_copy  (true, \"arrayof_jint_arraycopy\");\n-    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_long_copy (true, \"arrayof_jlong_arraycopy\");\n-    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy  (true, \"arrayof_oop_arraycopy\", false);\n-    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy  (true, \"arrayof_oop_arraycopy_uninit\", true);\n+    StubRoutines::_jbyte_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_jshort_disjoint_arraycopy     = generate_disjoint_nonoop_copy(StubGenStubId::jshort_disjoint_arraycopy_id);\n+    StubRoutines::_jint_disjoint_arraycopy       = generate_disjoint_nonoop_copy  (StubGenStubId::jint_disjoint_arraycopy_id);\n+    StubRoutines::_jlong_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::jlong_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (StubGenStubId::oop_disjoint_arraycopy_id);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (StubGenStubId::oop_disjoint_arraycopy_uninit_id);\n+\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_nonoop_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_nonoop_copy  (StubGenStubId::arrayof_jint_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_nonoop_copy (StubGenStubId::arrayof_jlong_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy  (StubGenStubId::arrayof_oop_disjoint_arraycopy_id);\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy  (StubGenStubId::arrayof_oop_disjoint_arraycopy_uninit_id);\n+\n+    StubRoutines::_jbyte_arraycopy           = generate_conjoint_nonoop_copy(StubGenStubId::jbyte_arraycopy_id);\n+    StubRoutines::_jshort_arraycopy          = generate_conjoint_nonoop_copy(StubGenStubId::jshort_arraycopy_id);\n+    StubRoutines::_jint_arraycopy            = generate_conjoint_nonoop_copy(StubGenStubId::jint_arraycopy_id);\n+    StubRoutines::_jlong_arraycopy           = generate_conjoint_nonoop_copy(StubGenStubId::jlong_arraycopy_id);\n+    StubRoutines::_oop_arraycopy             = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_id);\n+    StubRoutines::_oop_arraycopy_uninit      = generate_conjoint_oop_copy(StubGenStubId::oop_arraycopy_uninit_id);\n+\n+    StubRoutines::_arrayof_jbyte_arraycopy      = generate_conjoint_nonoop_copy(StubGenStubId::arrayof_jbyte_arraycopy_id);\n+    StubRoutines::_arrayof_jshort_arraycopy     = generate_conjoint_nonoop_copy(StubGenStubId::arrayof_jshort_arraycopy_id);\n+    StubRoutines::_arrayof_jint_arraycopy       = generate_conjoint_nonoop_copy (StubGenStubId::arrayof_jint_arraycopy_id);\n+    StubRoutines::_arrayof_jlong_arraycopy      = generate_conjoint_nonoop_copy(StubGenStubId::arrayof_jlong_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy        = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_id);\n+    StubRoutines::_arrayof_oop_arraycopy_uninit = generate_conjoint_oop_copy(StubGenStubId::arrayof_oop_arraycopy_uninit_id);\n@@ -1736,1 +1784,1 @@\n-  address generate_AES_encryptBlock(const char* name) {\n+  address generate_AES_encryptBlock() {\n@@ -1738,1 +1786,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1747,1 +1796,1 @@\n-  address generate_AES_decryptBlock(const char* name) {\n+  address generate_AES_decryptBlock() {\n@@ -1749,1 +1798,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1807,1 +1857,1 @@\n-  address generate_cipherBlockChaining_AES_encrypt(const char* name) {\n+  address generate_cipherBlockChaining_AES_encrypt() {\n@@ -1809,1 +1859,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1818,1 +1869,1 @@\n-  address generate_cipherBlockChaining_AES_decrypt(const char* name) {\n+  address generate_cipherBlockChaining_AES_decrypt() {\n@@ -1820,1 +1871,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2524,1 +2576,1 @@\n-  address generate_counterMode_AESCrypt(const char* name) {\n+  address generate_counterMode_AESCrypt() {\n@@ -2526,1 +2578,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2539,1 +2592,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"ghash_processBlocks\");\n+    StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2616,1 +2670,12 @@\n-  address generate_SHA1_stub(bool multiBlock, const char* name) {\n+  address generate_SHA1_stub(StubGenStubId stub_id) {\n+    bool multiBlock;\n+    switch (stub_id) {\n+    case sha1_implCompress_id:\n+      multiBlock = false;\n+      break;\n+    case sha1_implCompressMB_id:\n+      multiBlock = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -2618,1 +2683,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2698,1 +2763,12 @@\n-  address generate_SHA256_stub(bool multiBlock, const char* name) {\n+  address generate_SHA256_stub(StubGenStubId stub_id) {\n+    bool multiBlock;\n+    switch (stub_id) {\n+    case sha256_implCompress_id:\n+      multiBlock = false;\n+      break;\n+    case sha256_implCompressMB_id:\n+      multiBlock = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -2700,1 +2776,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2778,1 +2854,12 @@\n-  address generate_SHA512_stub(bool multiBlock, const char* name) {\n+  address generate_SHA512_stub(StubGenStubId stub_id) {\n+    bool multiBlock;\n+    switch (stub_id) {\n+    case sha512_implCompress_id:\n+      multiBlock = false;\n+      break;\n+    case sha512_implCompressMB_id:\n+      multiBlock = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n@@ -2780,1 +2867,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -2870,1 +2957,1 @@\n-  void generate_CRC_updateBytes(const char* name, Register table, bool invertCRC) {\n+  void generate_CRC_updateBytes(Register table, bool invertCRC) {\n@@ -2901,1 +2988,1 @@\n-  address generate_CRC32_updateBytes(const char* name) {\n+  address generate_CRC32_updateBytes() {\n@@ -2903,1 +2990,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id =  StubGenStubId::updateBytesCRC32_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2906,1 +2994,1 @@\n-    assert(UseCRC32Intrinsics, \"should not generate this stub (%s) with CRC32 intrinsics disabled\", name);\n+    assert(UseCRC32Intrinsics, \"should not generate this stub (%s) with CRC32 intrinsics disabled\", StubRoutines::get_stub_name(stub_id));\n@@ -2912,1 +3000,1 @@\n-    generate_CRC_updateBytes(name, table, true);\n+    generate_CRC_updateBytes(table, true);\n@@ -2920,1 +3008,1 @@\n-  address generate_CRC32C_updateBytes(const char* name) {\n+  address generate_CRC32C_updateBytes() {\n@@ -2922,1 +3010,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id =  StubGenStubId::updateBytesCRC32C_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2925,1 +3014,1 @@\n-    assert(UseCRC32CIntrinsics, \"should not generate this stub (%s) with CRC32C intrinsics disabled\", name);\n+    assert(UseCRC32CIntrinsics, \"should not generate this stub (%s) with CRC32C intrinsics disabled\", StubRoutines::get_stub_name(stub_id));\n@@ -2931,1 +3020,1 @@\n-    generate_CRC_updateBytes(name, table, false);\n+    generate_CRC_updateBytes(table, false);\n@@ -2946,1 +3035,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"multiplyToLen\");\n+    StubGenStubId stub_id =  StubGenStubId::multiplyToLen_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2977,1 +3067,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+    StubGenStubId stub_id =  StubGenStubId::method_entry_barrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3042,1 +3133,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+    StubGenStubId stub_id =  StubGenStubId::upcall_stub_exception_handler_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3059,1 +3151,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+    StubGenStubId stub_id =  StubGenStubId::upcall_stub_load_target_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3096,1 +3189,1 @@\n-      StubRoutines::_updateBytesCRC32  = generate_CRC32_updateBytes(\"CRC32_updateBytes\");\n+      StubRoutines::_updateBytesCRC32  = generate_CRC32_updateBytes();\n@@ -3101,1 +3194,1 @@\n-      StubRoutines::_updateBytesCRC32C = generate_CRC32C_updateBytes(\"CRC32C_updateBytes\");\n+      StubRoutines::_updateBytesCRC32C = generate_CRC32C_updateBytes();\n@@ -3120,2 +3213,0 @@\n-    StubRoutines::zarch::_partial_subtype_check            = generate_partial_subtype_check();\n-\n@@ -3134,0 +3225,9 @@\n+#ifdef COMPILER2\n+    if (UseSecondarySupersTable) {\n+      StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+      if (!InlineSecondarySupersTest) {\n+        generate_lookup_secondary_supers_table_stub();\n+      }\n+    }\n+#endif \/\/ COMPILER2\n+\n@@ -3139,0 +3239,3 @@\n+\n+    StubRoutines::zarch::_partial_subtype_check            = generate_partial_subtype_check();\n+\n@@ -3143,4 +3246,4 @@\n-        StubRoutines::_aescrypt_encryptBlock = generate_AES_encryptBlock(\"AES_encryptBlock\");\n-        StubRoutines::_aescrypt_decryptBlock = generate_AES_decryptBlock(\"AES_decryptBlock\");\n-        StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_AES_encrypt(\"AES_encryptBlock_chaining\");\n-        StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_AES_decrypt(\"AES_decryptBlock_chaining\");\n+        StubRoutines::_aescrypt_encryptBlock = generate_AES_encryptBlock();\n+        StubRoutines::_aescrypt_decryptBlock = generate_AES_decryptBlock();\n+        StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_AES_encrypt();\n+        StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_AES_decrypt();\n@@ -3156,1 +3259,1 @@\n-        StubRoutines::_counterMode_AESCrypt = generate_counterMode_AESCrypt(\"counterMode_AESCrypt\");\n+        StubRoutines::_counterMode_AESCrypt = generate_counterMode_AESCrypt();\n@@ -3171,2 +3274,2 @@\n-      StubRoutines::_sha1_implCompress     = generate_SHA1_stub(false,   \"SHA1_singleBlock\");\n-      StubRoutines::_sha1_implCompressMB   = generate_SHA1_stub(true,    \"SHA1_multiBlock\");\n+      StubRoutines::_sha1_implCompress     = generate_SHA1_stub(StubGenStubId::sha1_implCompress_id);\n+      StubRoutines::_sha1_implCompressMB   = generate_SHA1_stub(StubGenStubId::sha1_implCompressMB_id);\n@@ -3175,2 +3278,2 @@\n-      StubRoutines::_sha256_implCompress   = generate_SHA256_stub(false, \"SHA256_singleBlock\");\n-      StubRoutines::_sha256_implCompressMB = generate_SHA256_stub(true,  \"SHA256_multiBlock\");\n+      StubRoutines::_sha256_implCompress   = generate_SHA256_stub(StubGenStubId::sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = generate_SHA256_stub(StubGenStubId::sha256_implCompressMB_id);\n@@ -3179,2 +3282,2 @@\n-      StubRoutines::_sha512_implCompress   = generate_SHA512_stub(false, \"SHA512_singleBlock\");\n-      StubRoutines::_sha512_implCompressMB = generate_SHA512_stub(true,  \"SHA512_multiBlock\");\n+      StubRoutines::_sha512_implCompress   = generate_SHA512_stub(StubGenStubId::sha512_implCompress_id);\n+      StubRoutines::_sha512_implCompressMB = generate_SHA512_stub(StubGenStubId::sha512_implCompressMB_id);\n@@ -3195,8 +3298,0 @@\n-    if (UseSecondarySupersTable) {\n-      StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n-      if (!InlineSecondarySupersTest) {\n-        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-          StubRoutines::_lookup_secondary_supers_table_stubs[slot] = generate_lookup_secondary_supers_table_stub(slot);\n-        }\n-      }\n-    }\n@@ -3208,3 +3303,3 @@\n-  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    switch(kind) {\n-    case Initial_stubs:\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+    switch(blob_id) {\n+    case initial_id:\n@@ -3213,1 +3308,1 @@\n-     case Continuation_stubs:\n+     case continuation_id:\n@@ -3216,1 +3311,1 @@\n-    case Compiler_stubs:\n+    case compiler_id:\n@@ -3219,1 +3314,1 @@\n-    case Final_stubs:\n+    case final_id:\n@@ -3223,1 +3318,1 @@\n-      fatal(\"unexpected stubs kind: %d\", kind);\n+      fatal(\"unexpected blob id: %d\", blob_id);\n@@ -3262,2 +3357,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":302,"deletions":207,"binary":false,"changes":509,"status":"modified"},{"patch":"@@ -2,0 +2,3 @@\n+<<<<<<< HEAD\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+=======\n@@ -3,0 +6,1 @@\n+>>>>>>> master\n@@ -35,1 +39,12 @@\n-address StubRoutines::zarch::_partial_subtype_check = nullptr;\n+\/\/ define fields for arch-specific entries\n+\n+#define DEFINE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = nullptr;\n+\n+#define DEFINE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = CAST_FROM_FN_PTR(address, init_function);\n+\n+STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY, DEFINE_ARCH_ENTRY_INIT)\n+\n+#undef DEFINE_ARCH_ENTRY_INIT\n+#undef DEFINE_ARCH_ENTRY\n","filename":"src\/hotspot\/cpu\/s390\/stubRoutines_s390.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,6 +34,7 @@\n-enum { \/\/ Platform dependent constants.\n-  \/\/ simply increase sizes if too small (assembler will crash if too small)\n-  _initial_stubs_code_size      = 20000,\n-  _continuation_stubs_code_size =  2000,\n-  _compiler_stubs_code_size     = 20000,\n-  _final_stubs_code_size        = 20000\n+\/\/ emit enum used to size per-blob code buffers\n+\n+#define DEFINE_BLOB_SIZE(blob_name, size) \\\n+  _ ## blob_name ## _code_size = size,\n+\n+enum platform_dependent_constants {\n+  STUBGEN_ARCH_BLOBS_DO(DEFINE_BLOB_SIZE)\n@@ -42,0 +43,2 @@\n+#undef DEFINE_BLOB_SIZE\n+\n@@ -72,0 +75,14 @@\n+  \/\/ declare fields for arch-specific entries\n+\n+#define DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address STUB_FIELD_NAME(field_name) ;\n+\n+#define DECLARE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name)\n+\n+private:\n+  STUBGEN_ARCH_ENTRIES_DO(DECLARE_ARCH_ENTRY, DECLARE_ARCH_ENTRY_INIT)\n+\n+#undef DECLARE_ARCH_ENTRY_INIT\n+#undef DECLARE_ARCH_ENTRY\n+\n@@ -73,0 +90,1 @@\n+\n@@ -75,1 +93,0 @@\n-  static address _partial_subtype_check;\n@@ -84,0 +101,14 @@\n+\n+  \/\/ declare getters for arch-specific entries\n+\n+#define DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address getter_name() { return STUB_FIELD_NAME(field_name) ; }\n+\n+#define DEFINE_ARCH_ENTRY_GETTER_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name)\n+\n+  STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY_GETTER, DEFINE_ARCH_ENTRY_GETTER_INIT)\n+\n+#undef DEFINE_ARCH_ENTRY_GETTER_INIT\n+#undef DEFINE_ARCH_ENTRY_GETTER\n+\n@@ -95,2 +126,0 @@\n-  static address partial_subtype_check()                  { return _partial_subtype_check; }\n-\n","filename":"src\/hotspot\/cpu\/s390\/stubRoutines_s390.hpp","additions":39,"deletions":10,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -202,1 +202,0 @@\n-  StubCodeMark mark(stubgen, \"StubRoutines\", \"stringIndexOf\");\n@@ -209,0 +208,2 @@\n+  StubGenStubId stub_id = (isLL ?  StubGenStubId::string_indexof_linear_ll_id : (isUL ? StubGenStubId::string_indexof_linear_ul_id : StubGenStubId::string_indexof_linear_uu_id));\n+  StubCodeMark mark(stubgen, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/c2_stubGenerator_x86_64_string.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -9139,2 +9139,2 @@\n-    const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;\n-    const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr+1);\n+    const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::crc32c_table_addr();\n+    const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 1);\n@@ -9142,2 +9142,2 @@\n-    const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);\n-    const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);\n+    const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 2);\n+    const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 3);\n@@ -9145,2 +9145,2 @@\n-    const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);\n-    const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);\n+    const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 4);\n+    const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 5);\n@@ -9219,2 +9219,2 @@\n-    const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;\n-    const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 1);\n+    const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::crc32c_table_addr();\n+    const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 1);\n@@ -9222,2 +9222,2 @@\n-    const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);\n-    const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);\n+    const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 2);\n+    const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 3);\n@@ -9225,2 +9225,2 @@\n-    const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);\n-    const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);\n+    const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 4);\n+    const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::crc32c_table_addr() + 5);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,262 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_X86_STUBDECLARATIONS_HPP\n+#define CPU_X86_STUBDECLARATIONS_HPP\n+\n+#define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n+  do_arch_blob(initial, 20000 WINDOWS_ONLY(+1000))                      \\\n+  do_stub(initial, verify_mxcsr)                                        \\\n+  do_arch_entry(x86, initial, verify_mxcsr, verify_mxcsr_entry,         \\\n+                verify_mxcsr_entry)                                     \\\n+  LP64_ONLY(                                                            \\\n+    do_stub(initial, get_previous_sp)                                   \\\n+    do_arch_entry(x86, initial, get_previous_sp,                        \\\n+                  get_previous_sp_entry,                                \\\n+                  get_previous_sp_entry)                                \\\n+    do_stub(initial, f2i_fixup)                                         \\\n+    do_arch_entry(x86, initial, f2i_fixup, f2i_fixup, f2i_fixup)        \\\n+    do_stub(initial, f2l_fixup)                                         \\\n+    do_arch_entry(x86, initial, f2l_fixup, f2l_fixup, f2l_fixup)        \\\n+    do_stub(initial, d2i_fixup)                                         \\\n+    do_arch_entry(x86, initial, d2i_fixup, d2i_fixup, d2i_fixup)        \\\n+    do_stub(initial, d2l_fixup)                                         \\\n+    do_arch_entry(x86, initial, d2l_fixup, d2l_fixup, d2l_fixup)        \\\n+    do_stub(initial, float_sign_mask)                                   \\\n+    do_arch_entry(x86, initial, float_sign_mask, float_sign_mask,       \\\n+                  float_sign_mask)                                      \\\n+    do_stub(initial, float_sign_flip)                                   \\\n+    do_arch_entry(x86, initial, float_sign_flip, float_sign_flip,       \\\n+                  float_sign_flip)                                      \\\n+    do_stub(initial, double_sign_mask)                                  \\\n+    do_arch_entry(x86, initial, double_sign_mask, double_sign_mask,     \\\n+                  double_sign_mask)                                     \\\n+    do_stub(initial, double_sign_flip)                                  \\\n+    do_arch_entry(x86, initial, double_sign_flip, double_sign_flip,     \\\n+                  double_sign_flip)                                     \\\n+  )                                                                     \\\n+  NOT_LP64(                                                             \\\n+    do_stub(initial, verify_fpu_cntrl_word)                             \\\n+    do_arch_entry(x86, initial, verify_fpu_cntrl_word,                  \\\n+                  verify_fpu_cntrl_wrd_entry,                           \\\n+                  verify_fpu_cntrl_wrd_entry)                           \\\n+    do_stub(initial, d2i_wrapper)                                       \\\n+    do_arch_entry(x86, initial, d2i_wrapper, d2i_wrapper,               \\\n+                  d2i_wrapper)                                          \\\n+    do_stub(initial, d2l_wrapper)                                       \\\n+    do_arch_entry(x86, initial, d2l_wrapper, d2l_wrapper,               \\\n+                  d2l_wrapper)                                          \\\n+  )                                                                     \\\n+\n+\n+#define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \\\n+                                           do_arch_blob,                \\\n+                                           do_arch_entry,               \\\n+                                           do_arch_entry_init)          \\\n+  do_arch_blob(continuation, 1000 LP64_ONLY(+2000))                     \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \\\n+                                       do_arch_blob,                    \\\n+                                       do_arch_entry,                   \\\n+                                       do_arch_entry_init)              \\\n+  do_arch_blob(compiler, 20000 LP64_ONLY(+60000) WINDOWS_ONLY(+2000))   \\\n+  do_stub(compiler, vector_float_sign_mask)                             \\\n+  do_arch_entry(x86, compiler, vector_float_sign_mask,                  \\\n+                vector_float_sign_mask, vector_float_sign_mask)         \\\n+  do_stub(compiler, vector_float_sign_flip)                             \\\n+  do_arch_entry(x86, compiler, vector_float_sign_flip,                  \\\n+                vector_float_sign_flip, vector_float_sign_flip)         \\\n+  do_stub(compiler, vector_double_sign_mask)                            \\\n+  do_arch_entry(x86, compiler, vector_double_sign_mask,                 \\\n+                vector_double_sign_mask, vector_double_sign_mask)       \\\n+  do_stub(compiler, vector_double_sign_flip)                            \\\n+  do_arch_entry(x86, compiler, vector_double_sign_flip,                 \\\n+                vector_double_sign_flip, vector_double_sign_flip)       \\\n+  do_stub(compiler, vector_all_bits_set)                                \\\n+  do_arch_entry(x86, compiler, vector_all_bits_set,                     \\\n+                vector_all_bits_set, vector_all_bits_set)               \\\n+  do_stub(compiler, vector_int_mask_cmp_bits)                           \\\n+  do_arch_entry(x86, compiler, vector_int_mask_cmp_bits,                \\\n+                vector_int_mask_cmp_bits, vector_int_mask_cmp_bits)     \\\n+  do_stub(compiler, vector_short_to_byte_mask)                          \\\n+  do_arch_entry(x86, compiler, vector_short_to_byte_mask,               \\\n+                vector_short_to_byte_mask, vector_short_to_byte_mask)   \\\n+  do_stub(compiler, vector_byte_perm_mask)                              \\\n+  do_arch_entry(x86, compiler,vector_byte_perm_mask,                    \\\n+                vector_byte_perm_mask, vector_byte_perm_mask)           \\\n+  do_stub(compiler, vector_int_to_byte_mask)                            \\\n+  do_arch_entry(x86, compiler, vector_int_to_byte_mask,                 \\\n+                vector_int_to_byte_mask, vector_int_to_byte_mask)       \\\n+  do_stub(compiler, vector_int_to_short_mask)                           \\\n+  do_arch_entry(x86, compiler, vector_int_to_short_mask,                \\\n+                vector_int_to_short_mask, vector_int_to_short_mask)     \\\n+  do_stub(compiler, vector_32_bit_mask)                                 \\\n+  do_arch_entry(x86, compiler, vector_32_bit_mask,                      \\\n+                vector_32_bit_mask, vector_32_bit_mask)                 \\\n+  do_stub(compiler, vector_64_bit_mask)                                 \\\n+  do_arch_entry(x86, compiler, vector_64_bit_mask,                      \\\n+                vector_64_bit_mask, vector_64_bit_mask)                 \\\n+  do_stub(compiler, vector_byte_shuffle_mask)                           \\\n+  do_arch_entry(x86, compiler, vector_int_shuffle_mask,                 \\\n+                vector_byte_shuffle_mask, vector_byte_shuffle_mask)     \\\n+  do_stub(compiler, vector_short_shuffle_mask)                          \\\n+  do_arch_entry(x86, compiler, vector_int_shuffle_mask,                 \\\n+                vector_short_shuffle_mask, vector_short_shuffle_mask)   \\\n+  do_stub(compiler, vector_int_shuffle_mask)                            \\\n+  do_arch_entry(x86, compiler, vector_int_shuffle_mask,                 \\\n+                vector_int_shuffle_mask, vector_int_shuffle_mask)       \\\n+  do_stub(compiler, vector_long_shuffle_mask)                           \\\n+  do_arch_entry(x86, compiler, vector_long_shuffle_mask,                \\\n+                vector_long_shuffle_mask, vector_long_shuffle_mask)     \\\n+  do_stub(compiler, vector_long_sign_mask)                              \\\n+  do_arch_entry(x86, compiler, vector_long_sign_mask,                   \\\n+                vector_long_sign_mask, vector_long_sign_mask)           \\\n+  do_stub(compiler, vector_iota_indices)                                \\\n+  do_arch_entry(x86, compiler, vector_iota_indices,                     \\\n+                vector_iota_indices, vector_iota_indices)               \\\n+  do_stub(compiler, vector_count_leading_zeros_lut)                     \\\n+  do_arch_entry(x86, compiler, vector_count_leading_zeros_lut,          \\\n+                vector_count_leading_zeros_lut,                         \\\n+                vector_count_leading_zeros_lut)                         \\\n+  do_stub(compiler, vector_reverse_bit_lut)                             \\\n+  do_arch_entry(x86, compiler, vector_reverse_bit_lut,                  \\\n+                vector_reverse_bit_lut, vector_reverse_bit_lut)         \\\n+  do_stub(compiler, vector_reverse_byte_perm_mask_short)                \\\n+  do_arch_entry(x86, compiler, vector_reverse_byte_perm_mask_short,     \\\n+                vector_reverse_byte_perm_mask_short,                    \\\n+                vector_reverse_byte_perm_mask_short)                    \\\n+  do_stub(compiler, vector_reverse_byte_perm_mask_int)                  \\\n+  do_arch_entry(x86, compiler, vector_reverse_byte_perm_mask_int,       \\\n+                vector_reverse_byte_perm_mask_int,                      \\\n+                vector_reverse_byte_perm_mask_int)                      \\\n+  do_stub(compiler, vector_reverse_byte_perm_mask_long)                 \\\n+  do_arch_entry(x86, compiler, vector_reverse_byte_perm_mask_long,      \\\n+                vector_reverse_byte_perm_mask_long,                     \\\n+                vector_reverse_byte_perm_mask_long)                     \\\n+  do_stub(compiler, vector_popcount_lut)                                \\\n+  do_arch_entry(x86, compiler, vector_popcount_lut,                     \\\n+                vector_popcount_lut, vector_popcount_lut)               \\\n+  do_stub(compiler, upper_word_mask)                                    \\\n+  do_arch_entry(x86, compiler, upper_word_mask, upper_word_mask_addr,   \\\n+                upper_word_mask_addr)                                   \\\n+  do_stub(compiler, shuffle_byte_flip_mask)                             \\\n+  do_arch_entry(x86, compiler, shuffle_byte_flip_mask,                  \\\n+                shuffle_byte_flip_mask_addr,                            \\\n+                shuffle_byte_flip_mask_addr)                            \\\n+  do_stub(compiler, pshuffle_byte_flip_mask)                            \\\n+  do_arch_entry(x86, compiler, pshuffle_byte_flip_mask,                 \\\n+                pshuffle_byte_flip_mask_addr,                           \\\n+                pshuffle_byte_flip_mask_addr)                           \\\n+  LP64_ONLY(                                                            \\\n+    \/* x86_64 exposes these 3 stubs via a generic entry array *\/        \\\n+    \/* oher arches use arch-specific entries *\/                         \\\n+    \/* this really needs rationalising *\/                               \\\n+    do_stub(compiler, string_indexof_linear_ll)                         \\\n+    do_stub(compiler, string_indexof_linear_uu)                         \\\n+    do_stub(compiler, string_indexof_linear_ul)                         \\\n+    do_stub(compiler, pshuffle_byte_flip_mask_sha512)                   \\\n+    do_arch_entry(x86, compiler, pshuffle_byte_flip_mask_sha512,        \\\n+                  pshuffle_byte_flip_mask_addr_sha512,                  \\\n+                  pshuffle_byte_flip_mask_addr_sha512)                  \\\n+    do_stub(compiler, compress_perm_table32)                            \\\n+    do_arch_entry(x86, compiler, compress_perm_table32,                 \\\n+                  compress_perm_table32, compress_perm_table32)         \\\n+    do_stub(compiler, compress_perm_table64)                            \\\n+    do_arch_entry(x86, compiler, compress_perm_table64,                 \\\n+                  compress_perm_table64, compress_perm_table64)         \\\n+    do_stub(compiler, expand_perm_table32)                              \\\n+    do_arch_entry(x86, compiler, expand_perm_table32,                   \\\n+                  expand_perm_table32, expand_perm_table32)             \\\n+    do_stub(compiler, expand_perm_table64)                              \\\n+    do_arch_entry(x86, compiler, expand_perm_table64,                   \\\n+                  expand_perm_table64, expand_perm_table64)             \\\n+    do_stub(compiler, avx2_shuffle_base64)                              \\\n+    do_arch_entry(x86, compiler, avx2_shuffle_base64,                   \\\n+                  avx2_shuffle_base64, base64_avx2_shuffle_addr)        \\\n+    do_stub(compiler, avx2_input_mask_base64)                           \\\n+    do_arch_entry(x86, compiler, avx2_input_mask_base64,                \\\n+                  avx2_input_mask_base64,                               \\\n+                  base64_avx2_input_mask_addr)                          \\\n+    do_stub(compiler, avx2_lut_base64)                                  \\\n+    do_arch_entry(x86, compiler, avx2_lut_base64,                       \\\n+                  avx2_lut_base64, base64_avx2_lut_addr)                \\\n+    do_stub(compiler, avx2_decode_tables_base64)                        \\\n+    do_arch_entry(x86, compiler, avx2_decode_tables_base64,             \\\n+                  avx2_decode_tables_base64,                            \\\n+                  base64_AVX2_decode_tables_addr)                       \\\n+    do_stub(compiler, avx2_decode_lut_tables_base64)                    \\\n+    do_arch_entry(x86, compiler, avx2_decode_lut_tables_base64,         \\\n+                  avx2_decode_lut_tables_base64,                        \\\n+                  base64_AVX2_decode_LUT_tables_addr)                   \\\n+    do_stub(compiler, shuffle_base64)                                   \\\n+    do_arch_entry(x86, compiler, shuffle_base64, shuffle_base64,        \\\n+                  base64_shuffle_addr)                                  \\\n+    do_stub(compiler, lookup_lo_base64)                                 \\\n+    do_arch_entry(x86, compiler, lookup_lo_base64, lookup_lo_base64,    \\\n+                  base64_vbmi_lookup_lo_addr)                           \\\n+    do_stub(compiler, lookup_hi_base64)                                 \\\n+    do_arch_entry(x86, compiler, lookup_hi_base64, lookup_hi_base64,    \\\n+                  base64_vbmi_lookup_hi_addr)                           \\\n+    do_stub(compiler, lookup_lo_base64url)                              \\\n+    do_arch_entry(x86, compiler, lookup_lo_base64url,                   \\\n+                  lookup_lo_base64url,                                  \\\n+                  base64_vbmi_lookup_lo_url_addr)                       \\\n+    do_stub(compiler, lookup_hi_base64url)                              \\\n+    do_arch_entry(x86, compiler, lookup_hi_base64url,                   \\\n+                  lookup_hi_base64url,                                  \\\n+                  base64_vbmi_lookup_hi_url_addr)                       \\\n+    do_stub(compiler, pack_vec_base64)                                  \\\n+    do_arch_entry(x86, compiler, pack_vec_base64, pack_vec_base64,      \\\n+                  base64_vbmi_pack_vec_addr)                            \\\n+    do_stub(compiler, join_0_1_base64)                                  \\\n+    do_arch_entry(x86, compiler, join_0_1_base64, join_0_1_base64,      \\\n+                  base64_vbmi_join_0_1_addr)                            \\\n+    do_stub(compiler, join_1_2_base64)                                  \\\n+    do_arch_entry(x86, compiler, join_1_2_base64, join_1_2_base64,      \\\n+                  base64_vbmi_join_1_2_addr)                            \\\n+    do_stub(compiler, join_2_3_base64)                                  \\\n+    do_arch_entry(x86, compiler, join_2_3_base64, join_2_3_base64,      \\\n+                  base64_vbmi_join_2_3_addr)                            \\\n+    do_stub(compiler, encoding_table_base64)                            \\\n+    do_arch_entry(x86, compiler, encoding_table_base64,                 \\\n+                  encoding_table_base64, base64_encoding_table_addr)    \\\n+    do_stub(compiler, decoding_table_base64)                            \\\n+    do_arch_entry(x86, compiler, decoding_table_base64,                 \\\n+                  decoding_table_base64, base64_decoding_table_addr)    \\\n+  )                                                                     \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \\\n+                                    do_arch_blob,                       \\\n+                                    do_arch_entry,                      \\\n+                                    do_arch_entry_init)                 \\\n+  do_arch_blob(final, 11000 LP64_ONLY(+20000)                           \\\n+               WINDOWS_ONLY(+22000) ZGC_ONLY(+20000))                    \\\n+\n+#endif \/\/ CPU_X86_STUBDECLARATIONS_HPP\n","filename":"src\/hotspot\/cpu\/x86\/stubDeclarations_x86.hpp","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"},{"patch":"@@ -140,1 +140,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"call_stub\");\n+    StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -342,1 +343,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"catch_exception\");\n+    StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -385,1 +387,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"forward exception\");\n+    StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -457,1 +460,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"verify_mxcsr\");\n+    StubGenStubId stub_id = StubGenStubId::verify_mxcsr_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -496,1 +500,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"verify_spcw\");\n+    StubGenStubId stub_id = StubGenStubId::verify_fpu_cntrl_word_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -534,1 +539,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"d2i_wrapper\");\n+    StubGenStubId stub_id = StubGenStubId::d2i_wrapper_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -594,1 +600,1 @@\n-  address generate_vector_mask(const char *stub_name, int32_t mask) {\n+  address generate_vector_mask(StubGenStubId stub_id, int32_t mask) {\n@@ -596,1 +602,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubCodeMark mark(this, stub_id);\n@@ -606,1 +612,1 @@\n-  address generate_count_leading_zeros_lut(const char *stub_name) {\n+  address generate_count_leading_zeros_lut() {\n@@ -608,1 +614,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_count_leading_zeros_lut_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -630,1 +637,1 @@\n-  address generate_popcount_avx_lut(const char *stub_name) {\n+  address generate_popcount_avx_lut() {\n@@ -632,1 +639,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_popcount_lut_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -654,1 +662,1 @@\n-  address generate_iota_indices(const char *stub_name) {\n+  address generate_iota_indices() {\n@@ -656,1 +664,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_iota_indices_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -768,1 +777,1 @@\n-  address generate_vector_reverse_bit_lut(const char *stub_name) {\n+  address generate_vector_reverse_bit_lut() {\n@@ -770,1 +779,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_reverse_bit_lut_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -791,1 +801,1 @@\n-  address generate_vector_reverse_byte_perm_mask_long(const char *stub_name) {\n+  address generate_vector_reverse_byte_perm_mask_long() {\n@@ -793,1 +803,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_long_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -814,1 +825,1 @@\n-  address generate_vector_reverse_byte_perm_mask_int(const char *stub_name) {\n+  address generate_vector_reverse_byte_perm_mask_int() {\n@@ -816,1 +827,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_int_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -837,1 +849,1 @@\n-  address generate_vector_reverse_byte_perm_mask_short(const char *stub_name) {\n+  address generate_vector_reverse_byte_perm_mask_short() {\n@@ -839,1 +851,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_short_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -860,1 +873,1 @@\n-  address generate_vector_byte_shuffle_mask(const char *stub_name) {\n+  address generate_vector_byte_shuffle_mask() {\n@@ -862,1 +875,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_byte_shuffle_mask_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -875,1 +889,1 @@\n-  address generate_vector_mask_long_double(const char *stub_name, int32_t maskhi, int32_t masklo) {\n+  address generate_vector_mask_long_double(StubGenStubId stub_id, int32_t maskhi, int32_t masklo) {\n@@ -877,1 +891,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubCodeMark mark(this, stub_id);\n@@ -890,1 +904,1 @@\n-  address generate_vector_byte_perm_mask(const char *stub_name) {\n+  address generate_vector_byte_perm_mask() {\n@@ -892,1 +906,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubGenStubId stub_id = StubGenStubId::vector_byte_perm_mask_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -915,1 +930,1 @@\n-  address generate_vector_custom_i32(const char *stub_name, Assembler::AvxVectorLen len,\n+  address generate_vector_custom_i32(StubGenStubId stub_id, Assembler::AvxVectorLen len,\n@@ -921,1 +936,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    StubCodeMark mark(this, stub_id);\n@@ -953,1 +968,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"verify_oop\");\n+    StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1085,4 +1101,74 @@\n-  address generate_disjoint_copy(BasicType t, bool aligned,\n-                                 Address::ScaleFactor sf,\n-                                 address* entry, const char *name,\n-                                 bool dest_uninitialized = false) {\n+  address generate_disjoint_copy(StubGenStubId stub_id, address* entry) {\n+    BasicType t;\n+    bool aligned;\n+    Address::ScaleFactor sf;\n+    bool dest_uninitialized;\n+\n+    switch (stub_id) {\n+    case jbyte_disjoint_arraycopy_id:\n+      t = T_BYTE;\n+      aligned = false;\n+      sf = Address::times_1;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jbyte_disjoint_arraycopy_id:\n+      t = T_BYTE;\n+      aligned = true;\n+      sf = Address::times_1;\n+      dest_uninitialized = false;\n+      break;\n+    case jshort_disjoint_arraycopy_id:\n+      t = T_SHORT;\n+      aligned = false;\n+      sf = Address::times_2;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jshort_disjoint_arraycopy_id:\n+      t = T_SHORT;\n+      aligned = true;\n+      sf = Address::times_2;\n+      dest_uninitialized = false;\n+      break;\n+    case jint_disjoint_arraycopy_id:\n+      t = T_INT;\n+      aligned = true;\n+      sf = Address::times_4;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jint_disjoint_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case jint_disjoint_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case jlong_disjoint_arraycopy_id:\n+    case arrayof_jlong_disjoint_arraycopy_id:\n+      \/\/ Handled by a special generator routine on 32 bit\n+      ShouldNotReachHere();\n+      break;\n+    case oop_disjoint_arraycopy_id:\n+      t = T_OBJECT;\n+      aligned = true;\n+      sf = Address::times_ptr;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case oop_disjoint_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case oop_disjoint_arraycopy_uninit_id:\n+      t = T_OBJECT;\n+      aligned = true;\n+      sf = Address::times_ptr;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_disjoint_arraycopy_uninit_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case oop_disjoint_arraycopy_uninit\n+      ShouldNotReachHere();\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+    }\n+\n@@ -1090,1 +1176,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1233,1 +1319,33 @@\n-  address generate_fill(BasicType t, bool aligned, const char *name) {\n+  address generate_fill(StubGenStubId stub_id) {\n+    BasicType t;\n+    bool aligned;\n+    switch(stub_id) {\n+    case jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = false;\n+      break;\n+    case jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = false;\n+      break;\n+    case jint_fill_id:\n+      t = T_INT;\n+      aligned = false;\n+      break;\n+    case arrayof_jbyte_fill_id:\n+      t = T_BYTE;\n+      aligned = true;\n+      break;\n+    case arrayof_jshort_fill_id:\n+      t = T_SHORT;\n+      aligned = true;\n+      break;\n+    case arrayof_jint_fill_id:\n+      t = T_INT;\n+      aligned = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+    }\n+\n@@ -1235,1 +1353,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1260,2 +1378,1 @@\n-  address generate_conjoint_copy(BasicType t, bool aligned,\n-                                 Address::ScaleFactor sf,\n+  address generate_conjoint_copy(StubGenStubId stub_id,\n@@ -1263,2 +1380,74 @@\n-                                 address* entry, const char *name,\n-                                 bool dest_uninitialized = false) {\n+                                 address* entry) {\n+    BasicType t;\n+    bool aligned;\n+    Address::ScaleFactor sf;\n+    bool dest_uninitialized;\n+\n+    switch (stub_id) {\n+    case jbyte_arraycopy_id:\n+      t = T_BYTE;\n+      aligned = false;\n+      sf = Address::times_1;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jbyte_arraycopy_id:\n+      t = T_BYTE;\n+      aligned = true;\n+      sf = Address::times_1;\n+      dest_uninitialized = false;\n+      break;\n+    case jshort_arraycopy_id:\n+      t = T_SHORT;\n+      aligned = false;\n+      sf = Address::times_2;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jshort_arraycopy_id:\n+      t = T_SHORT;\n+      aligned = true;\n+      sf = Address::times_2;\n+      dest_uninitialized = false;\n+      break;\n+    case jint_arraycopy_id:\n+      t = T_INT;\n+      aligned = true;\n+      sf = Address::times_4;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_jint_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case jint_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case jlong_arraycopy_id:\n+    case arrayof_jlong_arraycopy_id:\n+      \/\/ Handled by a special generator routine on 32 bit\n+      ShouldNotReachHere();\n+      break;\n+    case oop_arraycopy_id:\n+      t = T_OBJECT;\n+      aligned = true;\n+      sf = Address::times_ptr;\n+      dest_uninitialized = false;\n+      break;\n+    case arrayof_oop_arraycopy_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case oop_arraycopy\n+      ShouldNotReachHere();\n+      break;\n+    case oop_arraycopy_uninit_id:\n+      t = T_OBJECT;\n+      aligned = true;\n+      sf = Address::times_ptr;\n+      dest_uninitialized = true;\n+      break;\n+    case arrayof_oop_arraycopy_uninit_id:\n+      \/\/ since this is always aligned we can (should!) use the same\n+      \/\/ stub as for case oop_arraycopy_uninit\n+      ShouldNotReachHere();\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+    }\n+\n@@ -1266,1 +1455,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1432,1 +1621,1 @@\n-  address generate_disjoint_long_copy(address* entry, const char *name) {\n+  address generate_disjoint_long_copy(address* entry) {\n@@ -1434,1 +1623,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::jlong_disjoint_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1477,2 +1667,1 @@\n-  address generate_conjoint_long_copy(address nooverlap_target,\n-                                      address* entry, const char *name) {\n+  address generate_conjoint_long_copy(address nooverlap_target, address* entry) {\n@@ -1480,1 +1669,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::jlong_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1601,1 +1791,13 @@\n-  address generate_checkcast_copy(const char *name, address* entry, bool dest_uninitialized = false) {\n+  address generate_checkcast_copy(StubGenStubId stub_id, address* entry) {\n+    bool dest_uninitialized;\n+    switch(stub_id) {\n+    case checkcast_arraycopy_id:\n+      dest_uninitialized = false;\n+      break;\n+    case checkcast_arraycopy_uninit_id:\n+      dest_uninitialized = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -1603,1 +1805,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -1758,2 +1960,1 @@\n-  address generate_unsafe_copy(const char *name,\n-                               address byte_copy_entry,\n+  address generate_unsafe_copy(address byte_copy_entry,\n@@ -1767,1 +1968,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -1864,2 +2066,1 @@\n-  address generate_generic_copy(const char *name,\n-                                address entry_jbyte_arraycopy,\n+  address generate_generic_copy(address entry_jbyte_arraycopy,\n@@ -1879,1 +2080,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2192,2 +2394,1 @@\n-        generate_disjoint_copy(T_BYTE,  true, Address::times_1, &entry,\n-                               \"arrayof_jbyte_disjoint_arraycopy\");\n+        generate_disjoint_copy(StubGenStubId::arrayof_jbyte_disjoint_arraycopy_id, &entry);\n@@ -2195,2 +2396,1 @@\n-        generate_conjoint_copy(T_BYTE,  true, Address::times_1,  entry,\n-                               nullptr, \"arrayof_jbyte_arraycopy\");\n+        generate_conjoint_copy(StubGenStubId::arrayof_jbyte_arraycopy_id, entry, nullptr);\n@@ -2198,2 +2398,1 @@\n-        generate_disjoint_copy(T_BYTE, false, Address::times_1, &entry,\n-                               \"jbyte_disjoint_arraycopy\");\n+      generate_disjoint_copy(StubGenStubId::jbyte_disjoint_arraycopy_id, &entry);\n@@ -2201,2 +2400,1 @@\n-        generate_conjoint_copy(T_BYTE, false, Address::times_1,  entry,\n-                               &entry_jbyte_arraycopy, \"jbyte_arraycopy\");\n+        generate_conjoint_copy(StubGenStubId::jbyte_arraycopy_id,  entry, &entry_jbyte_arraycopy);\n@@ -2205,2 +2403,1 @@\n-        generate_disjoint_copy(T_SHORT,  true, Address::times_2, &entry,\n-                               \"arrayof_jshort_disjoint_arraycopy\");\n+        generate_disjoint_copy(StubGenStubId::arrayof_jshort_disjoint_arraycopy_id, &entry);\n@@ -2208,2 +2405,1 @@\n-        generate_conjoint_copy(T_SHORT,  true, Address::times_2,  entry,\n-                               nullptr, \"arrayof_jshort_arraycopy\");\n+        generate_conjoint_copy(StubGenStubId::arrayof_jshort_arraycopy_id, entry, nullptr);\n@@ -2211,2 +2407,1 @@\n-        generate_disjoint_copy(T_SHORT, false, Address::times_2, &entry,\n-                               \"jshort_disjoint_arraycopy\");\n+        generate_disjoint_copy(StubGenStubId::jshort_disjoint_arraycopy_id, &entry);\n@@ -2214,2 +2409,1 @@\n-        generate_conjoint_copy(T_SHORT, false, Address::times_2,  entry,\n-                               &entry_jshort_arraycopy, \"jshort_arraycopy\");\n+        generate_conjoint_copy(StubGenStubId::jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n@@ -2219,2 +2413,1 @@\n-        generate_disjoint_copy(T_INT, true, Address::times_4, &entry,\n-                               \"jint_disjoint_arraycopy\");\n+        generate_disjoint_copy(StubGenStubId::jint_disjoint_arraycopy_id, &entry);\n@@ -2222,2 +2415,1 @@\n-        generate_conjoint_copy(T_INT, true, Address::times_4,  entry,\n-                               &entry_jint_arraycopy, \"jint_arraycopy\");\n+        generate_conjoint_copy(StubGenStubId::jint_arraycopy_id, entry, &entry_jint_arraycopy);\n@@ -2226,2 +2418,1 @@\n-        generate_disjoint_copy(T_OBJECT, true, Address::times_ptr, &entry,\n-                               \"oop_disjoint_arraycopy\");\n+        generate_disjoint_copy(StubGenStubId::oop_disjoint_arraycopy_id, &entry);\n@@ -2229,2 +2420,1 @@\n-        generate_conjoint_copy(T_OBJECT, true, Address::times_ptr,  entry,\n-                               &entry_oop_arraycopy, \"oop_arraycopy\");\n+        generate_conjoint_copy(StubGenStubId::oop_arraycopy_id, entry, &entry_oop_arraycopy);\n@@ -2233,3 +2423,1 @@\n-        generate_disjoint_copy(T_OBJECT, true, Address::times_ptr, &entry,\n-                               \"oop_disjoint_arraycopy_uninit\",\n-                               \/*dest_uninitialized*\/true);\n+        generate_disjoint_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id, &entry);\n@@ -2237,3 +2425,1 @@\n-        generate_conjoint_copy(T_OBJECT, true, Address::times_ptr,  entry,\n-                               nullptr, \"oop_arraycopy_uninit\",\n-                               \/*dest_uninitialized*\/true);\n+        generate_conjoint_copy(StubGenStubId::oop_arraycopy_uninit_id, entry, nullptr);\n@@ -2242,1 +2428,1 @@\n-        generate_disjoint_long_copy(&entry, \"jlong_disjoint_arraycopy\");\n+        generate_disjoint_long_copy(&entry);\n@@ -2244,2 +2430,1 @@\n-        generate_conjoint_long_copy(entry, &entry_jlong_arraycopy,\n-                                    \"jlong_arraycopy\");\n+        generate_conjoint_long_copy(entry, &entry_jlong_arraycopy);\n@@ -2247,6 +2432,6 @@\n-    StubRoutines::_jbyte_fill = generate_fill(T_BYTE, false, \"jbyte_fill\");\n-    StubRoutines::_jshort_fill = generate_fill(T_SHORT, false, \"jshort_fill\");\n-    StubRoutines::_jint_fill = generate_fill(T_INT, false, \"jint_fill\");\n-    StubRoutines::_arrayof_jbyte_fill = generate_fill(T_BYTE, true, \"arrayof_jbyte_fill\");\n-    StubRoutines::_arrayof_jshort_fill = generate_fill(T_SHORT, true, \"arrayof_jshort_fill\");\n-    StubRoutines::_arrayof_jint_fill = generate_fill(T_INT, true, \"arrayof_jint_fill\");\n+    StubRoutines::_jbyte_fill = generate_fill(StubGenStubId::jbyte_fill_id);\n+    StubRoutines::_jshort_fill = generate_fill(StubGenStubId::jshort_fill_id);\n+    StubRoutines::_jint_fill = generate_fill(StubGenStubId::jint_fill_id);\n+    StubRoutines::_arrayof_jbyte_fill = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n+    StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n+    StubRoutines::_arrayof_jint_fill = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n@@ -2265,1 +2450,1 @@\n-        generate_checkcast_copy(\"checkcast_arraycopy\", &entry_checkcast_arraycopy);\n+      generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n@@ -2267,1 +2452,1 @@\n-        generate_checkcast_copy(\"checkcast_arraycopy_uninit\", nullptr, \/*dest_uninitialized*\/true);\n+      generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id, nullptr);\n@@ -2270,5 +2455,4 @@\n-        generate_unsafe_copy(\"unsafe_arraycopy\",\n-                               entry_jbyte_arraycopy,\n-                               entry_jshort_arraycopy,\n-                               entry_jint_arraycopy,\n-                               entry_jlong_arraycopy);\n+        generate_unsafe_copy(entry_jbyte_arraycopy,\n+                             entry_jshort_arraycopy,\n+                             entry_jint_arraycopy,\n+                             entry_jlong_arraycopy);\n@@ -2277,2 +2461,1 @@\n-        generate_generic_copy(\"generic_arraycopy\",\n-                               entry_jbyte_arraycopy,\n+        generate_generic_copy( entry_jbyte_arraycopy,\n@@ -2358,1 +2541,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_encryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2457,1 +2641,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_decryptBlock\");\n+    StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2581,1 +2766,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_encryptAESCrypt\");\n+    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2739,1 +2925,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_decryptAESCrypt\");\n+    StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -2912,1 +3099,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"counterMode_AESCrypt\");\n+    StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3194,1 +3382,13 @@\n-  address generate_md5_implCompress(bool multi_block, const char *name) {\n+  address generate_md5_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch(stub_id) {\n+    case StubGenStubId::md5_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case StubGenStubId::md5_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -3196,1 +3396,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -3234,1 +3434,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"upper_word_mask\");\n+    StubGenStubId stub_id = StubGenStubId::upper_word_mask_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3245,1 +3446,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"shuffle_byte_flip_mask\");\n+    StubGenStubId stub_id = StubGenStubId::shuffle_byte_flip_mask_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3256,1 +3458,13 @@\n-  address generate_sha1_implCompress(bool multi_block, const char *name) {\n+  address generate_sha1_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch(stub_id) {\n+    case StubGenStubId::sha1_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case StubGenStubId::sha1_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -3258,1 +3472,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -3304,1 +3518,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"pshuffle_byte_flip_mask\");\n+    StubGenStubId stub_id = StubGenStubId::pshuffle_byte_flip_mask_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3315,1 +3530,13 @@\n- address generate_sha256_implCompress(bool multi_block, const char *name) {\n+ address generate_sha256_implCompress(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch(stub_id) {\n+    case StubGenStubId::sha256_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case StubGenStubId::sha256_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n@@ -3317,1 +3544,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n+    StubCodeMark mark(this, stub_id);\n@@ -3375,1 +3602,3 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"ghash_processBlocks\");\n+    StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+    StubCodeMark mark(this, stub_id);\n+\n@@ -3523,1 +3752,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32\");\n+    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3578,1 +3808,3 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32C\");\n+    StubGenStubId stub_id = StubGenStubId::updateBytesCRC32C_id;\n+    StubCodeMark mark(this, stub_id);\n+\n@@ -3621,1 +3853,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"libmExp\");\n+    StubGenStubId stub_id = StubGenStubId::dexp_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3637,1 +3870,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libmLog\");\n+   StubGenStubId stub_id = StubGenStubId::dlog_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3653,1 +3887,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libmLog10\");\n+   StubGenStubId stub_id = StubGenStubId::dlog10_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3669,1 +3904,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libmPow\");\n+   StubGenStubId stub_id = StubGenStubId::dpow_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3685,1 +3921,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libm_reduce_pi04l\");\n+   StubGenStubId stub_id = StubGenStubId::dlibm_reduce_pi04l_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3697,1 +3934,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libm_sin_cos_huge\");\n+   StubGenStubId stub_id = StubGenStubId::dlibm_sin_cos_huge_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3709,1 +3947,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libmSin\");\n+   StubGenStubId stub_id = StubGenStubId::dsin_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3725,1 +3964,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libmCos\");\n+   StubGenStubId stub_id = StubGenStubId::dcos_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3741,1 +3981,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libm_tan_cot_huge\");\n+   StubGenStubId stub_id = StubGenStubId::dlibm_tan_cot_huge_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3753,1 +3994,2 @@\n-   StubCodeMark mark(this, \"StubRoutines\", \"libmTan\");\n+   StubGenStubId stub_id = StubGenStubId::dtan_id;\n+   StubCodeMark mark(this, stub_id);\n@@ -3770,1 +4012,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+    StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+    StubCodeMark mark(this, stub_id);\n@@ -3990,8 +4233,8 @@\n-    StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(\"vector_float_sign_mask\", 0x7FFFFFFF);\n-    StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(\"vector_float_sign_flip\", 0x80000000);\n-    StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask_long_double(\"vector_double_sign_mask\", 0x7FFFFFFF, 0xFFFFFFFF);\n-    StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask_long_double(\"vector_double_sign_flip\", 0x80000000, 0x00000000);\n-    StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(\"vector_short_to_byte_mask\", 0x00ff00ff);\n-    StubRoutines::x86::_vector_int_to_byte_mask = generate_vector_mask(\"vector_int_to_byte_mask\", 0x000000ff);\n-    StubRoutines::x86::_vector_int_to_short_mask = generate_vector_mask(\"vector_int_to_short_mask\", 0x0000ffff);\n-    StubRoutines::x86::_vector_32_bit_mask = generate_vector_custom_i32(\"vector_32_bit_mask\", Assembler::AVX_512bit,\n+    StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(StubGenStubId::vector_float_sign_mask_id, 0x7FFFFFFF);\n+    StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(StubGenStubId::vector_float_sign_flip_id, 0x80000000);\n+    StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask_long_double(StubGenStubId::vector_double_sign_mask_id, 0x7FFFFFFF, 0xFFFFFFFF);\n+    StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask_long_double(StubGenStubId::vector_double_sign_flip_id, 0x80000000, 0x00000000);\n+    StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(StubGenStubId::vector_short_to_byte_mask_id, 0x00ff00ff);\n+    StubRoutines::x86::_vector_int_to_byte_mask = generate_vector_mask(StubGenStubId::vector_int_to_byte_mask_id, 0x000000ff);\n+    StubRoutines::x86::_vector_int_to_short_mask = generate_vector_mask(StubGenStubId::vector_int_to_short_mask_id, 0x0000ffff);\n+    StubRoutines::x86::_vector_32_bit_mask = generate_vector_custom_i32(StubGenStubId::vector_32_bit_mask_id, Assembler::AVX_512bit,\n@@ -3999,1 +4242,1 @@\n-    StubRoutines::x86::_vector_64_bit_mask = generate_vector_custom_i32(\"vector_64_bit_mask\", Assembler::AVX_512bit,\n+    StubRoutines::x86::_vector_64_bit_mask = generate_vector_custom_i32(StubGenStubId::vector_64_bit_mask_id, Assembler::AVX_512bit,\n@@ -4001,14 +4244,14 @@\n-    StubRoutines::x86::_vector_int_shuffle_mask = generate_vector_mask(\"vector_int_shuffle_mask\", 0x03020100);\n-    StubRoutines::x86::_vector_byte_shuffle_mask = generate_vector_byte_shuffle_mask(\"vector_byte_shuffle_mask\");\n-    StubRoutines::x86::_vector_short_shuffle_mask = generate_vector_mask(\"vector_short_shuffle_mask\", 0x01000100);\n-    StubRoutines::x86::_vector_long_shuffle_mask = generate_vector_mask_long_double(\"vector_long_shuffle_mask\", 0x00000001, 0x0);\n-    StubRoutines::x86::_vector_byte_perm_mask = generate_vector_byte_perm_mask(\"vector_byte_perm_mask\");\n-    StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask_long_double(\"vector_long_sign_mask\", 0x80000000, 0x00000000);\n-    StubRoutines::x86::_vector_all_bits_set = generate_vector_mask(\"vector_all_bits_set\", 0xFFFFFFFF);\n-    StubRoutines::x86::_vector_int_mask_cmp_bits = generate_vector_mask(\"vector_int_mask_cmp_bits\", 0x00000001);\n-    StubRoutines::x86::_vector_iota_indices = generate_iota_indices(\"iota_indices\");\n-    StubRoutines::x86::_vector_count_leading_zeros_lut = generate_count_leading_zeros_lut(\"count_leading_zeros_lut\");\n-    StubRoutines::x86::_vector_reverse_bit_lut = generate_vector_reverse_bit_lut(\"reverse_bit_lut\");\n-    StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long(\"perm_mask_long\");\n-    StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int(\"perm_mask_int\");\n-    StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short(\"perm_mask_short\");\n+    StubRoutines::x86::_vector_int_shuffle_mask = generate_vector_mask(StubGenStubId::vector_int_shuffle_mask_id, 0x03020100);\n+    StubRoutines::x86::_vector_byte_shuffle_mask = generate_vector_byte_shuffle_mask();\n+    StubRoutines::x86::_vector_short_shuffle_mask = generate_vector_mask(StubGenStubId::vector_short_shuffle_mask_id, 0x01000100);\n+    StubRoutines::x86::_vector_long_shuffle_mask = generate_vector_mask_long_double(StubGenStubId::vector_long_shuffle_mask_id, 0x00000001, 0x0);\n+    StubRoutines::x86::_vector_byte_perm_mask = generate_vector_byte_perm_mask();\n+    StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask_long_double(StubGenStubId::vector_long_sign_mask_id, 0x80000000, 0x00000000);\n+    StubRoutines::x86::_vector_all_bits_set = generate_vector_mask(StubGenStubId::vector_all_bits_set_id, 0xFFFFFFFF);\n+    StubRoutines::x86::_vector_int_mask_cmp_bits = generate_vector_mask(StubGenStubId::vector_int_mask_cmp_bits_id, 0x00000001);\n+    StubRoutines::x86::_vector_iota_indices = generate_iota_indices();\n+    StubRoutines::x86::_vector_count_leading_zeros_lut = generate_count_leading_zeros_lut();\n+    StubRoutines::x86::_vector_reverse_bit_lut = generate_vector_reverse_bit_lut();\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long();\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int();\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short();\n@@ -4018,1 +4261,1 @@\n-      StubRoutines::x86::_vector_popcount_lut = generate_popcount_avx_lut(\"popcount_lut\");\n+      StubRoutines::x86::_vector_popcount_lut = generate_popcount_avx_lut();\n@@ -4034,2 +4277,2 @@\n-      StubRoutines::_md5_implCompress = generate_md5_implCompress(false, \"md5_implCompress\");\n-      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(true, \"md5_implCompressMB\");\n+      StubRoutines::_md5_implCompress = generate_md5_implCompress(StubGenStubId::md5_implCompress_id);\n+      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(StubGenStubId::md5_implCompressMB_id);\n@@ -4040,2 +4283,2 @@\n-      StubRoutines::_sha1_implCompress = generate_sha1_implCompress(false, \"sha1_implCompress\");\n-      StubRoutines::_sha1_implCompressMB = generate_sha1_implCompress(true, \"sha1_implCompressMB\");\n+      StubRoutines::_sha1_implCompress = generate_sha1_implCompress(StubGenStubId::sha1_implCompress_id);\n+      StubRoutines::_sha1_implCompressMB = generate_sha1_implCompress(StubGenStubId::sha1_implCompressMB_id);\n@@ -4046,2 +4289,2 @@\n-      StubRoutines::_sha256_implCompress = generate_sha256_implCompress(false, \"sha256_implCompress\");\n-      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(true, \"sha256_implCompressMB\");\n+      StubRoutines::_sha256_implCompress = generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n+      StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n@@ -4059,3 +4302,3 @@\n-  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    switch(kind) {\n-    case Initial_stubs:\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+    switch(blob_id) {\n+    case initial_id:\n@@ -4064,1 +4307,1 @@\n-     case Continuation_stubs:\n+     case continuation_id:\n@@ -4067,1 +4310,1 @@\n-    case Compiler_stubs:\n+    case compiler_id:\n@@ -4070,1 +4313,1 @@\n-    case Final_stubs:\n+    case final_id:\n@@ -4074,1 +4317,1 @@\n-      fatal(\"unexpected stubs kind: %d\", kind);\n+      fatal(\"unexpected blob id: %d\", blob_id);\n@@ -4080,2 +4323,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":414,"deletions":171,"binary":false,"changes":585,"status":"modified"},{"patch":"@@ -190,1 +190,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"call_stub\");\n+  StubGenStubId stub_id = StubGenStubId::call_stub_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -415,1 +416,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"catch_exception\");\n+  StubGenStubId stub_id = StubGenStubId::catch_exception_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -470,1 +472,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"forward exception\");\n+  StubGenStubId stub_id = StubGenStubId::forward_exception_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -533,1 +536,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"orderaccess_fence\");\n+  StubGenStubId stub_id = StubGenStubId::fence_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -548,1 +552,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"get_previous_sp\");\n+  StubGenStubId stub_id = StubGenStubId::get_previous_sp_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -566,1 +571,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"verify_mxcsr\");\n+  StubGenStubId stub_id = StubGenStubId::verify_mxcsr_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -597,1 +603,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"f2i_fixup\");\n+  StubGenStubId stub_id = StubGenStubId::f2i_fixup_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -635,1 +642,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"f2l_fixup\");\n+  StubGenStubId stub_id = StubGenStubId::f2l_fixup_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -672,1 +680,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"d2i_fixup\");\n+  StubGenStubId stub_id = StubGenStubId::d2i_fixup_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -719,1 +728,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"d2l_fixup\");\n+  StubGenStubId stub_id = StubGenStubId::d2l_fixup_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -765,1 +775,1 @@\n-address StubGenerator::generate_count_leading_zeros_lut(const char *stub_name) {\n+address StubGenerator::generate_count_leading_zeros_lut() {\n@@ -767,1 +777,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_count_leading_zeros_lut_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -782,1 +793,1 @@\n-address StubGenerator::generate_popcount_avx_lut(const char *stub_name) {\n+address StubGenerator::generate_popcount_avx_lut() {\n@@ -784,1 +795,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_popcount_lut_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -799,1 +811,1 @@\n-address StubGenerator::generate_iota_indices(const char *stub_name) {\n+address StubGenerator::generate_iota_indices() {\n@@ -801,1 +813,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_iota_indices_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -860,1 +873,1 @@\n-address StubGenerator::generate_vector_reverse_bit_lut(const char *stub_name) {\n+address StubGenerator::generate_vector_reverse_bit_lut() {\n@@ -862,1 +875,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_reverse_bit_lut_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -877,1 +891,1 @@\n-address StubGenerator::generate_vector_reverse_byte_perm_mask_long(const char *stub_name) {\n+address StubGenerator::generate_vector_reverse_byte_perm_mask_long() {\n@@ -879,1 +893,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_long_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -894,1 +909,1 @@\n-address StubGenerator::generate_vector_reverse_byte_perm_mask_int(const char *stub_name) {\n+address StubGenerator::generate_vector_reverse_byte_perm_mask_int() {\n@@ -896,1 +911,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_int_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -911,1 +927,1 @@\n-address StubGenerator::generate_vector_reverse_byte_perm_mask_short(const char *stub_name) {\n+address StubGenerator::generate_vector_reverse_byte_perm_mask_short() {\n@@ -913,1 +929,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_reverse_byte_perm_mask_short_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -928,1 +945,1 @@\n-address StubGenerator::generate_vector_byte_shuffle_mask(const char *stub_name) {\n+address StubGenerator::generate_vector_byte_shuffle_mask() {\n@@ -930,1 +947,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_byte_shuffle_mask_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -941,1 +959,1 @@\n-address StubGenerator::generate_fp_mask(const char *stub_name, int64_t mask) {\n+address StubGenerator::generate_fp_mask(StubGenStubId stub_id, int64_t mask) {\n@@ -943,1 +961,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubCodeMark mark(this, stub_id);\n@@ -952,1 +970,12 @@\n-address StubGenerator::generate_compress_perm_table(const char *stub_name, int32_t esize) {\n+address StubGenerator::generate_compress_perm_table(StubGenStubId stub_id) {\n+  int esize;\n+  switch (stub_id) {\n+  case compress_perm_table32_id:\n+    esize = 32;\n+    break;\n+  case compress_perm_table64_id:\n+    esize = 64;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n@@ -954,1 +983,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubCodeMark mark(this, stub_id);\n@@ -996,1 +1025,12 @@\n-address StubGenerator::generate_expand_perm_table(const char *stub_name, int32_t esize) {\n+address StubGenerator::generate_expand_perm_table(StubGenStubId stub_id) {\n+  int esize;\n+  switch (stub_id) {\n+  case expand_perm_table32_id:\n+    esize = 32;\n+    break;\n+  case expand_perm_table64_id:\n+    esize = 64;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n@@ -998,1 +1038,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1038,1 +1078,1 @@\n-address StubGenerator::generate_vector_mask(const char *stub_name, int64_t mask) {\n+address StubGenerator::generate_vector_mask(StubGenStubId stub_id, int64_t mask) {\n@@ -1040,1 +1080,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1055,1 +1095,1 @@\n-address StubGenerator::generate_vector_byte_perm_mask(const char *stub_name) {\n+address StubGenerator::generate_vector_byte_perm_mask() {\n@@ -1057,1 +1097,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubGenStubId stub_id = StubGenStubId::vector_byte_perm_mask_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1072,1 +1113,1 @@\n-address StubGenerator::generate_vector_fp_mask(const char *stub_name, int64_t mask) {\n+address StubGenerator::generate_vector_fp_mask(StubGenStubId stub_id, int64_t mask) {\n@@ -1074,1 +1115,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1089,1 +1130,1 @@\n-address StubGenerator::generate_vector_custom_i32(const char *stub_name, Assembler::AvxVectorLen len,\n+address StubGenerator::generate_vector_custom_i32(StubGenStubId stub_id, Assembler::AvxVectorLen len,\n@@ -1095,1 +1136,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1139,1 +1180,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"verify_oop\");\n+  StubGenStubId stub_id = StubGenStubId::verify_oop_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1336,1 +1378,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"_data_cache_writeback\");\n+  StubGenStubId stub_id = StubGenStubId::data_cache_writeback_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1353,1 +1396,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"_data_cache_writeback_sync\");\n+  StubGenStubId stub_id = StubGenStubId::data_cache_writeback_sync_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1374,1 +1418,12 @@\n-address StubGenerator::generate_md5_implCompress(bool multi_block, const char *name) {\n+address StubGenerator::generate_md5_implCompress(StubGenStubId stub_id) {\n+  bool multi_block;\n+  switch (stub_id) {\n+  case md5_implCompress_id:\n+    multi_block = false;\n+    break;\n+  case md5_implCompressMB_id:\n+    multi_block = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n@@ -1376,1 +1431,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1412,1 +1467,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"upper_word_mask\");\n+  StubGenStubId stub_id = StubGenStubId::upper_word_mask_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1423,1 +1479,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"shuffle_byte_flip_mask\");\n+  StubGenStubId stub_id = StubGenStubId::shuffle_byte_flip_mask_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1434,1 +1491,12 @@\n-address StubGenerator::generate_sha1_implCompress(bool multi_block, const char *name) {\n+address StubGenerator::generate_sha1_implCompress(StubGenStubId stub_id) {\n+  bool multi_block;\n+  switch (stub_id) {\n+  case sha1_implCompress_id:\n+    multi_block = false;\n+    break;\n+  case sha1_implCompressMB_id:\n+    multi_block = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n@@ -1436,1 +1504,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1471,1 +1539,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"pshuffle_byte_flip_mask\");\n+  StubGenStubId stub_id = StubGenStubId::pshuffle_byte_flip_mask_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1498,1 +1567,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"pshuffle_byte_flip_mask_sha512\");\n+  StubGenStubId stub_id = StubGenStubId::pshuffle_byte_flip_mask_sha512_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1517,1 +1587,12 @@\n-address StubGenerator::generate_sha256_implCompress(bool multi_block, const char *name) {\n+address StubGenerator::generate_sha256_implCompress(StubGenStubId stub_id) {\n+  bool multi_block;\n+  switch (stub_id) {\n+  case sha256_implCompress_id:\n+    multi_block = false;\n+    break;\n+  case sha256_implCompressMB_id:\n+    multi_block = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n@@ -1520,1 +1601,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1559,1 +1640,12 @@\n-address StubGenerator::generate_sha512_implCompress(bool multi_block, const char *name) {\n+address StubGenerator::generate_sha512_implCompress(StubGenStubId stub_id) {\n+  bool multi_block;\n+  switch (stub_id) {\n+  case sha512_implCompress_id:\n+    multi_block = false;\n+    break;\n+  case sha512_implCompressMB_id:\n+    multi_block = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n@@ -1563,1 +1655,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1598,1 +1690,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"shuffle_base64\");\n+  StubGenStubId stub_id = StubGenStubId::shuffle_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1617,1 +1710,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"avx2_shuffle_base64\");\n+  StubGenStubId stub_id = StubGenStubId::avx2_shuffle_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1630,1 +1724,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"avx2_input_mask_base64\");\n+  StubGenStubId stub_id = StubGenStubId::avx2_input_mask_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1643,1 +1738,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"avx2_lut_base64\");\n+  StubGenStubId stub_id = StubGenStubId::avx2_lut_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1662,1 +1758,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"encoding_table_base64\");\n+  StubGenStubId stub_id = StubGenStubId::encoding_table_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1695,1 +1792,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"implEncode\");\n+  StubGenStubId stub_id = StubGenStubId::base64_encodeBlock_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2077,1 +2175,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"lookup_lo_base64\");\n+  StubGenStubId stub_id = StubGenStubId::lookup_lo_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2096,1 +2195,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"lookup_hi_base64\");\n+  StubGenStubId stub_id = StubGenStubId::lookup_hi_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2114,1 +2214,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"lookup_lo_base64url\");\n+  StubGenStubId stub_id = StubGenStubId::lookup_lo_base64url_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2133,1 +2234,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"lookup_hi_base64url\");\n+  StubGenStubId stub_id = StubGenStubId::lookup_hi_base64url_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2152,1 +2254,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"pack_vec_base64\");\n+  StubGenStubId stub_id = StubGenStubId::pack_vec_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2171,1 +2274,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"join_0_1_base64\");\n+  StubGenStubId stub_id = StubGenStubId::join_0_1_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2190,1 +2294,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"join_1_2_base64\");\n+  StubGenStubId stub_id = StubGenStubId::join_1_2_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2209,1 +2314,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"join_2_3_base64\");\n+  StubGenStubId stub_id = StubGenStubId::join_2_3_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2228,1 +2334,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"AVX2_tables_base64\");\n+  StubGenStubId stub_id = StubGenStubId::avx2_decode_tables_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2262,1 +2369,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"AVX2_tables_URL_base64\");\n+  StubGenStubId stub_id = StubGenStubId::avx2_decode_lut_tables_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2301,1 +2409,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"decoding_table_base64\");\n+  StubGenStubId stub_id = StubGenStubId::decoding_table_base64_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2383,1 +2492,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"implDecode\");\n+  StubGenStubId stub_id = StubGenStubId::base64_decodeBlock_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2916,1 +3026,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32\");\n+  StubGenStubId stub_id = StubGenStubId::updateBytesCRC32_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2972,1 +3083,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32C\");\n+  StubGenStubId stub_id = StubGenStubId::updateBytesCRC32C_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3052,1 +3164,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"multiplyToLen\");\n+  StubGenStubId stub_id = StubGenStubId::multiplyToLen_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3108,1 +3221,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"vectorizedMismatch\");\n+  StubGenStubId stub_id = StubGenStubId::vectorizedMismatch_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3159,1 +3273,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"squareToLen\");\n+  StubGenStubId stub_id = StubGenStubId::squareToLen_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3194,1 +3309,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+  StubGenStubId stub_id = StubGenStubId::method_entry_barrier_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3283,1 +3399,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"mulAdd\");\n+  StubGenStubId stub_id = StubGenStubId::mulAdd_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3324,1 +3441,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"bigIntegerRightShiftWorker\");\n+  StubGenStubId stub_id = StubGenStubId::bigIntegerRightShiftWorker_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3459,1 +3577,2 @@\n-  StubCodeMark mark(this,  \"StubRoutines\", \"bigIntegerLeftShiftWorker\");\n+  StubGenStubId stub_id = StubGenStubId::bigIntegerLeftShiftWorker_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3607,1 +3726,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"float16ToFloat\");\n+  StubGenStubId stub_id = StubGenStubId::hf2f_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3632,1 +3752,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"floatToFloat16\");\n+  StubGenStubId stub_id = StubGenStubId::f2hf_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3647,1 +3768,1 @@\n-address StubGenerator::generate_cont_thaw(const char* label, Continuation::thaw_kind kind) {\n+address StubGenerator::generate_cont_thaw(StubGenStubId stub_id) {\n@@ -3650,4 +3771,24 @@\n-  bool return_barrier = Continuation::is_thaw_return_barrier(kind);\n-  bool return_barrier_exception = Continuation::is_thaw_return_barrier_exception(kind);\n-\n-  StubCodeMark mark(this, \"StubRoutines\", label);\n+  bool return_barrier;\n+  bool return_barrier_exception;\n+  Continuation::thaw_kind kind;\n+\n+  switch (stub_id) {\n+  case cont_thaw_id:\n+    return_barrier = false;\n+    return_barrier_exception = false;\n+    kind = Continuation::thaw_top;\n+    break;\n+  case cont_returnBarrier_id:\n+    return_barrier = true;\n+    return_barrier_exception = false;\n+    kind = Continuation::thaw_return_barrier;\n+    break;\n+  case cont_returnBarrierExc_id:\n+    return_barrier = true;\n+    return_barrier_exception = true;\n+    kind = Continuation::thaw_return_barrier_exception;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+  StubCodeMark mark(this, stub_id);\n@@ -3771,1 +3912,1 @@\n-  return generate_cont_thaw(\"Cont thaw\", Continuation::thaw_top);\n+  return generate_cont_thaw(StubGenStubId::cont_thaw_id);\n@@ -3777,1 +3918,1 @@\n-  return generate_cont_thaw(\"Cont thaw return barrier\", Continuation::thaw_return_barrier);\n+  return generate_cont_thaw(StubGenStubId::cont_returnBarrier_id);\n@@ -3781,1 +3922,1 @@\n-  return generate_cont_thaw(\"Cont thaw return barrier exception\", Continuation::thaw_return_barrier_exception);\n+  return generate_cont_thaw(StubGenStubId::cont_returnBarrierExc_id);\n@@ -3786,1 +3927,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\",\"Continuation preempt stub\");\n+  StubGenStubId stub_id = StubGenStubId::cont_preempt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3816,1 +3958,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+  StubGenStubId stub_id = StubGenStubId::upcall_stub_exception_handler_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3836,1 +3979,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+  StubGenStubId stub_id = StubGenStubId::upcall_stub_load_target_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3854,4 +3998,3 @@\n-address StubGenerator::generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-  StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n-\n-  address start = __ pc();\n+void StubGenerator::generate_lookup_secondary_supers_table_stub() {\n+  StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3864,7 +4007,8 @@\n-  __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n-                                         rdx, rcx, rbx, r11, \/\/ temps\n-                                         result,\n-                                         super_klass_index);\n-  __ ret(0);\n-\n-  return start;\n+  for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+    StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+    __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n+                                           rdx, rcx, rbx, r11, \/\/ temps\n+                                           result,\n+                                           slot);\n+    __ ret(0);\n+  }\n@@ -3875,1 +4019,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+  StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_slow_path_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -3948,4 +4093,4 @@\n-  StubRoutines::x86::_float_sign_mask       = generate_fp_mask(\"float_sign_mask\",  0x7FFFFFFF7FFFFFFF);\n-  StubRoutines::x86::_float_sign_flip       = generate_fp_mask(\"float_sign_flip\",  0x8000000080000000);\n-  StubRoutines::x86::_double_sign_mask      = generate_fp_mask(\"double_sign_mask\", 0x7FFFFFFFFFFFFFFF);\n-  StubRoutines::x86::_double_sign_flip      = generate_fp_mask(\"double_sign_flip\", 0x8000000000000000);\n+  StubRoutines::x86::_float_sign_mask       = generate_fp_mask(StubGenStubId::float_sign_mask_id,  0x7FFFFFFF7FFFFFFF);\n+  StubRoutines::x86::_float_sign_flip       = generate_fp_mask(StubGenStubId::float_sign_flip_id,  0x8000000080000000);\n+  StubRoutines::x86::_double_sign_mask      = generate_fp_mask(StubGenStubId::double_sign_mask_id, 0x7FFFFFFFFFFFFFFF);\n+  StubRoutines::x86::_double_sign_flip      = generate_fp_mask(StubGenStubId::double_sign_flip_id, 0x8000000000000000);\n@@ -3997,4 +4142,0 @@\n-  \/\/ data cache line writeback\n-  StubRoutines::_data_cache_writeback = generate_data_cache_writeback();\n-  StubRoutines::_data_cache_writeback_sync = generate_data_cache_writeback_sync();\n-\n@@ -4009,0 +4150,9 @@\n+#ifdef COMPILER2\n+  if (UseSecondarySupersTable) {\n+    StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+    if (! InlineSecondarySupersTest) {\n+      generate_lookup_secondary_supers_table_stub();\n+    }\n+  }\n+#endif \/\/ COMPILER2\n+\n@@ -4022,11 +4172,11 @@\n-  StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(\"vector_float_sign_mask\", 0x7FFFFFFF7FFFFFFF);\n-  StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(\"vector_float_sign_flip\", 0x8000000080000000);\n-  StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask(\"vector_double_sign_mask\", 0x7FFFFFFFFFFFFFFF);\n-  StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask(\"vector_double_sign_flip\", 0x8000000000000000);\n-  StubRoutines::x86::_vector_all_bits_set = generate_vector_mask(\"vector_all_bits_set\", 0xFFFFFFFFFFFFFFFF);\n-  StubRoutines::x86::_vector_int_mask_cmp_bits = generate_vector_mask(\"vector_int_mask_cmp_bits\", 0x0000000100000001);\n-  StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(\"vector_short_to_byte_mask\", 0x00ff00ff00ff00ff);\n-  StubRoutines::x86::_vector_byte_perm_mask = generate_vector_byte_perm_mask(\"vector_byte_perm_mask\");\n-  StubRoutines::x86::_vector_int_to_byte_mask = generate_vector_mask(\"vector_int_to_byte_mask\", 0x000000ff000000ff);\n-  StubRoutines::x86::_vector_int_to_short_mask = generate_vector_mask(\"vector_int_to_short_mask\", 0x0000ffff0000ffff);\n-  StubRoutines::x86::_vector_32_bit_mask = generate_vector_custom_i32(\"vector_32_bit_mask\", Assembler::AVX_512bit,\n+  StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(StubGenStubId::vector_float_sign_mask_id, 0x7FFFFFFF7FFFFFFF);\n+  StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(StubGenStubId::vector_float_sign_flip_id, 0x8000000080000000);\n+  StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask(StubGenStubId::vector_double_sign_mask_id, 0x7FFFFFFFFFFFFFFF);\n+  StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask(StubGenStubId::vector_double_sign_flip_id, 0x8000000000000000);\n+  StubRoutines::x86::_vector_all_bits_set = generate_vector_mask(StubGenStubId::vector_all_bits_set_id, 0xFFFFFFFFFFFFFFFF);\n+  StubRoutines::x86::_vector_int_mask_cmp_bits = generate_vector_mask(StubGenStubId::vector_int_mask_cmp_bits_id, 0x0000000100000001);\n+  StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(StubGenStubId::vector_short_to_byte_mask_id, 0x00ff00ff00ff00ff);\n+  StubRoutines::x86::_vector_byte_perm_mask = generate_vector_byte_perm_mask();\n+  StubRoutines::x86::_vector_int_to_byte_mask = generate_vector_mask(StubGenStubId::vector_int_to_byte_mask_id, 0x000000ff000000ff);\n+  StubRoutines::x86::_vector_int_to_short_mask = generate_vector_mask(StubGenStubId::vector_int_to_short_mask_id, 0x0000ffff0000ffff);\n+  StubRoutines::x86::_vector_32_bit_mask = generate_vector_custom_i32(StubGenStubId::vector_32_bit_mask_id, Assembler::AVX_512bit,\n@@ -4034,1 +4184,1 @@\n-  StubRoutines::x86::_vector_64_bit_mask = generate_vector_custom_i32(\"vector_64_bit_mask\", Assembler::AVX_512bit,\n+  StubRoutines::x86::_vector_64_bit_mask = generate_vector_custom_i32(StubGenStubId::vector_64_bit_mask_id, Assembler::AVX_512bit,\n@@ -4036,11 +4186,11 @@\n-  StubRoutines::x86::_vector_int_shuffle_mask = generate_vector_mask(\"vector_int_shuffle_mask\", 0x0302010003020100);\n-  StubRoutines::x86::_vector_byte_shuffle_mask = generate_vector_byte_shuffle_mask(\"vector_byte_shuffle_mask\");\n-  StubRoutines::x86::_vector_short_shuffle_mask = generate_vector_mask(\"vector_short_shuffle_mask\", 0x0100010001000100);\n-  StubRoutines::x86::_vector_long_shuffle_mask = generate_vector_mask(\"vector_long_shuffle_mask\", 0x0000000100000000);\n-  StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask(\"vector_long_sign_mask\", 0x8000000000000000);\n-  StubRoutines::x86::_vector_iota_indices = generate_iota_indices(\"iota_indices\");\n-  StubRoutines::x86::_vector_count_leading_zeros_lut = generate_count_leading_zeros_lut(\"count_leading_zeros_lut\");\n-  StubRoutines::x86::_vector_reverse_bit_lut = generate_vector_reverse_bit_lut(\"reverse_bit_lut\");\n-  StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long(\"perm_mask_long\");\n-  StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int(\"perm_mask_int\");\n-  StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short(\"perm_mask_short\");\n+  StubRoutines::x86::_vector_int_shuffle_mask = generate_vector_mask(StubGenStubId::vector_int_shuffle_mask_id, 0x0302010003020100);\n+  StubRoutines::x86::_vector_byte_shuffle_mask = generate_vector_byte_shuffle_mask();\n+  StubRoutines::x86::_vector_short_shuffle_mask = generate_vector_mask(StubGenStubId::vector_short_shuffle_mask_id, 0x0100010001000100);\n+  StubRoutines::x86::_vector_long_shuffle_mask = generate_vector_mask(StubGenStubId::vector_long_shuffle_mask_id, 0x0000000100000000);\n+  StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask(StubGenStubId::vector_long_sign_mask_id, 0x8000000000000000);\n+  StubRoutines::x86::_vector_iota_indices = generate_iota_indices();\n+  StubRoutines::x86::_vector_count_leading_zeros_lut = generate_count_leading_zeros_lut();\n+  StubRoutines::x86::_vector_reverse_bit_lut = generate_vector_reverse_bit_lut();\n+  StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long();\n+  StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int();\n+  StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short();\n@@ -4049,4 +4199,4 @@\n-    StubRoutines::x86::_compress_perm_table32 = generate_compress_perm_table(\"compress_perm_table32\", 32);\n-    StubRoutines::x86::_compress_perm_table64 = generate_compress_perm_table(\"compress_perm_table64\", 64);\n-    StubRoutines::x86::_expand_perm_table32 = generate_expand_perm_table(\"expand_perm_table32\", 32);\n-    StubRoutines::x86::_expand_perm_table64 = generate_expand_perm_table(\"expand_perm_table64\", 64);\n+    StubRoutines::x86::_compress_perm_table32 = generate_compress_perm_table(StubGenStubId::compress_perm_table32_id);\n+    StubRoutines::x86::_compress_perm_table64 = generate_compress_perm_table(StubGenStubId::compress_perm_table64_id);\n+    StubRoutines::x86::_expand_perm_table32 = generate_expand_perm_table(StubGenStubId::expand_perm_table32_id);\n+    StubRoutines::x86::_expand_perm_table64 = generate_expand_perm_table(StubGenStubId::expand_perm_table64_id);\n@@ -4057,1 +4207,1 @@\n-    StubRoutines::x86::_vector_popcount_lut = generate_popcount_avx_lut(\"popcount_lut\");\n+    StubRoutines::x86::_vector_popcount_lut = generate_popcount_avx_lut();\n@@ -4068,0 +4218,4 @@\n+  \/\/ data cache line writeback\n+  StubRoutines::_data_cache_writeback = generate_data_cache_writeback();\n+  StubRoutines::_data_cache_writeback_sync = generate_data_cache_writeback_sync();\n+\n@@ -4088,2 +4242,2 @@\n-    StubRoutines::_md5_implCompress = generate_md5_implCompress(false, \"md5_implCompress\");\n-    StubRoutines::_md5_implCompressMB = generate_md5_implCompress(true, \"md5_implCompressMB\");\n+    StubRoutines::_md5_implCompress = generate_md5_implCompress(StubGenStubId::md5_implCompress_id);\n+    StubRoutines::_md5_implCompressMB = generate_md5_implCompress(StubGenStubId::md5_implCompressMB_id);\n@@ -4095,2 +4249,2 @@\n-    StubRoutines::_sha1_implCompress = generate_sha1_implCompress(false, \"sha1_implCompress\");\n-    StubRoutines::_sha1_implCompressMB = generate_sha1_implCompress(true, \"sha1_implCompressMB\");\n+    StubRoutines::_sha1_implCompress = generate_sha1_implCompress(StubGenStubId::sha1_implCompress_id);\n+    StubRoutines::_sha1_implCompressMB = generate_sha1_implCompress(StubGenStubId::sha1_implCompressMB_id);\n@@ -4109,2 +4263,2 @@\n-    StubRoutines::_sha256_implCompress = generate_sha256_implCompress(false, \"sha256_implCompress\");\n-    StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(true, \"sha256_implCompressMB\");\n+    StubRoutines::_sha256_implCompress = generate_sha256_implCompress(StubGenStubId::sha256_implCompress_id);\n+    StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(StubGenStubId::sha256_implCompressMB_id);\n@@ -4116,2 +4270,2 @@\n-    StubRoutines::_sha512_implCompress = generate_sha512_implCompress(false, \"sha512_implCompress\");\n-    StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(true, \"sha512_implCompressMB\");\n+    StubRoutines::_sha512_implCompress = generate_sha512_implCompress(StubGenStubId::sha512_implCompress_id);\n+    StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(StubGenStubId::sha512_implCompressMB_id);\n@@ -4159,8 +4313,0 @@\n-  if (UseSecondarySupersTable) {\n-    StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n-    if (! InlineSecondarySupersTest) {\n-      for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-        StubRoutines::_lookup_secondary_supers_table_stubs[slot] = generate_lookup_secondary_supers_table_stub(slot);\n-      }\n-    }\n-  }\n@@ -4265,19 +4411,18 @@\n-StubGenerator::StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    DEBUG_ONLY( _regs_in_thread = false; )\n-    switch(kind) {\n-    case Initial_stubs:\n-      generate_initial_stubs();\n-      break;\n-     case Continuation_stubs:\n-      generate_continuation_stubs();\n-      break;\n-    case Compiler_stubs:\n-      generate_compiler_stubs();\n-      break;\n-    case Final_stubs:\n-      generate_final_stubs();\n-      break;\n-    default:\n-      fatal(\"unexpected stubs kind: %d\", kind);\n-      break;\n-    };\n+StubGenerator::StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  switch(blob_id) {\n+  case initial_id:\n+    generate_initial_stubs();\n+    break;\n+  case continuation_id:\n+    generate_continuation_stubs();\n+    break;\n+  case compiler_id:\n+    generate_compiler_stubs();\n+    break;\n+  case final_id:\n+    generate_final_stubs();\n+    break;\n+  default:\n+    fatal(\"unexpected blob id: %d\", blob_id);\n+    break;\n+  };\n@@ -4286,2 +4431,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":325,"deletions":180,"binary":false,"changes":505,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -90,4 +91,4 @@\n-  address generate_count_leading_zeros_lut(const char *stub_name);\n-  address generate_popcount_avx_lut(const char *stub_name);\n-  address generate_iota_indices(const char *stub_name);\n-  address generate_vector_reverse_bit_lut(const char *stub_name);\n+  address generate_count_leading_zeros_lut();\n+  address generate_popcount_avx_lut();\n+  address generate_iota_indices();\n+  address generate_vector_reverse_bit_lut();\n@@ -95,4 +96,4 @@\n-  address generate_vector_reverse_byte_perm_mask_long(const char *stub_name);\n-  address generate_vector_reverse_byte_perm_mask_int(const char *stub_name);\n-  address generate_vector_reverse_byte_perm_mask_short(const char *stub_name);\n-  address generate_vector_byte_shuffle_mask(const char *stub_name);\n+  address generate_vector_reverse_byte_perm_mask_long();\n+  address generate_vector_reverse_byte_perm_mask_int();\n+  address generate_vector_reverse_byte_perm_mask_short();\n+  address generate_vector_byte_shuffle_mask();\n@@ -100,1 +101,1 @@\n-  address generate_fp_mask(const char *stub_name, int64_t mask);\n+  address generate_fp_mask(StubGenStubId stub_id, int64_t mask);\n@@ -102,1 +103,1 @@\n-  address generate_compress_perm_table(const char *stub_name, int32_t esize);\n+  address generate_compress_perm_table(StubGenStubId stub_id);\n@@ -104,1 +105,1 @@\n-  address generate_expand_perm_table(const char *stub_name, int32_t esize);\n+  address generate_expand_perm_table(StubGenStubId stub_id);\n@@ -106,1 +107,1 @@\n-  address generate_vector_mask(const char *stub_name, int64_t mask);\n+  address generate_vector_mask(StubGenStubId stub_id, int64_t mask);\n@@ -108,1 +109,1 @@\n-  address generate_vector_byte_perm_mask(const char *stub_name);\n+  address generate_vector_byte_perm_mask();\n@@ -110,1 +111,1 @@\n-  address generate_vector_fp_mask(const char *stub_name, int64_t mask);\n+  address generate_vector_fp_mask(StubGenStubId stub_id, int64_t mask);\n@@ -112,1 +113,1 @@\n-  address generate_vector_custom_i32(const char *stub_name, Assembler::AvxVectorLen len,\n+  address generate_vector_custom_i32(StubGenStubId stub_id, Assembler::AvxVectorLen len,\n@@ -182,2 +183,1 @@\n-  address generate_disjoint_copy_avx3_masked(address* entry, const char *name, int shift,\n-                                             bool aligned, bool is_oop, bool dest_uninitialized);\n+  address generate_disjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry);\n@@ -185,3 +185,2 @@\n-  address generate_conjoint_copy_avx3_masked(address* entry, const char *name, int shift,\n-                                             address nooverlap_target, bool aligned, bool is_oop,\n-                                             bool dest_uninitialized);\n+  address generate_conjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry,\n+                                             address nooverlap_target);\n@@ -228,1 +227,1 @@\n-  address generate_disjoint_byte_copy(bool aligned, address* entry, const char *name);\n+  address generate_disjoint_byte_copy(address* entry);\n@@ -230,2 +229,1 @@\n-  address generate_conjoint_byte_copy(bool aligned, address nooverlap_target,\n-                                      address* entry, const char *name);\n+  address generate_conjoint_byte_copy(address nooverlap_target, address* entry);\n@@ -233,1 +231,1 @@\n-  address generate_disjoint_short_copy(bool aligned, address *entry, const char *name);\n+  address generate_disjoint_short_copy(address *entry);\n@@ -235,1 +233,1 @@\n-  address generate_fill(BasicType t, bool aligned, const char *name);\n+  address generate_fill(StubGenStubId stub_id);\n@@ -237,12 +235,7 @@\n-  address generate_conjoint_short_copy(bool aligned, address nooverlap_target,\n-                                       address *entry, const char *name);\n-  address generate_disjoint_int_oop_copy(bool aligned, bool is_oop, address* entry,\n-                                         const char *name, bool dest_uninitialized = false);\n-  address generate_conjoint_int_oop_copy(bool aligned, bool is_oop, address nooverlap_target,\n-                                         address *entry, const char *name,\n-                                         bool dest_uninitialized = false);\n-  address generate_disjoint_long_oop_copy(bool aligned, bool is_oop, address *entry,\n-                                          const char *name, bool dest_uninitialized = false);\n-  address generate_conjoint_long_oop_copy(bool aligned, bool is_oop,\n-                                          address nooverlap_target, address *entry,\n-                                          const char *name, bool dest_uninitialized = false);\n+  address generate_conjoint_short_copy(address nooverlap_target, address *entry);\n+  address generate_disjoint_int_oop_copy(StubGenStubId stub_id, address* entry);\n+  address generate_conjoint_int_oop_copy(StubGenStubId stub_id, address nooverlap_target,\n+                                         address *entry);\n+  address generate_disjoint_long_oop_copy(StubGenStubId stub_id, address* entry);\n+  address generate_conjoint_long_oop_copy(StubGenStubId stub_id, address nooverlap_target,\n+                                          address *entry);\n@@ -258,2 +251,1 @@\n-  address generate_checkcast_copy(const char *name, address *entry,\n-                                  bool dest_uninitialized = false);\n+  address generate_checkcast_copy(StubGenStubId stub_id, address *entry);\n@@ -267,2 +259,1 @@\n-  address generate_unsafe_copy(const char *name,\n-                               address byte_copy_entry, address short_copy_entry,\n+  address generate_unsafe_copy(address byte_copy_entry, address short_copy_entry,\n@@ -277,1 +268,1 @@\n-  address generate_unsafe_setmemory(const char *name, address byte_copy_entry);\n+  address generate_unsafe_setmemory(address byte_copy_entry);\n@@ -291,2 +282,1 @@\n-  address generate_generic_copy(const char *name,\n-                                address byte_copy_entry, address short_copy_entry,\n+  address generate_generic_copy(address byte_copy_entry, address short_copy_entry,\n@@ -307,1 +297,1 @@\n-  address generate_md5_implCompress(bool multi_block, const char *name);\n+  address generate_md5_implCompress(StubGenStubId stub_id);\n@@ -314,1 +304,1 @@\n-  address generate_sha1_implCompress(bool multi_block, const char *name);\n+  address generate_sha1_implCompress(StubGenStubId stub_id);\n@@ -318,2 +308,2 @@\n-  address generate_sha256_implCompress(bool multi_block, const char *name);\n-  address generate_sha512_implCompress(bool multi_block, const char *name);\n+  address generate_sha256_implCompress(StubGenStubId stub_id);\n+  address generate_sha512_implCompress(StubGenStubId stub_id);\n@@ -502,1 +492,1 @@\n-  address generate_sha3_implCompress(bool multiBlock, const char *name);\n+  address generate_sha3_implCompress(StubGenStubId stub_id);\n@@ -598,1 +588,1 @@\n-  address generate_cont_thaw(const char* label, Continuation::thaw_kind kind);\n+  address generate_cont_thaw(StubGenStubId stub_id);\n@@ -607,0 +597,2 @@\n+  \/\/ TODO -- delete this as it is not implemented?\n+  \/\/\n@@ -632,1 +624,1 @@\n-  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index);\n+  void generate_lookup_secondary_supers_table_stub();\n@@ -645,2 +637,2 @@\n- public:\n-  StubGenerator(CodeBuffer* code, StubsKind kind);\n+public:\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":46,"deletions":54,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+* Copyright (c) 2021, 2024, Intel Corporation. All rights reserved.\n@@ -69,1 +69,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"updateBytesAdler32\");\n+  StubGenStubId stub_id = StubGenStubId::updateBytesAdler32_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_adler.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -252,1 +252,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"galoisCounterMode_AESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::galoisCounterMode_AESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -338,1 +339,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"galoisCounterMode_AESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::galoisCounterMode_AESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -409,1 +411,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"counterMode_AESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -497,1 +500,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"counterMode_AESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::counterMode_AESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -784,1 +788,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_decryptAESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1066,1 +1071,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_encryptBlock\");\n+  StubGenStubId stub_id = StubGenStubId::aescrypt_encryptBlock_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1160,1 +1166,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"aescrypt_decryptBlock\");\n+  StubGenStubId stub_id = StubGenStubId::aescrypt_decryptBlock_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1261,1 +1268,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_encryptAESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_encryptAESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1412,1 +1420,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"cipherBlockChaining_decryptAESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::cipherBlockChaining_decryptAESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1654,1 +1663,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"electronicCodeBook_encryptAESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::electronicCodeBook_encryptAESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -1674,1 +1684,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"electronicCodeBook_decryptAESCrypt\");\n+  StubGenStubId stub_id = StubGenStubId::electronicCodeBook_decryptAESCrypt_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_aes.cpp","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -87,19 +87,11 @@\n-  StubRoutines::_jbyte_disjoint_arraycopy  = generate_disjoint_byte_copy(false, &entry,\n-                                                                         \"jbyte_disjoint_arraycopy\");\n-  StubRoutines::_jbyte_arraycopy           = generate_conjoint_byte_copy(false, entry, &entry_jbyte_arraycopy,\n-                                                                         \"jbyte_arraycopy\");\n-\n-  StubRoutines::_jshort_disjoint_arraycopy = generate_disjoint_short_copy(false, &entry,\n-                                                                          \"jshort_disjoint_arraycopy\");\n-  StubRoutines::_jshort_arraycopy          = generate_conjoint_short_copy(false, entry, &entry_jshort_arraycopy,\n-                                                                          \"jshort_arraycopy\");\n-\n-  StubRoutines::_jint_disjoint_arraycopy   = generate_disjoint_int_oop_copy(false, false, &entry,\n-                                                                            \"jint_disjoint_arraycopy\");\n-  StubRoutines::_jint_arraycopy            = generate_conjoint_int_oop_copy(false, false, entry,\n-                                                                            &entry_jint_arraycopy, \"jint_arraycopy\");\n-\n-  StubRoutines::_jlong_disjoint_arraycopy  = generate_disjoint_long_oop_copy(false, false, &entry,\n-                                                                             \"jlong_disjoint_arraycopy\");\n-  StubRoutines::_jlong_arraycopy           = generate_conjoint_long_oop_copy(false, false, entry,\n-                                                                             &entry_jlong_arraycopy, \"jlong_arraycopy\");\n+  StubRoutines::_jbyte_disjoint_arraycopy  = generate_disjoint_byte_copy(&entry);\n+  StubRoutines::_jbyte_arraycopy           = generate_conjoint_byte_copy(entry, &entry_jbyte_arraycopy);\n+\n+  StubRoutines::_jshort_disjoint_arraycopy = generate_disjoint_short_copy(&entry);\n+  StubRoutines::_jshort_arraycopy          = generate_conjoint_short_copy(entry, &entry_jshort_arraycopy);\n+\n+  StubRoutines::_jint_disjoint_arraycopy   = generate_disjoint_int_oop_copy(StubGenStubId::jint_disjoint_arraycopy_id, &entry);\n+  StubRoutines::_jint_arraycopy            = generate_conjoint_int_oop_copy(StubGenStubId::jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+\n+  StubRoutines::_jlong_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubGenStubId::jlong_disjoint_arraycopy_id, &entry);\n+  StubRoutines::_jlong_arraycopy           = generate_conjoint_long_oop_copy(StubGenStubId::jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n@@ -107,10 +99,4 @@\n-    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_int_oop_copy(false, true, &entry,\n-                                                                            \"oop_disjoint_arraycopy\");\n-    StubRoutines::_oop_arraycopy           = generate_conjoint_int_oop_copy(false, true, entry,\n-                                                                            &entry_oop_arraycopy, \"oop_arraycopy\");\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_int_oop_copy(false, true, &entry,\n-                                                                                   \"oop_disjoint_arraycopy_uninit\",\n-                                                                                   \/*dest_uninitialized*\/true);\n-    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_int_oop_copy(false, true, entry,\n-                                                                                   nullptr, \"oop_arraycopy_uninit\",\n-                                                                                   \/*dest_uninitialized*\/true);\n+    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_int_oop_copy(StubGenStubId::oop_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_oop_arraycopy           = generate_conjoint_int_oop_copy(StubGenStubId::oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_int_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id, &entry);\n+    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_int_oop_copy(StubGenStubId::oop_arraycopy_uninit_id, entry, nullptr);\n@@ -118,18 +104,10 @@\n-    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_long_oop_copy(false, true, &entry,\n-                                                                             \"oop_disjoint_arraycopy\");\n-    StubRoutines::_oop_arraycopy           = generate_conjoint_long_oop_copy(false, true, entry,\n-                                                                             &entry_oop_arraycopy, \"oop_arraycopy\");\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_long_oop_copy(false, true, &entry,\n-                                                                                    \"oop_disjoint_arraycopy_uninit\",\n-                                                                                    \/*dest_uninitialized*\/true);\n-    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_long_oop_copy(false, true, entry,\n-                                                                                    nullptr, \"oop_arraycopy_uninit\",\n-                                                                                    \/*dest_uninitialized*\/true);\n-  }\n-\n-  StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(\"checkcast_arraycopy\", &entry_checkcast_arraycopy);\n-  StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", nullptr,\n-                                                                      \/*dest_uninitialized*\/true);\n-\n-  StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(\"unsafe_arraycopy\",\n-                                                            entry_jbyte_arraycopy,\n+    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubGenStubId::oop_disjoint_arraycopy_id, &entry);\n+    StubRoutines::_oop_arraycopy           = generate_conjoint_long_oop_copy(StubGenStubId::oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_long_oop_copy(StubGenStubId::oop_disjoint_arraycopy_uninit_id, &entry);\n+    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_long_oop_copy(StubGenStubId::oop_arraycopy_uninit_id, entry, nullptr);\n+  }\n+\n+  StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+  StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(StubGenStubId::checkcast_arraycopy_uninit_id, nullptr);\n+\n+  StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(entry_jbyte_arraycopy,\n@@ -139,2 +117,1 @@\n-  StubRoutines::_generic_arraycopy   = generate_generic_copy(\"generic_arraycopy\",\n-                                                             entry_jbyte_arraycopy,\n+  StubRoutines::_generic_arraycopy   = generate_generic_copy(entry_jbyte_arraycopy,\n@@ -147,6 +124,6 @@\n-  StubRoutines::_jbyte_fill = generate_fill(T_BYTE, false, \"jbyte_fill\");\n-  StubRoutines::_jshort_fill = generate_fill(T_SHORT, false, \"jshort_fill\");\n-  StubRoutines::_jint_fill = generate_fill(T_INT, false, \"jint_fill\");\n-  StubRoutines::_arrayof_jbyte_fill = generate_fill(T_BYTE, true, \"arrayof_jbyte_fill\");\n-  StubRoutines::_arrayof_jshort_fill = generate_fill(T_SHORT, true, \"arrayof_jshort_fill\");\n-  StubRoutines::_arrayof_jint_fill = generate_fill(T_INT, true, \"arrayof_jint_fill\");\n+  StubRoutines::_jbyte_fill = generate_fill(StubGenStubId::jbyte_fill_id);\n+  StubRoutines::_jshort_fill = generate_fill(StubGenStubId::jshort_fill_id);\n+  StubRoutines::_jint_fill = generate_fill(StubGenStubId::jint_fill_id);\n+  StubRoutines::_arrayof_jbyte_fill = generate_fill(StubGenStubId::arrayof_jbyte_fill_id);\n+  StubRoutines::_arrayof_jshort_fill = generate_fill(StubGenStubId::arrayof_jshort_fill_id);\n+  StubRoutines::_arrayof_jint_fill = generate_fill(StubGenStubId::arrayof_jint_fill_id);\n@@ -154,1 +131,1 @@\n-  StubRoutines::_unsafe_setmemory = generate_unsafe_setmemory(\"unsafe_setmemory\", StubRoutines::_jbyte_fill);\n+  StubRoutines::_unsafe_setmemory = generate_unsafe_setmemory(StubRoutines::_jbyte_fill);\n@@ -510,3 +487,42 @@\n-address StubGenerator::generate_disjoint_copy_avx3_masked(address* entry, const char *name,\n-                                                          int shift, bool aligned, bool is_oop,\n-                                                          bool dest_uninitialized) {\n+address StubGenerator::generate_disjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry) {\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n+  int shift;\n+  bool is_oop;\n+  bool dest_uninitialized;\n+\n+  switch (stub_id) {\n+  case jbyte_disjoint_arraycopy_id:\n+    shift = 0;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case jshort_disjoint_arraycopy_id:\n+    shift = 1;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case jint_disjoint_arraycopy_id:\n+    shift = 2;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case jlong_disjoint_arraycopy_id:\n+    shift = 3;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case oop_disjoint_arraycopy_id:\n+    shift = (UseCompressedOops ? 2 : 3);\n+    is_oop = true;\n+    dest_uninitialized = false;\n+    break;\n+  case oop_disjoint_arraycopy_uninit_id:\n+    shift = (UseCompressedOops ? 2 : 3);\n+    is_oop = true;\n+    dest_uninitialized = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -514,1 +530,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -809,3 +825,42 @@\n-address StubGenerator::generate_conjoint_copy_avx3_masked(address* entry, const char *name, int shift,\n-                                                          address nooverlap_target, bool aligned,\n-                                                          bool is_oop, bool dest_uninitialized) {\n+address StubGenerator::generate_conjoint_copy_avx3_masked(StubGenStubId stub_id, address* entry, address nooverlap_target) {\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n+  int shift;\n+  bool is_oop;\n+  bool dest_uninitialized;\n+\n+  switch (stub_id) {\n+  case jbyte_arraycopy_id:\n+    shift = 0;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case jshort_arraycopy_id:\n+    shift = 1;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case jint_arraycopy_id:\n+    shift = 2;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case jlong_arraycopy_id:\n+    shift = 3;\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case oop_arraycopy_id:\n+    shift = (UseCompressedOops ? 2 : 3);\n+    is_oop = true;\n+    dest_uninitialized = false;\n+    break;\n+  case oop_arraycopy_uninit_id:\n+    shift = (UseCompressedOops ? 2 : 3);\n+    is_oop = true;\n+    dest_uninitialized = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -813,1 +868,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1265,3 +1320,1 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   name    - stub name string\n+\/\/   entry     - location for return of (post-push) entry\n@@ -1280,1 +1333,1 @@\n-\/\/   disjoint_byte_copy_entry is set to the no-overlap entry point\n+\/\/   entry is set to the no-overlap entry point\n@@ -1283,1 +1336,4 @@\n-address StubGenerator::generate_disjoint_byte_copy(bool aligned, address* entry, const char *name) {\n+address StubGenerator::generate_disjoint_byte_copy(address* entry) {\n+  StubGenStubId stub_id = StubGenStubId::jbyte_disjoint_arraycopy_id;\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n@@ -1286,2 +1342,1 @@\n-     return generate_disjoint_copy_avx3_masked(entry, \"jbyte_disjoint_arraycopy_avx3\", 0,\n-                                               aligned, false, false);\n+    return generate_disjoint_copy_avx3_masked(stub_id, entry);\n@@ -1291,1 +1346,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1386,3 +1441,2 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   name    - stub name string\n+\/\/   entry     - location for return of (post-push) entry\n+\/\/   nooverlap_target - entry to branch to if no overlap detected\n@@ -1400,2 +1454,4 @@\n-address StubGenerator::generate_conjoint_byte_copy(bool aligned, address nooverlap_target,\n-                                                   address* entry, const char *name) {\n+address StubGenerator::generate_conjoint_byte_copy(address nooverlap_target, address* entry) {\n+  StubGenStubId stub_id = StubGenStubId::jbyte_arraycopy_id;\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n@@ -1404,2 +1460,1 @@\n-     return generate_conjoint_copy_avx3_masked(entry, \"jbyte_conjoint_arraycopy_avx3\", 0,\n-                                               nooverlap_target, aligned, false, false);\n+    return generate_conjoint_copy_avx3_masked(stub_id, entry, nooverlap_target);\n@@ -1409,1 +1464,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1496,3 +1551,1 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   name    - stub name string\n+\/\/   entry     - location for return of (post-push) entry\n@@ -1511,1 +1564,1 @@\n-\/\/   disjoint_short_copy_entry is set to the no-overlap entry point\n+\/\/   entry is set to the no-overlap entry point\n@@ -1514,1 +1567,4 @@\n-address StubGenerator::generate_disjoint_short_copy(bool aligned, address *entry, const char *name) {\n+address StubGenerator::generate_disjoint_short_copy(address *entry) {\n+  StubGenStubId stub_id = StubGenStubId::jshort_disjoint_arraycopy_id;\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n@@ -1517,2 +1573,1 @@\n-     return generate_disjoint_copy_avx3_masked(entry, \"jshort_disjoint_arraycopy_avx3\", 1,\n-                                               aligned, false, false);\n+    return generate_disjoint_copy_avx3_masked(stub_id, entry);\n@@ -1523,1 +1578,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1610,1 +1665,33 @@\n-address StubGenerator::generate_fill(BasicType t, bool aligned, const char *name) {\n+address StubGenerator::generate_fill(StubGenStubId stub_id) {\n+  BasicType t;\n+  bool aligned;\n+\n+  switch (stub_id) {\n+  case jbyte_fill_id:\n+    t = T_BYTE;\n+    aligned = false;\n+    break;\n+  case jshort_fill_id:\n+    t = T_SHORT;\n+    aligned = false;\n+    break;\n+  case jint_fill_id:\n+    t = T_INT;\n+    aligned = false;\n+    break;\n+  case arrayof_jbyte_fill_id:\n+    t = T_BYTE;\n+    aligned = true;\n+    break;\n+  case arrayof_jshort_fill_id:\n+    t = T_SHORT;\n+    aligned = true;\n+    break;\n+  case arrayof_jint_fill_id:\n+    t = T_INT;\n+    aligned = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -1612,1 +1699,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1639,3 +1726,2 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   name    - stub name string\n+\/\/   entry     - location for return of (post-push) entry\n+\/\/   nooverlap_target - entry to branch to if no overlap detected\n@@ -1653,2 +1739,4 @@\n-address StubGenerator::generate_conjoint_short_copy(bool aligned, address nooverlap_target,\n-                                                    address *entry, const char *name) {\n+address StubGenerator::generate_conjoint_short_copy(address nooverlap_target, address *entry) {\n+  StubGenStubId stub_id = StubGenStubId::jshort_arraycopy_id;\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n@@ -1657,2 +1745,1 @@\n-     return generate_conjoint_copy_avx3_masked(entry, \"jshort_conjoint_arraycopy_avx3\", 1,\n-                                               nooverlap_target, aligned, false, false);\n+    return generate_conjoint_copy_avx3_masked(stub_id, entry, nooverlap_target);\n@@ -1661,0 +1748,1 @@\n+\n@@ -1662,1 +1750,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1741,4 +1829,3 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   is_oop  - true => oop array, so generate store check code\n-\/\/   name    - stub name string\n+\/\/   stub_id   - unqiue id for stub to generate\n+\/\/   entry     - location for return of (post-push) entry\n+\/\/   is_oop    - true => oop array, so generate store check code\n@@ -1759,2 +1846,24 @@\n-address StubGenerator::generate_disjoint_int_oop_copy(bool aligned, bool is_oop, address* entry,\n-                                                      const char *name, bool dest_uninitialized) {\n+address StubGenerator::generate_disjoint_int_oop_copy(StubGenStubId stub_id, address* entry) {\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n+  bool is_oop;\n+  bool dest_uninitialized;\n+  switch (stub_id) {\n+  case StubGenStubId::jint_disjoint_arraycopy_id:\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_disjoint_arraycopy_id:\n+    assert(UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_disjoint_arraycopy_uninit_id:\n+    assert(UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -1764,2 +1873,1 @@\n-     return generate_disjoint_copy_avx3_masked(entry, \"jint_disjoint_arraycopy_avx3\", 2,\n-                                               aligned, is_oop, dest_uninitialized);\n+    return generate_disjoint_copy_avx3_masked(stub_id, entry);\n@@ -1770,1 +1878,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1856,2 +1964,2 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n+\/\/   entry     - location for return of (post-push) entry\n+\/\/   nooverlap_target - entry to branch to if no overlap detected\n@@ -1859,1 +1967,0 @@\n-\/\/   name    - stub name string\n@@ -1870,3 +1977,24 @@\n-address StubGenerator::generate_conjoint_int_oop_copy(bool aligned, bool is_oop, address nooverlap_target,\n-                                                      address *entry, const char *name,\n-                                                      bool dest_uninitialized) {\n+address StubGenerator::generate_conjoint_int_oop_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n+  bool is_oop;\n+  bool dest_uninitialized;\n+  switch (stub_id) {\n+  case StubGenStubId::jint_arraycopy_id:\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_arraycopy_id:\n+    assert(UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_arraycopy_uninit_id:\n+    assert(UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -1876,2 +2004,1 @@\n-     return generate_conjoint_copy_avx3_masked(entry, \"jint_conjoint_arraycopy_avx3\", 2,\n-                                               nooverlap_target, aligned, is_oop, dest_uninitialized);\n+    return generate_conjoint_copy_avx3_masked(stub_id, entry, nooverlap_target);\n@@ -1880,0 +2007,1 @@\n+\n@@ -1881,1 +2009,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -1971,4 +2099,1 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-\/\/             ignored\n-\/\/   is_oop  - true => oop array, so generate store check code\n-\/\/   name    - stub name string\n+\/\/   entry     - location for return of (post-push) entry\n@@ -1985,2 +2110,24 @@\n-address StubGenerator::generate_disjoint_long_oop_copy(bool aligned, bool is_oop, address *entry,\n-                                                       const char *name, bool dest_uninitialized) {\n+address StubGenerator::generate_disjoint_long_oop_copy(StubGenStubId stub_id, address *entry) {\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n+  bool is_oop;\n+  bool dest_uninitialized;\n+  switch (stub_id) {\n+  case StubGenStubId::jlong_disjoint_arraycopy_id:\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_disjoint_arraycopy_id:\n+    assert(!UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_disjoint_arraycopy_uninit_id:\n+    assert(!UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -1990,2 +2137,1 @@\n-     return generate_disjoint_copy_avx3_masked(entry, \"jlong_disjoint_arraycopy_avx3\", 3,\n-                                               aligned, is_oop, dest_uninitialized);\n+    return generate_disjoint_copy_avx3_masked(stub_id, entry);\n@@ -1994,0 +2140,1 @@\n+\n@@ -1995,1 +2142,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -2087,2 +2234,2 @@\n-\/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-\/\/             ignored\n+\/\/   entry     - location for return of (post-push) entry\n+\/\/   nooverlap_target - entry to branch to if no overlap detected\n@@ -2090,1 +2237,0 @@\n-\/\/   name    - stub name string\n@@ -2097,3 +2243,24 @@\n-address StubGenerator::generate_conjoint_long_oop_copy(bool aligned, bool is_oop, address nooverlap_target,\n-                                                       address *entry, const char *name,\n-                                                       bool dest_uninitialized) {\n+address StubGenerator::generate_conjoint_long_oop_copy(StubGenStubId stub_id, address nooverlap_target, address *entry) {\n+  \/\/ aligned is always false -- x86_64 always uses the unaligned code\n+  const bool aligned = false;\n+  bool is_oop;\n+  bool dest_uninitialized;\n+  switch (stub_id) {\n+  case StubGenStubId::jlong_arraycopy_id:\n+    is_oop = false;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_arraycopy_id:\n+    assert(!UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::oop_arraycopy_uninit_id:\n+    assert(!UseCompressedOops, \"inconsistent oop copy size!\");\n+    is_oop = true;\n+    dest_uninitialized = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -2103,2 +2270,1 @@\n-     return generate_conjoint_copy_avx3_masked(entry, \"jlong_conjoint_arraycopy_avx3\", 3,\n-                                               nooverlap_target, aligned, is_oop, dest_uninitialized);\n+    return generate_conjoint_copy_avx3_masked(stub_id, entry, nooverlap_target);\n@@ -2107,0 +2273,1 @@\n+\n@@ -2108,1 +2275,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -2227,1 +2394,13 @@\n-address StubGenerator::generate_checkcast_copy(const char *name, address *entry, bool dest_uninitialized) {\n+address StubGenerator::generate_checkcast_copy(StubGenStubId stub_id, address *entry) {\n+\n+  bool dest_uninitialized;\n+  switch (stub_id) {\n+  case StubGenStubId::checkcast_arraycopy_id:\n+    dest_uninitialized = false;\n+    break;\n+  case StubGenStubId::checkcast_arraycopy_uninit_id:\n+    dest_uninitialized = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n@@ -2257,1 +2436,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n@@ -2433,2 +2612,1 @@\n-address StubGenerator::generate_unsafe_copy(const char *name,\n-                                            address byte_copy_entry, address short_copy_entry,\n+address StubGenerator::generate_unsafe_copy(address byte_copy_entry, address short_copy_entry,\n@@ -2448,1 +2626,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubGenStubId stub_id = StubGenStubId::unsafe_arraycopy_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2581,2 +2760,1 @@\n-address StubGenerator::generate_unsafe_setmemory(const char *name,\n-                                                 address unsafe_byte_fill) {\n+address StubGenerator::generate_unsafe_setmemory(address unsafe_byte_fill) {\n@@ -2584,1 +2762,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubGenStubId stub_id = StubGenStubId::unsafe_setmemory_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -2727,2 +2906,1 @@\n-address StubGenerator::generate_generic_copy(const char *name,\n-                                             address byte_copy_entry, address short_copy_entry,\n+address StubGenerator::generate_generic_copy(address byte_copy_entry, address short_copy_entry,\n@@ -2754,1 +2932,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubGenStubId stub_id = StubGenStubId::generic_arraycopy_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":324,"deletions":145,"binary":false,"changes":469,"status":"modified"},{"patch":"@@ -115,1 +115,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+  StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -303,1 +304,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+  StubGenStubId stub_id = StubGenStubId::chacha20Block_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_chacha.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+ *  Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n@@ -176,1 +176,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmCos\");\n+  StubGenStubId stub_id = StubGenStubId::dcos_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_cos.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n@@ -168,1 +168,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmExp\");\n+  StubGenStubId stub_id = StubGenStubId::dexp_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_exp.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2023, 2024, Intel Corporation. All rights reserved.\n@@ -76,1 +76,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmFmod\");\n+  StubGenStubId stub_id = StubGenStubId::fmod_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_fmod.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -85,1 +85,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"ghash_processBlocks\");\n+  StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -221,1 +222,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"ghash_processBlocks\");\n+  StubGenStubId stub_id = StubGenStubId::ghash_processBlocks_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_ghash.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n@@ -179,1 +179,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmLog\");\n+  StubGenStubId stub_id = StubGenStubId::dlog_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -517,1 +518,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmLog10\");\n+  StubGenStubId stub_id = StubGenStubId::dlog10_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_log.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -913,1 +913,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"poly1305_processBlocks\");\n+  StubGenStubId stub_id = StubGenStubId::poly1305_processBlocks_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly1305.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -240,1 +240,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"intpoly_montgomeryMult_P256\");\n+  StubGenStubId stub_id = StubGenStubId::intpoly_montgomeryMult_P256_id;\n+  StubCodeMark mark(this, stub_id);\n@@ -298,1 +299,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"intpoly_assign\");\n+  StubGenStubId stub_id = StubGenStubId::intpoly_assign_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly_mont.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n@@ -762,1 +762,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmPow\");\n+  StubGenStubId stub_id = StubGenStubId::dpow_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_pow.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-    StubRoutines::_sha3_implCompress   = generate_sha3_implCompress(false,\"sha3_implCompress\");\n-    StubRoutines::_sha3_implCompressMB = generate_sha3_implCompress(true, \"sha3_implCompressMB\");\n+    StubRoutines::_sha3_implCompress   = generate_sha3_implCompress(StubGenStubId::sha3_implCompress_id);\n+    StubRoutines::_sha3_implCompressMB = generate_sha3_implCompress(StubGenStubId::sha3_implCompressMB_id);\n@@ -98,1 +98,13 @@\n-address StubGenerator::generate_sha3_implCompress(bool multiBlock, const char *name) {\n+address StubGenerator::generate_sha3_implCompress(StubGenStubId stub_id) {\n+  bool multiBlock;\n+  switch(stub_id) {\n+  case sha3_implCompress_id:\n+    multiBlock = false;\n+    break;\n+  case sha3_implCompressMB_id:\n+    multiBlock = true;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -100,1 +112,1 @@\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_sha3.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n@@ -183,1 +183,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmSin\");\n+  StubGenStubId stub_id = StubGenStubId::dsin_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_sin.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Copyright (c) 2016, 2024, Intel Corporation. All rights reserved.\n@@ -458,1 +458,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmTan\");\n+  StubGenStubId stub_id = StubGenStubId::dtan_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_tan.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -305,1 +305,2 @@\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmTanh\");\n+  StubGenStubId stub_id = StubGenStubId::dtanh_id;\n+  StubCodeMark mark(this, stub_id);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_tanh.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,3 +35,13 @@\n-address StubRoutines::x86::_verify_mxcsr_entry = nullptr;\n-address StubRoutines::x86::_upper_word_mask_addr = nullptr;\n-address StubRoutines::x86::_shuffle_byte_flip_mask_addr = nullptr;\n+\/\/ define fields for arch-specific entries\n+\n+#define DEFINE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = nullptr;\n+\n+#define DEFINE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  address StubRoutines:: arch :: STUB_FIELD_NAME(field_name)  = CAST_FROM_FN_PTR(address, init_function);\n+\n+STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY, DEFINE_ARCH_ENTRY_INIT)\n+\n+#undef DEFINE_ARCH_ENTRY_INIT\n+#undef DEFINE_ARCH_ENTRY\n+\n@@ -39,24 +49,0 @@\n-address StubRoutines::x86::_vector_short_to_byte_mask = nullptr;\n-address StubRoutines::x86::_vector_int_to_byte_mask = nullptr;\n-address StubRoutines::x86::_vector_int_to_short_mask = nullptr;\n-address StubRoutines::x86::_vector_all_bits_set = nullptr;\n-address StubRoutines::x86::_vector_byte_shuffle_mask = nullptr;\n-address StubRoutines::x86::_vector_int_mask_cmp_bits = nullptr;\n-address StubRoutines::x86::_vector_short_shuffle_mask = nullptr;\n-address StubRoutines::x86::_vector_int_shuffle_mask = nullptr;\n-address StubRoutines::x86::_vector_long_shuffle_mask = nullptr;\n-address StubRoutines::x86::_vector_float_sign_mask = nullptr;\n-address StubRoutines::x86::_vector_float_sign_flip = nullptr;\n-address StubRoutines::x86::_vector_double_sign_mask = nullptr;\n-address StubRoutines::x86::_vector_double_sign_flip = nullptr;\n-address StubRoutines::x86::_vector_byte_perm_mask = nullptr;\n-address StubRoutines::x86::_vector_long_sign_mask = nullptr;\n-address StubRoutines::x86::_vector_iota_indices = nullptr;\n-address StubRoutines::x86::_vector_reverse_bit_lut = nullptr;\n-address StubRoutines::x86::_vector_reverse_byte_perm_mask_long = nullptr;\n-address StubRoutines::x86::_vector_reverse_byte_perm_mask_int = nullptr;\n-address StubRoutines::x86::_vector_reverse_byte_perm_mask_short = nullptr;\n-address StubRoutines::x86::_vector_popcount_lut = nullptr;\n-address StubRoutines::x86::_vector_count_leading_zeros_lut = nullptr;\n-address StubRoutines::x86::_vector_32_bit_mask = nullptr;\n-address StubRoutines::x86::_vector_64_bit_mask = nullptr;\n@@ -66,22 +52,0 @@\n-address StubRoutines::x86::_pshuffle_byte_flip_mask_addr_sha512 = nullptr;\n-\/\/ Base64 masks\n-address StubRoutines::x86::_encoding_table_base64 = nullptr;\n-address StubRoutines::x86::_shuffle_base64 = nullptr;\n-address StubRoutines::x86::_avx2_shuffle_base64 = nullptr;\n-address StubRoutines::x86::_avx2_input_mask_base64 = nullptr;\n-address StubRoutines::x86::_avx2_lut_base64 = nullptr;\n-address StubRoutines::x86::_avx2_decode_tables_base64 = nullptr;\n-address StubRoutines::x86::_avx2_decode_lut_tables_base64 = nullptr;\n-address StubRoutines::x86::_lookup_lo_base64 = nullptr;\n-address StubRoutines::x86::_lookup_hi_base64 = nullptr;\n-address StubRoutines::x86::_lookup_lo_base64url = nullptr;\n-address StubRoutines::x86::_lookup_hi_base64url = nullptr;\n-address StubRoutines::x86::_pack_vec_base64 = nullptr;\n-address StubRoutines::x86::_join_0_1_base64 = nullptr;\n-address StubRoutines::x86::_join_1_2_base64 = nullptr;\n-address StubRoutines::x86::_join_2_3_base64 = nullptr;\n-address StubRoutines::x86::_decoding_table_base64 = nullptr;\n-address StubRoutines::x86::_compress_perm_table32 = nullptr;\n-address StubRoutines::x86::_compress_perm_table64 = nullptr;\n-address StubRoutines::x86::_expand_perm_table32 = nullptr;\n-address StubRoutines::x86::_expand_perm_table64 = nullptr;\n@@ -89,1 +53,0 @@\n-address StubRoutines::x86::_pshuffle_byte_flip_mask_addr = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":13,"deletions":50,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -34,0 +34,5 @@\n+\/\/ emit enum used to size per-blob code buffers\n+\n+#define DEFINE_BLOB_SIZE(blob_name, size) \\\n+  _ ## blob_name ## _code_size = size,\n+\n@@ -35,7 +40,1 @@\n-  \/\/ simply increase sizes if too small (assembler will crash if too small)\n-  _initial_stubs_code_size      = 20000 WINDOWS_ONLY(+1000),\n-  _continuation_stubs_code_size =  1000 LP64_ONLY(+2000),\n-  \/\/ AVX512 intrinsics add more code in 64-bit VM,\n-  \/\/ Windows have more code to save\/restore registers\n-  _compiler_stubs_code_size     = 20000 LP64_ONLY(+47000) WINDOWS_ONLY(+2000),\n-  _final_stubs_code_size        = 10000 LP64_ONLY(+20000) WINDOWS_ONLY(+22000) ZGC_ONLY(+20000)\n+  STUBGEN_ARCH_BLOBS_DO(DEFINE_BLOB_SIZE)\n@@ -44,0 +43,2 @@\n+#undef DEFINE_BLOB_SIZE\n+\n@@ -48,8 +49,1 @@\n-#ifdef _LP64\n- private:\n-  static address _get_previous_sp_entry;\n-\n-  static address _f2i_fixup;\n-  static address _f2l_fixup;\n-  static address _d2i_fixup;\n-  static address _d2l_fixup;\n+  \/\/ declare fields for arch-specific entries\n@@ -57,8 +51,2 @@\n-  static address _float_sign_mask;\n-  static address _float_sign_flip;\n-  static address _double_sign_mask;\n-  static address _double_sign_flip;\n-  static address _compress_perm_table32;\n-  static address _compress_perm_table64;\n-  static address _expand_perm_table32;\n-  static address _expand_perm_table64;\n+#define DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address STUB_FIELD_NAME(field_name) ;\n@@ -66,1 +54,2 @@\n- public:\n+#define DECLARE_ARCH_ENTRY_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DECLARE_ARCH_ENTRY(arch, blob_name, stub_name, field_name, getter_name)\n@@ -68,3 +57,2 @@\n-  static address get_previous_sp_entry() {\n-    return _get_previous_sp_entry;\n-  }\n+private:\n+  STUBGEN_ARCH_ENTRIES_DO(DECLARE_ARCH_ENTRY, DECLARE_ARCH_ENTRY_INIT)\n@@ -72,3 +60,2 @@\n-  static address f2i_fixup() {\n-    return _f2i_fixup;\n-  }\n+#undef DECLARE_ARCH_ENTRY_INIT\n+#undef DECLARE_ARCH_ENTRY\n@@ -76,3 +63,0 @@\n-  static address f2l_fixup() {\n-    return _f2l_fixup;\n-  }\n@@ -80,3 +64,1 @@\n-  static address d2i_fixup() {\n-    return _d2i_fixup;\n-  }\n+  \/\/ define getters for arch-specific entries\n@@ -84,3 +66,2 @@\n-  static address d2l_fixup() {\n-    return _d2l_fixup;\n-  }\n+#define DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name) \\\n+  static address getter_name() { return STUB_FIELD_NAME(field_name); }\n@@ -88,3 +69,2 @@\n-  static address float_sign_mask() {\n-    return _float_sign_mask;\n-  }\n+#define DEFINE_ARCH_ENTRY_GETTER_INIT(arch, blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DEFINE_ARCH_ENTRY_GETTER(arch, blob_name, stub_name, field_name, getter_name)\n@@ -92,3 +72,2 @@\n-  static address float_sign_flip() {\n-    return _float_sign_flip;\n-  }\n+public:\n+  STUBGEN_ARCH_ENTRIES_DO(DEFINE_ARCH_ENTRY_GETTER, DEFINE_ARCH_ENTRY_GETTER_INIT)\n@@ -96,3 +75,2 @@\n-  static address double_sign_mask() {\n-    return _double_sign_mask;\n-  }\n+#undef DEFINE_ARCH_ENTRY_GETTER_INIT\n+#undef DEFINE_ARCH_GETTER_ENTRY\n@@ -100,3 +78,0 @@\n-  static address double_sign_flip() {\n-    return _double_sign_flip;\n-  }\n@@ -104,6 +79,1 @@\n-#else \/\/ !LP64\n-\n- private:\n-  static address _verify_fpu_cntrl_wrd_entry;\n-  static address _d2i_wrapper;\n-  static address _d2l_wrapper;\n+#ifndef _LP64\n@@ -118,4 +88,0 @@\n- public:\n-  static address verify_fpu_cntrl_wrd_entry() { return _verify_fpu_cntrl_wrd_entry; }\n-  static address d2i_wrapper()                { return _d2i_wrapper; }\n-  static address d2l_wrapper()                { return _d2l_wrapper; }\n@@ -136,3 +102,0 @@\n-\n-  static address _verify_mxcsr_entry;\n-\n@@ -152,6 +115,0 @@\n-\n-  \/\/ upper word mask for sha1\n-  static address _upper_word_mask_addr;\n-  \/\/ byte flip mask for sha1\n-  static address _shuffle_byte_flip_mask_addr;\n-\n@@ -161,24 +118,0 @@\n-  static address _vector_short_to_byte_mask;\n-  static address _vector_float_sign_mask;\n-  static address _vector_float_sign_flip;\n-  static address _vector_double_sign_mask;\n-  static address _vector_double_sign_flip;\n-  static address _vector_long_sign_mask;\n-  static address _vector_all_bits_set;\n-  static address _vector_int_mask_cmp_bits;\n-  static address _vector_byte_perm_mask;\n-  static address _vector_int_to_byte_mask;\n-  static address _vector_int_to_short_mask;\n-  static address _vector_32_bit_mask;\n-  static address _vector_64_bit_mask;\n-  static address _vector_int_shuffle_mask;\n-  static address _vector_byte_shuffle_mask;\n-  static address _vector_short_shuffle_mask;\n-  static address _vector_long_shuffle_mask;\n-  static address _vector_iota_indices;\n-  static address _vector_popcount_lut;\n-  static address _vector_count_leading_zeros_lut;\n-  static address _vector_reverse_bit_lut;\n-  static address _vector_reverse_byte_perm_mask_long;\n-  static address _vector_reverse_byte_perm_mask_int;\n-  static address _vector_reverse_byte_perm_mask_short;\n@@ -190,19 +123,0 @@\n-  \/\/ byte flip mask for sha512\n-  static address _pshuffle_byte_flip_mask_addr_sha512;\n-  \/\/ Masks for base64\n-  static address _encoding_table_base64;\n-  static address _shuffle_base64;\n-  static address _avx2_shuffle_base64;\n-  static address _avx2_input_mask_base64;\n-  static address _avx2_lut_base64;\n-  static address _avx2_decode_tables_base64;\n-  static address _avx2_decode_lut_tables_base64;\n-  static address _lookup_lo_base64;\n-  static address _lookup_hi_base64;\n-  static address _lookup_lo_base64url;\n-  static address _lookup_hi_base64url;\n-  static address _pack_vec_base64;\n-  static address _join_0_1_base64;\n-  static address _join_1_2_base64;\n-  static address _join_2_3_base64;\n-  static address _decoding_table_base64;\n@@ -210,2 +124,0 @@\n-  \/\/ byte flip mask for sha256\n-  static address _pshuffle_byte_flip_mask_addr;\n@@ -218,1 +130,0 @@\n-  static address verify_mxcsr_entry()    { return _verify_mxcsr_entry; }\n@@ -226,2 +137,0 @@\n-  static address upper_word_mask_addr() { return _upper_word_mask_addr; }\n-  static address shuffle_byte_flip_mask_addr() { return _shuffle_byte_flip_mask_addr; }\n@@ -229,96 +138,0 @@\n-  static address method_entry_barrier() { return _method_entry_barrier; }\n-\n-  static address vector_short_to_byte_mask() {\n-    return _vector_short_to_byte_mask;\n-  }\n-  static address vector_float_sign_mask() {\n-    return _vector_float_sign_mask;\n-  }\n-\n-  static address vector_float_sign_flip() {\n-    return _vector_float_sign_flip;\n-  }\n-\n-  static address vector_double_sign_mask() {\n-    return _vector_double_sign_mask;\n-  }\n-\n-  static address vector_double_sign_flip() {\n-    return _vector_double_sign_flip;\n-  }\n-\n-  static address vector_all_bits_set() {\n-    return _vector_all_bits_set;\n-  }\n-\n-  static address vector_int_mask_cmp_bits() {\n-    return _vector_int_mask_cmp_bits;\n-  }\n-\n-  static address vector_byte_perm_mask() {\n-    return _vector_byte_perm_mask;\n-  }\n-\n-  static address vector_int_to_byte_mask() {\n-    return _vector_int_to_byte_mask;\n-  }\n-\n-  static address vector_int_to_short_mask() {\n-    return _vector_int_to_short_mask;\n-  }\n-\n-  static address vector_32_bit_mask() {\n-    return _vector_32_bit_mask;\n-  }\n-\n-  static address vector_64_bit_mask() {\n-    return _vector_64_bit_mask;\n-  }\n-\n-  static address vector_int_shuffle_mask() {\n-    return _vector_int_shuffle_mask;\n-  }\n-\n-  static address vector_byte_shuffle_mask() {\n-    return _vector_byte_shuffle_mask;\n-  }\n-\n-  static address vector_short_shuffle_mask() {\n-    return _vector_short_shuffle_mask;\n-  }\n-\n-  static address vector_long_shuffle_mask() {\n-    return _vector_long_shuffle_mask;\n-  }\n-\n-  static address vector_long_sign_mask() {\n-    return _vector_long_sign_mask;\n-  }\n-\n-  static address vector_iota_indices() {\n-    return _vector_iota_indices;\n-  }\n-\n-  static address vector_count_leading_zeros_lut() {\n-    return _vector_count_leading_zeros_lut;\n-  }\n-\n-  static address vector_reverse_bit_lut() {\n-    return _vector_reverse_bit_lut;\n-  }\n-\n-  static address vector_reverse_byte_perm_mask_long() {\n-    return _vector_reverse_byte_perm_mask_long;\n-  }\n-\n-  static address vector_reverse_byte_perm_mask_int() {\n-    return _vector_reverse_byte_perm_mask_int;\n-  }\n-\n-  static address vector_reverse_byte_perm_mask_short() {\n-    return _vector_reverse_byte_perm_mask_short;\n-  }\n-\n-  static address vector_popcount_lut() {\n-    return _vector_popcount_lut;\n-  }\n@@ -328,21 +141,0 @@\n-  static address pshuffle_byte_flip_mask_addr_sha512() { return _pshuffle_byte_flip_mask_addr_sha512; }\n-  static address base64_encoding_table_addr() { return _encoding_table_base64; }\n-  static address base64_shuffle_addr() { return _shuffle_base64; }\n-  static address base64_avx2_shuffle_addr() { return _avx2_shuffle_base64; }\n-  static address base64_avx2_input_mask_addr() { return _avx2_input_mask_base64; }\n-  static address base64_avx2_lut_addr() { return _avx2_lut_base64; }\n-  static address base64_vbmi_lookup_lo_addr() { return _lookup_lo_base64; }\n-  static address base64_vbmi_lookup_hi_addr() { return _lookup_hi_base64; }\n-  static address base64_vbmi_lookup_lo_url_addr() { return _lookup_lo_base64url; }\n-  static address base64_vbmi_lookup_hi_url_addr() { return _lookup_hi_base64url; }\n-  static address base64_vbmi_pack_vec_addr() { return _pack_vec_base64; }\n-  static address base64_vbmi_join_0_1_addr() { return _join_0_1_base64; }\n-  static address base64_vbmi_join_1_2_addr() { return _join_1_2_base64; }\n-  static address base64_vbmi_join_2_3_addr() { return _join_2_3_base64; }\n-  static address base64_decoding_table_addr() { return _decoding_table_base64; }\n-  static address base64_AVX2_decode_tables_addr() { return _avx2_decode_tables_base64; }\n-  static address base64_AVX2_decode_LUT_tables_addr() { return _avx2_decode_lut_tables_base64; }\n-  static address compress_perm_table32() { return _compress_perm_table32; }\n-  static address compress_perm_table64() { return _compress_perm_table64; }\n-  static address expand_perm_table32() { return _expand_perm_table32; }\n-  static address expand_perm_table64() { return _expand_perm_table64; }\n@@ -350,1 +142,1 @@\n-  static address pshuffle_byte_flip_mask_addr() { return _pshuffle_byte_flip_mask_addr; }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":28,"deletions":236,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -33,5 +33,0 @@\n-address StubRoutines::x86::_verify_fpu_cntrl_wrd_entry = nullptr;\n-\n-address StubRoutines::x86::_d2i_wrapper = nullptr;\n-address StubRoutines::x86::_d2l_wrapper = nullptr;\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86_32.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,11 +35,0 @@\n-\n-address StubRoutines::x86::_get_previous_sp_entry = nullptr;\n-\n-address StubRoutines::x86::_f2i_fixup = nullptr;\n-address StubRoutines::x86::_f2l_fixup = nullptr;\n-address StubRoutines::x86::_d2i_fixup = nullptr;\n-address StubRoutines::x86::_d2l_fixup = nullptr;\n-address StubRoutines::x86::_float_sign_mask = nullptr;\n-address StubRoutines::x86::_float_sign_flip = nullptr;\n-address StubRoutines::x86::_double_sign_mask = nullptr;\n-address StubRoutines::x86::_double_sign_flip = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86_64.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ZERO_STUBDECLARATIONS_HPP\n+#define CPU_ZERO_STUBDECLARATIONS_HPP\n+\n+#define STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub,                          \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry,                    \\\n+                                      do_arch_entry_init)               \\\n+  do_arch_blob(initial, 0)                                              \\\n+\n+\n+#define STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,                     \\\n+                                           do_arch_blob,                \\\n+                                           do_arch_entry,               \\\n+                                           do_arch_entry_init)          \\\n+  do_arch_blob(continuation, 0)                                         \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,                         \\\n+                                       do_arch_blob,                    \\\n+                                       do_arch_entry,                   \\\n+                                       do_arch_entry_init)              \\\n+  do_arch_blob(compiler, 0)                                             \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,                            \\\n+                                    do_arch_blob,                       \\\n+                                    do_arch_entry,                      \\\n+                                    do_arch_entry_init)                 \\\n+  do_arch_blob(final, 0)                                                \\\n+\n+\n+#endif \/\/ CPU_ZERO_STUBDECLARATIONS_HPP\n","filename":"src\/hotspot\/cpu\/zero\/stubDeclarations_zero.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -182,2 +182,0 @@\n-    \/\/ Generates all stubs and initializes the entry points\n-\n@@ -202,2 +200,3 @@\n-  void generate_final_stubs() {\n-    \/\/ Generates all stubs and initializes the entry points\n+  void generate_continuation_stubs() {\n+    \/\/ do nothing\n+  }\n@@ -205,0 +204,5 @@\n+  void generate_compiler_stubs() {\n+    \/\/ do nothing\n+  }\n+\n+  void generate_final_stubs() {\n@@ -211,2 +215,3 @@\n-  StubGenerator(CodeBuffer* code, StubsKind kind) : StubCodeGenerator(code) {\n-    if (kind == Initial_stubs) {\n+  StubGenerator(CodeBuffer* code, StubGenBlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+    switch(blob_id) {\n+    case initial_id:\n@@ -214,1 +219,8 @@\n-    } else if (kind == Final_stubs) {\n+      break;\n+     case continuation_id:\n+       generate_continuation_stubs();\n+      break;\n+    case compiler_id:\n+       \/\/ do nothing\n+      break;\n+    case final_id:\n@@ -216,1 +228,5 @@\n-    }\n+      break;\n+    default:\n+      fatal(\"unexpected blob id: %d\", blob_id);\n+      break;\n+    };\n@@ -220,2 +236,2 @@\n-void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind) {\n-  StubGenerator g(code, kind);\n+void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id) {\n+  StubGenerator g(code, blob_id);\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,0 +2,3 @@\n+<<<<<<< HEAD\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+=======\n@@ -3,0 +6,1 @@\n+>>>>>>> master\n@@ -30,0 +34,2 @@\n+\n+\/\/ zero has no arch-specific stubs nor any associated entries\n","filename":"src\/hotspot\/cpu\/zero\/stubRoutines_zero.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,8 +42,12 @@\n-  enum platform_dependent_constants {\n-    \/\/ The assembler will fail with a guarantee if these are too small.\n-    \/\/ Simply increase them if that happens.\n-    _initial_stubs_code_size      = 0,\n-    _continuation_stubs_code_size = 0,\n-    _compiler_stubs_code_size     = 0,\n-    _final_stubs_code_size        = 0\n-  };\n+\/\/ emit enum used to size per-blob code buffers\n+\n+#define DEFINE_BLOB_SIZE(blob_name, size) \\\n+  _ ## blob_name ## _code_size = size,\n+\n+enum platform_dependent_constants {\n+  STUBGEN_ARCH_BLOBS_DO(DEFINE_BLOB_SIZE)\n+};\n+\n+#undef DEFINE_BLOB_SIZE\n+\n+\/\/ zero has no arch-specific stubs nor any associated entries\n","filename":"src\/hotspot\/cpu\/zero\/stubRoutines_zero.hpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -540,1 +540,1 @@\n-  load_long_func_t func = CAST_TO_FN_PTR(load_long_func_t, StubRoutines::atomic_load_long_entry());\n+  load_long_func_t func = CAST_TO_FN_PTR(load_long_func_t, StubRoutines::Arm::atomic_load_long_entry());\n@@ -554,1 +554,1 @@\n-  store_long_func_t func = CAST_TO_FN_PTR(store_long_func_t, StubRoutines::atomic_store_long_entry());\n+  store_long_func_t func = CAST_TO_FN_PTR(store_long_func_t, StubRoutines::Arm::atomic_store_long_entry());\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -71,0 +72,7 @@\n+  _blob_id = StubGenBlobId::NO_BLOBID;\n+  _print_code = PrintStubCode || print_code;\n+}\n+\n+StubCodeGenerator::StubCodeGenerator(CodeBuffer* code, StubGenBlobId blob_id, bool print_code) {\n+  _masm = new MacroAssembler(code);\n+  _blob_id = blob_id;\n@@ -113,0 +121,5 @@\n+#ifdef ASSERT\n+void StubCodeGenerator::verify_stub(StubGenStubId stub_id) {\n+  assert(StubRoutines::stub_to_blob(stub_id) == blob_id(), \"wrong blob %s for generation of stub %s\", StubRoutines::get_blob_name(blob_id()), StubRoutines::get_stub_name(stub_id));\n+}\n+#endif\n@@ -124,0 +137,6 @@\n+StubCodeMark::StubCodeMark(StubCodeGenerator* cgen, StubGenStubId stub_id) : StubCodeMark(cgen, \"StubRoutines\", StubRoutines::get_stub_name(stub_id)) {\n+#ifdef ASSERT\n+  cgen->verify_stub(stub_id);\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,0 +99,5 @@\n+\/\/ forward declare blob and stub id enums\n+\n+enum StubGenBlobId : int;\n+enum StubGenStubId : int;\n+\n@@ -105,1 +110,1 @@\n-\n+  StubGenBlobId _blob_id;\n@@ -111,0 +116,1 @@\n+  StubCodeGenerator(CodeBuffer* code, StubGenBlobId blob_id, bool print_code = false);\n@@ -114,0 +120,1 @@\n+  StubGenBlobId blob_id()                        { return _blob_id; }\n@@ -118,14 +125,3 @@\n-  enum StubsKind {\n-    Initial_stubs,       \/\/ Stubs used by Runtime, Interpreter and compiled code.\n-                         \/\/ Have to be generated very early during VM startup.\n-\n-    Continuation_stubs,  \/\/ Stubs used by virtual threads.\n-                         \/\/ Generated after GC barriers initialization but before\n-                         \/\/ Interpreter initialization.\n-\n-    Compiler_stubs,      \/\/ Intrinsics and other stubs used only by compiled code.\n-                         \/\/ Can be generated by compiler (C2\/JVMCI) thread based on\n-                         \/\/ DelayCompilerStubsGeneration flag.\n-\n-    Final_stubs          \/\/ The rest of stubs. Generated at the end of VM init.\n-  };\n+#ifdef ASSERT\n+  void verify_stub(StubGenStubId stub_id);\n+#endif\n@@ -134,1 +130,0 @@\n-\n@@ -147,0 +142,1 @@\n+  StubCodeMark(StubCodeGenerator* cgen, StubGenStubId stub_id);\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.hpp","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n@@ -50,0 +50,2 @@\n+\/\/ client macro to operate on shared stubs\n+\/\/\n@@ -76,0 +78,2 @@\n+\/\/ client macro to operate on c1 stubs\n+\/\/\n@@ -138,0 +142,2 @@\n+\/\/ client macro to operate on c2 stubs\n+\/\/\n@@ -168,1 +174,748 @@\n-\/\/ generate a stub or blob id enum tag from a name\n+\/\/ Stub Generator Blobs and Stubs Overview\n+\/\/\n+\/\/ StubGenerator stubs do not require their own individual blob. They\n+\/\/ are generated in batches into one of four distinct BufferBlobs:\n+\/\/\n+\/\/ 1) Initial stubs\n+\/\/ 2) Continuation stubs\n+\/\/ 3) Compiler stubs\n+\/\/ 4) Final stubs\n+\/\/\n+\/\/ Creation of each successive BufferBlobs is staged to ensure that\n+\/\/ specific VM subsystems required by those stubs are suitably\n+\/\/ initialized before generated code attempt to reference data or\n+\/\/ addresses exported by those subsystems. The sequencing of\n+\/\/ initialization must be taken into account when adding a new stub\n+\/\/ declaration.\n+\/\/\n+\/\/ StubGenerator stubs are declared using template macros, one set of\n+\/\/ declarations per blob (see below), with arch-specific stubs for any\n+\/\/ gven blob declared after generic stubs for that blob. Blobs are\n+\/\/ created in a fixed order during startup, which is reflected in the\n+\/\/ order of the declaration set. Stubs within a blob are currently\n+\/\/ created in an order determined by the arch-specific generator code\n+\/\/ which may not reflect the order of stub declarations. It is not\n+\/\/ straightforward to enforce a strict ordering. not least because\n+\/\/ arch-specific stub creation may need to be interleaved with generic\n+\/\/ stub creation.\n+\/\/\n+\/\/ Blob and stub declaration templates are used to generate a variety\n+\/\/ of C++ code elements needed to manage stubs.\n+\/\/\n+\/\/ Blob identifiers:\n+\/\/\n+\/\/ public enum StubGenBlobId is generated to identify each of the\n+\/\/ StubGenerator blobs in blob declaration order. This enum is\n+\/\/ provided for use by client code to identify a specific blob. For a\n+\/\/ blob declared with name <blob_name> the associated enum value is\n+\/\/ StubGenBlobId::<blob_name>_id.\n+\/\/\n+\/\/ Global stub identifiers:\n+\/\/\n+\/\/ public enum StubGenStubId is generated to identify all declared\n+\/\/ stubs across all blobs, sorted first by blob declaration order and\n+\/\/ then within a blob by stub declaration order, generic stubs before\n+\/\/ arch-specific stubs. This enum is provided for use by client code\n+\/\/ to identify a specific stub, independent of the blob it belongs to.\n+\/\/ For a stub declared with name <stub_name> the associated enum value\n+\/\/ is StubGenStubId::<stub_name>_id.\n+\/\/\n+\/\/ Blob-local stub identifiers:\n+\/\/\n+\/\/ For each blob <blob_name>, public enum StubGenStubId_<blob_name> is\n+\/\/ generated to enumerate all stubs within the blob in stub\n+\/\/ declaration order, generic stubs before arch-specific stubs. This\n+\/\/ enum is provided only in a non-product build and is intended for\n+\/\/ internal use by class StubRoutines to validate stub declarations.\n+\/\/ For a stub declared with name <stub_name> belonging to blob\n+\/\/ <blob_name> the associated enum value is\n+\/\/ StubGenStubId::<blob_name>_<stub_name>_id.\n+\/\/\n+\/\/ Stub names and associated getters:\n+\/\/\n+\/\/ Two private static fields are generated to hold the names of the\n+\/\/ four generated blobs and all the generated stubs.\n+\/\/\n+\/\/  const char* StubRoutines::_blob_names[];\n+\/\/  const char* StubRoutines::_stub_names[];\n+\/\/\n+\/\/ The entry in _blob_names for a blob declared with name <blob_name>\n+\/\/ will be \"<blob_name>\".\n+\/\/\n+\/\/ The entry in _stub_names for a stub declared with name <stub_name>\n+\/\/ will be \"<stub_name>\".\n+\/\/\n+\/\/ Corresponding public static lookup methods are generated to allow\n+\/\/ names to be looked up by blob or global stub id.\n+\/\/\n+\/\/  const char* StubRoutines::get_blob_name(StubGenBlobId id)\n+\/\/  const char* StubRoutines::get_stub_name(StubGenStubId id)\n+\/\/\n+\/\/ These name lookup methods should be used by generic and\n+\/\/ cpu-specific client code to ensure that blobs and stubs are\n+\/\/ identified consistently.\n+\/\/\n+\/\/ Blob code buffer sizes:\n+\/\/\n+\/\/ An enumeration enum platform_dependent_constants is generated in\n+\/\/ the architecture specific StubRoutines header. For each blob named\n+\/\/ <nnn> an associated enum tag is generated which defines the\n+\/\/ relevant size\n+\/\/\n+\/\/  _<nnn>_stubs_code_size      = <size>,\n+\/\/\n+\/\/ For example,\n+\/\/\n+\/\/ enum platform_dependent_constants {\n+\/\/   _initial_stubs_code_size      = 10000,\n+\/\/   _continuation_stubs_code_size =  2000,\n+\/\/   . . .\n+\/\/\n+\/\/ Blob fields and associated getters:\n+\/\/\n+\/\/ For each blob named <nnn> a private field declaration will be\n+\/\/ generated: static field address StubRoutines::_<nnn>_stubs_code and\n+\/\/ a declaration provided to initialise it to nullptr. A corresponding\n+\/\/ public getter method address StubRoutines::_<nnn>_stubs_code() will\n+\/\/ be generated.\n+\/\/\n+\/\/ Blob initialization routines:\n+\/\/\n+\/\/ For each blob named <nnn> an initalization function is defined\n+\/\/ which allows clients to schedule blob and stub generation during\n+\/\/ JVM bootstrap:\n+\/\/\n+\/\/ void <nnn>_stubs_init() { StubRoutines::initialize_<nnn>_stubs(); }\n+\/\/\n+\/\/ A declaration and definition of each underlying implementation\n+\/\/ method StubRoutines::initialize_<nnn>_stubs() is also generated.\n+\/\/\n+\/\/ Stub entry points and associated getters:\n+\/\/\n+\/\/ Some generated stubs require their main entry point and, possibly,\n+\/\/ auxiliary entry points to be stored in fields declared either as\n+\/\/ members of class SharedRuntime. For stubs that are specific to a\n+\/\/ given cpu, the field needs to be declared in an arch-specific inner\n+\/\/ class of SharedRuntime.\n+\/\/\n+\/\/ For a generic stub named <nnn> the corresponding main entry usually\n+\/\/ has the same name: static field address StubRoutines::_<nnn> modulo\n+\/\/ an _ prefix.  An associated getter method is also generated, again\n+\/\/ normally using the same name: address StubRoutines::<nnn>() e.g.\n+\/\/\n+\/\/  class StubRoutines {\n+\/\/    . . .\n+\/\/    static address _aescrypt_encryptBlock;\n+\/\/    . . .\n+\/\/    address aescrypt_encryptBlock() { return _aescrypt_encryptBlock; }\n+\/\/\n+\/\/ Multiple fields and getters may be generated where a stub has more\n+\/\/ than one entry point, each provided with their own unique field and\n+\/\/ getter name e.g.\n+\/\/\n+\/\/    . . .\n+\/\/    static address _call_stub;\n+\/\/    static address _call_stub_return_address;\n+\/\/    . . .\n+\/\/    static address call_stub_entry() { return _call_stub; }\n+\/\/    static address call_stub_return_address() { return _call_stub_return_address; }\n+\/\/\n+\/\/ In special cases a stub may declare a (compile-time) fixed size\n+\/\/ array of entries, in which case an address array field is\n+\/\/ generated,along with a getter that accepts an index as argument:\n+\/\/\n+\/\/    . . .\n+\/\/   static address _lookup_secondary_supers_table[Klass::SECONDARY_SUPERS_TABLE_SIZE];\n+\/\/   . . .\n+\/\/   static address lookup_secondary_supers_table(int i);\n+\/\/\n+\/\/ CPU-specific stub entry points and associated getters:\n+\/\/\n+\/\/ For an arch-specific stub with name <nnn> belonging to architecture\n+\/\/ <arch> private field address StubRoutines::<arch>::_<nnn> is\n+\/\/ generated to hold the entry address. An associated public getter\n+\/\/ method address StubRoutines::<arch>::<nnn>() is also generated e.g.\n+\/\/\n+\/\/  class StubRoutines {\n+\/\/    . . .\n+\/\/    class x86 {\n+\/\/      . . .\n+\/\/      static address _f2i_fixup;\n+\/\/      . . .\n+\/\/      static address f2i_fixup() { return _f2i_fixup; }\n+\/\/      static void set_f2i_fixup(address a) { _f2i_fixup = a; }\n+\/\/\n+\n+\n+\/\/--------------------------------------------------\n+\/\/ Stub Generator Blob, Stub and Entry Declarations\n+\/\/ -------------------------------------------------\n+\/\/\n+\/\/ The formal declarations of blobs, stubs and entries provided below\n+\/\/ are used to schedule application of template macros that either\n+\/\/ declare or define the C++ code we need to manage those blobs, stubs\n+\/\/ and entries.\n+\/\/\n+\/\/ All ports employ the same blobs. However, the organization of the\n+\/\/ stubs and entry points in a blob can vary from one port to the\n+\/\/ next. A template macro is provided to specify the details of each\n+\/\/ blob, including generic and arch-specific variations.\n+\/\/\n+\/\/ If you want to define a new stub or entry then you can do so by\n+\/\/ adding suitable declarations within the scope of the relevant blob.\n+\/\/ For the blob with name BLOB_NAME add your declarations to macro\n+\/\/ STUBGEN_<BLOB_NAME>_STUBS_DO. Generic stubs and entries are\n+\/\/ declared using the do_stub, do_entry and do_entry_init and\n+\/\/ array_entry templates (see below for full details). The do_blob\n+\/\/ and end_blob templates should never need to be modified.\n+\/\/\n+\/\/ Some stubs and their associated entries are architecture-specific.\n+\/\/ They need to be declared in the architecture-specific header file\n+\/\/ src\/cpu\/<arch>stubDecolaration_<arch>.cpp. For the blob with name\n+\/\/ BLOB_NAME the correspnding declarations macro are provided by macro\n+\/\/ STUBGEN_<BLOB_NAME>_STUBS_ARCH_DO. Arch-specific stubs and entries\n+\/\/ are declared using the do_stub, do_arch_entry and\n+\/\/ do_arch_entry_init templates (see below for details). An\n+\/\/ architecure also needs to specify architecture parameters used when\n+\/\/ creating each blob. These are defined using the do_arch_blob\n+\/\/ template (see below).\n+\/\/\n+\/\/ Note, the client macro STUBGEN_ALL_DO is provided to allow client\n+\/\/ code to iterate over all blob, stub or entry declarations. It has\n+\/\/ only been split into separate per-blob generic submacros,\n+\/\/ STUBGEN_<BLOB_NAME>_BLOBS_DO and arch-specific per-blob submacros\n+\/\/ STUBGEN_<BLOB_NAME>_BLOBS_ARCH_DO for convenience, to make it\n+\/\/ easier to manage definitions. The blob_specific sub-macros should\n+\/\/ not be called directly by client code (in class StubRoutines and\n+\/\/ StubGenerator),\n+\/\/\n+\/\/ A client wishing to generate blob, stub or entry code elements is\n+\/\/ expected to pass template macros as arguments to STUBGEN_ALL_DO.\n+\/\/ This will schedule code generation code for whatever C++ code\n+\/\/ elements are required to implement a declaration or definition\n+\/\/ relevant to each blob, stub or entry. Alternatively, a client can\n+\/\/ operate on a subset of the declarations by calling macros\n+\/\/ STUBGEN_BLOBS_DO, STUBGEN_STUBS_DO, STUBGEN_BLOBS_STUBS_DO,\n+\/\/ STUBGEN_ENTRIES_DO and STUBGEN_ARCH_ENTRIES_DO.\n+\/\/\n+\/\/ The do_blob and end_blob templates receive a blob name as argument.\n+\/\/\n+\/\/ do_blob(blob_name)\n+\/\/ end_blob(blob_name)\n+\/\/\n+\/\/ do_blob is primarily used to define a global enum tag for a blob\n+\/\/ and an associated constant string name, both for use by client\n+\/\/ code.\n+\/\/\n+\/\/ end_blob is provided for use in combination with do_blob to to open\n+\/\/ and close a blob-local enum type identifying all stubs within a\n+\/\/ given blob. This enum is private to the stub management code and\n+\/\/ used to validate correct use of stubs within a given blob.\n+\/\/\n+\/\/ The do_stub template receives a blob name and stub name as argument.\n+\/\/\n+\/\/ do_stub(blob_name, stub_name)\n+\/\/\n+\/\/ do_stub is primarily used to define a global enum tag for a stub\n+\/\/ and a constant string name, both for use by client code. It is also\n+\/\/ used to declare a tag within the blob-local enum type used to\n+\/\/ validate correct use of stubs within their declared blob. Finally,\n+\/\/ it is also used to declare a name for each stub.\n+\/\/\n+\/\/ The do_entry and do_entry_array templates receive 4 or 5 arguments\n+\/\/\n+\/\/ do_entry(blob_name, stub_name, field_name, getter_name)\n+\/\/\n+\/\/ do_entry_init(blob_name, stub_name, field_name, getter_name, init_function)\n+\/\/\n+\/\/ do_entry_array(blob_name, stub_name, field_name, getter_name, count)\n+\/\/\n+\/\/ do_entry is used to declare or define a static field of class\n+\/\/ StubRoutines with type address that stores a specific entry point\n+\/\/ for a given stub. n.b. the number of entries associated with a stub\n+\/\/ is often one but it can be more than one and, in a few special\n+\/\/ cases, it is zero. do_entry is also used to declare and define an\n+\/\/ associated getter method for the field. do_entry is used to declare\n+\/\/ fields that should be initialized to nullptr.\n+\/\/\n+\/\/ do_entry_init is used when the field needs to be initialized a\n+\/\/ specific function or method .\n+\/\/\n+\/\/ do_entry_array is used for the special case where a stub employs an\n+\/\/ array to store multiple entries which are stored at generate time\n+\/\/ and subsequently accessed using an associated index (e.g. the\n+\/\/ secondary supers table stub which has 63 qassociated entries).\n+\/\/ Note that this distinct from the case where a stub generates\n+\/\/ multiple entries each of them stored in its own named field with\n+\/\/ its own named getter. In the latter case multiple do_entry or\n+\/\/ do_entry_init declarations are associated with the stub.\n+\/\/\n+\/\/ blob_name and stub_name are the names of the blob and stub to which\n+\/\/ the entry belongs.\n+\/\/\n+\/\/ field_name is prefixed with a leading '_' to produce the name of\n+\/\/ the field used to store an entry address for the stub. For stubs\n+\/\/ with one entry field_name is normally, but not always, the same as\n+\/\/ stub_name.  Obviously when a stub has multiple entries secondary\n+\/\/ names must be different to stub_name. For normal entry declarations\n+\/\/ the field type is address. For do_entry_array declarations the field\n+\/\/ type is an address[] whose size is defined by then parameter.\n+\/\/\n+\/\/ getter_name is the name of a getter that is generated to allow\n+\/\/ access to the field. It is normally, but not always, the same as\n+\/\/ stub_name. For normal entry declarations the getter signature is\n+\/\/ (void).  For do_entry_array declarations the getter signature is\n+\/\/ (int).\n+\/\/\n+\/\/ init_function is the name of an function or method which should be\n+\/\/ assigned to the field as a default value (n.b. fields declared\n+\/\/ using do_entry are intialised to nullptr, array fields declared\n+\/\/ using do_entry_array have their elements initalized to nullptr).\n+\/\/\n+\/\/ Architecture-specific blob details need to be specified using the\n+\/\/ do_arch_blob template\n+\/\/\n+\/\/ do_arch_blob(blob_name, size)\n+\/\/\n+\/\/ Currently, the do_arch_blob macro is only used to define the size\n+\/\/ of the code buffer into which blob-specific stub code is to be\n+\/\/ generated.\n+\/\/\n+\/\/ Architecture-specific entries need to be declared using the\n+\/\/ do_arch_entry template\n+\/\/\n+\/\/ do_arch_entry(arch, blob_name, stub_name, field_name, getter_name)\n+\/\/\n+\/\/ do_arch_entry_init(arch, blob_name, stub_name, field_name,\n+\/\/                    getter_name, init_function)\n+\/\/\n+\/\/ The only difference between these templates and the generic ones is\n+\/\/ that they receive an extra argument which identifies the current\n+\/\/ architecture e.g. x86, aarch64 etc.\n+\/\/\n+\/\/ Currently there is no support for a do_arch_array_entry template.\n+\n+\/\/ Include arch-specific stub and entry declarations and make sure the\n+\/\/ relevant template macros ahve been defined\n+\n+#include CPU_HEADER(stubDeclarations)\n+\n+#ifndef STUBGEN_INITIAL_BLOBS_ARCH_DO\n+#error \"Arch-specific directory failed to declare required initial stubs and entries\"\n+#endif\n+\n+#ifndef STUBGEN_CONTINUATION_BLOBS_ARCH_DO\n+#error \"Arch-specific directory failed to declare required continuation stubs and entries\"\n+#endif\n+\n+#ifndef STUBGEN_COMPILER_BLOBS_ARCH_DO\n+#error \"Arch-specific directory failed to declare required compiler stubs and entries\"\n+#endif\n+\n+#ifndef STUBGEN_FINAL_BLOBS_ARCH_DO\n+#error \"Arch-specific directory failed to declare required final stubs and entries\"\n+#endif\n+\n+\/\/ Iterator macros to apply templates to all relevant blobs, stubs and\n+\/\/ entries. Clients should use STUBGEN_ALL_DO, STUBGEN_BLOBS_DO,\n+\/\/ STUBGEN_STUBS_DO, STUBGEN_BLOBS_STUBS_DO, STUBGEN_ENTRIES_DO,\n+\/\/ STUBGEN_ARCH_BLOBS_DO and STUBGEN_ARCH_ENTRIES_DO.\n+\/\/\n+\/\/ n.b. Client macros appear after the STUBGEN_<BLOB_NAME>_BLOBS_DO\n+\/\/ submacros which follow next. These submacros are not intended to be\n+\/\/ called directly. They serve to define the main client macro\n+\/\/ STUBGEN_ALL_DO and, from there, the other more specific client\n+\/\/ macros. n.b. multiple, 'per-blob' submacros are used to declare\n+\/\/ each group of stubs and entries, because that makes it simpler to\n+\/\/ lookup and update related elements. If you need to update these\n+\/\/ submacros to change the list of stubs or entries be sure to locate\n+\/\/ stubs within the correct blob and locate entry declarations\n+\/\/ immediately after their associated stub declaration.\n+\n+#define STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                     \\\n+                                 do_stub,                               \\\n+                                 do_entry, do_entry_init,               \\\n+                                 do_entry_array,                        \\\n+                                 do_arch_blob,                          \\\n+                                 do_arch_entry, do_arch_entry_init)     \\\n+  do_blob(initial)                                                      \\\n+  do_stub(initial, call_stub)                                           \\\n+  do_entry(initial, call_stub, call_stub_entry, call_stub_entry)        \\\n+  do_entry(initial, call_stub, call_stub_return_address,                \\\n+           call_stub_return_address)                                    \\\n+  do_stub(initial, forward_exception)                                   \\\n+  do_entry(initial, forward_exception, forward_exception_entry,         \\\n+           forward_exception_entry)                                     \\\n+  do_stub(initial, catch_exception)                                     \\\n+  do_entry(initial, catch_exception, catch_exception_entry,             \\\n+           catch_exception_entry)                                       \\\n+  do_stub(initial, fence)                                               \\\n+  do_entry(initial, fence, fence_entry, fence_entry)                    \\\n+  do_stub(initial, atomic_xchg)                                         \\\n+  do_entry(initial, atomic_xchg, atomic_xchg_entry, atomic_xchg_entry)  \\\n+  do_stub(initial, atomic_cmpxchg)                                      \\\n+  do_entry(initial, atomic_cmpxchg, atomic_cmpxchg_entry,               \\\n+           atomic_cmpxchg_entry)                                        \\\n+  do_stub(initial, atomic_cmpxchg_long)                                 \\\n+  do_entry(initial, atomic_cmpxchg_long, atomic_cmpxchg_long_entry,     \\\n+           atomic_cmpxchg_long_entry)                                   \\\n+  do_stub(initial, updateBytesCRC32)                                    \\\n+  do_entry(initial, updateBytesCRC32, updateBytesCRC32,                 \\\n+           updateBytesCRC32)                                            \\\n+  do_entry(initial, updateBytesCRC32, crc_table_adr, crc_table_addr)    \\\n+  do_stub(initial, updateBytesCRC32C)                                   \\\n+  do_entry(initial, updateBytesCRC32C, updateBytesCRC32C,               \\\n+           updateBytesCRC32C)                                           \\\n+  do_entry(initial, updateBytesCRC32C, crc32c_table_addr,               \\\n+           crc32c_table_addr)                                           \\\n+  do_stub(initial, f2hf)                                                \\\n+  do_entry(initial, f2hf, f2hf, f2hf_adr)                               \\\n+  do_stub(initial, hf2f)                                                \\\n+  do_entry(initial, hf2f, hf2f, hf2f_adr)                               \\\n+  do_stub(initial, dexp)                                                \\\n+  do_entry(initial, dexp, dexp, dexp)                                   \\\n+  do_stub(initial, dlog)                                                \\\n+  do_entry(initial, dlog, dlog, dlog)                                   \\\n+  do_stub(initial, dlog10)                                              \\\n+  do_entry(initial, dlog10, dlog10, dlog10)                             \\\n+  do_stub(initial, dpow)                                                \\\n+  do_entry(initial, dpow, dpow, dpow)                                   \\\n+  do_stub(initial, dsin)                                                \\\n+  do_entry(initial, dsin, dsin, dsin)                                   \\\n+  do_stub(initial, dcos)                                                \\\n+  do_entry(initial, dcos, dcos, dcos)                                   \\\n+  do_stub(initial, dtan)                                                \\\n+  do_entry(initial, dtan, dtan, dtan)                                   \\\n+  do_stub(initial, dtanh)                                               \\\n+  do_entry(initial, dtanh, dtanh, dtanh)                                \\\n+  do_stub(initial, fmod)                                                \\\n+  do_entry(initial, fmod, fmod, fmod)                                   \\\n+  \/* following generic entries should really be x86_32 only *\/          \\\n+  do_stub(initial, dlibm_sin_cos_huge)                                  \\\n+  do_entry(initial, dlibm_sin_cos_huge, dlibm_sin_cos_huge,             \\\n+           dlibm_sin_cos_huge)                                          \\\n+  do_stub(initial, dlibm_reduce_pi04l)                                  \\\n+  do_entry(initial, dlibm_reduce_pi04l, dlibm_reduce_pi04l,             \\\n+           dlibm_reduce_pi04l)                                          \\\n+  do_stub(initial, dlibm_tan_cot_huge)                                  \\\n+  do_entry(initial, dlibm_tan_cot_huge, dlibm_tan_cot_huge,             \\\n+           dlibm_tan_cot_huge)                                          \\\n+  \/* merge in stubs and entries declared in arch header *\/              \\\n+  STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub, do_arch_blob,                  \\\n+                                do_arch_entry, do_arch_entry_init)      \\\n+  end_blob(initial)                                                     \\\n+\n+\n+#define STUBGEN_CONTINUATION_BLOBS_DO(do_blob, end_blob,                \\\n+                                      do_stub,                          \\\n+                                      do_entry, do_entry_init,          \\\n+                                      do_entry_array,                   \\\n+                                      do_arch_blob,                     \\\n+                                      do_arch_entry, do_arch_entry_init) \\\n+  do_blob(continuation)                                                 \\\n+  do_stub(continuation, cont_thaw)                                      \\\n+  do_entry(continuation, cont_thaw, cont_thaw, cont_thaw)               \\\n+  do_stub(continuation, cont_preempt)                                   \\\n+  do_entry(continuation, cont_prempt, cont_preempt_stub,                \\\n+           cont_preempt_stub)                                           \\\n+  do_stub(continuation, cont_returnBarrier)                             \\\n+  do_entry(continuation, cont_returnBarrier, cont_returnBarrier,        \\\n+           cont_returnBarrier)                                          \\\n+  do_stub(continuation, cont_returnBarrierExc)                          \\\n+  do_entry(continuation, cont_returnBarrierExc, cont_returnBarrierExc,  \\\n+           cont_returnBarrierExc)                                       \\\n+  \/* merge in stubs and entries declared in arch header *\/              \\\n+  STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,  do_arch_blob,            \\\n+                                     do_arch_entry, do_arch_entry_init) \\\n+  end_blob(continuation)                                                \\\n+\n+\n+#define STUBGEN_COMPILER_BLOBS_DO(do_blob, end_blob,                    \\\n+                                  do_stub,                              \\\n+                                  do_entry, do_entry_init,              \\\n+                                  do_entry_array,                       \\\n+                                  do_arch_blob,                         \\\n+                                  do_arch_entry, do_arch_entry_init)    \\\n+  do_blob(compiler)                                                     \\\n+  do_stub(compiler, atomic_add)                                         \\\n+  do_entry(compiler, atomic_add, atomic_add_entry, atomic_add_entry)    \\\n+  do_stub(compiler, array_sort)                                         \\\n+  do_entry(compiler, array_sort, array_sort, select_arraysort_function) \\\n+  do_stub(compiler, array_partition)                                    \\\n+  do_entry(compiler, array_partition, array_partition,                  \\\n+           select_array_partition_function)                             \\\n+  do_stub(compiler, aescrypt_encryptBlock)                              \\\n+  do_entry(compiler, aescrypt_encryptBlock, aescrypt_encryptBlock,      \\\n+           aescrypt_encryptBlock)                                       \\\n+  do_stub(compiler, aescrypt_decryptBlock)                              \\\n+  do_entry(compiler, aescrypt_decryptBlock, aescrypt_decryptBlock,      \\\n+           aescrypt_decryptBlock)                                       \\\n+  do_stub(compiler, cipherBlockChaining_encryptAESCrypt)                \\\n+  do_entry(compiler, cipherBlockChaining_encryptAESCrypt,               \\\n+           cipherBlockChaining_encryptAESCrypt,                         \\\n+           cipherBlockChaining_encryptAESCrypt)                         \\\n+  do_stub(compiler, cipherBlockChaining_decryptAESCrypt)                \\\n+  do_entry(compiler, cipherBlockChaining_decryptAESCrypt,               \\\n+           cipherBlockChaining_decryptAESCrypt,                         \\\n+           cipherBlockChaining_decryptAESCrypt)                         \\\n+  do_stub(compiler, electronicCodeBook_encryptAESCrypt)                 \\\n+  do_entry(compiler, electronicCodeBook_encryptAESCrypt,                \\\n+           electronicCodeBook_encryptAESCrypt,                          \\\n+           electronicCodeBook_encryptAESCrypt)                          \\\n+  do_stub(compiler, electronicCodeBook_decryptAESCrypt)                 \\\n+  do_entry(compiler, electronicCodeBook_decryptAESCrypt,                \\\n+           electronicCodeBook_decryptAESCrypt,                          \\\n+           electronicCodeBook_decryptAESCrypt)                          \\\n+  do_stub(compiler, counterMode_AESCrypt)                               \\\n+  do_entry(compiler, counterMode_AESCrypt, counterMode_AESCrypt,        \\\n+           counterMode_AESCrypt)                                        \\\n+  do_stub(compiler, galoisCounterMode_AESCrypt)                         \\\n+  do_entry(compiler, galoisCounterMode_AESCrypt,                        \\\n+           galoisCounterMode_AESCrypt, galoisCounterMode_AESCrypt)      \\\n+  do_stub(compiler, ghash_processBlocks)                                \\\n+  do_entry(compiler, ghash_processBlocks, ghash_processBlocks,          \\\n+           ghash_processBlocks)                                         \\\n+  do_stub(compiler, chacha20Block)                                      \\\n+  do_entry(compiler, chacha20Block, chacha20Block, chacha20Block)       \\\n+  do_stub(compiler, data_cache_writeback)                               \\\n+  do_entry(compiler, data_cache_writeback, data_cache_writeback,        \\\n+           data_cache_writeback)                                        \\\n+  do_stub(compiler, data_cache_writeback_sync)                          \\\n+  do_entry(compiler, data_cache_writeback_sync,                         \\\n+           data_cache_writeback_sync, data_cache_writeback_sync)        \\\n+  do_stub(compiler, base64_encodeBlock)                                 \\\n+  do_entry(compiler, base64_encodeBlock, base64_encodeBlock,            \\\n+           base64_encodeBlock)                                          \\\n+  do_stub(compiler, base64_decodeBlock)                                 \\\n+  do_entry(compiler, base64_decodeBlock, base64_decodeBlock,            \\\n+           base64_decodeBlock)                                          \\\n+  do_stub(compiler, poly1305_processBlocks)                             \\\n+  do_entry(compiler, poly1305_processBlocks, poly1305_processBlocks,    \\\n+           poly1305_processBlocks)                                      \\\n+  do_stub(compiler, intpoly_montgomeryMult_P256)                        \\\n+  do_entry(compiler, intpoly_montgomeryMult_P256,                       \\\n+           intpoly_montgomeryMult_P256, intpoly_montgomeryMult_P256)    \\\n+  do_stub(compiler, intpoly_assign)                                     \\\n+  do_entry(compiler, intpoly_assign, intpoly_assign, intpoly_assign)    \\\n+  do_stub(compiler, md5_implCompress)                                   \\\n+  do_entry(compiler, md5_implCompress, md5_implCompress,                \\\n+           md5_implCompress)                                            \\\n+  do_stub(compiler, md5_implCompressMB)                                 \\\n+  do_entry(compiler, md5_implCompressMB, md5_implCompressMB,            \\\n+           md5_implCompressMB)                                          \\\n+  do_stub(compiler, sha1_implCompress)                                  \\\n+  do_entry(compiler, sha1_implCompress, sha1_implCompress,              \\\n+           sha1_implCompress)                                           \\\n+  do_stub(compiler, sha1_implCompressMB)                                \\\n+  do_entry(compiler, sha1_implCompressMB, sha1_implCompressMB,          \\\n+           sha1_implCompressMB)                                         \\\n+  do_stub(compiler, sha256_implCompress)                                \\\n+  do_entry(compiler, sha256_implCompress, sha256_implCompress,          \\\n+           sha256_implCompress)                                         \\\n+  do_stub(compiler, sha256_implCompressMB)                              \\\n+  do_entry(compiler, sha256_implCompressMB, sha256_implCompressMB,      \\\n+           sha256_implCompressMB)                                       \\\n+  do_stub(compiler, sha512_implCompress)                                \\\n+  do_entry(compiler, sha512_implCompress, sha512_implCompress,          \\\n+           sha512_implCompress)                                         \\\n+  do_stub(compiler, sha512_implCompressMB)                              \\\n+  do_entry(compiler, sha512_implCompressMB, sha512_implCompressMB,      \\\n+           sha512_implCompressMB)                                       \\\n+  do_stub(compiler, sha3_implCompress)                                  \\\n+  do_entry(compiler, sha3_implCompress, sha3_implCompress,              \\\n+           sha3_implCompress)                                           \\\n+  do_stub(compiler, sha3_implCompressMB)                                \\\n+  do_entry(compiler, sha3_implCompressMB, sha3_implCompressMB,          \\\n+           sha3_implCompressMB)                                         \\\n+  do_stub(compiler, updateBytesAdler32)                                 \\\n+  do_entry(compiler, updateBytesAdler32, updateBytesAdler32,            \\\n+           updateBytesAdler32)                                          \\\n+  do_stub(compiler, multiplyToLen)                                      \\\n+  do_entry(compiler, multiplyToLen, multiplyToLen, multiplyToLen)       \\\n+  do_stub(compiler, squareToLen)                                        \\\n+  do_entry(compiler, squareToLen, squareToLen, squareToLen)             \\\n+  do_stub(compiler, mulAdd)                                             \\\n+  do_entry(compiler, mulAdd, mulAdd, mulAdd)                            \\\n+  do_stub(compiler, montgomeryMultiply)                                 \\\n+  do_entry(compiler, montgomeryMultiply, montgomeryMultiply,            \\\n+           montgomeryMultiply)                                          \\\n+  do_stub(compiler, montgomerySquare)                                   \\\n+  do_entry(compiler, montgomerySquare, montgomerySquare,                \\\n+           montgomerySquare)                                            \\\n+  do_stub(compiler, bigIntegerRightShiftWorker)                         \\\n+  do_entry(compiler, bigIntegerRightShiftWorker,                        \\\n+           bigIntegerRightShiftWorker, bigIntegerRightShift)            \\\n+  do_stub(compiler, bigIntegerLeftShiftWorker)                          \\\n+  do_entry(compiler, bigIntegerLeftShiftWorker,                         \\\n+           bigIntegerLeftShiftWorker, bigIntegerLeftShift)              \\\n+  \/* merge in stubs and entries declared in arch header *\/              \\\n+  STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,  do_arch_blob,                \\\n+                                     do_arch_entry, do_arch_entry_init) \\\n+  end_blob(compiler)                                                    \\\n+\n+\n+#define STUBGEN_FINAL_BLOBS_DO(do_blob, end_blob,                       \\\n+                               do_stub,                                 \\\n+                               do_entry, do_entry_init,                 \\\n+                               do_entry_array,                          \\\n+                               do_arch_blob,                            \\\n+                               do_arch_entry, do_arch_entry_init)       \\\n+  do_blob(final)                                                        \\\n+  do_stub(final, verify_oop)                                            \\\n+  do_entry(final, verify_oop, verify_oop_subroutine_entry,              \\\n+           verify_oop_subroutine_entry)                                 \\\n+  do_stub(final, jbyte_arraycopy)                                       \\\n+  do_entry_init(final, jbyte_arraycopy, jbyte_arraycopy,                \\\n+                jbyte_arraycopy, StubRoutines::jbyte_copy)              \\\n+  do_stub(final, jshort_arraycopy)                                      \\\n+  do_entry_init(final, jshort_arraycopy, jshort_arraycopy,              \\\n+                jshort_arraycopy, StubRoutines::jshort_copy)            \\\n+  do_stub(final, jint_arraycopy)                                        \\\n+  do_entry_init(final, jint_arraycopy, jint_arraycopy,                  \\\n+                jint_arraycopy, StubRoutines::jint_copy)                \\\n+  do_stub(final, jlong_arraycopy)                                       \\\n+  do_entry_init(final, jlong_arraycopy, jlong_arraycopy,                \\\n+                jlong_arraycopy, StubRoutines::jlong_copy)              \\\n+  do_stub(final, oop_arraycopy)                                         \\\n+  do_entry_init(final, oop_arraycopy, oop_arraycopy,                    \\\n+                oop_arraycopy_entry, StubRoutines::oop_copy)            \\\n+  do_stub(final, oop_arraycopy_uninit)                                  \\\n+  do_entry_init(final, oop_arraycopy_uninit, oop_arraycopy_uninit,      \\\n+                oop_arraycopy_uninit_entry,                             \\\n+                StubRoutines::oop_copy_uninit)                          \\\n+  do_stub(final, jbyte_disjoint_arraycopy)                              \\\n+  do_entry_init(final, jbyte_disjoint_arraycopy,                        \\\n+                jbyte_disjoint_arraycopy, jbyte_disjoint_arraycopy,     \\\n+                StubRoutines::jbyte_copy)                               \\\n+  do_stub(final, jshort_disjoint_arraycopy)                             \\\n+  do_entry_init(final, jshort_disjoint_arraycopy,                       \\\n+                jshort_disjoint_arraycopy, jshort_disjoint_arraycopy,   \\\n+                StubRoutines::jshort_copy)                              \\\n+  do_stub(final, jint_disjoint_arraycopy)                               \\\n+  do_entry_init(final, jint_disjoint_arraycopy,                         \\\n+                jint_disjoint_arraycopy, jint_disjoint_arraycopy,       \\\n+                StubRoutines::jint_copy)                                \\\n+  do_stub(final, jlong_disjoint_arraycopy)                              \\\n+  do_entry_init(final, jlong_disjoint_arraycopy,                        \\\n+                jlong_disjoint_arraycopy, jlong_disjoint_arraycopy,     \\\n+                StubRoutines::jlong_copy)                               \\\n+  do_stub(final, oop_disjoint_arraycopy)                                \\\n+  do_entry_init(final, oop_disjoint_arraycopy, oop_disjoint_arraycopy,  \\\n+                oop_disjoint_arraycopy_entry, StubRoutines::oop_copy)   \\\n+  do_stub(final, oop_disjoint_arraycopy_uninit)                         \\\n+  do_entry_init(final, oop_disjoint_arraycopy_uninit,                   \\\n+                oop_disjoint_arraycopy_uninit,                          \\\n+                oop_disjoint_arraycopy_uninit_entry,                    \\\n+                StubRoutines::oop_copy_uninit)                          \\\n+  do_stub(final, arrayof_jbyte_arraycopy)                               \\\n+  do_entry_init(final, arrayof_jbyte_arraycopy,                         \\\n+                arrayof_jbyte_arraycopy, arrayof_jbyte_arraycopy,       \\\n+                StubRoutines::arrayof_jbyte_copy)                       \\\n+  do_stub(final, arrayof_jshort_arraycopy)                              \\\n+  do_entry_init(final, arrayof_jshort_arraycopy,                        \\\n+                arrayof_jshort_arraycopy, arrayof_jshort_arraycopy,     \\\n+                StubRoutines::arrayof_jshort_copy)                      \\\n+  do_stub(final, arrayof_jint_arraycopy)                                \\\n+  do_entry_init(final, arrayof_jint_arraycopy, arrayof_jint_arraycopy,  \\\n+                arrayof_jint_arraycopy,                                 \\\n+                StubRoutines::arrayof_jint_copy)                        \\\n+  do_stub(final, arrayof_jlong_arraycopy)                               \\\n+  do_entry_init(final, arrayof_jlong_arraycopy,                         \\\n+                arrayof_jlong_arraycopy, arrayof_jlong_arraycopy,       \\\n+                StubRoutines::arrayof_jlong_copy)                       \\\n+  do_stub(final, arrayof_oop_arraycopy)                                 \\\n+  do_entry_init(final, arrayof_oop_arraycopy, arrayof_oop_arraycopy,    \\\n+                arrayof_oop_arraycopy, StubRoutines::arrayof_oop_copy)  \\\n+  do_stub(final, arrayof_oop_arraycopy_uninit)                          \\\n+  do_entry_init(final, arrayof_oop_arraycopy_uninit,                    \\\n+                arrayof_oop_arraycopy_uninit,                           \\\n+                arrayof_oop_arraycopy_uninit,                           \\\n+                StubRoutines::arrayof_oop_copy_uninit)                  \\\n+  do_stub(final, arrayof_jbyte_disjoint_arraycopy)                      \\\n+  do_entry_init(final, arrayof_jbyte_disjoint_arraycopy,                \\\n+                arrayof_jbyte_disjoint_arraycopy,                       \\\n+                arrayof_jbyte_disjoint_arraycopy,                       \\\n+                StubRoutines::arrayof_jbyte_copy)                       \\\n+  do_stub(final, arrayof_jshort_disjoint_arraycopy)                     \\\n+  do_entry_init(final, arrayof_jshort_disjoint_arraycopy,               \\\n+                arrayof_jshort_disjoint_arraycopy,                      \\\n+                arrayof_jshort_disjoint_arraycopy,                      \\\n+                StubRoutines::arrayof_jshort_copy)                      \\\n+  do_stub(final, arrayof_jint_disjoint_arraycopy)                       \\\n+  do_entry_init(final, arrayof_jint_disjoint_arraycopy,                 \\\n+                arrayof_jint_disjoint_arraycopy,                        \\\n+                arrayof_jint_disjoint_arraycopy,                        \\\n+                StubRoutines::arrayof_jint_copy)                        \\\n+  do_stub(final, arrayof_jlong_disjoint_arraycopy)                      \\\n+  do_entry_init(final, arrayof_jlong_disjoint_arraycopy,                \\\n+                arrayof_jlong_disjoint_arraycopy,                       \\\n+                arrayof_jlong_disjoint_arraycopy,                       \\\n+                StubRoutines::arrayof_jlong_copy)                       \\\n+  do_stub(final, arrayof_oop_disjoint_arraycopy)                        \\\n+  do_entry_init(final, arrayof_oop_disjoint_arraycopy,                  \\\n+                arrayof_oop_disjoint_arraycopy,                         \\\n+                arrayof_oop_disjoint_arraycopy_entry,                   \\\n+                StubRoutines::arrayof_oop_copy)                         \\\n+  do_stub(final, arrayof_oop_disjoint_arraycopy_uninit)                 \\\n+  do_entry_init(final, arrayof_oop_disjoint_arraycopy_uninit,           \\\n+                arrayof_oop_disjoint_arraycopy_uninit,                  \\\n+                arrayof_oop_disjoint_arraycopy_uninit_entry,            \\\n+                StubRoutines::arrayof_oop_copy_uninit)                  \\\n+  do_stub(final, checkcast_arraycopy)                                   \\\n+  do_entry(final, checkcast_arraycopy, checkcast_arraycopy,             \\\n+           checkcast_arraycopy_entry)                                   \\\n+  do_stub(final, checkcast_arraycopy_uninit)                            \\\n+  do_entry(final, checkcast_arraycopy_uninit,                           \\\n+           checkcast_arraycopy_uninit,                                  \\\n+           checkcast_arraycopy_uninit_entry)                            \\\n+  do_stub(final, unsafe_arraycopy)                                      \\\n+  do_entry(final, unsafe_arraycopy, unsafe_arraycopy, unsafe_arraycopy) \\\n+  do_stub(final, generic_arraycopy)                                     \\\n+  do_entry(final, generic_arraycopy, generic_arraycopy,                 \\\n+           generic_arraycopy)                                           \\\n+  do_stub(final, unsafe_setmemory)                                      \\\n+  do_entry(final, unsafe_setmemory, unsafe_setmemory, unsafe_setmemory) \\\n+  do_stub(final, jbyte_fill)                                            \\\n+  do_entry(final, jbyte_fill, jbyte_fill, jbyte_fill)                   \\\n+  do_stub(final, jshort_fill)                                           \\\n+  do_entry(final, jshort_fill, jshort_fill, jshort_fill)                \\\n+  do_stub(final, jint_fill)                                             \\\n+  do_entry(final, jint_fill, jint_fill, jint_fill)                      \\\n+  do_stub(final, arrayof_jbyte_fill)                                    \\\n+  do_entry(final, arrayof_jbyte_fill, arrayof_jbyte_fill,               \\\n+           arrayof_jbyte_fill)                                          \\\n+  do_stub(final, arrayof_jshort_fill)                                   \\\n+  do_entry(final, arrayof_jshort_fill, arrayof_jshort_fill,             \\\n+           arrayof_jshort_fill)                                         \\\n+  do_stub(final, arrayof_jint_fill)                                     \\\n+  do_entry(final, arrayof_jint_fill, arrayof_jint_fill,                 \\\n+           arrayof_jint_fill)                                           \\\n+  do_stub(final, method_entry_barrier)                                  \\\n+  do_entry(final, method_entry_barrier, method_entry_barrier,           \\\n+           method_entry_barrier)                                        \\\n+  do_stub(final, vectorizedMismatch) \/* only used by x86! *\/            \\\n+  do_entry(final, vectorizedMismatch, vectorizedMismatch,               \\\n+           vectorizedMismatch)                                          \\\n+  do_stub(final, upcall_stub_exception_handler)                         \\\n+  do_entry(final, upcall_stub_exception_handler,                        \\\n+           upcall_stub_exception_handler,                               \\\n+           upcall_stub_exception_handler)                               \\\n+  do_stub(final, upcall_stub_load_target)                               \\\n+  do_entry(final, upcall_stub_load_target, upcall_stub_load_target,     \\\n+           upcall_stub_load_target)                                     \\\n+  do_stub(final, lookup_secondary_supers_table)                         \\\n+  do_entry_array(final, lookup_secondary_supers_table,                  \\\n+                 lookup_secondary_supers_table_stubs,                   \\\n+                 lookup_secondary_supers_table_stub,                    \\\n+                 Klass::SECONDARY_SUPERS_TABLE_SIZE)                    \\\n+  do_stub(final, lookup_secondary_supers_table_slow_path)               \\\n+  do_entry(final, lookup_secondary_supers_table_slow_path,              \\\n+           lookup_secondary_supers_table_slow_path_stub,                \\\n+           lookup_secondary_supers_table_slow_path_stub)                \\\n+  \/* merge in stubs and entries declared in arch header *\/              \\\n+  STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,  do_arch_blob,                   \\\n+                              do_arch_entry, do_arch_entry_init)        \\\n+  end_blob(final)                                                       \\\n+\n+\n+\/\/ Convenience macros for use by template implementations\n@@ -172,1 +925,1 @@\n-\/\/ generate a stub field name\n+\/\/ emit a runtime or stubgen stub field name\n@@ -176,1 +929,1 @@\n-\/\/ generate a blob field name\n+\/\/ emit a runtime blob field name\n@@ -180,0 +933,133 @@\n+\/\/ emit a stubgen blob field name\n+\n+#define STUBGEN_BLOB_FIELD_NAME(base) _ ## base ## _stubs_code\n+\n+\/\/ Convenience templates that emit nothing\n+\n+\/\/ ignore do_blob(blob_name, type) declarations\n+#define DO_BLOB_EMPTY2(blob_name, type)\n+\n+\/\/ ignore do_blob(blob_name) and end_blob(blob_name) declarations\n+#define DO_BLOB_EMPTY1(blob_name)\n+\n+\/\/ ignore do_stub(name, fancy_jump, pass_tls, return_pc) declarations\n+#define DO_STUB_EMPTY4(name, fancy_jump, pass_tls, return_pc)\n+\n+\/\/ ignore do_jvmti_stub(name) declarations\n+#define DO_JVMTI_STUB_EMPTY1(stub_name)\n+\n+\/\/ ignore do_stub(blob_name, stub_name) declarations\n+#define DO_STUB_EMPTY2(blob_name, stub_name)\n+\n+\/\/ ignore do_entry(blob_name, stub_name, fieldname, getter_name) declarations\n+#define DO_ENTRY_EMPTY4(blob_name, stub_name, fieldname, getter_name)\n+\n+\/\/ ignore do_entry(blob_name, stub_name, fieldname, getter_name, init_function) and\n+\/\/ do_entry_array(blob_name, stub_name, fieldname, getter_name, count) declarations\n+#define DO_ENTRY_EMPTY5(blob_name, stub_name, fieldname, getter_name, init_function)\n+\n+\/\/ ignore do_arch_blob(blob_name, size) declarations\n+#define DO_ARCH_BLOB_EMPTY2(arch, size)\n+\n+\/\/ ignore do_arch_entry(arch, blob_name, stub_name, fieldname, getter_name) declarations\n+#define DO_ARCH_ENTRY_EMPTY5(arch, blob_name, stub_name, field_name, getter_name)\n+\n+\/\/ ignore do_arch_entry(arch, blob_name, stub_name, fieldname, getter_name, init_function) declarations\n+#define DO_ARCH_ENTRY_EMPTY6(arch, blob_name, stub_name, field_name, getter_name, init_function)\n+\n+\/\/ The whole shebang!\n+\/\/\n+\/\/ client macro for emitting StubGenerator blobs, stubs and entries\n+\n+#define STUBGEN_ALL_DO(do_blob, end_blob,                               \\\n+                       do_stub,                                         \\\n+                       do_entry, do_entry_init,                         \\\n+                       do_entry_array,                                  \\\n+                       do_arch_blob,                                    \\\n+                       do_arch_entry, do_arch_entry_init)               \\\n+  STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                           \\\n+                           do_stub,                                     \\\n+                           do_entry, do_entry_init,                     \\\n+                           do_entry_array,                              \\\n+                           do_arch_blob,                                \\\n+                           do_arch_entry, do_arch_entry_init)           \\\n+  STUBGEN_CONTINUATION_BLOBS_DO(do_blob, end_blob,                      \\\n+                                do_stub,                                \\\n+                                do_entry, do_entry_init,                \\\n+                                do_entry_array,                         \\\n+                                do_arch_blob,                           \\\n+                                do_arch_entry, do_arch_entry_init)      \\\n+  STUBGEN_COMPILER_BLOBS_DO(do_blob, end_blob,                          \\\n+                            do_stub,                                    \\\n+                            do_entry, do_entry_init,                    \\\n+                            do_entry_array,                             \\\n+                            do_arch_blob,                               \\\n+                            do_arch_entry, do_arch_entry_init)          \\\n+  STUBGEN_FINAL_BLOBS_DO(do_blob, end_blob,                             \\\n+                         do_stub,                                       \\\n+                         do_entry, do_entry_init,                       \\\n+                         do_entry_array,                                \\\n+                         do_arch_blob,                                  \\\n+                         do_arch_entry, do_arch_entry_init)             \\\n+\n+\/\/ client macro to operate only on StubGenerator blobs\n+\n+#define STUBGEN_BLOBS_DO(do_blob)                                       \\\n+  STUBGEN_ALL_DO(do_blob, DO_BLOB_EMPTY1,                               \\\n+                 DO_STUB_EMPTY2,                                        \\\n+                 DO_ENTRY_EMPTY4, DO_ENTRY_EMPTY5,                      \\\n+                 DO_ENTRY_EMPTY5,                                       \\\n+                 DO_ARCH_BLOB_EMPTY2,                                   \\\n+                 DO_ARCH_ENTRY_EMPTY5, DO_ARCH_ENTRY_EMPTY6)            \\\n+\n+\/\/ client macro to operate only on StubGenerator stubs\n+\n+#define STUBGEN_STUBS_DO(do_stub)                                       \\\n+  STUBGEN_ALL_DO(DO_BLOB_EMPTY1, DO_BLOB_EMPTY1,                        \\\n+                 do_stub,                                               \\\n+                 DO_ENTRY_EMPTY4, DO_ENTRY_EMPTY5,                      \\\n+                 DO_ENTRY_EMPTY5,                                       \\\n+                 DO_ARCH_BLOB_EMPTY2,                                   \\\n+                 DO_ARCH_ENTRY_EMPTY5, DO_ARCH_ENTRY_EMPTY6)            \\\n+\n+\/\/ client macro to operate only on StubGenerator blobs and stubs\n+\n+#define STUBGEN_BLOBS_STUBS_DO(do_blob, end_blob, do_stub)              \\\n+  STUBGEN_ALL_DO(do_blob, end_blob,                                     \\\n+                 do_stub,                                               \\\n+                 DO_ENTRY_EMPTY4, DO_ENTRY_EMPTY5,                      \\\n+                 DO_ENTRY_EMPTY5,                                       \\\n+                 DO_ARCH_BLOB_EMPTY2,                                   \\\n+                 DO_ARCH_ENTRY_EMPTY5,DO_ARCH_ENTRY_EMPTY6)             \\\n+\n+\/\/ client macro to operate only on StubGenerator entries\n+\n+#define STUBGEN_ENTRIES_DO(do_entry, do_entry_init, do_entry_array)     \\\n+  STUBGEN_ALL_DO(DO_BLOB_EMPTY1, DO_BLOB_EMPTY1,                        \\\n+                 DO_STUB_EMPTY2,                                        \\\n+                 do_entry, do_entry_init,                               \\\n+                 do_entry_array,                                        \\\n+                 DO_ARCH_BLOB_EMPTY2,                                   \\\n+                 DO_ARCH_ENTRY_EMPTY5, DO_ARCH_ENTRY_EMPTY6)            \\\n+\n+\n+\/\/ client macro to operate only on StubGenerator arch blobs\n+\n+#define STUBGEN_ARCH_BLOBS_DO(do_arch_blob)                             \\\n+  STUBGEN_ALL_DO(DO_BLOB_EMPTY1, DO_BLOB_EMPTY1,                        \\\n+                 DO_STUB_EMPTY2,                                        \\\n+                 DO_ENTRY_EMPTY4, DO_ENTRY_EMPTY5,                      \\\n+                 DO_ENTRY_EMPTY5,                                       \\\n+                 do_arch_blob,                                          \\\n+                 DO_ARCH_ENTRY_EMPTY5, DO_ARCH_ENTRY_EMPTY6)            \\\n+\n+\/\/ client macro to operate only on StubGenerator arch entries\n+\n+#define STUBGEN_ARCH_ENTRIES_DO(do_arch_entry, do_arch_entry_init)      \\\n+  STUBGEN_ALL_DO(DO_BLOB_EMPTY1, DO_BLOB_EMPTY1,                        \\\n+                 DO_STUB_EMPTY2,                                        \\\n+                 DO_ENTRY_EMPTY4, DO_ENTRY_EMPTY5,                      \\\n+                 DO_ENTRY_EMPTY5,                                       \\\n+                 DO_ARCH_BLOB_EMPTY2,                                   \\\n+                 do_arch_entry, do_arch_entry_init)                     \\\n+\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":891,"deletions":5,"binary":false,"changes":896,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-\/\/ Implementation of StubRoutines - for a description\n-\/\/ of how to extend it, see the header file.\n+\/\/ Implementation of StubRoutines - for a description of how to\n+\/\/ declare new blobs, stubs and entries , see stubDefinitions.hpp.\n@@ -51,1 +51,1 @@\n-\/\/ Class Variables\n+\/\/ define arrays to hold stub and blob names\n@@ -53,4 +53,1 @@\n-BufferBlob* StubRoutines::_initial_stubs_code                   = nullptr;\n-BufferBlob* StubRoutines::_final_stubs_code                     = nullptr;\n-BufferBlob* StubRoutines::_compiler_stubs_code                  = nullptr;\n-BufferBlob* StubRoutines::_continuation_stubs_code              = nullptr;\n+\/\/ use a template to generate the initializer for the blob names array\n@@ -58,2 +55,2 @@\n-address StubRoutines::_call_stub_return_address                 = nullptr;\n-address StubRoutines::_call_stub_entry                          = nullptr;\n+#define DEFINE_BLOB_NAME(blob_name)             \\\n+  # blob_name,\n@@ -61,84 +58,3 @@\n-address StubRoutines::_catch_exception_entry                    = nullptr;\n-address StubRoutines::_forward_exception_entry                  = nullptr;\n-jint    StubRoutines::_verify_oop_count                         = 0;\n-address StubRoutines::_verify_oop_subroutine_entry              = nullptr;\n-address StubRoutines::_atomic_xchg_entry                        = nullptr;\n-address StubRoutines::_atomic_cmpxchg_entry                     = nullptr;\n-address StubRoutines::_atomic_cmpxchg_long_entry                = nullptr;\n-address StubRoutines::_atomic_add_entry                         = nullptr;\n-address StubRoutines::_fence_entry                              = nullptr;\n-\n-\/\/ Compiled code entry points default values\n-\/\/ The default functions don't have separate disjoint versions.\n-address StubRoutines::_jbyte_arraycopy          = CAST_FROM_FN_PTR(address, StubRoutines::jbyte_copy);\n-address StubRoutines::_jshort_arraycopy         = CAST_FROM_FN_PTR(address, StubRoutines::jshort_copy);\n-address StubRoutines::_jint_arraycopy           = CAST_FROM_FN_PTR(address, StubRoutines::jint_copy);\n-address StubRoutines::_jlong_arraycopy          = CAST_FROM_FN_PTR(address, StubRoutines::jlong_copy);\n-address StubRoutines::_oop_arraycopy            = CAST_FROM_FN_PTR(address, StubRoutines::oop_copy);\n-address StubRoutines::_oop_arraycopy_uninit     = CAST_FROM_FN_PTR(address, StubRoutines::oop_copy_uninit);\n-address StubRoutines::_jbyte_disjoint_arraycopy          = CAST_FROM_FN_PTR(address, StubRoutines::jbyte_copy);\n-address StubRoutines::_jshort_disjoint_arraycopy         = CAST_FROM_FN_PTR(address, StubRoutines::jshort_copy);\n-address StubRoutines::_jint_disjoint_arraycopy           = CAST_FROM_FN_PTR(address, StubRoutines::jint_copy);\n-address StubRoutines::_jlong_disjoint_arraycopy          = CAST_FROM_FN_PTR(address, StubRoutines::jlong_copy);\n-address StubRoutines::_oop_disjoint_arraycopy            = CAST_FROM_FN_PTR(address, StubRoutines::oop_copy);\n-address StubRoutines::_oop_disjoint_arraycopy_uninit     = CAST_FROM_FN_PTR(address, StubRoutines::oop_copy_uninit);\n-\n-address StubRoutines::_arrayof_jbyte_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jbyte_copy);\n-address StubRoutines::_arrayof_jshort_arraycopy = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jshort_copy);\n-address StubRoutines::_arrayof_jint_arraycopy   = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jint_copy);\n-address StubRoutines::_arrayof_jlong_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jlong_copy);\n-address StubRoutines::_arrayof_oop_arraycopy    = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy);\n-address StubRoutines::_arrayof_oop_arraycopy_uninit      = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy_uninit);\n-address StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jbyte_copy);\n-address StubRoutines::_arrayof_jshort_disjoint_arraycopy = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jshort_copy);\n-address StubRoutines::_arrayof_jint_disjoint_arraycopy   = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jint_copy);\n-address StubRoutines::_arrayof_jlong_disjoint_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jlong_copy);\n-address StubRoutines::_arrayof_oop_disjoint_arraycopy    = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy);\n-address StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy_uninit);\n-\n-address StubRoutines::_data_cache_writeback              = nullptr;\n-address StubRoutines::_data_cache_writeback_sync         = nullptr;\n-\n-address StubRoutines::_checkcast_arraycopy               = nullptr;\n-address StubRoutines::_checkcast_arraycopy_uninit        = nullptr;\n-address StubRoutines::_unsafe_arraycopy                  = nullptr;\n-address StubRoutines::_generic_arraycopy                 = nullptr;\n-\n-address StubRoutines::_unsafe_setmemory                  = nullptr;\n-\n-address StubRoutines::_jbyte_fill;\n-address StubRoutines::_jshort_fill;\n-address StubRoutines::_jint_fill;\n-address StubRoutines::_arrayof_jbyte_fill;\n-address StubRoutines::_arrayof_jshort_fill;\n-address StubRoutines::_arrayof_jint_fill;\n-\n-address StubRoutines::_aescrypt_encryptBlock               = nullptr;\n-address StubRoutines::_aescrypt_decryptBlock               = nullptr;\n-address StubRoutines::_cipherBlockChaining_encryptAESCrypt = nullptr;\n-address StubRoutines::_cipherBlockChaining_decryptAESCrypt = nullptr;\n-address StubRoutines::_electronicCodeBook_encryptAESCrypt  = nullptr;\n-address StubRoutines::_electronicCodeBook_decryptAESCrypt  = nullptr;\n-address StubRoutines::_counterMode_AESCrypt                = nullptr;\n-address StubRoutines::_galoisCounterMode_AESCrypt          = nullptr;\n-address StubRoutines::_ghash_processBlocks                 = nullptr;\n-address StubRoutines::_chacha20Block                       = nullptr;\n-address StubRoutines::_base64_encodeBlock                  = nullptr;\n-address StubRoutines::_base64_decodeBlock                  = nullptr;\n-address StubRoutines::_poly1305_processBlocks              = nullptr;\n-address StubRoutines::_intpoly_montgomeryMult_P256         = nullptr;\n-address StubRoutines::_intpoly_assign                      = nullptr;\n-\n-address StubRoutines::_md5_implCompress      = nullptr;\n-address StubRoutines::_md5_implCompressMB    = nullptr;\n-address StubRoutines::_sha1_implCompress     = nullptr;\n-address StubRoutines::_sha1_implCompressMB   = nullptr;\n-address StubRoutines::_sha256_implCompress   = nullptr;\n-address StubRoutines::_sha256_implCompressMB = nullptr;\n-address StubRoutines::_sha512_implCompress   = nullptr;\n-address StubRoutines::_sha512_implCompressMB = nullptr;\n-address StubRoutines::_sha3_implCompress     = nullptr;\n-address StubRoutines::_sha3_implCompressMB   = nullptr;\n-\n-address StubRoutines::_updateBytesCRC32 = nullptr;\n-address StubRoutines::_crc_table_adr =    nullptr;\n+const char* StubRoutines::_blob_names[StubGenBlobId::NUM_BLOBIDS] = {\n+  STUBGEN_BLOBS_DO(DEFINE_BLOB_NAME)\n+};\n@@ -146,1 +62,22 @@\n-address StubRoutines::_string_indexof_array[4]   =    { nullptr };\n+#undef DEFINE_BLOB_NAME\n+\n+#define DEFINE_STUB_NAME(blob_name, stub_name)          \\\n+  # stub_name ,                                         \\\n+\n+\/\/ use a template to generate the initializer for the stub names array\n+const char* StubRoutines::_stub_names[StubGenStubId::NUM_STUBIDS] = {\n+  STUBGEN_STUBS_DO(DEFINE_STUB_NAME)\n+};\n+\n+#undef DEFINE_STUB_NAME\n+\n+\/\/ Define fields used to store blobs\n+\n+#define DEFINE_BLOB_FIELD(blob_name) \\\n+  BufferBlob* StubRoutines:: STUBGEN_BLOB_FIELD_NAME(blob_name) = nullptr;\n+\n+STUBGEN_BLOBS_DO(DEFINE_BLOB_FIELD)\n+\n+#undef DEFINE_BLOB_FIELD\n+\n+\/\/ Define fields used to store stub entries\n@@ -148,29 +85,2 @@\n-address StubRoutines::_crc32c_table_addr = nullptr;\n-address StubRoutines::_updateBytesCRC32C = nullptr;\n-address StubRoutines::_updateBytesAdler32 = nullptr;\n-\n-address StubRoutines::_multiplyToLen = nullptr;\n-address StubRoutines::_squareToLen = nullptr;\n-address StubRoutines::_mulAdd = nullptr;\n-address StubRoutines::_montgomeryMultiply = nullptr;\n-address StubRoutines::_montgomerySquare = nullptr;\n-address StubRoutines::_bigIntegerRightShiftWorker = nullptr;\n-address StubRoutines::_bigIntegerLeftShiftWorker = nullptr;\n-\n-address StubRoutines::_vectorizedMismatch = nullptr;\n-\n-address StubRoutines::_dexp = nullptr;\n-address StubRoutines::_dlog = nullptr;\n-address StubRoutines::_dlog10 = nullptr;\n-address StubRoutines::_fmod = nullptr;\n-address StubRoutines::_dpow = nullptr;\n-address StubRoutines::_dsin = nullptr;\n-address StubRoutines::_dcos = nullptr;\n-address StubRoutines::_dlibm_sin_cos_huge = nullptr;\n-address StubRoutines::_dlibm_reduce_pi04l = nullptr;\n-address StubRoutines::_dlibm_tan_cot_huge = nullptr;\n-address StubRoutines::_dtan = nullptr;\n-address StubRoutines::_dtanh = nullptr;\n-\n-address StubRoutines::_f2hf = nullptr;\n-address StubRoutines::_hf2f = nullptr;\n+#define DEFINE_ENTRY_FIELD(blob_name, stub_name, field_name, getter_name) \\\n+  address StubRoutines:: STUB_FIELD_NAME(field_name) = nullptr;\n@@ -178,0 +88,15 @@\n+#define DEFINE_ENTRY_FIELD_INIT(blob_name, stub_name, field_name, getter_name, init_function) \\\n+  address StubRoutines:: STUB_FIELD_NAME(field_name) = CAST_FROM_FN_PTR(address, init_function);\n+\n+#define DEFINE_ENTRY_FIELD_ARRAY(blob_name, stub_name, field_name, getter_name, count) \\\n+  address StubRoutines:: STUB_FIELD_NAME(field_name)[count] = { nullptr };\n+\n+STUBGEN_ENTRIES_DO(DEFINE_ENTRY_FIELD, DEFINE_ENTRY_FIELD_INIT, DEFINE_ENTRY_FIELD_ARRAY)\n+\n+#undef DEFINE_ENTRY_FIELD_ARRAY\n+#undef DEFINE_ENTRY_FIELD_INIT\n+#undef DEFINE_ENTRY_FIELD\n+\n+jint    StubRoutines::_verify_oop_count                         = 0;\n+\n+address StubRoutines::_string_indexof_array[4]   =    { nullptr };\n@@ -181,3 +106,55 @@\n-address StubRoutines::_method_entry_barrier = nullptr;\n-address StubRoutines::_array_sort = nullptr;\n-address StubRoutines::_array_partition  = nullptr;\n+const char* StubRoutines::get_blob_name(StubGenBlobId id) {\n+  assert(0 <= id && id < StubGenBlobId::NUM_BLOBIDS, \"invalid blob id\");\n+  return _blob_names[id];\n+}\n+\n+const char* StubRoutines::get_stub_name(StubGenStubId id) {\n+  assert(0 <= id && id < StubGenStubId::NUM_STUBIDS, \"invalid stub id\");\n+  return _stub_names[id];\n+}\n+\n+#ifdef ASSERT\n+\n+\/\/ array holding start and end indices for stub ids associated with a\n+\/\/ given blob. Given a blob with id (StubGenBlobId) blob_id for any\n+\/\/ stub with id (StubGenStubId) stub_id declared within the blob:\n+\/\/ _blob_offsets[blob_id] <= stub_id < _blob_offsets[blob_id+1]\n+\n+static int _blob_limits[StubGenBlobId::NUM_BLOBIDS + 1];\n+\n+\/\/ macro used to compute blob limits\n+#define BLOB_COUNT(blob_name)                                           \\\n+  counter += StubGenStubId_ ## blob_name :: NUM_STUBIDS_ ## blob_name;  \\\n+  _blob_limits[++index] = counter;                                      \\\n+\n+\/\/ macro that checks stubs are associated with the correct blobs\n+#define STUB_VERIFY(blob_name, stub_name)                               \\\n+  localStubId = (int) (StubGenStubId_ ## blob_name :: blob_name ## _ ## stub_name ## _id); \\\n+  globalStubId = (int) (StubGenStubId:: stub_name ## _id);              \\\n+  blobId = (int) (StubGenBlobId:: blob_name ## _id);                    \\\n+  assert((globalStubId >= _blob_limits[blobId] &&                       \\\n+          globalStubId < _blob_limits[blobId+1]),                       \\\n+         \"stub \" # stub_name \" uses incorrect blob name \" # blob_name); \\\n+  assert(globalStubId == _blob_limits[blobId] + localStubId,            \\\n+         \"stub \" # stub_name \" id found at wrong offset!\");             \\\n+\n+bool verifyStubIds() {\n+  \/\/ first compute the blob limits\n+  int counter = 0;\n+  int index = 0;\n+  \/\/ populate offsets table with cumulative total of local enum counts\n+  STUBGEN_BLOBS_DO(BLOB_COUNT);\n+\n+  \/\/ ensure 1) global stub ids lie in the range of the associated blob\n+  \/\/ and 2) each blob's base + local stub id == global stub id\n+  int globalStubId, blobId, localStubId;\n+  STUBGEN_STUBS_DO(STUB_VERIFY);\n+  return true;\n+}\n+\n+#undef BLOB_COUNT\n+#undef STUB_VERIFY\n+\n+\/\/ ensure we verify the blob ids when this compile unit is first entered\n+bool _verified_stub_ids = verifyStubIds();\n+\n@@ -185,4 +162,1 @@\n-address StubRoutines::_cont_thaw          = nullptr;\n-address StubRoutines::_cont_returnBarrier = nullptr;\n-address StubRoutines::_cont_returnBarrierExc = nullptr;\n-address StubRoutines::_cont_preempt_stub = nullptr;\n+\/\/ macro used by stub to blob translation\n@@ -190,2 +164,3 @@\n-address StubRoutines::_upcall_stub_exception_handler = nullptr;\n-address StubRoutines::_upcall_stub_load_target = nullptr;\n+#define BLOB_CHECK_OFFSET(blob_name)                                \\\n+  if (id < _blob_limits[((int)blobId) + 1]) { return blobId; }      \\\n+  blobId = StubGenBlobId:: blob_name ## _id;                        \\\n@@ -193,2 +168,2 @@\n-address StubRoutines::_lookup_secondary_supers_table_slow_path_stub = nullptr;\n-address StubRoutines::_lookup_secondary_supers_table_stubs[Klass::SECONDARY_SUPERS_TABLE_SIZE] = { nullptr };\n+\/\/ translate a global stub id to an associated blob id based on the\n+\/\/ computed blob limits\n@@ -196,0 +171,12 @@\n+StubGenBlobId StubRoutines::stub_to_blob(StubGenStubId stubId) {\n+  int id = (int)stubId;\n+  assert(id > ((int)StubGenStubId::NO_STUBID) && id < ((int)StubGenStubId::NUM_STUBIDS), \"stub id out of range!\");\n+  \/\/ start with no blob to catch stub id == -1\n+  StubGenBlobId blobId = StubGenBlobId::NO_BLOBID;\n+  STUBGEN_BLOBS_DO(BLOB_CHECK_OFFSET);\n+  \/\/ if we reach here we should have the last blob id\n+  assert(blobId == StubGenBlobId::NUM_BLOBIDS - 1, \"unexpected blob id\");\n+  return blobId;\n+}\n+\n+#endif \/\/ ASSERT\n@@ -203,1 +190,1 @@\n-extern void StubGenerator_generate(CodeBuffer* code, StubCodeGenerator::StubsKind kind); \/\/ only interface to generators\n+extern void StubGenerator_generate(CodeBuffer* code, StubGenBlobId blob_id); \/\/ only interface to generators\n@@ -231,1 +218,1 @@\n-static BufferBlob* initialize_stubs(StubCodeGenerator::StubsKind kind,\n+static BufferBlob* initialize_stubs(StubGenBlobId blob_id,\n@@ -245,1 +232,1 @@\n-  StubGenerator_generate(&buffer, kind);\n+  StubGenerator_generate(&buffer, blob_id);\n@@ -260,7 +247,13 @@\n-void StubRoutines::initialize_initial_stubs() {\n-  if (_initial_stubs_code == nullptr) {\n-    _initial_stubs_code = initialize_stubs(StubCodeGenerator::Initial_stubs,\n-                                           _initial_stubs_code_size, 10,\n-                                           \"StubRoutines generation initial stubs\",\n-                                           \"StubRoutines (initial stubs)\",\n-                                           \"_initial_stubs_code_size\");\n+#define DEFINE_BLOB_INIT_METHOD(blob_name)                              \\\n+  void StubRoutines::initialize_ ## blob_name ## _stubs() {             \\\n+    if (STUBGEN_BLOB_FIELD_NAME(blob_name) == nullptr) {                \\\n+      StubGenBlobId blob_id = StubGenBlobId:: STUB_ID_NAME(blob_name);  \\\n+      int size = _ ## blob_name ## _code_size;                          \\\n+      int max_aligned_size = 10;                                        \\\n+      const char* timer_msg = \"StubRoutines generation \" # blob_name \" stubs\"; \\\n+      const char* name = \"StubRoutines (\" # blob_name \"stubs)\";         \\\n+      const char* assert_msg = \"_\" # blob_name \"_code_size\";            \\\n+      STUBGEN_BLOB_FIELD_NAME(blob_name) =                              \\\n+        initialize_stubs(blob_id, size, max_aligned_size, timer_msg,    \\\n+                         name, assert_msg);                             \\\n+    }                                                                   \\\n@@ -268,1 +261,0 @@\n-}\n@@ -270,9 +262,0 @@\n-void StubRoutines::initialize_continuation_stubs() {\n-  if (_continuation_stubs_code == nullptr) {\n-    _continuation_stubs_code = initialize_stubs(StubCodeGenerator::Continuation_stubs,\n-                                           _continuation_stubs_code_size, 10,\n-                                           \"StubRoutines generation continuation stubs\",\n-                                           \"StubRoutines (continuation stubs)\",\n-                                           \"_continuation_stubs_code_size\");\n-  }\n-}\n@@ -280,9 +263,1 @@\n-void StubRoutines::initialize_compiler_stubs() {\n-  if (_compiler_stubs_code == nullptr) {\n-    _compiler_stubs_code = initialize_stubs(StubCodeGenerator::Compiler_stubs,\n-                                           _compiler_stubs_code_size, 100,\n-                                           \"StubRoutines generation compiler stubs\",\n-                                           \"StubRoutines (compiler stubs)\",\n-                                           \"_compiler_stubs_code_size\");\n-  }\n-}\n+STUBGEN_BLOBS_DO(DEFINE_BLOB_INIT_METHOD)\n@@ -290,8 +265,6 @@\n-void StubRoutines::initialize_final_stubs() {\n-  if (_final_stubs_code == nullptr) {\n-    _final_stubs_code = initialize_stubs(StubCodeGenerator::Final_stubs,\n-                                         _final_stubs_code_size, 10,\n-                                         \"StubRoutines generation final stubs\",\n-                                         \"StubRoutines (final stubs)\",\n-                                         \"_final_stubs_code_size\");\n-  }\n+#undef DEFINE_BLOB_INIT_METHOD\n+\n+\n+#define DEFINE_BLOB_INIT_FUNCTION(blob_name)            \\\n+void blob_name ## _stubs_init()  {                      \\\n+  StubRoutines::initialize_ ## blob_name ## _stubs();   \\\n@@ -300,3 +273,10 @@\n-void initial_stubs_init()      { StubRoutines::initialize_initial_stubs(); }\n-void continuation_stubs_init() { StubRoutines::initialize_continuation_stubs(); }\n-void final_stubs_init()        { StubRoutines::initialize_final_stubs(); }\n+STUBGEN_BLOBS_DO(DEFINE_BLOB_INIT_FUNCTION)\n+\n+#undef DEFINE_BLOB_INIT_FUNCTION\n+\n+\/*\n+ * we generate the underlying driver method but this wrapper is needed\n+ * to perform special handling depending on where the compiler init\n+ * gets called from. it ought to be possible to remove this at some\n+ * point and have adeterminate ordered init.\n+ *\/\n@@ -319,0 +299,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":155,"deletions":174,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"runtime\/stubDeclarations.hpp\"\n@@ -153,0 +154,45 @@\n+\/\/ declare stubgen blob id enum\n+\n+#define BLOB_ENUM_DECLARE(blob_name) \\\n+  STUB_ID_NAME(blob_name),\n+\n+enum StubGenBlobId : int {\n+  NO_BLOBID = -1,\n+  STUBGEN_BLOBS_DO(BLOB_ENUM_DECLARE)\n+  NUM_BLOBIDS\n+};\n+\n+#undef BLOB_ENUM_DECLARE\n+\n+\/\/ declare blob local stub id enums\n+\n+#define BLOB_LOCAL_ENUM_START(blob_name)        \\\n+  enum StubGenStubId_ ## blob_name {            \\\n+    NO_STUBID_ ## blob_name = -1,\n+\n+#define BLOB_LOCAL_ENUM_END(blob_name)   \\\n+    NUM_STUBIDS_ ## blob_name            \\\n+  };\n+\n+#define BLOB_LOCAL_STUB_ENUM_DECLARE(blob_name, stub_name) \\\n+  blob_name ## _ ## stub_name ## _id,\n+\n+STUBGEN_BLOBS_STUBS_DO(BLOB_LOCAL_ENUM_START, BLOB_LOCAL_ENUM_END, BLOB_LOCAL_STUB_ENUM_DECLARE)\n+\n+#undef BLOB_LOCAL_ENUM_START\n+#undef BLOB_LOCAL_ENUM_END\n+#undef BLOB_LOCAL_STUB_ENUM_DECLARE\n+\n+\/\/ declare global stub id enum\n+\n+#define STUB_ENUM_DECLARE(blob_name, stub_name) \\\n+  STUB_ID_NAME(stub_name) ,\n+\n+enum StubGenStubId : int {\n+  NO_STUBID = -1,\n+  STUBGEN_STUBS_DO(STUB_ENUM_DECLARE)\n+  NUM_STUBIDS\n+};\n+\n+#undef STUB_ENUM_DECLARE\n+\n@@ -155,1 +201,1 @@\n- public:\n+public:\n@@ -158,0 +204,4 @@\n+  friend class VMStructs;\n+#if INCLUDE_JVMCI\n+  friend class JVMCIVMStructs;\n+#endif\n@@ -161,96 +211,1 @@\n-  static jint    _verify_oop_count;\n-  static address _verify_oop_subroutine_entry;\n-\n-  static address _call_stub_return_address;                \/\/ the return PC, when returning to a call stub\n-  static address _call_stub_entry;\n-  static address _forward_exception_entry;\n-  static address _catch_exception_entry;\n-\n-  static address _atomic_xchg_entry;\n-  static address _atomic_cmpxchg_entry;\n-  static address _atomic_cmpxchg_long_entry;\n-  static address _atomic_add_entry;\n-  static address _fence_entry;\n-\n-  static BufferBlob* _initial_stubs_code;                  \/\/ code buffer for initial routines\n-  static BufferBlob* _continuation_stubs_code;             \/\/ code buffer for continuation stubs\n-  static BufferBlob* _compiler_stubs_code;                 \/\/ code buffer for C2 intrinsics\n-  static BufferBlob* _final_stubs_code;                    \/\/ code buffer for all other routines\n-\n-  static address _array_sort;\n-  static address _array_partition;\n-  \/\/ Leaf routines which implement arraycopy and their addresses\n-  \/\/ arraycopy operands aligned on element type boundary\n-  static address _jbyte_arraycopy;\n-  static address _jshort_arraycopy;\n-  static address _jint_arraycopy;\n-  static address _jlong_arraycopy;\n-  static address _oop_arraycopy, _oop_arraycopy_uninit;\n-  static address _jbyte_disjoint_arraycopy;\n-  static address _jshort_disjoint_arraycopy;\n-  static address _jint_disjoint_arraycopy;\n-  static address _jlong_disjoint_arraycopy;\n-  static address _oop_disjoint_arraycopy, _oop_disjoint_arraycopy_uninit;\n-\n-  \/\/ arraycopy operands aligned on zero'th element boundary\n-  \/\/ These are identical to the ones aligned aligned on an\n-  \/\/ element type boundary, except that they assume that both\n-  \/\/ source and destination are HeapWord aligned.\n-  static address _arrayof_jbyte_arraycopy;\n-  static address _arrayof_jshort_arraycopy;\n-  static address _arrayof_jint_arraycopy;\n-  static address _arrayof_jlong_arraycopy;\n-  static address _arrayof_oop_arraycopy, _arrayof_oop_arraycopy_uninit;\n-  static address _arrayof_jbyte_disjoint_arraycopy;\n-  static address _arrayof_jshort_disjoint_arraycopy;\n-  static address _arrayof_jint_disjoint_arraycopy;\n-  static address _arrayof_jlong_disjoint_arraycopy;\n-  static address _arrayof_oop_disjoint_arraycopy, _arrayof_oop_disjoint_arraycopy_uninit;\n-\n-  \/\/ cache line writeback\n-  static address _data_cache_writeback;\n-  static address _data_cache_writeback_sync;\n-\n-  \/\/ these are recommended but optional:\n-  static address _checkcast_arraycopy, _checkcast_arraycopy_uninit;\n-  static address _unsafe_arraycopy;\n-  static address _generic_arraycopy;\n-\n-  static address _unsafe_setmemory;\n-\n-  static address _jbyte_fill;\n-  static address _jshort_fill;\n-  static address _jint_fill;\n-  static address _arrayof_jbyte_fill;\n-  static address _arrayof_jshort_fill;\n-  static address _arrayof_jint_fill;\n-\n-  static address _aescrypt_encryptBlock;\n-  static address _aescrypt_decryptBlock;\n-  static address _cipherBlockChaining_encryptAESCrypt;\n-  static address _cipherBlockChaining_decryptAESCrypt;\n-  static address _electronicCodeBook_encryptAESCrypt;\n-  static address _electronicCodeBook_decryptAESCrypt;\n-  static address _counterMode_AESCrypt;\n-  static address _galoisCounterMode_AESCrypt;\n-  static address _ghash_processBlocks;\n-  static address _chacha20Block;\n-  static address _base64_encodeBlock;\n-  static address _base64_decodeBlock;\n-  static address _poly1305_processBlocks;\n-  static address _intpoly_montgomeryMult_P256;\n-  static address _intpoly_assign;\n-\n-  static address _md5_implCompress;\n-  static address _md5_implCompressMB;\n-  static address _sha1_implCompress;\n-  static address _sha1_implCompressMB;\n-  static address _sha256_implCompress;\n-  static address _sha256_implCompressMB;\n-  static address _sha512_implCompress;\n-  static address _sha512_implCompressMB;\n-  static address _sha3_implCompress;\n-  static address _sha3_implCompressMB;\n-\n-  static address _updateBytesCRC32;\n-  static address _crc_table_adr;\n+\/\/ declare blob and stub name storage and associated lookup methods\n@@ -258,1 +213,4 @@\n-  static address _string_indexof_array[4];\n+private:\n+  static bool _inited_names;\n+  static const char* _blob_names[StubGenBlobId::NUM_BLOBIDS];\n+  static const char* _stub_names[StubGenStubId::NUM_STUBIDS];\n@@ -260,36 +218,4 @@\n-  static address _crc32c_table_addr;\n-  static address _updateBytesCRC32C;\n-  static address _updateBytesAdler32;\n-\n-  static address _multiplyToLen;\n-  static address _squareToLen;\n-  static address _mulAdd;\n-  static address _montgomeryMultiply;\n-  static address _montgomerySquare;\n-  static address _bigIntegerRightShiftWorker;\n-  static address _bigIntegerLeftShiftWorker;\n-\n-  static address _vectorizedMismatch;\n-\n-  static address _dexp;\n-  static address _dlog;\n-  static address _dlog10;\n-  static address _dpow;\n-  static address _dsin;\n-  static address _dcos;\n-  static address _dlibm_sin_cos_huge;\n-  static address _dlibm_reduce_pi04l;\n-  static address _dlibm_tan_cot_huge;\n-  static address _dtan;\n-  static address _dtanh;\n-  static address _fmod;\n-\n-  static address _f2hf;\n-  static address _hf2f;\n-\n-  static address _method_entry_barrier;\n-\n-  static address _cont_thaw;\n-  static address _cont_returnBarrier;\n-  static address _cont_returnBarrierExc;\n-  static address _cont_preempt_stub;\n+public:\n+  static bool init_names();\n+  static const char* get_blob_name(StubGenBlobId id);\n+  static const char* get_stub_name(StubGenStubId id);\n@@ -297,3 +223,1 @@\n-  \/\/ Vector Math Routines\n-  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n-  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n+\/\/ declare blob fields\n@@ -301,2 +225,2 @@\n-  static address _upcall_stub_exception_handler;\n-  static address _upcall_stub_load_target;\n+#define DECLARE_BLOB_FIELD(blob_name) \\\n+  static BufferBlob* STUBGEN_BLOB_FIELD_NAME(blob_name);\n@@ -304,2 +228,2 @@\n-  static address _lookup_secondary_supers_table_stubs[];\n-  static address _lookup_secondary_supers_table_slow_path_stub;\n+private:\n+  STUBGEN_BLOBS_DO(DECLARE_BLOB_FIELD);\n@@ -307,6 +231,1 @@\n- public:\n-  \/\/ Initialization\/Testing\n-  static void    initialize_initial_stubs();               \/\/ must happen before universe::genesis\n-  static void    initialize_continuation_stubs();          \/\/ must happen after  universe::genesis\n-  static void    initialize_compiler_stubs();              \/\/ must happen after  universe::genesis\n-  static void    initialize_final_stubs();                 \/\/ must happen after  universe::genesis\n+#undef DECLARE_BLOB_FIELD\n@@ -314,1 +233,1 @@\n-  static bool is_stub_code(address addr)                   { return contains(addr); }\n+\/\/ declare fields to store entry addresses\n@@ -316,7 +235,2 @@\n-  static bool contains(address addr) {\n-    return\n-      (_initial_stubs_code      != nullptr && _initial_stubs_code->blob_contains(addr))  ||\n-      (_continuation_stubs_code != nullptr && _continuation_stubs_code->blob_contains(addr)) ||\n-      (_compiler_stubs_code     != nullptr && _compiler_stubs_code->blob_contains(addr)) ||\n-      (_final_stubs_code        != nullptr && _final_stubs_code->blob_contains(addr)) ;\n-  }\n+#define DECLARE_ENTRY_FIELD(blob_name, stub_name, field_name, getter_name) \\\n+  static address STUB_FIELD_NAME(field_name);\n@@ -324,4 +238,2 @@\n-  static RuntimeBlob* initial_stubs_code()      { return _initial_stubs_code; }\n-  static RuntimeBlob* continuation_stubs_code() { return _continuation_stubs_code; }\n-  static RuntimeBlob* compiler_stubs_code()     { return _compiler_stubs_code; }\n-  static RuntimeBlob* final_stubs_code()        { return _final_stubs_code; }\n+#define DECLARE_ENTRY_FIELD_INIT(blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DECLARE_ENTRY_FIELD(blob_name, stub_name, field_name, getter_name)\n@@ -329,5 +241,39 @@\n-  \/\/ Debugging\n-  static jint    verify_oop_count()                        { return _verify_oop_count; }\n-  static jint*   verify_oop_count_addr()                   { return &_verify_oop_count; }\n-  \/\/ a subroutine for debugging the GC\n-  static address verify_oop_subroutine_entry_address()     { return (address)&_verify_oop_subroutine_entry; }\n+#define DECLARE_ENTRY_FIELD_ARRAY(blob_name, stub_name, field_name, getter_name, count) \\\n+  static address STUB_FIELD_NAME(field_name)[count];\n+\n+private:\n+  STUBGEN_ENTRIES_DO(DECLARE_ENTRY_FIELD, DECLARE_ENTRY_FIELD_INIT, DECLARE_ENTRY_FIELD_ARRAY);\n+\n+#undef DECLARE_ENTRY_FIELD_ARRAY\n+#undef DECLARE_ENTRY_FIELD_INIT\n+#undef DECLARE_ENTRY_FIELD\n+\n+\/\/ declare getters and setters for entry addresses\n+\n+#define DEFINE_ENTRY_GETTER(blob_name, stub_name, field_name, getter_name) \\\n+  static address getter_name() { return STUB_FIELD_NAME(field_name); } \\\n+\n+#define DEFINE_ENTRY_GETTER_INIT(blob_name, stub_name, field_name, getter_name, init_function) \\\n+  DEFINE_ENTRY_GETTER(blob_name, stub_name, field_name, getter_name)\n+\n+#define DEFINE_ENTRY_GETTER_ARRAY(blob_name, stub_name, field_name, getter_name, count) \\\n+  static address getter_name(int idx) {                                 \\\n+    assert(idx < count, \"out of bounds\");                               \\\n+    return STUB_FIELD_NAME(field_name)[idx];                            \\\n+  }                                                                     \\\n+\n+public:\n+  STUBGEN_ENTRIES_DO(DEFINE_ENTRY_GETTER, DEFINE_ENTRY_GETTER_INIT, DEFINE_ENTRY_GETTER_ARRAY);\n+\n+#undef DEFINE_ENTRY_GETTER_ARRAY\n+#undef DEFINE_ENTRY_GETTER_INIT\n+#undef DEFINE_ENTRY_GETTER\n+\n+public:\n+\n+#define DECLARE_BLOB_INIT_METHOD(blob_name)     \\\n+  static void initialize_ ## blob_name ## _stubs();\n+\n+  STUBGEN_BLOBS_DO(DECLARE_BLOB_INIT_METHOD)\n+\n+#undef DECLARE_BLOB_INIT_METHOD\n@@ -335,1 +281,1 @@\n-  static address catch_exception_entry()                   { return _catch_exception_entry; }\n+public:\n@@ -349,1 +295,32 @@\n-  static CallStub call_stub()                              { return CAST_TO_FN_PTR(CallStub, _call_stub_entry); }\n+  static jint    _verify_oop_count;\n+\n+public:\n+  \/\/ this is used by x86_64 to expose string index stubs to the opto\n+  \/\/ library as a target to a call planted before back end lowering.\n+  \/\/ all other arches plant the call to the stub during back end\n+  \/\/ lowering and use arch-specific entries. we really need to\n+  \/\/ rationalise this at some point.\n+\n+  static address _string_indexof_array[4];\n+\n+  \/* special case: stub employs array of entries *\/\n+\n+  \/\/ Vector Math Routines\n+  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n+  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n+\n+  static bool is_stub_code(address addr)                   { return contains(addr); }\n+\n+  \/\/ generate code to implement method contains\n+\n+#define CHECK_ADDRESS_IN_BLOB(blob_name) \\\n+  blob = STUBGEN_BLOB_FIELD_NAME(blob_name); \\\n+  if (blob != nullptr && blob->blob_contains(addr)) { return true; }\n+\n+  static bool contains(address addr) {\n+    BufferBlob *blob;\n+    STUBGEN_BLOBS_DO(CHECK_ADDRESS_IN_BLOB)\n+    return false;\n+  }\n+#undef CHECK_ADDRESS_IN_BLOB\n+\/\/ define getters for stub code blobs\n@@ -351,2 +328,2 @@\n-  \/\/ Exceptions\n-  static address forward_exception_entry()                 { return _forward_exception_entry; }\n+#define DEFINE_BLOB_GETTER(blob_name) \\\n+  static RuntimeBlob* blob_name ## _stubs_code() { return _ ## blob_name ## _stubs_code; }\n@@ -354,5 +331,16 @@\n-  static address atomic_xchg_entry()                       { return _atomic_xchg_entry; }\n-  static address atomic_cmpxchg_entry()                    { return _atomic_cmpxchg_entry; }\n-  static address atomic_cmpxchg_long_entry()               { return _atomic_cmpxchg_long_entry; }\n-  static address atomic_add_entry()                        { return _atomic_add_entry; }\n-  static address fence_entry()                             { return _fence_entry; }\n+  STUBGEN_BLOBS_DO(DEFINE_BLOB_GETTER);\n+\n+#undef DEFINE_BLOB_GETTER\n+\n+#ifdef ASSERT\n+  \/\/ provide a translation from stub id to its associated blob id\n+  static StubGenBlobId stub_to_blob(StubGenStubId stubId);\n+#endif\n+\n+  \/\/ Debugging\n+  static jint    verify_oop_count()                        { return _verify_oop_count; }\n+  static jint*   verify_oop_count_addr()                   { return &_verify_oop_count; }\n+  \/\/ a subroutine for debugging the GC\n+  static address verify_oop_subroutine_entry_address()     { return (address)&_verify_oop_subroutine_entry; }\n+\n+  static CallStub call_stub()                              { return CAST_TO_FN_PTR(CallStub, _call_stub_entry); }\n@@ -362,4 +350,0 @@\n-  static address jbyte_arraycopy()  { return _jbyte_arraycopy; }\n-  static address jshort_arraycopy() { return _jshort_arraycopy; }\n-  static address jint_arraycopy()   { return _jint_arraycopy; }\n-  static address jlong_arraycopy()  { return _jlong_arraycopy; }\n@@ -369,4 +353,1 @@\n-  static address jbyte_disjoint_arraycopy()  { return _jbyte_disjoint_arraycopy; }\n-  static address jshort_disjoint_arraycopy() { return _jshort_disjoint_arraycopy; }\n-  static address jint_disjoint_arraycopy()   { return _jint_disjoint_arraycopy; }\n-  static address jlong_disjoint_arraycopy()  { return _jlong_disjoint_arraycopy; }\n+\n@@ -377,4 +358,0 @@\n-  static address arrayof_jbyte_arraycopy()  { return _arrayof_jbyte_arraycopy; }\n-  static address arrayof_jshort_arraycopy() { return _arrayof_jshort_arraycopy; }\n-  static address arrayof_jint_arraycopy()   { return _arrayof_jint_arraycopy; }\n-  static address arrayof_jlong_arraycopy()  { return _arrayof_jlong_arraycopy; }\n@@ -385,4 +362,0 @@\n-  static address arrayof_jbyte_disjoint_arraycopy()  { return _arrayof_jbyte_disjoint_arraycopy; }\n-  static address arrayof_jshort_disjoint_arraycopy() { return _arrayof_jshort_disjoint_arraycopy; }\n-  static address arrayof_jint_disjoint_arraycopy()   { return _arrayof_jint_disjoint_arraycopy; }\n-  static address arrayof_jlong_disjoint_arraycopy()  { return _arrayof_jlong_disjoint_arraycopy; }\n@@ -392,2 +365,0 @@\n-  static address data_cache_writeback()              { return _data_cache_writeback; }\n-  static address data_cache_writeback_sync()         { return _data_cache_writeback_sync; }\n@@ -403,1 +374,0 @@\n-  static address unsafe_arraycopy()     { return _unsafe_arraycopy; }\n@@ -408,2 +378,0 @@\n-  static address unsafe_setmemory()     { return _unsafe_setmemory; }\n-\n@@ -413,74 +381,0 @@\n-  static address generic_arraycopy()   { return _generic_arraycopy; }\n-  static address select_arraysort_function() { return _array_sort; }\n-  static address select_array_partition_function() { return _array_partition; }\n-\n-  static address jbyte_fill()          { return _jbyte_fill; }\n-  static address jshort_fill()         { return _jshort_fill; }\n-  static address jint_fill()           { return _jint_fill; }\n-  static address arrayof_jbyte_fill()  { return _arrayof_jbyte_fill; }\n-  static address arrayof_jshort_fill() { return _arrayof_jshort_fill; }\n-  static address arrayof_jint_fill()   { return _arrayof_jint_fill; }\n-\n-  static address aescrypt_encryptBlock()                { return _aescrypt_encryptBlock; }\n-  static address aescrypt_decryptBlock()                { return _aescrypt_decryptBlock; }\n-  static address cipherBlockChaining_encryptAESCrypt()  { return _cipherBlockChaining_encryptAESCrypt; }\n-  static address cipherBlockChaining_decryptAESCrypt()  { return _cipherBlockChaining_decryptAESCrypt; }\n-  static address electronicCodeBook_encryptAESCrypt()   { return _electronicCodeBook_encryptAESCrypt; }\n-  static address electronicCodeBook_decryptAESCrypt()   { return _electronicCodeBook_decryptAESCrypt; }\n-  static address poly1305_processBlocks()               { return _poly1305_processBlocks; }\n-  static address intpoly_montgomeryMult_P256()          { return _intpoly_montgomeryMult_P256; }\n-  static address intpoly_assign()        { return _intpoly_assign; }\n-  static address counterMode_AESCrypt()  { return _counterMode_AESCrypt; }\n-  static address ghash_processBlocks()   { return _ghash_processBlocks; }\n-  static address chacha20Block()         { return _chacha20Block; }\n-  static address base64_encodeBlock()    { return _base64_encodeBlock; }\n-  static address base64_decodeBlock()    { return _base64_decodeBlock; }\n-  static address md5_implCompress()      { return _md5_implCompress; }\n-  static address md5_implCompressMB()    { return _md5_implCompressMB; }\n-  static address sha1_implCompress()     { return _sha1_implCompress; }\n-  static address sha1_implCompressMB()   { return _sha1_implCompressMB; }\n-  static address sha256_implCompress()   { return _sha256_implCompress; }\n-  static address sha256_implCompressMB() { return _sha256_implCompressMB; }\n-  static address sha512_implCompress()   { return _sha512_implCompress; }\n-  static address sha512_implCompressMB() { return _sha512_implCompressMB; }\n-  static address sha3_implCompress()     { return _sha3_implCompress; }\n-  static address sha3_implCompressMB()   { return _sha3_implCompressMB; }\n-\n-  static address updateBytesCRC32()    { return _updateBytesCRC32; }\n-  static address crc_table_addr()      { return _crc_table_adr; }\n-\n-  static address crc32c_table_addr()   { return _crc32c_table_addr; }\n-  static address updateBytesCRC32C()   { return _updateBytesCRC32C; }\n-  static address updateBytesAdler32()  { return _updateBytesAdler32; }\n-\n-  static address multiplyToLen()       { return _multiplyToLen; }\n-  static address squareToLen()         { return _squareToLen; }\n-  static address mulAdd()              { return _mulAdd; }\n-  static address montgomeryMultiply()  { return _montgomeryMultiply; }\n-  static address montgomerySquare()    { return _montgomerySquare; }\n-  static address bigIntegerRightShift() { return _bigIntegerRightShiftWorker; }\n-  static address bigIntegerLeftShift()  { return _bigIntegerLeftShiftWorker; }\n-  static address galoisCounterMode_AESCrypt()   { return _galoisCounterMode_AESCrypt; }\n-\n-  static address vectorizedMismatch()  { return _vectorizedMismatch; }\n-\n-  static address dexp()                { return _dexp; }\n-  static address dlog()                { return _dlog; }\n-  static address dlog10()              { return _dlog10; }\n-  static address dpow()                { return _dpow; }\n-  static address fmod()                { return _fmod; }\n-  static address dsin()                { return _dsin; }\n-  static address dcos()                { return _dcos; }\n-  static address dlibm_reduce_pi04l()  { return _dlibm_reduce_pi04l; }\n-  static address dlibm_sin_cos_huge()  { return _dlibm_sin_cos_huge; }\n-  static address dlibm_tan_cot_huge()  { return _dlibm_tan_cot_huge; }\n-  static address dtan()                { return _dtan; }\n-  static address dtanh()               { return _dtanh; }\n-\n-  \/\/ These are versions of the java.lang.Float::floatToFloat16() and float16ToFloat()\n-  \/\/ methods which perform the same operations as the intrinsic version.\n-  \/\/ They are used for constant folding in JIT compiler to ensure equivalence.\n-  \/\/\n-  static address f2hf_adr()            { return _f2hf; }\n-  static address hf2f_adr()            { return _hf2f; }\n-\n@@ -500,28 +394,0 @@\n-  static address method_entry_barrier() { return _method_entry_barrier; }\n-\n-  static address cont_thaw()           { return _cont_thaw; }\n-  static address cont_returnBarrier()  { return _cont_returnBarrier; }\n-  static address cont_returnBarrierExc(){return _cont_returnBarrierExc; }\n-  static address cont_preempt_stub()   { return _cont_preempt_stub; }\n-\n-  static address upcall_stub_exception_handler() {\n-    assert(_upcall_stub_exception_handler != nullptr, \"not implemented\");\n-    return _upcall_stub_exception_handler;\n-  }\n-\n-  static address upcall_stub_load_target() {\n-    assert(_upcall_stub_load_target != nullptr, \"not implemented\");\n-    return _upcall_stub_load_target;\n-  }\n-\n-  static address lookup_secondary_supers_table_stub(u1 slot) {\n-    assert(slot < Klass::SECONDARY_SUPERS_TABLE_SIZE, \"out of bounds\");\n-    assert(_lookup_secondary_supers_table_stubs[slot] != nullptr, \"not implemented\");\n-    return _lookup_secondary_supers_table_stubs[slot];\n-  }\n-\n-  static address lookup_secondary_supers_table_slow_path_stub() {\n-    assert(_lookup_secondary_supers_table_slow_path_stub != nullptr, \"not implemented\");\n-    return _lookup_secondary_supers_table_slow_path_stub;\n-  }\n-\n@@ -530,3 +396,2 @@\n-  \/\/\n-  \/\/ Default versions of the above arraycopy functions for platforms which do\n-  \/\/ not have specialized versions\n+  \/\/ Default versions of some of the arraycopy functions for platforms\n+  \/\/ which do not have specialized versions\n@@ -547,0 +412,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":166,"deletions":300,"binary":false,"changes":466,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  if (StubRoutines::_##type##_fill != nullptr) {                                             \\\n+  if (StubRoutines::type##_fill() != nullptr) {                         \\\n@@ -127,1 +127,1 @@\n-            ((void (*)(type*, int, int))StubRoutines::_arrayof_##type##_fill)(start, v, 80); \\\n+            ((void (*)(type*, int, int))StubRoutines::arrayof_##type##_fill())(start, v, 80); \\\n@@ -132,1 +132,1 @@\n-          ((void (*)(type*, int, int))StubRoutines::_##type##_fill)(start, v, 80);           \\\n+          ((void (*)(type*, int, int))StubRoutines::type##_fill())(start, v, 80); \\\n","filename":"test\/hotspot\/gtest\/runtime\/test_stubRoutines.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}