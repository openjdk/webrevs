{"files":[{"patch":"@@ -30,1 +30,0 @@\n-                                      repeat_stub,                      \\\n@@ -38,1 +37,0 @@\n-                                           repeat_stub,                 \\\n@@ -46,1 +44,0 @@\n-                                       repeat_stub,                     \\\n@@ -112,1 +109,0 @@\n-                                    repeat_stub,                        \\\n","filename":"src\/hotspot\/cpu\/aarch64\/stubDeclarations_aarch64.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7196,2 +7196,2 @@\n-  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-    StubGenStubId stub_id = (StubGenStubId)(StubGenStubId::lookup_secondary_supers_table_id + super_klass_index);\n+  void generate_lookup_secondary_supers_table_stub() {\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n@@ -7200,1 +7200,0 @@\n-    address start = __ pc();\n@@ -7212,10 +7211,11 @@\n-    Label L_success;\n-    __ enter();\n-    __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n-                                           r_array_base, r_array_length, r_array_index,\n-                                           vtemp, result, super_klass_index,\n-                                           \/*stub_is_near*\/true);\n-    __ leave();\n-    __ ret(lr);\n-\n-    return start;\n+    for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+      Label L_success;\n+      __ enter();\n+      __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n+                                             r_array_base, r_array_length, r_array_index,\n+                                             vtemp, result, slot,\n+                                             \/*stub_is_near*\/true);\n+      __ leave();\n+      __ ret(lr);\n+    }\n@@ -8794,4 +8794,1 @@\n-        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n-            = generate_lookup_secondary_supers_table_stub(slot);\n-        }\n+        generate_lookup_secondary_supers_table_stub();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-                                      repeat_stub,                      \\\n@@ -46,1 +45,0 @@\n-                                           repeat_stub,                 \\\n@@ -54,1 +52,0 @@\n-                                       repeat_stub,                     \\\n@@ -65,1 +62,0 @@\n-                                    repeat_stub,                        \\\n","filename":"src\/hotspot\/cpu\/arm\/stubDeclarations_arm.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-                                      repeat_stub,                      \\\n@@ -38,1 +37,0 @@\n-                                           repeat_stub,                 \\\n@@ -46,1 +44,0 @@\n-                                       repeat_stub,                     \\\n@@ -51,3 +48,0 @@\n-  \/* this is coded but not currently used or even generated *\/          \\\n-  \/* assuming it is intended for use as a compiler stub *\/              \\\n-  do_stub(compiler, zero_words_aligned8)                                \\\n@@ -57,1 +51,0 @@\n-                                    repeat_stub,                        \\\n","filename":"src\/hotspot\/cpu\/ppc\/stubDeclarations_ppc.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -524,88 +524,0 @@\n-\n-  \/\/ Support for void zero_words_aligned8(HeapWord* to, size_t count)\n-  \/\/\n-  \/\/ Arguments:\n-  \/\/   to:\n-  \/\/   count:\n-  \/\/\n-  \/\/ Destroys:\n-  \/\/\n-  address generate_zero_words_aligned8() {\n-    StubGenStubId stub_id = StubGenStubId::zero_words_aligned8_id;\n-    StubCodeMark mark(this, stub_id);\n-\n-    \/\/ Implemented as in ClearArray.\n-    address start = __ function_entry();\n-\n-    Register base_ptr_reg   = R3_ARG1; \/\/ tohw (needs to be 8b aligned)\n-    Register cnt_dwords_reg = R4_ARG2; \/\/ count (in dwords)\n-    Register tmp1_reg       = R5_ARG3;\n-    Register tmp2_reg       = R6_ARG4;\n-    Register zero_reg       = R7_ARG5;\n-\n-    \/\/ Procedure for large arrays (uses data cache block zero instruction).\n-    Label dwloop, fast, fastloop, restloop, lastdword, done;\n-    int cl_size = VM_Version::L1_data_cache_line_size();\n-    int cl_dwords = cl_size >> 3;\n-    int cl_dwordaddr_bits = exact_log2(cl_dwords);\n-    int min_dcbz = 2; \/\/ Needs to be positive, apply dcbz only to at least min_dcbz cache lines.\n-\n-    \/\/ Clear up to 128byte boundary if long enough, dword_cnt=(16-(base>>3))%16.\n-    __ dcbtst(base_ptr_reg);                    \/\/ Indicate write access to first cache line ...\n-    __ andi(tmp2_reg, cnt_dwords_reg, 1);       \/\/ to check if number of dwords is even.\n-    __ srdi_(tmp1_reg, cnt_dwords_reg, 1);      \/\/ number of double dwords\n-    __ load_const_optimized(zero_reg, 0L);      \/\/ Use as zero register.\n-\n-    __ cmpdi(CCR1, tmp2_reg, 0);                \/\/ cnt_dwords even?\n-    __ beq(CCR0, lastdword);                    \/\/ size <= 1\n-    __ mtctr(tmp1_reg);                         \/\/ Speculatively preload counter for rest loop (>0).\n-    __ cmpdi(CCR0, cnt_dwords_reg, (min_dcbz+1)*cl_dwords-1); \/\/ Big enough to ensure >=min_dcbz cache lines are included?\n-    __ neg(tmp1_reg, base_ptr_reg);             \/\/ bit 0..58: bogus, bit 57..60: (16-(base>>3))%16, bit 61..63: 000\n-\n-    __ blt(CCR0, restloop);                     \/\/ Too small. (<31=(2*cl_dwords)-1 is sufficient, but bigger performs better.)\n-    __ rldicl_(tmp1_reg, tmp1_reg, 64-3, 64-cl_dwordaddr_bits); \/\/ Extract number of dwords to 128byte boundary=(16-(base>>3))%16.\n-\n-    __ beq(CCR0, fast);                         \/\/ already 128byte aligned\n-    __ mtctr(tmp1_reg);                         \/\/ Set ctr to hit 128byte boundary (0<ctr<cnt).\n-    __ subf(cnt_dwords_reg, tmp1_reg, cnt_dwords_reg); \/\/ rest (>0 since size>=256-8)\n-\n-    \/\/ Clear in first cache line dword-by-dword if not already 128byte aligned.\n-    __ bind(dwloop);\n-      __ std(zero_reg, 0, base_ptr_reg);        \/\/ Clear 8byte aligned block.\n-      __ addi(base_ptr_reg, base_ptr_reg, 8);\n-    __ bdnz(dwloop);\n-\n-    \/\/ clear 128byte blocks\n-    __ bind(fast);\n-    __ srdi(tmp1_reg, cnt_dwords_reg, cl_dwordaddr_bits); \/\/ loop count for 128byte loop (>0 since size>=256-8)\n-    __ andi(tmp2_reg, cnt_dwords_reg, 1);       \/\/ to check if rest even\n-\n-    __ mtctr(tmp1_reg);                         \/\/ load counter\n-    __ cmpdi(CCR1, tmp2_reg, 0);                \/\/ rest even?\n-    __ rldicl_(tmp1_reg, cnt_dwords_reg, 63, 65-cl_dwordaddr_bits); \/\/ rest in double dwords\n-\n-    __ bind(fastloop);\n-      __ dcbz(base_ptr_reg);                    \/\/ Clear 128byte aligned block.\n-      __ addi(base_ptr_reg, base_ptr_reg, cl_size);\n-    __ bdnz(fastloop);\n-\n-    \/\/__ dcbtst(base_ptr_reg);                  \/\/ Indicate write access to last cache line.\n-    __ beq(CCR0, lastdword);                    \/\/ rest<=1\n-    __ mtctr(tmp1_reg);                         \/\/ load counter\n-\n-    \/\/ Clear rest.\n-    __ bind(restloop);\n-      __ std(zero_reg, 0, base_ptr_reg);        \/\/ Clear 8byte aligned block.\n-      __ std(zero_reg, 8, base_ptr_reg);        \/\/ Clear 8byte aligned block.\n-      __ addi(base_ptr_reg, base_ptr_reg, 16);\n-    __ bdnz(restloop);\n-\n-    __ bind(lastdword);\n-    __ beq(CCR1, done);\n-    __ std(zero_reg, 0, base_ptr_reg);\n-    __ bind(done);\n-    __ blr();                                   \/\/ return\n-\n-    return start;\n-  }\n-\n@@ -4675,2 +4587,2 @@\n-address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-    StubGenStubId stub_id = (StubGenStubId)(StubGenStubId::lookup_secondary_supers_table_id + super_klass_index);\n+void generate_lookup_secondary_supers_table_stub() {\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n@@ -4679,1 +4591,0 @@\n-    address start = __ pc();\n@@ -4689,4 +4600,7 @@\n-    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n-                                     r_array_base, r_array_length, r_array_index,\n-                                     r_bitmap, result, super_klass_index);\n-    __ blr();\n+    for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+      __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n+                                       r_array_base, r_array_length, r_array_index,\n+                                       r_bitmap, result, slot);\n+      __ blr();\n+    }\n@@ -4694,1 +4608,0 @@\n-    return start;\n@@ -4985,4 +4898,1 @@\n-        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n-            = generate_lookup_secondary_supers_table_stub(slot);\n-        }\n+        generate_lookup_secondary_supers_table_stub();\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":10,"deletions":100,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-                                      repeat_stub,                      \\\n@@ -38,1 +37,0 @@\n-                                           repeat_stub,                 \\\n@@ -46,1 +44,0 @@\n-                                       repeat_stub,                     \\\n@@ -75,1 +72,0 @@\n-                                    repeat_stub,                        \\\n","filename":"src\/hotspot\/cpu\/riscv\/stubDeclarations_riscv.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3007,2 +3007,2 @@\n-  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-    StubGenStubId stub_id = (StubGenStubId)(StubGenStubId::lookup_secondary_supers_table_id + super_klass_index);\n+  void generate_lookup_secondary_supers_table_stub() {\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n@@ -3011,1 +3011,0 @@\n-    address start = __ pc();\n@@ -3021,9 +3020,10 @@\n-    Label L_success;\n-    __ enter();\n-    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass, result,\n-                                     r_array_base, r_array_length, r_array_index,\n-                                     r_bitmap, super_klass_index, \/*stub_is_near*\/true);\n-    __ leave();\n-    __ ret();\n-\n-    return start;\n+    for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+      Label L_success;\n+      __ enter();\n+      __ lookup_secondary_supers_table(r_sub_klass, r_super_klass, result,\n+                                       r_array_base, r_array_length, r_array_index,\n+                                       r_bitmap, slot, \/*stub_is_near*\/true);\n+      __ leave();\n+      __ ret();\n+    }\n@@ -6529,4 +6529,1 @@\n-        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n-            = generate_lookup_secondary_supers_table_stub(slot);\n-        }\n+        generate_lookup_secondary_supers_table_stub();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-                                      repeat_stub,                      \\\n@@ -38,1 +37,0 @@\n-                                           repeat_stub,                 \\\n@@ -46,1 +44,0 @@\n-                                       repeat_stub,                     \\\n@@ -57,1 +54,0 @@\n-                                    repeat_stub,                        \\\n","filename":"src\/hotspot\/cpu\/s390\/stubDeclarations_s390.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -629,2 +629,2 @@\n-  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-    StubGenStubId stub_id = (StubGenStubId)(StubGenStubId::lookup_secondary_supers_table_id + super_klass_index);\n+  void generate_lookup_secondary_supers_table_stub() {\n+    StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n@@ -641,5 +641,5 @@\n-    address start = __ pc();\n-\n-    __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n-                                           r_array_base, r_array_length, r_array_index,\n-                                           r_bitmap, r_result, super_klass_index);\n+    for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+      __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n+                                             r_array_base, r_array_length, r_array_index,\n+                                             r_bitmap, r_result, slot);\n@@ -647,3 +647,2 @@\n-    __ z_br(Z_R14);\n-\n-    return start;\n+      __ z_br(Z_R14);\n+    }\n@@ -1364,1 +1363,1 @@\n-    int element_size;\n+    int shift; \/\/ i.e. log2(element size)\n@@ -1369,1 +1368,1 @@\n-      element_size = 1;\n+      shift = 0;\n@@ -1374,1 +1373,1 @@\n-      element_size = 1;\n+      shift = 0;\n@@ -1379,1 +1378,1 @@\n-      element_size = 2;\n+      shift = 1;\n@@ -1384,1 +1383,1 @@\n-      element_size = 2;\n+      shift = 1;\n@@ -1389,1 +1388,1 @@\n-      element_size = 4;\n+      shift = 2;\n@@ -1394,1 +1393,1 @@\n-      element_size = 4;\n+      shift = 2;\n@@ -1399,1 +1398,1 @@\n-      element_size = 8;\n+      shift = 3;\n@@ -1404,1 +1403,1 @@\n-      element_size = 8;\n+      shift = 3;\n@@ -1412,1 +1411,2 @@\n-    generate_conjoint_copy(aligned, element_size, false);\n+    array_overlap_test(nooverlap_target, shift); \/\/ Branch away to nooverlap_target if disjoint.\n+    generate_conjoint_copy(aligned, 1 << shift, false);\n@@ -1433,1 +1433,1 @@\n-      dest_uninitialized = false;\n+      dest_uninitialized = true;\n@@ -1438,1 +1438,1 @@\n-      dest_uninitialized = false;\n+      dest_uninitialized = true;\n@@ -3230,3 +3230,1 @@\n-        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-          StubRoutines::_lookup_secondary_supers_table_stubs[slot] = generate_lookup_secondary_supers_table_stub(slot);\n-        }\n+        generate_lookup_secondary_supers_table_stub();\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-                                      repeat_stub,                      \\\n@@ -79,1 +78,0 @@\n-                                           repeat_stub,                 \\\n@@ -87,1 +85,0 @@\n-                                       repeat_stub,                     \\\n@@ -259,1 +256,0 @@\n-                                    repeat_stub,                        \\\n","filename":"src\/hotspot\/cpu\/x86\/stubDeclarations_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3999,5 +3999,2 @@\n-address StubGenerator::generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n-  StubGenStubId stub_id = (StubGenStubId)(StubGenStubId::lookup_secondary_supers_table_id + super_klass_index);\n-  assert(stub_id >= StubGenStubId::lookup_secondary_supers_table_id &&\n-         stub_id >= StubGenStubId::lookup_secondary_supers_table_limit,\n-         \"super klass index out of expected range!\");\n+void StubGenerator::generate_lookup_secondary_supers_table_stub() {\n+  StubGenStubId stub_id = StubGenStubId::lookup_secondary_supers_table_id;\n@@ -4006,2 +4003,0 @@\n-  address start = __ pc();\n-\n@@ -4013,7 +4008,8 @@\n-  __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n-                                         rdx, rcx, rbx, r11, \/\/ temps\n-                                         result,\n-                                         super_klass_index);\n-  __ ret(0);\n-\n-  return start;\n+  for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+    StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+    __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n+                                           rdx, rcx, rbx, r11, \/\/ temps\n+                                           result,\n+                                           slot);\n+    __ ret(0);\n+  }\n@@ -4159,3 +4155,1 @@\n-      for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n-        StubRoutines::_lookup_secondary_supers_table_stubs[slot] = generate_lookup_secondary_supers_table_stub(slot);\n-      }\n+      generate_lookup_secondary_supers_table_stub();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index);\n+  void generate_lookup_secondary_supers_table_stub();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-                                      repeat_stub,                      \\\n@@ -38,1 +37,0 @@\n-                                           repeat_stub,                 \\\n@@ -46,1 +44,0 @@\n-                                       repeat_stub,                     \\\n@@ -54,1 +51,0 @@\n-                                    repeat_stub,                        \\\n","filename":"src\/hotspot\/cpu\/zero\/stubDeclarations_zero.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -323,0 +323,9 @@\n+\/\/ In special cases a stub may declare a (compile-time) fixed size\n+\/\/ array of entries, in which case an address array field is\n+\/\/ generated,along with a getter that accepts an index as argument:\n+\/\/\n+\/\/    . . .\n+\/\/   static address _lookup_secondary_supers_table[Klass::SECONDARY_SUPERS_TABLE_SIZE];\n+\/\/   . . .\n+\/\/   static address lookup_secondary_supers_table(int i);\n+\/\/\n@@ -359,3 +368,3 @@\n-\/\/ declared using the do_stub, repeat_stub, do_entry and do_entry_init\n-\/\/ templates (see below for full details). The do_blob and end_blob\n-\/\/ templates should never need to be modified.\n+\/\/ declared using the do_stub, do_entry and do_entry_init and\n+\/\/ array_entry templates (see below for full details). The do_blob\n+\/\/ and end_blob templates should never need to be modified.\n@@ -368,1 +377,1 @@\n-\/\/ are declared using the do_stub, repeat_stub, do_arch_entry and\n+\/\/ are declared using the do_stub, do_arch_entry and\n@@ -416,16 +425,1 @@\n-\/\/ The repeat_stub template receives a blob name, stub name and a\n-\/\/ (constant expression) count as argument.\n-\/\/\n-\/\/ repeat_stub(blob_name, stub_name, count)\n-\/\/\n-\/\/ repeat_stub is needed as an alternative to do_stub in the special\n-\/\/ case where a series of stubs are generated with the same base name,\n-\/\/ currently only for the 'lookup_secondary_supers_table_index' stub.\n-\/\/ It generates all the same code elements as do_stub. However, it\n-\/\/ also bumps the current enum tag to accomomodate the multi-stub\n-\/\/ range and generates extra numbered stub names for each stub in the\n-\/\/ multi-stub range. It is not (yet) possible to use entry\n-\/\/ declarations to associate either single entries or an array of\n-\/\/ entries with the resulting series of stubs.\n-\/\/\n-\/\/ The do_entry templates receive 4 or 5 arguments\n+\/\/ The do_entry and do_entry_array templates receive 4 or 5 arguments\n@@ -437,0 +431,2 @@\n+\/\/ do_entry_array(blob_name, stub_name, field_name, getter_name, count)\n+\/\/\n@@ -443,3 +439,13 @@\n-\/\/ fields that shoudl eb initialized to nullptr. do_entry5 is used\n-\/\/ when the field needs to be initialized a specific function or\n-\/\/ method.\n+\/\/ fields that should be initialized to nullptr.\n+\/\/\n+\/\/ do_entry_init is used when the field needs to be initialized a\n+\/\/ specific function or method .\n+\/\/\n+\/\/ do_entry_array is used for the special case where a stub employs an\n+\/\/ array to store multiple entries which are stored at generate time\n+\/\/ and subsequently accessed using an associated index (e.g. the\n+\/\/ secondary supers table stub which has 63 qassociated entries).\n+\/\/ Note that this distinct from the case where a stub generates\n+\/\/ multiple entries each of them stored in its own named field with\n+\/\/ its own named getter. In the latter case multiple do_entry or\n+\/\/ do_entry_init declarations are associated with the stub.\n@@ -454,1 +460,3 @@\n-\/\/ names must be different to stub_name.\n+\/\/ names must be different to stub_name. For normal entry declarations\n+\/\/ the field type is address. For do_entry_array declarations the field\n+\/\/ type is an address[] whose size is defined by then parameter.\n@@ -458,1 +466,3 @@\n-\/\/ stub_name.\n+\/\/ stub_name. For normal entry declarations the getter signature is\n+\/\/ (void).  For do_entry_array declarations the getter signature is\n+\/\/ (int).\n@@ -462,1 +472,2 @@\n-\/\/ using do_entry are intialised to nullptr).\n+\/\/ using do_entry are intialised to nullptr, array fields declared\n+\/\/ using do_entry_array have their elements initalized to nullptr).\n@@ -484,0 +495,2 @@\n+\/\/\n+\/\/ Currently there is no support for a do_arch_array_entry template.\n@@ -523,1 +536,1 @@\n-                                 do_stub, repeat_stub,                  \\\n+                                 do_stub,                               \\\n@@ -525,0 +538,1 @@\n+                                 do_entry_array,                        \\\n@@ -590,2 +604,1 @@\n-  STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub, repeat_stub,                   \\\n-                                do_arch_blob,                           \\\n+  STUBGEN_INITIAL_BLOBS_ARCH_DO(do_stub, do_arch_blob,                  \\\n@@ -597,1 +610,1 @@\n-                                      do_stub, repeat_stub,             \\\n+                                      do_stub,                          \\\n@@ -599,0 +612,1 @@\n+                                      do_entry_array,                   \\\n@@ -607,1 +621,1 @@\n-do_stub(continuation, cont_returnBarrier)                               \\\n+  do_stub(continuation, cont_returnBarrier)                             \\\n@@ -614,2 +628,1 @@\n-  STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub, repeat_stub,              \\\n-                                     do_arch_blob,                      \\\n+  STUBGEN_CONTINUATION_BLOBS_ARCH_DO(do_stub,  do_arch_blob,            \\\n@@ -621,1 +634,1 @@\n-                                  do_stub, repeat_stub,                 \\\n+                                  do_stub,                              \\\n@@ -623,0 +636,1 @@\n+                                  do_entry_array,                       \\\n@@ -738,2 +752,1 @@\n-  STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub, repeat_stub,                  \\\n-                                     do_arch_blob,                      \\\n+  STUBGEN_COMPILER_BLOBS_ARCH_DO(do_stub,  do_arch_blob,                \\\n@@ -745,1 +758,1 @@\n-                               do_stub, repeat_stub,                    \\\n+                               do_stub,                                 \\\n@@ -747,0 +760,1 @@\n+                               do_entry_array,                          \\\n@@ -892,3 +906,5 @@\n-  \/* n.b. entry array for next two stubs is hand-generated *\/           \\\n-  repeat_stub(final, lookup_secondary_supers_table,                     \\\n-              Klass::SECONDARY_SUPERS_TABLE_SIZE)                       \\\n+  do_stub(final, lookup_secondary_supers_table)                         \\\n+  do_entry_array(final, lookup_secondary_supers_table,                  \\\n+                 lookup_secondary_supers_table_stubs,                   \\\n+                 lookup_secondary_supers_table_stub,                    \\\n+                 Klass::SECONDARY_SUPERS_TABLE_SIZE)                    \\\n@@ -900,2 +916,1 @@\n-  STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub, repeat_stub,                     \\\n-                              do_arch_blob,                             \\\n+  STUBGEN_FINAL_BLOBS_ARCH_DO(do_stub,  do_arch_blob,                   \\\n@@ -939,3 +954,0 @@\n-\/\/ ignore repeat_stub(blob_name, stub_name, count) declarations\n-#define REPEAT_STUB_EMPTY3(blob_name, stub_name, count)\n-\n@@ -945,1 +957,2 @@\n-\/\/ ignore do_entry(blob_name, stub_name, fieldname, getter_name, init_function) declarations\n+\/\/ ignore do_entry(blob_name, stub_name, fieldname, getter_name, init_function) and\n+\/\/ do_entry_array(blob_name, stub_name, fieldname, getter_name, count) declarations\n@@ -962,1 +975,1 @@\n-                       do_stub, repeat_stub,                            \\\n+                       do_stub,                                         \\\n@@ -964,0 +977,1 @@\n+                       do_entry_array,                                  \\\n@@ -967,1 +981,1 @@\n-                           do_stub, repeat_stub,                        \\\n+                           do_stub,                                     \\\n@@ -969,0 +983,1 @@\n+                           do_entry_array,                              \\\n@@ -972,1 +987,1 @@\n-                                do_stub, repeat_stub,                   \\\n+                                do_stub,                                \\\n@@ -974,0 +989,1 @@\n+                                do_entry_array,                         \\\n@@ -977,1 +993,1 @@\n-                            do_stub, repeat_stub,                       \\\n+                            do_stub,                                    \\\n@@ -979,0 +995,1 @@\n+                            do_entry_array,                             \\\n@@ -982,1 +999,1 @@\n-                         do_stub, repeat_stub,                          \\\n+                         do_stub,                                       \\\n@@ -984,0 +1001,1 @@\n+                         do_entry_array,                                \\\n@@ -991,1 +1009,1 @@\n-                 DO_STUB_EMPTY2, REPEAT_STUB_EMPTY3,                    \\\n+                 DO_STUB_EMPTY2,                                        \\\n@@ -993,0 +1011,1 @@\n+                 DO_ENTRY_EMPTY5,                                       \\\n@@ -998,1 +1017,1 @@\n-#define STUBGEN_STUBS_DO(do_stub, repeat_stub)                          \\\n+#define STUBGEN_STUBS_DO(do_stub)                                       \\\n@@ -1000,1 +1019,1 @@\n-                 do_stub, repeat_stub,                                  \\\n+                 do_stub,                                               \\\n@@ -1002,0 +1021,1 @@\n+                 DO_ENTRY_EMPTY5,                                       \\\n@@ -1007,1 +1027,1 @@\n-#define STUBGEN_BLOBS_STUBS_DO(do_blob, end_blob, do_stub, repeat_stub) \\\n+#define STUBGEN_BLOBS_STUBS_DO(do_blob, end_blob, do_stub)              \\\n@@ -1009,1 +1029,1 @@\n-                 do_stub, repeat_stub,                                  \\\n+                 do_stub,                                               \\\n@@ -1011,0 +1031,1 @@\n+                 DO_ENTRY_EMPTY5,                                       \\\n@@ -1016,1 +1037,1 @@\n-#define STUBGEN_ENTRIES_DO(do_entry, do_entry_init)                     \\\n+#define STUBGEN_ENTRIES_DO(do_entry, do_entry_init, do_entry_array)     \\\n@@ -1018,1 +1039,1 @@\n-                 DO_STUB_EMPTY2, REPEAT_STUB_EMPTY3,                    \\\n+                 DO_STUB_EMPTY2,                                        \\\n@@ -1020,0 +1041,1 @@\n+                 do_entry_array,                                        \\\n@@ -1028,1 +1050,1 @@\n-                 DO_STUB_EMPTY2, REPEAT_STUB_EMPTY3,                    \\\n+                 DO_STUB_EMPTY2,                                        \\\n@@ -1030,0 +1052,1 @@\n+                 DO_ENTRY_EMPTY5,                                       \\\n@@ -1037,1 +1060,1 @@\n-                 DO_STUB_EMPTY2, REPEAT_STUB_EMPTY3,                    \\\n+                 DO_STUB_EMPTY2,                                        \\\n@@ -1039,0 +1062,1 @@\n+                 DO_ENTRY_EMPTY5,                                       \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":84,"deletions":60,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-const char* StubRoutines::_blob_names[] = {\n+const char* StubRoutines::_blob_names[StubGenBlobId::NUM_BLOBIDS] = {\n@@ -65,10 +65,0 @@\n-\/\/ stub repeats mean that we cannot fill in the _stub_names array\n-\/\/ using a generated initializer (even though the repeat count is a\n-\/\/ compile time constant). what we can do is declare the array using\n-\/\/ the correct size and generate some code that will fill in the\n-\/\/ names, inlcuding the repated ones. the generated code is used to\n-\/\/ initialize a local (static) var i.e. before anyone can use\n-\/\/ _stub_names.\n-\n-const char* StubRoutines::_stub_names[StubGenStubId::NUM_STUBIDS];\n-\n@@ -76,42 +66,1 @@\n-  stub_id = StubGenStubId:: STUB_ID_NAME(stub_name);    \\\n-  _stub_names[stub_id] = # stub_name ;                  \\\n-\n-\n-#define REPEAT_STUB_NAME(blob_name, stub_name, count)            \\\n-  stub_id = StubGenStubId:: STUB_ID_NAME(stub_name);             \\\n-  const char *name = # stub_name;                                \\\n-  int len = (int)strlen(name);                                   \\\n-  _stub_names[stub_id] = name ;                                  \\\n-  assert(count < 100, \"increase digit count in repeat names\");   \\\n-  for (int i = 1; i < count; i++) {                              \\\n-    assert(buffer + len + 3 < name_buffer_end,                   \\\n-           \"increase size of repeat stub name_buffer\");          \\\n-    _stub_names[stub_id + i] = buffer;                           \\\n-    strcpy(buffer, name);                                        \\\n-    buffer += strlen(buffer);                                    \\\n-    if (i < 10) {                                                \\\n-      *buffer++ = '0' + i;                                       \\\n-    } else {                                                     \\\n-      *buffer++ = '0' + (i \/ 10);                                \\\n-      *buffer++ = '0' + (i % 10);                                \\\n-    }                                                            \\\n-    *buffer++ = '\\0';                                             \\\n-  }                                                              \\\n-\n-\/\/ this should be big enough to hold all the repeat stub names we\n-\/\/ need. it allows for 100 stub repeats in total with 100 bytes for\n-\/\/ the stub name (inlcuding 1 or 2 digit numeric suffix). if we don't\n-\/\/ have enough space or need more digits the generated init function\n-\/\/ will assert.\n-\n-static char name_buffer[100 * 100];\n-static char* name_buffer_end = name_buffer + sizeof(name_buffer);\n-\n-bool StubRoutines::init_names() {\n-  assert(!_inited_names, \"should only be called once!\");\n-  _inited_names = true;\n-  char *buffer = name_buffer;\n-  StubGenStubId stub_id;\n-  STUBGEN_STUBS_DO(DEFINE_STUB_NAME, REPEAT_STUB_NAME);\n-  return _inited_names;\n-}\n+  # stub_name ,                                         \\\n@@ -119,2 +68,4 @@\n-#undef REPEAT_STUB_NAME\n-#undef DEFINE_STUB_NAME\n+\/\/ use a template to generate the initializer for the stub names array\n+const char* StubRoutines::_stub_names[StubGenStubId::NUM_STUBIDS] = {\n+  STUBGEN_STUBS_DO(DEFINE_STUB_NAME)\n+};\n@@ -122,1 +73,1 @@\n-bool StubRoutines::_inited_names = StubRoutines::init_names();\n+#undef DEFINE_STUB_NAME\n@@ -141,1 +92,2 @@\n-STUBGEN_ENTRIES_DO(DEFINE_ENTRY_FIELD, DEFINE_ENTRY_FIELD_INIT)\n+#define DEFINE_ENTRY_FIELD_ARRAY(blob_name, stub_name, field_name, getter_name, count) \\\n+  address StubRoutines:: STUB_FIELD_NAME(field_name)[count] = { nullptr };\n@@ -143,0 +95,3 @@\n+STUBGEN_ENTRIES_DO(DEFINE_ENTRY_FIELD, DEFINE_ENTRY_FIELD_INIT, DEFINE_ENTRY_FIELD_ARRAY)\n+\n+#undef DEFINE_ENTRY_FIELD_ARRAY\n@@ -151,1 +106,0 @@\n-address StubRoutines::_lookup_secondary_supers_table_stubs[Klass::SECONDARY_SUPERS_TABLE_SIZE] = { nullptr };\n@@ -188,6 +142,0 @@\n-#define REPEAT_VERIFY(blob_name, stub_name, count)                      \\\n-  STUB_VERIFY(blob_name, stub_name)                                     \\\n-  localStubLimit = (int) (StubGenStubId_ ## blob_name :: blob_name ## _ ## stub_name ## _limit); \\\n-  assert(globalStubId + (count - 1) == _blob_limits[blobId] + localStubLimit, \\\n-         \"stub \" # stub_name \" limit found at wrong offset!\");          \\\n-\n@@ -204,1 +152,1 @@\n-  STUBGEN_STUBS_DO(STUB_VERIFY, REPEAT_VERIFY);\n+  STUBGEN_STUBS_DO(STUB_VERIFY);\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":13,"deletions":65,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -180,5 +180,1 @@\n-#define BLOB_LOCAL_STUB_ENUM_REPEAT_DECLARE(blob_name, stub_name, count)       \\\n-  blob_name ## _ ## stub_name ## _id,                                   \\\n-  blob_name ## _ ## stub_name ## _limit = blob_name ## _ ## stub_name ## _id + (count - 1),\n-\n-STUBGEN_BLOBS_STUBS_DO(BLOB_LOCAL_ENUM_START, BLOB_LOCAL_ENUM_END, BLOB_LOCAL_STUB_ENUM_DECLARE, BLOB_LOCAL_STUB_ENUM_REPEAT_DECLARE)\n+STUBGEN_BLOBS_STUBS_DO(BLOB_LOCAL_ENUM_START, BLOB_LOCAL_ENUM_END, BLOB_LOCAL_STUB_ENUM_DECLARE)\n@@ -195,4 +191,0 @@\n-#define STUB_ENUM_REPEAT(blob_name, stub_name, count)                   \\\n-  STUB_ID_NAME(stub_name),                                              \\\n-  stub_name ## _limit = STUB_ID_NAME(stub_name) + (count - 1),\n-\n@@ -201,1 +193,1 @@\n-  STUBGEN_STUBS_DO(STUB_ENUM_DECLARE, STUB_ENUM_REPEAT)\n+  STUBGEN_STUBS_DO(STUB_ENUM_DECLARE)\n@@ -249,0 +241,3 @@\n+#define DECLARE_ENTRY_FIELD_ARRAY(blob_name, stub_name, field_name, getter_name, count) \\\n+  static address STUB_FIELD_NAME(field_name)[count];\n+\n@@ -250,1 +245,1 @@\n-  STUBGEN_ENTRIES_DO(DECLARE_ENTRY_FIELD, DECLARE_ENTRY_FIELD_INIT);\n+  STUBGEN_ENTRIES_DO(DECLARE_ENTRY_FIELD, DECLARE_ENTRY_FIELD_INIT, DECLARE_ENTRY_FIELD_ARRAY);\n@@ -252,0 +247,1 @@\n+#undef DECLARE_ENTRY_FIELD_ARRAY\n@@ -263,0 +259,6 @@\n+#define DEFINE_ENTRY_GETTER_ARRAY(blob_name, stub_name, field_name, getter_name, count) \\\n+  static address getter_name(int idx) {                                 \\\n+    assert(idx < count, \"out of bounds\");                               \\\n+    return STUB_FIELD_NAME(field_name)[idx];                            \\\n+  }                                                                     \\\n+\n@@ -264,1 +266,1 @@\n-  STUBGEN_ENTRIES_DO(DEFINE_ENTRY_GETTER, DEFINE_ENTRY_GETTER_INIT);\n+  STUBGEN_ENTRIES_DO(DEFINE_ENTRY_GETTER, DEFINE_ENTRY_GETTER_INIT, DEFINE_ENTRY_GETTER_ARRAY);\n@@ -266,0 +268,1 @@\n+#undef DEFINE_ENTRY_GETTER_ARRAY\n@@ -391,10 +394,0 @@\n-  \/* special case: stub employs array of entries *\/\n-\n-  static address _lookup_secondary_supers_table_stubs[];\n-\n-  static address lookup_secondary_supers_table_stub(u1 slot) {\n-    assert(slot < Klass::SECONDARY_SUPERS_TABLE_SIZE, \"out of bounds\");\n-    assert(_lookup_secondary_supers_table_stubs[slot] != nullptr, \"not implemented\");\n-    return _lookup_secondary_supers_table_stubs[slot];\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":15,"deletions":22,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  if (StubRoutines::type##_fill != nullptr) {                                                \\\n+  if (StubRoutines::type##_fill() != nullptr) {                         \\\n","filename":"test\/hotspot\/gtest\/runtime\/test_stubRoutines.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}