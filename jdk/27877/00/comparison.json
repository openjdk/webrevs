{"files":[{"patch":"@@ -377,2 +377,8 @@\n-            \/\/ Use absolute path as jpackage can be executed in another directory\n-            cmd.setArgumentValue(argName, TKit.createTempDirectory(\"stash-script-resource-dir\").toAbsolutePath());\n+            \/\/ Use absolute path as jpackage can be executed in another directory.\n+            \/\/ Some tests expect a specific last argument, don't interfere with them\n+            \/\/ and insert the argument at the beginning of the command line.\n+            List<String> args = new ArrayList<>();\n+            args.add(argName);\n+            args.add(TKit.createTempDirectory(\"stash-script-resource-dir\").toAbsolutePath().toString());\n+            args.addAll(cmd.getAllArguments());\n+            cmd.clearArguments().addArguments(args);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigFilesStasher.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.HashMap;\n@@ -694,1 +693,1 @@\n-        defaultToolProvider = Optional.of(jpackageToolProvider);\n+        defaultToolProvider.set(Optional.of(jpackageToolProvider));\n@@ -702,1 +701,1 @@\n-        defaultToolProvider = Optional.empty();\n+        defaultToolProvider.set(Optional.empty());\n@@ -811,1 +810,3 @@\n-        return Optional.ofNullable(withToolProvider).orElseGet(defaultToolProvider::isPresent);\n+        return Optional.ofNullable(withToolProvider).orElseGet(() -> {\n+            return defaultToolProvider.get().isPresent();\n+        });\n@@ -827,1 +828,1 @@\n-            exec.setToolProvider(defaultToolProvider.orElseGet(JavaTool.JPACKAGE::asToolProvider));\n+            exec.setToolProvider(defaultToolProvider.get().orElseGet(JavaTool.JPACKAGE::asToolProvider));\n@@ -1259,4 +1260,1 @@\n-            if (expectedPath.isAbsolute()) {\n-                throw new IllegalArgumentException();\n-            }\n-            if (!expectedPath.getFileName().equals(filename.getFileName())) {\n+            if (expectedPath.isAbsolute() || !expectedPath.getFileName().equals(filename.getFileName())) {\n@@ -1348,1 +1346,1 @@\n-        if (!hasArgument(\"--verbose\") && TKit.VERBOSE_JPACKAGE && !ignoreDefaultVerbose) {\n+        if (!hasArgument(\"--verbose\") && TKit.verboseJPackage() && !ignoreDefaultVerbose) {\n@@ -1372,5 +1370,1 @@\n-                if (TKit.isLinux() && typesSet.equals(PackageType.LINUX)) {\n-                    return;\n-                }\n-\n-                if (TKit.isWindows() && typesSet.equals(PackageType.WINDOWS)) {\n+                if ((TKit.isLinux() && typesSet.equals(PackageType.LINUX)) || (TKit.isWindows() && typesSet.equals(PackageType.WINDOWS))) {\n@@ -1526,20 +1520,4 @@\n-    private static Optional<ToolProvider> defaultToolProvider = Optional.empty();\n-\n-    private static final Map<String, PackageType> PACKAGE_TYPES = Functional.identity(\n-            () -> {\n-                Map<String, PackageType> reply = new HashMap<>();\n-                for (PackageType type : PackageType.values()) {\n-                    reply.put(type.getType(), type);\n-                }\n-                return reply;\n-            }).get();\n-\n-    public static final Path DEFAULT_RUNTIME_IMAGE = Functional.identity(() -> {\n-        \/\/ Set the property to the path of run-time image to speed up\n-        \/\/ building app images and platform bundles by avoiding running jlink\n-        \/\/ The value of the property will be automativcally appended to\n-        \/\/ jpackage command line if the command line doesn't have\n-        \/\/ `--runtime-image` parameter set.\n-        String val = TKit.getConfigProperty(\"runtime-image\");\n-        if (val != null) {\n-            return Path.of(val);\n+    private static InheritableThreadLocal<Optional<ToolProvider>> defaultToolProvider = new InheritableThreadLocal<>() {\n+        @Override\n+        protected Optional<ToolProvider> initialValue() {\n+            return Optional.empty();\n@@ -1547,2 +1525,10 @@\n-        return null;\n-    }).get();\n+    };\n+\n+    private static final Map<String, PackageType> PACKAGE_TYPES = Stream.of(PackageType.values()).collect(toMap(PackageType::getType, x -> x));\n+\n+    \/\/ Set the property to the path of run-time image to speed up\n+    \/\/ building app images and platform bundles by avoiding running jlink.\n+    \/\/ The value of the property will be automatically appended to\n+    \/\/ jpackage command line if the command line doesn't have\n+    \/\/ `--runtime-image` parameter set.\n+    public static final Path DEFAULT_RUNTIME_IMAGE = Optional.ofNullable(TKit.getConfigProperty(\"runtime-image\")).map(Path::of).orElse(null);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":23,"deletions":37,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    public static void main(String args[]) throws Throwable {\n+    public static void main(String... args) throws Throwable {\n@@ -48,1 +48,1 @@\n-    public static void main(TestBuilder.Builder builder, String args[]) throws Throwable {\n+    public static void main(TestBuilder.Builder builder, String... args) throws Throwable {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.io.FileOutputStream;\n@@ -41,0 +40,1 @@\n+import java.nio.file.StandardOpenOption;\n@@ -112,1 +112,1 @@\n-        if (extraLogStream != null) {\n+        if (state().extraLogStream != null) {\n@@ -122,1 +122,33 @@\n-        var oldExtraLogStream = extraLogStream;\n+        withNewState(action, stateBuilder -> {\n+            stateBuilder.extraLogStream(logStream);\n+        });\n+    }\n+\n+    public static void withMainLogStream(ThrowingRunnable action, PrintStream logStream) {\n+        withNewState(action, stateBuilder -> {\n+            stateBuilder.mainLogStream(logStream);\n+        });\n+    }\n+\n+    public static void withStackTraceStream(ThrowingRunnable action, PrintStream logStream) {\n+        withNewState(action, stateBuilder -> {\n+            stateBuilder.stackTraceStream(logStream);\n+        });\n+    }\n+\n+    public static State state() {\n+        return STATE.get();\n+    }\n+\n+    public static void state(State v) {\n+        STATE.set(Objects.requireNonNull(v));\n+    }\n+\n+    private static void withNewState(ThrowingRunnable action, Consumer<State.Builder> stateBuilderMutator) {\n+        Objects.requireNonNull(action);\n+        Objects.requireNonNull(stateBuilderMutator);\n+\n+        var oldState = state();\n+        var builder = oldState.buildCopy();\n+        stateBuilderMutator.accept(builder);\n+        var newState = builder.create();\n@@ -124,1 +156,1 @@\n-            extraLogStream = logStream;\n+            state(newState);\n@@ -127,1 +159,1 @@\n-            extraLogStream = oldExtraLogStream;\n+            state(oldState);\n@@ -144,3 +176,2 @@\n-        if (currentTest != null) {\n-            throw new IllegalStateException(\n-                    \"Unexpected nested or concurrent Test.run() call\");\n+        if (currentTest() != null) {\n+            throw new IllegalStateException(\"Unexpected nested Test.run() call\");\n@@ -151,11 +182,9 @@\n-                currentTest = test;\n-                try {\n-                    if (modes.contains(RunTestMode.FAIL_FAST)) {\n-                        ThrowingRunnable.toRunnable(test::run).run();\n-                    } else {\n-                        ignoreExceptions(test).run();\n-                    }\n-                } finally {\n-                    currentTest = null;\n-                    if (extraLogStream != null) {\n-                        extraLogStream.flush();\n+                withNewState(() -> {\n+                    try {\n+                        if (modes.contains(RunTestMode.FAIL_FAST)) {\n+                            test.run();\n+                        } else {\n+                            ignoreExceptions(test).run();\n+                        }\n+                    } finally {\n+                        Optional.ofNullable(state().extraLogStream).ifPresent(PrintStream::flush);\n@@ -163,1 +192,3 @@\n-                }\n+                }, stateBuilder -> {\n+                    stateBuilder.currentTest(test);\n+                });\n@@ -220,1 +251,1 @@\n-        return currentTest.workDir();\n+        return currentTest().workDir();\n@@ -227,1 +258,1 @@\n-        String appNamePrefix = currentTest.functionName();\n+        String appNamePrefix = currentTest().functionName();\n@@ -231,1 +262,1 @@\n-        return Stream.of(appNamePrefix, currentTest.baseName()).filter(\n+        return Stream.of(appNamePrefix, currentTest().baseName()).filter(\n@@ -259,3 +290,4 @@\n-        System.out.println(v);\n-        if (extraLogStream != null) {\n-            extraLogStream.println(v);\n+        var state = state();\n+        state.mainLogStream.println(v);\n+        if (state.extraLogStream != null) {\n+            state.extraLogStream.println(v);\n@@ -311,1 +343,1 @@\n-        if (TRACE) {\n+        if (state().trace) {\n@@ -317,1 +349,1 @@\n-        if (TRACE_ASSERTS) {\n+        if (state().traceAsserts) {\n@@ -578,1 +610,1 @@\n-        currentTest.notifySkipped(ex);\n+        currentTest().notifySkipped(ex);\n@@ -582,0 +614,4 @@\n+    public static boolean isSkippedException(Throwable t) {\n+        return JtregSkippedExceptionClass.INSTANCE.isInstance(t);\n+    }\n+\n@@ -656,4 +692,3 @@\n-        if (extraLogStream != null) {\n-            throwable.printStackTrace(extraLogStream);\n-        }\n-        throwable.printStackTrace();\n+        var state = state();\n+        Optional.ofNullable(state.extraLogStream).ifPresent(throwable::printStackTrace);\n+        throwable.printStackTrace(state.stackTraceStream);\n@@ -670,1 +705,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -681,1 +716,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -692,1 +727,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -703,1 +738,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -715,1 +750,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -727,1 +762,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -740,1 +775,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -750,1 +785,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -767,1 +802,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -779,1 +814,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -856,1 +891,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -882,1 +917,1 @@\n-            currentTest.notifyAssert();\n+            currentTest().notifyAssert();\n@@ -909,1 +944,1 @@\n-            currentTest.notifyAssert();\n+            currentTest().notifyAssert();\n@@ -954,1 +989,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -1180,6 +1215,7 @@\n-        if (LOG_FILE == null) {\n-            return null;\n-        }\n-\n-        return ThrowingSupplier.toSupplier(() -> new PrintStream(\n-                new FileOutputStream(LOG_FILE.toFile(), true))).get();\n+        return state().logFile.map(logfile -> {\n+            try {\n+                return Files.newOutputStream(logfile, StandardOpenOption.CREATE, StandardOpenOption.APPEND);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }).map(PrintStream::new).orElse(null);\n@@ -1229,9 +1265,0 @@\n-    private static TestInstance currentTest;\n-    private static PrintStream extraLogStream;\n-\n-    private static final boolean TRACE;\n-    private static final boolean TRACE_ASSERTS;\n-\n-    static final boolean VERBOSE_JPACKAGE;\n-    static final boolean VERBOSE_TEST_SETUP;\n-\n@@ -1265,7 +1292,3 @@\n-    static final Path LOG_FILE = Functional.identity(() -> {\n-        String val = getConfigProperty(\"logfile\");\n-        if (val == null) {\n-            return null;\n-        }\n-        return Path.of(val);\n-    }).get();\n+    private static TestInstance currentTest() {\n+        return state().currentTest;\n+    }\n@@ -1273,16 +1296,3 @@\n-    static {\n-        Set<String> logOptions = tokenizeConfigProperty(\"suppress-logging\");\n-        if (logOptions == null) {\n-            TRACE = true;\n-            TRACE_ASSERTS = true;\n-            VERBOSE_JPACKAGE = true;\n-            VERBOSE_TEST_SETUP = true;\n-        } else if (logOptions.contains(\"all\")) {\n-            TRACE = false;\n-            TRACE_ASSERTS = false;\n-            VERBOSE_JPACKAGE = false;\n-            VERBOSE_TEST_SETUP = false;\n-        } else {\n-            Predicate<Set<String>> isNonOf = options -> {\n-                return Collections.disjoint(logOptions, options);\n-            };\n+    static boolean verboseJPackage() {\n+        return state().verboseJPackage;\n+    }\n@@ -1290,5 +1300,2 @@\n-            TRACE = isNonOf.test(Set.of(\"trace\", \"t\"));\n-            TRACE_ASSERTS = isNonOf.test(Set.of(\"assert\", \"a\"));\n-            VERBOSE_JPACKAGE = isNonOf.test(Set.of(\"jpackage\", \"jp\"));\n-            VERBOSE_TEST_SETUP = isNonOf.test(Set.of(\"init\", \"i\"));\n-        }\n+    static boolean verboseTestSetup() {\n+        return state().verboseTestSetup;\n@@ -1297,0 +1304,1 @@\n+\n@@ -1322,0 +1330,155 @@\n+\n+\n+    public static final class State {\n+\n+        private State(\n+                Optional<Path> logFile,\n+                TestInstance currentTest,\n+                PrintStream mainLogStream,\n+                PrintStream stackTraceStream,\n+                PrintStream extraLogStream,\n+                boolean trace,\n+                boolean traceAsserts,\n+                boolean verboseJPackage,\n+                boolean verboseTestSetup) {\n+\n+            Objects.requireNonNull(logFile);\n+            Objects.requireNonNull(mainLogStream);\n+            Objects.requireNonNull(stackTraceStream);\n+\n+            this.logFile = logFile;\n+            this.currentTest = currentTest;\n+            this.mainLogStream = mainLogStream;\n+            this.stackTraceStream = stackTraceStream;\n+            this.extraLogStream = extraLogStream;\n+\n+            this.trace = trace;\n+            this.traceAsserts = traceAsserts;\n+\n+            this.verboseJPackage = verboseJPackage;\n+            this.verboseTestSetup = verboseTestSetup;\n+        }\n+\n+\n+        Builder buildCopy() {\n+            return build().initFrom(this);\n+        }\n+\n+        static Builder build() {\n+            return new Builder();\n+        }\n+\n+\n+        static final class Builder {\n+\n+            Builder initDefaults() {\n+                logFile = Optional.ofNullable(getConfigProperty(\"logfile\")).map(Path::of);\n+                currentTest = null;\n+                mainLogStream = System.out;\n+                stackTraceStream = System.err;\n+                extraLogStream = null;\n+\n+                var logOptions = tokenizeConfigProperty(\"suppress-logging\");\n+                if (logOptions == null) {\n+                    trace = true;\n+                    traceAsserts = true;\n+                    verboseJPackage = true;\n+                    verboseTestSetup = true;\n+                } else if (logOptions.contains(\"all\")) {\n+                    trace = false;\n+                    traceAsserts = false;\n+                    verboseJPackage = false;\n+                    verboseTestSetup = false;\n+                } else {\n+                    Predicate<Set<String>> isNonOf = options -> {\n+                        return Collections.disjoint(logOptions, options);\n+                    };\n+\n+                    trace = isNonOf.test(Set.of(\"trace\", \"t\"));\n+                    traceAsserts = isNonOf.test(Set.of(\"assert\", \"a\"));\n+                    verboseJPackage = isNonOf.test(Set.of(\"jpackage\", \"jp\"));\n+                    verboseTestSetup = isNonOf.test(Set.of(\"init\", \"i\"));\n+                }\n+\n+                return this;\n+            }\n+\n+            Builder initFrom(State state) {\n+                logFile = state.logFile;\n+                currentTest = state.currentTest;\n+                mainLogStream = state.mainLogStream;\n+                stackTraceStream = state.stackTraceStream;\n+                extraLogStream = state.extraLogStream;\n+\n+                trace = state.trace;\n+                traceAsserts = state.traceAsserts;\n+\n+                verboseJPackage = state.verboseJPackage;\n+                verboseTestSetup = state.verboseTestSetup;\n+\n+                return this;\n+            }\n+\n+            Builder logFile(Optional<Path> v) {\n+                logFile = v;\n+                return this;\n+            }\n+\n+            Builder currentTest(TestInstance v) {\n+                currentTest = v;\n+                return this;\n+            }\n+\n+            Builder mainLogStream(PrintStream v) {\n+                mainLogStream = v;\n+                return this;\n+            }\n+\n+            Builder stackTraceStream(PrintStream v) {\n+                stackTraceStream = v;\n+                return this;\n+            }\n+\n+            Builder extraLogStream(PrintStream v) {\n+                extraLogStream = v;\n+                return this;\n+            }\n+\n+            State create() {\n+                return new State(logFile, currentTest, mainLogStream, stackTraceStream, extraLogStream, trace, traceAsserts, verboseJPackage, verboseTestSetup);\n+            }\n+\n+            private Optional<Path> logFile;\n+            private TestInstance currentTest;\n+            private PrintStream mainLogStream;\n+            private PrintStream stackTraceStream;\n+            private PrintStream extraLogStream;\n+\n+            private boolean trace;\n+            private boolean traceAsserts;\n+\n+            private boolean verboseJPackage;\n+            private boolean verboseTestSetup;\n+        }\n+\n+\n+        private final Optional<Path> logFile;\n+        private final TestInstance currentTest;\n+        private final PrintStream mainLogStream;\n+        private final PrintStream stackTraceStream;\n+        private final PrintStream extraLogStream;\n+\n+        private final boolean trace;\n+        private final boolean traceAsserts;\n+\n+        private final boolean verboseJPackage;\n+        private final boolean verboseTestSetup;\n+    }\n+\n+\n+    private static final InheritableThreadLocal<State> STATE = new InheritableThreadLocal<>() {\n+        @Override\n+        protected State initialValue() {\n+            return State.build().initDefaults().create();\n+        }\n+    };\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":253,"deletions":90,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n-        if (TKit.VERBOSE_TEST_SETUP) {\n+        if (TKit.verboseTestSetup()) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -412,1 +412,1 @@\n-        if (TKit.VERBOSE_TEST_SETUP) {\n+        if (TKit.verboseTestSetup()) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestMethodSupplier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import static jdk.jpackage.test.WindowsHelper.killAppLauncherProcess;\n+\n@@ -27,3 +29,0 @@\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import jdk.jpackage.test.JPackageCommand;\n@@ -33,1 +32,1 @@\n-import static jdk.jpackage.test.WindowsHelper.killAppLauncherProcess;\n+import jdk.jpackage.test.JPackageCommand;\n@@ -96,5 +95,4 @@\n-            try ( \/\/ Launch the app in a separate thread\n-                ExecutorService exec = Executors.newSingleThreadExecutor()) {\n-                exec.execute(() -> {\n-                    HelloApp.executeLauncher(cmd);\n-                });\n+            \/\/ Launch the app in a separate thread\n+            new Thread(() -> {\n+                HelloApp.executeLauncher(cmd);\n+            }).start();\n@@ -102,2 +100,2 @@\n-                \/\/ Wait a bit to let the app start\n-                Thread.sleep(Duration.ofSeconds(10));\n+            \/\/ Wait a bit to let the app start\n+            Thread.sleep(Duration.ofSeconds(10));\n@@ -105,3 +103,2 @@\n-                \/\/ Find the main app launcher process and kill it\n-                killAppLauncherProcess(cmd, null, expectedNoRestarted ? 1 : 2);\n-            }\n+            \/\/ Find the main app launcher process and kill it\n+            killAppLauncherProcess(cmd, null, expectedNoRestarted ? 1 : 2);\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinNoRestartTest.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"}]}