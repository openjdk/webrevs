{"files":[{"patch":"@@ -1010,4 +1010,2 @@\n-    z_l(tmp, Address(tmp, Klass::access_flags_offset()));\n-    assert((JVM_ACC_IS_VALUE_BASED_CLASS & 0xFFFF) == 0, \"or change following instruction\");\n-    z_nilh(tmp, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n-    z_brne(slow_case);\n+    testbit(Address(tmp, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    z_btrue(slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5711,3 +5711,0 @@\n-\/\/ Branches to slow upon failure to lock the object.\n-\/\/ Falls through upon success.\n-\/\/\n@@ -5748,10 +5745,9 @@\n-  \/\/ Try to lock. Transition lock-bits 0b01 => 0b00\n-  z_oill(mark, markWord::unlocked_value);\n-\n-  z_lgr(top, mark);\n-\n-  \/\/ Clear lock-bits from hdr (locked state)\n-  z_xilf(top, markWord::unlocked_value);\n-\n-  z_csg(mark, top, oopDesc::mark_offset_in_bytes(), obj);\n-  branch_optimized(Assembler::bcondNotEqual, slow);\n+  { \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n+    const Register locked_obj = top;\n+    z_oill(mark, markWord::unlocked_value);\n+    z_lgr(locked_obj, mark);\n+    \/\/ Clear lock-bits from locked_obj (locked state)\n+    z_xilf(locked_obj, markWord::unlocked_value);\n+    z_csg(mark, locked_obj, oopDesc::mark_offset_in_bytes(), obj);\n+    branch_optimized(Assembler::bcondNotEqual, slow);\n+  }\n@@ -5765,3 +5761,0 @@\n-\n-  \/\/ as locking was successful, set CC to EQ\n-  z_cr(top, top); \/\/ z_ahi instruction above can change the cc, so we need this\n@@ -5771,3 +5764,0 @@\n-\/\/ Branches to slow upon failure.\n-\/\/ Falls through upon success.\n-\/\/\n@@ -5783,2 +5773,2 @@\n-  const Register mark     = temp1;\n-  const Register top      = temp2;\n+  const Register mark = temp1;\n+  const Register top  = temp2;\n@@ -5837,2 +5827,1 @@\n-  \/\/ Try to unlock. Transition lock bits 0b00 => 0b01\n-  {\n+  { \/\/ Try to unlock. Transition lock bits 0b00 => 0b01\n@@ -5856,1 +5845,1 @@\n-  bind(unlocked); \/\/ CC is already set to EQ, if we jumped here\n+  bind(unlocked);\n@@ -5906,1 +5895,1 @@\n-    \/\/ Try to lock. Transition lock bits 0b00 => 0b01\n+    \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n@@ -5986,4 +5975,2 @@\n-  const Register mark     = tmp1;\n-  const Register top      = tmp2;\n-  const Register temp_top = tmp1;\n-\n+  const Register mark = tmp1;\n+  const Register top  = tmp2;\n@@ -6003,0 +5990,1 @@\n+    const Register temp_top = tmp1; \/\/ let's not kill top here, we can use for recursive check\n@@ -6012,5 +6000,2 @@\n-    z_aghik(temp_top, top, -oopSize);\n-    \/\/ we will encounter a loop while handling the inflated monitor case\n-    \/\/ so, we need to make sure, when we reach there only top one object is removed.\n-    \/\/ if we load top there then it could result into infinite loop, So preserving top is a Must here;\n-    z_cg(obj, Address(Z_thread, temp_top));\n+    z_aghi(top, -oopSize);\n+    z_cg(obj, Address(Z_thread, top));\n@@ -6035,2 +6020,1 @@\n-    \/\/ Try to unlock. Transition lock bits 0b00 => 0b01\n-    {\n+    { \/\/ Try to unlock. Transition lock bits 0b00 => 0b01\n@@ -6069,1 +6053,3 @@\n-    NearLabel check_done;\n+    NearLabel check_done, loop;\n+    z_lgf(top, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n+    bind(loop);\n@@ -6074,1 +6060,1 @@\n-    z_brne(inflated);\n+    z_brne(loop);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":24,"deletions":38,"binary":false,"changes":62,"status":"modified"}]}