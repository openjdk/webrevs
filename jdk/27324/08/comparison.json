{"files":[{"patch":"@@ -485,8 +485,1 @@\n-        String canonicalPath = canonicalize0(path);\n-        String finalPath = null;\n-        try {\n-            finalPath = getFinalPath(canonicalPath);\n-        } catch (IOException ignored) {\n-            finalPath = canonicalPath;\n-        }\n-        return finalPath;\n+        return canonicalize0(path);\n","filename":"src\/java.base\/windows\/classes\/java\/io\/WinNTFileSystem.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-extern int wcanonicalize(const WCHAR *path, WCHAR *out, int len);\n+extern WCHAR* wcanonicalize(const WCHAR *path, WCHAR *out, int len);\n@@ -277,0 +277,1 @@\n+        WCHAR* fp;\n@@ -280,2 +281,4 @@\n-                if (wcanonicalize(path, cp, len) >= 0) {\n-                    rv = (*env)->NewString(env, cp, (jsize)wcslen(cp));\n+                if ((fp = wcanonicalize(path, cp, len)) != NULL) {\n+                    rv = (*env)->NewString(env, fp, (jsize)wcslen(fp));\n+                    if (fp != cp)\n+                        free(fp);\n@@ -287,2 +290,4 @@\n-        } else if (wcanonicalize(path, canonicalPath, MAX_PATH_LENGTH) >= 0) {\n-            rv = (*env)->NewString(env, canonicalPath, (jsize)wcslen(canonicalPath));\n+        } else if ((fp = wcanonicalize(path, canonicalPath, MAX_PATH_LENGTH)) != NULL) {\n+            rv = (*env)->NewString(env, fp, (jsize)wcslen(canonicalPath));\n+            if (fp != canonicalPath)\n+                free(fp);\n","filename":"src\/java.base\/windows\/native\/libjava\/WinNTFileSystem_md.c","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include <wchar.h>\n@@ -149,0 +150,47 @@\n+\/\/\n+\/\/ Return the final path of 'path'. If 'finalPath' is long enough, the final\n+\/\/ path is placed in it. If not, a new character array is allocated for the\n+\/\/ return value. If the return value does not equal the original 'finalPath'\n+\/\/ value, then the calling code might need to free the memory of the\n+\/\/ parameter. Non-NULL is returned on success, NULL on error.\n+\/\/\n+WCHAR* getFinalPath(WCHAR* path, WCHAR* finalPath, DWORD size)\n+{\n+    HANDLE h = CreateFileW(path,\n+                           FILE_READ_ATTRIBUTES,\n+                           FILE_SHARE_DELETE |\n+                           FILE_SHARE_READ | FILE_SHARE_WRITE,\n+                           NULL,\n+                           OPEN_EXISTING,\n+                           FILE_FLAG_BACKUP_SEMANTICS,\n+                           NULL);\n+\n+    if (h != INVALID_HANDLE_VALUE) {\n+        DWORD len = GetFinalPathNameByHandleW(h, finalPath, size, 0);\n+        if (len >= size) {\n+            if ((finalPath = (WCHAR*)malloc(len * sizeof(WCHAR))) == NULL)\n+                return NULL;\n+            len = GetFinalPathNameByHandleW(h, finalPath, len, 0);\n+        }\n+        CloseHandle(h);\n+        if (len != 0) {\n+            if (finalPath[0] == L'\\\\' && finalPath[1] == L'\\\\' &&\n+                finalPath[2] == L'?' && finalPath[3] == L'\\\\')\n+            {\n+                \/\/ Strip prefix (should be \\\\?\\ or \\\\?\\UNC)\n+                int isUnc = (finalPath[4] == L'U' &&\n+                             finalPath[5] == L'N' &&\n+                             finalPath[6] == L'C');\n+                int prefixLen = (isUnc) ? 7 : 4;\n+                \/\/ the amount to copy includes terminator\n+                int amountToCopy = len - prefixLen + 1;\n+                wmemmove(finalPath, finalPath + prefixLen, amountToCopy);\n+            }\n+\n+            return finalPath;\n+        }\n+    }\n+\n+    return NULL;\n+}\n+\n@@ -153,1 +201,1 @@\n-int\n+WCHAR*\n@@ -164,1 +212,1 @@\n-        return -1;\n+        return NULL;\n@@ -168,1 +216,1 @@\n-        return -1;\n+        return NULL;\n@@ -240,0 +288,10 @@\n+\n+            \/\/ If a reparse point is encountered, get the final path.\n+            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) != 0) {\n+                WCHAR* fp = NULL;\n+                if ((fp = getFinalPath(path, result, size)) == NULL)\n+                    goto err;\n+                free(path);\n+                return fp;\n+            }\n+\n@@ -264,1 +322,1 @@\n-    return 0;\n+    return result;\n@@ -268,1 +326,1 @@\n-    return -1;\n+    return NULL;\n","filename":"src\/java.base\/windows\/native\/libjava\/canonicalize_md.c","additions":63,"deletions":5,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4899022 8003887\n+ * @bug 4899022 8003887 8355342\n@@ -36,0 +36,1 @@\n+import java.util.Set;\n@@ -130,0 +131,46 @@\n+    @Test\n+    @EnabledOnOs(OS.WINDOWS)\n+    void mappedDrive() throws IOException {\n+        \/\/ find the first unused drive letter\n+        char drive = '[';\n+        var roots = Set.of(new File(\".\").listRoots());\n+        for (int i = 4; i < 26; i++) {\n+            char c = (char)('A' + i);\n+            if (!roots.contains(new File(c + \":\\\\\"))) {\n+                drive = c;\n+                break;\n+            }\n+        }\n+        assertFalse(drive == '['); \/\/ '[' is next after 'Z'\n+\n+        \/\/ map the first unused drive letter to the cwd\n+        String cwd = System.getProperty(\"user.dir\");\n+        Runtime rt = Runtime.getRuntime();\n+        String share =\n+            \"\\\\\\\\localhost\\\\\" + cwd.charAt(0) + \"$\" + cwd.substring(2);\n+        try {\n+            Process p = rt.exec(new String[] {\"net\", \"use\", drive + \":\", share});\n+            assertEquals(0, p.waitFor());\n+        } catch (InterruptedException x) {\n+            fail(x);\n+        }\n+\n+        \/\/ check that the canonical path name and its content are as expected\n+        try {\n+            final String filename = \"file.txt\";\n+            final String text = \"This is some text\";\n+            Files.writeString(Path.of(share, filename), text);\n+            File file = new File(drive + \":\\\\\" + filename);\n+            String canonicalPath = file.getCanonicalPath();\n+            assertEquals(drive + \":\\\\\" + filename, canonicalPath);\n+            assertEquals(text, Files.readString(Path.of(canonicalPath)));\n+        } finally {\n+            try {\n+                Process p = rt.exec(new String[] {\"net\", \"use\", drive + \":\", \"\/Delete\"});\n+                assertEquals(0, p.waitFor());\n+            } catch (InterruptedException x) {\n+                fail(x);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/io\/File\/GetCanonicalPath.java","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"}]}