{"files":[{"patch":"@@ -485,8 +485,1 @@\n-        String canonicalPath = canonicalize0(path);\n-        String finalPath = null;\n-        try {\n-            finalPath = getFinalPath(canonicalPath);\n-        } catch (IOException ignored) {\n-            finalPath = canonicalPath;\n-        }\n-        return finalPath;\n+        return canonicalize0(path);\n@@ -498,8 +491,0 @@\n-    private String getFinalPath(String path) throws IOException {\n-        return getFinalPath0(path);\n-    }\n-\n-    private native String getFinalPath0(String path)\n-            throws IOException;\n-\n-\n","filename":"src\/java.base\/windows\/classes\/java\/io\/WinNTFileSystem.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-extern int wcanonicalize(const WCHAR *path, WCHAR *out, int len);\n+extern WCHAR* wcanonicalize(const WCHAR *path, WCHAR *out, int len);\n@@ -277,0 +277,1 @@\n+        WCHAR* fp;\n@@ -280,2 +281,4 @@\n-                if (wcanonicalize(path, cp, len) >= 0) {\n-                    rv = (*env)->NewString(env, cp, (jsize)wcslen(cp));\n+                if ((fp = wcanonicalize(path, cp, len)) != NULL) {\n+                    rv = (*env)->NewString(env, fp, (jsize)wcslen(fp));\n+                    if (fp != cp)\n+                        free(fp);\n@@ -287,2 +290,4 @@\n-        } else if (wcanonicalize(path, canonicalPath, MAX_PATH_LENGTH) >= 0) {\n-            rv = (*env)->NewString(env, canonicalPath, (jsize)wcslen(canonicalPath));\n+        } else if ((fp = wcanonicalize(path, canonicalPath, MAX_PATH_LENGTH)) != NULL) {\n+            rv = (*env)->NewString(env, fp, (jsize)wcslen(fp));\n+            if (fp != canonicalPath)\n+                free(fp);\n@@ -297,20 +302,0 @@\n-\n-JNIEXPORT jstring JNICALL\n-Java_java_io_WinNTFileSystem_getFinalPath0(JNIEnv* env, jobject this, jstring pathname) {\n-    jstring rv = NULL;\n-\n-    WITH_UNICODE_STRING(env, pathname, path) {\n-        WCHAR* finalPath = getFinalPath(env, path);\n-        if (finalPath != NULL) {\n-            rv = (*env)->NewString(env, finalPath, (jsize)wcslen(finalPath));\n-            free(finalPath);\n-        }\n-    } END_UNICODE_STRING(env, path);\n-\n-    if (rv == NULL && !(*env)->ExceptionCheck(env)) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"Bad pathname\");\n-    }\n-\n-    return rv;\n-}\n-\n","filename":"src\/java.base\/windows\/native\/libjava\/WinNTFileSystem_md.c","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include <wchar.h>\n@@ -85,1 +86,1 @@\n-wwild(WCHAR *start)\n+wwild(const WCHAR *start)\n@@ -87,1 +88,1 @@\n-    WCHAR *p = start;\n+    WCHAR *p = (WCHAR*)start;\n@@ -149,6 +150,53 @@\n-\/* Convert a pathname to canonical form.  The input orig_path is assumed to\n-   have been converted to native form already, via JVM_NativePath().  This is\n-   necessary because _fullpath() rejects duplicate separator characters on\n-   Win95, though it accepts them on NT. *\/\n-int\n-wcanonicalize(WCHAR *orig_path, WCHAR *result, int size)\n+\/\/\n+\/\/ Return the final path of 'path'. If 'finalPath' is long enough, the final\n+\/\/ path is placed in it. If not, a new character array is allocated for the\n+\/\/ return value. If the return value does not equal the original 'finalPath'\n+\/\/ value, then the calling code might need to free the memory of the\n+\/\/ parameter. Non-NULL is returned on success, NULL on error.\n+\/\/\n+WCHAR* getFinalPath(WCHAR* path, WCHAR* finalPath, DWORD size)\n+{\n+    HANDLE h = CreateFileW(path,\n+                           FILE_READ_ATTRIBUTES,\n+                           FILE_SHARE_DELETE |\n+                           FILE_SHARE_READ | FILE_SHARE_WRITE,\n+                           NULL,\n+                           OPEN_EXISTING,\n+                           FILE_FLAG_BACKUP_SEMANTICS,\n+                           NULL);\n+\n+    if (h != INVALID_HANDLE_VALUE) {\n+        DWORD len = GetFinalPathNameByHandleW(h, finalPath, size, 0);\n+        if (len >= size) {\n+            if ((finalPath = (WCHAR*)malloc(len * sizeof(WCHAR))) == NULL)\n+                return NULL;\n+            len = GetFinalPathNameByHandleW(h, finalPath, len, 0);\n+        }\n+        CloseHandle(h);\n+        if (len != 0) {\n+            if (finalPath[0] == L'\\\\' && finalPath[1] == L'\\\\' &&\n+                finalPath[2] == L'?' && finalPath[3] == L'\\\\')\n+            {\n+                \/\/ Strip prefix (should be \\\\?\\ or \\\\?\\UNC)\n+                int isUnc = (finalPath[4] == L'U' &&\n+                             finalPath[5] == L'N' &&\n+                             finalPath[6] == L'C');\n+                int prefixLen = (isUnc) ? 7 : 4;\n+                \/\/ the amount to copy includes terminator\n+                int amountToCopy = len - prefixLen + 1;\n+                wmemmove(finalPath, finalPath + prefixLen, amountToCopy);\n+            }\n+\n+            return finalPath;\n+        }\n+    }\n+\n+    return NULL;\n+}\n+\n+\/* Convert a pathname to canonical form.  If a reparse point is encountered\n+   while traversing the path, then the final path is derived from the full path\n+   and returned as the canonical pathname.\n+ *\/\n+WCHAR*\n+wcanonicalize(const WCHAR *orig_path, WCHAR *result, int size)\n@@ -164,1 +212,1 @@\n-        return -1;\n+        return NULL;\n@@ -168,1 +216,1 @@\n-        return -1;\n+        return NULL;\n@@ -240,0 +288,10 @@\n+\n+            \/\/ If a reparse point is encountered, get the final path.\n+            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) != 0) {\n+                WCHAR* fp = NULL;\n+                if ((fp = getFinalPath(path, result, size)) == NULL)\n+                    goto err;\n+                free(path);\n+                return fp;\n+            }\n+\n@@ -264,1 +322,1 @@\n-    return 0;\n+    return result;\n@@ -268,1 +326,1 @@\n-    return -1;\n+    return NULL;\n@@ -277,0 +335,1 @@\n+    wchar_t* wcanon = NULL;\n@@ -300,1 +359,1 @@\n-    if (wcanonicalize(wpath, wresult, len) != 0) {\n+    if ((wcanon = wcanonicalize(wpath, wresult, len)) == NULL) {\n@@ -305,1 +364,1 @@\n-                            wresult, -1, out, len, NULL, NULL) == 0) {\n+                            wcanon, -1, out, len, NULL, NULL) == 0) {\n@@ -313,2 +372,6 @@\n-    free(wresult);\n-    free(wpath);\n+    if (wcanon != NULL && wcanon != wresult)\n+        free(wcanon);\n+    if (wresult != NULL)\n+        free(wresult);\n+    if (wpath != NULL)\n+        free(wpath);\n","filename":"src\/java.base\/windows\/native\/libjava\/canonicalize_md.c","additions":79,"deletions":16,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4899022 8003887\n+ * @bug 4899022 8003887 8355342\n@@ -36,0 +36,1 @@\n+import java.util.Set;\n@@ -130,0 +131,46 @@\n+    @Test\n+    @EnabledOnOs(OS.WINDOWS)\n+    void mappedDrive() throws IOException {\n+        \/\/ find the first unused drive letter\n+        char drive = '[';\n+        var roots = Set.of(new File(\".\").listRoots());\n+        for (int i = 4; i < 26; i++) {\n+            char c = (char)('A' + i);\n+            if (!roots.contains(new File(c + \":\\\\\"))) {\n+                drive = c;\n+                break;\n+            }\n+        }\n+        assertFalse(drive == '['); \/\/ '[' is next after 'Z'\n+\n+        \/\/ map the first unused drive letter to the cwd\n+        String cwd = System.getProperty(\"user.dir\");\n+        Runtime rt = Runtime.getRuntime();\n+        String share =\n+            \"\\\\\\\\localhost\\\\\" + cwd.charAt(0) + \"$\" + cwd.substring(2);\n+        try {\n+            Process p = rt.exec(new String[] {\"net\", \"use\", drive + \":\", share});\n+            assertEquals(0, p.waitFor());\n+        } catch (InterruptedException x) {\n+            fail(x);\n+        }\n+\n+        \/\/ check that the canonical path name and its content are as expected\n+        try {\n+            final String filename = \"file.txt\";\n+            final String text = \"This is some text\";\n+            Files.writeString(Path.of(share, filename), text);\n+            File file = new File(drive + \":\\\\\" + filename);\n+            String canonicalPath = file.getCanonicalPath();\n+            assertEquals(drive + \":\\\\\" + filename, canonicalPath);\n+            assertEquals(text, Files.readString(Path.of(canonicalPath)));\n+        } finally {\n+            try {\n+                Process p = rt.exec(new String[] {\"net\", \"use\", drive + \":\", \"\/Delete\"});\n+                assertEquals(0, p.waitFor());\n+            } catch (InterruptedException x) {\n+                fail(x);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/io\/File\/GetCanonicalPath.java","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"}]}