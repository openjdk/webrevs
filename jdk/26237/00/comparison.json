{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2025, Red Hat, Inc. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"oops\/oop.inline.hpp\"\n@@ -33,0 +34,2 @@\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/vmError.hpp\"\n@@ -60,4 +63,1 @@\n-  r->print_on(&ss);\n-\n-  stringStream mw_ss;\n-  obj->mark().print_on(&mw_ss);\n+  StreamIndentor si(&ss);\n@@ -67,16 +67,28 @@\n-  Klass* obj_klass = ShenandoahForwarding::klass(obj);\n-\n-  msg.append(\"  \" PTR_FORMAT \" - klass \" PTR_FORMAT \" %s\\n\", p2i(obj), p2i(obj_klass), obj_klass->external_name());\n-  msg.append(\"    %3s allocated after mark start\\n\", ctx->allocated_after_mark_start(obj) ? \"\" : \"not\");\n-  msg.append(\"    %3s after update watermark\\n\",     cast_from_oop<HeapWord*>(obj) >= r->get_update_watermark() ? \"\" : \"not\");\n-  msg.append(\"    %3s marked strong\\n\",              ctx->is_marked_strong(obj) ? \"\" : \"not\");\n-  msg.append(\"    %3s marked weak\\n\",                ctx->is_marked_weak(obj) ? \"\" : \"not\");\n-  msg.append(\"    %3s in collection set\\n\",          heap->in_collection_set(obj) ? \"\" : \"not\");\n-  if (heap->mode()->is_generational() && !obj->is_forwarded()) {\n-    msg.append(\"  age: %d\\n\", obj->age());\n-  }\n-  msg.append(\"  mark:%s\\n\", mw_ss.freeze());\n-  msg.append(\"  region: %s\", ss.freeze());\n-  if (obj_klass == vmClasses::Class_klass()) {\n-    msg.append(\"  mirrored klass:       \" PTR_FORMAT \"\\n\", p2i(obj->metadata_field(java_lang_Class::klass_offset())));\n-    msg.append(\"  mirrored array klass: \" PTR_FORMAT \"\\n\", p2i(obj->metadata_field(java_lang_Class::array_klass_offset())));\n+  narrowKlass nk = 0;\n+  const Klass* obj_klass = nullptr;\n+  const bool klass_valid = extract_klass_safely(obj, nk, obj_klass);\n+  const char* klass_text = \"(invalid)\";\n+  if (klass_valid && os::is_readable_pointer(obj_klass) && Metaspace::contains(obj_klass)) {\n+    klass_text = obj_klass->external_name();\n+  }\n+  ss.print_cr(PTR_FORMAT \" - nk %u klass \" PTR_FORMAT \" %s\\n\", p2i(obj), nk, p2i(obj_klass), klass_text);\n+  {\n+    StreamIndentor si(&ss);\n+    ss.print_cr(\"%3s allocated after mark start\", ctx->allocated_after_mark_start(obj) ? \"\" : \"not\");\n+    ss.print_cr(\"%3s after update watermark\",     cast_from_oop<HeapWord*>(obj) >= r->get_update_watermark() ? \"\" : \"not\");\n+    ss.print_cr(\"%3s marked strong\",              ctx->is_marked_strong(obj) ? \"\" : \"not\");\n+    ss.print_cr(\"%3s marked weak\",                ctx->is_marked_weak(obj) ? \"\" : \"not\");\n+    ss.print_cr(\"%3s in collection set\",          heap->in_collection_set(obj) ? \"\" : \"not\");\n+    if (heap->mode()->is_generational() && !obj->is_forwarded()) {\n+      ss.print_cr(\"age: %d\", obj->age());\n+    }\n+    ss.print_raw(\"mark: \");\n+    obj->mark().print_on(&ss);\n+    ss.cr();\n+    ss.print_raw(\"region: \");\n+    r->print_on(&ss);\n+    ss.cr();\n+    if (obj_klass == vmClasses::Class_klass()) {\n+      msg.append(\"  mirrored klass:       \" PTR_FORMAT \"\\n\", p2i(obj->metadata_field(java_lang_Class::klass_offset())));\n+      msg.append(\"  mirrored array klass: \" PTR_FORMAT \"\\n\", p2i(obj->metadata_field(java_lang_Class::array_klass_offset())));\n+    }\n@@ -84,0 +96,3 @@\n+  const_address loc = cast_from_oop<const_address>(obj);\n+  os::print_hex_dump(&ss, loc, loc + 64, 4, true, 32, loc);\n+  msg.append(\"%s\", ss.base());\n@@ -124,0 +139,4 @@\n+  if (!os::is_readable_pointer(obj)) {\n+    level = _safe_unknown;\n+  }\n+\n@@ -131,1 +150,1 @@\n-    if (loc_in_heap) {\n+    if (loc_in_heap && os::is_readable_pointer(loc)) {\n@@ -153,1 +172,1 @@\n-      if (level >= _safe_oop_fwd) {\n+      if (level >= _safe_oop_fwd && os::is_readable_pointer(fwd)) {\n@@ -208,8 +227,1 @@\n-  Klass* obj_klass = ShenandoahForwarding::klass(obj);\n-  if (obj_klass == nullptr) {\n-    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n-                  \"Object klass pointer should not be null\",\n-                  file,line);\n-  }\n-\n-  if (!Metaspace::contains(obj_klass)) {\n+  if (!os::is_readable_pointer(obj)) {\n@@ -217,2 +229,2 @@\n-                  \"Object klass pointer must go to metaspace\",\n-                  file,line);\n+                  \"oop within heap bounds but at unreadable location\",\n+                  file, line);\n@@ -246,1 +258,1 @@\n-    if (obj_klass != ShenandoahForwarding::klass(fwd)) {\n+    if (!os::is_readable_pointer(fwd)) {\n@@ -248,1 +260,1 @@\n-                    \"Forwardee klass disagrees with object class\",\n+                    \"Forwardee within heap bounds but at unreadable location\",\n@@ -274,0 +286,26 @@\n+  const Klass* obj_klass = nullptr;\n+  narrowKlass nk = 0;\n+  if (!extract_klass_safely(obj, nk, obj_klass)) {\n+    print_failure(_safe_oop, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                  \"Object klass pointer invalid\",\n+                  file,line);\n+  }\n+\n+  if (obj_klass == nullptr) {\n+    print_failure(_safe_oop, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                  \"Object klass pointer should not be null\",\n+                  file,line);\n+  }\n+\n+  if (!Metaspace::contains(obj_klass)) {\n+    print_failure(_safe_oop, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                  \"Object klass pointer must go to metaspace\",\n+                  file,line);\n+  }\n+\n+  if (!UseCompactObjectHeaders && obj_klass != fwd->klass_or_null()) {\n+    print_failure(_safe_oop, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                  \"Forwardee klass disagrees with object class\",\n+                  file, line);\n+  }\n+\n@@ -522,0 +560,27 @@\n+\n+bool ShenandoahAsserts::extract_klass_safely(oop obj, narrowKlass& nk, const Klass*& k) {\n+  nk = 0;\n+  k = nullptr;\n+\n+  if (!os::is_readable_pointer(obj)) {\n+    return false;\n+  }\n+  if (UseCompressedClassPointers) {\n+    if (UseCompactObjectHeaders) { \/\/ look in forwardee\n+      oop fwd = ShenandoahForwarding::get_forwardee_raw_unchecked(obj);\n+      if (!os::is_readable_pointer(fwd)) {\n+        return false;\n+      }\n+      nk = fwd->mark().narrow_klass();\n+    } else {\n+      nk = obj->narrow_klass();\n+    }\n+    if (!CompressedKlassPointers::is_valid_narrow_klass_id(nk)) {\n+      return false;\n+    }\n+    k = CompressedKlassPointers::decode_not_null_without_asserts(nk);\n+  } else {\n+    k = obj->klass();\n+  }\n+  return k != nullptr;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":100,"deletions":35,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2025, Red Hat, Inc. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n@@ -80,0 +81,5 @@\n+  \/\/ Given a possibly invalid oop, extract narrowKlass (if UCCP) and Klass*\n+  \/\/ from it safely.\n+  \/\/ Note: For -UCCP, returned nk is always 0.\n+  static bool extract_klass_safely(oop obj, narrowKlass& nk, const Klass*& k);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2025, Red Hat, Inc. All rights reserved.\n@@ -152,0 +152,2 @@\n+    check(ShenandoahAsserts::_safe_unknown, obj, os::is_readable_pointer(obj),\n+              \"oop must be accessible\");\n@@ -154,1 +156,7 @@\n-    Klass* obj_klass = ShenandoahForwarding::klass(obj);\n+\n+    narrowKlass nk = 0;\n+    const Klass* obj_klass = nullptr;\n+    const bool klass_valid = ShenandoahAsserts::extract_klass_safely(obj, nk, obj_klass);\n+\n+    check(ShenandoahAsserts::_safe_unknown, obj, klass_valid,\n+           \"Object klass pointer unreadable or invalid\");\n@@ -159,2 +167,0 @@\n-      check(ShenandoahAsserts::_safe_unknown, obj, obj_klass != nullptr,\n-             \"Object klass pointer should not be null\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -254,0 +254,3 @@\n+  \/\/ Given a narrow Klass ID, returns true if it appears to be valid\n+  inline static bool is_valid_narrow_klass_id(narrowKlass nk);\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -96,0 +96,5 @@\n+\/\/ Given a narrow Klass ID, returns true if it appears to be valid\n+inline bool CompressedKlassPointers::is_valid_narrow_klass_id(narrowKlass nk) {\n+  return nk >= _lowest_valid_narrow_klass_id && nk < _highest_valid_narrow_klass_id;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+  inline narrowKlass narrow_klass() const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+narrowKlass oopDesc::narrow_klass() const {\n+  switch (ObjLayout::klass_mode()) {\n+    case ObjLayout::Compact:\n+      return mark().narrow_klass();\n+    case ObjLayout::Compressed:\n+      return _metadata._compressed_klass;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-  StreamIndentor(outputStream* os, int indentation) :\n+  StreamIndentor(outputStream* os, int indentation = 2) :\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2024, 2025, Red Hat, Inc. All rights reserved.\n@@ -25,0 +25,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -110,0 +111,12 @@\n+\n+TEST_VM(CompressedKlass, test_is_valid_narrow_klass) {\n+  if (!UseCompressedClassPointers) {\n+    return;\n+  }\n+  ASSERT_FALSE(CompressedKlassPointers::is_valid_narrow_klass_id(0));\n+  narrowKlass nk_jlC = CompressedKlassPointers::encode((Klass*)vmClasses::Class_klass());\n+  ASSERT_TRUE(CompressedKlassPointers::is_valid_narrow_klass_id(nk_jlC));\n+  if (CompressedClassSpaceSize < 4 * G && CompressedKlassPointers::base() != nullptr) {\n+    ASSERT_FALSE(CompressedKlassPointers::is_valid_narrow_klass_id(0xFFFFFFFF));\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/oops\/test_compressedKlass.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"}]}