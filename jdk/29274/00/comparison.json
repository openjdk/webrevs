{"files":[{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/atomicAccess.hpp\"\n@@ -195,2 +194,2 @@\n-    _coarsen_from[i] = 0;\n-    _coarsen_collision[i] = 0;\n+    _coarsen_from[i].store_relaxed(0);\n+    _coarsen_collision[i].store_relaxed(0);\n@@ -203,2 +202,2 @@\n-    _coarsen_from[i] = other._coarsen_from[i];\n-    _coarsen_collision[i] = other._coarsen_collision[i];\n+    _coarsen_from[i].store_relaxed(other._coarsen_from[i].load_relaxed());\n+    _coarsen_collision[i].store_relaxed(other._coarsen_collision[i].load_relaxed());\n@@ -211,2 +210,2 @@\n-    _coarsen_from[i] = other._coarsen_from[i] - _coarsen_from[i];\n-    _coarsen_collision[i] = other._coarsen_collision[i] - _coarsen_collision[i];\n+    _coarsen_from[i].store_relaxed(other._coarsen_from[i].load_relaxed() - _coarsen_from[i].load_relaxed());\n+    _coarsen_collision[i].store_relaxed(other._coarsen_collision[i].load_relaxed() - _coarsen_collision[i].load_relaxed());\n@@ -218,1 +217,1 @@\n-  AtomicAccess::inc(&_coarsen_from[tag], memory_order_relaxed);\n+  _coarsen_from[tag].add_then_fetch(1u, memory_order_relaxed);\n@@ -220,1 +219,1 @@\n-    AtomicAccess::inc(&_coarsen_collision[tag], memory_order_relaxed);\n+    _coarsen_collision[tag].add_then_fetch(1u, memory_order_relaxed);\n@@ -231,2 +230,2 @@\n-                _coarsen_from[0], _coarsen_collision[0],\n-                _coarsen_from[1], _coarsen_collision[1],\n+                _coarsen_from[0].load_relaxed(), _coarsen_collision[0].load_relaxed(),\n+                _coarsen_from[1].load_relaxed(), _coarsen_collision[1].load_relaxed(),\n@@ -234,4 +233,4 @@\n-                _coarsen_from[3], _coarsen_collision[3],\n-                _coarsen_from[4], _coarsen_collision[4],\n-                _coarsen_from[5], _coarsen_collision[5],\n-                _coarsen_from[6], _coarsen_collision[6]\n+                _coarsen_from[3].load_relaxed(), _coarsen_collision[3].load_relaxed(),\n+                _coarsen_from[4].load_relaxed(), _coarsen_collision[4].load_relaxed(),\n+                _coarsen_from[5].load_relaxed(), _coarsen_collision[5].load_relaxed(),\n+                _coarsen_from[6].load_relaxed(), _coarsen_collision[6].load_relaxed()\n@@ -251,1 +250,1 @@\n-  bool volatile _inserted_card;\n+  Atomic<bool> _inserted_card;\n@@ -314,1 +313,1 @@\n-    if (!_inserted_card && inserted) {\n+    if (!_inserted_card.load_relaxed() && inserted) {\n@@ -317,1 +316,1 @@\n-      AtomicAccess::store(&_inserted_card, true);\n+      _inserted_card.store_relaxed(true);\n@@ -346,1 +345,1 @@\n-    if (AtomicAccess::load(&_inserted_card)) {\n+    if (_inserted_card.load_relaxed()) {\n@@ -348,1 +347,1 @@\n-      AtomicAccess::store(&_inserted_card, false);\n+      _inserted_card.store_relaxed(false);\n@@ -458,1 +457,1 @@\n-G1CardSet::ContainerPtr G1CardSet::acquire_container(ContainerPtr volatile* container_addr) {\n+G1CardSet::ContainerPtr G1CardSet::acquire_container(Atomic<ContainerPtr>* container_addr) {\n@@ -465,1 +464,1 @@\n-    ContainerPtr container = AtomicAccess::load_acquire(container_addr);\n+    ContainerPtr container = container_addr->load_acquire();\n@@ -506,1 +505,1 @@\n-  void coarsen_to_full(ContainerPtr* container_addr) {\n+  void coarsen_to_full(Atomic<ContainerPtr>* container_addr) {\n@@ -508,1 +507,1 @@\n-      ContainerPtr cur_container = AtomicAccess::load_acquire(container_addr);\n+      ContainerPtr cur_container = container_addr->load_acquire();\n@@ -514,1 +513,1 @@\n-      ContainerPtr old_value = AtomicAccess::cmpxchg(container_addr, cur_container, G1CardSet::FullCardSet);\n+      ContainerPtr old_value = container_addr->compare_exchange(cur_container, G1CardSet::FullCardSet);\n@@ -526,1 +525,1 @@\n-  void operator ()(ContainerPtr* container_addr) {\n+  void operator ()(Atomic<ContainerPtr>* container_addr) {\n@@ -547,1 +546,1 @@\n-  ContainerPtr volatile* bucket_entry = howl->container_addr(bucket);\n+  Atomic<ContainerPtr>* bucket_entry = howl->container_addr(bucket);\n@@ -550,1 +549,1 @@\n-    if (AtomicAccess::load(&howl->_num_entries) >= _config->cards_in_howl_threshold()) {\n+    if (howl->_num_entries.load_relaxed() >= _config->cards_in_howl_threshold()) {\n@@ -574,1 +573,1 @@\n-    AtomicAccess::inc(&howl->_num_entries, memory_order_relaxed);\n+    howl->_num_entries.add_then_fetch(1u, memory_order_relaxed);\n@@ -591,1 +590,1 @@\n-G1AddCardResult G1CardSet::add_to_inline_ptr(ContainerPtr volatile* container_addr, ContainerPtr container, uint card_in_region) {\n+G1AddCardResult G1CardSet::add_to_inline_ptr(Atomic<ContainerPtr>* container_addr, ContainerPtr container, uint card_in_region) {\n@@ -613,1 +612,1 @@\n-bool G1CardSet::coarsen_container(ContainerPtr volatile* container_addr,\n+bool G1CardSet::coarsen_container(Atomic<ContainerPtr>* container_addr,\n@@ -643,1 +642,1 @@\n-  ContainerPtr old_value = AtomicAccess::cmpxchg(container_addr, cur_container, new_container); \/\/ Memory order?\n+  ContainerPtr old_value = container_addr->compare_exchange(cur_container, new_container); \/\/ Memory order?\n@@ -690,1 +689,1 @@\n-    AtomicAccess::add(&_num_occupied, _config->max_cards_in_region() - table_entry->_num_occupied, memory_order_relaxed);\n+    _num_occupied.add_then_fetch(_config->max_cards_in_region() - table_entry->_num_occupied.load_relaxed(), memory_order_relaxed);\n@@ -716,1 +715,1 @@\n-    AtomicAccess::add(&howling_array->_num_entries, diff, memory_order_relaxed);\n+    howling_array->_num_entries.add_then_fetch(diff, memory_order_relaxed);\n@@ -721,1 +720,1 @@\n-    AtomicAccess::add(&table_entry->_num_occupied, diff, memory_order_relaxed);\n+    table_entry->_num_occupied.add_then_fetch(diff, memory_order_relaxed);\n@@ -723,1 +722,1 @@\n-    AtomicAccess::add(&_num_occupied, diff, memory_order_relaxed);\n+    _num_occupied.add_then_fetch(diff, memory_order_relaxed);\n@@ -727,1 +726,1 @@\n-G1AddCardResult G1CardSet::add_to_container(ContainerPtr volatile* container_addr,\n+G1AddCardResult G1CardSet::add_to_container(Atomic<ContainerPtr>* container_addr,\n@@ -830,2 +829,2 @@\n-    AtomicAccess::inc(&table_entry->_num_occupied, memory_order_relaxed);\n-    AtomicAccess::inc(&_num_occupied, memory_order_relaxed);\n+    table_entry->_num_occupied.add_then_fetch(1u, memory_order_relaxed);\n+    _num_occupied.add_then_fetch(1u, memory_order_relaxed);\n@@ -856,1 +855,1 @@\n-  ContainerPtr container = table_entry->_container;\n+  ContainerPtr container = table_entry->_container.load_relaxed();\n@@ -892,1 +891,1 @@\n-  ContainerPtr container = table_entry->_container;\n+  ContainerPtr container = table_entry->_container.load_relaxed();\n@@ -943,1 +942,1 @@\n-      cl->do_containerptr(value->_region_idx, value->_num_occupied, value->_container);\n+      cl->do_containerptr(value->_region_idx, value->_num_occupied.load_relaxed(), value->_container.load_relaxed());\n@@ -1004,1 +1003,1 @@\n-  return _num_occupied == 0;\n+  return _num_occupied.load_relaxed() == 0;\n@@ -1008,1 +1007,1 @@\n-  return _num_occupied;\n+  return _num_occupied.load_relaxed();\n@@ -1054,1 +1053,1 @@\n-  _num_occupied = 0;\n+  _num_occupied.store_relaxed(0);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":44,"deletions":45,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -157,2 +158,2 @@\n-  size_t _coarsen_from[NumCoarsenCategories];\n-  size_t _coarsen_collision[NumCoarsenCategories];\n+  Atomic<size_t>_coarsen_from[NumCoarsenCategories];\n+  Atomic<size_t> _coarsen_collision[NumCoarsenCategories];\n@@ -274,1 +275,1 @@\n-  size_t _num_occupied;\n+  Atomic<size_t> _num_occupied;\n@@ -278,1 +279,1 @@\n-  ContainerPtr acquire_container(ContainerPtr volatile* container_addr);\n+  ContainerPtr acquire_container(Atomic<ContainerPtr>* container_addr);\n@@ -291,1 +292,1 @@\n-  bool coarsen_container(ContainerPtr volatile* container_addr,\n+  bool coarsen_container(Atomic<ContainerPtr>* container_addr,\n@@ -303,1 +304,1 @@\n-  G1AddCardResult add_to_container(ContainerPtr volatile* container_addr, ContainerPtr container, uint card_region, uint card, bool increment_total = true);\n+  G1AddCardResult add_to_container(Atomic<ContainerPtr>* container_addr, ContainerPtr container, uint card_region, uint card, bool increment_total = true);\n@@ -305,1 +306,1 @@\n-  G1AddCardResult add_to_inline_ptr(ContainerPtr volatile* container_addr, ContainerPtr container, uint card_in_region);\n+  G1AddCardResult add_to_inline_ptr(Atomic<ContainerPtr>* container_addr, ContainerPtr container, uint card_in_region);\n@@ -369,1 +370,0 @@\n-  static G1CardSetCoarsenStats coarsen_stats();\n@@ -415,2 +415,9 @@\n-  uint volatile _num_occupied;\n-  ContainerPtr volatile _container;\n+  Atomic<uint> _num_occupied;\n+  Atomic<ContainerPtr> _container;\n+\n+  \/\/ Copy constructor needed for use in ConcurrentHashTable.\n+  G1CardSetHashTableValue(const G1CardSetHashTableValue& other) :\n+    _region_idx(other._region_idx),\n+    _num_occupied(other._num_occupied.load_relaxed()),\n+    _container(other._container.load_relaxed())\n+  { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -70,1 +70,1 @@\n-  ContainerPtr volatile * _value_addr;\n+  Atomic<ContainerPtr>* _value_addr;\n@@ -106,1 +106,1 @@\n-  G1CardSetInlinePtr(ContainerPtr volatile* value_addr, ContainerPtr value) : _value_addr(value_addr), _value(value) {\n+  G1CardSetInlinePtr(Atomic<ContainerPtr>* value_addr, ContainerPtr value) : _value_addr(value_addr), _value(value) {\n@@ -148,1 +148,1 @@\n-  uintptr_t _ref_count;\n+  Atomic<uintptr_t> _ref_count;\n@@ -154,1 +154,1 @@\n-  uintptr_t refcount() const { return AtomicAccess::load_acquire(&_ref_count); }\n+  uintptr_t refcount() const { return _ref_count.load_acquire(); }\n@@ -175,1 +175,1 @@\n-  EntryCountType volatile _num_entries;\n+  Atomic<EntryCountType> _num_entries;\n@@ -183,1 +183,1 @@\n-    EntryCountType volatile* _num_entries_addr;\n+    Atomic<EntryCountType>* _num_entries_addr;\n@@ -186,1 +186,1 @@\n-    G1CardSetArrayLocker(EntryCountType volatile* value);\n+    G1CardSetArrayLocker(Atomic<EntryCountType>* value);\n@@ -195,1 +195,1 @@\n-      AtomicAccess::release_store(_num_entries_addr, _local_num_entries);\n+      _num_entries_addr->release_store(_local_num_entries);\n@@ -216,1 +216,1 @@\n-  size_t num_entries() const { return _num_entries & EntryMask; }\n+  size_t num_entries() const { return _num_entries.load_relaxed() & EntryMask; }\n@@ -226,1 +226,1 @@\n-  size_t _num_bits_set;\n+  Atomic<size_t> _num_bits_set;\n@@ -239,1 +239,1 @@\n-  uint num_bits_set() const { return (uint)_num_bits_set; }\n+  uint num_bits_set() const { return (uint)_num_bits_set.load_relaxed(); }\n@@ -258,1 +258,1 @@\n-  EntryCountType volatile _num_entries;\n+  Atomic<EntryCountType> _num_entries;\n@@ -261,1 +261,1 @@\n-  ContainerPtr _buckets[1];\n+  Atomic<ContainerPtr> _buckets[1];\n@@ -271,1 +271,1 @@\n-  ContainerPtr const* buckets() const;\n+  Atomic<ContainerPtr> const* buckets() const;\n@@ -276,1 +276,1 @@\n-  ContainerPtr const* container_addr(EntryCountType index) const;\n+  Atomic<ContainerPtr> const* container_addr(EntryCountType index) const;\n@@ -278,1 +278,1 @@\n-  ContainerPtr* container_addr(EntryCountType index);\n+  Atomic<ContainerPtr>* container_addr(EntryCountType index);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    ContainerPtr old_value = AtomicAccess::cmpxchg(_value_addr, _value, new_value, memory_order_relaxed);\n+    ContainerPtr old_value = _value_addr->compare_exchange(_value, new_value, memory_order_relaxed);\n@@ -129,1 +129,1 @@\n-    uintptr_t ref_count = AtomicAccess::cmpxchg(&_ref_count, old_value, new_value);\n+    uintptr_t ref_count = _ref_count.compare_exchange(old_value, new_value);\n@@ -140,1 +140,1 @@\n-  return AtomicAccess::sub(&_ref_count, 2u);\n+  return _ref_count.sub_then_fetch(2u);\n@@ -152,1 +152,1 @@\n-inline G1CardSetArray::G1CardSetArrayLocker::G1CardSetArrayLocker(EntryCountType volatile* num_entries_addr) :\n+inline G1CardSetArray::G1CardSetArrayLocker::G1CardSetArrayLocker(Atomic<EntryCountType>* num_entries_addr) :\n@@ -155,1 +155,1 @@\n-  EntryCountType num_entries = AtomicAccess::load(_num_entries_addr) & EntryMask;\n+  EntryCountType num_entries = _num_entries_addr->load_relaxed() & EntryMask;\n@@ -157,3 +157,2 @@\n-    EntryCountType old_value = AtomicAccess::cmpxchg(_num_entries_addr,\n-                                                     num_entries,\n-                                                     (EntryCountType)(num_entries | LockBitMask));\n+    EntryCountType old_value = _num_entries_addr->compare_exchange(num_entries,\n+                                                                   (EntryCountType)(num_entries | LockBitMask));\n@@ -177,1 +176,1 @@\n-  assert(index < _num_entries, \"precondition\");\n+  assert(index < _num_entries.load_relaxed(), \"precondition\");\n@@ -192,1 +191,1 @@\n-  EntryCountType num_entries = AtomicAccess::load_acquire(&_num_entries) & EntryMask;\n+  EntryCountType num_entries = _num_entries.load_acquire() & EntryMask;\n@@ -226,1 +225,1 @@\n-  EntryCountType num_entries = AtomicAccess::load_acquire(&_num_entries) & EntryMask;\n+  EntryCountType num_entries = _num_entries.load_acquire() & EntryMask;\n@@ -238,1 +237,1 @@\n-  EntryCountType num_entries = AtomicAccess::load_acquire(&_num_entries) & EntryMask;\n+  EntryCountType num_entries = _num_entries.load_acquire() & EntryMask;\n@@ -259,1 +258,1 @@\n-  if (_num_bits_set >= threshold) {\n+  if (_num_bits_set.load_relaxed() >= threshold) {\n@@ -263,1 +262,1 @@\n-    AtomicAccess::inc(&_num_bits_set, memory_order_relaxed);\n+    _num_bits_set.add_then_fetch(1u, memory_order_relaxed);\n@@ -279,2 +278,2 @@\n-inline G1CardSetHowl::ContainerPtr const* G1CardSetHowl::container_addr(EntryCountType index) const {\n-  assert(index < _num_entries, \"precondition\");\n+inline Atomic<G1CardSetHowl::ContainerPtr> const* G1CardSetHowl::container_addr(EntryCountType index) const {\n+  assert(index < _num_entries.load_relaxed(), \"precondition\");\n@@ -284,2 +283,2 @@\n-inline G1CardSetHowl::ContainerPtr* G1CardSetHowl::container_addr(EntryCountType index) {\n-  return const_cast<ContainerPtr*>(const_cast<const G1CardSetHowl*>(this)->container_addr(index));\n+inline Atomic<G1CardSetHowl::ContainerPtr>* G1CardSetHowl::container_addr(EntryCountType index) {\n+  return const_cast<Atomic<ContainerPtr>*>(const_cast<const G1CardSetHowl*>(this)->container_addr(index));\n@@ -289,1 +288,1 @@\n-  return *container_addr(index);\n+  return (*container_addr(index)).load_relaxed();\n@@ -292,1 +291,1 @@\n-inline G1CardSetHowl::ContainerPtr const* G1CardSetHowl::buckets() const {\n+inline Atomic<G1CardSetHowl::ContainerPtr> const* G1CardSetHowl::buckets() const {\n@@ -294,1 +293,1 @@\n-  return reinterpret_cast<ContainerPtr const*>(ptr);\n+  return reinterpret_cast<Atomic<ContainerPtr> const*>(ptr);\n@@ -303,1 +302,1 @@\n-    *container_addr(i) = G1CardSetInlinePtr();\n+    container_addr(i)->store_relaxed(G1CardSetInlinePtr());\n@@ -313,2 +312,2 @@\n-  ContainerPtr* array_entry = container_addr(bucket);\n-  ContainerPtr container = AtomicAccess::load_acquire(array_entry);\n+  Atomic<ContainerPtr>* array_entry = container_addr(bucket);\n+  ContainerPtr container = array_entry->load_acquire();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -85,1 +86,1 @@\n-  G1CardSet::ContainerPtr value = G1CardSetInlinePtr();\n+  Atomic<G1CardSet::ContainerPtr> value{};\n@@ -89,1 +90,1 @@\n-      G1CardSetInlinePtr cards(&value, value);\n+      G1CardSetInlinePtr cards(&value, value.load_relaxed());\n@@ -94,1 +95,1 @@\n-      G1CardSetInlinePtr cards(&value, value);\n+      G1CardSetInlinePtr cards(&value, value.load_relaxed());\n@@ -100,1 +101,1 @@\n-    G1CardSetInlinePtr cards(value);\n+    G1CardSetInlinePtr cards(value.load_relaxed());\n@@ -106,1 +107,1 @@\n-    G1CardSetInlinePtr cards(&value, value);\n+    G1CardSetInlinePtr cards(&value, value.load_relaxed());\n@@ -113,1 +114,1 @@\n-    G1CardSetInlinePtr cards(&value, value);\n+    G1CardSetInlinePtr cards(&value, value.load_relaxed());\n@@ -120,1 +121,1 @@\n-    G1CardSetInlinePtr cards(value);\n+    G1CardSetInlinePtr cards(value.load_relaxed());\n@@ -126,1 +127,1 @@\n-    G1CardSetInlinePtr cards(value);\n+    G1CardSetInlinePtr cards(value.load_relaxed());\n@@ -134,1 +135,1 @@\n-    G1CardSetInlinePtr cards(value);\n+    G1CardSetInlinePtr cards(value.load_relaxed());\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSetContainers.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"}]}