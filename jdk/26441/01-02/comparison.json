{"files":[{"patch":"@@ -1214,14 +1214,15 @@\n-      \/\/ Recover symbolic info for method resolution.\n-      ciMethod* caller = jvms()->method();\n-      ciBytecodeStream iter(caller);\n-      iter.force_bci(jvms()->bci());\n-\n-      bool             not_used1;\n-      ciSignature*     not_used2;\n-      ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n-      ciKlass*         holder       = iter.get_declared_method_holder();\n-      if (orig_callee->is_method_handle_intrinsic()) {\n-        assert(_override_symbolic_info, \"required\");\n-        orig_callee = method();\n-        holder = method()->holder();\n-      }\n+      if (cg->callee_method() == nullptr) {\n+        \/\/ Recover symbolic info for method resolution.\n+        ciMethod* caller = jvms()->method();\n+        ciBytecodeStream iter(caller);\n+        iter.force_bci(jvms()->bci());\n+\n+        bool             not_used1;\n+        ciSignature*     not_used2;\n+        ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n+        ciKlass*         holder       = iter.get_declared_method_holder();\n+        if (orig_callee->is_method_handle_intrinsic()) {\n+          assert(_override_symbolic_info, \"required\");\n+          orig_callee = method();\n+          holder = method()->holder();\n+        }\n@@ -1229,1 +1230,1 @@\n-      ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n+        ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n@@ -1231,2 +1232,2 @@\n-      Node* receiver_node = in(TypeFunc::Parms);\n-      const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n+        Node* receiver_node = in(TypeFunc::Parms);\n+        const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n@@ -1234,8 +1235,5 @@\n-      int  not_used3;\n-      bool call_does_dispatch;\n-      ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n-                                                         call_does_dispatch, not_used3);  \/\/ out-parameters\n-      if (!call_does_dispatch) {\n-        ciMethod* old_callee = cg->callee_method();\n-        if (old_callee == nullptr || old_callee == callee) {\n-          \/\/ Register for late inlining.\n+        int  not_used3;\n+        bool call_does_dispatch;\n+        ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n+                                                           call_does_dispatch, not_used3);  \/\/ out-parameters\n+        if (!call_does_dispatch) {\n@@ -1243,9 +1241,0 @@\n-#ifdef ASSERT\n-        } else {\n-          \/\/ If callee has changed between inline attempts, check that it happens because of dynamic loading\n-          Dependencies* deps = phase->C->dependencies();\n-          MutexLocker ml(Compile_lock);\n-          deps->encode_content_bytes();\n-          assert(deps->validate_dependencies(phase->C->env()->task()) != Dependencies::end_marker,\n-          \"repeated inline attempt with different callee\");\n-#endif\n@@ -1253,0 +1242,3 @@\n+      }\n+      if (cg->callee_method() != nullptr) {\n+        \/\/ Register for late inlining.\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":26,"deletions":34,"binary":false,"changes":60,"status":"modified"}]}