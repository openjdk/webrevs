{"files":[{"patch":"@@ -472,0 +472,4 @@\n+  virtual ciMethod* callee_method() {\n+    return _callee;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  virtual ciMethod* callee_method() { ShouldNotReachHere(); }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1214,14 +1214,15 @@\n-      \/\/ Recover symbolic info for method resolution.\n-      ciMethod* caller = jvms()->method();\n-      ciBytecodeStream iter(caller);\n-      iter.force_bci(jvms()->bci());\n-\n-      bool             not_used1;\n-      ciSignature*     not_used2;\n-      ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n-      ciKlass*         holder       = iter.get_declared_method_holder();\n-      if (orig_callee->is_method_handle_intrinsic()) {\n-        assert(_override_symbolic_info, \"required\");\n-        orig_callee = method();\n-        holder = method()->holder();\n-      }\n+      if (cg->callee_method() == nullptr) {\n+        \/\/ Recover symbolic info for method resolution.\n+        ciMethod* caller = jvms()->method();\n+        ciBytecodeStream iter(caller);\n+        iter.force_bci(jvms()->bci());\n+\n+        bool             not_used1;\n+        ciSignature*     not_used2;\n+        ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n+        ciKlass*         holder       = iter.get_declared_method_holder();\n+        if (orig_callee->is_method_handle_intrinsic()) {\n+          assert(_override_symbolic_info, \"required\");\n+          orig_callee = method();\n+          holder = method()->holder();\n+        }\n@@ -1229,1 +1230,1 @@\n-      ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n+        ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n@@ -1231,2 +1232,2 @@\n-      Node* receiver_node = in(TypeFunc::Parms);\n-      const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n+        Node* receiver_node = in(TypeFunc::Parms);\n+        const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n@@ -1234,5 +1235,9 @@\n-      int  not_used3;\n-      bool call_does_dispatch;\n-      ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n-                                                         call_does_dispatch, not_used3);  \/\/ out-parameters\n-      if (!call_does_dispatch) {\n+        int  not_used3;\n+        bool call_does_dispatch;\n+        ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n+                                                           call_does_dispatch, not_used3);  \/\/ out-parameters\n+        if (!call_does_dispatch) {\n+          cg->set_callee_method(callee);\n+        }\n+      }\n+      if (cg->callee_method() != nullptr) {\n@@ -1240,1 +1245,0 @@\n-        cg->set_callee_method(callee);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":27,"deletions":23,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2106,0 +2106,1 @@\n+  bool should_stress = false;\n@@ -2113,0 +2114,6 @@\n+      if (should_stress_inlining()) {\n+        cg->call_node()->set_generator(cg);\n+        C->igvn_worklist()->push(cg->call_node());\n+        should_stress = true;\n+        break;\n+      }\n@@ -2141,1 +2148,1 @@\n-  assert(inlining_progress() || _late_inlines.length() == 0, \"no progress\");\n+  assert(should_stress || inlining_progress() || _late_inlines.length() == 0, \"no progress\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1097,1 +1097,2 @@\n-  bool should_delay_inlining() { return AlwaysIncrementalInline || (StressIncrementalInlining && (random() % 2) == 0); }\n+  bool should_stress_inlining() { return StressIncrementalInlining && (random() % 2) == 0; }\n+  bool should_delay_inlining() { return AlwaysIncrementalInline || should_stress_inlining(); }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}