{"files":[{"patch":"@@ -99,1 +99,2 @@\n-  notify_control_thread(ml, GCCause::_shenandoah_stop_vm);\n+  _requested_gc_cause = GCCause::_shenandoah_stop_vm;\n+  notify_cancellation(ml, GCCause::_shenandoah_stop_vm);\n@@ -142,2 +143,1 @@\n-  \/\/ Important: not all paths update the request.generation. This is intentional.\n-  \/\/ A degenerated cycle must use the same generation carried over from the previous request.\n+\n@@ -636,1 +636,3 @@\n-    notify_control_thread(cause);\n+    \/\/ GC should already be cancelled. Here we are just notifying the control thread to\n+    \/\/ wake up and handle the cancellation request, so we don't need to set _requested_gc_cause.\n+    notify_cancellation(cause);\n@@ -662,1 +664,1 @@\n-      notify_control_thread(ml, GCCause::_shenandoah_concurrent_gc);\n+      notify_cancellation(ml, GCCause::_shenandoah_concurrent_gc);\n@@ -702,1 +704,1 @@\n-void ShenandoahGenerationalControlThread::notify_control_thread(GCCause::Cause cause) {\n+void ShenandoahGenerationalControlThread::notify_cancellation(GCCause::Cause cause) {\n@@ -704,1 +706,1 @@\n-  notify_control_thread(ml, cause);\n+  notify_cancellation(ml, cause);\n@@ -707,4 +709,3 @@\n-void ShenandoahGenerationalControlThread::notify_control_thread(MonitorLocker& ml, GCCause::Cause cause) {\n-  assert(_control_lock.is_locked(), \"Request lock must be held here\");\n-  log_debug(gc, thread)(\"Notify control (%s): %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause));\n-  _requested_gc_cause = cause;\n+void ShenandoahGenerationalControlThread::notify_cancellation(MonitorLocker& ml, GCCause::Cause cause) {\n+  assert(_heap->cancelled_gc(), \"GC should already be cancelled\");\n+  log_debug(gc,thread)(\"Notify control (%s): %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -138,4 +138,2 @@\n-  \/\/ These notify the control thread after updating _requested_gc_cause and (optionally) _requested_generation.\n-  \/\/ Updating the requested generation is not necessary for allocation failures nor when stopping the thread.\n-  void notify_control_thread(GCCause::Cause cause);\n-  void notify_control_thread(MonitorLocker& ml, GCCause::Cause cause);\n+  \/\/ Takes the request lock and updates the requested cause and generation, then notifies the control thread.\n+  \/\/ The overloaded variant should be used when the _control_lock is already held.\n@@ -145,0 +143,5 @@\n+  \/\/ Notifies the control thread, but does not update the requested cause or generation.\n+  \/\/ The overloaded variant should be used when the _control_lock is already held.\n+  void notify_cancellation(GCCause::Cause cause);\n+  void notify_cancellation(MonitorLocker& ml, GCCause::Cause cause);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"}]}