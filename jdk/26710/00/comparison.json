{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -42,0 +43,2 @@\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n@@ -85,0 +88,5 @@\n+    private final ReentrantLock lock = new ReentrantLock();\n+    private volatile boolean closed;\n+    private volatile boolean stopped;\n+    private LocalStoppedListener localStoppedListener;\n+    private LocalClosedListener localClosedListener;\n@@ -328,3 +336,35 @@\n-        directoryStream.setChunkCompleteHandler(null);\n-        recording.close();\n-        directoryStream.close();\n+        try {\n+            lock.lock();\n+            if (closed) {\n+                return;\n+            }\n+            if (localStoppedListener != null) {\n+                FlightRecorder.removeListener(localStoppedListener);\n+            }\n+            if (localClosedListener != null) {\n+                FlightRecorder.removeListener(localClosedListener);\n+            }\n+            recording.close();\n+            closeInternal();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeInternal() {\n+        final boolean isHeldByCurrentThread = lock.isHeldByCurrentThread();\n+        try {\n+            if (!isHeldByCurrentThread) {\n+                lock.lock();\n+            }\n+            if (closed) {\n+                return;\n+            }\n+            directoryStream.setChunkCompleteHandler(null);\n+            directoryStream.close();\n+            closed = true;\n+        } finally {\n+            if (!isHeldByCurrentThread) {\n+                lock.unlock();\n+            }\n+        }\n@@ -342,0 +382,4 @@\n+        this.localStoppedListener = new LocalStoppedListener(pr.getId(), this);\n+        this.localClosedListener = new LocalClosedListener(pr.getId(), this);\n+        FlightRecorder.addListener(localStoppedListener);\n+        FlightRecorder.addListener(localClosedListener);\n@@ -365,0 +409,4 @@\n+        this.localStoppedListener = new LocalStoppedListener(pr.getId(), this);\n+        this.localClosedListener = new LocalClosedListener(pr.getId(), this);\n+        FlightRecorder.addListener(localStoppedListener);\n+        FlightRecorder.addListener(localClosedListener);\n@@ -392,1 +440,0 @@\n-        boolean stopped = false;\n@@ -394,4 +441,3 @@\n-            try (StreamBarrier sb = directoryStream.activateStreamBarrier()) {\n-                stopped = recording.stop();\n-                directoryStream.setCloseOnComplete(false);\n-                sb.setStreamEnd(recording.getStopTime().toEpochMilli());\n+            lock.lock();\n+            if (stopped) {\n+                return true;\n@@ -399,0 +445,5 @@\n+            if (localStoppedListener != null) {\n+                FlightRecorder.removeListener(localStoppedListener);\n+            }\n+            recording.stop();\n+            stopInternal(recording.getStopTime().toEpochMilli());\n@@ -400,1 +451,1 @@\n-        } catch (InterruptedException | IOException e) {\n+        } catch (InterruptedException e) {\n@@ -402,0 +453,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -406,0 +459,22 @@\n+    private void stopInternal(long stopTime) {\n+        final boolean isHeldByCurrentThread = lock.isHeldByCurrentThread();\n+        try {\n+            if (!isHeldByCurrentThread) {\n+                lock.lock();\n+            }\n+            if (stopped) {\n+                return;\n+            }\n+            try (StreamBarrier sb = directoryStream.activateStreamBarrier()) {\n+                directoryStream.setCloseOnComplete(false);\n+                sb.setStreamEnd(stopTime);\n+                stopped = true;\n+            } catch (Exception e) {\n+            }\n+        } finally {\n+            if (!isHeldByCurrentThread) {\n+                lock.unlock();\n+            }\n+        }\n+    }\n+\n@@ -484,0 +559,42 @@\n+\n+    static final class LocalStoppedListener implements FlightRecorderListener {\n+\n+        private final long recordingId;\n+        private final RecordingStream recordingStream;\n+\n+        public LocalStoppedListener(long recordingId, RecordingStream recordingStream) {\n+            this.recordingId = recordingId;\n+            this.recordingStream = recordingStream;\n+        }\n+\n+        @Override\n+        public void recordingStateChanged(Recording recording) {\n+            if (this.recordingId != recording.getId()) {\n+                return;\n+            }\n+            if (recording.getState() == RecordingState.STOPPED) {\n+                recordingStream.stopInternal(recording.getStopTime().toEpochMilli());\n+            }\n+        }\n+    }\n+\n+    static final class LocalClosedListener implements FlightRecorderListener {\n+\n+        private final long recordingId;\n+        private final RecordingStream recordingStream;\n+\n+        public LocalClosedListener(long recordingId, RecordingStream recordingStream) {\n+            this.recordingId = recordingId;\n+            this.recordingStream = recordingStream;\n+        }\n+\n+        @Override\n+        public void recordingStateChanged(Recording recording) {\n+            if (this.recordingId != recording.getId()) {\n+                return;\n+            }\n+            if (recording.getState() == RecordingState.CLOSED) {\n+                recordingStream.closeInternal();\n+            }\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":126,"deletions":9,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.jfr.RecordingState;\n@@ -184,7 +183,0 @@\n-                if (isRecordingStream()) {\n-                    if (recording.getState() == RecordingState.STOPPED && !barrier.used()) {\n-                        logStreamEnd(\"recording stopped externally.\");\n-                        return;\n-                    }\n-                }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.nio.channels.FileChannel;\n@@ -33,2 +32,0 @@\n-import java.nio.file.Paths;\n-import java.nio.file.StandardOpenOption;\n@@ -43,1 +40,1 @@\n-import java.util.concurrent.Future;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -45,0 +42,2 @@\n+import javax.management.AttributeChangeNotification;\n+import javax.management.InstanceNotFoundException;\n@@ -46,0 +45,1 @@\n+import javax.management.ListenerNotFoundException;\n@@ -47,0 +47,2 @@\n+import javax.management.Notification;\n+import javax.management.NotificationListener;\n@@ -48,0 +50,1 @@\n+import javax.management.openmbean.CompositeData;\n@@ -57,1 +60,0 @@\n-import jdk.jfr.consumer.RecordingStream;\n@@ -61,1 +63,0 @@\n-import jdk.management.jfr.DiskRepository.DiskChunk;\n@@ -153,1 +154,1 @@\n-    final Object lock = new Object();\n+    private final ReentrantLock lock = new ReentrantLock();\n@@ -157,0 +158,1 @@\n+    volatile boolean stopped;\n@@ -161,0 +163,3 @@\n+    private final MBeanServerConnection connection;\n+    private RemoteStoppedListener remoteStoppedListener;\n+    private RemoteClosedListener remoteClosedListener;\n@@ -214,0 +219,1 @@\n+        this.connection = connection;\n@@ -330,1 +336,1 @@\n-    };\n+    }\n@@ -399,1 +405,2 @@\n-        synchronized (lock) {\n+        try {\n+            lock.lock();\n@@ -403,0 +410,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -429,1 +438,2 @@\n-        synchronized (lock) {\n+        try {\n+            lock.lock();\n@@ -433,0 +443,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -463,1 +475,2 @@\n-        synchronized (lock) { \/\/ ensure one closer\n+        try {\n+            lock.lock();\n@@ -467,8 +480,11 @@\n-            closed = true;\n-        }\n-        ManagementSupport.setOnChunkCompleteHandler(stream, null);\n-        stream.close();\n-        try {\n-            mbean.closeRecording(recordingId);\n-        } catch (IOException e) {\n-            ManagementSupport.logDebug(e.getMessage());\n+            closeInternal();\n+            try {\n+                if (remoteClosedListener != null) {\n+                    connection.removeNotificationListener(OBJECT_NAME, remoteClosedListener);\n+                }\n+                mbean.closeRecording(recordingId);\n+            } catch (InstanceNotFoundException | ListenerNotFoundException | IOException e) {\n+                ManagementSupport.logDebug(e.getMessage());\n+            }\n+        } finally {\n+            lock.unlock();\n@@ -476,0 +492,4 @@\n+    }\n+\n+    private void closeInternal() {\n+        final boolean isHeldByCurrentThread = lock.isHeldByCurrentThread();\n@@ -477,3 +497,18 @@\n-            repository.close();\n-        } catch (IOException e) {\n-            ManagementSupport.logDebug(e.getMessage());\n+            if (!isHeldByCurrentThread) {\n+                lock.lock();\n+            }\n+            if (closed) {\n+                return;\n+            }\n+            ManagementSupport.setOnChunkCompleteHandler(stream, null);\n+            stream.close();\n+            try {\n+                repository.close();\n+            } catch (IOException e) {\n+                ManagementSupport.logDebug(e.getMessage());\n+            }\n+            closed = true;\n+        } finally {\n+            if (!isHeldByCurrentThread) {\n+                lock.unlock();\n+            }\n@@ -515,0 +550,4 @@\n+                this.remoteStoppedListener = new RemoteStoppedListener(recordingId, this);\n+                this.remoteClosedListener = new RemoteClosedListener(recordingId, this);\n+                connection.addNotificationListener(OBJECT_NAME, remoteStoppedListener, null, null);\n+                connection.addNotificationListener(OBJECT_NAME, remoteClosedListener, null, null);\n@@ -533,0 +572,4 @@\n+            this.remoteStoppedListener = new RemoteStoppedListener(recordingId, this);\n+            this.remoteClosedListener = new RemoteClosedListener(recordingId, this);\n+            connection.addNotificationListener(OBJECT_NAME, remoteStoppedListener, null, null);\n+            connection.addNotificationListener(OBJECT_NAME, remoteClosedListener, null, null);\n@@ -578,1 +621,2 @@\n-        synchronized (lock) {\n+        try {\n+            lock.lock();\n@@ -586,9 +630,2 @@\n-                boolean stopped = false;\n-                try (StreamBarrier pb = ManagementSupport.activateStreamBarrier(stream)) {\n-                    try (StreamBarrier rb = repository.activateStreamBarrier()) {\n-                        stopped = mbean.stopRecording(recordingId);\n-                        ManagementSupport.setCloseOnComplete(stream, false);\n-                        long stopTime = getRecordingInfo(mbean.getRecordings(), recordingId).getStopTime();\n-                        pb.setStreamEnd(stopTime);\n-                        rb.setStreamEnd(stopTime);\n-                    }\n+                if (remoteStoppedListener != null) {\n+                    connection.removeNotificationListener(OBJECT_NAME, remoteStoppedListener);\n@@ -596,0 +633,4 @@\n+                stopped = mbean.stopRecording(this.recordingId);\n+                RecordingInfo recordingInfo = mbean.getRecordings().stream().filter(r -> r.getId() == this.recordingId).findFirst().get();\n+                long stopTime = recordingInfo.getStopTime();\n+                stopInternal(stopTime);\n@@ -606,0 +647,27 @@\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public boolean stopInternal(long stopTime) {\n+        final boolean isHeldByCurrentThread = lock.isHeldByCurrentThread();\n+        try {\n+            if (!isHeldByCurrentThread) {\n+                lock.lock();\n+            }\n+            boolean stopped = false;\n+            try (StreamBarrier pb = ManagementSupport.activateStreamBarrier(stream)) {\n+                try (StreamBarrier rb = repository.activateStreamBarrier()) {\n+                    ManagementSupport.setCloseOnComplete(stream, false);\n+                    pb.setStreamEnd(stopTime);\n+                    rb.setStreamEnd(stopTime);\n+                }\n+            }\n+            return stopped;\n+        } catch (Exception e) {\n+            ManagementSupport.logDebug(e.getMessage());\n+            return false;\n+        } finally {\n+            if (!isHeldByCurrentThread) {\n+                lock.unlock();\n+            }\n@@ -610,1 +678,2 @@\n-        synchronized (lock) {\n+        try {\n+            lock.lock();\n@@ -618,0 +687,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -645,1 +716,2 @@\n-            synchronized (lock) { \/\/ ensure running state while preparing dump\n+            try {\n+                lock.lock(); \/\/ ensure running state while preparing dump\n@@ -659,0 +731,2 @@\n+            } finally {\n+                lock.unlock();\n@@ -720,0 +794,77 @@\n+\n+    static final class RemoteStoppedListener implements NotificationListener {\n+\n+        private final long recordingId;\n+        private final RemoteRecordingStream stream;\n+\n+        public RemoteStoppedListener(long recordingId, RemoteRecordingStream stream) {\n+            this.recordingId = recordingId;\n+            this.stream = stream;\n+        }\n+\n+        @Override\n+        public void handleNotification(Notification notification, Object handback) {\n+            if (notification instanceof AttributeChangeNotification acn) {\n+                CompositeData[] newVal = (CompositeData[]) acn.getNewValue();\n+                CompositeData[] oldVal = (CompositeData[]) acn.getOldValue();\n+                CompositeData newRecording = getRecording(newVal, recordingId);\n+                CompositeData oldRecording = getRecording(oldVal, recordingId);\n+                if (oldRecording == null || newRecording == null) {\n+                    return;\n+                }\n+                String newState = (String) newRecording.get(\"state\");\n+                if (newState.equals(oldRecording.get(\"state\"))) {\n+                    return;\n+                }\n+                if (newState.equals(RecordingState.STOPPED.name())) {\n+                    stream.stopInternal((long) newRecording.get(\"stopTime\"));\n+                }\n+            }\n+        }\n+    }\n+\n+    static class RemoteClosedListener implements NotificationListener {\n+\n+        private final long recordingId;\n+        private final RemoteRecordingStream remoteRecordingStream;\n+\n+        public RemoteClosedListener(long recordingId, RemoteRecordingStream remoteRecordingStream) {\n+            this.recordingId = recordingId;\n+            this.remoteRecordingStream = remoteRecordingStream;\n+        }\n+\n+        @Override\n+        public void handleNotification(Notification notification, Object handback) {\n+            if (notification instanceof AttributeChangeNotification acn) {\n+                CompositeData[] newVal = (CompositeData[]) acn.getNewValue();\n+                CompositeData[] oldVal = (CompositeData[]) acn.getOldValue();\n+                CompositeData newRecording = getRecording(newVal, recordingId);\n+                CompositeData oldRecording = getRecording(oldVal, recordingId);\n+                if (oldRecording == null) {\n+                    return;\n+                }\n+                if (newRecording == null) {\n+                    if (!oldRecording.get(\"state\").equals(RecordingState.CLOSED.name())) {\n+                        remoteRecordingStream.closeInternal();\n+                    }\n+                } else {\n+                    String newState = (String) newRecording.get(\"state\");\n+                    if (newState.equals(oldRecording.get(\"state\"))) {\n+                        return;\n+                    }\n+                    if (newState.equals(RecordingState.CLOSED.name())) {\n+                        remoteRecordingStream.closeInternal();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static CompositeData getRecording(CompositeData[] recordings, long id) {\n+        for (CompositeData r : recordings) {\n+            if (r.get(\"id\").equals(id)) {\n+                return r;\n+            }\n+        }\n+        return null;\n+    }\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/RemoteRecordingStream.java","additions":185,"deletions":34,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.consumer.recordingstream;\n+\n+import jdk.jfr.*;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * @test\n+ * @summary Tests that a RecordingStream is closed if the underlying Recording\n+ * is closed.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.api.consumer.recordingstream.TestClosedRecording\n+ *\/\n+public class TestClosedRecording {\n+\n+    private static class SendEventListener implements FlightRecorderListener {\n+        @Override\n+        public void recordingStateChanged(Recording recording) {\n+            if(recording.getState() == RecordingState.RUNNING){\n+                CloseEvent e = new CloseEvent();\n+                e.commit();\n+            }\n+        }\n+    }\n+\n+    private static final class CloseEvent extends Event {\n+    }\n+\n+    private static final Consumer<RecordedEvent> CLOSE_RECORDING = e -> {\n+        FlightRecorder.getFlightRecorder().getRecordings().getFirst().close();\n+    };\n+\n+    public static void main(String... args) throws Exception {\n+        FlightRecorder.addListener(new SendEventListener());\n+        sync();\n+        async();\n+    }\n+\n+    private static void sync() throws Exception {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.onEvent(CLOSE_RECORDING);\n+            rs.start();\n+        }\n+    }\n+\n+    private static void async() throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.onEvent(CLOSE_RECORDING);\n+            rs.onClose(() -> {\n+                latch.countDown();\n+            });\n+            rs.startAsync();\n+            latch.await();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestClosedRecording.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import java.util.concurrent.CountDownLatch;\n-\n@@ -30,0 +28,4 @@\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+import jdk.jfr.consumer.RecordedEvent;\n@@ -32,0 +34,3 @@\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n@@ -43,0 +48,10 @@\n+    private static class SendEventListener implements FlightRecorderListener {\n+        @Override\n+        public void recordingStateChanged(Recording recording) {\n+            if (recording.getState() == RecordingState.RUNNING) {\n+                StopEvent e = new StopEvent();\n+                e.commit();\n+            }\n+        }\n+    }\n+\n@@ -46,0 +61,9 @@\n+    private static final Consumer<RecordedEvent> STOP_RECORDING = e -> {\n+        List<Recording> recordings = FlightRecorder.getFlightRecorder().getRecordings().stream().filter(r -> r.getState() == RecordingState.RUNNING).toList();\n+        if (recordings.size() != 1) {\n+            throw new IllegalStateException(\"Expected one recording to be running\");\n+        }\n+        Recording r = recordings.getFirst();\n+        r.stop();\n+    };\n+\n@@ -47,1 +71,13 @@\n-        CountDownLatch latch = new CountDownLatch(1);\n+        FlightRecorder.addListener(new SendEventListener());\n+        sync();\n+        async();\n+    }\n+\n+    private static void sync() throws Exception {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.onEvent(STOP_RECORDING);\n+            rs.start();\n+        }\n+    }\n+\n+    private static void async() throws Exception {\n@@ -49,6 +85,1 @@\n-            rs.onEvent(e -> {\n-                FlightRecorder.getFlightRecorder().getRecordings().getFirst().stop();\n-            });\n-            rs.onClose(() -> {\n-                latch.countDown();\n-            });\n+            rs.onEvent(STOP_RECORDING);\n@@ -56,3 +87,2 @@\n-            StopEvent stop = new StopEvent();\n-            stop.commit();\n-            latch.await();\n+            rs.awaitTermination();\n+            rs.stop();\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestStoppedRecording.java","additions":43,"deletions":13,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jmx.streaming;\n+\n+import jdk.jfr.*;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.management.jfr.RemoteRecordingStream;\n+\n+import javax.management.MBeanServerConnection;\n+import java.lang.management.ManagementFactory;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * @test\n+ * @summary Tests that a RemoteRecordingStream is closed if the underlying remote recording is closed.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @build jdk.jfr.api.consumer.recordingstream.EventProducer\n+ * @run main\/othervm jdk.jfr.jmx.streaming.TestClosedRecording\n+ *\/\n+public class TestClosedRecording {\n+\n+    private static class SendEventListener implements FlightRecorderListener {\n+        @Override\n+        public void recordingStateChanged(Recording recording) {\n+            if(recording.getState() == RecordingState.RUNNING){\n+                CloseEvent e = new CloseEvent();\n+                e.commit();\n+            }\n+        }\n+    }\n+\n+    private static final class CloseEvent extends Event {\n+    }\n+\n+    private static final Consumer<RecordedEvent> CLOSE_RECORDING = e -> {\n+        FlightRecorder.getFlightRecorder().getRecordings().getFirst().close();\n+    };\n+\n+    private static final MBeanServerConnection CONNECTION = ManagementFactory.getPlatformMBeanServer();\n+\n+    public static void main(String... args) throws Exception {\n+        FlightRecorder.addListener(new SendEventListener());\n+        sync();\n+        async();\n+    }\n+\n+    private static void sync() throws Exception {\n+        try (RemoteRecordingStream rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.onEvent(CLOSE_RECORDING);\n+            rs.start();\n+        }\n+    }\n+\n+    private static void async() throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try (RemoteRecordingStream rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.onEvent(CLOSE_RECORDING);\n+            rs.onClose(() -> {\n+                latch.countDown();\n+            });\n+            rs.startAsync();\n+            latch.await();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestClosedRecording.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jmx.streaming;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.management.jfr.RemoteRecordingStream;\n+\n+import javax.management.MBeanServerConnection;\n+import java.lang.management.ManagementFactory;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * @test\n+ * @summary Tests that a RemoteRecordingStream is closed if the underlying Remote Recording is stopped.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @build jdk.jfr.api.consumer.recordingstream.EventProducer\n+ * @run main\/othervm jdk.jfr.jmx.streaming.TestStoppedRecording\n+ *\/\n+public class TestStoppedRecording {\n+\n+    private static class SendEventListener implements FlightRecorderListener {\n+        @Override\n+        public void recordingStateChanged(Recording recording) {\n+            if (recording.getState() == RecordingState.RUNNING) {\n+                StopEvent e = new StopEvent();\n+                e.commit();\n+                System.out.println(\"StopEvent committed\");\n+            }\n+        }\n+    }\n+\n+    private static final class StopEvent extends Event {\n+    }\n+\n+    private static final Consumer<RecordedEvent> STOP_RECORDING = e -> {\n+        FlightRecorder.getFlightRecorder().getRecordings().getFirst().stop();\n+        System.out.println(\"stopped\");\n+    };\n+    private static final MBeanServerConnection CONNECTION = ManagementFactory.getPlatformMBeanServer();\n+\n+    public static void main(String... args) throws Exception {\n+        FlightRecorder.addListener(new SendEventListener());\n+        sync();\n+        async();\n+    }\n+\n+    private static void sync() throws Exception {\n+        try (RemoteRecordingStream rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.onEvent(STOP_RECORDING);\n+            rs.start();\n+        }\n+    }\n+\n+    private static void async() throws Exception {\n+        try (RemoteRecordingStream rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.onEvent(STOP_RECORDING);\n+            rs.startAsync();\n+            rs.awaitTermination();\n+            rs.stop();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestStoppedRecording.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}