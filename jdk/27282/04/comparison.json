{"files":[{"patch":"@@ -95,0 +95,1 @@\n+  compiler\/gallery \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,554 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.gallery;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.JFrame;\n+\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Color;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBufferInt;\n+import java.io.IOException;\n+import java.util.Random;\n+import javax.swing.JPanel;\n+import java.awt.Font;\n+\n+import java.net.URL;\n+import java.net.URISyntaxException;\n+import java.io.File;\n+import java.util.Arrays;\n+\n+\/**\n+ * I presented this demo at the JVMLS 2025 conference, when giving\n+ * a talk about Auto-Vectorization in HotSpot, see:\n+ *   https:\/\/inside.java\/2025\/08\/16\/jvmls-hotspot-auto-vectorization\/\n+ *\n+ * This is a stand-alone test that you can run directly with:\n+ *   java NormalMapping.java\n+ *\n+ * If you want to disable the auto-vectorizer, you can run:\n+ *   java -XX:-UseSuperWord NormalMapping.java\n+ *\n+ * On x86, you can also play with the UseAVX flag:\n+ *   java -XX:UseAVX=1 NormalMapping.java\n+ *\n+ * There is a JTREG test that automatically runs this demo,\n+ * see {@link TestNormalMapping}.\n+ *\n+ * My motivation for JVMLS 2025 was to present something that vectorizes\n+ * in an \"embarassingly parallel\" way. It should be something that C2's\n+ * SuperWord Auto Vectorizer could already do for many JDK releases,\n+ * and also has some visual appeal. I decided to use normal mapping, see:\n+ *   https:\/\/en.wikipedia.org\/wiki\/Normal_mapping\n+ *\n+ * At the conference, I only had the version that loads a normal map\n+ * from an image. I now also added some \"generated\" cases, which are\n+ * created from 2d height functions, and then converted to normal\n+ * maps. This allows us to show more \"surfaces\" without having to\n+ * store the images for all those cases.\n+ *\n+ * If you are interested in understanding the components, then look at these:\n+ * - computeLight: the normal mapping \"shader \/ kernel\".\n+ * - generateNormals \/ computeNormals: computing normals from height functions.\n+ * - nextNormals: add you own normal map png or height function.\n+ * - main: setup and endless-loop that triggers normals to be swapped periodically.\n+ * - MyDrawingPanel: drawing all the parts to the screen.\n+ *\/\n+public class NormalMapping {\n+    public static Random RANDOM = new Random();\n+\n+    \/\/ Increasing this number will make the demo slower.\n+    public static final int NUMBER_OF_LIGHTS = 5;\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Welcome to the Normal Mapping Demo!\");\n+        State state = new State(NUMBER_OF_LIGHTS);\n+\n+        \/\/ Set up a panel we can draw on, and put it in a window.\n+        System.out.println(\"Setting up Window...\");\n+        MyDrawingPanel panel = new MyDrawingPanel(state);\n+        JFrame frame = new JFrame(\"Normal Mapping Demo (Auto-Vectorization)\");\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setSize(2000, 1000);\n+        frame.add(panel);\n+        frame.setVisible(true);\n+        System.out.println(\"Running Demo...\");\n+\n+        try {\n+            \/\/ Tight loop where we redraw the panel as fast as possible.\n+            int count = 0;\n+            while (true) {\n+                Thread.sleep(1);\n+                state.update();\n+                panel.repaint();\n+                if (count++ > 500) {\n+                    count = 0;\n+                    state.nextNormals();\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+            System.out.println(\"Interrputed, terminating demo.\");\n+        } finally {\n+            System.out.println(\"Shut down demo.\");\n+            frame.setVisible(false);\n+            frame.dispose();\n+        }\n+    }\n+\n+    public static File getLocalFile(String name) {\n+        \/\/ If we are in JTREG IR testing mode, we have to get the path via system property,\n+        \/\/ if it is run in stand-alone that property is not available, and we can load\n+        \/\/ via getResource.\n+        System.out.println(\"Loading file: \" + name);\n+        String testSrc = System.getProperty(\"test.src\", null);\n+        System.out.println(\"System Property test.src: \" + testSrc);\n+        if (testSrc == null) {\n+            URL path = NormalMapping.class.getResource(name);\n+            System.out.println(\"  Loading via getResource: \" + path);\n+            try {\n+                return new File(path.toURI());\n+            } catch (URISyntaxException e) {\n+                throw new RuntimeException(\"Could not load: \", e);\n+            }\n+        } else {\n+            return new File(testSrc + \"\/\" + name);\n+        }\n+    }\n+\n+    public static BufferedImage loadImage(File file) {\n+        try {\n+            return ImageIO.read(file);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Could not load: \", e);\n+        }\n+    }\n+\n+    \/**\n+     * This class represents the lights that are located on the normal map,\n+     * move around randomyl, and shine their color of light on the scene.\n+     *\/\n+    public static class Light {\n+        public float x = 0.5f;\n+        public float y = 0.5f;\n+        private float dx;\n+        private float dy;\n+\n+        private float h;\n+        public float r;\n+        public float g;\n+        public float b;\n+\n+        Light() {\n+            this.h = RANDOM.nextFloat();\n+        }\n+\n+        \/\/ Random movement of the Light\n+        public void update() {\n+            \/\/ Random acceleration with dampening.\n+            dx *= 0.99;\n+            dy *= 0.99;\n+            dx += RANDOM.nextFloat() * 0.001 - 0.0005;\n+            dy += RANDOM.nextFloat() * 0.001 - 0.0005;\n+            x += dx;\n+            y += dy;\n+\n+            \/\/ Boounce off the walls.\n+            if (x < 0) { dx = +Math.abs(dx); }\n+            if (x > 1) { dx = -Math.abs(dx); }\n+            if (y < 0) { dy = +Math.abs(dy); }\n+            if (y > 1) { dy = -Math.abs(dy); }\n+\n+            \/\/ Rotate the hue -> gets us nice rainbow colors.\n+            h += 0.001 + RANDOM.nextFloat() * 0.0002;\n+            Color c = Color.getHSBColor(h, 1f, 1f);\n+            r = (1f \/ 256f) * c.getRed();\n+            g = (1f \/ 256f) * c.getGreen();\n+            b = (1f \/ 256f) * c.getBlue();\n+        }\n+    }\n+\n+    \/**\n+     * This class manages the state of the demo, including the lights,\n+     * arrays passed in and out of the normal map computation, as well\n+     * as the image buffers and FPS tracking.\n+     *\/\n+    public static class State {\n+        private static final int sizeX = 1000;\n+        private static final int sizeY = 1000;\n+\n+        public Light[] lights;\n+\n+        public float[] coordsX;\n+        public float[] coordsY;\n+\n+        private int nextNormalsId = 0;\n+        public BufferedImage normals;\n+        public float[] normalsX;\n+        public float[] normalsY;\n+        public float[] normalsZ;\n+\n+        public BufferedImage output;\n+        public BufferedImage output_2;\n+        public int[] outputRGB;\n+        public int[] outputRGB_2;\n+\n+        public long lastTime;\n+        public float fps;\n+\n+        float luminosityCorrection = 1f;\n+\n+        public State(int numberOfLights) {\n+            lights = new Light[numberOfLights];\n+            for (int i = 0; i < lights.length; i++) {\n+                lights[i] = new Light();\n+            }\n+\n+            \/\/ Coordinates\n+            this.coordsX = new float[sizeX * sizeY];\n+            this.coordsY = new float[sizeX * sizeY];\n+            for (int y = 0; y < sizeY; y++) {\n+                for (int x = 0; x < sizeX; x++) {\n+                    this.coordsX[y * sizeX + x] = x * (1f \/ sizeX);\n+                    this.coordsY[y * sizeX + x] = y * (1f \/ sizeY);\n+                }\n+            }\n+\n+            nextNormals();\n+\n+            \/\/ Double buffered output images, where we render to.\n+            \/\/ Without double buffering, we would get some flickering effects,\n+            \/\/ because we would be concurrently updating the buffer and drawing it.\n+            this.output   = new BufferedImage(sizeX, sizeY, BufferedImage.TYPE_INT_RGB);\n+            this.output_2 = new BufferedImage(sizeX, sizeY, BufferedImage.TYPE_INT_RGB);\n+            this.outputRGB   = ((DataBufferInt) output.getRaster().getDataBuffer()).getData();\n+            this.outputRGB_2 = ((DataBufferInt) output_2.getRaster().getDataBuffer()).getData();\n+\n+            \/\/ Set up the FPS tracker\n+            lastTime = System.nanoTime();\n+        }\n+\n+        public void nextNormals() {\n+            switch (nextNormalsId) {\n+                case 0 -> setNormals(loadNormals(\"normal_map.png\"));\n+                case 1 -> setNormals(generateNormals(\"heart\"));\n+                case 2 -> setNormals(generateNormals(\"hex\"));\n+                case 3 -> setNormals(generateNormals(\"cone\"));\n+                case 4 -> setNormals(generateNormals(\"ripple\"));\n+                case 5 -> setNormals(generateNormals(\"hill\"));\n+                case 6 -> setNormals(generateNormals(\"ripple2\"));\n+                case 7 -> setNormals(generateNormals(\"cones\"));\n+                case 8 -> setNormals(generateNormals(\"spheres\"));\n+                case 9 -> setNormals(generateNormals(\"donut\"));\n+                default -> throw new RuntimeException();\n+            }\n+            nextNormalsId = (nextNormalsId + 1) % 10;\n+        }\n+\n+        public BufferedImage loadNormals(String name) {\n+            \/\/ Extract normal values from RGB image\n+            \/\/ The loaded image may not have the desired INT_RGB format, so first convert it\n+            BufferedImage normalsLoaded = loadImage(getLocalFile(name));\n+            BufferedImage buf = new BufferedImage(sizeX, sizeY, BufferedImage.TYPE_INT_RGB);\n+            buf.getGraphics().drawImage(normalsLoaded, 0, 0, null);\n+            return buf;\n+        }\n+\n+        public void setNormals(BufferedImage buf) {\n+            this.normals = buf;\n+\n+            int[] normalsRGB = ((DataBufferInt) this.normals.getRaster().getDataBuffer()).getData();\n+            this.normalsX = new float[sizeX * sizeY];\n+            this.normalsY = new float[sizeX * sizeY];\n+            this.normalsZ = new float[sizeX * sizeY];\n+            for (int y = 0; y < sizeY; y++) {\n+                for (int x = 0; x < sizeX; x++) {\n+                    this.coordsY[y * sizeX + x] = y * (1f \/ sizeY);\n+                    int normal = normalsRGB[y * sizeX + x];\n+                    \/\/ RGB values in range [0 ... 255]\n+                    int nr = (normal >> 16) & 0xff;\n+                    int ng = (normal >>  8) & 0xff;\n+                    int nb = (normal >>  0) & 0xff;\n+\n+                    \/\/ Map range [0..255] -> [-1 .. 1]\n+                    float nx = ((float)nr) * (1f \/ 128f) - 1f;\n+                    float ny = ((float)ng) * (1f \/ 128f) - 1f;\n+                    float nz = ((float)nb) * (1f \/ 128f) - 1f;\n+\n+                    this.normalsX[y * sizeX + x] = -nx;\n+                    this.normalsY[y * sizeX + x] = ny;\n+                    this.normalsZ[y * sizeX + x] = nz;\n+                }\n+            }\n+        }\n+\n+        interface HeightFunction {\n+            \/\/ x and y should be in [0..1]\n+            double call(double x, double y);\n+        }\n+\n+        public BufferedImage generateNormals(String name) {\n+            System.out.println(\"  generate normals for: \" + name);\n+            return computeNormals((double x, double y) -> {\n+                \/\/ Scale out, so we see a little more\n+                x = 10 * (x - 0.5);\n+                y = 10 * (y - 0.5);\n+\n+                \/\/ A selection of \"height functions\":\n+                return switch (name) {\n+                    case \"cone\" -> 0.1 * Math.max(0, 2 - Math.sqrt(x * x + y * y));\n+                    case \"heart\" -> {\n+                        double heart = Math.abs(Math.pow(x * x + y * y - 1, 3) - x * x * Math.pow(-y, 3));\n+                        double decay = Math.exp(-(x * x + y * y));\n+                        yield 0.1 * heart * decay;\n+                    }\n+                    case \"hill\" ->    0.5 * Math.exp(-(x * x + y * y));\n+                    case \"ripple\" ->  0.01 * Math.sin(x * x + y * y);\n+                    case \"ripple2\" -> 0.3 * Math.sin(x) * Math.sin(y);\n+                    case \"donut\" -> {\n+                        double d = Math.sqrt(x * x + y * y) - 2;\n+                        double i = 1 - d*d;\n+                        yield (i >= 0) ? 0.1 * Math.sqrt(i) : 0;\n+                    }\n+                    case \"hex\" -> {\n+                        double f = 3.0;\n+                        double a = Math.cos(f * x);\n+                        double b = Math.cos(f * (-0.5 * x + Math.sqrt(3) \/ 2.0 * y));\n+                        double c = Math.cos(f * (-0.5 * x - Math.sqrt(3) \/ 2.0 * y));\n+                        yield 0.03 * (a + b + c);\n+                    }\n+                    case \"cones\" -> {\n+                        double scale = 2.0;\n+                        double r = 0.8;\n+                        double cx = scale * (Math.floor(x \/ scale) + 0.5);\n+                        double cy = scale * (Math.floor(y \/ scale) + 0.5);\n+                        double dx = x - cx;\n+                        double dy = y - cy;\n+                        double d = Math.sqrt(dx * dx + dy * dy);\n+                        yield 0.1 * Math.max(0, 0.8 - d);\n+                    }\n+                    case \"spheres\" -> {\n+                        double scale = 2.0;\n+                        double r = 0.8;\n+                        double cx = scale * (Math.floor(x \/ scale) + 0.5);\n+                        double cy = scale * (Math.floor(y \/ scale) + 0.5);\n+                        double dx = x - cx;\n+                        double dy = y - cy;\n+                        double d2 = dx * dx + dy * dy;\n+                        if (d2 <= r * r) {\n+                            yield 0.03 * Math.sqrt(r * r - d2);\n+                        }\n+                        yield 0.0;\n+                    }\n+                    default -> throw new RuntimeException(\"not supported: \" + name);\n+                };\n+            });\n+        }\n+\n+        public static BufferedImage computeNormals(HeightFunction fun) {\n+            BufferedImage out = new BufferedImage(1000, 1000, BufferedImage.TYPE_INT_RGB);\n+            int[] arr = ((DataBufferInt) out.getRaster().getDataBuffer()).getData();\n+            int sx = out.getWidth();\n+            int sy = out.getHeight();\n+\n+            double delta = 0.00001;\n+            double dxx = 1.0 \/ sx;\n+            double dyy = 1.0 \/ sy;\n+            for (int yy = 0; yy < sy; yy++) {\n+                int nStart = sy * yy;\n+                for (int xx = 0; xx < sx; xx++) {\n+                    double x = xx * dxx;\n+                    double y = yy * dyy;\n+\n+                    \/\/ Compute the partial derivatives in x and y direction;\n+                    double fdx = fun.call(x + delta, y) - fun.call(x - delta, y);\n+                    double fdy = fun.call(x, y + delta) - fun.call(x, y - delta);\n+                    \/\/ We can compute the normal from the cross product of:\n+                    \/\/\n+                    \/\/  df\/dx  x  df\/dy = [2*delta, 0, fdx]  x  [0, 2*delta, fdy]\n+                    \/\/                  = [0*fdy - fdx*2*delta, fdx*0 - 2*delta*fdy, 2*delta*2*delta - 0*0]\n+                    double nx = -fdx * 2 * delta;\n+                    double ny = -2 * delta * fdy;\n+                    double nz = 2 * delta * 2 * delta;\n+\n+                    \/\/ normalize\n+                    float dist = (float)Math.sqrt(nx * nx + ny * ny + nz * nz);\n+                    nx \/= dist;\n+                    ny \/= dist;\n+                    nz \/= dist;\n+\n+                    \/\/ Now transform [-1..1] -> [0..255]\n+                    int r = (int)(nx * 127f + 127f) & 0xff;\n+                    int g = (int)(ny * 127f + 127f) & 0xff;\n+                    int b = (int)(nz * 127f + 127f) & 0xff;\n+                    int c = (r << 16) + (g << 8) + b;\n+                    arr[nStart + xx] = c;\n+                }\n+            }\n+            return out;\n+        }\n+\n+        public void update() {\n+            long nowTime = System.nanoTime();\n+            float newFPS = 1e9f \/ (nowTime - lastTime);\n+            fps = 0.99f * fps + 0.01f * newFPS;\n+            lastTime = nowTime;\n+\n+            for (Light light : lights) {\n+                light.update();\n+            }\n+\n+            \/\/ Reset the buffer\n+            int[] outputArray = ((DataBufferInt) output.getRaster().getDataBuffer()).getData();\n+            Arrays.fill(outputArray, 0);\n+\n+            \/\/ Add in the contribution of each light\n+            for (Light l : lights) {\n+                computeLight(l);\n+            }\n+            computeLuminosityCorrection();\n+\n+            \/\/ Swap the buffers for double buffering.\n+            var outputTmp = output;\n+            output = output_2;\n+            output_2 = outputTmp;\n+\n+            var outputRGBTmp = outputRGB;\n+            outputRGB = outputRGB_2;\n+            outputRGB_2 = outputRGBTmp;\n+        }\n+\n+        public void computeLight(Light l) {\n+            for (int i = 0; i < outputRGB.length; i++) {\n+                float x = coordsX[i];\n+                float y = coordsY[i];\n+                float nx = normalsX[i];\n+                float ny = normalsY[i];\n+                float nz = normalsZ[i];\n+\n+                \/\/ Compute distance vector between the light and the pixel\n+                float dx = x - l.x;\n+                float dy = y - l.y;\n+                float dz = 0.2f; \/\/ how much the lights float above the scene\n+\n+                \/\/ Compute the distance (dot product of d with itself)\n+                float d2 = dx * dx + dy * dy + dz * dz;\n+                float d = (float)Math.sqrt(d2);\n+                float d3 = d * d2;\n+\n+                \/\/ Compute dot-product between distance and normal vector\n+                float dotProduct = nx * dx + ny * dy + nz * dz;\n+\n+                \/\/ If the dot-product is negative:\n+                \/\/   Light on wrong side -> 0\n+                \/\/ If the dot-product is positive:\n+                \/\/   There should be light normalize by distance (d), and divide by the\n+                \/\/   squared distance (d2) to have physically accurately decaying light.\n+                \/\/   Correct the luminosity so the RGB values are going to be close\n+                \/\/   to 255, but not over.\n+                float luminosity = Math.max(0, dotProduct \/ d3) * luminosityCorrection;\n+\n+                \/\/ Now we compute the color values that hopefully end up in the range\n+                \/\/ [0..255]. If the hack\/trick with luminosityCorrection fails, we may\n+                \/\/ occasionally go out of the range and generate an overflow in the masking.\n+                \/\/ This can lead to some funky visual artifacts around the lights, but it\n+                \/\/ is quite rare.\n+                \/\/\n+                \/\/ Feel free to play with the targetExposure below, and see if you can\n+                \/\/ observe the artefacts.\n+                int r = (int)(luminosity * l.r) & 0xff;\n+                int g = (int)(luminosity * l.g) & 0xff;\n+                int b = (int)(luminosity * l.b) & 0xff;\n+                int c = (r << 16) + (g << 8) + b;\n+                outputRGB[i] += c;\n+            }\n+        }\n+\n+        \/\/ This is a bit of a horrible hack, but it mostly works.\n+        \/\/ Essentially, it tries to solve the \"exposure\" problem:\n+        \/\/ It is hard to know how much light a pixel will receive at most, and\n+        \/\/ we have to convert this value to a byte [0..255] at some point.\n+        \/\/ If we chose the \"exposure\" too low, we get a very dark picture\n+        \/\/ that is not very exciting to look at. If we over-expose, then we\n+        \/\/ may overflow\/clip the range [0..255], leading to unpleasant visual\n+        \/\/ artifacts.\n+        public void computeLuminosityCorrection() {\n+            \/\/ Find maximum R, G, and B value.\n+            float maxR = 0;\n+            float maxG = 0;\n+            float maxB = 0;\n+            for (int i = 0; i < outputRGB.length; i++) {\n+                int c = outputRGB[i];\n+                int cr = (c >> 16) & 0xff;\n+                int cg = (c >>  8) & 0xff;\n+                int cb = (c >>  0) & 0xff;\n+\n+                maxR = Math.max(maxR, cr);\n+                maxG = Math.max(maxG, cg);\n+                maxB = Math.max(maxB, cb);\n+            }\n+\n+            float maxC = Math.max(Math.max(maxR, maxG), maxB);\n+\n+            \/\/ Correct the maximum value to be 230, so we are safely in range 0..255\n+            \/\/ Setting it instead to 255 will make the image brighter, but most likely\n+            \/\/ it will give you some funky artefacts.\n+            \/\/ Setting it to 100 will make the image darker.\n+            float targetExposure = 230f;\n+            luminosityCorrection *= targetExposure \/ maxC;\n+        }\n+    }\n+\n+    public static class MyDrawingPanel extends JPanel {\n+        private final State state;\n+\n+        public MyDrawingPanel(State state) {\n+            this.state = state;\n+        }\n+\n+        @Override\n+        protected void paintComponent(Graphics g) {\n+            super.paintComponent(g);\n+            Graphics2D g2d = (Graphics2D) g;\n+\n+            \/\/ Draw color output\n+            g2d.drawImage(state.output_2, 0, 0, null);\n+\n+            \/\/ Draw position of lights\n+            for (Light l : state.lights) {\n+                g2d.setColor(new Color(l.r, l.g, l.b));\n+                g2d.fillRect((int)(1000f * l.x) - 3, (int)(1000f * l.y) - 3, 6, 6);\n+            }\n+\n+            g2d.setColor(new Color(0, 0, 0));\n+            g2d.fillRect(0, 0, 150, 35);\n+            g2d.setColor(new Color(255, 255, 255));\n+            g2d.setFont(new Font(\"Consolas\", Font.PLAIN, 30));\n+            g2d.drawString(\"FPS: \" + (int)Math.floor(state.fps), 0, 30);\n+\n+            g2d.drawImage(state.normals, 1000, 0, null);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/gallery\/NormalMapping.java","additions":554,"deletions":0,"binary":false,"changes":554,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=ir\n+ * @bug 8367657\n+ * @summary Visual example of auto vectorization: normal mapping.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.gallery.TestNormalMapping ir\n+ *\/\n+\n+\/*\n+ * @test id=visual\n+ * @key headful\n+ * @library \/test\/lib \/\n+ * @run main compiler.gallery.TestNormalMapping visual\n+ *\/\n+\n+package compiler.gallery;\n+\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/**\n+ * This test is the JTREG version for automatic verification of the stand-alone\n+ * {@link NormalMapping}. If you just want to run the demo and play with it,\n+ * go look at the documentation in {@link NormalMapping}.\n+ * Here, we launch both a visual version that just runs for a few seconds, to see\n+ * that there are no crashes, but we don't do any specific verification.\n+ * We also have an IR test, that ensures that we get vectorization.\n+ *\/\n+public class TestNormalMapping {\n+    public static void main(String[] args) throws InterruptedException {\n+        String mode = args[0];\n+        System.out.println(\"Running JTREG test in mode: \" + mode);\n+\n+        switch(mode) {\n+            case \"ir\" -> runIR();\n+            case \"visual\" -> runVisual();\n+            default -> throw new RuntimeException(\"Unknown mode: \" + mode);\n+        }\n+    }\n+\n+    private static void runIR() {\n+        System.out.println(\"Testing with IR rules...\");\n+        String src = System.getProperty(\"test.src\", null);\n+        if (src == null) { throw new RuntimeException(\"Could not find test.src property.\"); }\n+        TestFramework.runWithFlags(\"-Dtest.src=\" + src,\n+                                   \"-XX:CompileCommand=inline,compiler.gallery.NormalMapping$State::update\",\n+                                   \"-XX:CompileCommand=inline,compiler.gallery.NormalMapping$State::computeLight\");\n+    }\n+\n+    private static void runVisual() throws InterruptedException {\n+        System.out.println(\"Testing with 2d Graphics (visual)...\");\n+\n+        \/\/ We will not do anything special here, just launch the application,\n+        \/\/ tell it to run for 10 second, interrupt it and let it shut down.\n+        Thread thread = new Thread() {\n+            public void run() {\n+                NormalMapping.main(null);\n+            }\n+        };\n+        thread.setDaemon(true);\n+        thread.start();\n+        Thread.sleep(Utils.adjustTimeout(10000)); \/\/ let demo run for 10 seconds\n+        thread.interrupt();\n+        Thread.sleep(Utils.adjustTimeout(1000)); \/\/ allow demo 1 second for shutdown\n+    }\n+\n+    \/\/ ---------------------- For the IR testing part only --------------------------------\n+    NormalMapping.State state = new NormalMapping.State(5);\n+\n+    @Test\n+    @Warmup(1000)\n+    @IR(counts = {IRNode.REPLICATE_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.REPLICATE_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.LOAD_VECTOR_F,   IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.SUB_VF,          IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.MUL_VF,          IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.ADD_VF,          IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.SQRT_VF,         IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.MAX_VF,          IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.VECTOR_CAST_F2I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.AND_VI,          IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.LSHIFT_VI,       IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private void testIR() {\n+        \/\/ This call should inline givne the CompileCommand above.\n+        state.update();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/gallery\/TestNormalMapping.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"filename":"test\/hotspot\/jtreg\/compiler\/gallery\/normal_map.png","binary":true,"status":"added"}]}