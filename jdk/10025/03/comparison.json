{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,89 @@\n+\n+\n+bool CompressedSparseDataReadStream::read_zero() {\n+  if (_buffer[_position] & (1 << (7 - _byte_pos))) {\n+    return 0; \/\/ not a zero data\n+  }\n+  if (++_byte_pos == 8) {\n+    _position++;\n+    _byte_pos = 0;\n+  }\n+  return 1;\n+}\n+\n+uint8_t CompressedSparseDataReadStream::read_byte_impl() {\n+  uint8_t b1 = _buffer[_position] << _byte_pos;\n+  uint8_t b2 = _buffer[++_position] >> (8 - _byte_pos);\n+  return b1 | b2;\n+}\n+\n+jint CompressedSparseDataReadStream::read_int() {\n+  if (read_zero()) {\n+    return 0;\n+  }\n+  \/\/ integer value encoded as a sequence of 1 to 5 bytes\n+  \/\/ - the most frequent case (0 < x < 64) is encoded in one byte\n+  \/\/ - the payload of the first byte is 6 bits, the payload of the following bytes is 7 bits\n+  \/\/ - the most significant bit in the first byte is occupied by a zero flag\n+  \/\/ - each byte has a bit indicating whether it is the last byte in the sequence\n+  uint8_t b = read_byte_impl();\n+  juint result = b & 0x3f;\n+  for (int i = 0; (i == 0) ? (b & 0x40) : (b & 0x80); i++) {\n+    b = read_byte_impl();\n+    result |= ((b & 0x7f) << (6 + 7 * i));\n+  }\n+  return (jint)result;\n+}\n+\n+int CompressedSparseDataWriteStream::position() {\n+  if (_byte_pos == 0) {\n+    return _position;\n+  }\n+  \/\/ flush current data and start a new byte\n+  write(_curr_byte << (8 - _byte_pos));\n+  _curr_byte = 0;\n+  _byte_pos = 0;\n+  return _position;\n+}\n+\n+void CompressedSparseDataWriteStream::write_zero() {\n+  _curr_byte <<= 1; \/\/ zero bit represents a zero word\n+  if (++_byte_pos == 8) {\n+    write(_curr_byte);\n+    _curr_byte = 0;\n+    _byte_pos = 0;\n+  }\n+}\n+\n+void CompressedSparseDataWriteStream::write_byte_impl(uint8_t b) {\n+  write((_curr_byte << (8 - _byte_pos)) | (b >> _byte_pos));\n+  _curr_byte = (0xff >> (8 - _byte_pos)) & b;\n+}\n+\n+void CompressedSparseDataWriteStream::write_int(juint val) {\n+  if (val == 0) {\n+    write_zero();\n+    return;\n+  }\n+  int bit0 = 0x80; \/\/ first byte upper bit is set to indicate a value is not zero\n+  juint next = val >> 6;\n+  int bit1 = (next != 0) ? 0x40 : 0; \/\/ bit indicating a last byte\n+  write_byte_impl(bit0 | bit1 | (val & 0x3f));\n+  while (next != 0) {\n+    bit1 = (next >> 7) ? 0x80 : 0;\n+    write_byte_impl(bit1 | (next & 0x7f));\n+    next >>= 7;\n+  }\n+}\n+\n+void CompressedSparseDataWriteStream::grow() {\n+  int nsize = _size * 2;\n+  const int min_expansion = UNSIGNED5::MAX_LENGTH;\n+  if (nsize < min_expansion*2) {\n+    nsize = min_expansion*2;\n+  }\n+  u_char* _new_buffer = NEW_RESOURCE_ARRAY(u_char, nsize);\n+  memcpy(_new_buffer, _buffer, _position);\n+  _buffer = _new_buffer;\n+  _size   = nsize;\n+}\n","filename":"src\/hotspot\/share\/code\/compressedStream.cpp","additions":90,"deletions":1,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"utilities\/moveBits.hpp\"\n@@ -76,1 +77,1 @@\n-\n+\/\/ Pack200 compression algorithm\n@@ -114,0 +115,89 @@\n+class CompressedBitStream : public ResourceObj {\n+protected:\n+  u_char* _buffer;\n+  int     _position; \/\/ current byte offset\n+  size_t  _byte_pos {0}; \/\/ current bit offset\n+\n+public:\n+  CompressedBitStream(u_char* buffer = NULL, int position = 0) {\n+    _buffer   = buffer;\n+    _position = position;\n+  }\n+\n+  u_char* buffer() const { return _buffer; }\n+};\n+\n+\/\/ Modified compression algorithm for a data set in which a significant part of the data is null\n+class CompressedSparseDataReadStream : public CompressedBitStream {\n+public:\n+  CompressedSparseDataReadStream(u_char* buffer, int position) : CompressedBitStream(buffer, position) {}\n+\n+  void set_position(int pos) {\n+    _byte_pos = 0;\n+    _position = pos;\n+  }\n+\n+  jboolean read_bool()       { return read_int(); }\n+  jbyte    read_byte()       { return read_int(); }\n+  jint     read_signed_int() { return UNSIGNED5::decode_sign(read_int()); }\n+  jint     read_int();\n+  jdouble  read_double() {\n+    jint h = reverse_bits(read_int());\n+    jint l = reverse_bits(read_int());\n+    return jdouble_cast(jlong_from(h, l));\n+  }\n+  jlong    read_long() {\n+    jint low  = read_signed_int();\n+    jint high = read_signed_int();\n+    return jlong_from(high, low);\n+  }\n+\n+protected:\n+  bool read_zero();\n+  uint8_t read_byte_impl();\n+  inline u_char read()       { return _buffer[_position++]; }\n+};\n+\n+class CompressedSparseDataWriteStream : public CompressedBitStream {\n+public:\n+  CompressedSparseDataWriteStream(int initial_size) : CompressedBitStream() {\n+    _buffer   = NEW_RESOURCE_ARRAY(u_char, initial_size);\n+    _size     = initial_size;\n+  }\n+\n+  void write_bool(jboolean value)   { write_int(value ? 1 : 0); }\n+  void write_byte(jbyte value)      { write_int(value); }\n+  void write_signed_int(jint value) { write_int(UNSIGNED5::encode_sign(value)); }\n+  void write_int(juint value);\n+  void write_double(jdouble value)  {\n+    juint rh = reverse_bits(high(jlong_cast(value)));\n+    juint rl = reverse_bits(low( jlong_cast(value)));\n+    write_int(rh);\n+    write_int(rl);\n+  }\n+  void write_long(jlong value)      {\n+    write_signed_int(low(value));\n+    write_signed_int(high(value));\n+  }\n+\n+  int position(); \/\/ method have a side effect: the current byte becomes aligned\n+  void set_position(int pos) {\n+    position();\n+    _position = pos;\n+  }\n+protected:\n+  int    _size;\n+  u_char _curr_byte {0};\n+\n+  void grow();\n+  void write(u_char b) {\n+    if (_position >= _size) {\n+      grow();\n+    }\n+    _buffer[_position++] = b;\n+  }\n+\n+  void write_zero();  \/\/ The zero word is encoded with a single zero bit\n+  void write_byte_impl(uint8_t b);\n+};\n+\n","filename":"src\/hotspot\/share\/code\/compressedStream.hpp","additions":92,"deletions":2,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-: CompressedWriteStream(initial_size) {\n+: CompressedSparseDataWriteStream(initial_size) {\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-class DebugInfoReadStream : public CompressedReadStream {\n+class DebugInfoReadStream : public CompressedSparseDataReadStream {\n@@ -305,1 +305,1 @@\n-    CompressedReadStream(code->scopes_data_begin(), offset) {\n+    CompressedSparseDataReadStream(code->scopes_data_begin(), offset) {\n@@ -324,1 +324,1 @@\n-\/\/ DebugInfoWriteStream specializes CompressedWriteStream for\n+\/\/ DebugInfoWriteStream specializes CompressedSparseDataWriteStream for\n@@ -327,1 +327,1 @@\n-class DebugInfoWriteStream : public CompressedWriteStream {\n+class DebugInfoWriteStream : public CompressedSparseDataWriteStream {\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-  private short read() {\n+  protected short read() {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedReadStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.jvm.hotspot.code;\n+\n+import sun.jvm.hotspot.debugger.*;\n+\n+public class CompressedSparseDataReadStream extends CompressedReadStream {\n+\n+  public CompressedSparseDataReadStream(Address buffer, int position) {\n+    super(buffer, position);\n+    curr_byte_ = (byte) read();\n+  }\n+\n+  byte curr_byte_ = 0;\n+  int  byte_pos_  = 0;\n+\n+  public byte readByteImpl() {\n+    byte b = (byte) (curr_byte_ << byte_pos_);\n+    curr_byte_ = (byte) read();\n+    if (byte_pos_ > 0) {\n+      b |= (byte) ((0xFF & curr_byte_) >> (8 - byte_pos_));\n+    }\n+    return b;\n+  }\n+\n+  boolean readZero() {\n+    if (0 != (curr_byte_ & (1 << (7 - byte_pos_)))) {\n+      return false;\n+    }\n+    if (++byte_pos_ == 8) {\n+      byte_pos_ = 0;\n+      curr_byte_ = (byte) read();\n+    }\n+    return true;\n+  }\n+\n+  public int readInt() {\n+    if (readZero()) {\n+      return 0;\n+    }\n+    byte b = readByteImpl();\n+    int result = b & 0x3f;\n+    for (int i = 0; 0 != ((i == 0) ? (b & 0x40) : (b & 0x80)); i++) {\n+        b = readByteImpl();\n+        result |= ((b & 0x7f) << (6 + 7 * i));\n+    }\n+    return result;\n+  }\n+\n+  public boolean readBoolean() { return readInt() != 0; }\n+  public byte    readByte()    { return (byte) readInt(); }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedSparseDataReadStream.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-public class DebugInfoReadStream extends CompressedReadStream {\n+public class DebugInfoReadStream extends CompressedSparseDataReadStream {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/DebugInfoReadStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}