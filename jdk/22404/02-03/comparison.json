{"files":[{"patch":"@@ -938,50 +938,0 @@\n-\/\/ Builds a platform dependent Agent_OnLoad_<lib_name> function name\n-\/\/ which is used to find statically linked in agents.\n-\/\/ Parameters:\n-\/\/            sym_name: Symbol in library we are looking for\n-\/\/            lib_name: Name of library to look in, null for shared libs.\n-\/\/            is_absolute_path == true if lib_name is absolute path to agent\n-\/\/                                     such as \"\/a\/b\/libL.so\"\n-\/\/            == false if only the base name of the library is passed in\n-\/\/               such as \"L\"\n-char* os::build_agent_function_name(const char *sym_name, const char *lib_name,\n-                                    bool is_absolute_path) {\n-  char *agent_entry_name;\n-  size_t len = 0;\n-  size_t name_len = 0;\n-  size_t prefix_len = strlen(JNI_LIB_PREFIX);\n-  size_t suffix_len = strlen(JNI_LIB_SUFFIX);\n-  const char *start;\n-  bool need_underscore = false;\n-\n-  if (lib_name != nullptr) {\n-    if (is_absolute_path) {\n-      \/\/ Need to strip path, prefix and suffix\n-      if ((start = strrchr(lib_name, *os::file_separator())) != nullptr) {\n-        lib_name = ++start;\n-      }\n-      name_len = strlen(lib_name);\n-      if (name_len <= (prefix_len + suffix_len)) {\n-        return nullptr;\n-      }\n-      lib_name += prefix_len;\n-      name_len = strlen(lib_name) - suffix_len;\n-    } else {\n-      name_len = strlen(lib_name);\n-    }\n-    need_underscore = true;\n-  }\n-   \/\/ Total buffer length to allocate - includes null terminator.\n-  len = strlen(sym_name) + (need_underscore ? 1 : 0) + name_len + 1;\n-  agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);\n-  if (agent_entry_name == nullptr) {\n-    return nullptr;\n-  }\n-  strcpy(agent_entry_name, sym_name);\n-  if (lib_name != nullptr) {\n-    strcat(agent_entry_name, \"_\");\n-    strncat(agent_entry_name, lib_name, name_len);\n-  }\n-  return agent_entry_name;\n-}\n-\n@@ -2233,1 +2183,0 @@\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -5832,56 +5832,0 @@\n-\/\/ Builds a platform dependent Agent_OnLoad_<lib_name> function name\n-\/\/ which is used to find statically linked in agents.\n-\/\/ Parameters:\n-\/\/            sym_name: Symbol in library we are looking for\n-\/\/            lib_name: Name of library to look in, null for shared libs.\n-\/\/            is_absolute_path == true if lib_name is absolute path to agent\n-\/\/                                     such as \"C:\/a\/b\/L.dll\"\n-\/\/            == false if only the base name of the library is passed in\n-\/\/               such as \"L\"\n-char* os::build_agent_function_name(const char *sym_name, const char *lib_name,\n-                                    bool is_absolute_path) {\n-  char *agent_entry_name;\n-  size_t len = 0;\n-  size_t name_len = 0;\n-  size_t prefix_len = strlen(JNI_LIB_PREFIX);\n-  size_t suffix_len = strlen(JNI_LIB_SUFFIX);\n-  const char *start;\n-  bool need_underscore = false;\n-\n-  if (lib_name != nullptr) {\n-    if (is_absolute_path) {\n-      \/\/ Need to strip path, prefix and suffix\n-      if ((start = strrchr(lib_name, *os::file_separator())) != nullptr) {\n-        lib_name = ++start;\n-      } else {\n-        \/\/ Need to check for drive prefix\n-        if ((start = strchr(lib_name, ':')) != nullptr) {\n-          lib_name = ++start;\n-        }\n-      }\n-      name_len = strlen(lib_name);\n-      if (name_len <= (prefix_len + suffix_len)) {\n-        return nullptr;\n-      }\n-      lib_name += prefix_len;\n-      name_len = strlen(lib_name) - suffix_len;\n-    } else {\n-      name_len = strlen(lib_name);\n-    }\n-    need_underscore = true;\n-  }\n-  \/\/ Total buffer length to allocate - includes null terminator.\n-  len = strlen(sym_name) + (need_underscore ? 1 : 0) + name_len + 1;\n-  agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);\n-  if (agent_entry_name == nullptr) {\n-    return nullptr;\n-  }\n-\n-  strcpy(agent_entry_name, sym_name);\n-  if (lib_name != nullptr) {\n-    strcat(agent_entry_name, \"_\");\n-    strncat(agent_entry_name, lib_name, name_len);\n-  }\n-  return agent_entry_name;\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":56,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2479,0 +2479,59 @@\n+\n+\/\/ Builds a platform dependent Agent_OnLoad_<lib_name> function name\n+\/\/ which is used to find statically linked in agents.\n+\/\/ Parameters:\n+\/\/            sym_name: Symbol in library we are looking for\n+\/\/            lib_name: Name of library to look in, null for shared libs.\n+\/\/            is_absolute_path == true if lib_name is absolute path to agent\n+\/\/                                     such as \"C:\/a\/b\/L.dll\" or \"\/a\/b\/libL.so\"\n+\/\/            == false if only the base name of the library is passed in\n+\/\/               such as \"L\"\n+char* os::build_agent_function_name(const char *sym_name, const char *lib_name,\n+                                    bool is_absolute_path) {\n+  char *agent_entry_name;\n+  size_t len = 0;\n+  size_t name_len = 0;\n+  size_t prefix_len = strlen(JNI_LIB_PREFIX);\n+  size_t suffix_len = strlen(JNI_LIB_SUFFIX);\n+  size_t underscore_len = 0; \/\/ optional underscore if lib_name is set\n+  const char *start;\n+\n+\n+  if (lib_name != nullptr) {\n+    if (is_absolute_path) {\n+      \/\/ Need to strip path, prefix and suffix\n+      if ((start = strrchr(lib_name, *os::file_separator())) != nullptr) {\n+        lib_name = ++start;\n+      }\n+#ifdef WINDOWS\n+      else { \/\/ Need to check for drive prefix e.g. C:L.dll\n+        if ((start = strchr(lib_name, ':')) != nullptr) {\n+          lib_name = ++start;\n+        }\n+      }\n+#endif\n+      name_len = strlen(lib_name);\n+      if (name_len <= (prefix_len + suffix_len)) {\n+        return nullptr;\n+      }\n+      lib_name += prefix_len;\n+      name_len = strlen(lib_name) - suffix_len;\n+    } else {\n+      name_len = strlen(lib_name);\n+    }\n+    underscore_len = 1;\n+  }\n+  \/\/ Total buffer length to allocate - includes null terminator.\n+  len = strlen(sym_name) + underscore_len + name_len + 1;\n+  agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);\n+  if (agent_entry_name == nullptr) {\n+    return nullptr;\n+  }\n+\n+  strcpy(agent_entry_name, sym_name);\n+  if (lib_name != nullptr) {\n+    strcat(agent_entry_name, \"_\");\n+    strncat(agent_entry_name, lib_name, name_len);\n+  }\n+  return agent_entry_name;\n+}\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"}]}