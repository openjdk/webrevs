{"files":[{"patch":"@@ -113,6 +113,7 @@\n-            withToString(\"mask[i % 2]\", (int l) -> {\n-                boolean[] a = new boolean[l];\n-                for (int i = 0; i < l; i++) {\n-                    a[i] = (i % 2 == 0);\n-                }\n-                return a;\n+            withToString(\"mask[i % 2]\", (int s) -> {\n+                return fill_boolean(s,\n+                        i -> ((i % 2) == 0));\n+            }),\n+            withToString(\"mask[i % 5]\", (int s) -> {\n+                return fill_boolean(s,\n+                        i -> ((i % 5) == 0));\n@@ -120,0 +121,1 @@\n+\n@@ -125,1 +127,8 @@\n-            withToString(\"mask[false]\", boolean[]::new)\n+            withToString(\"mask[false]\", boolean[]::new),\n+            withToString(\"mask[random]\", (int l) -> {\n+                boolean[] a = new boolean[l];\n+                for (int i = 0; i < l; i++) {\n+                    a[i] = RAND.nextBoolean();\n+                }\n+                return a;\n+            })\n@@ -134,0 +143,20 @@\n+    static long[] pack_booleans_to_longs(boolean[] mask) {\n+        int totalLongs = (mask.length + 63) \/ 64; \/\/ ceil division\n+        long[] packed = new long[totalLongs];\n+        for (int i = 0; i < mask.length; i++) {\n+            int longIndex = i \/ 64;\n+            int bitIndex = i % 64;\n+            if (mask[i]) {\n+                packed[longIndex] |= 1L << bitIndex;\n+            }\n+        }\n+        return packed;\n+    }\n+\n+    static final List<IntFunction<long[]>> LONG_MASK_GENERATORS = BOOLEAN_MASK_GENERATORS.stream()\n+            .map(f -> withToString(\n+                    f.toString().replace(\"mask\", \"long_mask\"),\n+                    (IntFunction<long[]>) (int l) -> pack_booleans_to_longs(f.apply(l))\n+            ))\n+            .collect(Collectors.toList());\n+\n@@ -213,15 +242,0 @@\n-    interface FBooleanBinOp {\n-        boolean apply(boolean a, boolean b);\n-    }\n-\n-    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBooleanBinOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorTest.java","additions":36,"deletions":22,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1098,6 +1128,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1235,2 +1259,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4467,1 +4506,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4491,1 +4530,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6393,0 +6432,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandByte128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorByte128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorByte128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotByte128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqByte128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotByte128VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongByte128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6703,96 +6893,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte128VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte128VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte128VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte128VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsByte128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6801,1 +6897,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6803,5 +6898,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6809,1 +6907,0 @@\n-        assertArraysEquals(r, a, b, Byte128VectorTests::beq);\n@@ -6916,17 +7013,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongByte128VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1098,6 +1128,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1235,2 +1259,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4467,1 +4506,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4491,1 +4530,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6393,0 +6432,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandByte256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorByte256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorByte256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotByte256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqByte256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotByte256VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongByte256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6703,96 +6893,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte256VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte256VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte256VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte256VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsByte256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6801,1 +6897,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6803,5 +6898,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6809,1 +6907,0 @@\n-        assertArraysEquals(r, a, b, Byte256VectorTests::beq);\n@@ -6916,17 +7013,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongByte256VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1098,6 +1128,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1235,2 +1259,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4467,1 +4506,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4491,1 +4530,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6393,0 +6432,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandByte512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorByte512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorByte512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotByte512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqByte512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotByte512VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongByte512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6703,96 +6893,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte512VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte512VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte512VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte512VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsByte512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6801,1 +6897,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6803,5 +6898,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6809,1 +6907,0 @@\n-        assertArraysEquals(r, a, b, Byte512VectorTests::beq);\n@@ -6916,17 +7013,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongByte512VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1098,6 +1128,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1235,2 +1259,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4467,1 +4506,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4491,1 +4530,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6393,0 +6432,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandByte64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorByte64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorByte64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotByte64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqByte64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotByte64VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongByte64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6703,96 +6893,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte64VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte64VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte64VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte64VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsByte64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6801,1 +6897,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6803,5 +6898,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6809,1 +6907,0 @@\n-        assertArraysEquals(r, a, b, Byte64VectorTests::beq);\n@@ -6916,17 +7013,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongByte64VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -401,0 +401,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1103,6 +1133,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1240,2 +1264,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4472,1 +4511,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4496,1 +4535,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6398,0 +6437,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandByteMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorByteMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorByteMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotByteMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqByteMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotByteMaxVectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongByteMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6708,77 +6898,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ByteMaxVectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ByteMaxVectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ByteMaxVectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsByteMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6787,10 +6902,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ByteMaxVectorTests::bandNot);\n-    }\n@@ -6798,15 +6903,8 @@\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6814,1 +6912,0 @@\n-        assertArraysEquals(r, a, b, ByteMaxVectorTests::beq);\n@@ -6921,1 +7018,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":210,"deletions":114,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1190,6 +1220,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1294,2 +1318,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4809,0 +4848,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandDouble128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorDouble128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorDouble128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotDouble128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqDouble128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double128VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotDouble128VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Double128VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongDouble128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5098,20 +5288,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsDouble128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5120,14 +5292,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double128VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n@@ -5135,68 +5293,8 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double128VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double128VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double128VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5204,1 +5302,0 @@\n-        assertArraysEquals(r, a, b, Double128VectorTests::beq);\n@@ -5311,17 +5408,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongDouble128VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":208,"deletions":128,"binary":false,"changes":336,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1190,6 +1220,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1294,2 +1318,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4809,0 +4848,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandDouble256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorDouble256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorDouble256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotDouble256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqDouble256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double256VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotDouble256VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Double256VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongDouble256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5098,20 +5288,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsDouble256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5120,14 +5292,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double256VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n@@ -5135,68 +5293,8 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double256VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double256VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double256VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5204,1 +5302,0 @@\n-        assertArraysEquals(r, a, b, Double256VectorTests::beq);\n@@ -5311,17 +5408,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongDouble256VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":208,"deletions":128,"binary":false,"changes":336,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1190,6 +1220,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1294,2 +1318,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4809,0 +4848,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandDouble512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorDouble512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorDouble512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotDouble512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqDouble512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double512VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotDouble512VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Double512VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongDouble512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5098,20 +5288,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsDouble512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5120,14 +5292,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double512VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n@@ -5135,68 +5293,8 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double512VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double512VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double512VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5204,1 +5302,0 @@\n-        assertArraysEquals(r, a, b, Double512VectorTests::beq);\n@@ -5311,17 +5408,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongDouble512VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":208,"deletions":128,"binary":false,"changes":336,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1190,6 +1220,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1294,2 +1318,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4809,0 +4848,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandDouble64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorDouble64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorDouble64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotDouble64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqDouble64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double64VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotDouble64VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Double64VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongDouble64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5098,20 +5288,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsDouble64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5120,14 +5292,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double64VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n@@ -5135,68 +5293,8 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double64VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double64VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double64VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5204,1 +5302,0 @@\n-        assertArraysEquals(r, a, b, Double64VectorTests::beq);\n@@ -5311,17 +5408,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongDouble64VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":208,"deletions":128,"binary":false,"changes":336,"status":"modified"},{"patch":"@@ -419,0 +419,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1195,6 +1225,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1299,2 +1323,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4814,0 +4853,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandDoubleMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, DoubleMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorDoubleMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorDoubleMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotDoubleMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqDoubleMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, DoubleMaxVectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotDoubleMaxVectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, DoubleMaxVectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongDoubleMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5103,2 +5293,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsDoubleMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5108,100 +5298,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, DoubleMaxVectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5209,1 +5307,0 @@\n-        assertArraysEquals(r, a, b, DoubleMaxVectorTests::beq);\n@@ -5316,1 +5413,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":208,"deletions":112,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1201,6 +1231,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1305,2 +1329,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4778,0 +4817,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandFloat128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorFloat128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorFloat128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotFloat128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqFloat128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float128VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotFloat128VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Float128VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongFloat128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5077,20 +5267,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsFloat128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5099,14 +5271,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float128VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n@@ -5114,68 +5272,8 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float128VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float128VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float128VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5183,1 +5281,0 @@\n-        assertArraysEquals(r, a, b, Float128VectorTests::beq);\n@@ -5290,17 +5387,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongFloat128VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":208,"deletions":128,"binary":false,"changes":336,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1201,6 +1231,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1305,2 +1329,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4778,0 +4817,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandFloat256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorFloat256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorFloat256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotFloat256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqFloat256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float256VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotFloat256VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Float256VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongFloat256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5077,20 +5267,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsFloat256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5099,14 +5271,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float256VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n@@ -5114,68 +5272,8 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float256VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float256VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float256VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5183,1 +5281,0 @@\n-        assertArraysEquals(r, a, b, Float256VectorTests::beq);\n@@ -5290,17 +5387,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongFloat256VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":208,"deletions":128,"binary":false,"changes":336,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1201,6 +1231,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1305,2 +1329,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4778,0 +4817,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandFloat512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorFloat512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorFloat512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotFloat512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqFloat512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float512VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotFloat512VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Float512VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongFloat512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5077,20 +5267,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsFloat512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5099,14 +5271,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float512VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n@@ -5114,68 +5272,8 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float512VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float512VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float512VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5183,1 +5281,0 @@\n-        assertArraysEquals(r, a, b, Float512VectorTests::beq);\n@@ -5290,17 +5387,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongFloat512VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":208,"deletions":128,"binary":false,"changes":336,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1201,6 +1231,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1305,2 +1329,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4778,0 +4817,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandFloat64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorFloat64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorFloat64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotFloat64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqFloat64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float64VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotFloat64VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Float64VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongFloat64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5077,20 +5267,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsFloat64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5099,14 +5271,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float64VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n@@ -5114,68 +5272,8 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float64VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float64VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float64VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5183,1 +5281,0 @@\n-        assertArraysEquals(r, a, b, Float64VectorTests::beq);\n@@ -5290,17 +5387,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongFloat64VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":208,"deletions":128,"binary":false,"changes":336,"status":"modified"},{"patch":"@@ -419,0 +419,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1206,6 +1236,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1310,2 +1334,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4783,0 +4822,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandFloatMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, FloatMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorFloatMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, FloatMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorFloatMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, FloatMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotFloatMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, FloatMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqFloatMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, FloatMaxVectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotFloatMaxVectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, FloatMaxVectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongFloatMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5082,2 +5272,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsFloatMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5087,100 +5277,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, FloatMaxVectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, FloatMaxVectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, FloatMaxVectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, FloatMaxVectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5188,1 +5286,0 @@\n-        assertArraysEquals(r, a, b, FloatMaxVectorTests::beq);\n@@ -5295,1 +5392,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":208,"deletions":112,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1088,6 +1118,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1225,2 +1249,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4511,1 +4550,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4535,1 +4574,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6437,0 +6476,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandInt128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorInt128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorInt128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotInt128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqInt128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotInt128VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongInt128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6736,96 +6926,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int128VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int128VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int128VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int128VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsInt128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6834,1 +6930,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6836,5 +6931,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6842,1 +6940,0 @@\n-        assertArraysEquals(r, a, b, Int128VectorTests::beq);\n@@ -6949,17 +7046,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongInt128VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1088,6 +1118,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1225,2 +1249,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4511,1 +4550,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4535,1 +4574,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6437,0 +6476,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandInt256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorInt256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorInt256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotInt256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqInt256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotInt256VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongInt256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6736,96 +6926,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int256VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int256VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int256VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int256VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsInt256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6834,1 +6930,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6836,5 +6931,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6842,1 +6940,0 @@\n-        assertArraysEquals(r, a, b, Int256VectorTests::beq);\n@@ -6949,17 +7046,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongInt256VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1088,6 +1118,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1225,2 +1249,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4511,1 +4550,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4535,1 +4574,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6437,0 +6476,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandInt512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorInt512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorInt512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotInt512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqInt512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotInt512VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongInt512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6736,96 +6926,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int512VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int512VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int512VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int512VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsInt512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6834,1 +6930,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6836,5 +6931,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6842,1 +6940,0 @@\n-        assertArraysEquals(r, a, b, Int512VectorTests::beq);\n@@ -6949,17 +7046,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongInt512VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1088,6 +1118,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1225,2 +1249,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4511,1 +4550,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4535,1 +4574,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6437,0 +6476,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandInt64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorInt64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorInt64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotInt64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqInt64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotInt64VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongInt64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6736,96 +6926,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int64VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int64VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int64VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int64VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsInt64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6834,1 +6930,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6836,5 +6931,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6842,1 +6940,0 @@\n-        assertArraysEquals(r, a, b, Int64VectorTests::beq);\n@@ -6949,17 +7046,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongInt64VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -401,0 +401,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1093,6 +1123,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1230,2 +1254,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4516,1 +4555,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4540,1 +4579,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6442,0 +6481,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandIntMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorIntMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorIntMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotIntMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqIntMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotIntMaxVectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongIntMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6741,77 +6931,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, IntMaxVectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, IntMaxVectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, IntMaxVectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsIntMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6820,10 +6935,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, IntMaxVectorTests::bandNot);\n-    }\n@@ -6831,15 +6936,8 @@\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6847,1 +6945,0 @@\n-        assertArraysEquals(r, a, b, IntMaxVectorTests::beq);\n@@ -6954,1 +7051,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":210,"deletions":114,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -353,0 +353,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1078,6 +1108,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1222,2 +1246,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4533,1 +4572,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4557,1 +4596,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6389,0 +6428,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandLong128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorLong128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorLong128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotLong128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqLong128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotLong128VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6622,20 +6812,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsLong128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6644,10 +6816,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long128VectorTests::band);\n-    }\n@@ -6655,72 +6817,8 @@\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long128VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long128VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long128VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6728,1 +6826,0 @@\n-        assertArraysEquals(r, a, b, Long128VectorTests::beq);\n@@ -6835,17 +6932,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongLong128VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -353,0 +353,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1078,6 +1108,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1222,2 +1246,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4533,1 +4572,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4557,1 +4596,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6389,0 +6428,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandLong256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorLong256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorLong256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotLong256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqLong256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotLong256VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6622,20 +6812,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsLong256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6644,10 +6816,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long256VectorTests::band);\n-    }\n@@ -6655,72 +6817,8 @@\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long256VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long256VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long256VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6728,1 +6826,0 @@\n-        assertArraysEquals(r, a, b, Long256VectorTests::beq);\n@@ -6835,17 +6932,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongLong256VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -353,0 +353,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1078,6 +1108,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1222,2 +1246,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4533,1 +4572,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4557,1 +4596,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6389,0 +6428,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandLong512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorLong512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorLong512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotLong512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqLong512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotLong512VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6622,20 +6812,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsLong512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6644,10 +6816,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long512VectorTests::band);\n-    }\n@@ -6655,72 +6817,8 @@\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long512VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long512VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long512VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6728,1 +6826,0 @@\n-        assertArraysEquals(r, a, b, Long512VectorTests::beq);\n@@ -6835,17 +6932,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongLong512VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -353,0 +353,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1078,6 +1108,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1222,2 +1246,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4533,1 +4572,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4557,1 +4596,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6389,0 +6428,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandLong64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorLong64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorLong64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotLong64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqLong64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotLong64VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6622,20 +6812,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsLong64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6644,10 +6816,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long64VectorTests::band);\n-    }\n@@ -6655,72 +6817,8 @@\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long64VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long64VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long64VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6728,1 +6826,0 @@\n-        assertArraysEquals(r, a, b, Long64VectorTests::beq);\n@@ -6835,17 +6932,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongLong64VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -358,0 +358,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1083,6 +1113,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1227,2 +1251,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4538,1 +4577,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4562,1 +4601,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6394,0 +6433,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandLongMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorLongMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorLongMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotLongMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqLongMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotLongMaxVectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6627,2 +6817,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsLongMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6632,100 +6822,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, LongMaxVectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, LongMaxVectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, LongMaxVectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, LongMaxVectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6733,1 +6831,0 @@\n-        assertArraysEquals(r, a, b, LongMaxVectorTests::beq);\n@@ -6840,1 +6937,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":210,"deletions":114,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1088,6 +1118,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1225,2 +1249,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4458,1 +4497,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4482,1 +4521,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6384,0 +6423,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandShort128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorShort128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorShort128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotShort128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqShort128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotShort128VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongShort128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6683,96 +6873,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short128VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short128VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short128VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short128VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsShort128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6781,1 +6877,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6783,5 +6878,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6789,1 +6887,0 @@\n-        assertArraysEquals(r, a, b, Short128VectorTests::beq);\n@@ -6896,17 +6993,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongShort128VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1088,6 +1118,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1225,2 +1249,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4458,1 +4497,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4482,1 +4521,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6384,0 +6423,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandShort256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorShort256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorShort256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotShort256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqShort256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotShort256VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongShort256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6683,96 +6873,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short256VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short256VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short256VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short256VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsShort256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6781,1 +6877,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6783,5 +6878,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6789,1 +6887,0 @@\n-        assertArraysEquals(r, a, b, Short256VectorTests::beq);\n@@ -6896,17 +6993,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongShort256VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1088,6 +1118,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1225,2 +1249,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4458,1 +4497,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4482,1 +4521,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6384,0 +6423,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandShort512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorShort512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorShort512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotShort512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqShort512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotShort512VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongShort512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6683,96 +6873,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short512VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short512VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short512VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short512VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsShort512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6781,1 +6877,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6783,5 +6878,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6789,1 +6887,0 @@\n-        assertArraysEquals(r, a, b, Short512VectorTests::beq);\n@@ -6896,17 +6993,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongShort512VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1088,6 +1118,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1225,2 +1249,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4458,1 +4497,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4482,1 +4521,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6384,0 +6423,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandShort64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorShort64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorShort64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotShort64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqShort64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotShort64VectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongShort64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6683,96 +6873,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short64VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short64VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short64VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short64VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsShort64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6781,1 +6877,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6783,5 +6878,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6789,1 +6887,0 @@\n-        assertArraysEquals(r, a, b, Short64VectorTests::beq);\n@@ -6896,17 +6993,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongShort64VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":210,"deletions":130,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -401,0 +401,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1093,6 +1123,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1230,2 +1254,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n@@ -4463,1 +4502,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -4487,1 +4526,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n@@ -6389,0 +6428,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandShortMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskorShortMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskxorShortMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskandNotShortMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskeqShortMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void masknotShortMaxVectorTests(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongShortMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6688,77 +6878,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ShortMaxVectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ShortMaxVectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ShortMaxVectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEqualsShortMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6767,10 +6882,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ShortMaxVectorTests::bandNot);\n-    }\n@@ -6778,15 +6883,8 @@\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6794,1 +6892,0 @@\n-        assertArraysEquals(r, a, b, ShortMaxVectorTests::beq);\n@@ -6901,1 +6998,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":210,"deletions":114,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+bool_binary_template=\"BoolBinary-op\"\n+bool_unary_template=\"BoolUnary-op\"\n+mask_fromtolong_template=\"Mask-FromToLong\"\n@@ -233,1 +236,2 @@\n-     [[ $template == *\"Compare-Masked\"* ]] || [[ $template == *\"Compare-Broadcast\"* ]]; then\n+     [[ $template == *\"Compare-Masked\"* ]] || [[ $template == *\"Compare-Broadcast\"* ]] ||\n+     [[ $template == *\"Mask-Binary\"* ]]; then\n@@ -628,0 +632,9 @@\n+# Mask operations\n+gen_op_tmpl $bool_binary_template \"and\" \"a \\& b\"\n+gen_op_tmpl $bool_binary_template \"or\" \"a | b\"\n+gen_op_tmpl $bool_binary_template \"xor\" \"a != b\"\n+gen_op_tmpl $bool_binary_template \"andNot\" \"a \\& !b\"\n+gen_op_tmpl $bool_binary_template \"eq\" \"a == b\"\n+gen_op_tmpl $bool_unary_template \"not\" \"!a\"\n+gen_op_tmpl $mask_fromtolong_template \"FromToLong\" \"\"\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,11 @@\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.[[TEST]](bv).intoArray(r, i);\n+            }\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-BoolBinary-op.template","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.[[TEST]]().intoArray(r, i);\n+            }\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-BoolUnary-op.template","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+\n+    static boolean b[[TEST]](boolean a, boolean b) {\n+        return [[TEST_OP]];\n+    }\n+\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void mask[[TEST]]$vectorteststype$(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+[[KERNEL]]\n+        assertArraysEquals(r, a, b, $vectorteststype$::b[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-BoolBinary-op.template","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-BoolReduction-op.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,10 @@\n+\n+    static boolean u[[TEST]](boolean a) {\n+        return [[TEST_OP]];\n+    }\n+\n+    @Test(dataProvider = \"boolMaskUnaryOpProvider\")\n+    static void mask[[TEST]]$vectorteststype$(IntFunction<boolean[]> fa) {\n+[[KERNEL]]\n+        assertArraysEquals(r, a, $vectorteststype$::u[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-BoolUnary-op.template","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void mask[[TEST]]$vectorteststype$(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Mask-FromToLong.template","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -385,2 +385,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEquals$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"boolMaskBinaryOpProvider\")\n+    static void maskEquals$vectorteststype$(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -390,100 +390,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAnd$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, $vectorteststype$::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOr$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, $vectorteststype$::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXor$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, $vectorteststype$::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNot$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, $vectorteststype$::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEq$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -491,1 +399,0 @@\n-        assertArraysEquals(r, a, b, $vectorteststype$::beq);\n@@ -598,19 +505,0 @@\n-#if[!MaxBit]\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLong$vectorteststype$SmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-#end[!MaxBit]\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":10,"deletions":122,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -493,0 +493,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1363,6 +1393,0 @@\n-    @DataProvider\n-    public Object[][] boolUnaryOpProvider() {\n-        return BOOL_ARRAY_GENERATORS.stream().\n-                map(f -> new Object[]{f}).\n-                toArray(Object[][]::new);\n-    }\n@@ -1524,2 +1548,17 @@\n-    public Object[][] maskCompareOpProvider() {\n-        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+    public Object[][] longMaskProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskBinaryOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().\n+                map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] boolMaskUnaryOpProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":47,"deletions":8,"binary":false,"changes":55,"status":"modified"}]}