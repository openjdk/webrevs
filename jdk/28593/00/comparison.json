{"files":[{"patch":"@@ -120,0 +120,7 @@\n+            withToString(\"mask[i % 5]\", (int l) -> {\n+                boolean[] a = new boolean[l];\n+                for (int i = 0; i < l; i++) {\n+                    a[i] = (i % 2 == 0);\n+                }\n+                return a;\n+            }),\n@@ -125,1 +132,8 @@\n-            withToString(\"mask[false]\", boolean[]::new)\n+            withToString(\"mask[false]\", boolean[]::new),\n+            withToString(\"mask[random]\", (int l) -> {\n+                boolean[] a = new boolean[l];\n+                for (int i = 0; i < l; i++) {\n+                    a[i] = RAND.nextBoolean();\n+                }\n+                return a;\n+            })\n@@ -134,0 +148,20 @@\n+    static long[] pack_booleans_to_longs(boolean[] mask) {\n+        int totalLongs = (mask.length + 63) \/ 64; \/\/ ceil division\n+        long[] packed = new long[totalLongs];\n+        for (int i = 0; i < mask.length; i++) {\n+            int longIndex = i \/ 64;\n+            int bitIndex = i % 64;\n+            if (mask[i]) {\n+                packed[longIndex] |= 1L << bitIndex;\n+            }\n+        }\n+        return packed;\n+    }\n+\n+    static final List<IntFunction<long[]>> LONG_MASK_GENERATORS = BOOLEAN_MASK_GENERATORS.stream()\n+            .map(f -> withToString(\n+                    f.toString().replace(\"mask\", \"long_mask\"),\n+                    (IntFunction<long[]>) (int l) -> pack_booleans_to_longs(f.apply(l))\n+            ))\n+            .collect(Collectors.toList());\n+\n@@ -213,15 +247,0 @@\n-    interface FBooleanBinOp {\n-        boolean apply(boolean a, boolean b);\n-    }\n-\n-    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBooleanBinOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorTest.java","additions":35,"deletions":16,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1235,1 +1265,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6393,0 +6430,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandByte128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorByte128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorByte128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotByte128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqByte128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotByte128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongByte128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6703,58 +6891,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte128VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte128VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsByte128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6763,10 +6895,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte128VectorTests::bxor);\n-    }\n@@ -6774,34 +6896,8 @@\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte128VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6809,1 +6905,0 @@\n-        assertArraysEquals(r, a, b, Byte128VectorTests::beq);\n@@ -6916,17 +7011,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongByte128VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1235,1 +1265,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6393,0 +6430,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandByte256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorByte256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorByte256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotByte256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqByte256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotByte256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongByte256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6703,58 +6891,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte256VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte256VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsByte256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6763,10 +6895,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte256VectorTests::bxor);\n-    }\n@@ -6774,34 +6896,8 @@\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte256VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6809,1 +6905,0 @@\n-        assertArraysEquals(r, a, b, Byte256VectorTests::beq);\n@@ -6916,17 +7011,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongByte256VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1235,1 +1265,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6393,0 +6430,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandByte512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorByte512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorByte512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotByte512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqByte512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotByte512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongByte512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6703,58 +6891,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte512VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte512VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsByte512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6763,10 +6895,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte512VectorTests::bxor);\n-    }\n@@ -6774,34 +6896,8 @@\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte512VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6809,1 +6905,0 @@\n-        assertArraysEquals(r, a, b, Byte512VectorTests::beq);\n@@ -6916,17 +7011,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongByte512VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1235,1 +1265,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6393,0 +6430,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandByte64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorByte64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorByte64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotByte64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqByte64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotByte64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongByte64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6703,58 +6891,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte64VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte64VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsByte64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6763,10 +6895,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte64VectorTests::bxor);\n-    }\n@@ -6774,34 +6896,8 @@\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Byte64VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6809,1 +6905,0 @@\n-        assertArraysEquals(r, a, b, Byte64VectorTests::beq);\n@@ -6916,17 +7011,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongByte64VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -401,0 +401,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1240,1 +1270,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6398,0 +6435,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandByteMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorByteMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorByteMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotByteMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqByteMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotByteMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongByteMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6708,20 +6896,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsByteMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6730,1 +6900,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6732,81 +6901,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ByteMaxVectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ByteMaxVectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ByteMaxVectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ByteMaxVectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6814,1 +6910,0 @@\n-        assertArraysEquals(r, a, b, ByteMaxVectorTests::beq);\n@@ -6921,1 +7016,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":199,"deletions":105,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1294,1 +1324,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -4809,0 +4846,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandDouble128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorDouble128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorDouble128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotDouble128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqDouble128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double128VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotDouble128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Double128VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongDouble128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5098,20 +5286,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsDouble128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5120,10 +5290,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double128VectorTests::band);\n-    }\n@@ -5131,72 +5291,8 @@\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double128VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double128VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double128VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5204,1 +5300,0 @@\n-        assertArraysEquals(r, a, b, Double128VectorTests::beq);\n@@ -5311,17 +5406,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongDouble128VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1294,1 +1324,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -4809,0 +4846,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandDouble256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorDouble256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorDouble256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotDouble256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqDouble256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double256VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotDouble256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Double256VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongDouble256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5098,20 +5286,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsDouble256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5120,10 +5290,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double256VectorTests::band);\n-    }\n@@ -5131,72 +5291,8 @@\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double256VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double256VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double256VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5204,1 +5300,0 @@\n-        assertArraysEquals(r, a, b, Double256VectorTests::beq);\n@@ -5311,17 +5406,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongDouble256VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1294,1 +1324,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -4809,0 +4846,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandDouble512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorDouble512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorDouble512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotDouble512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqDouble512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double512VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotDouble512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Double512VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongDouble512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5098,20 +5286,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsDouble512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5120,10 +5290,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double512VectorTests::band);\n-    }\n@@ -5131,72 +5291,8 @@\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double512VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double512VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double512VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5204,1 +5300,0 @@\n-        assertArraysEquals(r, a, b, Double512VectorTests::beq);\n@@ -5311,17 +5406,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongDouble512VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1294,1 +1324,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -4809,0 +4846,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandDouble64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorDouble64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorDouble64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotDouble64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqDouble64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Double64VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotDouble64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Double64VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongDouble64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5098,20 +5286,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsDouble64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5120,10 +5290,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double64VectorTests::band);\n-    }\n@@ -5131,72 +5291,8 @@\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double64VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double64VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Double64VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5204,1 +5300,0 @@\n-        assertArraysEquals(r, a, b, Double64VectorTests::beq);\n@@ -5311,17 +5406,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongDouble64VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -419,0 +419,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1299,1 +1329,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -4814,0 +4851,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandDoubleMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, DoubleMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorDoubleMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorDoubleMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotDoubleMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqDoubleMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, DoubleMaxVectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotDoubleMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, DoubleMaxVectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongDoubleMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5103,58 +5291,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, DoubleMaxVectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsDoubleMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5163,1 +5295,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -5165,43 +5296,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5209,1 +5305,0 @@\n-        assertArraysEquals(r, a, b, DoubleMaxVectorTests::beq);\n@@ -5316,1 +5411,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":199,"deletions":105,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1305,1 +1335,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -4778,0 +4815,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandFloat128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorFloat128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorFloat128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotFloat128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqFloat128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float128VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotFloat128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Float128VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongFloat128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5077,20 +5265,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsFloat128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5099,10 +5269,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float128VectorTests::band);\n-    }\n@@ -5110,72 +5270,8 @@\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float128VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float128VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float128VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5183,1 +5279,0 @@\n-        assertArraysEquals(r, a, b, Float128VectorTests::beq);\n@@ -5290,17 +5385,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongFloat128VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1305,1 +1335,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -4778,0 +4815,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandFloat256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorFloat256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorFloat256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotFloat256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqFloat256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float256VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotFloat256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Float256VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongFloat256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5077,20 +5265,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsFloat256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5099,10 +5269,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float256VectorTests::band);\n-    }\n@@ -5110,72 +5270,8 @@\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float256VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float256VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float256VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5183,1 +5279,0 @@\n-        assertArraysEquals(r, a, b, Float256VectorTests::beq);\n@@ -5290,17 +5385,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongFloat256VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1305,1 +1335,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -4778,0 +4815,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandFloat512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorFloat512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorFloat512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotFloat512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqFloat512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float512VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotFloat512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Float512VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongFloat512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5077,20 +5265,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsFloat512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5099,10 +5269,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float512VectorTests::band);\n-    }\n@@ -5110,72 +5270,8 @@\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float512VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float512VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float512VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5183,1 +5279,0 @@\n-        assertArraysEquals(r, a, b, Float512VectorTests::beq);\n@@ -5290,17 +5385,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongFloat512VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -414,0 +414,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1305,1 +1335,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -4778,0 +4815,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandFloat64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorFloat64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorFloat64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotFloat64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqFloat64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Float64VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotFloat64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Float64VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongFloat64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5077,20 +5265,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsFloat64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5099,10 +5269,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float64VectorTests::band);\n-    }\n@@ -5110,72 +5270,8 @@\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float64VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float64VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Float64VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5183,1 +5279,0 @@\n-        assertArraysEquals(r, a, b, Float64VectorTests::beq);\n@@ -5290,17 +5385,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongFloat64VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -419,0 +419,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1310,1 +1340,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -4783,0 +4820,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandFloatMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, FloatMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorFloatMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, FloatMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorFloatMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, FloatMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotFloatMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, FloatMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqFloatMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, FloatMaxVectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotFloatMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, FloatMaxVectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongFloatMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -5082,58 +5270,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, FloatMaxVectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, FloatMaxVectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsFloatMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -5142,1 +5274,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -5144,43 +5275,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, FloatMaxVectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, FloatMaxVectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -5188,1 +5284,0 @@\n-        assertArraysEquals(r, a, b, FloatMaxVectorTests::beq);\n@@ -5295,1 +5390,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":199,"deletions":105,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1225,1 +1255,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6437,0 +6474,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandInt128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorInt128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorInt128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotInt128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqInt128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotInt128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongInt128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6736,58 +6924,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int128VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int128VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsInt128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6796,10 +6928,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int128VectorTests::bxor);\n-    }\n@@ -6807,34 +6929,8 @@\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int128VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6842,1 +6938,0 @@\n-        assertArraysEquals(r, a, b, Int128VectorTests::beq);\n@@ -6949,17 +7044,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongInt128VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1225,1 +1255,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6437,0 +6474,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandInt256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorInt256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorInt256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotInt256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqInt256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotInt256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongInt256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6736,58 +6924,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int256VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int256VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsInt256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6796,10 +6928,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int256VectorTests::bxor);\n-    }\n@@ -6807,34 +6929,8 @@\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int256VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6842,1 +6938,0 @@\n-        assertArraysEquals(r, a, b, Int256VectorTests::beq);\n@@ -6949,17 +7044,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongInt256VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1225,1 +1255,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6437,0 +6474,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandInt512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorInt512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorInt512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotInt512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqInt512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotInt512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongInt512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6736,58 +6924,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int512VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int512VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsInt512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6796,10 +6928,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int512VectorTests::bxor);\n-    }\n@@ -6807,34 +6929,8 @@\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int512VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6842,1 +6938,0 @@\n-        assertArraysEquals(r, a, b, Int512VectorTests::beq);\n@@ -6949,17 +7044,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongInt512VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1225,1 +1255,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6437,0 +6474,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandInt64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorInt64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorInt64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotInt64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqInt64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotInt64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongInt64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6736,58 +6924,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int64VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int64VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsInt64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6796,10 +6928,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int64VectorTests::bxor);\n-    }\n@@ -6807,34 +6929,8 @@\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Int64VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6842,1 +6938,0 @@\n-        assertArraysEquals(r, a, b, Int64VectorTests::beq);\n@@ -6949,17 +7044,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongInt64VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -401,0 +401,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1230,1 +1260,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6442,0 +6479,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandIntMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorIntMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorIntMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotIntMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqIntMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotIntMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongIntMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6741,20 +6929,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsIntMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6763,1 +6933,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6765,81 +6934,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, IntMaxVectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, IntMaxVectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, IntMaxVectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, IntMaxVectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6847,1 +6943,0 @@\n-        assertArraysEquals(r, a, b, IntMaxVectorTests::beq);\n@@ -6954,1 +7049,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":199,"deletions":105,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -353,0 +353,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1222,1 +1252,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6389,0 +6426,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandLong128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorLong128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorLong128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotLong128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqLong128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotLong128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6622,2 +6810,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsLong128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6627,100 +6815,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long128VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long128VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long128VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long128VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6728,1 +6824,0 @@\n-        assertArraysEquals(r, a, b, Long128VectorTests::beq);\n@@ -6835,17 +6930,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongLong128VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -353,0 +353,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1222,1 +1252,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6389,0 +6426,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandLong256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorLong256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorLong256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotLong256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqLong256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotLong256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6622,2 +6810,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsLong256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6627,100 +6815,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long256VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long256VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long256VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long256VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6728,1 +6824,0 @@\n-        assertArraysEquals(r, a, b, Long256VectorTests::beq);\n@@ -6835,17 +6930,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongLong256VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -353,0 +353,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1222,1 +1252,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6389,0 +6426,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandLong512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorLong512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorLong512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotLong512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqLong512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotLong512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6622,2 +6810,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsLong512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6627,100 +6815,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long512VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long512VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long512VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long512VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6728,1 +6824,0 @@\n-        assertArraysEquals(r, a, b, Long512VectorTests::beq);\n@@ -6835,17 +6930,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongLong512VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -353,0 +353,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1222,1 +1252,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6389,0 +6426,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandLong64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorLong64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorLong64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotLong64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqLong64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotLong64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6622,2 +6810,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsLong64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6627,100 +6815,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long64VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long64VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long64VectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Long64VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6728,1 +6824,0 @@\n-        assertArraysEquals(r, a, b, Long64VectorTests::beq);\n@@ -6835,17 +6930,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongLong64VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -358,0 +358,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1227,1 +1257,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6394,0 +6431,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandLongMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorLongMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorLongMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotLongMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqLongMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotLongMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6627,96 +6815,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, LongMaxVectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, LongMaxVectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, LongMaxVectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, LongMaxVectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsLongMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6725,1 +6819,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6727,5 +6820,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6733,1 +6829,0 @@\n-        assertArraysEquals(r, a, b, LongMaxVectorTests::beq);\n@@ -6840,1 +6935,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":199,"deletions":105,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1225,1 +1255,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6384,0 +6421,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandShort128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorShort128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorShort128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotShort128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqShort128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotShort128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongShort128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6683,58 +6871,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short128VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short128VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsShort128VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6743,10 +6875,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short128VectorTests::bxor);\n-    }\n@@ -6754,34 +6876,8 @@\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short128VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6789,1 +6885,0 @@\n-        assertArraysEquals(r, a, b, Short128VectorTests::beq);\n@@ -6896,17 +6991,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongShort128VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1225,1 +1255,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6384,0 +6421,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandShort256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorShort256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorShort256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotShort256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqShort256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotShort256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongShort256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6683,58 +6871,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short256VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short256VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsShort256VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6743,10 +6875,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short256VectorTests::bxor);\n-    }\n@@ -6754,34 +6876,8 @@\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short256VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6789,1 +6885,0 @@\n-        assertArraysEquals(r, a, b, Short256VectorTests::beq);\n@@ -6896,17 +6991,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongShort256VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1225,1 +1255,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6384,0 +6421,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandShort512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorShort512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorShort512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotShort512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqShort512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotShort512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongShort512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6683,58 +6871,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short512VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short512VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsShort512VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6743,10 +6875,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short512VectorTests::bxor);\n-    }\n@@ -6754,34 +6876,8 @@\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short512VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6789,1 +6885,0 @@\n-        assertArraysEquals(r, a, b, Short512VectorTests::beq);\n@@ -6896,17 +6991,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongShort512VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1225,1 +1255,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6384,0 +6421,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandShort64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorShort64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorShort64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotShort64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqShort64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotShort64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongShort64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6683,58 +6871,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short64VectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short64VectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsShort64VectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6743,10 +6875,0 @@\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short64VectorTests::bxor);\n-    }\n@@ -6754,34 +6876,8 @@\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, Short64VectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6789,1 +6885,0 @@\n-        assertArraysEquals(r, a, b, Short64VectorTests::beq);\n@@ -6896,17 +6991,0 @@\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLongShort64VectorTestsSmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":199,"deletions":121,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -401,0 +401,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1230,1 +1260,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n@@ -6389,0 +6426,151 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandShortMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.and(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskorShortMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.or(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskxorShortMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.xor(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskandNotShortMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.andNot(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return a == b;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskeqShortMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.eq(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::beq);\n+    }\n+\n+    static boolean unot(boolean a) {\n+        return !a;\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void masknotShortMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::unot);\n+    }\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void maskFromToLongShortMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n+\n@@ -6688,20 +6876,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqualsShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEqualsShortMaxVectorTests(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -6710,1 +6880,0 @@\n-        boolean[] r = new boolean[a.length];\n@@ -6712,81 +6881,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ShortMaxVectorTests::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOrShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ShortMaxVectorTests::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXorShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ShortMaxVectorTests::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNotShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, ShortMaxVectorTests::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEqShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -6794,1 +6890,0 @@\n-        assertArraysEquals(r, a, b, ShortMaxVectorTests::beq);\n@@ -6901,1 +6996,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":199,"deletions":105,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+bool_binary_template=\"BoolBinary-op\"\n+bool_unary_template=\"BoolUnary-op\"\n+mask_fromtolong_template=\"Mask-FromToLong\"\n@@ -233,1 +236,2 @@\n-     [[ $template == *\"Compare-Masked\"* ]] || [[ $template == *\"Compare-Broadcast\"* ]]; then\n+     [[ $template == *\"Compare-Masked\"* ]] || [[ $template == *\"Compare-Broadcast\"* ]] ||\n+     [[ $template == *\"Mask-Binary\"* ]]; then\n@@ -628,0 +632,9 @@\n+# Mask operations\n+gen_op_tmpl $bool_binary_template \"and\" \"a \\& b\"\n+gen_op_tmpl $bool_binary_template \"or\" \"a | b\"\n+gen_op_tmpl $bool_binary_template \"xor\" \"a != b\"\n+gen_op_tmpl $bool_binary_template \"andNot\" \"a \\& !b\"\n+gen_op_tmpl $bool_binary_template \"eq\" \"a == b\"\n+gen_op_tmpl $bool_unary_template \"not\" \"!a\"\n+gen_op_tmpl $mask_fromtolong_template \"FromToLong\" \"\"\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,11 @@\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                VectorMask bv = SPECIES.loadMask(b, i);\n+                av.[[TEST]](bv).intoArray(r, i);\n+            }\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-BoolBinary-op.template","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask av = SPECIES.loadMask(a, i);\n+                av.[[TEST]]().intoArray(r, i);\n+            }\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-BoolUnary-op.template","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+\n+    static boolean b[[TEST]](boolean a, boolean b) {\n+        return [[TEST_OP]];\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void mask[[TEST]]$vectorteststype$(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+[[KERNEL]]\n+        assertArraysEquals(r, a, b, $vectorteststype$::b[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-BoolBinary-op.template","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+\n+    static boolean u[[TEST]](boolean a) {\n+        return [[TEST_OP]];\n+    }\n+\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void mask[[TEST]]$vectorteststype$(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+[[KERNEL]]\n+        assertArraysEquals(r, a, $vectorteststype$::u[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-BoolUnary-op.template","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\n+    private static final long LONG_MASK_BITS = 0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length());\n+\n+    static void assertArraysEquals(long[] r, long[] a, long bits) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i] & bits);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i] & bits, \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    static void mask[[TEST]]$vectorteststype$(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i++) {\n+                VectorMask vmask = VectorMask.fromLong(SPECIES, a[i]);\n+                r[i] = vmask.toLong();\n+            }\n+        }\n+        assertArraysEquals(r, a, LONG_MASK_BITS);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Mask-FromToLong.template","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -385,2 +385,2 @@\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEquals$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+    @Test(dataProvider = \"maskBinaryOpProvider\")\n+    static void maskEquals$vectorteststype$(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n@@ -390,100 +390,8 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            boolean equals = av.equals(bv);\n-            int to = i + SPECIES.length();\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n-        }\n-    }\n-\n-    static boolean band(boolean a, boolean b) {\n-        return a & b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAnd$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.and(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, $vectorteststype$::band);\n-    }\n-\n-    static boolean bor(boolean a, boolean b) {\n-        return a | b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskOr$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.or(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, $vectorteststype$::bor);\n-    }\n-\n-    static boolean bxor(boolean a, boolean b) {\n-        return a != b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskXor$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.xor(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, $vectorteststype$::bxor);\n-    }\n-\n-    static boolean bandNot(boolean a, boolean b) {\n-        return a & !b;\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskAndNot$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.andNot(bv);\n-            cv.intoArray(r, i);\n-        }\n-        assertArraysEquals(r, a, b, $vectorteststype$::bandNot);\n-    }\n-\n-    static boolean beq(boolean a, boolean b) {\n-        return (a == b);\n-    }\n-\n-    @Test(dataProvider = \"maskCompareOpProvider\")\n-    static void maskEq$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-        boolean[] b = fb.apply(SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var av = SPECIES.loadMask(a, i);\n-            var bv = SPECIES.loadMask(b, i);\n-            var cv = av.eq(bv);\n-            cv.intoArray(r, i);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var av = SPECIES.loadMask(a, i);\n+                var bv = SPECIES.loadMask(b, i);\n+                boolean equals = av.equals(bv);\n+                int to = i + SPECIES.length();\n+                Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            }\n@@ -491,1 +399,0 @@\n-        assertArraysEquals(r, a, b, $vectorteststype$::beq);\n@@ -598,19 +505,0 @@\n-#if[!MaxBit]\n-    @DataProvider\n-    public static Object[][] longMaskProvider() {\n-        return new Object[][]{\n-                {0xFFFFFFFFFFFFFFFFL},\n-                {0x0000000000000000L},\n-                {0x5555555555555555L},\n-                {0x0123456789abcdefL},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void maskFromToLong$vectorteststype$SmokeTest(long inputLong) {\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n-    }\n-#end[!MaxBit]\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":10,"deletions":122,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -493,0 +493,30 @@\n+    interface FBoolUnOp {\n+        boolean apply(boolean a);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, FBoolUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"(\" + a[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] b, FBoolBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -1524,1 +1554,8 @@\n-    public Object[][] maskCompareOpProvider() {\n+    public Object[][] maskLongProvider() {\n+        return LONG_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskBinaryOpProvider() {\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"}]}