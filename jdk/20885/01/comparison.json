{"files":[{"patch":"@@ -598,0 +598,1 @@\n+  friend class VMStructs;\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -566,0 +566,6 @@\n+  \/*****************************************************\/                                                                            \\\n+  \/* UpcallStubs (NOTE: incomplete, but only a little) *\/                                                                            \\\n+  \/*****************************************************\/                                                                            \\\n+                                                                                                                                     \\\n+  nonstatic_field(UpcallStub,                  _frame_data_offset,                            ByteSize)                              \\\n+                                                                                                                                     \\\n@@ -1015,1 +1021,3 @@\n-  nonstatic_field(InvocationCounter,           _counter,                                      unsigned int)\n+  nonstatic_field(InvocationCounter,           _counter,                                      unsigned int)                          \\\n+                                                                                                                                     \\\n+  nonstatic_field(UpcallStub::FrameData,       jfa,                                           JavaFrameAnchor)\n@@ -1309,0 +1317,1 @@\n+  declare_type(UpcallStub,               RuntimeBlob)                     \\\n@@ -1903,0 +1912,1 @@\n+  declare_integer_type(ByteSize)                                          \\\n@@ -1951,0 +1961,1 @@\n+  declare_toplevel_type(UpcallStub::FrameData)                            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -146,0 +146,2 @@\n+  public boolean isUpcallStub()         { return false; }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeBlob.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+    virtualConstructor.addMapping(\"UpcallStub\", UpcallStub.class);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeCache.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.code;\n+\n+import java.util.*;\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.types.*;\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+public class UpcallStub extends RuntimeBlob {\n+\n+  private static CIntegerField frameDataOffsetField;\n+\n+  private static AddressField lastJavaFPField;\n+\n+  private static AddressField lastJavaSPField;\n+\n+  private static AddressField lastJavaPCField;\n+\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+  }\n+\n+  private static void initialize(TypeDataBase db) {\n+    Type type = db.lookupType(\"UpcallStub\");\n+    frameDataOffsetField = type.getCIntegerField(\"_frame_data_offset\");\n+\n+    Type anchorType = db.lookupType(\"JavaFrameAnchor\");\n+    lastJavaSPField = anchorType.getAddressField(\"_last_Java_sp\");\n+    lastJavaPCField = anchorType.getAddressField(\"_last_Java_pc\");\n+\n+    try {\n+      lastJavaFPField = anchorType.getAddressField(\"_last_Java_fp\");\n+    } catch (Exception e) {\n+      \/\/ Some platforms (e.g. PPC64) does not have this field.\n+      lastJavaFPField = null;\n+    }\n+  }\n+\n+  public UpcallStub(Address addr) {\n+    super(addr);\n+  }\n+\n+  protected Address getJavaFrameAnchor(Frame frame) {\n+    var frameDataOffset = frameDataOffsetField.getValue(addr);\n+    var frameDataAddr = frame.getUnextendedSP().addOffsetTo(frameDataOffset);\n+    var frameData = VMObjectFactory.newObject(FrameData.class, frameDataAddr);\n+    return frameData.getJavaFrameAnchor();\n+  }\n+\n+  public Address getLastJavaSP(Frame frame) {\n+    return lastJavaSPField.getValue(getJavaFrameAnchor(frame));\n+  }\n+\n+  public Address getLastJavaFP(Frame frame) {\n+    return lastJavaFPField == null ? null : lastJavaFPField.getValue(getJavaFrameAnchor(frame));\n+  }\n+\n+  public Address getLastJavaPC(Frame frame) {\n+    return lastJavaPCField.getValue(getJavaFrameAnchor(frame));\n+  }\n+\n+  public boolean isUpcallStub() {\n+    return true;\n+  }\n+\n+  public static class FrameData extends VMObject {\n+\n+    private static AddressField jfaField;\n+\n+    static {\n+      VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+    }\n+\n+    private static void initialize(TypeDataBase db) {\n+      Type type = db.lookupType(\"UpcallStub::FrameData\");\n+      jfaField = type.getAddressField(\"jfa\");\n+    }\n+\n+    public FrameData(Address addr) {\n+      super(addr);\n+    }\n+\n+    public Address getJavaFrameAnchor() {\n+      return addr.addOffsetTo(jfaField.getOffset());\n+    }\n+\n+  }\n+\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/UpcallStub.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,1 +295,1 @@\n-      return senderForCompiledFrame(map, cb);\n+      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n@@ -330,0 +330,28 @@\n+  private Frame senderForUpcallStub(AARCH64RegisterMap map, UpcallStub stub) {\n+    if (DEBUG) {\n+      System.out.println(\"senderForUpcallStub\");\n+    }\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map != null, \"map must be set\");\n+    }\n+\n+    var lastJavaFP = stub.getLastJavaFP(this);\n+    var lastJavaSP = stub.getLastJavaSP(this);\n+    var lastJavaPC = stub.getLastJavaPC(this);\n+\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(lastJavaSP.greaterThan(getSP()), \"must be above this frame on stack\");\n+    }\n+    AARCH64Frame fr;\n+    if (lastJavaPC != null) {\n+      fr = new AARCH64Frame(lastJavaSP, lastJavaFP, lastJavaPC);\n+    } else {\n+      fr = new AARCH64Frame(lastJavaSP, lastJavaFP);\n+    }\n+    map.clear();\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map.getIncludeArgumentOops(), \"should be set by clear\");\n+    }\n+    return fr;\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/aarch64\/AARCH64Frame.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -282,1 +282,1 @@\n-      return senderForCompiledFrame(map, cb);\n+      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n@@ -317,0 +317,28 @@\n+  private Frame senderForUpcallStub(PPC64RegisterMap map, UpcallStub stub) {\n+    if (DEBUG) {\n+      System.out.println(\"senderForUpcallStub\");\n+    }\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map != null, \"map must be set\");\n+    }\n+\n+    var lastJavaFP = stub.getLastJavaFP(this); \/\/ This will be null\n+    var lastJavaSP = stub.getLastJavaSP(this);\n+    var lastJavaPC = stub.getLastJavaPC(this);\n+\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(lastJavaSP.greaterThan(getSP()), \"must be above this frame on stack\");\n+    }\n+    PPC64Frame fr;\n+    if (lastJavaPC != null) {\n+      fr = new PPC64Frame(lastJavaSP, lastJavaFP, lastJavaPC);\n+    } else {\n+      fr = new PPC64Frame(lastJavaSP, lastJavaFP);\n+    }\n+    map.clear();\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map.getIncludeArgumentOops(), \"should be set by clear\");\n+    }\n+    return fr;\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ppc64\/PPC64Frame.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -287,1 +287,1 @@\n-      return senderForCompiledFrame(map, cb);\n+      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n@@ -322,0 +322,28 @@\n+  private Frame senderForUpcallStub(RISCV64RegisterMap map, UpcallStub stub) {\n+    if (DEBUG) {\n+      System.out.println(\"senderForUpcallStub\");\n+    }\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map != null, \"map must be set\");\n+    }\n+\n+    var lastJavaFP = stub.getLastJavaFP(this);\n+    var lastJavaSP = stub.getLastJavaSP(this);\n+    var lastJavaPC = stub.getLastJavaPC(this);\n+\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(lastJavaSP.greaterThan(getSP()), \"must be above this frame on stack\");\n+    }\n+    RISCV64Frame fr;\n+    if (lastJavaPC != null) {\n+      fr = new RISCV64Frame(lastJavaSP, lastJavaFP, lastJavaPC);\n+    } else {\n+      fr = new RISCV64Frame(lastJavaSP, lastJavaFP);\n+    }\n+    map.clear();\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map.getIncludeArgumentOops(), \"should be set by clear\");\n+    }\n+    return fr;\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/riscv64\/RISCV64Frame.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -292,1 +292,1 @@\n-      return senderForCompiledFrame(map, cb);\n+      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n@@ -323,0 +323,28 @@\n+    }\n+    return fr;\n+  }\n+\n+  private Frame senderForUpcallStub(X86RegisterMap map, UpcallStub stub) {\n+    if (DEBUG) {\n+      System.out.println(\"senderForUpcallStub\");\n+    }\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map != null, \"map must be set\");\n+    }\n+\n+    var lastJavaFP = stub.getLastJavaFP(this);\n+    var lastJavaSP = stub.getLastJavaSP(this);\n+    var lastJavaPC = stub.getLastJavaPC(this);\n+\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(lastJavaSP.greaterThan(getSP()), \"must be above this frame on stack\");\n+    }\n+    X86Frame fr;\n+    if (lastJavaPC != null) {\n+      fr = new X86Frame(lastJavaSP, lastJavaFP, lastJavaPC);\n+    } else {\n+      fr = new X86Frame(lastJavaSP, lastJavaFP);\n+    }\n+    map.clear();\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map.getIncludeArgumentOops(), \"should be set by clear\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/x86\/X86Frame.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+\n+public class LingeredAppWithFFMUpcall extends LingeredApp {\n+\n+    public static final String THREAD_NAME = \"Upcall thread\";\n+\n+    private static final Object lockObj = new Object();\n+\n+    private static final CountDownLatch signal = new CountDownLatch(1);\n+\n+    static {\n+        System.loadLibrary(\"upcall\");\n+    }\n+\n+    public static void upcall() {\n+        signal.countDown();\n+        synchronized(lockObj) {\n+        }\n+    }\n+\n+    public static long createFunctionPointerForUpcall() throws NoSuchMethodException, IllegalAccessException {\n+        var mh = MethodHandles.lookup()\n+                              .findStatic(LingeredAppWithFFMUpcall.class, \"upcall\", MethodType.methodType(void.class));\n+        var stub = Linker.nativeLinker()\n+                         .upcallStub(mh, FunctionDescriptor.ofVoid(), Arena.global());\n+        return stub.address();\n+    }\n+\n+    public static native void callJNI(long upcallAddr);\n+\n+    public static void main(String[] args) {\n+        try {\n+            long upcallAddr = createFunctionPointerForUpcall();\n+            var upcallThread = new Thread(() -> callJNI(upcallAddr), THREAD_NAME);\n+            synchronized(lockObj) {\n+                upcallThread.start();\n+                signal.await();\n+                LingeredApp.main(args);\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/LingeredAppWithFFMUpcall.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.SA.SATestUtils;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @bug 8339307\n+ * @requires vm.hasSA\n+ * @library \/test\/lib\n+ * @run driver TestJhsdbJstackUpcall\n+ *\/\n+public class TestJhsdbJstackUpcall {\n+\n+    private static void runJstack(LingeredApp app) throws Exception {\n+        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"jhsdb\");\n+        launcher.addVMArgs(Utils.getTestJavaOpts());\n+        launcher.addToolArg(\"jstack\");\n+        launcher.addToolArg(\"--pid\");\n+        launcher.addToolArg(Long.toString(app.getPid()));\n+\n+        ProcessBuilder pb = SATestUtils.createProcessBuilder(launcher);\n+        Process jhsdb = pb.start();\n+        OutputAnalyzer out = new OutputAnalyzer(jhsdb);\n+\n+        jhsdb.waitFor();\n+\n+        System.out.println(out.getStdout());\n+        System.err.println(out.getStderr());\n+\n+        out.shouldContain(LingeredAppWithFFMUpcall.THREAD_NAME);\n+        out.shouldContain(\"LingeredAppWithFFMUpcall.upcall()\");\n+        out.shouldContain(\"jdk.internal.foreign.abi.UpcallStub\");\n+        out.shouldContain(\"LingeredAppWithFFMUpcall.callJNI\");\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        SATestUtils.skipIfCannotAttach(); \/\/ throws SkippedException if attach not expected to work.\n+        LingeredApp app = null;\n+\n+        try {\n+            \/\/ Needed for LingeredAppWithFFMUpcall to be able to resolve native library.\n+            String libPath = System.getProperty(\"java.library.path\");\n+            String[] vmArgs = (libPath != null)\n+                ? Utils.prependTestJavaOpts(\"-Djava.library.path=\" + libPath)\n+                : Utils.getTestJavaOpts();\n+\n+            app = new LingeredAppWithFFMUpcall();\n+            LingeredApp.startAppExactJvmOpts(app, vmArgs);\n+            System.out.println(\"Started LingeredAppWithFFMUpcall with pid \" + app.getPid());\n+            runJstack(app);\n+            System.out.println(\"Test Completed\");\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            throw e;\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackUpcall.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+typedef void (*upcall_func)(void);\n+\n+JNIEXPORT void JNICALL\n+Java_LingeredAppWithFFMUpcall_callJNI(JNIEnv *env, jclass cls, jlong upcallAddr) {\n+  upcall_func upcall = (upcall_func)upcallAddr;\n+  upcall();\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/libupcall.c","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"}]}