{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,3 @@\n-### This file is just a very small wrapper needed to run the real make\/Init.gmk.\n-### It also performs some sanity checks on make.\n+### This file is just a very small wrapper which will include make\/PreInit.gmk,\n+### where the real work is done. This wrapper also performs some sanity checks\n+### on make that must be done before we can include another file.\n@@ -63,2 +64,2 @@\n-# ... and then we can include the real makefile\n-include $(topdir)\/make\/Init.gmk\n+# ... and then we can include the real makefile to bootstrap the build\n+include $(topdir)\/make\/PreInit.gmk\n","filename":"Makefile","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,5 @@\n-# This is the bootstrapping part of the build. This file is included from the\n-# top level Makefile, and is responsible for launching the Main.gmk file with\n-# the proper make and the proper make arguments.\n+# Init.gmk sits between PreInit.gmk and Main.gmk when bootstrapping the build.\n+# It is called from PreInit.gmk, and its main responsibility is to launch\n+# Main.gmk with the proper make and the proper make arguments.\n+# PreMain.gmk has provided us with a proper SPEC. This allows us to use the\n+# value of $(MAKE) for all further make calls.\n@@ -40,4 +42,1 @@\n-ifeq ($(HAS_SPEC), )\n-  ##############################################################################\n-  # This is the default mode. We have not been recursively called with a SPEC.\n-  ##############################################################################\n+include $(SPEC)\n@@ -45,2 +44,1 @@\n-  # Include our helper functions.\n-  include $(topdir)\/make\/InitSupport.gmk\n+include $(TOPDIR)\/make\/common\/MakeBase.gmk\n@@ -48,3 +46,3 @@\n-  # Here are \"global\" targets, i.e. targets that can be executed without having\n-  # a configuration. This will define ALL_GLOBAL_TARGETS.\n-  include $(topdir)\/make\/Global.gmk\n+# Our helper functions.\n+include $(TOPDIR)\/make\/InitSupport.gmk\n+include $(TOPDIR)\/make\/common\/LogUtils.gmk\n@@ -52,3 +50,2 @@\n-  # Targets provided by Init.gmk.\n-  ALL_INIT_TARGETS := print-modules print-targets print-configuration \\\n-      print-tests reconfigure pre-compare-build post-compare-build\n+# Parse COMPARE_BUILD (for makefile development)\n+$(eval $(call ParseCompareBuild))\n@@ -56,3 +53,2 @@\n-  # CALLED_TARGETS is the list of targets that the user provided,\n-  # or \"default\" if unspecified.\n-  CALLED_TARGETS := $(if $(MAKECMDGOALS), $(MAKECMDGOALS), default)\n+# Setup reproducible build environment\n+$(eval $(call SetupReproducibleBuild))\n@@ -60,61 +56,5 @@\n-  # Extract non-global targets that require a spec file.\n-  CALLED_SPEC_TARGETS := $(filter-out $(ALL_GLOBAL_TARGETS), $(CALLED_TARGETS))\n-\n-  # If we have only global targets, or if we are called with -qp (assuming an\n-  # external part, e.g. bash completion, is trying to understand our targets),\n-  # we will skip SPEC location and the sanity checks.\n-  ifeq ($(CALLED_SPEC_TARGETS), )\n-    ONLY_GLOBAL_TARGETS := true\n-  endif\n-  ifeq ($(findstring p, $(MAKEFLAGS))$(findstring q, $(MAKEFLAGS)), pq)\n-    ONLY_GLOBAL_TARGETS := true\n-  endif\n-\n-  ifeq ($(ONLY_GLOBAL_TARGETS), true)\n-    ############################################################################\n-    # We have only global targets, or are called with -pq.\n-    ############################################################################\n-\n-    ifeq ($(wildcard $(SPEC)), )\n-      # If we have no SPEC provided, we will just make a \"best effort\" target list.\n-      # First try to grab any available pre-existing main-targets.gmk.\n-      main_targets_file := $(firstword $(wildcard $(build_dir)\/*\/make-support\/main-targets.gmk))\n-      ifneq ($(main_targets_file), )\n-        # Extract the SPEC that corresponds to this main-targets.gmk file.\n-        SPEC := $(patsubst %\/make-support\/main-targets.gmk, %\/spec.gmk, $(main_targets_file))\n-      else\n-        # None found, pick an arbitrary SPEC for which to generate a file\n-        SPEC := $(firstword $(all_spec_files))\n-      endif\n-    endif\n-\n-    ifneq ($(wildcard $(SPEC)), )\n-      $(eval $(call DefineMainTargets, LAZY, $(SPEC)))\n-    else\n-      # If we have no configurations we can not provide any main targets.\n-      ALL_MAIN_TARGETS :=\n-    endif\n-\n-    ALL_TARGETS := $(sort $(ALL_GLOBAL_TARGETS) $(ALL_MAIN_TARGETS) $(ALL_INIT_TARGETS))\n-\n-    # Just list all our targets.\n-    $(ALL_TARGETS):\n-\n-    .PHONY: $(ALL_TARGETS)\n-\n-  else\n-    ############################################################################\n-    # This is the normal case, we have been called from the command line by the\n-    # user and we need to call ourself back with a proper SPEC.\n-    # We have at least one non-global target, so we need to find a spec file.\n-    ############################################################################\n-\n-    # Basic checks on environment and command line.\n-    $(eval $(call CheckControlVariables))\n-    $(eval $(call CheckDeprecatedEnvironment))\n-    $(eval $(call CheckInvalidMakeFlags))\n-\n-    # Check that CONF_CHECK is valid.\n-    $(eval $(call ParseConfCheckOption))\n-\n-    # Check that the LOG given is valid, and set LOG_LEVEL, LOG_NOFILE, MAKE_LOG_VARS and MAKE_LOG_FLAGS.\n+# If no LOG= was given on command line, but we have a non-standard default\n+# value, use that instead and re-parse log level.\n+ifeq ($(LOG), )\n+  ifneq ($(DEFAULT_LOG), )\n+    override LOG := $(DEFAULT_LOG)\n@@ -122,120 +62,0 @@\n-\n-    # After this SPECS contain 1..N spec files (otherwise ParseConfAndSpec fails).\n-    $(eval $(call ParseConfAndSpec))\n-\n-    # Extract main targets from Main.gmk using the spec(s) provided. In theory,\n-    # with multiple specs, we should find the intersection of targets provided\n-    # by all specs, but we approximate this by an arbitrary spec from the list.\n-    # This will setup ALL_MAIN_TARGETS.\n-    $(eval $(call DefineMainTargets, FORCE, $(firstword $(SPECS))))\n-\n-    # Separate called targets depending on type.\n-    INIT_TARGETS := $(filter $(ALL_INIT_TARGETS), $(CALLED_SPEC_TARGETS))\n-    MAIN_TARGETS := $(filter $(ALL_MAIN_TARGETS), $(CALLED_SPEC_TARGETS))\n-    SEQUENTIAL_TARGETS := $(filter dist-clean clean%, $(MAIN_TARGETS))\n-    PARALLEL_TARGETS := $(filter-out $(SEQUENTIAL_TARGETS), $(MAIN_TARGETS))\n-\n-    # The spec files depend on the autoconf source code. This check makes sure\n-    # the configuration is up to date after changes to configure.\n-    $(SPECS): $(wildcard $(topdir)\/make\/autoconf\/*) \\\n-            $(if $(CUSTOM_CONFIG_DIR), $(wildcard $(CUSTOM_CONFIG_DIR)\/*)) \\\n-            $(addprefix $(topdir)\/make\/conf\/, version-numbers.conf branding.conf) \\\n-            $(if $(CUSTOM_CONF_DIR), $(wildcard $(addprefix $(CUSTOM_CONF_DIR)\/, \\\n-                version-numbers.conf branding.conf)))\n-        ifeq ($(CONF_CHECK), fail)\n-\t  @echo Error: The configuration is not up to date for \\\n-\t      \"'$(lastword $(subst \/, , $(dir $@)))'.\"\n-\t  $(call PrintConfCheckFailed)\n-\t  @exit 2\n-        else ifeq ($(CONF_CHECK), auto)\n-\t  @echo Note: The configuration is not up to date for \\\n-\t      \"'$(lastword $(subst \/, , $(dir $@)))'.\"\n-\t  @( cd $(topdir) && \\\n-\t      $(MAKE) $(MFLAGS) $(MAKE_LOG_FLAGS) -r -R -f $(topdir)\/make\/Init.gmk \\\n-\t      SPEC=$@ HAS_SPEC=true ACTUAL_TOPDIR=$(topdir) \\\n-\t      reconfigure )\n-        else ifeq ($(CONF_CHECK), ignore)\n-          # Do nothing\n-        endif\n-\n-    # Do not let make delete spec files even if aborted while doing a reconfigure\n-    .PRECIOUS: $(SPECS)\n-\n-    # Unless reconfigure is explicitly called, let all main targets depend on\n-    # the spec files to be up to date.\n-    ifeq ($(findstring reconfigure, $(INIT_TARGETS)), )\n-      $(MAIN_TARGETS): $(SPECS)\n-    endif\n-\n-    make-info:\n-        ifneq ($(findstring $(LOG_LEVEL), info debug trace), )\n-\t  $(info Running make as '$(strip $(MAKE) $(MFLAGS) \\\n-\t      $(COMMAND_LINE_VARIABLES) $(MAKECMDGOALS))')\n-        endif\n-\n-    MAKE_INIT_WITH_SPEC_ARGUMENTS := ACTUAL_TOPDIR=$(topdir) \\\n-        USER_MAKE_VARS=\"$(USER_MAKE_VARS)\" MAKE_LOG_FLAGS=$(MAKE_LOG_FLAGS) \\\n-        $(MAKE_LOG_VARS) \\\n-        INIT_TARGETS=\"$(INIT_TARGETS)\" \\\n-        SEQUENTIAL_TARGETS=\"$(SEQUENTIAL_TARGETS)\" \\\n-        PARALLEL_TARGETS=\"$(PARALLEL_TARGETS)\"\n-\n-    # Now the init and main targets will be called, once for each SPEC. The\n-    # recipe will be run once for every target specified, but we only want to\n-    # execute the recipe a single time, hence the TARGET_DONE with a dummy\n-    # command if true.\n-    # The COMPARE_BUILD part implements special support for makefile development.\n-    $(ALL_INIT_TARGETS) $(ALL_MAIN_TARGETS): make-info\n-\t@$(if $(TARGET_DONE), \\\n-\t  true \\\n-\t, \\\n-\t  ( cd $(topdir) && \\\n-\t  $(foreach spec, $(SPECS), \\\n-\t    $(MAKE) $(MFLAGS) $(MAKE_LOG_FLAGS) -r -R -j 1 -f $(topdir)\/make\/Init.gmk \\\n-\t        SPEC=$(spec) HAS_SPEC=true $(MAKE_INIT_WITH_SPEC_ARGUMENTS) \\\n-\t        main && \\\n-\t    $(if $(and $(COMPARE_BUILD), $(PARALLEL_TARGETS)), \\\n-\t        $(MAKE) $(MFLAGS) $(MAKE_LOG_FLAGS) -r -R -f $(topdir)\/make\/Init.gmk \\\n-\t            SPEC=$(spec) HAS_SPEC=true ACTUAL_TOPDIR=$(topdir) \\\n-\t            COMPARE_BUILD=\"$(COMPARE_BUILD)\" pre-compare-build && \\\n-\t        $(MAKE) $(MFLAGS) $(MAKE_LOG_FLAGS) -r -R -j 1 -f $(topdir)\/make\/Init.gmk \\\n-\t            SPEC=$(spec) HAS_SPEC=true $(MAKE_INIT_WITH_SPEC_ARGUMENTS) \\\n-\t            COMPARE_BUILD=\"$(COMPARE_BUILD):NODRYRUN=true\" main && \\\n-\t        $(MAKE) $(MFLAGS) $(MAKE_LOG_FLAGS) -r -R -f $(topdir)\/make\/Init.gmk \\\n-\t            SPEC=$(spec) HAS_SPEC=true ACTUAL_TOPDIR=$(topdir) \\\n-\t            COMPARE_BUILD=\"$(COMPARE_BUILD):NODRYRUN=true\" post-compare-build && \\\n-\t    ) \\\n-\t  ) true ) \\\n-\t  $(eval TARGET_DONE=true) \\\n-\t)\n-\n-    .PHONY: $(ALL_MAIN_TARGETS) $(ALL_INIT_TARGETS)\n-\n-  endif # $(ONLY_GLOBAL_TARGETS)!=true\n-\n-else # HAS_SPEC=true\n-\n-  ##############################################################################\n-  # Now we have a spec. This part provides the \"main\" target that acts as a\n-  # trampoline to call the Main.gmk with the value of $(MAKE) found in the spec\n-  # file.\n-  ##############################################################################\n-\n-  include $(SPEC)\n-\n-  # Our helper functions.\n-  include $(TOPDIR)\/make\/InitSupport.gmk\n-\n-  # Parse COMPARE_BUILD (for makefile development)\n-  $(eval $(call ParseCompareBuild))\n-\n-  # Setup reproducible build environment\n-  $(eval $(call SetupReproducibleBuild))\n-\n-  # If no LOG= was given on command line, but we have a non-standard default\n-  # value, use that instead and re-parse log level.\n-  ifeq ($(LOG), )\n-    ifneq ($(DEFAULT_LOG), )\n-      override LOG := $(DEFAULT_LOG)\n-      $(eval $(call ParseLogLevel))\n-    endif\n@@ -243,0 +63,1 @@\n+endif\n@@ -244,5 +65,5 @@\n-  ifeq ($(LOG_NOFILE), true)\n-    # Disable build log if LOG=[level,]nofile was given\n-    override BUILD_LOG_PIPE :=\n-    override BUILD_LOG_PIPE_SIMPLE :=\n-  endif\n+ifeq ($(LOG_NOFILE), true)\n+  # Disable build log if LOG=[level,]nofile was given\n+  override BUILD_LOG_PIPE :=\n+  override BUILD_LOG_PIPE_SIMPLE :=\n+endif\n@@ -250,5 +71,5 @@\n-  ifeq ($(filter dist-clean, $(SEQUENTIAL_TARGETS)), dist-clean)\n-    # We can't have a log file if we're about to remove it.\n-    override BUILD_LOG_PIPE :=\n-    override BUILD_LOG_PIPE_SIMPLE :=\n-  endif\n+ifeq ($(filter dist-clean, $(SEQUENTIAL_TARGETS)), dist-clean)\n+  # We can't have a log file if we're about to remove it.\n+  override BUILD_LOG_PIPE :=\n+  override BUILD_LOG_PIPE_SIMPLE :=\n+endif\n@@ -256,3 +77,3 @@\n-  ifeq ($(OUTPUT_SYNC_SUPPORTED), true)\n-    OUTPUT_SYNC_FLAG := -O$(OUTPUT_SYNC)\n-  endif\n+ifeq ($(OUTPUT_SYNC_SUPPORTED), true)\n+  OUTPUT_SYNC_FLAG := -O$(OUTPUT_SYNC)\n+endif\n@@ -260,3 +81,3 @@\n-  ##############################################################################\n-  # Init targets\n-  ##############################################################################\n+##############################################################################\n+# Init targets. These are handled fully, here and now.\n+##############################################################################\n@@ -264,1 +85,1 @@\n-  print-modules:\n+print-modules:\n@@ -269,1 +90,1 @@\n-  print-targets:\n+print-targets:\n@@ -274,1 +95,1 @@\n-  print-tests:\n+print-tests:\n@@ -279,2 +100,2 @@\n-  print-configuration:\n-\t  $(ECHO) $(CONFIGURE_COMMAND_LINE)\n+print-configuration:\n+\t$(ECHO) $(CONFIGURE_COMMAND_LINE)\n@@ -282,1 +103,1 @@\n-  reconfigure:\n+reconfigure:\n@@ -298,3 +119,1 @@\n-  ##############################################################################\n-  # The main target, for delegating into Main.gmk\n-  ##############################################################################\n+.PHONY: print-modules print-targets print-tests print-configuration reconfigure\n@@ -302,8 +121,3 @@\n-  MAIN_TARGETS := $(SEQUENTIAL_TARGETS) $(PARALLEL_TARGETS) $(COMPARE_BUILD_MAKE)\n-  # If building the default target, add what they are to the description.\n-  DESCRIPTION_TARGETS := $(strip $(MAIN_TARGETS))\n-  ifeq ($(DESCRIPTION_TARGETS), default)\n-    DESCRIPTION_TARGETS += ($(DEFAULT_MAKE_TARGET))\n-  endif\n-  TARGET_DESCRIPTION := target$(if $(word 2, $(MAIN_TARGETS)),s) \\\n-      '$(strip $(DESCRIPTION_TARGETS))' in configuration '$(CONF_NAME)'\n+##############################################################################\n+# The main target. This will delegate all other targets into Main.gmk.\n+##############################################################################\n@@ -311,4 +125,8 @@\n-  # MAKEOVERRIDES is automatically set and propagated by Make to sub-Make calls.\n-  # We need to clear it of the init-specific variables. The user-specified\n-  # variables are explicitly propagated using $(USER_MAKE_VARS).\n-  main: MAKEOVERRIDES :=\n+MAIN_TARGETS := $(SEQUENTIAL_TARGETS) $(PARALLEL_TARGETS) $(COMPARE_BUILD_MAKE)\n+# If building the default target, add what they are to the description.\n+DESCRIPTION_TARGETS := $(strip $(MAIN_TARGETS))\n+ifeq ($(DESCRIPTION_TARGETS), default)\n+  DESCRIPTION_TARGETS += ($(DEFAULT_MAKE_TARGET))\n+endif\n+TARGET_DESCRIPTION := target$(if $(word 2, $(MAIN_TARGETS)),s) \\\n+    '$(strip $(DESCRIPTION_TARGETS))' in configuration '$(CONF_NAME)'\n@@ -316,1 +134,6 @@\n-  main: $(INIT_TARGETS)\n+# MAKEOVERRIDES is automatically set and propagated by Make to sub-Make calls.\n+# We need to clear it of the init-specific variables. The user-specified\n+# variables are explicitly propagated using $(USER_MAKE_VARS).\n+main: MAKEOVERRIDES :=\n+\n+main: $(INIT_TARGETS)\n@@ -336,1 +159,1 @@\n-                    $(if $(JOBS), -j $(JOBS)) \\\n+\t            $(if $(JOBS), -j $(JOBS)) \\\n@@ -356,1 +179,1 @@\n-    on-failure:\n+on-failure:\n@@ -368,2 +191,2 @@\n-    # Support targets for COMPARE_BUILD, used for makefile development\n-    pre-compare-build:\n+# Support targets for COMPARE_BUILD, used for makefile development\n+pre-compare-build:\n@@ -373,1 +196,1 @@\n-    post-compare-build:\n+post-compare-build:\n@@ -378,2 +201,1 @@\n-  .PHONY: print-targets print-modules reconfigure main on-failure\n-endif\n+.PHONY: main on-failure pre-compare-build post-compare-build\n","filename":"make\/Init.gmk","additions":67,"deletions":245,"binary":false,"changes":312,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-# It is divided in two parts, depending on if a SPEC is present or not\n-# (HAS_SPEC is true or not).\n@@ -32,51 +30,22 @@\n-ifndef _INITSUPPORT_GMK\n-_INITSUPPORT_GMK := 1\n-\n-ifeq ($(HAS_SPEC), )\n-\n-  # COMMA is defined in spec.gmk, but that is not included yet\n-  COMMA := ,\n-\n-  # Include the corresponding closed file, if present.\n-  ifneq ($(CUSTOM_MAKE_DIR), )\n-    -include $(CUSTOM_MAKE_DIR)\/InitSupport.gmk\n-  endif\n-\n-  ##############################################################################\n-  # Helper functions for the initial part of Init.gmk, before the spec file is\n-  # loaded. Most of these functions provide parsing and setting up make options\n-  # from the command-line.\n-  ##############################################################################\n-\n-  # Essential control variables that are handled by Init.gmk\n-  INIT_CONTROL_VARIABLES := LOG CONF CONF_NAME SPEC JOBS CONF_CHECK ALLOW \\\n-      COMPARE_BUILD\n-\n-  # All known make control variables; these are handled in other makefiles\n-  MAKE_CONTROL_VARIABLES += JDK_FILTER SPEC_FILTER \\\n-      TEST TEST_JOBS JTREG GTEST MICRO TEST_OPTS TEST_VM_OPTS TEST_DEPS\n-\n-  ALL_CONTROL_VARIABLES := $(INIT_CONTROL_VARIABLES) $(MAKE_CONTROL_VARIABLES)\n-\n-  # Define a simple reverse function.\n-  # Should maybe move to MakeBase.gmk, but we can't include that file now.\n-  reverse = \\\n-      $(if $(strip $(1)), $(call reverse, $(wordlist 2, $(words $(1)), $(1)))) \\\n-          $(firstword $(1))\n-\n-  # The variable MAKEOVERRIDES contains variable assignments from the command\n-  # line, but in reverse order to what the user entered.\n-  # The '§' <=> '\\ 'dance is needed to keep values with space in them connected.\n-  COMMAND_LINE_VARIABLES := $(subst §,\\ , $(call reverse, $(subst \\ ,§,$(MAKEOVERRIDES))))\n-\n-  # A list like FOO=\"val1\" BAR=\"val2\" containing all user-supplied make\n-  # variables that we should propagate.\n-  # The '§' <=> '\\ 'dance is needed to keep values with space in them connected.\n-  USER_MAKE_VARS := $(subst §,\\ , $(filter-out $(addsuffix =%, $(INIT_CONTROL_VARIABLES)), \\\n-      $(subst \\ ,§,$(MAKEOVERRIDES))))\n-\n-  # Setup information about available configurations, if any.\n-  ifneq ($(CUSTOM_ROOT), )\n-    build_dir = $(CUSTOM_ROOT)\/build\n-  else\n-    build_dir = $(topdir)\/build\n+# Define basic logging setup\n+BUILD_LOG := $(OUTPUTDIR)\/build.log\n+BUILD_PROFILE_LOG := $(OUTPUTDIR)\/build-profile.log\n+\n+BUILD_LOG_PIPE := > >($(TEE) -a $(BUILD_LOG)) 2> >($(TEE) -a $(BUILD_LOG) >&2) && wait\n+# Use this for simple echo\/printf commands that are never expected to print\n+# to stderr.\n+BUILD_LOG_PIPE_SIMPLE := | $(TEE) -a $(BUILD_LOG)\n+\n+ifneq ($(CUSTOM_ROOT), )\n+  topdir = $(CUSTOM_ROOT)\n+else\n+  topdir = $(TOPDIR)\n+endif\n+\n+# Setup the build environment to match the requested specification on\n+# level of reproducible builds\n+define SetupReproducibleBuild\n+  ifeq ($$(SOURCE_DATE), updated)\n+    # For static values of SOURCE_DATE (not \"updated\"), these are set in spec.gmk\n+    export SOURCE_DATE_EPOCH := $$(shell $$(DATE) +\"%s\")\n+    export SOURCE_DATE_ISO_8601 := $$(call EpochToISO8601, $$(SOURCE_DATE_EPOCH))\n@@ -84,81 +53,1 @@\n-  all_spec_files = $(wildcard $(build_dir)\/*\/spec.gmk)\n-  # Extract the configuration names from the path\n-  all_confs = $(patsubst %\/spec.gmk, %, $(patsubst $(build_dir)\/%, %, $(all_spec_files)))\n-\n-  # Check for unknown command-line variables\n-  define CheckControlVariables\n-    command_line_variables := $$(strip $$(foreach var, \\\n-        $$(subst \\ ,_,$$(MAKEOVERRIDES)), \\\n-        $$(firstword $$(subst =, , $$(var)))))\n-    allowed_command_line_variables := $$(strip $$(subst $$(COMMA), , $$(ALLOW)))\n-    unknown_command_line_variables := $$(strip \\\n-        $$(filter-out $$(ALL_CONTROL_VARIABLES) $$(allowed_command_line_variables), \\\n-        $$(command_line_variables)))\n-    ifneq ($$(unknown_command_line_variables), )\n-      $$(info Note: Command line contains non-control variables:)\n-      $$(foreach var, $$(unknown_command_line_variables), $$(info * $$(var)=$$($$(var))))\n-      $$(info Make sure it is not mistyped, and that you intend to override this variable.)\n-      $$(info 'make help' will list known control variables.)\n-      $$(info )\n-    endif\n-  endef\n-\n-  # Check for deprecated ALT_ variables\n-  define CheckDeprecatedEnvironment\n-    defined_alt_variables := $$(filter ALT_%, $$(.VARIABLES))\n-    ifneq ($$(defined_alt_variables), )\n-      $$(info Warning: You have the following ALT_ variables set:)\n-      $$(foreach var, $$(defined_alt_variables), $$(info * $$(var)=$$($$(var))))\n-      $$(info ALT_ variables are deprecated, and may result in a failed build.)\n-      $$(info Please clean your environment.)\n-      $$(info )\n-    endif\n-  endef\n-\n-  # Check for invalid make flags like -j\n-  define CheckInvalidMakeFlags\n-    # This is a trick to get this rule to execute before any other rules\n-    # MAKEFLAGS only indicate -j if read in a recipe (!)\n-    $$(topdir)\/make\/Init.gmk: .FORCE\n-\t$$(if $$(findstring --jobserver, $$(MAKEFLAGS)), \\\n-\t    $$(info Error: 'make -jN' is not supported, use 'make JOBS=N') \\\n-\t    $$(error Cannot continue) \\\n-\t)\n-    .FORCE:\n-    .PHONY: .FORCE\n-  endef\n-\n-  # Check that the CONF_CHECK option is valid and set up handling\n-  define ParseConfCheckOption\n-    ifeq ($$(CONF_CHECK), )\n-      # Default behavior is fail\n-      CONF_CHECK := fail\n-    else ifneq ($$(filter-out auto fail ignore, $$(CONF_CHECK)), )\n-      $$(info Error: CONF_CHECK must be one of: auto, fail or ignore.)\n-      $$(error Cannot continue)\n-    endif\n-  endef\n-\n-  define ParseConfAndSpec\n-    ifneq ($$(origin SPEC), undefined)\n-      # We have been given a SPEC, check that it works out properly\n-      ifneq ($$(origin CONF), undefined)\n-        # We also have a CONF argument. We can't have both.\n-        $$(info Error: Cannot use CONF=$$(CONF) and SPEC=$$(SPEC) at the same time. Choose one.)\n-        $$(error Cannot continue)\n-      endif\n-      ifneq ($$(origin CONF_NAME), undefined)\n-        # We also have a CONF_NAME argument. We can't have both.\n-        $$(info Error: Cannot use CONF_NAME=$$(CONF_NAME) and SPEC=$$(SPEC) at the same time. Choose one.)\n-        $$(error Cannot continue)\n-      endif\n-      ifeq ($$(wildcard $$(SPEC)), )\n-        $$(info Error: Cannot locate spec.gmk, given by SPEC=$$(SPEC).)\n-        $$(error Cannot continue)\n-      endif\n-      ifeq ($$(filter \/%, $$(SPEC)), )\n-        # If given with relative path, make it absolute\n-        SPECS := $$(CURDIR)\/$$(strip $$(SPEC))\n-      else\n-        SPECS := $$(SPEC)\n-      endif\n+endef\n@@ -166,2 +55,39 @@\n-      # For now, unset this SPEC variable.\n-      override SPEC :=\n+# Parse COMPARE_BUILD into COMPARE_BUILD_*\n+# Syntax: COMPARE_BUILD=CONF=<configure options>:PATCH=<patch file>:\n+#         MAKE=<make targets>:COMP_OPTS=<compare script options>:\n+#         COMP_DIR=<compare script base dir>|<default>:\n+#         FAIL=<bool>\n+# If neither CONF or PATCH is given, assume <default> means CONF if it\n+# begins with \"--\", otherwise assume it means PATCH.\n+# MAKE and COMP_OPTS can only be used with CONF and\/or PATCH specified.\n+# If any value contains \"+\", it will be replaced by space.\n+# FAIL can be set to false to have the return value of compare be ignored.\n+define ParseCompareBuild\n+  ifneq ($$(COMPARE_BUILD), )\n+    COMPARE_BUILD_OUTPUTDIR := $(topdir)\/build\/compare-build\/$(CONF_NAME)\n+    COMPARE_BUILD_FAIL := true\n+\n+    ifneq ($$(findstring :, $$(COMPARE_BUILD)), )\n+      $$(foreach part, $$(subst :, , $$(COMPARE_BUILD)), \\\n+        $$(if $$(filter PATCH=%, $$(part)), \\\n+          $$(eval COMPARE_BUILD_PATCH = $$(strip $$(patsubst PATCH=%, %, $$(part)))) \\\n+        ) \\\n+        $$(if $$(filter CONF=%, $$(part)), \\\n+          $$(eval COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(part))))) \\\n+        ) \\\n+        $$(if $$(filter MAKE=%, $$(part)), \\\n+          $$(eval COMPARE_BUILD_MAKE = $$(strip $$(subst +, , $$(patsubst MAKE=%, %, $$(part))))) \\\n+        ) \\\n+        $$(if $$(filter COMP_OPTS=%, $$(part)), \\\n+          $$(eval COMPARE_BUILD_COMP_OPTS = $$(strip $$(subst +, , $$(patsubst COMP_OPTS=%, %, $$(part))))) \\\n+        ) \\\n+        $$(if $$(filter COMP_DIR=%, $$(part)), \\\n+          $$(eval COMPARE_BUILD_COMP_DIR = $$(strip $$(subst +, , $$(patsubst COMP_DIR=%, %, $$(part))))) \\\n+        ) \\\n+        $$(if $$(filter FAIL=%, $$(part)), \\\n+          $$(eval COMPARE_BUILD_FAIL = $$(strip $$(subst +, , $$(patsubst FAIL=%, %, $$(part))))) \\\n+        ) \\\n+        $$(if $$(filter NODRYRUN=%, $$(part)), \\\n+          $$(eval COMPARE_BUILD_NODRYRUN = $$(strip $$(subst +, , $$(patsubst NODRYRUN=%, %, $$(part))))) \\\n+        ) \\\n+      )\n@@ -169,83 +95,8 @@\n-      # Use spec.gmk files in the build output directory\n-      ifeq ($$(all_spec_files), )\n-        ifneq ($(CUSTOM_ROOT), )\n-          $$(info Error: No configurations found for $$(CUSTOM_ROOT).)\n-        else\n-          $$(info Error: No configurations found for $$(topdir).)\n-        endif\n-        $$(info Please run 'bash configure' to create a configuration.)\n-        $$(info )\n-        $$(error Cannot continue)\n-      endif\n-\n-      ifneq ($$(origin CONF_NAME), undefined)\n-        ifneq ($$(origin CONF), undefined)\n-          # We also have a CONF argument. We can't have both.\n-          $$(info Error: Cannot use CONF=$$(CONF) and CONF_NAME=$$(CONF_NAME) at the same time. Choose one.)\n-          $$(error Cannot continue)\n-        endif\n-        matching_conf := $$(strip $$(filter $$(CONF_NAME), $$(all_confs)))\n-        ifeq ($$(matching_conf), )\n-          $$(info Error: No configurations found matching CONF_NAME=$$(CONF_NAME).)\n-          $$(info Available configurations in $$(build_dir):)\n-          $$(foreach var, $$(all_confs), $$(info * $$(var)))\n-          $$(error Cannot continue)\n-        else ifneq ($$(words $$(matching_conf)), 1)\n-          $$(info Error: Matching more than one configuration CONF_NAME=$$(CONF_NAME).)\n-          $$(info Available configurations in $$(build_dir):)\n-          $$(foreach var, $$(all_confs), $$(info * $$(var)))\n-          $$(error Cannot continue)\n-        else\n-          $$(info Building configuration '$$(matching_conf)' (matching CONF_NAME=$$(CONF_NAME)))\n-        endif\n-        # Create a SPEC definition. This will contain the path to exactly one spec file.\n-        SPECS := $$(build_dir)\/$$(matching_conf)\/spec.gmk\n-      else ifneq ($$(origin CONF), undefined)\n-        # User have given a CONF= argument.\n-        ifeq ($$(CONF), )\n-          # If given CONF=, match all configurations\n-          matching_confs := $$(strip $$(all_confs))\n-        else\n-          # Otherwise select those that contain the given CONF string\n-          ifeq ($$(patsubst !%,,$$(CONF)), )\n-            # A CONF starting with ! means we should negate the search term\n-            matching_confs := $$(strip $$(foreach var, $$(all_confs), \\\n-                $$(if $$(findstring $$(subst !,,$$(CONF)), $$(var)), ,$$(var))))\n-          else\n-            matching_confs := $$(strip $$(foreach var, $$(all_confs), \\\n-                $$(if $$(findstring $$(CONF), $$(var)), $$(var))))\n-          endif\n-          ifneq ($$(filter $$(CONF), $$(matching_confs)), )\n-            ifneq ($$(word 2, $$(matching_confs)), )\n-              # Don't repeat this output on make restarts caused by including\n-              # generated files.\n-              ifeq ($$(MAKE_RESTARTS), )\n-                $$(info Using exact match for CONF=$$(CONF) (other matches are possible))\n-              endif\n-            endif\n-            # If we found an exact match, use that\n-            matching_confs := $$(CONF)\n-          endif\n-        endif\n-        ifeq ($$(matching_confs), )\n-          $$(info Error: No configurations found matching CONF=$$(CONF).)\n-          $$(info Available configurations in $$(build_dir):)\n-          $$(foreach var, $$(all_confs), $$(info * $$(var)))\n-          $$(error Cannot continue)\n-        else\n-          # Don't repeat this output on make restarts caused by including\n-          # generated files.\n-          ifeq ($$(MAKE_RESTARTS), )\n-            ifeq ($$(words $$(matching_confs)), 1)\n-              ifneq ($$(findstring $$(LOG_LEVEL), info debug trace), )\n-                $$(info Building configuration '$$(matching_confs)' (matching CONF=$$(CONF)))\n-              endif\n-            else\n-              $$(info Building these configurations (matching CONF=$$(CONF)):)\n-              $$(foreach var, $$(matching_confs), $$(info * $$(var)))\n-            endif\n-          endif\n-        endif\n-\n-        # Create a SPEC definition. This will contain the path to one or more spec.gmk files.\n-        SPECS := $$(addsuffix \/spec.gmk, $$(addprefix $$(build_dir)\/, $$(matching_confs)))\n+      # Separate handling for single field case, to allow for spaces in values.\n+      ifneq ($$(filter PATCH=%, $$(COMPARE_BUILD)), )\n+        COMPARE_BUILD_PATCH = $$(strip $$(patsubst PATCH=%, %, $$(COMPARE_BUILD)))\n+      else ifneq ($$(filter CONF=%, $$(COMPARE_BUILD)), )\n+        COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(COMPARE_BUILD))))\n+      else ifneq ($$(filter --%, $$(COMPARE_BUILD)), )\n+        # Assume CONF if value begins with --\n+        COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(COMPARE_BUILD)))\n@@ -253,33 +104,2 @@\n-        # No CONF or SPEC given, check the available configurations\n-        ifneq ($$(words $$(all_spec_files)), 1)\n-          $$(info Error: No CONF given, but more than one configuration found.)\n-          $$(info Available configurations in $$(build_dir):)\n-          $$(foreach var, $$(all_confs), $$(info * $$(var)))\n-          $$(info Please retry building with CONF=<config pattern> (or SPEC=<spec file>).)\n-          $$(info )\n-          $$(error Cannot continue)\n-        endif\n-\n-        # We found exactly one configuration, use it\n-        SPECS := $$(strip $$(all_spec_files))\n-      endif\n-    endif\n-  endef\n-\n-  # Extract main targets from Main.gmk using the spec provided in $2.\n-  #\n-  # Param 1: FORCE = force generation of main-targets.gmk or LAZY = do not force.\n-  # Param 2: The SPEC file to use.\n-  define DefineMainTargets\n-\n-    # We will start by making sure the main-targets.gmk file is removed, if\n-    # make has not been restarted. By the -include, we will trigger the\n-    # rule for generating the file (which is never there since we removed it),\n-    # thus generating it fresh, and make will restart, incrementing the restart\n-    # count.\n-    main_targets_file := $$(dir $(strip $2))make-support\/main-targets.gmk\n-\n-    ifeq ($$(MAKE_RESTARTS), )\n-      # Only do this if make has not been restarted, and if we do not force it.\n-      ifeq ($(strip $1), FORCE)\n-        $$(shell rm -f $$(main_targets_file))\n+        # Otherwise assume patch file\n+        COMPARE_BUILD_PATCH = $$(strip $$(COMPARE_BUILD))\n@@ -288,105 +108,6 @@\n-\n-    $$(main_targets_file):\n-\t@( cd $$(topdir) && \\\n-\t$$(MAKE) $$(MAKE_LOG_FLAGS) -r -R -f $$(topdir)\/make\/Main.gmk \\\n-\t    -I $$(topdir)\/make\/common SPEC=$(strip $2) NO_RECIPES=true \\\n-\t    $$(MAKE_LOG_VARS) \\\n-\t    create-main-targets-include )\n-\n-    # Now include main-targets.gmk. This will define ALL_MAIN_TARGETS.\n-    -include $$(main_targets_file)\n-  endef\n-\n-  define PrintConfCheckFailed\n-\t@echo ' '\n-\t@echo \"Please rerun configure! Easiest way to do this is by running\"\n-\t@echo \"'make reconfigure'.\"\n-\t@echo \"This behavior may also be changed using CONF_CHECK=<ignore|auto>.\"\n-\t@echo ' '\n-  endef\n-\n-else # $(HAS_SPEC)=true\n-  ##############################################################################\n-  # Helper functions for the 'main' target. These functions assume a single,\n-  # proper and existing SPEC is included.\n-  ##############################################################################\n-\n-  include $(TOPDIR)\/make\/common\/MakeBase.gmk\n-\n-  # Define basic logging setup\n-  BUILD_LOG := $(OUTPUTDIR)\/build.log\n-  BUILD_PROFILE_LOG := $(OUTPUTDIR)\/build-profile.log\n-\n-  BUILD_LOG_PIPE := > >($(TEE) -a $(BUILD_LOG)) 2> >($(TEE) -a $(BUILD_LOG) >&2) && wait\n-  # Use this for simple echo\/printf commands that are never expected to print\n-  # to stderr.\n-  BUILD_LOG_PIPE_SIMPLE := | $(TEE) -a $(BUILD_LOG)\n-\n-  ifneq ($(CUSTOM_ROOT), )\n-    topdir = $(CUSTOM_ROOT)\n-  else\n-    topdir = $(TOPDIR)\n-  endif\n-\n-  # Setup the build environment to match the requested specification on\n-  # level of reproducible builds\n-  define SetupReproducibleBuild\n-    ifeq ($$(SOURCE_DATE), updated)\n-      # For static values of SOURCE_DATE (not \"updated\"), these are set in spec.gmk\n-      export SOURCE_DATE_EPOCH := $$(shell $$(DATE) +\"%s\")\n-      export SOURCE_DATE_ISO_8601 := $$(call EpochToISO8601, $$(SOURCE_DATE_EPOCH))\n-    endif\n-  endef\n-\n-  # Parse COMPARE_BUILD into COMPARE_BUILD_*\n-  # Syntax: COMPARE_BUILD=CONF=<configure options>:PATCH=<patch file>:\n-  #         MAKE=<make targets>:COMP_OPTS=<compare script options>:\n-  #         COMP_DIR=<compare script base dir>|<default>:\n-  #         FAIL=<bool>\n-  # If neither CONF or PATCH is given, assume <default> means CONF if it\n-  # begins with \"--\", otherwise assume it means PATCH.\n-  # MAKE and COMP_OPTS can only be used with CONF and\/or PATCH specified.\n-  # If any value contains \"+\", it will be replaced by space.\n-  # FAIL can be set to false to have the return value of compare be ignored.\n-  define ParseCompareBuild\n-    ifneq ($$(COMPARE_BUILD), )\n-      COMPARE_BUILD_OUTPUTDIR := $(topdir)\/build\/compare-build\/$(CONF_NAME)\n-      COMPARE_BUILD_FAIL := true\n-\n-      ifneq ($$(findstring :, $$(COMPARE_BUILD)), )\n-        $$(foreach part, $$(subst :, , $$(COMPARE_BUILD)), \\\n-          $$(if $$(filter PATCH=%, $$(part)), \\\n-            $$(eval COMPARE_BUILD_PATCH = $$(strip $$(patsubst PATCH=%, %, $$(part)))) \\\n-          ) \\\n-          $$(if $$(filter CONF=%, $$(part)), \\\n-            $$(eval COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(part))))) \\\n-          ) \\\n-          $$(if $$(filter MAKE=%, $$(part)), \\\n-            $$(eval COMPARE_BUILD_MAKE = $$(strip $$(subst +, , $$(patsubst MAKE=%, %, $$(part))))) \\\n-          ) \\\n-          $$(if $$(filter COMP_OPTS=%, $$(part)), \\\n-            $$(eval COMPARE_BUILD_COMP_OPTS = $$(strip $$(subst +, , $$(patsubst COMP_OPTS=%, %, $$(part))))) \\\n-          ) \\\n-          $$(if $$(filter COMP_DIR=%, $$(part)), \\\n-            $$(eval COMPARE_BUILD_COMP_DIR = $$(strip $$(subst +, , $$(patsubst COMP_DIR=%, %, $$(part))))) \\\n-          ) \\\n-          $$(if $$(filter FAIL=%, $$(part)), \\\n-            $$(eval COMPARE_BUILD_FAIL = $$(strip $$(subst +, , $$(patsubst FAIL=%, %, $$(part))))) \\\n-          ) \\\n-          $$(if $$(filter NODRYRUN=%, $$(part)), \\\n-            $$(eval COMPARE_BUILD_NODRYRUN = $$(strip $$(subst +, , $$(patsubst NODRYRUN=%, %, $$(part))))) \\\n-          ) \\\n-        )\n-      else\n-        # Separate handling for single field case, to allow for spaces in values.\n-        ifneq ($$(filter PATCH=%, $$(COMPARE_BUILD)), )\n-          COMPARE_BUILD_PATCH = $$(strip $$(patsubst PATCH=%, %, $$(COMPARE_BUILD)))\n-        else ifneq ($$(filter CONF=%, $$(COMPARE_BUILD)), )\n-          COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(COMPARE_BUILD))))\n-        else ifneq ($$(filter --%, $$(COMPARE_BUILD)), )\n-          # Assume CONF if value begins with --\n-          COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(COMPARE_BUILD)))\n-        else\n-          # Otherwise assume patch file\n-          COMPARE_BUILD_PATCH = $$(strip $$(COMPARE_BUILD))\n-        endif\n+    ifneq ($$(COMPARE_BUILD_PATCH), )\n+      ifneq ($$(wildcard $$(topdir)\/$$(COMPARE_BUILD_PATCH)), )\n+        # Assume relative path, if file exists\n+        COMPARE_BUILD_PATCH := $$(wildcard $$(topdir)\/$$(COMPARE_BUILD_PATCH))\n+      else ifeq ($$(wildcard $$(COMPARE_BUILD_PATCH)), )\n+        $$(error Patch file $$(COMPARE_BUILD_PATCH) does not exist)\n@@ -394,12 +115,4 @@\n-      ifneq ($$(COMPARE_BUILD_PATCH), )\n-        ifneq ($$(wildcard $$(topdir)\/$$(COMPARE_BUILD_PATCH)), )\n-          # Assume relative path, if file exists\n-          COMPARE_BUILD_PATCH := $$(wildcard $$(topdir)\/$$(COMPARE_BUILD_PATCH))\n-        else ifeq ($$(wildcard $$(COMPARE_BUILD_PATCH)), )\n-          $$(error Patch file $$(COMPARE_BUILD_PATCH) does not exist)\n-        endif\n-        ifneq ($$(COMPARE_BUILD_NODRYRUN), true)\n-          PATCH_DRY_RUN := $$(shell cd $$(topdir) && $$(PATCH) --dry-run -p1 < $$(COMPARE_BUILD_PATCH) > \/dev\/null 2>&1 || $$(ECHO) FAILED)\n-          ifeq ($$(PATCH_DRY_RUN), FAILED)\n-            $$(error Patch file $$(COMPARE_BUILD_PATCH) does not apply cleanly)\n-          endif\n+      ifneq ($$(COMPARE_BUILD_NODRYRUN), true)\n+        PATCH_DRY_RUN := $$(shell cd $$(topdir) && $$(PATCH) --dry-run -p1 < $$(COMPARE_BUILD_PATCH) > \/dev\/null 2>&1 || $$(ECHO) FAILED)\n+        ifeq ($$(PATCH_DRY_RUN), FAILED)\n+          $$(error Patch file $$(COMPARE_BUILD_PATCH) does not apply cleanly)\n@@ -408,3 +121,0 @@\n-      ifneq ($$(COMPARE_BUILD_FAIL), true)\n-        COMPARE_BUILD_IGNORE_RESULT := || true\n-      endif\n@@ -412,1 +122,5 @@\n-  endef\n+    ifneq ($$(COMPARE_BUILD_FAIL), true)\n+      COMPARE_BUILD_IGNORE_RESULT := || true\n+    endif\n+  endif\n+endef\n@@ -414,2 +128,2 @@\n-  # Prepare for a comparison rebuild\n-  define PrepareCompareBuild\n+# Prepare for a comparison rebuild\n+define PrepareCompareBuild\n@@ -433,1 +147,1 @@\n-  endef\n+endef\n@@ -435,2 +149,2 @@\n-  # Cleanup after a compare build\n-  define CleanupCompareBuild\n+# Cleanup after a compare build\n+define CleanupCompareBuild\n@@ -445,1 +159,1 @@\n-  endef\n+endef\n@@ -447,2 +161,2 @@\n-  # Do the actual comparison of two builds\n-  define CompareBuildDoComparison\n+# Do the actual comparison of two builds\n+define CompareBuildDoComparison\n@@ -458,1 +172,1 @@\n-  endef\n+endef\n@@ -460,1 +174,1 @@\n-  define PrintFailureReports\n+define PrintFailureReports\n@@ -482,1 +196,1 @@\n-  endef\n+endef\n@@ -484,1 +198,1 @@\n-  define PrintBuildLogFailures\n+define PrintBuildLogFailures\n@@ -497,1 +211,1 @@\n-  endef\n+endef\n@@ -499,1 +213,1 @@\n-  define RotateLogFiles\n+define RotateLogFiles\n@@ -506,1 +220,1 @@\n-  endef\n+endef\n@@ -508,6 +222,6 @@\n-  # Failure logs are only supported for \"parallel\" main targets, not the\n-  # (trivial) sequential make targets (such as clean and reconfigure),\n-  # since the failure-logs directory creation will conflict with clean.\n-  # We also make sure the javatmp directory exists, which is needed if a java\n-  # process (like javac) is using java.io.tmpdir.\n-  define PrepareFailureLogs\n+# Failure logs are only supported for \"parallel\" main targets, not the\n+# (trivial) sequential make targets (such as clean and reconfigure),\n+# since the failure-logs directory creation will conflict with clean.\n+# We also make sure the javatmp directory exists, which is needed if a java\n+# process (like javac) is using java.io.tmpdir.\n+define PrepareFailureLogs\n@@ -518,1 +232,1 @@\n-  endef\n+endef\n@@ -520,3 +234,3 @@\n-  # Remove any javac server logs and port files. This\n-  # prevents a new make run to reuse the previous servers.\n-  define PrepareJavacServer\n+# Remove any javac server logs and port files. This\n+# prevents a new make run to reuse the previous servers.\n+define PrepareJavacServer\n@@ -527,1 +241,1 @@\n-  endef\n+endef\n@@ -529,1 +243,1 @@\n-  define CleanupJavacServer\n+define CleanupJavacServer\n@@ -532,1 +246,1 @@\n-  endef\n+endef\n@@ -534,5 +248,5 @@\n-  ifeq ($(call isBuildOs, windows), true)\n-    # On windows we need to synchronize with the javac server to be able to\n-    # move or remove the build output directory. Since we have no proper\n-    # synchronization process, wait for a while and hope it helps. This is only\n-    # used by build comparisons.\n+ifeq ($(call isBuildOs, windows), true)\n+  # On windows we need to synchronize with the javac server to be able to\n+  # move or remove the build output directory. Since we have no proper\n+  # synchronization process, wait for a while and hope it helps. This is only\n+  # used by build comparisons.\n@@ -543,5 +257,5 @@\n-    endef\n-  else\n-    define WaitForJavacServerFinish\n-    endef\n-  endif\n+  endef\n+else\n+  define WaitForJavacServerFinish\n+  endef\n+endif\n@@ -549,3 +263,3 @@\n-  ##############################################################################\n-  # Functions for timers\n-  ##############################################################################\n+##############################################################################\n+# Functions for timers\n+##############################################################################\n@@ -553,2 +267,2 @@\n-  # Store the build times in this directory.\n-  BUILDTIMESDIR = $(OUTPUTDIR)\/make-support\/build-times\n+# Store the build times in this directory.\n+BUILDTIMESDIR = $(OUTPUTDIR)\/make-support\/build-times\n@@ -556,2 +270,2 @@\n-  # Record starting time for build of a sub repository.\n-  define RecordStartTime\n+# Record starting time for build of a sub repository.\n+define RecordStartTime\n@@ -560,1 +274,1 @@\n-  endef\n+endef\n@@ -562,4 +276,4 @@\n-  # Record ending time and calculate the difference and store it in a\n-  # easy to read format. Handles builds that cross midnight. Expects\n-  # that a build will never take 24 hours or more.\n-  define RecordEndTime\n+# Record ending time and calculate the difference and store it in a\n+# easy to read format. Handles builds that cross midnight. Expects\n+# that a build will never take 24 hours or more.\n+define RecordEndTime\n@@ -572,1 +286,1 @@\n-  endef\n+endef\n@@ -574,1 +288,1 @@\n-  define StartGlobalTimer\n+define StartGlobalTimer\n@@ -578,1 +292,1 @@\n-  endef\n+endef\n@@ -580,1 +294,1 @@\n-  define StopGlobalTimer\n+define StopGlobalTimer\n@@ -582,1 +296,1 @@\n-  endef\n+endef\n@@ -584,3 +298,3 @@\n-  # Find all build_time_* files and print their contents in a list sorted\n-  # on the name of the sub repository.\n-  define ReportBuildTimes\n+# Find all build_time_* files and print their contents in a list sorted\n+# on the name of the sub repository.\n+define ReportBuildTimes\n@@ -595,46 +309,0 @@\n-  endef\n-\n-  define ReportProfileTimes\n-    $(if $(findstring true, $(LOG_PROFILE_TIMES_LOG)), \\\n-      [ ! -f $(BUILD_PROFILE_LOG) ] || \\\n-      { $(ECHO) Begin $(notdir $(BUILD_PROFILE_LOG)) && \\\n-        $(CAT) $(BUILD_PROFILE_LOG) && \\\n-        $(ECHO) End $(notdir $(BUILD_PROFILE_LOG)); \\\n-      } \\\n-      $(BUILD_LOG_PIPE_SIMPLE)\n-    )\n-  endef\n-\n-endif # HAS_SPEC\n-\n-# Look for a given option in the LOG variable, and if found, set a variable\n-# and remove the option from the LOG variable\n-# $1: The option to look for\n-# $2: The variable to set to \"true\" if the option is found\n-define ParseLogOption\n-  ifneq ($$(findstring $1, $$(LOG)), )\n-    override $2 := true\n-    # First try to remove \",<option>\" if it exists, otherwise just remove \"<option>\"\n-    LOG_STRIPPED := $$(subst $1,, $$(subst $$(COMMA)$$(strip $1),, $$(LOG)))\n-    # We might have ended up with a leading comma. Remove it. Need override\n-    # since LOG is set from the command line.\n-    override LOG := $$(strip $$(patsubst $$(COMMA)%, %, $$(LOG_STRIPPED)))\n-  endif\n-endef\n-\n-# Look for a given option with an assignment in the LOG variable, and if found,\n-# set a variable to that value and remove the option from the LOG variable\n-# $1: The option to look for\n-# $2: The variable to set to the value of the option, if found\n-define ParseLogValue\n-  ifneq ($$(findstring $1=, $$(LOG)), )\n-    # Make words of out comma-separated list and find the one with opt=val\n-    value := $$(strip $$(subst $$(strip $1)=,, $$(filter $$(strip $1)=%, $$(subst $$(COMMA), , $$(LOG)))))\n-    override $2 := $$(value)\n-    # First try to remove \",<option>\" if it exists, otherwise just remove \"<option>\"\n-    LOG_STRIPPED := $$(subst $$(strip $1)=$$(value),, \\\n-        $$(subst $$(COMMA)$$(strip $1)=$$(value),, $$(LOG)))\n-    # We might have ended up with a leading comma. Remove it. Need override\n-    # since LOG is set from the command line.\n-    override LOG := $$(strip $$(patsubst $$(COMMA)%, %, $$(LOG_STRIPPED)))\n-  endif\n@@ -643,59 +311,9 @@\n-\n-define ParseLogLevel\n-  # Catch old-style VERBOSE= command lines.\n-  ifneq ($$(origin VERBOSE), undefined)\n-    $$(info Error: VERBOSE is deprecated. Use LOG=<warn|info|debug|trace> instead.)\n-    $$(error Cannot continue)\n-  endif\n-\n-  # Setup logging according to LOG\n-\n-  # If \"nofile\" is present, do not log to a file\n-  $$(eval $$(call ParseLogOption, nofile, LOG_NOFILE))\n-\n-  # If \"cmdline\" is present, print all executes \"important\" command lines.\n-  $$(eval $$(call ParseLogOption, cmdlines, LOG_CMDLINES))\n-\n-  # If \"report\" is present, use non-standard reporting options at build failure.\n-  $$(eval $$(call ParseLogValue, report, LOG_REPORT))\n-  ifneq ($$(LOG_REPORT), )\n-    ifeq ($$(filter $$(LOG_REPORT), none all default), )\n-      $$(info Error: LOG=report has invalid value: $$(LOG_REPORT).)\n-      $$(info Valid values: LOG=report=<none>|<all>|<default>)\n-      $$(error Cannot continue)\n-    endif\n-  endif\n-\n-  # If \"profile-to-log\" is present, write shell times in build log\n-  $$(eval $$(call ParseLogOption, profile-to-log, LOG_PROFILE_TIMES_LOG))\n-\n-  # If \"profile\" is present, write shell times in separate log file\n-  # IMPORTANT: $(ParseLogOption profile-to-log) should go first. Otherwise\n-  # parsing of 'LOG=debug,profile-to-log,nofile' ends up in the following error:\n-  # Error: LOG contains unknown option or log level: debug-to-log.\n-  $$(eval $$(call ParseLogOption, profile, LOG_PROFILE_TIMES_FILE))\n-\n-  # Treat LOG=profile-to-log as if it were LOG=profile,profile-to-log\n-  LOG_PROFILE_TIMES_FILE := $$(firstword $$(LOG_PROFILE_TIMES_FILE) $$(LOG_PROFILE_TIMES_LOG))\n-\n-  override LOG_LEVEL := $$(LOG)\n-\n-  ifeq ($$(LOG_LEVEL), )\n-    # Set LOG to \"warn\" as default if not set\n-    override LOG_LEVEL := warn\n-  endif\n-\n-  ifeq ($$(LOG_LEVEL), warn)\n-    override MAKE_LOG_FLAGS := -s\n-  else ifeq ($$(LOG_LEVEL), info)\n-    override MAKE_LOG_FLAGS := -s\n-  else ifeq ($$(LOG_LEVEL), debug)\n-    override MAKE_LOG_FLAGS :=\n-  else ifeq ($$(LOG_LEVEL), trace)\n-    override MAKE_LOG_FLAGS :=\n-  else\n-    $$(info Error: LOG contains unknown option or log level: $$(LOG).)\n-    $$(info LOG can be <level>[,<opt>[...]] where <opt> is nofile | cmdlines | profile | profile-to-log)\n-    $$(info and <level> is warn | info | debug | trace)\n-    $$(error Cannot continue)\n-  endif\n+define ReportProfileTimes\n+  $(if $(findstring true, $(LOG_PROFILE_TIMES_LOG)), \\\n+    [ ! -f $(BUILD_PROFILE_LOG) ] || \\\n+    { $(ECHO) Begin $(notdir $(BUILD_PROFILE_LOG)) && \\\n+      $(CAT) $(BUILD_PROFILE_LOG) && \\\n+      $(ECHO) End $(notdir $(BUILD_PROFILE_LOG)); \\\n+    } \\\n+    $(BUILD_LOG_PIPE_SIMPLE)\n+  )\n@@ -703,8 +321,0 @@\n-\n-MAKE_LOG_VARS = $(foreach v, \\\n-    LOG_LEVEL LOG_NOFILE LOG_CMDLINES LOG_REPORT LOG_PROFILE_TIMES_LOG \\\n-    LOG_PROFILE_TIMES_FILE, \\\n-    $v=$($v) \\\n-)\n-\n-endif # _INITSUPPORT_GMK\n","filename":"make\/InitSupport.gmk","additions":154,"deletions":544,"binary":false,"changes":698,"status":"modified"},{"patch":"@@ -0,0 +1,217 @@\n+#\n+# Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+################################################################################\n+# This file is the earliest part of the build bootstrap process (not counting\n+# Makefile that includes it). Its main responsibility is to figure out what\n+# configuration to use and pick up the corresponding SPEC file. It will then\n+# call Init.gmk with this SPEC for further bootstrapping.\n+################################################################################\n+\n+# This must be the first rule\n+default:\n+.PHONY: default\n+\n+# Inclusion of this pseudo-target will cause make to execute this file\n+# serially, regardless of -j.\n+.NOTPARALLEL:\n+\n+# Include our helper functions.\n+include $(topdir)\/make\/PreInitSupport.gmk\n+include $(topdir)\/make\/common\/LogUtils.gmk\n+\n+# Here are \"global\" targets, i.e. targets that can be executed without having\n+# a configuration. This will define ALL_GLOBAL_TARGETS.\n+include $(topdir)\/make\/Global.gmk\n+\n+# CALLED_TARGETS is the list of targets that the user provided,\n+# or \"default\" if unspecified.\n+CALLED_TARGETS := $(if $(MAKECMDGOALS), $(MAKECMDGOALS), default)\n+\n+# Extract non-global targets that require a spec file.\n+CALLED_SPEC_TARGETS := $(filter-out $(ALL_GLOBAL_TARGETS), $(CALLED_TARGETS))\n+\n+# If we have only global targets, or if we are called with -qp (assuming an\n+# external part, e.g. bash completion, is trying to understand our targets),\n+# we will skip SPEC location and the sanity checks.\n+ifeq ($(CALLED_SPEC_TARGETS), )\n+  SKIP_SPEC := true\n+endif\n+ifeq ($(findstring p, $(MAKEFLAGS))$(findstring q, $(MAKEFLAGS)), pq)\n+  SKIP_SPEC := true\n+endif\n+\n+ifneq ($(SKIP_SPEC), true)\n+\n+  ############################################################################\n+  # This is the common case: we have been called from the command line by the\n+  # user with a target that should be delegated to Main.gmk, so we need to\n+  # figure out a proper SPEC and call Init.gmk with it.\n+  ############################################################################\n+\n+  # Basic checks on environment and command line.\n+  $(eval $(call CheckControlVariables))\n+  $(eval $(call CheckDeprecatedEnvironment))\n+  $(eval $(call CheckInvalidMakeFlags))\n+\n+  # Check that CONF_CHECK is valid.\n+  $(eval $(call ParseConfCheckOption))\n+\n+  # Check that the LOG given is valid, and set LOG_LEVEL, LOG_NOFILE, MAKE_LOG_VARS and MAKE_LOG_FLAGS.\n+  $(eval $(call ParseLogLevel))\n+\n+  # After this SPECS contain 1..N spec files (otherwise ParseConfAndSpec fails).\n+  $(eval $(call ParseConfAndSpec))\n+\n+  # Extract main targets from Main.gmk using the spec(s) provided. In theory,\n+  # with multiple specs, we should find the intersection of targets provided\n+  # by all specs, but we approximate this by an arbitrary spec from the list.\n+  # This will setup ALL_MAIN_TARGETS.\n+  $(eval $(call DefineMainTargets, FORCE, $(firstword $(SPECS))))\n+\n+  # Targets provided by Init.gmk.\n+  ALL_INIT_TARGETS := print-modules print-targets print-configuration \\\n+      print-tests reconfigure pre-compare-build post-compare-build\n+\n+  # Separate called targets depending on type.\n+  INIT_TARGETS := $(filter $(ALL_INIT_TARGETS), $(CALLED_SPEC_TARGETS))\n+  MAIN_TARGETS := $(filter $(ALL_MAIN_TARGETS), $(CALLED_SPEC_TARGETS))\n+  SEQUENTIAL_TARGETS := $(filter dist-clean clean%, $(MAIN_TARGETS))\n+  PARALLEL_TARGETS := $(filter-out $(SEQUENTIAL_TARGETS), $(MAIN_TARGETS))\n+\n+  # The spec files depend on the autoconf source code. This check makes sure\n+  # the configuration is up to date after changes to configure.\n+  $(SPECS): $(wildcard $(topdir)\/make\/autoconf\/*) \\\n+          $(if $(CUSTOM_CONFIG_DIR), $(wildcard $(CUSTOM_CONFIG_DIR)\/*)) \\\n+          $(addprefix $(topdir)\/make\/conf\/, version-numbers.conf branding.conf) \\\n+          $(if $(CUSTOM_CONF_DIR), $(wildcard $(addprefix $(CUSTOM_CONF_DIR)\/, \\\n+              version-numbers.conf branding.conf)))\n+      ifeq ($(CONF_CHECK), fail)\n+\t  @echo Error: The configuration is not up to date for \\\n+\t      \"'$(lastword $(subst \/, , $(dir $@)))'.\"\n+\t  $(call PrintConfCheckFailed)\n+\t  @exit 2\n+      else ifeq ($(CONF_CHECK), auto)\n+\t  @echo Note: The configuration is not up to date for \\\n+\t      \"'$(lastword $(subst \/, , $(dir $@)))'.\"\n+\t  @( cd $(topdir) && \\\n+\t      $(MAKE) $(MFLAGS) $(MAKE_LOG_FLAGS) -r -R -f $(topdir)\/make\/Init.gmk \\\n+\t      SPEC=$@ HAS_SPEC=true ACTUAL_TOPDIR=$(topdir) \\\n+\t      -I $(topdir)\/make\/common reconfigure )\n+      else ifeq ($(CONF_CHECK), ignore)\n+        # Do nothing\n+      endif\n+\n+  # Do not let make delete spec files even if aborted while doing a reconfigure\n+  .PRECIOUS: $(SPECS)\n+\n+  # Unless reconfigure is explicitly called, let all main targets depend on\n+  # the spec files to be up to date.\n+  ifeq ($(findstring reconfigure, $(INIT_TARGETS)), )\n+    $(MAIN_TARGETS): $(SPECS)\n+  endif\n+\n+  make-info:\n+      ifneq ($(findstring $(LOG_LEVEL), info debug trace), )\n+\t  $(info Running make as '$(strip $(MAKE) $(MFLAGS) \\\n+\t      $(COMMAND_LINE_VARIABLES) $(MAKECMDGOALS))')\n+      endif\n+\n+  MAKE_INIT_WITH_SPEC_ARGUMENTS := ACTUAL_TOPDIR=$(topdir) \\\n+      USER_MAKE_VARS=\"$(USER_MAKE_VARS)\" MAKE_LOG_FLAGS=$(MAKE_LOG_FLAGS) \\\n+      $(MAKE_LOG_VARS) \\\n+      INIT_TARGETS=\"$(INIT_TARGETS)\" \\\n+      SEQUENTIAL_TARGETS=\"$(SEQUENTIAL_TARGETS)\" \\\n+      PARALLEL_TARGETS=\"$(PARALLEL_TARGETS)\"\n+\n+  # Now the init and main targets will be called, once for each SPEC. The\n+  # recipe will be run once for every target specified, but we only want to\n+  # execute the recipe a single time, hence the TARGET_DONE with a dummy\n+  # command if true.\n+  # The COMPARE_BUILD part implements special support for makefile development.\n+  $(ALL_INIT_TARGETS) $(ALL_MAIN_TARGETS): make-info\n+\t@$(if $(TARGET_DONE), \\\n+\t  true \\\n+\t, \\\n+\t  ( cd $(topdir) && \\\n+\t  $(foreach spec, $(SPECS), \\\n+\t    $(MAKE) $(MFLAGS) $(MAKE_LOG_FLAGS) -r -R -j 1 -f $(topdir)\/make\/Init.gmk \\\n+\t        SPEC=$(spec) HAS_SPEC=true $(MAKE_INIT_WITH_SPEC_ARGUMENTS) \\\n+\t        main && \\\n+\t    $(if $(and $(COMPARE_BUILD), $(PARALLEL_TARGETS)), \\\n+\t        $(MAKE) $(MFLAGS) $(MAKE_LOG_FLAGS) -r -R -f $(topdir)\/make\/Init.gmk \\\n+\t            SPEC=$(spec) HAS_SPEC=true ACTUAL_TOPDIR=$(topdir) \\\n+\t            COMPARE_BUILD=\"$(COMPARE_BUILD)\" \\\n+                    -I $(topdir)\/make\/common pre-compare-build && \\\n+\t        $(MAKE) $(MFLAGS) $(MAKE_LOG_FLAGS) -r -R -j 1 -f $(topdir)\/make\/Init.gmk \\\n+\t            SPEC=$(spec) HAS_SPEC=true $(MAKE_INIT_WITH_SPEC_ARGUMENTS) \\\n+\t            COMPARE_BUILD=\"$(COMPARE_BUILD):NODRYRUN=true\" main && \\\n+\t        $(MAKE) $(MFLAGS) $(MAKE_LOG_FLAGS) -r -R -f $(topdir)\/make\/Init.gmk \\\n+\t            SPEC=$(spec) HAS_SPEC=true ACTUAL_TOPDIR=$(topdir) \\\n+\t            COMPARE_BUILD=\"$(COMPARE_BUILD):NODRYRUN=true\" \\\n+                    -I $(topdir)\/make\/common post-compare-build && \\\n+\t    ) \\\n+\t  ) true ) \\\n+\t  $(eval TARGET_DONE=true) \\\n+\t)\n+\n+  .PHONY: $(ALL_MAIN_TARGETS) $(ALL_INIT_TARGETS)\n+\n+else # SKIP_SPEC=true\n+\n+  ############################################################################\n+  # We have only global targets, or are called with -pq (from command\n+  # completion). In this case we might not even have a configuration at all, but\n+  # still need to handle the situation gracefully even if there is no SPEC file.\n+  ############################################################################\n+\n+  ifeq ($(wildcard $(SPEC)), )\n+    # If we have no SPEC provided, we will just make a \"best effort\" target list.\n+    # First try to grab any available pre-existing main-targets.gmk.\n+    main_targets_file := $(firstword $(wildcard $(build_dir)\/*\/make-support\/main-targets.gmk))\n+    ifneq ($(main_targets_file), )\n+      # Extract the SPEC that corresponds to this main-targets.gmk file.\n+      SPEC := $(patsubst %\/make-support\/main-targets.gmk, %\/spec.gmk, $(main_targets_file))\n+    else\n+      # None found, pick an arbitrary SPEC for which to generate a file\n+      SPEC := $(firstword $(all_spec_files))\n+    endif\n+  endif\n+\n+  ifneq ($(wildcard $(SPEC)), )\n+    $(eval $(call DefineMainTargets, LAZY, $(SPEC)))\n+  else\n+    # If we have no configurations we can not provide any main targets.\n+    ALL_MAIN_TARGETS :=\n+  endif\n+\n+  ALL_TARGETS := $(sort $(ALL_GLOBAL_TARGETS) $(ALL_MAIN_TARGETS) $(ALL_INIT_TARGETS))\n+\n+  # Just list all our targets.\n+  $(ALL_TARGETS):\n+\n+  .PHONY: $(ALL_TARGETS)\n+\n+endif # $(SKIP_SPEC)!=true\n","filename":"make\/PreInit.gmk","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,295 @@\n+#\n+# Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+##############################################################################\n+# Helper functions for PreInit.gmk, the initial part of initialization before\n+# the SPEC file is loaded. Most of these functions provide parsing and setting\n+# up make options from the command-line.\n+##############################################################################\n+\n+# COMMA is defined in spec.gmk, but that is not included yet\n+COMMA := ,\n+\n+# Include the corresponding closed file, if present.\n+ifneq ($(CUSTOM_MAKE_DIR), )\n+  -include $(CUSTOM_MAKE_DIR)\/InitSupport.gmk\n+endif\n+\n+# Essential control variables that are handled by PreInit.gmk or Init.gmk\n+INIT_CONTROL_VARIABLES := LOG CONF CONF_NAME SPEC JOBS CONF_CHECK ALLOW \\\n+    COMPARE_BUILD\n+\n+# All known make control variables; these are handled in other makefiles\n+MAKE_CONTROL_VARIABLES += JDK_FILTER SPEC_FILTER \\\n+    TEST TEST_JOBS JTREG GTEST MICRO TEST_OPTS TEST_VM_OPTS TEST_DEPS\n+\n+ALL_CONTROL_VARIABLES := $(INIT_CONTROL_VARIABLES) $(MAKE_CONTROL_VARIABLES)\n+\n+# Define a simple reverse function.\n+# Should maybe move to MakeBase.gmk, but we can't include that file now.\n+reverse = \\\n+    $(if $(strip $(1)), $(call reverse, $(wordlist 2, $(words $(1)), $(1)))) \\\n+        $(firstword $(1))\n+\n+# The variable MAKEOVERRIDES contains variable assignments from the command\n+# line, but in reverse order to what the user entered.\n+# The '§' <=> '\\ 'dance is needed to keep values with space in them connected.\n+COMMAND_LINE_VARIABLES := $(subst §,\\ , $(call reverse, $(subst \\ ,§,$(MAKEOVERRIDES))))\n+\n+# A list like FOO=\"val1\" BAR=\"val2\" containing all user-supplied make\n+# variables that we should propagate.\n+# The '§' <=> '\\ 'dance is needed to keep values with space in them connected.\n+USER_MAKE_VARS := $(subst §,\\ , $(filter-out $(addsuffix =%, $(INIT_CONTROL_VARIABLES)), \\\n+    $(subst \\ ,§,$(MAKEOVERRIDES))))\n+\n+# Setup information about available configurations, if any.\n+ifneq ($(CUSTOM_ROOT), )\n+  build_dir = $(CUSTOM_ROOT)\/build\n+else\n+  build_dir = $(topdir)\/build\n+endif\n+all_spec_files = $(wildcard $(build_dir)\/*\/spec.gmk)\n+# Extract the configuration names from the path\n+all_confs = $(patsubst %\/spec.gmk, %, $(patsubst $(build_dir)\/%, %, $(all_spec_files)))\n+\n+# Check for unknown command-line variables\n+define CheckControlVariables\n+  command_line_variables := $$(strip $$(foreach var, \\\n+      $$(subst \\ ,_,$$(MAKEOVERRIDES)), \\\n+      $$(firstword $$(subst =, , $$(var)))))\n+  allowed_command_line_variables := $$(strip $$(subst $$(COMMA), , $$(ALLOW)))\n+  unknown_command_line_variables := $$(strip \\\n+      $$(filter-out $$(ALL_CONTROL_VARIABLES) $$(allowed_command_line_variables), \\\n+      $$(command_line_variables)))\n+  ifneq ($$(unknown_command_line_variables), )\n+    $$(info Note: Command line contains non-control variables:)\n+    $$(foreach var, $$(unknown_command_line_variables), $$(info * $$(var)=$$($$(var))))\n+    $$(info Make sure it is not mistyped, and that you intend to override this variable.)\n+    $$(info 'make help' will list known control variables.)\n+    $$(info )\n+  endif\n+endef\n+\n+# Check for deprecated ALT_ variables\n+define CheckDeprecatedEnvironment\n+  defined_alt_variables := $$(filter ALT_%, $$(.VARIABLES))\n+  ifneq ($$(defined_alt_variables), )\n+    $$(info Warning: You have the following ALT_ variables set:)\n+    $$(foreach var, $$(defined_alt_variables), $$(info * $$(var)=$$($$(var))))\n+    $$(info ALT_ variables are deprecated, and may result in a failed build.)\n+    $$(info Please clean your environment.)\n+    $$(info )\n+  endif\n+endef\n+\n+# Check for invalid make flags like -j\n+define CheckInvalidMakeFlags\n+  # This is a trick to get this rule to execute before any other rules\n+  # MAKEFLAGS only indicate -j if read in a recipe (!)\n+  $$(topdir)\/make\/PreInit.gmk: .FORCE\n+\t$$(if $$(findstring --jobserver, $$(MAKEFLAGS)), \\\n+\t    $$(info Error: 'make -jN' is not supported, use 'make JOBS=N') \\\n+\t    $$(error Cannot continue) \\\n+\t)\n+  .FORCE:\n+  .PHONY: .FORCE\n+endef\n+\n+# Check that the CONF_CHECK option is valid and set up handling\n+define ParseConfCheckOption\n+  ifeq ($$(CONF_CHECK), )\n+    # Default behavior is fail\n+    CONF_CHECK := fail\n+  else ifneq ($$(filter-out auto fail ignore, $$(CONF_CHECK)), )\n+    $$(info Error: CONF_CHECK must be one of: auto, fail or ignore.)\n+    $$(error Cannot continue)\n+  endif\n+endef\n+\n+define ParseConfAndSpec\n+  ifneq ($$(origin SPEC), undefined)\n+    # We have been given a SPEC, check that it works out properly\n+    ifneq ($$(origin CONF), undefined)\n+      # We also have a CONF argument. We can't have both.\n+      $$(info Error: Cannot use CONF=$$(CONF) and SPEC=$$(SPEC) at the same time. Choose one.)\n+      $$(error Cannot continue)\n+    endif\n+    ifneq ($$(origin CONF_NAME), undefined)\n+      # We also have a CONF_NAME argument. We can't have both.\n+      $$(info Error: Cannot use CONF_NAME=$$(CONF_NAME) and SPEC=$$(SPEC) at the same time. Choose one.)\n+      $$(error Cannot continue)\n+    endif\n+    ifeq ($$(wildcard $$(SPEC)), )\n+      $$(info Error: Cannot locate spec.gmk, given by SPEC=$$(SPEC).)\n+      $$(error Cannot continue)\n+    endif\n+    ifeq ($$(filter \/%, $$(SPEC)), )\n+      # If given with relative path, make it absolute\n+      SPECS := $$(CURDIR)\/$$(strip $$(SPEC))\n+    else\n+      SPECS := $$(SPEC)\n+    endif\n+\n+    # For now, unset this SPEC variable.\n+    override SPEC :=\n+  else\n+    # Use spec.gmk files in the build output directory\n+    ifeq ($$(all_spec_files), )\n+      ifneq ($(CUSTOM_ROOT), )\n+        $$(info Error: No configurations found for $$(CUSTOM_ROOT).)\n+      else\n+        $$(info Error: No configurations found for $$(topdir).)\n+      endif\n+      $$(info Please run 'bash configure' to create a configuration.)\n+      $$(info )\n+      $$(error Cannot continue)\n+    endif\n+\n+    ifneq ($$(origin CONF_NAME), undefined)\n+      ifneq ($$(origin CONF), undefined)\n+        # We also have a CONF argument. We can't have both.\n+        $$(info Error: Cannot use CONF=$$(CONF) and CONF_NAME=$$(CONF_NAME) at the same time. Choose one.)\n+        $$(error Cannot continue)\n+      endif\n+      matching_conf := $$(strip $$(filter $$(CONF_NAME), $$(all_confs)))\n+      ifeq ($$(matching_conf), )\n+        $$(info Error: No configurations found matching CONF_NAME=$$(CONF_NAME).)\n+        $$(info Available configurations in $$(build_dir):)\n+        $$(foreach var, $$(all_confs), $$(info * $$(var)))\n+        $$(error Cannot continue)\n+      else ifneq ($$(words $$(matching_conf)), 1)\n+        $$(info Error: Matching more than one configuration CONF_NAME=$$(CONF_NAME).)\n+        $$(info Available configurations in $$(build_dir):)\n+        $$(foreach var, $$(all_confs), $$(info * $$(var)))\n+        $$(error Cannot continue)\n+      else\n+        $$(info Building configuration '$$(matching_conf)' (matching CONF_NAME=$$(CONF_NAME)))\n+      endif\n+      # Create a SPEC definition. This will contain the path to exactly one spec file.\n+      SPECS := $$(build_dir)\/$$(matching_conf)\/spec.gmk\n+    else ifneq ($$(origin CONF), undefined)\n+      # User have given a CONF= argument.\n+      ifeq ($$(CONF), )\n+        # If given CONF=, match all configurations\n+        matching_confs := $$(strip $$(all_confs))\n+      else\n+        # Otherwise select those that contain the given CONF string\n+        ifeq ($$(patsubst !%,,$$(CONF)), )\n+          # A CONF starting with ! means we should negate the search term\n+          matching_confs := $$(strip $$(foreach var, $$(all_confs), \\\n+              $$(if $$(findstring $$(subst !,,$$(CONF)), $$(var)), ,$$(var))))\n+        else\n+          matching_confs := $$(strip $$(foreach var, $$(all_confs), \\\n+              $$(if $$(findstring $$(CONF), $$(var)), $$(var))))\n+        endif\n+        ifneq ($$(filter $$(CONF), $$(matching_confs)), )\n+          ifneq ($$(word 2, $$(matching_confs)), )\n+            # Don't repeat this output on make restarts caused by including\n+            # generated files.\n+            ifeq ($$(MAKE_RESTARTS), )\n+              $$(info Using exact match for CONF=$$(CONF) (other matches are possible))\n+            endif\n+          endif\n+          # If we found an exact match, use that\n+          matching_confs := $$(CONF)\n+        endif\n+      endif\n+      ifeq ($$(matching_confs), )\n+        $$(info Error: No configurations found matching CONF=$$(CONF).)\n+        $$(info Available configurations in $$(build_dir):)\n+        $$(foreach var, $$(all_confs), $$(info * $$(var)))\n+        $$(error Cannot continue)\n+      else\n+        # Don't repeat this output on make restarts caused by including\n+        # generated files.\n+        ifeq ($$(MAKE_RESTARTS), )\n+          ifeq ($$(words $$(matching_confs)), 1)\n+            ifneq ($$(findstring $$(LOG_LEVEL), info debug trace), )\n+              $$(info Building configuration '$$(matching_confs)' (matching CONF=$$(CONF)))\n+            endif\n+          else\n+            $$(info Building these configurations (matching CONF=$$(CONF)):)\n+            $$(foreach var, $$(matching_confs), $$(info * $$(var)))\n+          endif\n+        endif\n+      endif\n+\n+      # Create a SPEC definition. This will contain the path to one or more spec.gmk files.\n+      SPECS := $$(addsuffix \/spec.gmk, $$(addprefix $$(build_dir)\/, $$(matching_confs)))\n+    else\n+      # No CONF or SPEC given, check the available configurations\n+      ifneq ($$(words $$(all_spec_files)), 1)\n+        $$(info Error: No CONF given, but more than one configuration found.)\n+        $$(info Available configurations in $$(build_dir):)\n+        $$(foreach var, $$(all_confs), $$(info * $$(var)))\n+        $$(info Please retry building with CONF=<config pattern> (or SPEC=<spec file>).)\n+        $$(info )\n+        $$(error Cannot continue)\n+      endif\n+\n+      # We found exactly one configuration, use it\n+      SPECS := $$(strip $$(all_spec_files))\n+    endif\n+  endif\n+endef\n+\n+# Extract main targets from Main.gmk using the spec provided in $2.\n+#\n+# Param 1: FORCE = force generation of main-targets.gmk or LAZY = do not force.\n+# Param 2: The SPEC file to use.\n+define DefineMainTargets\n+\n+  # We will start by making sure the main-targets.gmk file is removed, if\n+  # make has not been restarted. By the -include, we will trigger the\n+  # rule for generating the file (which is never there since we removed it),\n+  # thus generating it fresh, and make will restart, incrementing the restart\n+  # count.\n+  main_targets_file := $$(dir $(strip $2))make-support\/main-targets.gmk\n+\n+  ifeq ($$(MAKE_RESTARTS), )\n+    # Only do this if make has not been restarted, and if we do not force it.\n+    ifeq ($(strip $1), FORCE)\n+      $$(shell rm -f $$(main_targets_file))\n+    endif\n+  endif\n+\n+  $$(main_targets_file):\n+\t@( cd $$(topdir) && \\\n+\t$$(MAKE) $$(MAKE_LOG_FLAGS) -r -R -f $$(topdir)\/make\/Main.gmk \\\n+\t    -I $$(topdir)\/make\/common SPEC=$(strip $2) NO_RECIPES=true \\\n+\t    $$(MAKE_LOG_VARS) \\\n+\t    create-main-targets-include )\n+\n+  # Now include main-targets.gmk. This will define ALL_MAIN_TARGETS.\n+  -include $$(main_targets_file)\n+endef\n+\n+define PrintConfCheckFailed\n+\t@echo ' '\n+\t@echo \"Please rerun configure! Easiest way to do this is by running\"\n+\t@echo \"'make reconfigure'.\"\n+\t@echo \"This behavior may also be changed using CONF_CHECK=<ignore|auto>.\"\n+\t@echo ' '\n+endef\n","filename":"make\/PreInitSupport.gmk","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n-# Initial bootstrapping, copied and stripped down from Makefile and Init.gmk\n+# Initial bootstrapping, copied and stripped down from Makefile and PreInit.gmk.\n@@ -139,1 +139,2 @@\n-include $(TOPDIR)\/make\/InitSupport.gmk\n+include $(TOPDIR)\/make\/PreInitSupport.gmk\n+include $(TOPDIR)\/make\/common\/LogUtils.gmk\n","filename":"make\/RunTestsPrebuilt.gmk","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+#\n+# Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+################################################################################\n+# This file contains helper functions for logging.\n+################################################################################\n+\n+# Look for a given option in the LOG variable, and if found, set a variable\n+# and remove the option from the LOG variable\n+# $1: The option to look for\n+# $2: The variable to set to \"true\" if the option is found\n+define ParseLogOption\n+  ifneq ($$(findstring $1, $$(LOG)), )\n+    override $2 := true\n+    # First try to remove \",<option>\" if it exists, otherwise just remove \"<option>\"\n+    LOG_STRIPPED := $$(subst $1,, $$(subst $$(COMMA)$$(strip $1),, $$(LOG)))\n+    # We might have ended up with a leading comma. Remove it. Need override\n+    # since LOG is set from the command line.\n+    override LOG := $$(strip $$(patsubst $$(COMMA)%, %, $$(LOG_STRIPPED)))\n+  endif\n+endef\n+\n+# Look for a given option with an assignment in the LOG variable, and if found,\n+# set a variable to that value and remove the option from the LOG variable\n+# $1: The option to look for\n+# $2: The variable to set to the value of the option, if found\n+define ParseLogValue\n+  ifneq ($$(findstring $1=, $$(LOG)), )\n+    # Make words of out comma-separated list and find the one with opt=val\n+    value := $$(strip $$(subst $$(strip $1)=,, $$(filter $$(strip $1)=%, $$(subst $$(COMMA), , $$(LOG)))))\n+    override $2 := $$(value)\n+    # First try to remove \",<option>\" if it exists, otherwise just remove \"<option>\"\n+    LOG_STRIPPED := $$(subst $$(strip $1)=$$(value),, \\\n+        $$(subst $$(COMMA)$$(strip $1)=$$(value),, $$(LOG)))\n+    # We might have ended up with a leading comma. Remove it. Need override\n+    # since LOG is set from the command line.\n+    override LOG := $$(strip $$(patsubst $$(COMMA)%, %, $$(LOG_STRIPPED)))\n+  endif\n+endef\n+\n+define ParseLogLevel\n+  # Catch old-style VERBOSE= command lines.\n+  ifneq ($$(origin VERBOSE), undefined)\n+    $$(info Error: VERBOSE is deprecated. Use LOG=<warn|info|debug|trace> instead.)\n+    $$(error Cannot continue)\n+  endif\n+\n+  # Setup logging according to LOG\n+\n+  # If \"nofile\" is present, do not log to a file\n+  $$(eval $$(call ParseLogOption, nofile, LOG_NOFILE))\n+\n+  # If \"cmdline\" is present, print all executes \"important\" command lines.\n+  $$(eval $$(call ParseLogOption, cmdlines, LOG_CMDLINES))\n+\n+  # If \"report\" is present, use non-standard reporting options at build failure.\n+  $$(eval $$(call ParseLogValue, report, LOG_REPORT))\n+  ifneq ($$(LOG_REPORT), )\n+    ifeq ($$(filter $$(LOG_REPORT), none all default), )\n+      $$(info Error: LOG=report has invalid value: $$(LOG_REPORT).)\n+      $$(info Valid values: LOG=report=<none>|<all>|<default>)\n+      $$(error Cannot continue)\n+    endif\n+  endif\n+\n+  # If \"profile-to-log\" is present, write shell times in build log\n+  $$(eval $$(call ParseLogOption, profile-to-log, LOG_PROFILE_TIMES_LOG))\n+\n+  # If \"profile\" is present, write shell times in separate log file\n+  # IMPORTANT: $(ParseLogOption profile-to-log) should go first. Otherwise\n+  # parsing of 'LOG=debug,profile-to-log,nofile' ends up in the following error:\n+  # Error: LOG contains unknown option or log level: debug-to-log.\n+  $$(eval $$(call ParseLogOption, profile, LOG_PROFILE_TIMES_FILE))\n+\n+  # Treat LOG=profile-to-log as if it were LOG=profile,profile-to-log\n+  LOG_PROFILE_TIMES_FILE := $$(firstword $$(LOG_PROFILE_TIMES_FILE) $$(LOG_PROFILE_TIMES_LOG))\n+\n+  override LOG_LEVEL := $$(LOG)\n+\n+  ifeq ($$(LOG_LEVEL), )\n+    # Set LOG to \"warn\" as default if not set\n+    override LOG_LEVEL := warn\n+  endif\n+\n+  ifeq ($$(LOG_LEVEL), warn)\n+    override MAKE_LOG_FLAGS := -s\n+  else ifeq ($$(LOG_LEVEL), info)\n+    override MAKE_LOG_FLAGS := -s\n+  else ifeq ($$(LOG_LEVEL), debug)\n+    override MAKE_LOG_FLAGS :=\n+  else ifeq ($$(LOG_LEVEL), trace)\n+    override MAKE_LOG_FLAGS :=\n+  else\n+    $$(info Error: LOG contains unknown option or log level: $$(LOG).)\n+    $$(info LOG can be <level>[,<opt>[...]] where <opt> is nofile | cmdlines | profile | profile-to-log)\n+    $$(info and <level> is warn | info | debug | trace)\n+    $$(error Cannot continue)\n+  endif\n+endef\n+\n+MAKE_LOG_VARS = $(foreach v, \\\n+    LOG_LEVEL LOG_NOFILE LOG_CMDLINES LOG_REPORT LOG_PROFILE_TIMES_LOG \\\n+    LOG_PROFILE_TIMES_FILE, \\\n+    $v=$($v) \\\n+)\n","filename":"make\/common\/LogUtils.gmk","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"}]}