{"files":[{"patch":"@@ -1345,2 +1345,0 @@\n-      __ ldr(rscratch1, Address(klass_RInfo, int64_t(k->super_check_offset())));\n-      __ cmp(k_RInfo, rscratch1);\n@@ -1348,0 +1346,2 @@\n+        __ ldr(rscratch1, Address(klass_RInfo, int64_t(k->super_check_offset())));\n+        __ cmp(k_RInfo, rscratch1);\n@@ -1351,2 +1351,6 @@\n-        \/\/ See if we get an immediate positive hit\n-        __ br(Assembler::EQ, *success_target);\n+        if (UseSecondarySupersCache) {\n+          \/\/ See if we get an immediate positive hit\n+          __ ldr(rscratch1, Address(klass_RInfo, int64_t(k->super_check_offset())));\n+          __ cmp(k_RInfo, rscratch1);\n+          __ br(Assembler::EQ, *success_target);\n+        }\n@@ -1357,0 +1361,5 @@\n+        if (UseSecondarySupersTable) {\n+          const FloatRegister vtemp = op->tmp4()->as_double_reg();\n+          lookup_secondary_supers_table((Klass*)(k->constant_encoding()),\n+                                        klass_RInfo, k_RInfo, vtemp, Rtmp1, rscratch1, success, failure);\n+        }\n@@ -1379,0 +1388,60 @@\n+void LIR_Assembler::lookup_secondary_supers_table(Klass *super_klass, Register r_sub_klass,\n+                                                  Register r_super_klass,\n+                                                  FloatRegister vtemp, Register rtemp, Register r_array_index,\n+                                                  Label* success_target, Label* failure_target) {\n+  __ block_comment(\"Hashed check_klass_subtype_slow_path {\");\n+\n+  \/\/ __ call_VM_leaf(CAST_FROM_FN_PTR(address, &poo), 0);\n+  const Register r_bitmap = rtemp;\n+\n+  \/\/ We're going to need the bitmap in a vector reg and in a core reg,\n+  \/\/ so load both now.\n+  __ ldr(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+  if (super_klass->hash_slot() != 0) {\n+    __ ldrd(vtemp, Address(r_sub_klass, Klass::bitmap_offset()));\n+  }\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  u1 bit = super_klass->hash_slot();\n+  {\n+    Label keep_going;\n+    __ tbnz(r_bitmap, bit, keep_going);\n+    __ b(*failure_target);\n+    __ bind(keep_going);\n+  }\n+\n+  \/\/ \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  if (bit != 0) {\n+    __ shld(vtemp, vtemp, Klass::SECONDARY_SUPERS_TABLE_MASK - bit);\n+    __ cnt(vtemp, __ T8B, vtemp);\n+    __ addv(vtemp, __ T8B, vtemp);\n+    __ fmovd(r_array_index, vtemp);\n+  } else {\n+    __ mov(r_array_index, (u1)1);\n+  }\n+\n+  \/\/ \/\/ We will consult the secondary-super array.\n+  __ ldr(rscratch2, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the\n+  \/\/ data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  __ ldr(rscratch2, Address(rscratch2, r_array_index, Address::lsl(LogBytesPerWord)));\n+  __ cmp(rscratch2, r_super_klass);\n+  __ br(__ EQ, *success_target); \/\/ Found a match\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  {\n+    Label keep_going;\n+    __ tbnz(r_bitmap, (bit+1) & Klass::SECONDARY_SUPERS_TABLE_MASK, keep_going);\n+    __ b(*failure_target);\n+    __ bind(keep_going);\n+  }\n+\n+  __ block_comment(\"} hashed check_klass_subtype_slow_path\");\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":73,"deletions":4,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -87,0 +87,5 @@\n+void lookup_secondary_supers_table(Klass *super_klass,\n+                                   Register r_sub_klass, Register r_super_klass,\n+                                   FloatRegister vtemp, Register rtemp, Register r_array_index,\n+                                   Label* success, Label* failure);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -303,1 +303,2 @@\n-    __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);\n+    LIR_Opr tmp4 = new_register(doubleType);\n+    __ store_check(value, array, tmp1, tmp2, tmp3, tmp4, store_check_info, profiled_method, profiled_bci);\n@@ -1276,0 +1277,1 @@\n+  LIR_Opr vtmp = LIR_OprFact::illegalOpr;\n@@ -1279,0 +1281,4 @@\n+  if (UseSecondarySupersTable) {\n+    vtmp = new_register(doubleType);\n+  }\n+\n@@ -1280,1 +1286,1 @@\n-               new_register(objectType), new_register(objectType), tmp3,\n+               new_register(objectType), new_register(objectType), tmp3, vtmp,\n@@ -1297,0 +1303,1 @@\n+  LIR_Opr vtmp = LIR_OprFact::illegalOpr;\n@@ -1300,0 +1307,3 @@\n+  if (UseSecondarySupersTable) {\n+    vtmp = new_register(doubleType);\n+  }\n@@ -1301,1 +1311,1 @@\n-                new_register(objectType), new_register(objectType), tmp3,\n+                new_register(objectType), new_register(objectType), tmp3, vtmp,\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -8471,0 +8471,1 @@\n+#ifdef COMPILER2\n@@ -8480,0 +8481,1 @@\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -81,1 +82,1 @@\n-static void select_different_registers(Register preserve,\n+ void select_different_registers(Register preserve,\n@@ -1656,0 +1657,4 @@\n+void poo() {\n+  asm(\"nop\");\n+}\n+\n@@ -1689,1 +1694,1 @@\n-  if (k->is_loaded() && !UseCompressedClassPointers) {\n+  if (k->is_loaded() && !UseCompressedClassPointers && !UseSecondarySupersTable) {\n@@ -1758,0 +1763,1 @@\n+      if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k->super_check_offset()) {\n@@ -1763,1 +1769,0 @@\n-      if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k->super_check_offset()) {\n@@ -1768,1 +1773,8 @@\n-        __ jcc(Assembler::equal, *success_target);\n+        if (UseSecondarySupersCache) {\n+#ifdef _LP64\n+      __ cmpptr(k_RInfo, Address(klass_RInfo, k->super_check_offset()));\n+#else\n+      __ cmpklass(Address(klass_RInfo, k->super_check_offset()), k->constant_encoding());\n+#endif \/\/ _LP64\n+          __ jcc(Assembler::equal, *success_target);\n+        }\n@@ -1777,0 +1789,7 @@\n+#ifdef _LP64\n+        if (UseSecondarySupersTable && UsePopCountInstruction) {\n+          lookup_secondary_supers_table((Klass*)(k->constant_encoding()), klass_RInfo,\n+                                        k_RInfo, Rtmp1, rscratch1, success, failure);\n+        }\n+#endif \/\/ LP64\n+\n@@ -1809,0 +1828,57 @@\n+void LIR_Assembler::lookup_secondary_supers_table(Klass *super_klass, Register r_sub_klass,\n+                                                  Register r_super_klass,\n+                                                  Register Rtmp1, Register r_array_index,\n+                                                  Label* success, Label* failure) {\n+#ifdef _LP64\n+  __ block_comment(\"hashed check_klass_subtype_slow_path {\");\n+\n+  assert_different_registers(r_sub_klass, r_super_klass, Rtmp1, r_array_index);\n+\n+  __ movq(r_array_index, Address(r_sub_klass, Klass::bitmap_offset()));\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  u1 bit = super_klass->hash_slot();\n+  {\n+    \/\/ NB: If the count in a x86 shift instruction is 0, the flags are\n+    \/\/ not affected, so we do a testq instead.\n+    int shift_count = Klass::SECONDARY_SUPERS_TABLE_MASK - bit;\n+    if (shift_count != 0) {\n+      __ salq(r_array_index, shift_count);\n+    } else {\n+      __ testq(r_array_index, r_array_index);\n+    }\n+  }  \/\/ We test the MSB of r_array_index, i.e. its sign bit\n+  __ jcc(Assembler::positive, *failure);\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  if (bit != 0) {\n+    __ popcntq(r_array_index, r_array_index);\n+  } else {\n+    __ movl(r_array_index, (u1)1);\n+  }\n+\n+  \/\/ We will consult the secondary-super array.\n+  __ movptr(Rtmp1, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ We're asserting that the first word in an Array<Klass*> is the\n+  \/\/ length, and the second word is the first word of the data. If\n+  \/\/ that ever changes, r_array_base will have to be adjusted here.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  __ cmpq(r_super_klass, Address(Rtmp1, r_array_index, Address::times_8));\n+  __ jcc(Assembler::equal, *success);\n+\n+  \/\/ Is there another entry to check? Consult the bitmap again.\n+  __ movq(Rtmp1, Address(r_sub_klass, Klass::bitmap_offset()));\n+  __ btq(Rtmp1, (bit + 1) & Klass::SECONDARY_SUPERS_TABLE_MASK);\n+  __ jcc(Assembler::carryClear, *failure);\n+\n+  \/\/ Neither success or failure. Fall through to continue searching.\n+\n+  __ block_comment(\"} hashed check_klass_subtype_slow_path\");\n+\n+#endif \/\/ _LP64\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":80,"deletions":4,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -70,0 +70,5 @@\n+void lookup_secondary_supers_table(Klass *super_klass,\n+                                   Register r_sub_klass, Register r_super_klass,\n+                                   Register r_tmp1, Register r_tmp2,\n+                                   Label* success, Label* failure);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1458,0 +1458,4 @@\n+  LIR_Opr tmp4 = LIR_OprFact::illegalOpr;\n+  if (UseSecondarySupersTable) {\n+    tmp4 = new_register(addressType);\n+  }\n@@ -1459,1 +1463,1 @@\n-               new_register(objectType), new_register(objectType), tmp3,\n+               new_register(objectType), new_register(objectType), tmp3, tmp4,\n@@ -1480,0 +1484,4 @@\n+  LIR_Opr tmp4 = LIR_OprFact::illegalOpr;\n+  if (UseSecondarySupersTable) {\n+    tmp4 = new_register(addressType);\n+  }\n@@ -1481,1 +1489,1 @@\n-                new_register(objectType), new_register(objectType), tmp3,\n+                new_register(objectType), new_register(objectType), tmp3, tmp4,\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-                                 LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,\n+                                 LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, LIR_Opr tmp4,\n@@ -301,0 +301,1 @@\n+  , _tmp4(tmp4)\n@@ -320,1 +321,1 @@\n-LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception)\n+LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, LIR_Opr tmp4, CodeEmitInfo* info_for_exception)\n@@ -328,0 +329,1 @@\n+  , _tmp4(tmp4)\n@@ -837,0 +839,1 @@\n+      if (opTypeCheck->_tmp4->is_valid())         do_temp(opTypeCheck->_tmp4);\n@@ -1447,1 +1450,1 @@\n-                          LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,\n+                          LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, LIR_Opr tmp4, bool fast_check,\n@@ -1451,1 +1454,1 @@\n-                                           tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub);\n+                                           tmp1, tmp2, tmp3, tmp4, fast_check, info_for_exception, info_for_patch, stub);\n@@ -1460,2 +1463,2 @@\n-void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {\n-  LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, nullptr, info_for_patch, nullptr);\n+void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, LIR_Opr tmp4, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {\n+  LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, tmp4, fast_check, nullptr, info_for_patch, nullptr);\n@@ -1471,1 +1474,1 @@\n-void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,\n+void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, LIR_Opr tmp4,\n@@ -1473,1 +1476,1 @@\n-  LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, info_for_exception);\n+  LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, tmp4, info_for_exception);\n@@ -2013,0 +2016,1 @@\n+  tmp4()->print(out);                    out->print(\" \");\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1547,0 +1547,1 @@\n+  LIR_Opr       _tmp4;\n@@ -1557,2 +1558,3 @@\n-                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,\n-                  CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub);\n+                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, LIR_Opr tmp4,\n+                  bool fast_check, CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch,\n+                  CodeStub* stub);\n@@ -1560,1 +1562,1 @@\n-                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception);\n+                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, LIR_Opr tmp4, CodeEmitInfo* info_for_exception);\n@@ -1567,0 +1569,1 @@\n+  LIR_Opr tmp4() const                           { return _tmp4;           }\n@@ -2360,2 +2363,13 @@\n-  void instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci);\n-  void store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci);\n+  void instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, LIR_Opr tmp4, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci);\n+  void instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,\n+                  bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {\n+    instanceof(result, object, klass, tmp1, tmp2, tmp3, LIR_Opr::illegalOpr(),\n+               fast_check, info_for_patch, profiled_method, profiled_bci);\n+  }\n+\n+  void store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, LIR_Opr tmp4, CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci);\n+  void store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,\n+                   CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci) {\n+    store_check(object, array, tmp1, tmp2, tmp3, LIR_Opr::illegalOpr(),\n+                info_for_exception, profiled_method, profiled_bci);\n+  }\n@@ -2364,1 +2378,1 @@\n-                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,\n+                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, LIR_Opr tmp4, bool fast_check,\n@@ -2367,0 +2381,9 @@\n+  void checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,\n+                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,\n+                  CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,\n+                  ciMethod* profiled_method, int profiled_bci){\n+    checkcast(result, object, klass, tmp1, tmp2, tmp3, LIR_Opr::illegalOpr(), fast_check,\n+              info_for_exception, info_for_patch, stub,\n+              profiled_method, profiled_bci);\n+  }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"}]}