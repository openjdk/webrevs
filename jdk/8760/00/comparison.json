{"files":[{"patch":"@@ -107,1 +107,1 @@\n-      if (_cb->is_nmethod() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_nmethod() || _cb->is_adapter_blob() || _cb->is_runtime_stub() || _cb->is_mh_intrinsic()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1149,0 +1149,23 @@\n+CodeBlob* SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler* masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType* in_sig_bt,\n+                                                                  VMRegPair* in_regs,\n+                                                                  BasicType ret_type) {\n+  assert(method->is_method_handle_intrinsic(), \"should be MH method\");\n+  assert(method->is_native(), \"should be native method\");\n+  vmIntrinsics::ID iid = method->intrinsic_id();\n+  intptr_t start = (intptr_t)__ pc();\n+\n+  \/\/ First instruction must be a nop as it may need to be patched on deoptimisation\n+  __ nop();\n+  gen_special_dispatch(masm,\n+                       method,\n+                       in_sig_bt,\n+                       in_regs);\n+  int frame_complete = ((intptr_t)__ pc()) - start;  \/\/ not complete, period\n+  __ flush();\n+  int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ no out slots at all, actually\n+  return MethodHandleIntrinsicBlob::create(method, masm->code());\n+}\n+\n@@ -1171,0 +1194,1 @@\n+  assert(!method->is_method_handle_intrinsic(), \"must not be MethodHandle intrinsic\");\n@@ -1201,25 +1225,0 @@\n-\n-  if (method->is_method_handle_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t)__ pc();\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n-\n-    \/\/ First instruction must be a nop as it may need to be patched on deoptimisation\n-    __ nop();\n-    gen_special_dispatch(masm,\n-                         method,\n-                         in_sig_bt,\n-                         in_regs);\n-    int frame_complete = ((intptr_t)__ pc()) - start;  \/\/ not complete, period\n-    __ flush();\n-    int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ no out slots at all, actually\n-    return nmethod::new_native_nmethod(method,\n-                                       compile_id,\n-                                       masm->code(),\n-                                       vep_offset,\n-                                       frame_complete,\n-                                       stack_slots \/ VMRegImpl::slots_per_word,\n-                                       in_ByteSize(-1),\n-                                       in_ByteSize(-1),\n-                                       (OopMapSet*)NULL);\n-  }\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub() || _cb->is_mh_intrinsic()) {\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -742,0 +742,18 @@\n+CodeBlob* SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler* masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType* in_sig_bt,\n+                                                                  VMRegPair* in_regs,\n+                                                                  BasicType ret_type) {\n+  assert(method->is_method_handle_intrinsic(), \"must be MethodHandle intrinsic\");\n+\n+  vmIntrinsics::ID iid = method->intrinsic_id();\n+  intptr_t start = (intptr_t)__ pc();\n+  gen_special_dispatch(masm,\n+                       method,\n+                       in_sig_bt,\n+                       in_regs);\n+  __ flush();\n+  return MethodHandleIntrinsicBlob::create(method, masm->code());\n+}\n+\n@@ -754,21 +772,1 @@\n-  if (method->is_method_handle_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t)__ pc();\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n-    gen_special_dispatch(masm,\n-                         method,\n-                         in_sig_bt,\n-                         in_regs);\n-    int frame_complete = ((intptr_t)__ pc()) - start;  \/\/ not complete, period\n-    __ flush();\n-    int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ no out slots at all, actually\n-    return nmethod::new_native_nmethod(method,\n-                                       compile_id,\n-                                       masm->code(),\n-                                       vep_offset,\n-                                       frame_complete,\n-                                       stack_slots \/ VMRegImpl::slots_per_word,\n-                                       in_ByteSize(-1),\n-                                       in_ByteSize(-1),\n-                                       (OopMapSet*)NULL);\n-  }\n+  assert(!method->is_method_handle_intrinsic(), \"must not be MethodHandle intrinsic\");\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub() || _cb->is_mh_intrinsic()) {\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1620,0 +1620,18 @@\n+CodeBlob *SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler *masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType *in_sig_bt,\n+                                                                  VMRegPair *in_regs,\n+                                                                  BasicType ret_type) {\n+  assert(method->is_method_handle_intrinsic(), \"must be MethodHandle intrinsic\");\n+\n+  vmIntrinsics::ID iid = method->intrinsic_id();\n+  intptr_t start = (intptr_t)__ pc();\n+  gen_special_dispatch(masm,\n+                       method,\n+                       in_sig_bt,\n+                       in_regs);\n+  __ flush();\n+  return MethodHandleIntrinsicBlob::create(method, masm->code());\n+}\n+\n@@ -1642,21 +1660,1 @@\n-  if (method->is_method_handle_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t)__ pc();\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n-    gen_special_dispatch(masm,\n-                         method,\n-                         in_sig_bt,\n-                         in_regs);\n-    int frame_complete = ((intptr_t)__ pc()) - start;  \/\/ not complete, period\n-    __ flush();\n-    int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ no out slots at all, actually\n-    return nmethod::new_native_nmethod(method,\n-                                       compile_id,\n-                                       masm->code(),\n-                                       vep_offset,\n-                                       frame_complete,\n-                                       stack_slots \/ VMRegImpl::slots_per_word,\n-                                       in_ByteSize(-1),\n-                                       in_ByteSize(-1),\n-                                       (OopMapSet*)NULL);\n-  }\n+  assert(!method->is_method_handle_intrinsic(), \"must not be MethodHandle intrinsic\");\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-      if (_cb->is_nmethod() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_nmethod() || _cb->is_adapter_blob() || _cb->is_runtime_stub() || _cb->is_mh_intrinsic()) {\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1115,0 +1115,21 @@\n+CodeBlob* SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler* masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType* in_sig_bt,\n+                                                                  VMRegPair* in_regs,\n+                                                                  BasicType ret_type) {\n+  assert(method->is_method_handle_intrinsic(), \"must be MethodHandle intrinsic\");\n+\n+  vmIntrinsics::ID iid = method->intrinsic_id();\n+  intptr_t start = (intptr_t)__ pc();\n+\n+  \/\/ First instruction must be a nop as it may need to be patched on deoptimisation\n+  __ nop();\n+  gen_special_dispatch(masm,\n+                       method,\n+                       in_sig_bt,\n+                       in_regs);\n+  __ flush();\n+  return MethodHandleIntrinsicBlob::create(method, masm->code());\n+}\n+\n@@ -1149,24 +1170,1 @@\n-  if (method->is_method_handle_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t)__ pc();\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n-\n-    \/\/ First instruction must be a nop as it may need to be patched on deoptimisation\n-    __ nop();\n-    gen_special_dispatch(masm,\n-                         method,\n-                         in_sig_bt,\n-                         in_regs);\n-    int frame_complete = ((intptr_t)__ pc()) - start;  \/\/ not complete, period\n-    __ flush();\n-    int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ no out slots at all, actually\n-    return nmethod::new_native_nmethod(method,\n-                                       compile_id,\n-                                       masm->code(),\n-                                       vep_offset,\n-                                       frame_complete,\n-                                       stack_slots \/ VMRegImpl::slots_per_word,\n-                                       in_ByteSize(-1),\n-                                       in_ByteSize(-1),\n-                                       (OopMapSet*)NULL);\n-  }\n+  assert(!method->is_method_handle_intrinsic(), \"must not be MethodHandle intrinsic\");\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-      if (_cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_adapter_blob() || _cb->is_runtime_stub() || _cb->is_mh_intrinsic()) {\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1293,0 +1293,20 @@\n+CodeBlob *SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler *masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType *in_sig_bt,\n+                                                                  VMRegPair *in_regs,\n+                                                                  BasicType ret_type) {\n+  assert(method->is_method_handle_intrinsic(), \"must be MethodHandle intrinsic\");\n+\n+  int total_in_args = method->size_of_parameters();\n+  vmIntrinsics::ID iid = method->intrinsic_id();\n+  intptr_t start = (intptr_t) __ pc();\n+\n+  gen_special_dispatch(masm, total_in_args,\n+                       method->intrinsic_id(), in_sig_bt, in_regs);\n+\n+  __ flush();\n+\n+  return MethodHandleIntrinsicBlob::create(method, masm->code());\n+}\n+\n@@ -1303,0 +1323,1 @@\n+  assert(!method->is_method_handle_intrinsic(), \"must not be MethodHandle intrinsic\");\n@@ -1304,25 +1325,0 @@\n-  if (method->is_method_handle_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t) __ pc();\n-    int vep_offset = ((intptr_t) __ pc()) - start;\n-\n-    gen_special_dispatch(masm, total_in_args,\n-                         method->intrinsic_id(), in_sig_bt, in_regs);\n-\n-    int frame_complete = ((intptr_t)__ pc()) - start; \/\/ Not complete, period.\n-\n-    __ flush();\n-\n-    int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ No out slots at all, actually.\n-\n-    return nmethod::new_native_nmethod(method,\n-                                       compile_id,\n-                                       masm->code(),\n-                                       vep_offset,\n-                                       frame_complete,\n-                                       stack_slots \/ VMRegImpl::slots_per_word,\n-                                       in_ByteSize(-1),\n-                                       in_ByteSize(-1),\n-                                       (OopMapSet *) NULL);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":21,"deletions":25,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub() || _cb->is_mh_intrinsic()) {\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1319,0 +1319,18 @@\n+CodeBlob* SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler* masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType* in_sig_bt,\n+                                                                  VMRegPair* in_regs,\n+                                                                  BasicType ret_type) {\n+  assert(method->is_method_handle_intrinsic(), \"must be MethodHandle intrinsic\");\n+\n+  vmIntrinsics::ID iid = method->intrinsic_id();\n+  intptr_t start = (intptr_t)__ pc();\n+  gen_special_dispatch(masm,\n+                       method,\n+                       in_sig_bt,\n+                       in_regs);\n+  __ flush();\n+  return MethodHandleIntrinsicBlob::create(method, masm->code());\n+}\n+\n@@ -1342,21 +1360,1 @@\n-  if (method->is_method_handle_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t)__ pc();\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n-    gen_special_dispatch(masm,\n-                         method,\n-                         in_sig_bt,\n-                         in_regs);\n-    int frame_complete = ((intptr_t)__ pc()) - start;  \/\/ not complete, period\n-    __ flush();\n-    int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ no out slots at all, actually\n-    return nmethod::new_native_nmethod(method,\n-                                       compile_id,\n-                                       masm->code(),\n-                                       vep_offset,\n-                                       frame_complete,\n-                                       stack_slots \/ VMRegImpl::slots_per_word,\n-                                       in_ByteSize(-1),\n-                                       in_ByteSize(-1),\n-                                       (OopMapSet*)NULL);\n-  }\n+  assert(!method->is_method_handle_intrinsic(), \"must not be MethodHandle intrinsic\");\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1419,0 +1419,18 @@\n+CodeBlob* SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler* masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType* in_sig_bt,\n+                                                                  VMRegPair* in_regs,\n+                                                                  BasicType ret_type) {\n+  assert(method->is_method_handle_intrinsic(), \"must be MethodHandle intrinsic\");\n+\n+  vmIntrinsics::ID iid = method->intrinsic_id();\n+  intptr_t start = (intptr_t)__ pc();\n+  gen_special_dispatch(masm,\n+                       method,\n+                       in_sig_bt,\n+                       in_regs);\n+  __ flush();\n+  return MethodHandleIntrinsicBlob::create(method, masm->code());\n+}\n+\n@@ -1441,0 +1459,1 @@\n+  assert(!method->is_method_handle_intrinsic(), \"must not be MethodHandle intrinsic\");\n@@ -1471,22 +1490,0 @@\n-\n-  if (method->is_method_handle_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t)__ pc();\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n-    gen_special_dispatch(masm,\n-                         method,\n-                         in_sig_bt,\n-                         in_regs);\n-    int frame_complete = ((intptr_t)__ pc()) - start;  \/\/ not complete, period\n-    __ flush();\n-    int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ no out slots at all, actually\n-    return nmethod::new_native_nmethod(method,\n-                                       compile_id,\n-                                       masm->code(),\n-                                       vep_offset,\n-                                       frame_complete,\n-                                       stack_slots \/ VMRegImpl::slots_per_word,\n-                                       in_ByteSize(-1),\n-                                       in_ByteSize(-1),\n-                                       (OopMapSet*)NULL);\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":19,"deletions":22,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -81,0 +81,10 @@\n+CodeBlob *SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler *masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType *sig_bt,\n+                                                                  VMRegPair *regs,\n+                                                                  BasicType ret_type) {\n+  ShouldNotCallThis();\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1168,1 +1168,2 @@\n-          CompiledMethod* old = method->code();\n+          CodeBlob* old_blob = method->code();\n+          CompiledMethod* old = (old_blob == nullptr) ? nullptr : old_blob->as_compiled_method();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1128,3 +1128,4 @@\n-                     CompiledMethod* code = get_Method()->code();\n-                     if (code != NULL && (code->comp_level() == CompLevel_full_optimization)) {\n-                       _instructions_size = code->insts_end() - code->verified_entry_point();\n+                     CodeBlob* code = get_Method()->code();\n+                     CompiledMethod* cm = (code == nullptr) ? nullptr : code->as_compiled_method_or_null();\n+                     if (cm != NULL && (cm->comp_level() == CompLevel_full_optimization)) {\n+                       _instructions_size = cm->insts_end() - cm->verified_entry_point();\n@@ -1143,3 +1144,3 @@\n-    CompiledMethod* code = get_Method()->code();\n-    if (code != NULL) {\n-      code->log_identity(log);\n+    CodeBlob* code = get_Method()->code();\n+    if (code != NULL && code->is_compiled()) {\n+      code->as_compiled_method()->log_identity(log);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -803,1 +803,1 @@\n-    CompiledMethod* nm = (entry_bci != InvocationEntryBci) ? method->lookup_osr_nmethod_for(entry_bci, comp_level, true) : method->code();\n+    CodeBlob* nm = (entry_bci != InvocationEntryBci) ? method->lookup_osr_nmethod_for(entry_bci, comp_level, true) : method->code();\n@@ -805,1 +805,1 @@\n-      nm->make_not_entrant();\n+      nm->as_compiled_method()->make_not_entrant();\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2673,1 +2673,1 @@\n-      CompiledMethod* nm = method->code();\n+      CodeBlob* nm = method->code();\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2049,1 +2049,1 @@\n-         spe->method()->code()->entry_point() == spe->method()->from_compiled_entry()),\n+         spe->method()->code()->code_begin() == spe->method()->from_compiled_entry()),\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"code\/nativeInst.hpp\"\n@@ -318,0 +319,50 @@\n+MethodHandleIntrinsicBlob::MethodHandleIntrinsicBlob(\n+  Method* method,\n+  int mhi_size,\n+  CodeBuffer* code_buffer):\n+  RuntimeBlob(\"MethodHandle intrinsic\", code_buffer, sizeof(MethodHandleIntrinsicBlob), mhi_size, CodeOffsets::frame_never_safe, 0, NULL),\n+  _method(method) {\n+  {\n+    debug_only(NoSafepointVerifier nsv;)\n+    assert_locked_or_safepoint(CodeCache_lock);\n+\n+    assert(code_buffer->total_oop_size() == 0, \"unexpected oop\");\n+    assert(code_buffer->total_metadata_size() == 0, \"unexpected metadata\");\n+\n+    CodeCache::commit(this);\n+  }\n+}\n+\n+void* MethodHandleIntrinsicBlob::operator new(size_t s, int size) throw() {\n+  return CodeCache::allocate(size, CodeBlobType::NonNMethod);\n+}\n+\n+MethodHandleIntrinsicBlob* MethodHandleIntrinsicBlob::create(const methodHandle& method,\n+  CodeBuffer *code_buffer) {\n+  code_buffer->finalize_oop_references(method);\n+\n+  MethodHandleIntrinsicBlob* mhi = NULL;\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    int mhi_size = CodeBlob::allocation_size(code_buffer, sizeof(MethodHandleIntrinsicBlob));\n+\n+    mhi = new (mhi_size) MethodHandleIntrinsicBlob(method(), mhi_size, code_buffer);\n+  }\n+\n+  if (mhi != NULL) {\n+    debug_only(mhi->verify();) \/\/ might block\n+  }\n+  return mhi;\n+}\n+\n+void MethodHandleIntrinsicBlob::verify() {\n+  \/\/ Make sure all the entry points are correctly aligned for patching.\n+  NativeJump::check_verified_entry_alignment(code_begin(), code_begin());\n+\n+  ResourceMark rm;\n+\n+  if (!CodeCache::contains((void*)this)) {\n+    fatal(\"MethodHandleIntrinsicBlob at \" INTPTR_FORMAT \" not in zone\", p2i(this));\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+class MethodHandleIntrinsicBlob;\n@@ -160,0 +161,1 @@\n+  virtual bool is_mh_intrinsic() const                { return false; }\n@@ -175,0 +177,1 @@\n+  MethodHandleIntrinsicBlob* as_mh_intrinsic() { assert(is_mh_intrinsic(), \"must be MH intrinsic\"); return (MethodHandleIntrinsicBlob*) this; }\n@@ -410,0 +413,1 @@\n+  friend class MethodHandleIntrinsicBlob;\n@@ -461,0 +465,22 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ MethodHandleIntrinsicBlob: used to hold MethodHandle intrinsic\n+\n+class MethodHandleIntrinsicBlob : public RuntimeBlob {\n+private:\n+  MethodHandleIntrinsicBlob(Method* method, int mhi_size, CodeBuffer *code_buffer);\n+\n+  void* operator new(size_t s, int size) throw();\n+\n+  Method*   _method;\n+\n+public:\n+  static MethodHandleIntrinsicBlob* create(const methodHandle& method, CodeBuffer *code_buffer);\n+\n+  bool is_alive() const                     { return true; }\n+  bool is_mh_intrinsic() const              { return true; }\n+\n+  void verify();\n+\n+  Method* method()      const               { return _method; }\n+};\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1411,0 +1411,1 @@\n+  int mhIntrinsicCount = 0;\n@@ -1462,0 +1463,2 @@\n+      } else if (cb->is_mh_intrinsic()) {\n+        mhIntrinsicCount++;\n@@ -1491,0 +1494,1 @@\n+  tty->print_cr(\"MH intrinsics: %d\",mhIntrinsicCount);\n@@ -1523,0 +1527,1 @@\n+  CodeBlob_sizes mhIntrinsic;\n@@ -1545,0 +1550,2 @@\n+      } else if (cb->is_mh_intrinsic()) {\n+        mhIntrinsic.add(cb);\n@@ -1578,0 +1585,1 @@\n+    { \"MH intrinsic\",   &mhIntrinsic },\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-  bool is_monomorphic = (cb != NULL && cb->is_compiled());\n+  bool is_monomorphic = (cb != NULL && (cb->is_compiled() || cb->is_mh_intrinsic()));\n@@ -463,1 +463,1 @@\n-    assert (cb != NULL && cb->is_compiled(), \"must be compiled!\");\n+    assert (cb != NULL && (cb->is_compiled() || cb->is_mh_intrinsic()), \"must be compiled!\");\n@@ -512,1 +512,0 @@\n-                                           bool caller_is_nmethod,\n@@ -515,1 +514,2 @@\n-  CompiledMethod* method_code = method->code();\n+  CodeBlob* blob = method->code();\n+  CompiledMethod* method_code = (blob == nullptr) ? nullptr : blob->as_compiled_method_or_null();\n@@ -542,0 +542,2 @@\n+  } else if (blob != nullptr && blob->is_mh_intrinsic()) {\n+    entry = blob->as_mh_intrinsic()->code_begin();\n@@ -641,2 +643,3 @@\n-void CompiledStaticCall::compute_entry(const methodHandle& m, bool caller_is_nmethod, StaticCallInfo& info) {\n-  CompiledMethod* m_code = m->code();\n+void CompiledStaticCall::compute_entry(const methodHandle& m, StaticCallInfo& info) {\n+  CodeBlob* m_blob = m->code();\n+  CompiledMethod* m_code = (m_blob == nullptr) ? nullptr : m_blob->as_compiled_method_or_null();\n@@ -647,0 +650,3 @@\n+  } else if (m_blob != NULL && m_blob->is_mh_intrinsic()) {\n+    info._to_interpreter = false;\n+    info._entry  = m_blob->code_begin();\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-                                        bool is_optimized, bool static_bound, bool caller_is_nmethod,\n+                                        bool is_optimized, bool static_bound,\n@@ -347,1 +347,1 @@\n-  static void compute_entry(const methodHandle& m, bool caller_is_nmethod, StaticCallInfo& info);\n+  static void compute_entry(const methodHandle& m, StaticCallInfo& info);\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -210,1 +210,0 @@\n-  int _scopes_data_offset;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -217,3 +217,3 @@\n-  CompiledMethod *nm = method->code();\n-  if (nm != NULL && nm->is_in_use()) {\n-    return (CompLevel)nm->comp_level();\n+  CodeBlob *blob = method->code();\n+  if (blob != NULL && blob->is_compiled() && blob->as_compiled_method()->is_in_use()) {\n+    return (CompLevel)blob->as_compiled_method()->comp_level();\n@@ -757,1 +757,1 @@\n-        mh->code()->make_not_used();\n+        mh->code()->as_compiled_method()->make_not_used();\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1346,1 +1346,1 @@\n-nmethod* CompileBroker::compile_method(const methodHandle& method, int osr_bci,\n+CodeBlob* CompileBroker::compile_method(const methodHandle& method, int osr_bci,\n@@ -1361,1 +1361,1 @@\n-  nmethod* nm = CompileBroker::compile_method(method, osr_bci, comp_level, hot_method, hot_count, compile_reason, directive, THREAD);\n+  CodeBlob* nm = CompileBroker::compile_method(method, osr_bci, comp_level, hot_method, hot_count, compile_reason, directive, THREAD);\n@@ -1366,1 +1366,1 @@\n-nmethod* CompileBroker::compile_method(const methodHandle& method, int osr_bci,\n+CodeBlob* CompileBroker::compile_method(const methodHandle& method, int osr_bci,\n@@ -1395,2 +1395,2 @@\n-    CompiledMethod* method_code = method->code();\n-    if (method_code != NULL && method_code->is_nmethod()) {\n+    CodeBlob* method_code = method->code();\n+    if (method_code != NULL && (method_code->is_nmethod() || method_code->is_mh_intrinsic())) {\n@@ -1398,1 +1398,1 @@\n-        return (nmethod*) method_code;\n+        return method_code;\n@@ -1499,6 +1499,1 @@\n-    CompiledMethod* code = method->code();\n-    if (code == NULL) {\n-      return (nmethod*) code;\n-    } else {\n-      return code->as_nmethod_or_null();\n-    }\n+    return method->code();\n@@ -1529,3 +1524,8 @@\n-      CompiledMethod* result = method->code();\n-      if (result == NULL) return false;\n-      return comp_level == result->comp_level();\n+      CodeBlob* result = method->code();\n+      if (result != nullptr && result->is_compiled()) {\n+        return comp_level == result->as_compiled_method()->comp_level();\n+      } else if (result != nullptr && result->is_mh_intrinsic()) {\n+        return comp_level == CompLevel_none;\n+      } else {\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-  static nmethod* compile_method(const methodHandle& method,\n+  static CodeBlob* compile_method(const methodHandle& method,\n@@ -307,1 +307,1 @@\n-  static nmethod* compile_method(const methodHandle& method,\n+  static CodeBlob* compile_method(const methodHandle& method,\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-    nmethod* nm = (cb == NULL) ? NULL : cb->as_compiled_method()->as_nmethod_or_null();\n+    nmethod* nm = (cb == NULL) ? NULL : cb->as_nmethod_or_null();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1123,3 +1123,3 @@\n-  CompiledMethod* code = method->code();\n-  if (code != NULL) {\n-    code->make_not_entrant();\n+  CodeBlob* code = method->code();\n+  if (code != NULL && code->is_compiled()) {\n+    code->as_compiled_method()->make_not_entrant();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2153,1 +2153,2 @@\n-            CompiledMethod* old = method->code();\n+            CodeBlob* old_code = method->code();\n+            CompiledMethod* old = (old_code == nullptr) ? nullptr : old_code->as_compiled_method();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-  volatile_nonstatic_field(Method,             _code,                                         CompiledMethod*)                       \\\n+  volatile_nonstatic_field(Method,             _code,                                         CodeBlob*)                             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1014,1 +1014,1 @@\n-  CompiledMethod* nm = code(); \/\/ Put it into local variable to guard against concurrent updates\n+  CodeBlob* nm = code();       \/\/ Put it into local variable to guard against concurrent updates\n@@ -1016,1 +1016,1 @@\n-    nm->make_not_entrant();\n+    nm->as_compiled_method()->make_not_entrant();\n@@ -1267,3 +1267,5 @@\n-  CompiledMethod *code = Atomic::load_acquire(&_code);\n-  if (code) {\n-    return code->verified_entry_point();\n+  CodeBlob *code = Atomic::load_acquire(&_code);\n+  if (code != nullptr && code->is_compiled()) {\n+    return code->as_compiled_method()->verified_entry_point();\n+  } else if (code != nullptr && code->is_mh_intrinsic()) {\n+    return code->as_mh_intrinsic()->code_begin();\n@@ -1293,2 +1295,11 @@\n-  CompiledMethod *code = Atomic::load_acquire(&_code);\n-  return code == NULL || (code->method() == NULL) || (code->method() == (Method*)this && !code->is_osr_method());\n+  CodeBlob *blob = Atomic::load_acquire(&_code);\n+  if (blob == nullptr) {\n+    return true;\n+  } else if (blob->is_compiled()) {\n+    CompiledMethod* cm = blob->as_compiled_method();\n+    return (cm->method() == nullptr) || (cm->method() == this && !cm->is_osr_method());\n+  } else {\n+    assert(blob->is_mh_intrinsic(), \"must be MH intrinsic\");\n+    MethodHandleIntrinsicBlob* mhi = blob->as_mh_intrinsic();\n+    return (mhi->method() == nullptr) || (mhi->method() == this);\n+  }\n@@ -1298,1 +1309,1 @@\n-void Method::set_code(const methodHandle& mh, CompiledMethod *code) {\n+void Method::set_code(const methodHandle& mh, CodeBlob *code) {\n@@ -1310,1 +1321,1 @@\n-  int comp_level = code->comp_level();\n+  int comp_level = code->is_compiled() ? code->as_compiled_method()->comp_level() : CompLevel_none;\n@@ -1318,1 +1329,6 @@\n-  mh->_from_compiled_entry = code->verified_entry_point();\n+  if (code->is_compiled()) {\n+    mh->_from_compiled_entry = code->as_compiled_method()->verified_entry_point();\n+  }\n+  else {\n+    mh->_from_compiled_entry = code->code_begin();\n+  }\n@@ -2437,1 +2453,1 @@\n-  if (WizardMode && code() != NULL) st->print(\" ((nmethod*)%p)\", code());\n+  if (WizardMode && code() != NULL) st->print(\" ((CodeBlob*)%p)\", code());\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-  CompiledMethod* volatile _code;                       \/\/ Points to the corresponding piece of native code\n+  CodeBlob* volatile _code;                           \/\/ Points to the corresponding piece of native code\n@@ -443,1 +443,1 @@\n-  CompiledMethod* volatile code() const;\n+  CodeBlob* volatile code() const;\n@@ -455,1 +455,1 @@\n-  static void set_code(const methodHandle& mh, CompiledMethod* code);\n+  static void set_code(const methodHandle& mh, CodeBlob* code);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-inline CompiledMethod* volatile Method::code() const {\n+inline CodeBlob* volatile Method::code() const {\n","filename":"src\/hotspot\/share\/oops\/method.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1764,1 +1764,1 @@\n-    CompiledMethod* cm = blob->as_compiled_method_or_null();\n+    CompiledMethod* cm = blob->as_compiled_method();\n@@ -1766,0 +1766,3 @@\n+  } else if (blob->is_mh_intrinsic()) {\n+    MethodHandleIntrinsicBlob* mhi = blob->as_mh_intrinsic();\n+    mhi->method()->print_value_on(&tempst);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -794,1 +794,1 @@\n-    mh->code()->mark_for_deoptimization();\n+    mh->code()->as_compiled_method()->mark_for_deoptimization();\n@@ -809,1 +809,2 @@\n-  CompiledMethod* code = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n+  CodeBlob* blob = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n+  CompiledMethod* code = (blob == nullptr) ? nullptr : blob->as_compiled_method_or_null();\n@@ -909,2 +910,2 @@\n-  CompiledMethod* code = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n-  return (code != NULL ? code->comp_level() : CompLevel_none);\n+  CodeBlob* code = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n+  return (code != NULL && code->is_compiled()) ? code->as_compiled_method()->comp_level() : CompLevel_none;\n@@ -1060,1 +1061,1 @@\n-  nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh->invocation_count(), CompileTask::Reason_Whitebox, CHECK_false);\n+  CodeBlob* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh->invocation_count(), CompileTask::Reason_Whitebox, CHECK_false);\n@@ -1068,1 +1069,1 @@\n-    CompiledMethod* code = mh->code();\n+    CodeBlob* code = mh->code();\n@@ -1528,1 +1529,2 @@\n-  CompiledMethod* code = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n+  CodeBlob* blob = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n+  CompiledMethod* code = (blob == nullptr) ? nullptr : blob->as_compiled_method_or_null();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -320,1 +320,1 @@\n-  CompiledMethod* nm = (CompiledMethod *)_cb;\n+  CompiledMethod* nm = _cb->as_compiled_method();\n@@ -337,1 +337,1 @@\n-  CompiledMethod* nm = (CompiledMethod*)_cb;\n+  CompiledMethod* nm = _cb->as_compiled_method();\n@@ -679,1 +679,1 @@\n-      CompiledMethod* cm = (CompiledMethod*)_cb;\n+      CompiledMethod* cm = _cb->as_compiled_method();\n@@ -728,0 +728,2 @@\n+    } else if (_cb->is_mh_intrinsic()) {\n+      st->print(\"v  ~MethodHandleIntrinsicBlob \" PTR_FORMAT, p2i(pc()));\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -911,1 +911,1 @@\n-  CompiledMethod* nm = (CompiledMethod*)cb;\n+  CompiledMethod* nm = cb->as_compiled_method();\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -557,1 +557,1 @@\n-  assert(((CompiledMethod*)cb)->is_at_poll_or_poll_return(pc),\n+  assert(cb->as_compiled_method()->is_at_poll_or_poll_return(pc),\n@@ -883,1 +883,1 @@\n-          if (!cb->is_compiled()) {\n+          if (!cb->is_compiled() && !cb->is_mh_intrinsic()) {\n@@ -895,9 +895,11 @@\n-          CompiledMethod* cm = (CompiledMethod*)cb;\n-          if (cm->inlinecache_check_contains(pc)) {\n-            \/\/ exception happened inside inline-cache check code\n-            \/\/ => the nmethod is not yet active (i.e., the frame\n-            \/\/ is not set up yet) => use return address pushed by\n-            \/\/ caller => don't push another return address\n-            Events::log_exception(current, \"NullPointerException in IC check \" INTPTR_FORMAT, p2i(pc));\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n-          }\n+          if (cb->is_compiled()) {\n+            CompiledMethod* cm = cb->as_compiled_method();\n+\n+            if (cm->inlinecache_check_contains(pc)) {\n+              \/\/ exception happened inside inline-cache check code\n+              \/\/ => the nmethod is not yet active (i.e., the frame\n+              \/\/ is not set up yet) => use return address pushed by\n+              \/\/ caller => don't push another return address\n+              Events::log_exception(current, \"NullPointerException in IC check \" INTPTR_FORMAT, p2i(pc));\n+              return StubRoutines::throw_NullPointerException_at_call_entry();\n+            }\n@@ -905,1 +907,9 @@\n-          if (cm->method()->is_method_handle_intrinsic()) {\n+#ifndef PRODUCT\n+            _implicit_null_throws++;\n+#endif\n+            target_pc = cm->continuation_for_implicit_null_exception(pc);\n+            \/\/ If there's an unexpected fault, target_pc might be NULL,\n+            \/\/ in which case we want to fall through into the normal\n+            \/\/ error handling code.\n+          } else {\n+            assert(cb->as_mh_intrinsic()->method()->is_method_handle_intrinsic(), \"should be MH adapter\");\n@@ -910,8 +920,0 @@\n-\n-#ifndef PRODUCT\n-          _implicit_null_throws++;\n-#endif\n-          target_pc = cm->continuation_for_implicit_null_exception(pc);\n-          \/\/ If there's an unexpected fault, target_pc might be NULL,\n-          \/\/ in which case we want to fall through into the normal\n-          \/\/ error handling code.\n@@ -1281,1 +1283,1 @@\n-  CompiledMethod* callee = callee_method->code();\n+  CodeBlob* callee = callee_method->code();\n@@ -1284,1 +1286,1 @@\n-    assert(callee->is_compiled(), \"must be nmethod for patching\");\n+    assert(callee->is_compiled() || callee->is_mh_intrinsic(), \"must be nmethod or MH intrinsic for patching\");\n@@ -1287,1 +1289,1 @@\n-  if (callee != NULL && !callee->is_in_use()) {\n+  if (callee != NULL && callee->is_compiled() && !callee->as_compiled_method()->is_in_use()) {\n@@ -1291,1 +1293,1 @@\n-  nmethodLocker nl_callee(callee);\n+  nmethodLocker nl_callee((callee != nullptr) ? callee->as_compiled_method_or_null() : nullptr);\n@@ -1293,1 +1295,1 @@\n-  address dest_entry_point = callee == NULL ? 0 : callee->entry_point(); \/\/ used below\n+  address dest_entry_point = callee == NULL ? 0 : (callee->is_compiled() ? callee->as_compiled_method()->entry_point() : callee->code_begin()); \/\/ used below\n@@ -1296,2 +1298,0 @@\n-  bool is_nmethod = caller_nm->is_nmethod();\n-\n@@ -1303,1 +1303,1 @@\n-                     is_optimized, static_bound, is_nmethod, virtual_call_info,\n+                     is_optimized, static_bound, virtual_call_info,\n@@ -1307,1 +1307,1 @@\n-    CompiledStaticCall::compute_entry(callee_method, is_nmethod, static_call_info);\n+    CompiledStaticCall::compute_entry(callee_method, static_call_info);\n@@ -1323,1 +1323,1 @@\n-        (callee == NULL || (callee->is_in_use() && callee_method->code() == callee))) {\n+        (callee == NULL || callee->is_mh_intrinsic() || (callee->as_compiled_method()->is_in_use() && callee_method->code() == callee))) {\n@@ -1329,1 +1329,1 @@\n-        assert((cb != NULL) && cb->is_compiled() && (((CompiledMethod*)cb) == callee),\n+        assert((cb != NULL) && (cb->is_compiled() || cb->is_mh_intrinsic()) && (cb == callee),\n@@ -1653,1 +1653,1 @@\n-                                            false, caller_nm->is_nmethod(),\n+                                            false,\n@@ -3037,1 +3037,1 @@\n-  nmethod* nm = NULL;\n+  CodeBlob* blob = NULL;\n@@ -3092,1 +3092,5 @@\n-      nm = SharedRuntime::generate_native_wrapper(&_masm, method, compile_id, sig_bt, regs, ret_type);\n+      if (!method->is_method_handle_intrinsic()) {\n+        blob = SharedRuntime::generate_native_wrapper(&_masm, method, compile_id, sig_bt, regs, ret_type);\n+      } else {\n+        blob = SharedRuntime::generate_method_handle_intrinsic_wrapper(&_masm, method, compile_id, sig_bt, regs, ret_type);\n+      }\n@@ -3094,1 +3098,1 @@\n-      if (nm != NULL) {\n+      if (blob != NULL) {\n@@ -3097,2 +3101,2 @@\n-          if (nm->make_in_use()) {\n-            method->set_code(method, nm);\n+          if (blob->is_mh_intrinsic() || blob->as_nmethod()->make_in_use()) {\n+            method->set_code(method, blob);\n@@ -3104,1 +3108,1 @@\n-          nm->print_code();\n+          blob->print_code();\n@@ -3113,1 +3117,2 @@\n-  if (nm != NULL) {\n+  if (blob != NULL && blob->is_nmethod()) {\n+    nmethod* nm = blob->as_nmethod();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":44,"deletions":39,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -483,0 +483,7 @@\n+  static CodeBlob* generate_method_handle_intrinsic_wrapper(MacroAssembler* masm,\n+                                                            const methodHandle& method,\n+                                                            int compile_id,\n+                                                            BasicType* sig_bt,\n+                                                            VMRegPair* regs,\n+                                                            BasicType ret_type);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-  volatile_nonstatic_field(Method,             _code,                                         CompiledMethod*)                       \\\n+  volatile_nonstatic_field(Method,             _code,                                         CodeBlob*)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-    final int methodCodeOffset = getFieldOffset(\"Method::_code\", Integer.class, \"CompiledMethod*\");\n+    final int methodCodeOffset = getFieldOffset(\"Method::_code\", Integer.class, \"CodeBlob*\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+                       + \" #\\\\d+ MH intrinsic = \" + entry\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckCodeCacheInfo.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}