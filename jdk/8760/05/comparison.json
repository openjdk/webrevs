{"files":[{"patch":"@@ -107,1 +107,1 @@\n-      if (_cb->is_nmethod() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_nmethod() || _cb->is_adapter_blob() || _cb->is_runtime_stub() || _cb->is_mh_intrinsic()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-void NativeJump::check_verified_entry_alignment(address entry, address verified_entry) {\n+void NativeJump::check_verified_entry_alignment(address verified_entry) {\n@@ -476,1 +476,1 @@\n-void NativeJump::patch_verified_entry(address entry, address verified_entry, address dest) {\n+void NativeJump::patch_verified_entry(address verified_entry, address dest) {\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -459,2 +459,2 @@\n-  static void check_verified_entry_alignment(address entry, address verified_entry);\n-  static void patch_verified_entry(address entry, address verified_entry, address dest);\n+  static void check_verified_entry_alignment(address verified_entry);\n+  static void patch_verified_entry(address verified_entry, address dest);\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1190,0 +1190,19 @@\n+CodeBlob* SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler* masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType* in_sig_bt,\n+                                                                  VMRegPair* in_regs,\n+                                                                  BasicType ret_type) {\n+  assert(method->is_method_handle_intrinsic(), \"should be MH method\");\n+  assert(method->is_native(), \"should be native method\");\n+\n+  \/\/ First instruction must be a nop as it may need to be patched on deoptimisation\n+  __ nop();\n+  gen_special_dispatch(masm,\n+                       method,\n+                       in_sig_bt,\n+                       in_regs);\n+  __ flush();\n+  return MethodHandleIntrinsicBlob::create(method, masm->code());\n+}\n+\n@@ -1212,0 +1231,1 @@\n+  assert(!method->is_method_handle_intrinsic(), \"must not be MethodHandle intrinsic\");\n@@ -1245,25 +1265,0 @@\n-\n-  if (method->is_method_handle_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t)__ pc();\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n-\n-    \/\/ First instruction must be a nop as it may need to be patched on deoptimisation\n-    __ nop();\n-    gen_special_dispatch(masm,\n-                         method,\n-                         in_sig_bt,\n-                         in_regs);\n-    int frame_complete = ((intptr_t)__ pc()) - start;  \/\/ not complete, period\n-    __ flush();\n-    int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ no out slots at all, actually\n-    return nmethod::new_native_nmethod(method,\n-                                       compile_id,\n-                                       masm->code(),\n-                                       vep_offset,\n-                                       frame_complete,\n-                                       stack_slots \/ VMRegImpl::slots_per_word,\n-                                       in_ByteSize(-1),\n-                                       in_ByteSize(-1),\n-                                       (OopMapSet*)NULL);\n-  }\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":20,"deletions":25,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub() || _cb->is_mh_intrinsic()) {\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-void RawNativeJump::check_verified_entry_alignment(address entry, address verified_entry) {\n+void RawNativeJump::check_verified_entry_alignment(address verified_entry) {\n@@ -290,1 +290,1 @@\n-void RawNativeJump::patch_verified_entry(address entry, address verified_entry, address dest) {\n+void RawNativeJump::patch_verified_entry(address verified_entry, address dest) {\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-  static void check_verified_entry_alignment(address entry, address verified_entry);\n+  static void check_verified_entry_alignment(address verified_entry);\n@@ -276,1 +276,1 @@\n-  static void patch_verified_entry(address entry, address verified_entry, address dest);\n+  static void patch_verified_entry(address verified_entry, address dest);\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -742,0 +742,16 @@\n+CodeBlob* SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler* masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType* in_sig_bt,\n+                                                                  VMRegPair* in_regs,\n+                                                                  BasicType ret_type) {\n+  assert(method->is_method_handle_intrinsic(), \"must be MethodHandle intrinsic\");\n+\n+  gen_special_dispatch(masm,\n+                       method,\n+                       in_sig_bt,\n+                       in_regs);\n+  __ flush();\n+  return MethodHandleIntrinsicBlob::create(method, masm->code());\n+}\n+\n@@ -754,21 +770,1 @@\n-  if (method->is_method_handle_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t)__ pc();\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n-    gen_special_dispatch(masm,\n-                         method,\n-                         in_sig_bt,\n-                         in_regs);\n-    int frame_complete = ((intptr_t)__ pc()) - start;  \/\/ not complete, period\n-    __ flush();\n-    int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ no out slots at all, actually\n-    return nmethod::new_native_nmethod(method,\n-                                       compile_id,\n-                                       masm->code(),\n-                                       vep_offset,\n-                                       frame_complete,\n-                                       stack_slots \/ VMRegImpl::slots_per_word,\n-                                       in_ByteSize(-1),\n-                                       in_ByteSize(-1),\n-                                       (OopMapSet*)NULL);\n-  }\n+  assert(!method->is_method_handle_intrinsic(), \"must not be MethodHandle intrinsic\");\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub() || _cb->is_mh_intrinsic()) {\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -333,1 +333,1 @@\n-void NativeJump::patch_verified_entry(address entry, address verified_entry, address dest) {\n+void NativeJump::patch_verified_entry(address verified_entry, address dest) {\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-  static void patch_verified_entry(address entry, address verified_entry, address dest);\n+  static void patch_verified_entry(address verified_entry, address dest);\n@@ -332,1 +332,1 @@\n-  static void check_verified_entry_alignment(address entry, address verified_entry) {\n+  static void check_verified_entry_alignment(address verified_entry) {\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1621,0 +1621,16 @@\n+CodeBlob *SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler *masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType *in_sig_bt,\n+                                                                  VMRegPair *in_regs,\n+                                                                  BasicType ret_type) {\n+  assert(method->is_method_handle_intrinsic(), \"must be MethodHandle intrinsic\");\n+\n+  gen_special_dispatch(masm,\n+                       method,\n+                       in_sig_bt,\n+                       in_regs);\n+  __ flush();\n+  return MethodHandleIntrinsicBlob::create(method, masm->code());\n+}\n+\n@@ -1643,21 +1659,1 @@\n-  if (method->is_method_handle_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t)__ pc();\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n-    gen_special_dispatch(masm,\n-                         method,\n-                         in_sig_bt,\n-                         in_regs);\n-    int frame_complete = ((intptr_t)__ pc()) - start;  \/\/ not complete, period\n-    __ flush();\n-    int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ no out slots at all, actually\n-    return nmethod::new_native_nmethod(method,\n-                                       compile_id,\n-                                       masm->code(),\n-                                       vep_offset,\n-                                       frame_complete,\n-                                       stack_slots \/ VMRegImpl::slots_per_word,\n-                                       in_ByteSize(-1),\n-                                       in_ByteSize(-1),\n-                                       (OopMapSet*)NULL);\n-  }\n+  assert(!method->is_method_handle_intrinsic(), \"must not be MethodHandle intrinsic\");\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-      if (_cb->is_nmethod() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_nmethod() || _cb->is_adapter_blob() || _cb->is_runtime_stub() || _cb->is_mh_intrinsic()) {\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-void NativeJump::check_verified_entry_alignment(address entry, address verified_entry) {\n+void NativeJump::check_verified_entry_alignment(address verified_entry) {\n@@ -350,1 +350,1 @@\n-void NativeJump::patch_verified_entry(address entry, address verified_entry, address dest) {\n+void NativeJump::patch_verified_entry(address verified_entry, address dest) {\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -451,2 +451,2 @@\n-  static void check_verified_entry_alignment(address entry, address verified_entry);\n-  static void patch_verified_entry(address entry, address verified_entry, address dest);\n+  static void check_verified_entry_alignment(address verified_entry);\n+  static void patch_verified_entry(address verified_entry, address dest);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1116,0 +1116,18 @@\n+CodeBlob* SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler* masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType* in_sig_bt,\n+                                                                  VMRegPair* in_regs,\n+                                                                  BasicType ret_type) {\n+  assert(method->is_method_handle_intrinsic(), \"must be MethodHandle intrinsic\");\n+\n+  \/\/ First instruction must be a nop as it may need to be patched on deoptimisation\n+  __ nop();\n+  gen_special_dispatch(masm,\n+                       method,\n+                       in_sig_bt,\n+                       in_regs);\n+  __ flush();\n+  return MethodHandleIntrinsicBlob::create(method, masm->code());\n+}\n+\n@@ -1150,24 +1168,1 @@\n-  if (method->is_method_handle_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t)__ pc();\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n-\n-    \/\/ First instruction must be a nop as it may need to be patched on deoptimisation\n-    __ nop();\n-    gen_special_dispatch(masm,\n-                         method,\n-                         in_sig_bt,\n-                         in_regs);\n-    int frame_complete = ((intptr_t)__ pc()) - start;  \/\/ not complete, period\n-    __ flush();\n-    int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ no out slots at all, actually\n-    return nmethod::new_native_nmethod(method,\n-                                       compile_id,\n-                                       masm->code(),\n-                                       vep_offset,\n-                                       frame_complete,\n-                                       stack_slots \/ VMRegImpl::slots_per_word,\n-                                       in_ByteSize(-1),\n-                                       in_ByteSize(-1),\n-                                       (OopMapSet*)NULL);\n-  }\n+  assert(!method->is_method_handle_intrinsic(), \"must not be MethodHandle intrinsic\");\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-      if (_cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_adapter_blob() || _cb->is_runtime_stub() || _cb->is_mh_intrinsic()) {\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -625,1 +625,1 @@\n-void NativeJump::patch_verified_entry(address entry, address verified_entry, address dest) {\n+void NativeJump::patch_verified_entry(address verified_entry, address dest) {\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -613,1 +613,1 @@\n-  static void check_verified_entry_alignment(address entry, address verified_entry) { }\n+  static void check_verified_entry_alignment(address verified_entry) { }\n@@ -615,1 +615,1 @@\n-  static void patch_verified_entry(address entry, address verified_entry, address dest);\n+  static void patch_verified_entry(address verified_entry, address dest);\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1293,0 +1293,17 @@\n+CodeBlob *SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler *masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType *in_sig_bt,\n+                                                                  VMRegPair *in_regs,\n+                                                                  BasicType ret_type) {\n+  assert(method->is_method_handle_intrinsic(), \"must be MethodHandle intrinsic\");\n+\n+  int total_in_args = method->size_of_parameters();\n+\n+  gen_special_dispatch(masm, total_in_args,\n+                       method->intrinsic_id(), in_sig_bt, in_regs);\n+  __ flush();\n+\n+  return MethodHandleIntrinsicBlob::create(method, masm->code());\n+}\n+\n@@ -1303,0 +1320,1 @@\n+  assert(!method->is_method_handle_intrinsic(), \"must not be MethodHandle intrinsic\");\n@@ -1304,25 +1322,0 @@\n-  if (method->is_method_handle_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t) __ pc();\n-    int vep_offset = ((intptr_t) __ pc()) - start;\n-\n-    gen_special_dispatch(masm, total_in_args,\n-                         method->intrinsic_id(), in_sig_bt, in_regs);\n-\n-    int frame_complete = ((intptr_t)__ pc()) - start; \/\/ Not complete, period.\n-\n-    __ flush();\n-\n-    int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ No out slots at all, actually.\n-\n-    return nmethod::new_native_nmethod(method,\n-                                       compile_id,\n-                                       masm->code(),\n-                                       vep_offset,\n-                                       frame_complete,\n-                                       stack_slots \/ VMRegImpl::slots_per_word,\n-                                       in_ByteSize(-1),\n-                                       in_ByteSize(-1),\n-                                       (OopMapSet *) NULL);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":18,"deletions":25,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n+      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub() || _cb->is_mh_intrinsic()) {\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -477,1 +477,1 @@\n-void NativeJump::check_verified_entry_alignment(address entry, address verified_entry) {\n+void NativeJump::check_verified_entry_alignment(address verified_entry) {\n@@ -511,1 +511,1 @@\n-void NativeJump::patch_verified_entry(address entry, address verified_entry, address dest) {\n+void NativeJump::patch_verified_entry(address verified_entry, address dest) {\n@@ -521,1 +521,1 @@\n-  check_verified_entry_alignment(entry, verified_entry);\n+  check_verified_entry_alignment(verified_entry);\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -522,2 +522,2 @@\n-  static void check_verified_entry_alignment(address entry, address verified_entry);\n-  static void patch_verified_entry(address entry, address verified_entry, address dest);\n+  static void check_verified_entry_alignment(address verified_entry);\n+  static void patch_verified_entry(address verified_entry, address dest);\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1319,0 +1319,16 @@\n+CodeBlob* SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler* masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType* in_sig_bt,\n+                                                                  VMRegPair* in_regs,\n+                                                                  BasicType ret_type) {\n+  assert(method->is_method_handle_intrinsic(), \"must be MethodHandle intrinsic\");\n+\n+  gen_special_dispatch(masm,\n+                       method,\n+                       in_sig_bt,\n+                       in_regs);\n+  __ flush();\n+  return MethodHandleIntrinsicBlob::create(method, masm->code());\n+}\n+\n@@ -1342,21 +1358,1 @@\n-  if (method->is_method_handle_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t)__ pc();\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n-    gen_special_dispatch(masm,\n-                         method,\n-                         in_sig_bt,\n-                         in_regs);\n-    int frame_complete = ((intptr_t)__ pc()) - start;  \/\/ not complete, period\n-    __ flush();\n-    int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ no out slots at all, actually\n-    return nmethod::new_native_nmethod(method,\n-                                       compile_id,\n-                                       masm->code(),\n-                                       vep_offset,\n-                                       frame_complete,\n-                                       stack_slots \/ VMRegImpl::slots_per_word,\n-                                       in_ByteSize(-1),\n-                                       in_ByteSize(-1),\n-                                       (OopMapSet*)NULL);\n-  }\n+  assert(!method->is_method_handle_intrinsic(), \"must not be MethodHandle intrinsic\");\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1506,0 +1506,16 @@\n+CodeBlob* SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler* masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType* in_sig_bt,\n+                                                                  VMRegPair* in_regs,\n+                                                                  BasicType ret_type) {\n+  assert(method->is_method_handle_intrinsic(), \"must be MethodHandle intrinsic\");\n+\n+  gen_special_dispatch(masm,\n+                       method,\n+                       in_sig_bt,\n+                       in_regs);\n+  __ flush();\n+  return MethodHandleIntrinsicBlob::create(method, masm->code());\n+}\n+\n@@ -1528,0 +1544,1 @@\n+  assert(!method->is_method_handle_intrinsic(), \"must not be MethodHandle intrinsic\");\n@@ -1559,22 +1576,0 @@\n-\n-  if (method->is_method_handle_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t)__ pc();\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n-    gen_special_dispatch(masm,\n-                         method,\n-                         in_sig_bt,\n-                         in_regs);\n-    int frame_complete = ((intptr_t)__ pc()) - start;  \/\/ not complete, period\n-    __ flush();\n-    int stack_slots = SharedRuntime::out_preserve_stack_slots();  \/\/ no out slots at all, actually\n-    return nmethod::new_native_nmethod(method,\n-                                       compile_id,\n-                                       masm->code(),\n-                                       vep_offset,\n-                                       frame_complete,\n-                                       stack_slots \/ VMRegImpl::slots_per_word,\n-                                       in_ByteSize(-1),\n-                                       in_ByteSize(-1),\n-                                       (OopMapSet*)NULL);\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -38,2 +38,1 @@\n-void NativeJump::patch_verified_entry(address entry,\n-                                      address verified_entry,\n+void NativeJump::patch_verified_entry(address verified_entry,\n","filename":"src\/hotspot\/cpu\/zero\/nativeInst_zero.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -179,2 +179,1 @@\n-  static void check_verified_entry_alignment(address entry,\n-                                             address verified_entry) {\n+  static void check_verified_entry_alignment(address verified_entry) {\n@@ -183,2 +182,1 @@\n-  static void patch_verified_entry(address entry,\n-                                   address verified_entry,\n+  static void patch_verified_entry(address verified_entry,\n","filename":"src\/hotspot\/cpu\/zero\/nativeInst_zero.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,0 +81,10 @@\n+CodeBlob *SharedRuntime::generate_method_handle_intrinsic_wrapper(MacroAssembler *masm,\n+                                                                  const methodHandle& method,\n+                                                                  int compile_id,\n+                                                                  BasicType *sig_bt,\n+                                                                  VMRegPair *regs,\n+                                                                  BasicType ret_type) {\n+  ShouldNotCallThis();\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1174,1 +1174,2 @@\n-          CompiledMethod* old = method->code();\n+          CodeBlob* old_blob = method->code();\n+          CompiledMethod* old = (old_blob == nullptr) ? nullptr : old_blob->as_compiled_method();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1128,3 +1128,4 @@\n-                     CompiledMethod* code = get_Method()->code();\n-                     if (code != NULL && (code->comp_level() == CompLevel_full_optimization)) {\n-                       _instructions_size = code->insts_end() - code->verified_entry_point();\n+                     CodeBlob* code = get_Method()->code();\n+                     CompiledMethod* cm = (code == nullptr) ? nullptr : code->as_compiled_method_or_null();\n+                     if (cm != NULL && (cm->comp_level() == CompLevel_full_optimization)) {\n+                       _instructions_size = cm->insts_end() - cm->verified_entry_point();\n@@ -1143,3 +1144,3 @@\n-    CompiledMethod* code = get_Method()->code();\n-    if (code != NULL) {\n-      code->log_identity(log);\n+    CodeBlob* code = get_Method()->code();\n+    if (code != NULL && code->is_compiled()) {\n+      code->as_compiled_method()->log_identity(log);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -804,1 +804,1 @@\n-    CompiledMethod* nm = (entry_bci != InvocationEntryBci) ? method->lookup_osr_nmethod_for(entry_bci, comp_level, true) : method->code();\n+    CodeBlob* nm = (entry_bci != InvocationEntryBci) ? method->lookup_osr_nmethod_for(entry_bci, comp_level, true) : method->code();\n@@ -806,1 +806,1 @@\n-      nm->make_not_entrant();\n+      nm->as_compiled_method()->make_not_entrant();\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2631,1 +2631,1 @@\n-      CompiledMethod* nm = method->code();\n+      CodeBlob* nm = method->code();\n@@ -2633,1 +2633,1 @@\n-        sprintf(buf + (int)strlen(buf), \"(nmethod \" INTPTR_FORMAT \")\", (intptr_t)nm);\n+        sprintf(buf + (int)strlen(buf), \"(code \" INTPTR_FORMAT \")\", (intptr_t)nm);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2113,2 +2113,1 @@\n-    assert(Arguments::is_interpreter_only() || (saved_method->has_compiled_code() &&\n-         saved_method->code()->entry_point() == saved_method->from_compiled_entry()),\n+    assert(Arguments::is_interpreter_only() || saved_method->has_compiled_code(),\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"code\/nativeInst.hpp\"\n@@ -322,0 +323,48 @@\n+MethodHandleIntrinsicBlob::MethodHandleIntrinsicBlob(\n+  Method* method,\n+  int mhi_size,\n+  CodeBuffer* code_buffer):\n+  RuntimeBlob(\"MethodHandle intrinsic\", code_buffer, sizeof(MethodHandleIntrinsicBlob), mhi_size, CodeOffsets::frame_never_safe, 0, NULL),\n+  _method(method) {\n+  {\n+    debug_only(NoSafepointVerifier nsv;)\n+    assert_locked_or_safepoint(CodeCache_lock);\n+\n+    assert(code_buffer->total_oop_size() == 0, \"unexpected oop\");\n+    assert(code_buffer->total_metadata_size() == 0, \"unexpected metadata\");\n+\n+    CodeCache::commit(this);\n+  }\n+}\n+\n+void* MethodHandleIntrinsicBlob::operator new(size_t s, int size) throw() {\n+  return CodeCache::allocate(size, CodeBlobType::NonNMethod);\n+}\n+\n+MethodHandleIntrinsicBlob* MethodHandleIntrinsicBlob::create(const methodHandle& method,\n+  CodeBuffer *code_buffer) {\n+\n+  MethodHandleIntrinsicBlob* mhi = NULL;\n+  int mhi_size = CodeBlob::allocation_size(code_buffer, sizeof(MethodHandleIntrinsicBlob));\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    mhi = new (mhi_size) MethodHandleIntrinsicBlob(method(), mhi_size, code_buffer);\n+  }\n+\n+  if (mhi != NULL) {\n+    debug_only(mhi->verify();) \/\/ might block\n+  }\n+  return mhi;\n+}\n+\n+void MethodHandleIntrinsicBlob::verify() {\n+  \/\/ Make sure all the entry points are correctly aligned for patching.\n+  NativeJump::check_verified_entry_alignment(code_begin());\n+}\n+\n+void MethodHandleIntrinsicBlob::post_dynamic_code_generated_event() {\n+  if (JvmtiExport::should_post_dynamic_code_generated()) {\n+    JvmtiExport::post_dynamic_code_generated(name(), code_begin(), code_end());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+class MethodHandleIntrinsicBlob;\n@@ -160,0 +161,1 @@\n+  virtual bool is_mh_intrinsic() const                { return false; }\n@@ -175,0 +177,1 @@\n+  MethodHandleIntrinsicBlob* as_mh_intrinsic() { assert(is_mh_intrinsic(), \"must be MH intrinsic\"); return (MethodHandleIntrinsicBlob*) this; }\n@@ -410,0 +413,1 @@\n+  friend class MethodHandleIntrinsicBlob;\n@@ -461,0 +465,24 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ MethodHandleIntrinsicBlob: used to hold MethodHandle intrinsic\n+\n+class MethodHandleIntrinsicBlob : public RuntimeBlob {\n+private:\n+  MethodHandleIntrinsicBlob(Method* method, int mhi_size, CodeBuffer *code_buffer);\n+\n+  void* operator new(size_t s, int size) throw();\n+\n+  Method*   _method;\n+\n+public:\n+  static MethodHandleIntrinsicBlob* create(const methodHandle& method, CodeBuffer *code_buffer);\n+\n+  bool is_alive() const                     { return true; }\n+  bool is_mh_intrinsic() const              { return true; }\n+\n+  void verify();\n+\n+  Method* method()      const               { return _method; }\n+\n+  void post_dynamic_code_generated_event();\n+};\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1416,0 +1416,1 @@\n+  int mhIntrinsicCount = 0;\n@@ -1467,0 +1468,2 @@\n+      } else if (cb->is_mh_intrinsic()) {\n+        mhIntrinsicCount++;\n@@ -1496,0 +1499,1 @@\n+  tty->print_cr(\"MH intrinsics: %d\",mhIntrinsicCount);\n@@ -1528,0 +1532,1 @@\n+  CodeBlob_sizes mhIntrinsic;\n@@ -1550,0 +1555,2 @@\n+      } else if (cb->is_mh_intrinsic()) {\n+        mhIntrinsic.add(cb);\n@@ -1583,0 +1590,1 @@\n+    { \"MH intrinsic\",   &mhIntrinsic },\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -324,1 +324,1 @@\n-  bool is_monomorphic = (cb != NULL && cb->is_compiled());\n+  bool is_monomorphic = (cb != NULL && (cb->is_compiled() || cb->is_mh_intrinsic()));\n@@ -464,1 +464,1 @@\n-    assert (cb != NULL && cb->is_compiled(), \"must be compiled!\");\n+    assert (cb != NULL && (cb->is_compiled() || cb->is_mh_intrinsic()), \"must be compiled!\");\n@@ -513,1 +513,0 @@\n-                                           bool caller_is_nmethod,\n@@ -516,1 +515,2 @@\n-  CompiledMethod* method_code = method->code();\n+  CodeBlob* blob = method->code();\n+  CompiledMethod* method_code = (blob == nullptr) ? nullptr : blob->as_compiled_method_or_null();\n@@ -543,0 +543,2 @@\n+  } else if (blob != nullptr && blob->is_mh_intrinsic()) {\n+    entry = blob->as_mh_intrinsic()->code_begin();\n@@ -642,2 +644,3 @@\n-void CompiledStaticCall::compute_entry(const methodHandle& m, bool caller_is_nmethod, StaticCallInfo& info) {\n-  CompiledMethod* m_code = m->code();\n+void CompiledStaticCall::compute_entry(const methodHandle& m, StaticCallInfo& info) {\n+  CodeBlob* m_blob = m->code();\n+  CompiledMethod* m_code = (m_blob == nullptr) ? nullptr : m_blob->as_compiled_method_or_null();\n@@ -648,0 +651,3 @@\n+  } else if (m_blob != NULL && m_blob->is_mh_intrinsic()) {\n+    info._to_interpreter = false;\n+    info._entry  = m_blob->code_begin();\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-                                        bool is_optimized, bool static_bound, bool caller_is_nmethod,\n+                                        bool is_optimized, bool static_bound,\n@@ -347,1 +347,1 @@\n-  static void compute_entry(const methodHandle& m, bool caller_is_nmethod, StaticCallInfo& info);\n+  static void compute_entry(const methodHandle& m, StaticCallInfo& info);\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1464,1 +1464,1 @@\n-      NativeJump::patch_verified_entry(entry_point(), verified_entry_point(),\n+      NativeJump::patch_verified_entry(verified_entry_point(),\n@@ -2497,1 +2497,1 @@\n-  NativeJump::check_verified_entry_alignment(entry_point(), verified_entry_point());\n+  NativeJump::check_verified_entry_alignment(verified_entry_point());\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -218,1 +218,0 @@\n-  int _scopes_data_offset;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -217,3 +217,3 @@\n-  CompiledMethod *nm = method->code();\n-  if (nm != NULL && nm->is_in_use()) {\n-    return (CompLevel)nm->comp_level();\n+  CodeBlob *blob = method->code();\n+  if (blob != NULL && blob->is_compiled() && blob->as_compiled_method()->is_in_use()) {\n+    return (CompLevel)blob->as_compiled_method()->comp_level();\n@@ -757,1 +757,1 @@\n-        mh->code()->make_not_used();\n+        mh->code()->as_compiled_method()->make_not_used();\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1379,0 +1379,1 @@\n+  assert(!method->is_method_handle_intrinsic(), \"cannot compile MH intrinsic\");\n@@ -1396,1 +1397,1 @@\n-    CompiledMethod* method_code = method->code();\n+    CodeBlob* method_code = method->code();\n@@ -1399,1 +1400,1 @@\n-        return (nmethod*) method_code;\n+        return method_code->as_nmethod();\n@@ -1428,1 +1429,1 @@\n-  if (method->is_native() && !method->is_method_handle_intrinsic()) {\n+  if (method->is_native()) {\n@@ -1453,1 +1454,1 @@\n-    if (!PreferInterpreterNativeStubs || method->is_method_handle_intrinsic()) {\n+    if (!PreferInterpreterNativeStubs) {\n@@ -1500,6 +1501,2 @@\n-    CompiledMethod* code = method->code();\n-    if (code == NULL) {\n-      return (nmethod*) code;\n-    } else {\n-      return code->as_nmethod_or_null();\n-    }\n+    CodeBlob* method_code = method->code();\n+    return (method_code == nullptr) ? nullptr : method_code->as_nmethod();\n@@ -1530,3 +1527,8 @@\n-      CompiledMethod* result = method->code();\n-      if (result == NULL) return false;\n-      return comp_level == result->comp_level();\n+      CodeBlob* result = method->code();\n+      if (result != nullptr && result->is_compiled()) {\n+        return comp_level == result->as_compiled_method()->comp_level();\n+      } else if (result != nullptr && result->is_mh_intrinsic()) {\n+        return comp_level == CompLevel_none;\n+      } else {\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-    nmethod* nm = (cb == NULL) ? NULL : cb->as_compiled_method()->as_nmethod_or_null();\n+    nmethod* nm = (cb == NULL) ? NULL : cb->as_nmethod_or_null();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1136,3 +1136,3 @@\n-  CompiledMethod* code = method->code();\n-  if (code != NULL) {\n-    code->make_not_entrant();\n+  CodeBlob* code = method->code();\n+  if (code != NULL && code->is_compiled()) {\n+    code->as_compiled_method()->make_not_entrant();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2168,1 +2168,2 @@\n-            CompiledMethod* old = method->code();\n+            CodeBlob* old_code = method->code();\n+            CompiledMethod* old = (old_code == nullptr) ? nullptr : old_code->as_compiled_method();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-  volatile_nonstatic_field(Method,             _code,                                         CompiledMethod*)                       \\\n+  volatile_nonstatic_field(Method,             _code,                                         CodeBlob*)                             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1015,1 +1015,1 @@\n-  CompiledMethod* nm = code(); \/\/ Put it into local variable to guard against concurrent updates\n+  CodeBlob* nm = code();       \/\/ Put it into local variable to guard against concurrent updates\n@@ -1017,1 +1017,1 @@\n-    nm->make_not_entrant();\n+    nm->as_compiled_method()->make_not_entrant();\n@@ -1274,3 +1274,5 @@\n-  CompiledMethod *code = Atomic::load_acquire(&_code);\n-  if (code) {\n-    return code->verified_entry_point();\n+  CodeBlob *code = Atomic::load_acquire(&_code);\n+  if (code != nullptr && code->is_compiled()) {\n+    return code->as_compiled_method()->verified_entry_point();\n+  } else if (code != nullptr && code->is_mh_intrinsic()) {\n+    return code->as_mh_intrinsic()->code_begin();\n@@ -1300,2 +1302,10 @@\n-  CompiledMethod *code = Atomic::load_acquire(&_code);\n-  return code == NULL || (code->method() == NULL) || (code->method() == (Method*)this && !code->is_osr_method());\n+  CodeBlob *blob = Atomic::load_acquire(&_code);\n+  if (blob == nullptr) {\n+    return true;\n+  } else if (blob->is_compiled()) {\n+    CompiledMethod* cm = blob->as_compiled_method();\n+    return (cm->method() == nullptr) || (cm->method() == this && !cm->is_osr_method());\n+  } else {\n+    MethodHandleIntrinsicBlob* mhi = blob->as_mh_intrinsic();\n+    return mhi->method() == this;\n+  }\n@@ -1305,1 +1315,1 @@\n-void Method::set_code(const methodHandle& mh, CompiledMethod *code) {\n+void Method::set_code(const methodHandle& mh, CodeBlob *code) {\n@@ -1317,1 +1327,1 @@\n-  int comp_level = code->comp_level();\n+  int comp_level = code->is_compiled() ? code->as_compiled_method()->comp_level() : CompLevel_none;\n@@ -1325,1 +1335,6 @@\n-  mh->_from_compiled_entry = code->verified_entry_point();\n+  if (code->is_compiled()) {\n+    mh->_from_compiled_entry = code->as_compiled_method()->verified_entry_point();\n+  }\n+  else {\n+    mh->_from_compiled_entry = code->code_begin();\n+  }\n@@ -2448,1 +2463,1 @@\n-  if (WizardMode && code() != NULL) st->print(\" ((nmethod*)%p)\", code());\n+  if (WizardMode && code() != NULL) st->print(\" ((CodeBlob*)%p)\", code());\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":26,"deletions":11,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-  CompiledMethod* volatile _code;                       \/\/ Points to the corresponding piece of native code\n+  CodeBlob* volatile _code;                           \/\/ Points to the corresponding piece of native code\n@@ -442,1 +442,1 @@\n-  CompiledMethod* volatile code() const;\n+  CodeBlob* volatile code() const;\n@@ -454,1 +454,1 @@\n-  static void set_code(const methodHandle& mh, CompiledMethod* code);\n+  static void set_code(const methodHandle& mh, CodeBlob* code);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-inline CompiledMethod* volatile Method::code() const {\n+inline CodeBlob* volatile Method::code() const {\n","filename":"src\/hotspot\/share\/oops\/method.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1779,1 +1779,1 @@\n-    CompiledMethod* cm = blob->as_compiled_method_or_null();\n+    CompiledMethod* cm = blob->as_compiled_method();\n@@ -1781,0 +1781,3 @@\n+  } else if (blob->is_mh_intrinsic()) {\n+    MethodHandleIntrinsicBlob* mhi = blob->as_mh_intrinsic();\n+    mhi->method()->print_value_on(&tempst);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -793,1 +793,1 @@\n-    mh->code()->mark_for_deoptimization();\n+    mh->code()->as_compiled_method()->mark_for_deoptimization();\n@@ -808,1 +808,2 @@\n-  CompiledMethod* code = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n+  CodeBlob* blob = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n+  CompiledMethod* code = (blob == nullptr) ? nullptr : blob->as_compiled_method_or_null();\n@@ -908,2 +909,2 @@\n-  CompiledMethod* code = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n-  return (code != NULL ? code->comp_level() : CompLevel_none);\n+  CodeBlob* code = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n+  return (code != NULL && code->is_compiled()) ? code->as_compiled_method()->comp_level() : CompLevel_none;\n@@ -1067,1 +1068,1 @@\n-    CompiledMethod* code = mh->code();\n+    CodeBlob* code = mh->code();\n@@ -1527,1 +1528,2 @@\n-  CompiledMethod* code = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n+  CodeBlob* blob = is_osr ? mh->lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh->code();\n+  CompiledMethod* code = (blob == nullptr) ? nullptr : blob->as_compiled_method_or_null();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-  CompiledMethod* nm = (CompiledMethod *)_cb;\n+  CompiledMethod* nm = _cb->as_compiled_method();\n@@ -340,1 +340,1 @@\n-  CompiledMethod* nm = (CompiledMethod*)_cb;\n+  CompiledMethod* nm = _cb->as_compiled_method();\n@@ -688,1 +688,1 @@\n-      CompiledMethod* cm = (CompiledMethod*)_cb;\n+      CompiledMethod* cm = _cb->as_compiled_method();\n@@ -737,0 +737,2 @@\n+    } else if (_cb->is_mh_intrinsic()) {\n+      st->print(\"v  ~MethodHandleIntrinsicBlob \" PTR_FORMAT, p2i(pc()));\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -901,1 +901,1 @@\n-  CompiledMethod* nm = (CompiledMethod*)cb;\n+  CompiledMethod* nm = cb->as_compiled_method();\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -557,1 +557,1 @@\n-  assert(((CompiledMethod*)cb)->is_at_poll_or_poll_return(pc),\n+  assert(cb->as_compiled_method()->is_at_poll_or_poll_return(pc),\n@@ -883,1 +883,1 @@\n-          if (!cb->is_compiled()) {\n+          if (!cb->is_compiled() && !cb->is_mh_intrinsic()) {\n@@ -895,9 +895,11 @@\n-          CompiledMethod* cm = (CompiledMethod*)cb;\n-          if (cm->inlinecache_check_contains(pc)) {\n-            \/\/ exception happened inside inline-cache check code\n-            \/\/ => the nmethod is not yet active (i.e., the frame\n-            \/\/ is not set up yet) => use return address pushed by\n-            \/\/ caller => don't push another return address\n-            Events::log_exception(current, \"NullPointerException in IC check \" INTPTR_FORMAT, p2i(pc));\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n-          }\n+          if (cb->is_compiled()) {\n+            CompiledMethod* cm = cb->as_compiled_method();\n+\n+            if (cm->inlinecache_check_contains(pc)) {\n+              \/\/ exception happened inside inline-cache check code\n+              \/\/ => the nmethod is not yet active (i.e., the frame\n+              \/\/ is not set up yet) => use return address pushed by\n+              \/\/ caller => don't push another return address\n+              Events::log_exception(current, \"NullPointerException in IC check \" INTPTR_FORMAT, p2i(pc));\n+              return StubRoutines::throw_NullPointerException_at_call_entry();\n+            }\n@@ -905,1 +907,9 @@\n-          if (cm->method()->is_method_handle_intrinsic()) {\n+#ifndef PRODUCT\n+            _implicit_null_throws++;\n+#endif\n+            target_pc = cm->continuation_for_implicit_null_exception(pc);\n+            \/\/ If there's an unexpected fault, target_pc might be NULL,\n+            \/\/ in which case we want to fall through into the normal\n+            \/\/ error handling code.\n+          } else {\n+            assert(cb->as_mh_intrinsic()->method()->is_method_handle_intrinsic(), \"should be MH adapter\");\n@@ -910,8 +920,0 @@\n-\n-#ifndef PRODUCT\n-          _implicit_null_throws++;\n-#endif\n-          target_pc = cm->continuation_for_implicit_null_exception(pc);\n-          \/\/ If there's an unexpected fault, target_pc might be NULL,\n-          \/\/ in which case we want to fall through into the normal\n-          \/\/ error handling code.\n@@ -1283,1 +1285,1 @@\n-  CompiledMethod* callee = callee_method->code();\n+  CodeBlob* callee = callee_method->code();\n@@ -1286,1 +1288,1 @@\n-    assert(callee->is_compiled(), \"must be nmethod for patching\");\n+    assert(callee->is_compiled() || callee->is_mh_intrinsic(), \"must be nmethod or MH intrinsic for patching\");\n@@ -1289,1 +1291,1 @@\n-  if (callee != NULL && !callee->is_in_use()) {\n+  if (callee != NULL && callee->is_compiled() && !callee->as_compiled_method()->is_in_use()) {\n@@ -1293,1 +1295,1 @@\n-  nmethodLocker nl_callee(callee);\n+  nmethodLocker nl_callee((callee != nullptr) ? callee->as_compiled_method_or_null() : nullptr);\n@@ -1295,1 +1297,1 @@\n-  address dest_entry_point = callee == NULL ? 0 : callee->entry_point(); \/\/ used below\n+  address dest_entry_point = callee == NULL ? 0 : (callee->is_compiled() ? callee->as_compiled_method()->entry_point() : callee->code_begin()); \/\/ used below\n@@ -1305,1 +1307,1 @@\n-                     is_optimized, static_bound, is_nmethod, virtual_call_info,\n+                     is_optimized, static_bound, virtual_call_info,\n@@ -1309,1 +1311,1 @@\n-    CompiledStaticCall::compute_entry(callee_method, is_nmethod, static_call_info);\n+    CompiledStaticCall::compute_entry(callee_method, static_call_info);\n@@ -1325,1 +1327,1 @@\n-        (callee == NULL || (callee->is_in_use() && callee_method->code() == callee))) {\n+        (callee == NULL || callee->is_mh_intrinsic() || (callee->as_compiled_method()->is_in_use() && callee_method->code() == callee))) {\n@@ -1331,1 +1333,1 @@\n-        assert((cb != NULL) && cb->is_compiled() && (((CompiledMethod*)cb) == callee),\n+        assert((cb != NULL) && (cb->is_compiled() || cb->is_mh_intrinsic()) && (cb == callee),\n@@ -1690,1 +1692,1 @@\n-                                            false, caller_nm->is_nmethod(),\n+                                            false,\n@@ -3093,1 +3095,1 @@\n-  nmethod* nm = NULL;\n+  CodeBlob* blob = NULL;\n@@ -3148,1 +3150,5 @@\n-      nm = SharedRuntime::generate_native_wrapper(&_masm, method, compile_id, sig_bt, regs, ret_type);\n+      if (!method->is_method_handle_intrinsic()) {\n+        blob = SharedRuntime::generate_native_wrapper(&_masm, method, compile_id, sig_bt, regs, ret_type);\n+      } else {\n+        blob = SharedRuntime::generate_method_handle_intrinsic_wrapper(&_masm, method, compile_id, sig_bt, regs, ret_type);\n+      }\n@@ -3150,1 +3156,1 @@\n-      if (nm != NULL) {\n+      if (blob != NULL) {\n@@ -3153,2 +3159,2 @@\n-          if (nm->make_in_use()) {\n-            method->set_code(method, nm);\n+          if (blob->is_mh_intrinsic() || blob->as_nmethod()->make_in_use()) {\n+            method->set_code(method, blob);\n@@ -3160,1 +3166,1 @@\n-          nm->print_code();\n+          blob->print_code();\n@@ -3169,1 +3175,2 @@\n-  if (nm != NULL) {\n+  if (blob != NULL && blob->is_nmethod()) {\n+    nmethod* nm = blob->as_nmethod();\n@@ -3177,0 +3184,2 @@\n+  } else if (blob != NULL && blob->is_mh_intrinsic()) {\n+    blob->as_mh_intrinsic()->post_dynamic_code_generated_event();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":46,"deletions":37,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -483,0 +483,7 @@\n+  static CodeBlob* generate_method_handle_intrinsic_wrapper(MacroAssembler* masm,\n+                                                            const methodHandle& method,\n+                                                            int compile_id,\n+                                                            BasicType* sig_bt,\n+                                                            VMRegPair* regs,\n+                                                            BasicType ret_type);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-  volatile_nonstatic_field(Method,             _code,                                         CompiledMethod*)                       \\\n+  volatile_nonstatic_field(Method,             _code,                                         CodeBlob*)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-    final int methodCodeOffset = getFieldOffset(\"Method::_code\", Integer.class, \"CompiledMethod*\");\n+    final int methodCodeOffset = getFieldOffset(\"Method::_code\", Integer.class, \"CodeBlob*\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+                       + \" #\\\\d+ MH intrinsic = \" + entry\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckCodeCacheInfo.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}