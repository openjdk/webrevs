{"files":[{"patch":"@@ -940,1 +940,1 @@\n-                                            allPermittedSubTypes((ClassSymbol) bpOther.type.tsym, s -> true);\n+                                            allPermittedSubTypes(bpOther.type.tsym, s -> true);\n@@ -976,1 +976,1 @@\n-        private Set<Symbol> allPermittedSubTypes(ClassSymbol root, Predicate<ClassSymbol> accept) {\n+        private Set<Symbol> allPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n@@ -978,1 +978,1 @@\n-            List<ClassSymbol> permittedSubtypesClosure = List.of(root);\n+            List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n@@ -1002,0 +1002,14 @@\n+        private List<ClassSymbol> baseClasses(TypeSymbol root) {\n+            if (root instanceof ClassSymbol clazz) {\n+                return List.of(clazz);\n+            } else if (root instanceof TypeVariableSymbol tvar) {\n+                ListBuffer<ClassSymbol> result = new ListBuffer<>();\n+                for (Type bound : tvar.getBounds()) {\n+                    result.appendList(baseClasses(bound.tsym));\n+                }\n+                return result.toList();\n+            } else {\n+                return List.nil();\n+            }\n+        }\n+\n@@ -1147,1 +1161,1 @@\n-                    covered &= isBpCovered(componentType[i], newNested);\n+                    covered &= checkCovered(componentType[i], List.of(newNested));\n@@ -1178,1 +1192,1 @@\n-                        Set<Symbol> permittedSymbols = allPermittedSubTypes((ClassSymbol) bp.type.tsym, cs -> true);\n+                        Set<Symbol> permittedSymbols = allPermittedSubTypes(bp.type.tsym, cs -> true);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215 8333169\n+ * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215 8333169 8327368\n@@ -2108,0 +2108,77 @@\n+    @Test\n+    public void testNestedIntersectionType(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               public class Test {\n+\n+                   static abstract class Abs {}\n+\n+                   sealed interface B permits V {}\n+\n+                   static final class V extends Abs implements B {}\n+\n+                   final static record R<T extends B>(T b) {}\n+\n+                   static <T extends Abs & B> int r(R<T> r) {\n+                       return switch (r) {\n+                           case R(B b) -> 3;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+    @Test \/\/JDK-8327368\n+    public void testExpandForTypeVariables(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               public class Test {\n+                   sealed interface A permits T, U {}\n+                   sealed interface B permits V, W {}\n+\n+                   static final class T implements A { public T() {} }\n+                   static final class U implements A { public U() {} }\n+\n+                   static final class V implements B { public V() {} }\n+                   static final class W implements B { public W() {} }\n+\n+                   final static record R<T1 extends A, T2 extends B>(T1 a, T2 b) { }\n+\n+                   static <T1 extends A, T2 extends B> int r(R<T1, T2> r) {\n+                       return switch (r) {\n+                           case R(A a, V b) -> 1; \/\/ Any A with specific B\n+                           case R(T a, var b) -> 2; \/\/ Specific A with any B\n+                           case R(U a, W b) -> 3; \/\/ Specific A with specific B\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               public class Test {\n+                   sealed interface A permits T, U {}\n+                   sealed interface B permits V, W {}\n+\n+                   static final class T implements A { public T() {} }\n+                   static final class U implements A { public U() {} }\n+\n+                   static final class V extends Abs implements B { public V() {} }\n+                   static final class W extends Abs implements B { public W() {} }\n+\n+                   static abstract class Abs {}\n+\n+                   final static record R<T1 extends A, T2 extends B>(T1 a, T2 b) { }\n+\n+                   static <T1 extends A, T2 extends Abs & B> int r(R<T1, T2> r) {\n+                       return switch (r) {\n+                           case R(A a, V b) -> 1; \/\/ Any A with specific B\n+                           case R(T a, var b) -> 2; \/\/ Specific A with any B\n+                           case R(U a, W b) -> 3; \/\/ Specific A with specific B\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":79,"deletions":2,"binary":false,"changes":81,"status":"modified"}]}