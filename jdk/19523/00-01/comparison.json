{"files":[{"patch":"@@ -940,1 +940,1 @@\n-                                            allPermittedSubTypes((ClassSymbol) bpOther.type.tsym, s -> true);\n+                                            allPermittedSubTypes(bpOther.type.tsym, s -> true);\n@@ -976,1 +976,1 @@\n-        private Set<Symbol> allPermittedSubTypes(ClassSymbol root, Predicate<ClassSymbol> accept) {\n+        private Set<Symbol> allPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n@@ -978,1 +978,1 @@\n-            List<ClassSymbol> permittedSubtypesClosure = List.of(root);\n+            List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n@@ -1002,0 +1002,14 @@\n+        private List<ClassSymbol> baseClasses(TypeSymbol root) {\n+            if (root instanceof ClassSymbol clazz) {\n+                return List.of(clazz);\n+            } else if (root instanceof TypeVariableSymbol tvar) {\n+                ListBuffer<ClassSymbol> result = new ListBuffer<>();\n+                for (Type bound : tvar.getBounds()) {\n+                    result.appendList(baseClasses(bound.tsym));\n+                }\n+                return result.toList();\n+            } else {\n+                return List.nil();\n+            }\n+        }\n+\n@@ -1147,1 +1161,1 @@\n-                    covered &= isBpCovered(componentType[i], newNested);\n+                    covered &= checkCovered(componentType[i], List.of(newNested));\n@@ -1177,2 +1191,2 @@\n-                    } else if (pd instanceof BindingPattern bp && bp.type.tsym instanceof ClassSymbol clazz) {\n-                        Set<Symbol> permittedSymbols = allPermittedSubTypes(clazz, cs -> true);\n+                    } else if (pd instanceof BindingPattern bp) {\n+                        Set<Symbol> permittedSymbols = allPermittedSubTypes(bp.type.tsym, cs -> true);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2108,0 +2108,23 @@\n+    @Test\n+    public void testNestedIntersectionType(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               public class Test {\n+\n+                   static abstract class Abs {}\n+\n+                   sealed interface B permits V {}\n+\n+                   static final class V extends Abs implements B {}\n+\n+                   final static record R<T extends B>(T b) {}\n+\n+                   static <T extends Abs & B> int r(R<T> r) {\n+                       return switch (r) {\n+                           case R(B b) -> 3;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n@@ -2114,1 +2137,2 @@\n-                   interface Parent { int a();}\n+                   sealed interface A permits T, U {}\n+                   sealed interface B permits V, W {}\n@@ -2116,5 +2140,2 @@\n-                   static class Child implements Parent {\n-                       public int a() {\n-                           return 1;\n-                       }\n-                   }\n+                   static final class T implements A { public T() {} }\n+                   static final class U implements A { public U() {} }\n@@ -2122,1 +2143,2 @@\n-                   record Rec<T, U>(T a, U b) {}\n+                   static final class V implements B { public V() {} }\n+                   static final class W implements B { public W() {} }\n@@ -2124,6 +2146,8 @@\n-                   private static <T extends Parent, U extends Parent> boolean test(Rec<T, U> p) {\n-                       boolean res;\n-                       switch (p) {\n-                           case Rec(Child a, var b) -> res = a.a() + b.a() == 2; \/\/line A\n-                       }\n-                       return res;\n+                   final static record R<T1 extends A, T2 extends B>(T1 a, T2 b) { }\n+\n+                   static <T1 extends A, T2 extends B> int r(R<T1, T2> r) {\n+                       return switch (r) {\n+                           case R(A a, V b) -> 1; \/\/ Any A with specific B\n+                           case R(T a, var b) -> 2; \/\/ Specific A with any B\n+                           case R(U a, W b) -> 3; \/\/ Specific A with specific B\n+                       };\n@@ -2131,0 +2155,8 @@\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               public class Test {\n+                   sealed interface A permits T, U {}\n+                   sealed interface B permits V, W {}\n@@ -2132,2 +2164,16 @@\n-                   public static void main(String argv[]) {\n-                       System.out.println(test(new Rec<>(new Child(), new Child())));\n+                   static final class T implements A { public T() {} }\n+                   static final class U implements A { public U() {} }\n+\n+                   static final class V extends Abs implements B { public V() {} }\n+                   static final class W extends Abs implements B { public W() {} }\n+\n+                   static abstract class Abs {}\n+\n+                   final static record R<T1 extends A, T2 extends B>(T1 a, T2 b) { }\n+\n+                   static <T1 extends A, T2 extends Abs & B> int r(R<T1, T2> r) {\n+                       return switch (r) {\n+                           case R(A a, V b) -> 1; \/\/ Any A with specific B\n+                           case R(T a, var b) -> 2; \/\/ Specific A with any B\n+                           case R(U a, W b) -> 3; \/\/ Specific A with specific B\n+                       };\n@@ -2136,3 +2182,1 @@\n-               \"\"\",\n-               \"Test.java:14:9: compiler.err.not.exhaustive.statement\",\n-               \"1 error\");\n+               \"\"\");\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":62,"deletions":18,"binary":false,"changes":80,"status":"modified"}]}