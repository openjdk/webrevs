{"files":[{"patch":"@@ -385,32 +385,0 @@\n-        \/**\n-         * Returns if this utf8 entry's content equals a substring\n-         * of {@code s} obtained as {@code s.substring(start, end - start)}.\n-         * This check avoids a substring allocation.\n-         *\/\n-        public boolean equalsRegion(String s, int start, int end) {\n-            \/\/ start and end values trusted\n-            if (state == State.RAW)\n-                inflate();\n-            int len = charLen;\n-            if (len != end - start)\n-                return false;\n-\n-            var sv = stringValue;\n-            if (sv != null) {\n-                return sv.regionMatches(0, s, start, len);\n-            }\n-\n-            var chars = this.chars;\n-            if (chars != null) {\n-                for (int i = 0; i < len; i++)\n-                    if (chars[i] != s.charAt(start + i))\n-                        return false;\n-            } else {\n-                var bytes = this.rawBytes;\n-                for (int i = 0; i < len; i++)\n-                    if (bytes[offset + i] != s.charAt(start + i))\n-                        return false;\n-            }\n-            return true;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -397,18 +397,0 @@\n-    private AbstractPoolEntry.Utf8EntryImpl tryFindUtf8OfRegion(int hash, String target, int start, int end) {\n-        EntryMap map = map();\n-        while (true) {\n-            for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n-                PoolEntry e = entryByIndex(map.getIndexByToken(token));\n-                if (e.tag() == TAG_UTF8\n-                        && e instanceof AbstractPoolEntry.Utf8EntryImpl ce\n-                        && ce.equalsRegion(target, start, end))\n-                    return ce;\n-            }\n-            if (!doneFullScan) {\n-                fullScan();\n-                continue;\n-            }\n-            return null;\n-        }\n-    }\n-\n@@ -432,2 +414,1 @@\n-                    var desc = cd.descriptorString();\n-                    if (ce.ref1.equalsRegion(desc, 1, desc.length() - 1)) {\n+                    if (ce.ref1.equalsString(Util.toInternalName(cd))) {\n@@ -457,2 +438,3 @@\n-        var utfHash = Util.internalNameHash(desc);\n-        var utf = tryFindUtf8OfRegion(AbstractPoolEntry.hashString(utfHash), desc, 1, desc.length() - 1);\n+        String internalName = Util.toInternalName(cd);\n+        var utfHash = internalName.hashCode();\n+        var utf = tryFindUtf8(AbstractPoolEntry.hashString(utfHash), internalName);\n@@ -460,1 +442,1 @@\n-            utf = internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, ConstantUtils.dropFirstAndLastChar(desc), utfHash));\n+            utf = internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, internalName, utfHash));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -136,4 +137,4 @@\n-        var desc = cd.descriptorString();\n-        if (desc.charAt(0) == 'L')\n-            return desc.substring(1, desc.length() - 1);\n-        throw new IllegalArgumentException(desc);\n+        if (cd instanceof ReferenceClassDescImpl rcd) {\n+            return rcd.internalName();\n+        }\n+        throw new IllegalArgumentException(cd.descriptorString());\n@@ -324,9 +325,0 @@\n-    \/**\n-     * Returns the hash code of an internal name given the class or interface L descriptor.\n-     *\/\n-    public static int internalNameHash(String desc) {\n-        if (desc.length() > 0xffff)\n-            throw new IllegalArgumentException(\"String too long: \".concat(Integer.toString(desc.length())));\n-        return (desc.hashCode() - pow31(desc.length() - 1) * 'L' - ';') * INVERSE_31;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -39,0 +40,1 @@\n+    private @Stable String internalName;\n@@ -79,0 +81,10 @@\n+    public String internalName() {\n+        var internalName = this.internalName;\n+        if (internalName == null) {\n+            var desc = this.descriptor;\n+            this.internalName = internalName = desc.charAt(0) == 'L' ? dropFirstAndLastChar(desc) : desc;\n+        }\n+\n+        return internalName;\n+    }\n+\n@@ -93,1 +105,1 @@\n-        return lookup.findClass(internalToBinary(dropFirstAndLastChar(descriptor)));\n+        return lookup.findClass(internalToBinary(internalName()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ReferenceClassDescImpl.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -106,14 +106,0 @@\n-    @ParameterizedTest\n-    @ValueSource(classes = {\n-            Long.class,\n-            Object.class,\n-            Util.class,\n-            Test.class,\n-            CopyOnWriteArrayList.class,\n-            AtomicReferenceFieldUpdater.class\n-    })\n-    void testInternalNameHash(Class<?> type) {\n-        var cd = type.describeConstable().orElseThrow();\n-        assertEquals(ConstantUtils.binaryToInternal(type.getName()).hashCode(), Util.internalNameHash(cd.descriptorString()));\n-    }\n-\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"}]}