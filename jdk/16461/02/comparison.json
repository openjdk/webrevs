{"files":[{"patch":"@@ -193,10 +193,1 @@\n- * <h2><a id=unnamedClasses>Unnamed Classes<\/a><\/h2>\n- *\n- * A {@code class} file representing an {@linkplain #isUnnamedClass unnamed class}\n- * is generated by a Java compiler from a source file for an unnamed class.\n- * The {@code Class} object representing an unnamed class is top-level,\n- * {@linkplain #isSynthetic synthetic}, and {@code final}. While an\n- * unnamed class does <em>not<\/em> have a name in its Java source\n- * form, several of the name-related methods of {@code java.lang.Class}\n- * do return non-null and non-empty results for the {@code Class}\n- * object representing an unnamed class.\n+ * <h2><a id=implicitClasses>Implicit Classes<\/a><\/h2>\n@@ -205,1 +196,1 @@\n- * unnamed class, say {@code HelloWorld.java}, creates a\n+ * implicit class, say {@code HelloWorld.java}, creates a\n@@ -211,1 +202,1 @@\n- * For the {@code Class} object of an unnamed class {@code\n+ * For the {@code Class} object of an implicit class {@code\n@@ -215,2 +206,2 @@\n- * simple name} of such an unnamed class is the empty string and the\n- * {@linkplain #getCanonicalName canonical name} is {@code null}.\n+ * simple name} of such an implicit class is {@code \"HelloWorld\"} and the\n+ * {@linkplain #getCanonicalName canonical name} is {@code \"HelloWorld\"}.\n@@ -1812,1 +1803,1 @@\n-     * {@linkplain #isAnonymousClass() anonymous} or {@linkplain #isUnnamedClass() unnamed}.\n+     * {@linkplain #isAnonymousClass() anonymous}.\n@@ -1825,3 +1816,0 @@\n-        if (isUnnamedClass()) {\n-            return \"\";\n-        }\n@@ -1877,1 +1865,0 @@\n-     * <li>an {@linkplain #isUnnamedClass() unnamed class}\n@@ -1897,3 +1884,0 @@\n-        if (isUnnamedClass()) {\n-            return null;\n-        }\n@@ -1934,20 +1918,0 @@\n-    \/**\n-     * {@return {@code true} if and only if the underlying class\n-     * is an unnamed class}\n-     *\n-     * @apiNote\n-     * An unnamed class is not an {@linkplain #isAnonymousClass anonymous class}.\n-     *\n-     * @since 21\n-     *\n-     * @jls 7.3 Compilation Units\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED_CLASSES,\n-                    reflective=true)\n-    public boolean isUnnamedClass() {\n-        return PreviewFeatures.isEnabled() && isSynthetic()\n-                                           && isTopLevelClass()\n-                                           && Modifier.isFinal(getModifiers());\n-    }\n-\n-\n@@ -1960,1 +1924,0 @@\n-     * An anonymous class is not an {@linkplain #isUnnamedClass() unnamed class}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":6,"deletions":43,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+        @JEP(number=999, title=\"Implicit Classes and Instance Main Methods\")\n+        IMPLICIT_CLASSES,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -34,6 +32,0 @@\n-    private static boolean correctArgs(Method method) {\n-        int argc = method.getParameterCount();\n-\n-        return argc == 0 || argc == 1 && method.getParameterTypes()[0] == String[].class;\n-    }\n-\n@@ -41,1 +33,1 @@\n-     * Gather all the \"main\" methods in the class hierarchy.\n+     * {@return true if method mets the requirements of a main method}\n@@ -43,3 +35,2 @@\n-     * @param refc         the main class or super class\n-     * @param mains        accumulated main methods\n-     * @param isMainClass  the class is the main class and not a super class\n+     * @param method    method to test\n+     * @param argCount  number of expected arguments (0 or 1)\n@@ -47,65 +38,6 @@\n-    private static void gatherMains(Class<?> refc, List<Method> mains, boolean isMainClass) {\n-        if (refc != null && refc != Object.class) {\n-            for (Method method : refc.getDeclaredMethods()) {\n-                int mods = method.getModifiers();\n-                \/\/ Must be named \"main\", public|protected|package-private, not synthetic (bridge) and either\n-                \/\/ no arguments or one string array argument. Only statics in the Main class are acceptable.\n-                if (\"main\".equals(method.getName()) &&\n-                        !method.isSynthetic() &&\n-                        !Modifier.isPrivate(mods) &&\n-                        correctArgs(method) &&\n-                        (isMainClass || !Modifier.isStatic(mods)))\n-                {\n-                    mains.add(method);\n-                }\n-            }\n-\n-            gatherMains(refc.getSuperclass(), mains, false);\n-        }\n-    }\n-\n-    \/**\n-     * Comparator for two methods.\n-     * Priority order is;\n-     * sub-class < super-class.\n-     * static < non-static,\n-     * string arg < no arg and\n-     *\n-     * @param a  first method\n-     * @param b  second method\n-     *\n-     * @return -1, 0 or 1 to represent higher priority. equals priority or lesser priority.\n-     *\/\n-    private static int compareMethods(Method a, Method b) {\n-        Class<?> aClass = a.getDeclaringClass();\n-        Class<?> bClass = b.getDeclaringClass();\n-\n-        if (aClass != bClass) {\n-            if (bClass.isAssignableFrom(aClass)) {\n-                return -1;\n-            } else {\n-                return 1;\n-            }\n-        }\n-\n-        int aMods = a.getModifiers();\n-        int bMods = b.getModifiers();\n-        boolean aIsStatic = Modifier.isStatic(aMods);\n-        boolean bIsStatic = Modifier.isStatic(bMods);\n-\n-        if (aIsStatic && !bIsStatic) {\n-            return -1;\n-        } else if (!aIsStatic && bIsStatic) {\n-            return 1;\n-        }\n-\n-        int aCount = a.getParameterCount();\n-        int bCount = b.getParameterCount();\n-\n-        if (bCount < aCount) {\n-            return -1;\n-        } else if (aCount < bCount) {\n-            return 1;\n-        }\n-\n-        return 0;\n+    private static boolean isMainMethod(Method method, int argCount) {\n+        return !Modifier.isPrivate(method.getModifiers()) &&\n+                method.getParameterCount() == argCount &&\n+                (argCount == 0 || method.getParameterTypes()[0] == String[].class) &&\n+                method.getReturnType() == void.class &&\n+                \"main\".equals(method.getName());\n@@ -115,1 +47,1 @@\n-     * Return the traditional main method or null if not found.\n+     * Search up the superclass hierarchy for a qualified main method.\n@@ -117,1 +49,2 @@\n-     * @param mainClass main class\n+     * @param mainClass    Main class to start search from.\n+     * @param noArgs       true if no argument otherwise expects one String[] argument\n@@ -119,1 +52,1 @@\n-     * @return main method or null\n+     * @return main method meeting requirements\n@@ -121,7 +54,7 @@\n-    private static Method getTraditionalMain(Class<?> mainClass) {\n-        try {\n-            Method traditionalMain = mainClass.getMethod(\"main\", String[].class);\n-            int mods = traditionalMain.getModifiers();\n-\n-            if (Modifier.isStatic(mods) && Modifier.isPublic(mods) && traditionalMain.getReturnType() == void.class) {\n-                return traditionalMain;\n+    private static Method findMainMethod(Class<?> mainClass, boolean noArgs) {\n+        int argCount = noArgs ? 0 : 1;\n+        for ( ; mainClass != null && mainClass != Object.class; mainClass = mainClass.getSuperclass()) {\n+            for (Method method : mainClass.getDeclaredMethods()) {\n+                if (isMainMethod(method, argCount)) {\n+                    return method;\n+                }\n@@ -129,2 +62,0 @@\n-        } catch (NoSuchMethodException ex) {\n-            \/\/ not found\n@@ -137,1 +68,1 @@\n-     * {@return priority main method if none found}\n+     * {@return qualified main method}\n@@ -141,1 +72,1 @@\n-     * @throws NoSuchMethodException when not preview and no method found\n+     * @throws NoSuchMethodException when no main method found\n@@ -144,4 +75,2 @@\n-        boolean isTraditionMain = !PreviewFeatures.isEnabled();\n-        if (isTraditionMain) {\n-            return mainClass.getMethod(\"main\", String[].class);\n-        }\n+        boolean useTraditionMain = !PreviewFeatures.isEnabled();\n+        boolean isTraditionalMain = false;\n@@ -149,2 +78,1 @@\n-        List<Method> mains = new ArrayList<>();\n-        gatherMains(mainClass, mains, true);\n+        Method mainMethod = findMainMethod(mainClass, false);\n@@ -152,2 +80,5 @@\n-        if (mains.isEmpty()) {\n-            throw new NoSuchMethodException(\"No main method found\");\n+        if (mainMethod == null) {\n+            mainMethod = findMainMethod(mainClass, true);\n+        } else {\n+            int mods = mainMethod.getModifiers();\n+            isTraditionalMain = Modifier.isStatic(mods) && Modifier.isPublic(mods);\n@@ -156,9 +87,2 @@\n-        if (1 < mains.size()) {\n-            mains.sort(MainMethodFinder::compareMethods);\n-        }\n-\n-        Method mainMethod = mains.get(0);\n-        Method traditionalMain = getTraditionalMain(mainClass);\n-\n-        if (traditionalMain != null && !traditionalMain.equals(mainMethod)) {\n-            System.err.println(\"WARNING: \\\"\" + mains.get(0) + \"\\\" chosen over \\\"\" + traditionalMain + \"\\\"\");\n+        if (mainMethod == null || useTraditionMain && !isTraditionalMain) {\n+            throw new NoSuchMethodException(mainClass.getName() + \".main(String[])\");\n@@ -167,1 +91,1 @@\n-        return mains.get(0);\n+        return mainMethod;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MainMethodFinder.java","additions":33,"deletions":109,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -862,1 +862,1 @@\n-            abort(le, \"java.launcher.cls.error6\", cn,\n+            abort(le, \"java.launcher.cls.error4\", cn,\n@@ -921,1 +921,1 @@\n-            abort(null, \"java.launcher.cls.error4\", mainClass.getName(),\n+            abort(null, \"java.launcher.cls.error2\", mainClass.getName(),\n@@ -925,1 +925,1 @@\n-                abort(e, \"java.launcher.module.error5\",\n+                abort(e, \"java.launcher.module.error3\",\n@@ -929,1 +929,1 @@\n-                abort(e, \"java.launcher.cls.error7\", mainClass.getName(),\n+                abort(e, \"java.launcher.cls.error5\", mainClass.getName(),\n@@ -936,18 +936,2 @@\n-        \/*\n-         * findMainMethod (above) will choose the correct method, based\n-         * on its name and parameter type, however, we still have to\n-         * ensure that the method is static (non-preview) and returns a void.\n-         *\/\n-        int mods = mainMethod.getModifiers();\n-        boolean isStatic = Modifier.isStatic(mods);\n-        boolean isPublic = Modifier.isPublic(mods);\n-        boolean noArgs = mainMethod.getParameterCount() == 0;\n-\n-        if (!PreviewFeatures.isEnabled()) {\n-            if (!isStatic || !isPublic || noArgs) {\n-                abort(null, \"java.launcher.cls.error2\", \"static\",\n-                      mainMethod.getDeclaringClass().getName());\n-            }\n-        }\n-\n-        if (!isStatic) {\n+        if (!Modifier.isStatic(mainMethod.getModifiers())) {\n+            String className = mainMethod.getDeclaringClass().getName();\n@@ -955,2 +939,1 @@\n-                abort(null, \"java.launcher.cls.error9\",\n-                        mainMethod.getDeclaringClass().getName());\n+                abort(null, \"java.launcher.cls.error7\", className);\n@@ -961,2 +944,1 @@\n-                    abort(null, \"java.launcher.cls.error8\",\n-                          mainMethod.getDeclaringClass().getName());\n+                    abort(null, \"java.launcher.cls.error6\", className);\n@@ -965,2 +947,1 @@\n-                abort(null, \"java.launcher.cls.error8\",\n-                      mainMethod.getDeclaringClass().getName());\n+                abort(null, \"java.launcher.cls.error6\", className);\n@@ -969,5 +950,0 @@\n-\n-        if (mainMethod.getReturnType() != java.lang.Void.TYPE) {\n-            abort(null, \"java.launcher.cls.error3\",\n-                  mainMethod.getDeclaringClass().getName());\n-        }\n@@ -1125,1 +1101,1 @@\n-                abort(null, \"java.launcher.cls.error5\");\n+                abort(null, \"java.launcher.cls.error3\");\n@@ -1131,1 +1107,1 @@\n-                abort(null, \"java.launcher.cls.error5\");\n+                abort(null, \"java.launcher.cls.error3\");\n@@ -1152,1 +1128,1 @@\n-                abort(ex, \"java.launcher.cls.error5\", ex);\n+                abort(ex, \"java.launcher.cls.error3\", ex);\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":12,"deletions":36,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -241,7 +241,0 @@\n-    Error: Main method is not {0} in class {1}, please define the main method as:\\n\\\n-\\   public static void main(String[] args)\n-java.launcher.cls.error3=\\\n-    Error: Main method must return a value of type void in class {0}, please \\n\\\n-    define the main method as:\\n\\\n-\\   public static void main(String[] args)\n-java.launcher.cls.error4=\\\n@@ -251,1 +244,1 @@\n-java.launcher.cls.error5=\\\n+java.launcher.cls.error3=\\\n@@ -253,1 +246,1 @@\n-java.launcher.cls.error6=\\\n+java.launcher.cls.error4=\\\n@@ -256,1 +249,1 @@\n-java.launcher.cls.error7=\\\n+java.launcher.cls.error5=\\\n@@ -259,1 +252,1 @@\n-java.launcher.cls.error8=\\\n+java.launcher.cls.error6=\\\n@@ -263,1 +256,1 @@\n-java.launcher.cls.error9=\\\n+java.launcher.cls.error7=\\\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -180,7 +180,0 @@\n-     * <p>If the environment is configured to support {@linkplain\n-     * TypeElement#isUnnamed unnamed classes}, the name argument is\n-     * used to provide the leading component of the name used for the\n-     * output file. For example {@code filer.createSourceFile(\"Foo\")}\n-     * to create an unnamed class hosted in {@code Foo.java}. All\n-     * unnamed classes must be in an unnamed package.\n-     *\n@@ -266,7 +259,0 @@\n-     * <p>If the environment is configured to support {@linkplain\n-     * TypeElement#isUnnamed unnamed classes}, the name argument is\n-     * used to provide the leading component of the name used for the\n-     * output file. For example {@code filer.createClassFile(\"Foo\")} to\n-     * create an unnamed class hosted in {@code Foo.class}. All unnamed\n-     * classes must be in an unnamed package.\n-     *\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Filer.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-     * For local, anonymous, and {@linkplain #isUnnamed() unnamed} classes, which do not have canonical\n+     * For local, and anonymous classes, which do not have canonical\n@@ -174,1 +174,0 @@\n-     * @jls 7.3 Compilation Units\n@@ -184,4 +183,0 @@\n-     * For an {@linkplain #isUnnamed() unnamed} class, a name matching\n-     * the base name of the hosting file, minus any extension, is\n-     * returned.\n-     *\n@@ -195,16 +190,0 @@\n-    \/**\n-     * {@return {@code true} if this is an unnamed class and {@code\n-     * false} otherwise}\n-     *\n-     * @implSpec\n-     * The default implementation of this method returns {@code false}.\n-     *\n-     * @jls 7.3 Compilation Units\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED_CLASSES,\n-                    reflective=true)\n-    default boolean isUnnamed() {\n-        return false;\n-    }\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -447,3 +447,0 @@\n-                if ((c.flags_field & UNNAMED_CLASS) != 0) {\n-                    syms.removeClass(ps.modle, flatname);\n-                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-    \/** Class is a unnamed top level class.\n+    \/** Class is a implicit top level class.\n@@ -128,1 +128,1 @@\n-    public static final int UNNAMED_CLASS    = 1<<19;\n+    public static final int IMPLICIT_CLASS    = 1<<19;\n@@ -502,1 +502,1 @@\n-        UNNAMED_CLASS(Flags.UNNAMED_CLASS),\n+        IMPLICIT_CLASS(Flags.IMPLICIT_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-            case UNNAMED_CLASSES -> true;\n+            case IMPLICIT_CLASSES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -249,0 +249,1 @@\n+        IMPLICIT_CLASSES(JDK21, Fragments.FeatureImplicitClasses, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1259,1 +1259,0 @@\n-    @SuppressWarnings(\"preview\") \/\/ isUnnamed()\n@@ -1373,1 +1372,1 @@\n-             return isUnnamed() ? fullname.subName(0, 0) \/* empty name *\/ : fullname;\n+             return fullname;\n@@ -1554,1 +1553,1 @@\n-            if (owner.kind == PCK) \/\/ Handles unnamed classes as well\n+            if (owner.kind == PCK) \/\/ Handles implicit classes as well\n@@ -1645,5 +1644,0 @@\n-\n-        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-        public boolean isUnnamed() {\n-            return (flags_field & Flags.UNNAMED_CLASS) != 0 ;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5551,1 +5551,1 @@\n-                if ((c.flags_field & Flags.UNNAMED_CLASS) != 0) {\n+                if ((c.flags_field & Flags.IMPLICIT_CLASS) != 0) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2288,1 +2288,1 @@\n-            log.error(pos, Errors.UnnamedClassDoesNotHaveMainMethod);\n+            log.error(pos, Errors.ImplicitClassDoesNotHaveMainMethod);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-            if ((tree.mods.flags & UNNAMED_CLASS) != 0) {\n+            if ((tree.mods.flags & IMPLICIT_CLASS) != 0) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2739,8 +2739,0 @@\n-        if (previewClassFile) {\n-            if ((c.flags_field & SYNTHETIC) != 0 &&\n-                    c.owner.kind == PCK &&\n-                    (c.flags_field & AUXILIARY) == 0 &&\n-                    (c.flags_field & FINAL) != 0) {\n-                c.flags_field |= UNNAMED_CLASS;\n-            }\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -410,2 +410,2 @@\n-        String mainClassName = (mainClass.isUnnamed() ? mainClass.getSimpleName()\n-                                                      : mainClass.getQualifiedName()).toString();\n+        String mainClassName = mainClass.getQualifiedName().toString();\n+\n@@ -444,13 +444,1 @@\n-        int mods = mainMethod.getModifiers();\n-        boolean isStatic = Modifier.isStatic(mods);\n-        boolean isPublic = Modifier.isPublic(mods);\n-        boolean noArgs = mainMethod.getParameterCount() == 0;\n-\n-        if (!PreviewFeatures.isEnabled() && (!isStatic || !isPublic)) {\n-            throw new Fault(Errors.MainNotPublicStatic);\n-        }\n-\n-        if (!mainMethod.getReturnType().equals(void.class)) {\n-            throw new Fault(Errors.MainNotVoid);\n-        }\n-\n+        boolean isStatic = Modifier.isStatic(mainMethod.getModifiers());\n@@ -481,1 +469,1 @@\n-            if (noArgs) {\n+            if (mainMethod.getParameterCount() == 0) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3920,1 +3920,1 @@\n-        boolean isUnnamedClass = false;\n+        boolean isImplicitClass = false;\n@@ -3987,1 +3987,1 @@\n-                \/\/ unnamed classes did not exist and error reporting\n+                \/\/ implicit classes did not exist and error reporting\n@@ -3989,1 +3989,1 @@\n-                if (Feature.UNNAMED_CLASSES.allowedInSource(source) && !isDeclaration()) {\n+                if (Feature.IMPLICIT_CLASSES.allowedInSource(source) && !isDeclaration()) {\n@@ -4001,1 +4001,1 @@\n-                    checkSourceLevel(token.pos, Feature.UNNAMED_CLASSES);\n+                    checkSourceLevel(token.pos, Feature.IMPLICIT_CLASSES);\n@@ -4003,1 +4003,1 @@\n-                    isUnnamedClass = true;\n+                    isImplicitClass = true;\n@@ -4015,1 +4015,1 @@\n-        List<JCTree> topLevelDefs = isUnnamedClass ?  constructUnnamedClass(defs.toList()) : defs.toList();\n+        List<JCTree> topLevelDefs = isImplicitClass ?  construcImplictClass(defs.toList()) : defs.toList();\n@@ -4030,2 +4030,2 @@\n-    \/\/ Restructure top level to be an unnamed class.\n-    private List<JCTree> constructUnnamedClass(List<JCTree> origDefs) {\n+    \/\/ Restructure top level to be an implicit class.\n+    private List<JCTree> construcImplictClass(List<JCTree> origDefs) {\n@@ -4037,1 +4037,1 @@\n-                log.error(def.pos(), Errors.UnnamedClassShouldNotHavePackageDeclaration);\n+                log.error(def.pos(), Errors.ImplicitClassShouldNotHavePackageDeclaration);\n@@ -4056,4 +4056,4 @@\n-        JCModifiers unnamedMods = F.at(Position.NOPOS)\n-                .Modifiers(Flags.FINAL|Flags.SYNTHETIC|Flags.UNNAMED_CLASS, List.nil());\n-        JCClassDecl unnamed = F.at(primaryPos).ClassDef(\n-                unnamedMods, name, List.nil(), null, List.nil(), List.nil(),\n+        JCModifiers implicitMods = F.at(Position.NOPOS)\n+                .Modifiers(Flags.FINAL|Flags.MANDATED|Flags.IMPLICIT_CLASS, List.nil());\n+        JCClassDecl implicit = F.at(primaryPos).ClassDef(\n+                implicitMods, name, List.nil(), null, List.nil(), List.nil(),\n@@ -4061,1 +4061,1 @@\n-        topDefs.append(unnamed);\n+        topDefs.append(implicit);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-                \/\/ Don't print out the constructor of an anonymous or unnamed class\n+                \/\/ Don't print out the constructor of an anonymous\n@@ -139,7 +139,0 @@\n-                    }).visit(enclosing)\n-                    || \/\/ Don't print the constructor of an unnamed class\n-                    (new SimpleElementVisitor14<Boolean, Void>(false) {\n-                        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-                        public Boolean visitType(TypeElement e, Void p) {\n-                            return e.isUnnamed();\n-                        }\n@@ -225,8 +218,0 @@\n-            } else if (e.isUnnamed()) {\n-                writer.println(\"\/\/ Unnamed class in file whose name starts with \" + e.getSimpleName());\n-\n-                for(Element element : e.getEnclosedElements()) {\n-                    this.visit(element);\n-                }\n-\n-                return this;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -519,2 +519,2 @@\n-compiler.err.unnamed.class.should.not.have.package.declaration=\\\n-    unnamed class should not have package declaration\n+compiler.err.implicit.class.should.not.have.package.declaration=\\\n+    implicit class should not have package declaration\n@@ -522,2 +522,2 @@\n-compiler.err.unnamed.class.does.not.have.main.method=\\\n-    unnamed class does not have main method in the form of void main() or void main(String[] args)\n+compiler.err.implicit.class.does.not.have.main.method=\\\n+    implicit class does not have main method in the form of void main() or void main(String[] args)\n@@ -3200,0 +3200,3 @@\n+compiler.misc.feature.implicit.classes=\\\n+    implicit classes\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1164,1 +1164,1 @@\n-        return sym.kind == TYP && (sym.flags_field & Flags.UNNAMED_CLASS) != 0;\n+        return sym.kind == TYP && (sym.flags_field & Flags.IMPLICIT_CLASS) != 0;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -989,1 +989,1 @@\n-        if (toolEnv.isSynthetic((Symbol) e) && !toolEnv.isUnnamed((Symbol) e)) {\n+        if (toolEnv.isSynthetic((Symbol) e)) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ElementsTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,4 +177,0 @@\n-    boolean isUnnamed(Symbol sym) {\n-        return (sym.flags() & Flags.UNNAMED_CLASS) != 0;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolEnvironment.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8306112\n- * @enablePreview\n- * @build Unnamed TestUnnamedClass\n- * @run main TestUnnamedClass\n- * @summary Basic checks of java.lang.Class support for unnamed classes\n- *\/\n-\n-import java.lang.reflect.Modifier;\n-\n-public class TestUnnamedClass {\n-    public static void main(String... args) throws Exception {\n-        Class<?> unnamedClass = Class.forName(\"Unnamed\");\n-\n-        \/*\n-         * From JEP 445 JLS changes:\n-         *\n-         * \"An unnamed class compilation unit implicitly declares a class that satisfies the following\n-         * properties:\n-         * It is always a top level class.\n-         * It is always an unnamed class (it has no canonical or fully qualified name (6.7)).\n-         * It is never abstract (8.1.1.1).\n-         * It is always final (8.1.1.2).\n-         * It is always a member of an unnamed package (7.4.2) and has package access.\n-         * Its direct superclass type is always Object (8.1.4).\n-         * It never has any direct superinterface types (8.1.5).\n-         *\/\n-\n-        check(unnamedClass.isUnnamedClass(), \"Unnamed class was isUnnamedClass() false\");\n-\n-        check(!(unnamedClass.isInterface() ||\n-                unnamedClass.isEnum()      ||\n-                unnamedClass.isRecord()    ||\n-                unnamedClass.isHidden()),\n-              \"Unnamed class was not a normal class\");\n-\n-        check(!(unnamedClass.isLocalClass()  ||\n-                unnamedClass.isMemberClass() ||\n-                unnamedClass.isPrimitive()   ||\n-                unnamedClass.isArray()),\n-              \"Unnamed class was not top-level\");\n-\n-        check(\"Unnamed\".equals(unnamedClass.getName()),     \"Unexpected Class.getName result\");\n-        check(\"Unnamed\".equals(unnamedClass.getTypeName()), \"Unexpected Class.getTypeName result\");\n-        check(\"\".equals(unnamedClass.getSimpleName()),      \"Unexpected Class.getSimpleName result\");\n-        check(unnamedClass.getCanonicalName() == null,      \"Unexpected non-null Class.getCanonicalName\");\n-\n-        int modifiers = unnamedClass.getModifiers();\n-        check((modifiers & Modifier.ABSTRACT) == 0,    \"Unnamed class was abstract\");\n-        check((modifiers & Modifier.FINAL) != 0,       \"Unnamed class was not final\");\n-        check((modifiers & (Modifier.PUBLIC  |\n-                            Modifier.PRIVATE |\n-                            Modifier.PROTECTED)) == 0, \"Unnamed class was not package access\");\n-\n-        check(unnamedClass.isSynthetic(), \"Unnamed class was not synthetic\");\n-\n-        check(\"\".equals(unnamedClass.getPackage().getName()), \"Unnamed class not in an unnamed package\");\n-\n-        check(unnamedClass.getSuperclass() == Object.class, \"Superclass was not java.lang.Object\");\n-\n-        check(unnamedClass.getInterfaces().length == 0, \"Unnamed class had super interfaces\");\n-    }\n-\n-    private static void check(boolean predicate, String message) {\n-        if (!predicate) {\n-            throw new RuntimeException(message);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Class\/UnnamedClass\/TestUnnamedClass.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Allow javadoc to process unnamed classes\n+ * @summary Allow javadoc to process implicit classes\n@@ -31,1 +31,1 @@\n- * @run main TestUnnamed\n+ * @run main TestImplicit\n@@ -42,1 +42,1 @@\n-public class TestUnnamed extends JavadocTester {\n+public class TestImplicit extends JavadocTester {\n@@ -49,1 +49,1 @@\n-        new TestUnnamed().runTests();\n+        new TestImplicit().runTests();\n@@ -53,1 +53,1 @@\n-    public void testUnnamed(Path base) throws IOException {\n+    public void testImplicit(Path base) throws IOException {\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnnamed\/TestImplicit.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnnamed\/TestUnnamed.java","status":"renamed"},{"patch":"@@ -70,0 +70,1 @@\n+compiler.misc.feature.unnamed.classes                   # obsolete feature\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- \/\/ key: compiler.misc.feature.unnamed.classes\n+ \/\/ key: compiler.misc.feature.implicit.classes\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- \/\/ key: compiler.err.unnamed.class.should.not.have.package.declaration\n+ \/\/ key: compiler.err.implicit.class.should.not.have.package.declaration\n@@ -29,1 +29,1 @@\n-package unnamed.classes;\n+package implicit.classes;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassHasPackage.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- \/\/ key: compiler.err.unnamed.class.does.not.have.main.method\n+ \/\/ key: compiler.err.implicit.class.does.not.have.main.method\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassNoMain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -567,1 +567,1 @@\n-                \"error: 'main' method is not declared 'public static'\");\n+                \"error: can't find main(String[]) method in class: NotStatic\");\n@@ -575,1 +575,1 @@\n-                \"error: 'main' method is not declared with a return type of 'void'\");\n+                \"error: can't find main(String[]) method in class: NotVoid\");\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2475,1 +2475,1 @@\n-                     \/*synthetic*\/ final class Test {\n+                     final class Test {\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,226 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8306112 8309568\n- * @summary Test basic processing of unnamed classes.\n- * @library \/tools\/javac\/lib\n- * @modules java.compiler\n- *          jdk.compiler\n- * @build   JavacTestingAbstractProcessor TestUnnamedClass\n- * @compile         -processor TestUnnamedClass            --enable-preview --release ${jdk.version}                            Anonymous.java\n- * @clean Nameless.java\n- * @compile\/process -processor TestUnnamedClass -proc:only --enable-preview --release ${jdk.version} -Xprefer:newer -AclassOnly Anonymous Nameless\n- *\/\n-\n-\/\/ The first @compile line processes Anonymous.java and a\n-\/\/ Nameless.java class generated using the Filer. Both of those\n-\/\/ unnamed classes are then compiled down to class files.  The second\n-\/\/ @compile line, as directed by -Xprefer:newer, builds and checks the\n-\/\/ language model objects constructed from those class files, ignoring\n-\/\/ any source files for those types.\n-\n-import java.lang.annotation.*;\n-import java.io.Writer;\n-import java.util.List;\n-import java.util.Set;\n-import javax.annotation.processing.*;\n-import javax.lang.model.element.*;\n-import javax.lang.model.util.Elements;\n-import static javax.lang.model.util.ElementFilter.*;\n-import javax.tools.JavaFileObject;\n-\n-\/**\n- * Test annotation processing representation of unnamed classes\n- * constructed from either a source file or a class file.\n- *\/\n-@SuppressWarnings(\"preview\")\n-@SupportedOptions(\"classOnly\")\n-public class TestUnnamedClass  extends JavacTestingAbstractProcessor {\n-\n-    private static int round  = 0;\n-    private static int checkedClassesCount = 0;\n-    private static boolean classOnly = false;\n-\n-    public boolean process(Set<? extends TypeElement> annotations,\n-                           RoundEnvironment roundEnv) {\n-        if (round == 0) {\n-            classOnly = options.containsKey(\"classOnly\");\n-\n-            checkRoots(roundEnv); \/\/ Check any files from the comamnd line\n-\n-            \/\/ Don't generate any files if testing pre-existing class files\n-            if (!classOnly) {\n-                generateUnnamed();\n-            }\n-        } else {\n-            if (!roundEnv.processingOver()) { \/\/ Test generated file(s)\n-                checkRoots(roundEnv);\n-            } else { \/\/ Should have checked at least one class before processing is over\n-                if (checkedClassesCount == 0) {\n-                    messager.printError(\"No unnamed classes checked.\");\n-                }\n-            }\n-        }\n-\n-        round++;\n-        return true;\n-    }\n-\n-    private void checkRoots(RoundEnvironment roundEnv) {\n-        int checks = 0;\n-        for (TypeElement type : typesIn(roundEnv.getRootElements())) {\n-            checks++;\n-            checkUnnamedClassProperties(type);\n-        }\n-        if (checks == 0) {\n-            messager.printError(\"No checking done of any candidate unnamed classes.\");\n-        }\n-    }\n-\n-    private void generateUnnamed() {\n-        try {\n-            String unnamedSource = \"\"\"\n-            void main() {\n-                System.out.println(\"Nameless, but not voiceless.\");\n-            }\n-            \"\"\";\n-\n-            JavaFileObject outputFile = processingEnv.getFiler().createSourceFile(\"Nameless\");\n-            try(Writer w = outputFile.openWriter()) {\n-                w.append(unnamedSource);\n-            }\n-        } catch (java.io.IOException ioe) {\n-            throw new RuntimeException(ioe);\n-        }\n-    }\n-\n-    \/*\n-     * From JEP 445 JLS changes:\n-     *\n-     * \"An unnamed class compilation unit implicitly declares a class that satisfies the following\n-     * properties:\n-     * It is always a top level class.\n-     * It is always an unnamed class (it has no canonical or fully qualified name (6.7)).\n-     * It is never abstract (8.1.1.1).\n-     * It is always final (8.1.1.2).\n-     * It is always a member of an unnamed package (7.4.2) and has package access.\n-     * Its direct superclass type is always Object (8.1.4).\n-     * It never has any direct superinterface types (8.1.5).\n-     *\n-     * The body of the class contains every ClassMemberDeclaration\n-     * from the unnamed class compilation unit. It is not possible for\n-     * an unnamed class compilation unit to declare an instance\n-     * initializer, static initializer, or constructor.\n-     *\n-     * It has an implicitly declared default constructor (8.8.9).\n-     * All members of this class, including any implicitly declared\n-     * members, are subject to the usual rules for member declarations\n-     * in a class.\n-     *\n-     * It is a compile-time error if this class does not declare a candidate main method (12.1.4).\n-     *\/\n-    void checkUnnamedClassProperties(TypeElement unnamedClass) {\n-        checkedClassesCount++;\n-        Name expectedName = unnamedClass.getSimpleName();\n-\n-        System.out.println(\"Checking \" + expectedName);\n-\n-        if (unnamedClass.getNestingKind() != NestingKind.TOP_LEVEL) {\n-            messager.printError(\"Unnamed class is not top-level.\", unnamedClass);\n-        }\n-\n-        if (!unnamedClass.isUnnamed()) {\n-            messager.printError(\"Unnamed class is _not_ indicated as such.\", unnamedClass);\n-        }\n-\n-        if (unnamedClass.getSimpleName().isEmpty()) {\n-            messager.printError(\"Unnamed class has an empty simple name.\", unnamedClass);\n-        }\n-\n-        if (!unnamedClass.getQualifiedName().isEmpty()) {\n-            messager.printError(\"Unnamed class does _not_ have an empty qualified name.\", unnamedClass);\n-        }\n-\n-        Name binaryName = elements.getBinaryName(unnamedClass);\n-        if (!expectedName.equals(binaryName)) {\n-            messager.printError(\"Unnamed has unexpected binary name\" + binaryName + \".\", unnamedClass);\n-        }\n-\n-        if (unnamedClass.getModifiers().contains(Modifier.ABSTRACT)) {\n-            messager.printError(\"Unnamed class is abstract.\", unnamedClass);\n-        }\n-\n-        if (!unnamedClass.getModifiers().contains(Modifier.FINAL)) {\n-            messager.printError(\"Unnamed class is _not_ final.\", unnamedClass);\n-        }\n-\n-        if (!elements.getPackageOf(unnamedClass).isUnnamed()) {\n-            messager.printError(\"Unnamed class is _not_ in an unnamed package.\", unnamedClass);\n-        }\n-\n-        if (unnamedClass.getModifiers().contains(Modifier.PUBLIC)  ||\n-            unnamedClass.getModifiers().contains(Modifier.PRIVATE) ||\n-            unnamedClass.getModifiers().contains(Modifier.PROTECTED)) {\n-            messager.printError(\"Unnamed class does _not_ have package access.\", unnamedClass);\n-        }\n-\n-        if ( !types.isSameType(unnamedClass.getSuperclass(),\n-                               elements.getTypeElement(\"java.lang.Object\").asType())) {\n-            messager.printError(\"Unnamed class does _not_ have java.lang.Object as a superclass.\", unnamedClass);\n-        }\n-\n-        if (!unnamedClass.getInterfaces().isEmpty()) {\n-            messager.printError(\"Unnamed class has superinterfaces.\", unnamedClass);\n-        }\n-\n-        List<ExecutableElement> ctors = constructorsIn(unnamedClass.getEnclosedElements());\n-        if (ctors.size() != 1 ) {\n-            messager.printError(\"Did not find exactly one constructor\", unnamedClass);\n-        }\n-\n-        if (!classOnly) {\n-            \/\/ Mandated-ness of default constructors not preserved in class files\n-            ExecutableElement ctor = ctors.getFirst();\n-            if (elements.getOrigin(ctor) != Elements.Origin.MANDATED) {\n-                messager.printError(\"Constructor was not marked as mandated\", ctor);\n-            }\n-        }\n-\n-        List<ExecutableElement> methods = methodsIn(unnamedClass.getEnclosedElements());\n-        \/\/ Just look for a method named \"main\"; don't check the other details.\n-        boolean mainFound = false;\n-        Name mainName = elements.getName(\"main\");\n-        for (var method : methods) {\n-            if (method.getSimpleName().equals(mainName)) {\n-                mainFound = true;\n-                break;\n-            }\n-        }\n-\n-        if (!mainFound) {\n-            messager.printError(\"No main mehtod found\", unnamedClass);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedClass.java","additions":0,"deletions":226,"binary":false,"changes":226,"status":"deleted"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Ensure proper error position for the \"unnamed classes not supported\" error\n+ * @summary Ensure proper error position for the \"implicit classes not supported\" error\n","filename":"test\/langtools\/tools\/javac\/unnamedclass\/SourceLevelErrorPosition.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SourceLevelErrorPosition.java:8:1: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.unnamed.classes)\n+SourceLevelErrorPosition.java:8:1: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.implicit.classes)\n","filename":"test\/langtools\/tools\/javac\/unnamedclass\/SourceLevelErrorPosition.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}