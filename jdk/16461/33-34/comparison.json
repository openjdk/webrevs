{"files":[{"patch":"@@ -2888,0 +2888,15 @@\n+    \/**\n+     * Returns the most specific {@code Method} object of this class, super class or\n+     * interface that have the specified method name and parameter types.\n+     *\n+     * @param publicOnly true if only public methods are examined, otherwise all methods\n+     * @param name the name of the method\n+     * @param parameterTypes the parameter array\n+     * @return the list of {@code Method} objects for the public methods of\n+     *         this class matching the specified name and parameters\n+     *\/\n+    Method findMethod(boolean publicOnly, String name, Class<?>... parameterTypes) {\n+        PublicMethods.MethodList res = getMethodsRecursive(name, parameterTypes, true, publicOnly);\n+        return res == null ? null : getReflectionFactory().copyMethod(res.getMostSpecific());\n+    }\n+\n@@ -4790,8 +4805,0 @@\n-\n-    \/**\n-     * Return most specific method that matches name and parameterTypes.\n-     *\/\n-    Method findMethod(boolean publicOnly, String name, Class<?>... parameterTypes) {\n-        PublicMethods.MethodList res = getMethodsRecursive(name, parameterTypes, true, publicOnly);\n-        return res == null ? null : getReflectionFactory().copyMethod(res.getMostSpecific());\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+\/**\n+ * A collection of static methods that return specific method objects of interest.\n+ *\/\n@@ -36,0 +39,2 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -40,2 +45,39 @@\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n+    \/**\n+     * Return the first method that meets the requirements of an application main method\n+     * {@jls 12.1.4}. The method must:\n+     * <ul>\n+     * <li>be declared in this class's hierarchy<\/li>\n+     * <li>have the name \"main\"<\/li>\n+     * <li>have a single argument of type {@code String[]}, {@code String...} or no argument<\/li>\n+     * <li>have the return type of void<\/li>\n+     * <li>be public, protected or package private<\/li>\n+     * <li>not be abstract<\/li>\n+     *<\/ul>\n+     *\n+     * The method returned would be used by a launcher to initiate the execution of an\n+     * application.\n+     *\n+     * Searching continues until a main method is found or the search is exhausted. The\n+     * primary search occurs in two phases, once for a main method with a {@code\n+     * String[]} or {@code String...} argument and failing that, once for a main method\n+     * with a no arguments. The search itself uses recursion to first look at methods\n+     * in this class, then default methods in this class's interface hierarchy and\n+     * then repeating these steps with the class's super class.\n+     *\n+     * @apiNote The method returned may be declared in this class, a super class\n+     * or as a default method of an interface that the class or super class\n+     * implements.\n+     * <p>It is not possible to declare a static main method and instance main\n+     * method with the same signature in the same class. {@jls 8.4.2} states that\n+     * \"It is a compile-time error to declare two methods with override-equivalent\n+     * signatures in a class.\"\n+     * <p>{@link SecurityException SecurityExceptions} can halt\n+     * the search. In this case, a null is returned.\n+     *\n+     * @return the main method if a method found or null if no method is found\n+     *\n+     * @jls 8.2 Class Members\n+     * @jls 8.4 Method Declarations\n+     * @jls 8.4.2 Method Signature\n+     * @jls 12.1.4 Invoke a main method\n+     *\/\n@@ -44,1 +86,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MethodFinder.java","additions":44,"deletions":3,"binary":false,"changes":47,"status":"modified"}]}