{"files":[{"patch":"@@ -193,10 +193,1 @@\n- * <h2><a id=unnamedClasses>Unnamed Classes<\/a><\/h2>\n- *\n- * A {@code class} file representing an {@linkplain #isUnnamedClass unnamed class}\n- * is generated by a Java compiler from a source file for an unnamed class.\n- * The {@code Class} object representing an unnamed class is top-level,\n- * {@linkplain #isSynthetic synthetic}, and {@code final}. While an\n- * unnamed class does <em>not<\/em> have a name in its Java source\n- * form, several of the name-related methods of {@code java.lang.Class}\n- * do return non-null and non-empty results for the {@code Class}\n- * object representing an unnamed class.\n+ * <h2><a id=implicitClasses>Implicit Classes<\/a><\/h2>\n@@ -205,1 +196,1 @@\n- * unnamed class, say {@code HelloWorld.java}, creates a\n+ * implicit class, say {@code HelloWorld.java}, creates a\n@@ -211,1 +202,1 @@\n- * For the {@code Class} object of an unnamed class {@code\n+ * For the {@code Class} object of an implicit class {@code\n@@ -215,2 +206,2 @@\n- * simple name} of such an unnamed class is the empty string and the\n- * {@linkplain #getCanonicalName canonical name} is {@code null}.\n+ * simple name} of such an implicit class is {@code \"HelloWorld\"} and the\n+ * {@linkplain #getCanonicalName canonical name} is {@code \"HelloWorld\"}.\n@@ -1812,1 +1803,1 @@\n-     * {@linkplain #isAnonymousClass() anonymous} or {@linkplain #isUnnamedClass() unnamed}.\n+     * {@linkplain #isAnonymousClass() anonymous}.\n@@ -1825,3 +1816,0 @@\n-        if (isUnnamedClass()) {\n-            return \"\";\n-        }\n@@ -1877,1 +1865,0 @@\n-     * <li>an {@linkplain #isUnnamedClass() unnamed class}\n@@ -1897,3 +1884,0 @@\n-        if (isUnnamedClass()) {\n-            return null;\n-        }\n@@ -1934,20 +1918,0 @@\n-    \/**\n-     * {@return {@code true} if and only if the underlying class\n-     * is an unnamed class}\n-     *\n-     * @apiNote\n-     * An unnamed class is not an {@linkplain #isAnonymousClass anonymous class}.\n-     *\n-     * @since 21\n-     *\n-     * @jls 7.3 Compilation Units\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED_CLASSES,\n-                    reflective=true)\n-    public boolean isUnnamedClass() {\n-        return PreviewFeatures.isEnabled() && isSynthetic()\n-                                           && isTopLevelClass()\n-                                           && Modifier.isFinal(getModifiers());\n-    }\n-\n-\n@@ -1960,1 +1924,0 @@\n-     * An anonymous class is not an {@linkplain #isUnnamedClass() unnamed class}.\n@@ -2925,0 +2888,15 @@\n+    \/**\n+     * Returns the most specific {@code Method} object of this class, super class or\n+     * interface that have the specified method name and parameter types.\n+     *\n+     * @param publicOnly true if only public methods are examined, otherwise all methods\n+     * @param name the name of the method\n+     * @param parameterTypes the parameter array\n+     * @return the {@code Method} object for the method found from this class matching\n+     * the specified name and parameters, or null if not found\n+     *\/\n+    Method findMethod(boolean publicOnly, String name, Class<?>... parameterTypes) {\n+        PublicMethods.MethodList res = getMethodsRecursive(name, parameterTypes, true, publicOnly);\n+        return res == null ? null : getReflectionFactory().copyMethod(res.getMostSpecific());\n+    }\n+\n@@ -3753,1 +3731,1 @@\n-            \/* includeStatic *\/ true);\n+            \/* includeStatic *\/ true, \/* publicOnly *\/ true);\n@@ -3762,3 +3740,4 @@\n-                                                         boolean includeStatic) {\n-        \/\/ 1st check declared public methods\n-        Method[] methods = privateGetDeclaredMethods(\/* publicOnly *\/ true);\n+                                                         boolean includeStatic,\n+                                                         boolean publicOnly) {\n+        \/\/ 1st check declared methods\n+        Method[] methods = privateGetDeclaredMethods(publicOnly);\n@@ -3778,1 +3757,1 @@\n-            res = sc.getMethodsRecursive(name, parameterTypes, includeStatic);\n+            res = sc.getMethodsRecursive(name, parameterTypes, includeStatic, publicOnly);\n@@ -3785,2 +3764,1 @@\n-                res, intf.getMethodsRecursive(name, parameterTypes,\n-                                              \/* includeStatic *\/ false));\n+                res, intf.getMethodsRecursive(name, parameterTypes, \/* includeStatic *\/ false, publicOnly));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":28,"deletions":50,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2348,0 +2348,3 @@\n+            public Method findMethod(Class<?> klass, boolean publicOnly, String name, Class<?>... parameterTypes) {\n+                return klass.findMethod(publicOnly, name, parameterTypes);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+    \/**\n+     * Return most specific method that matches name and parameterTypes.\n+     *\/\n+    Method findMethod(Class<?> klass, boolean publicOnly, String name, Class<?>... parameterTypes);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        @JEP(number=445, title=\"Unnamed Classes and Instance Main Methods\")\n+        @JEP(number=445, title=\"Unnamed Classes and Instance Main Methods\", status=\"Deprecated\")\n@@ -74,0 +74,2 @@\n+        @JEP(number=463, title=\"Implicit Classes and Instance Main Methods\", status=\"Preview\")\n+        IMPLICIT_CLASSES,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,169 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.misc;\n-\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-public class MainMethodFinder {\n-    private static boolean correctArgs(Method method) {\n-        int argc = method.getParameterCount();\n-\n-        return argc == 0 || argc == 1 && method.getParameterTypes()[0] == String[].class;\n-    }\n-\n-    \/**\n-     * Gather all the \"main\" methods in the class hierarchy.\n-     *\n-     * @param refc         the main class or super class\n-     * @param mains        accumulated main methods\n-     * @param isMainClass  the class is the main class and not a super class\n-     *\/\n-    private static void gatherMains(Class<?> refc, List<Method> mains, boolean isMainClass) {\n-        if (refc != null && refc != Object.class) {\n-            for (Method method : refc.getDeclaredMethods()) {\n-                int mods = method.getModifiers();\n-                \/\/ Must be named \"main\", public|protected|package-private, not synthetic (bridge) and either\n-                \/\/ no arguments or one string array argument. Only statics in the Main class are acceptable.\n-                if (\"main\".equals(method.getName()) &&\n-                        !method.isSynthetic() &&\n-                        !Modifier.isPrivate(mods) &&\n-                        correctArgs(method) &&\n-                        (isMainClass || !Modifier.isStatic(mods)))\n-                {\n-                    mains.add(method);\n-                }\n-            }\n-\n-            gatherMains(refc.getSuperclass(), mains, false);\n-        }\n-    }\n-\n-    \/**\n-     * Comparator for two methods.\n-     * Priority order is;\n-     * sub-class < super-class.\n-     * static < non-static,\n-     * string arg < no arg and\n-     *\n-     * @param a  first method\n-     * @param b  second method\n-     *\n-     * @return -1, 0 or 1 to represent higher priority. equals priority or lesser priority.\n-     *\/\n-    private static int compareMethods(Method a, Method b) {\n-        Class<?> aClass = a.getDeclaringClass();\n-        Class<?> bClass = b.getDeclaringClass();\n-\n-        if (aClass != bClass) {\n-            if (bClass.isAssignableFrom(aClass)) {\n-                return -1;\n-            } else {\n-                return 1;\n-            }\n-        }\n-\n-        int aMods = a.getModifiers();\n-        int bMods = b.getModifiers();\n-        boolean aIsStatic = Modifier.isStatic(aMods);\n-        boolean bIsStatic = Modifier.isStatic(bMods);\n-\n-        if (aIsStatic && !bIsStatic) {\n-            return -1;\n-        } else if (!aIsStatic && bIsStatic) {\n-            return 1;\n-        }\n-\n-        int aCount = a.getParameterCount();\n-        int bCount = b.getParameterCount();\n-\n-        if (bCount < aCount) {\n-            return -1;\n-        } else if (aCount < bCount) {\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-\n-    \/**\n-     * Return the traditional main method or null if not found.\n-     *\n-     * @param mainClass main class\n-     *\n-     * @return main method or null\n-     *\/\n-    private static Method getTraditionalMain(Class<?> mainClass) {\n-        try {\n-            Method traditionalMain = mainClass.getMethod(\"main\", String[].class);\n-            int mods = traditionalMain.getModifiers();\n-\n-            if (Modifier.isStatic(mods) && Modifier.isPublic(mods) && traditionalMain.getReturnType() == void.class) {\n-                return traditionalMain;\n-            }\n-        } catch (NoSuchMethodException ex) {\n-            \/\/ not found\n-        }\n-\n-        return null;\n-    }\n-\n-    \/**\n-     * {@return priority main method if none found}\n-     *\n-     * @param mainClass main class\n-     *\n-     * @throws NoSuchMethodException when not preview and no method found\n-     *\/\n-    public static Method findMainMethod(Class<?> mainClass) throws NoSuchMethodException {\n-        boolean isTraditionMain = !PreviewFeatures.isEnabled();\n-        if (isTraditionMain) {\n-            return mainClass.getMethod(\"main\", String[].class);\n-        }\n-\n-        List<Method> mains = new ArrayList<>();\n-        gatherMains(mainClass, mains, true);\n-\n-        if (mains.isEmpty()) {\n-            throw new NoSuchMethodException(\"No main method found\");\n-        }\n-\n-        if (1 < mains.size()) {\n-            mains.sort(MainMethodFinder::compareMethods);\n-        }\n-\n-        Method mainMethod = mains.get(0);\n-        Method traditionalMain = getTraditionalMain(mainClass);\n-\n-        if (traditionalMain != null && !traditionalMain.equals(mainMethod)) {\n-            System.err.println(\"WARNING: \\\"\" + mains.get(0) + \"\\\" chosen over \\\"\" + traditionalMain + \"\\\"\");\n-        }\n-\n-        return mains.get(0);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MainMethodFinder.java","additions":0,"deletions":169,"binary":false,"changes":169,"status":"deleted"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.misc;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+\/**\n+ * A collection of static methods that return specific method objects of interest.\n+ *\/\n+public class MethodFinder {\n+\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    private MethodFinder() {\n+        throw new AssertionError(\"private constructor\");\n+    }\n+\n+    \/**\n+     * Return the first method that meets the requirements of an application main method\n+     * {@jls 12.1.4}. The method must:\n+     * <ul>\n+     * <li>be declared in this class's hierarchy<\/li>\n+     * <li>have the name \"main\"<\/li>\n+     * <li>have a single argument of type {@code String[]}, {@code String...} or no argument<\/li>\n+     * <li>have the return type of void<\/li>\n+     * <li>be public, protected or package private<\/li>\n+     * <li>not be abstract<\/li>\n+     *<\/ul>\n+     *\n+     * The method returned would be used by a launcher to initiate the execution of an\n+     * application.\n+     *\n+     * Searching continues until a main method is found or the search is exhausted. The\n+     * primary search occurs in two phases, once for a main method with a {@code\n+     * String[]} or {@code String...} argument and failing that, once for a main method\n+     * with a no arguments. The search itself uses recursion to first look at methods\n+     * in this class, then default methods in this class's interface hierarchy and\n+     * then repeating these steps with the class's super class.\n+     *\n+     * @apiNote The method returned may be declared in this class, a super class\n+     * or as a default method of an interface that the class or super class\n+     * implements.\n+     * <p>It is not possible to declare a static main method and instance main\n+     * method with the same signature in the same class. {@jls 8.4.2} states that\n+     * \"It is a compile-time error to declare two methods with override-equivalent\n+     * signatures in a class.\"\n+     * <p>{@link SecurityException SecurityExceptions} can halt\n+     * the search. In this case, a null is returned.\n+     *\n+     * @return the main method if a method found or null if no method is found\n+     *\n+     * @jls 8.2 Class Members\n+     * @jls 8.4 Method Declarations\n+     * @jls 8.4.2 Method Signature\n+     * @jls 12.1.4 Invoke a main method\n+     *\/\n+    public static Method findMainMethod(Class<?> cls) {\n+        boolean isPreview = PreviewFeatures.isEnabled();\n+        Method mainMethod = JLA.findMethod(cls, !isPreview, \"main\", String[].class);\n+\n+        if (isPreview && mainMethod == null) {\n+            mainMethod = JLA.findMethod(cls, false, \"main\");\n+        }\n+\n+        if (mainMethod == null) {\n+            return null;\n+        }\n+\n+        int mods = mainMethod.getModifiers();\n+\n+        if (Modifier.isAbstract(mods) ||\n+                mainMethod.getReturnType() != void.class ||\n+                (isPreview && Modifier.isPrivate(mods)) ||\n+                (!isPreview && !Modifier.isStatic(mods))) {\n+            return null;\n+        }\n+\n+        return mainMethod;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MethodFinder.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -74,1 +74,1 @@\n-import jdk.internal.misc.MainMethodFinder;\n+import jdk.internal.misc.MethodFinder;\n@@ -712,1 +712,1 @@\n-     * 2. Checks the public static void main method.\n+     * 2. Checks for a valid main method.\n@@ -756,1 +756,1 @@\n-        validateMainClass(mainClass);\n+        validateMainMethod(mainClass);\n@@ -862,1 +862,1 @@\n-            abort(le, \"java.launcher.cls.error6\", cn,\n+            abort(le, \"java.launcher.cls.error4\", cn,\n@@ -893,23 +893,2 @@\n-    \/*\n-     * main type flags\n-     *\/\n-    private static final int MAIN_WITHOUT_ARGS = 1;\n-    private static final int MAIN_NONSTATIC = 2;\n-    private static int mainType = 0;\n-\n-    \/*\n-     * Return type so that launcher invokes the correct main\n-     *\/\n-    public static int getMainType() {\n-        return mainType;\n-    }\n-\n-    private static void setMainType(Method mainMethod) {\n-        int mods = mainMethod.getModifiers();\n-        boolean isStatic = Modifier.isStatic(mods);\n-        boolean noArgs = mainMethod.getParameterCount() == 0;\n-        mainType = (isStatic ? 0 : MAIN_NONSTATIC) | (noArgs ? MAIN_WITHOUT_ARGS : 0);\n-    }\n-\n-    \/\/ Check the existence and signature of main and abort if incorrect\n-    static void validateMainClass(Class<?> mainClass) {\n+    \/\/ Check the existence and signature of main and abort if incorrect.\n+    private static void validateMainMethod(Class<?> mainClass) {\n@@ -918,5 +897,7 @@\n-            mainMethod = MainMethodFinder.findMainMethod(mainClass);\n-        } catch (NoSuchMethodException nsme) {\n-            \/\/ invalid main or not FX application, abort with an error\n-            abort(null, \"java.launcher.cls.error4\", mainClass.getName(),\n-                  JAVAFX_APPLICATION_CLASS_NAME);\n+            mainMethod = MethodFinder.findMainMethod(mainClass);\n+\n+            if (mainMethod == null) {\n+                \/\/ invalid main or not FX application, abort with an error\n+                abort(null, \"java.launcher.cls.error2\", mainClass.getName(),\n+                      JAVAFX_APPLICATION_CLASS_NAME);\n+            }\n@@ -925,1 +906,1 @@\n-                abort(e, \"java.launcher.module.error5\",\n+                abort(e, \"java.launcher.module.error3\",\n@@ -929,1 +910,1 @@\n-                abort(e, \"java.launcher.cls.error7\", mainClass.getName(),\n+                abort(e, \"java.launcher.cls.error5\", mainClass.getName(),\n@@ -934,7 +915,0 @@\n-        setMainType(mainMethod);\n-\n-        \/*\n-         * findMainMethod (above) will choose the correct method, based\n-         * on its name and parameter type, however, we still have to\n-         * ensure that the method is static (non-preview) and returns a void.\n-         *\/\n@@ -948,2 +922,2 @@\n-                abort(null, \"java.launcher.cls.error2\", \"static\",\n-                      mainMethod.getDeclaringClass().getName());\n+                  abort(null, \"java.launcher.cls.error2\", mainClass.getName(),\n+                       JAVAFX_APPLICATION_CLASS_NAME);\n@@ -951,0 +925,1 @@\n+            return;\n@@ -954,0 +929,1 @@\n+            String className = mainMethod.getDeclaringClass().getName();\n@@ -955,2 +931,1 @@\n-                abort(null, \"java.launcher.cls.error9\",\n-                        mainMethod.getDeclaringClass().getName());\n+                abort(null, \"java.launcher.cls.error7\", className);\n@@ -961,2 +936,1 @@\n-                    abort(null, \"java.launcher.cls.error8\",\n-                          mainMethod.getDeclaringClass().getName());\n+                    abort(null, \"java.launcher.cls.error6\", className);\n@@ -965,2 +939,1 @@\n-                abort(null, \"java.launcher.cls.error8\",\n-                      mainMethod.getDeclaringClass().getName());\n+                abort(null, \"java.launcher.cls.error6\", className);\n@@ -969,5 +942,0 @@\n-\n-        if (mainMethod.getReturnType() != java.lang.Void.TYPE) {\n-            abort(null, \"java.launcher.cls.error3\",\n-                  mainMethod.getDeclaringClass().getName());\n-        }\n@@ -1125,1 +1093,1 @@\n-                abort(null, \"java.launcher.cls.error5\");\n+                abort(null, \"java.launcher.cls.error3\");\n@@ -1131,1 +1099,1 @@\n-                abort(null, \"java.launcher.cls.error5\");\n+                abort(null, \"java.launcher.cls.error3\");\n@@ -1152,1 +1120,1 @@\n-                abort(ex, \"java.launcher.cls.error5\", ex);\n+                abort(ex, \"java.launcher.cls.error3\", ex);\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":25,"deletions":57,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -241,7 +241,0 @@\n-    Error: Main method is not {0} in class {1}, please define the main method as:\\n\\\n-\\   public static void main(String[] args)\n-java.launcher.cls.error3=\\\n-    Error: Main method must return a value of type void in class {0}, please \\n\\\n-    define the main method as:\\n\\\n-\\   public static void main(String[] args)\n-java.launcher.cls.error4=\\\n@@ -251,1 +244,1 @@\n-java.launcher.cls.error5=\\\n+java.launcher.cls.error3=\\\n@@ -253,1 +246,1 @@\n-java.launcher.cls.error6=\\\n+java.launcher.cls.error4=\\\n@@ -256,1 +249,1 @@\n-java.launcher.cls.error7=\\\n+java.launcher.cls.error5=\\\n@@ -259,1 +252,1 @@\n-java.launcher.cls.error8=\\\n+java.launcher.cls.error6=\\\n@@ -263,1 +256,1 @@\n-java.launcher.cls.error9=\\\n+java.launcher.cls.error7=\\\n@@ -283,1 +276,1 @@\n-    \\t{2}\n+    Caused by: {2}\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -390,0 +390,78 @@\n+#define CHECK_EXCEPTION_FAIL() \\\n+    do { \\\n+        if ((*env)->ExceptionOccurred(env)) { \\\n+            (*env)->ExceptionClear(env); \\\n+            return 0; \\\n+        } \\\n+    } while (JNI_FALSE)\n+\n+\n+#define CHECK_EXCEPTION_NULL_FAIL(mainObject) \\\n+    do { \\\n+        if ((*env)->ExceptionOccurred(env)) { \\\n+            (*env)->ExceptionClear(env); \\\n+            return 0; \\\n+        } else if (mainObject == NULL) { \\\n+            return 0; \\\n+        } \\\n+    } while (JNI_FALSE)\n+\n+\/*\n+ * Invoke a static main with arguments. Returns 1 (true) if successful otherwise\n+ * processes the pending exception from GetStaticMethodID and returns 0 (false).\n+ *\/\n+int\n+invokeStaticMainWithArgs(JNIEnv *env, jclass mainClass, jobjectArray mainArgs) {\n+    jmethodID mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n+                                  \"([Ljava\/lang\/String;)V\");\n+    CHECK_EXCEPTION_FAIL();\n+    (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n+    return 1;\n+}\n+\n+\/*\n+ * Invoke an instance main with arguments. Returns 1 (true) if successful otherwise\n+ * processes the pending exception from GetMethodID and returns 0 (false).\n+ *\/\n+int\n+invokeInstanceMainWithArgs(JNIEnv *env, jclass mainClass, jobjectArray mainArgs) {\n+    jmethodID constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+    CHECK_EXCEPTION_FAIL();\n+    jobject mainObject = (*env)->NewObject(env, mainClass, constructor);\n+    CHECK_EXCEPTION_NULL_FAIL(mainObject);\n+    jmethodID mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n+                                 \"([Ljava\/lang\/String;)V\");\n+    CHECK_EXCEPTION_FAIL();\n+    (*env)->CallVoidMethod(env, mainObject, mainID, mainArgs);\n+    return 1;\n+ }\n+\n+\/*\n+ * Invoke a static main without arguments. Returns 1 (true) if successful otherwise\n+ * processes the pending exception from GetStaticMethodID and returns 0 (false).\n+ *\/\n+int\n+invokeStaticMainWithoutArgs(JNIEnv *env, jclass mainClass) {\n+    jmethodID mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n+                                       \"()V\");\n+    CHECK_EXCEPTION_FAIL();\n+    (*env)->CallStaticVoidMethod(env, mainClass, mainID);\n+    return 1;\n+}\n+\n+\/*\n+ * Invoke an instance main without arguments. Returns 1 (true) if successful otherwise\n+ * processes the pending exception from GetMethodID and returns 0 (false).\n+ *\/\n+int\n+invokeInstanceMainWithoutArgs(JNIEnv *env, jclass mainClass) {\n+    jmethodID constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+    CHECK_EXCEPTION_FAIL();\n+    jobject mainObject = (*env)->NewObject(env, mainClass, constructor);\n+    CHECK_EXCEPTION_NULL_FAIL(mainObject);\n+    jmethodID mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n+                                 \"()V\");\n+    CHECK_EXCEPTION_FAIL();\n+    (*env)->CallVoidMethod(env, mainObject, mainID);\n+    return 1;\n+}\n@@ -406,3 +484,0 @@\n-    jmethodID mainID;\n-    jmethodID constructor;\n-    jobject mainObject;\n@@ -494,3 +569,0 @@\n-     * Get the application's main class. It also checks if the main\n-     * method exists.\n-     *\n@@ -526,1 +598,1 @@\n-    NULL_CHECK_RETURN_VALUE(appClass, -1);\n+    CHECK_EXCEPTION_NULL_LEAVE(appClass);\n@@ -548,4 +620,2 @@\n-     * The LoadMainClass not only loads the main class, it will also ensure\n-     * that the main method's signature is correct, therefore further checking\n-     * is not required. The main method is invoked here so that extraneous java\n-     * stacks are not in the application stack trace.\n+     * The main method is invoked here so that extraneous java stacks are not in\n+     * the application stack trace.\n@@ -553,48 +623,6 @@\n-#define MAIN_WITHOUT_ARGS 1\n-#define MAIN_NONSTATIC 2\n-\n-    jclass helperClass = GetLauncherHelperClass(env);\n-    jmethodID getMainType = (*env)->GetStaticMethodID(env, helperClass,\n-                                                      \"getMainType\",\n-                                                      \"()I\");\n-    CHECK_EXCEPTION_NULL_LEAVE(getMainType);\n-    int mainType = (*env)->CallStaticIntMethod(env, helperClass, getMainType);\n-    CHECK_EXCEPTION_LEAVE(mainType);\n-\n-    switch (mainType) {\n-    case 0: {\n-        mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n-                                           \"([Ljava\/lang\/String;)V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-        (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n-        break;\n-        }\n-    case MAIN_WITHOUT_ARGS: {\n-        mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n-                                           \"()V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-        (*env)->CallStaticVoidMethod(env, mainClass, mainID);\n-        break;\n-        }\n-    case MAIN_NONSTATIC: {\n-        constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(constructor);\n-        mainObject = (*env)->NewObject(env, mainClass, constructor);\n-        CHECK_EXCEPTION_NULL_LEAVE(mainObject);\n-        mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n-                                     \"([Ljava\/lang\/String;)V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-        (*env)->CallVoidMethod(env, mainObject, mainID, mainArgs);\n-        break;\n-        }\n-    case MAIN_NONSTATIC | MAIN_WITHOUT_ARGS: {\n-        constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(constructor);\n-        mainObject = (*env)->NewObject(env, mainClass, constructor);\n-        CHECK_EXCEPTION_NULL_LEAVE(mainObject);\n-        mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n-                                     \"()V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-        (*env)->CallVoidMethod(env, mainObject, mainID);\n-        break;\n-        }\n+    if (!invokeStaticMainWithArgs(env, mainClass, mainArgs) &&\n+        !invokeInstanceMainWithArgs(env, mainClass, mainArgs) &&\n+        !invokeStaticMainWithoutArgs(env, mainClass) &&\n+        !invokeInstanceMainWithoutArgs(env, mainClass)) {\n+        ret = 1;\n+        LEAVE();\n@@ -1596,2 +1624,3 @@\n- * Loads a class and verifies that the main class is present and it is ok to\n- * call it for more details refer to the java implementation.\n+ * Calls LauncherHelper::checkAndLoadMain to verify that the main class\n+ * is present, it is ok to load the main class and then load the main class.\n+ * For more details refer to the java implementation.\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":90,"deletions":61,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -180,6 +180,5 @@\n-     * <p>If the environment is configured to support {@linkplain\n-     * TypeElement#isUnnamed unnamed classes}, the name argument is\n-     * used to provide the leading component of the name used for the\n-     * output file. For example {@code filer.createSourceFile(\"Foo\")}\n-     * to create an unnamed class hosted in {@code Foo.java}. All\n-     * unnamed classes must be in an unnamed package.\n+     * <p>If the environment is configured to support implicitly declared\n+     * classes, the name argument is used to provide the leading component of the\n+     * name used for the output file. For example {@code filer.createSourceFile(\"Foo\")}\n+     * to create an implicitly declared class hosted in {@code Foo.java}. All\n+     * implicit classes must be in an unnamed package.\n@@ -266,6 +265,5 @@\n-     * <p>If the environment is configured to support {@linkplain\n-     * TypeElement#isUnnamed unnamed classes}, the name argument is\n-     * used to provide the leading component of the name used for the\n-     * output file. For example {@code filer.createClassFile(\"Foo\")} to\n-     * create an unnamed class hosted in {@code Foo.class}. All unnamed\n-     * classes must be in an unnamed package.\n+     * <p>If the environment is configured to support implicitly declared\n+     * classes, the name argument is used to provide the leading component of the\n+     * name used for the output file. For example {@code filer.createSourceFile(\"Foo\")}\n+     * to create an implicitly declared class hosted in {@code Foo.java}. All\n+     * implicit classes must be in an unnamed package.\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Filer.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-     * For local, anonymous, and {@linkplain #isUnnamed() unnamed} classes, which do not have canonical\n+     * For local, and anonymous classes, which do not have canonical\n@@ -174,1 +174,0 @@\n-     * @jls 7.3 Compilation Units\n@@ -184,4 +183,0 @@\n-     * For an {@linkplain #isUnnamed() unnamed} class, a name matching\n-     * the base name of the hosting file, minus any extension, is\n-     * returned.\n-     *\n@@ -195,16 +190,0 @@\n-    \/**\n-     * {@return {@code true} if this is an unnamed class and {@code\n-     * false} otherwise}\n-     *\n-     * @implSpec\n-     * The default implementation of this method returns {@code false}.\n-     *\n-     * @jls 7.3 Compilation Units\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED_CLASSES,\n-                    reflective=true)\n-    default boolean isUnnamed() {\n-        return false;\n-    }\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -447,3 +447,0 @@\n-                if ((c.flags_field & UNNAMED_CLASS) != 0) {\n-                    syms.removeClass(ps.modle, flatname);\n-                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-    \/** Class is a unnamed top level class.\n+    \/** Class is a implicit top level class.\n@@ -128,1 +128,1 @@\n-    public static final int UNNAMED_CLASS    = 1<<19;\n+    public static final int IMPLICIT_CLASS    = 1<<19;\n@@ -502,1 +502,1 @@\n-        UNNAMED_CLASS(Flags.UNNAMED_CLASS),\n+        IMPLICIT_CLASS(Flags.IMPLICIT_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-            case UNNAMED_CLASSES -> true;\n+            case IMPLICIT_CLASSES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-        UNNAMED_CLASSES(JDK21, Fragments.FeatureUnnamedClasses, DiagKind.PLURAL),\n+        IMPLICIT_CLASSES(JDK21, Fragments.FeatureImplicitClasses, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -438,0 +438,4 @@\n+    public boolean isImplicit() {\n+        return (flags_field & IMPLICIT_CLASS) != 0;\n+    }\n+\n@@ -1259,1 +1263,0 @@\n-    @SuppressWarnings(\"preview\") \/\/ isUnnamed()\n@@ -1373,1 +1376,1 @@\n-             return isUnnamed() ? fullname.subName(0, 0) \/* empty name *\/ : fullname;\n+             return fullname;\n@@ -1554,1 +1557,1 @@\n-            if (owner.kind == PCK) \/\/ Handles unnamed classes as well\n+            if (owner.kind == PCK) \/\/ Handles implicit classes as well\n@@ -1645,5 +1648,0 @@\n-\n-        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-        public boolean isUnnamed() {\n-            return (flags_field & Flags.UNNAMED_CLASS) != 0 ;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -5510,1 +5510,1 @@\n-                if ((c.flags_field & Flags.UNNAMED_CLASS) != 0) {\n+                if (c.isImplicit()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -455,1 +455,2 @@\n-            if (sym.kind == TYP && sym.name == name && sym.name != names.error) {\n+            if (sym.kind == TYP && sym.name == name && sym.name != names.error &&\n+                    !sym.isImplicit()) {\n@@ -2279,1 +2280,1 @@\n-            log.error(pos, Errors.UnnamedClassDoesNotHaveMainMethod);\n+            log.error(pos, Errors.ImplicitClassDoesNotHaveMainMethod);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -445,1 +445,1 @@\n-            if ((tree.mods.flags & UNNAMED_CLASS) != 0) {\n+            if ((tree.mods.flags & IMPLICIT_CLASS) != 0) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3050,8 +3050,0 @@\n-        if (previewClassFile) {\n-            if ((c.flags_field & SYNTHETIC) != 0 &&\n-                    c.owner.kind == PCK &&\n-                    (c.flags_field & AUXILIARY) == 0 &&\n-                    (c.flags_field & FINAL) != 0) {\n-                c.flags_field |= UNNAMED_CLASS;\n-            }\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-import jdk.internal.misc.MainMethodFinder;\n+import jdk.internal.misc.MethodFinder;\n@@ -410,2 +410,2 @@\n-        String mainClassName = (mainClass.isUnnamed() ? mainClass.getSimpleName()\n-                                                      : mainClass.getQualifiedName()).toString();\n+        String mainClassName = mainClass.getQualifiedName().toString();\n+\n@@ -437,15 +437,1 @@\n-        Method mainMethod;\n-        try {\n-            mainMethod = MainMethodFinder.findMainMethod(appClass);\n-        } catch (NoSuchMethodException e) {\n-            throw new Fault(Errors.CantFindMainMethod(mainClassName));\n-        }\n-\n-        int mods = mainMethod.getModifiers();\n-        boolean isStatic = Modifier.isStatic(mods);\n-        boolean isPublic = Modifier.isPublic(mods);\n-        boolean noArgs = mainMethod.getParameterCount() == 0;\n-\n-        if (!PreviewFeatures.isEnabled() && (!isStatic || !isPublic)) {\n-            throw new Fault(Errors.MainNotPublicStatic);\n-        }\n+        Method mainMethod = MethodFinder.findMainMethod(appClass);\n@@ -453,2 +439,2 @@\n-        if (!mainMethod.getReturnType().equals(void.class)) {\n-            throw new Fault(Errors.MainNotVoid);\n+        if (mainMethod == null) {\n+            throw new Fault(Errors.CantFindMainMethod(mainClassName));\n@@ -457,0 +443,1 @@\n+        boolean isStatic = Modifier.isStatic(mainMethod.getModifiers());\n@@ -481,1 +468,1 @@\n-            if (noArgs) {\n+            if (mainMethod.getParameterCount() == 0) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java","additions":8,"deletions":21,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-        this.keepDocComments = false;\n+        this.keepDocComments = parser.keepDocComments;\n@@ -211,1 +211,1 @@\n-        this.docComments = null;\n+        this.docComments = parser.docComments;\n@@ -3919,2 +3919,2 @@\n-        boolean firstTypeDecl = true;   \/\/ have we see a class, enum, or interface declaration yet?\n-        boolean isUnnamedClass = false;\n+        boolean firstTypeDecl = true;   \/\/ have we seen a class, enum, or interface declaration yet?\n+        boolean isImplicitClass = false;\n@@ -3987,1 +3987,1 @@\n-                \/\/ unnamed classes did not exist and error reporting\n+                \/\/ implicit classes did not exist and error reporting\n@@ -3989,1 +3989,1 @@\n-                if (Feature.UNNAMED_CLASSES.allowedInSource(source) && !isDeclaration()) {\n+                if (Feature.IMPLICIT_CLASSES.allowedInSource(source) && !isDeclaration()) {\n@@ -3993,1 +3993,1 @@\n-                            speculative.topLevelMethodOrFieldDeclaration(finalMods);\n+                            speculative.topLevelMethodOrFieldDeclaration(finalMods, null);\n@@ -4001,3 +4001,3 @@\n-                    checkSourceLevel(token.pos, Feature.UNNAMED_CLASSES);\n-                    defs.appendList(topLevelMethodOrFieldDeclaration(mods));\n-                    isUnnamedClass = true;\n+                    checkSourceLevel(token.pos, Feature.IMPLICIT_CLASSES);\n+                    defs.appendList(topLevelMethodOrFieldDeclaration(mods, docComment));\n+                    isImplicitClass = true;\n@@ -4015,1 +4015,1 @@\n-        List<JCTree> topLevelDefs = isUnnamedClass ?  constructUnnamedClass(defs.toList()) : defs.toList();\n+        List<JCTree> topLevelDefs = isImplicitClass ?  constructImplictClass(defs.toList()) : defs.toList();\n@@ -4030,2 +4030,2 @@\n-    \/\/ Restructure top level to be an unnamed class.\n-    private List<JCTree> constructUnnamedClass(List<JCTree> origDefs) {\n+    \/\/ Restructure top level to be an implicit class.\n+    private List<JCTree> constructImplictClass(List<JCTree> origDefs) {\n@@ -4037,1 +4037,1 @@\n-                log.error(def.pos(), Errors.UnnamedClassShouldNotHavePackageDeclaration);\n+                log.error(def.pos(), Errors.ImplicitClassShouldNotHavePackageDeclaration);\n@@ -4056,4 +4056,4 @@\n-        JCModifiers unnamedMods = F.at(Position.NOPOS)\n-                .Modifiers(Flags.FINAL|Flags.SYNTHETIC|Flags.UNNAMED_CLASS, List.nil());\n-        JCClassDecl unnamed = F.at(primaryPos).ClassDef(\n-                unnamedMods, name, List.nil(), null, List.nil(), List.nil(),\n+        JCModifiers implicitMods = F.at(Position.NOPOS)\n+                .Modifiers(Flags.FINAL|Flags.IMPLICIT_CLASS, List.nil());\n+        JCClassDecl implicit = F.at(primaryPos).ClassDef(\n+                implicitMods, name, List.nil(), null, List.nil(), List.nil(),\n@@ -4061,1 +4061,1 @@\n-        topDefs.append(unnamed);\n+        topDefs.append(implicit);\n@@ -4738,2 +4738,1 @@\n-    private List<JCTree> topLevelMethodOrFieldDeclaration(JCModifiers mods) throws AssertionError {\n-        int topPos = token.pos;\n+    private List<JCTree> topLevelMethodOrFieldDeclaration(JCModifiers mods, Comment dc) throws AssertionError {\n@@ -4741,1 +4740,1 @@\n-        Comment dc = token.docComment();\n+        dc = dc == null ? token.docComment() : dc;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":21,"deletions":22,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-                \/\/ Don't print out the constructor of an anonymous or unnamed class\n+                \/\/ Don't print out the constructor of an anonymous\n@@ -139,7 +139,0 @@\n-                    }).visit(enclosing)\n-                    || \/\/ Don't print the constructor of an unnamed class\n-                    (new SimpleElementVisitor14<Boolean, Void>(false) {\n-                        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-                        public Boolean visitType(TypeElement e, Void p) {\n-                            return e.isUnnamed();\n-                        }\n@@ -225,8 +218,0 @@\n-            } else if (e.isUnnamed()) {\n-                writer.println(\"\/\/ Unnamed class in file whose name starts with \" + e.getSimpleName());\n-\n-                for(Element element : e.getEnclosedElements()) {\n-                    this.visit(element);\n-                }\n-\n-                return this;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -527,2 +527,2 @@\n-compiler.err.unnamed.class.should.not.have.package.declaration=\\\n-    unnamed class should not have package declaration\n+compiler.err.implicit.class.should.not.have.package.declaration=\\\n+    implicit class should not have package declaration\n@@ -530,2 +530,2 @@\n-compiler.err.unnamed.class.does.not.have.main.method=\\\n-    unnamed class does not have main method in the form of void main() or void main(String[] args)\n+compiler.err.implicit.class.does.not.have.main.method=\\\n+    implicit class does not have main method in the form of void main() or void main(String[] args)\n@@ -3201,2 +3201,2 @@\n-compiler.misc.feature.unnamed.classes=\\\n-    unnamed classes\n+compiler.misc.feature.implicit.classes=\\\n+    implicit classes\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1164,1 +1164,1 @@\n-        return sym.kind == TYP && (sym.flags_field & Flags.UNNAMED_CLASS) != 0;\n+        return sym.kind == TYP && sym.isImplicit();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -989,1 +989,1 @@\n-        if (toolEnv.isSynthetic((Symbol) e) && !toolEnv.isUnnamed((Symbol) e)) {\n+        if (toolEnv.isSynthetic((Symbol) e)) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ElementsTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,4 +177,0 @@\n-    boolean isUnnamed(Symbol sym) {\n-        return (sym.flags() & Flags.UNNAMED_CLASS) != 0;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolEnvironment.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8306112\n- * @enablePreview\n- * @build Unnamed TestUnnamedClass\n- * @run main TestUnnamedClass\n- * @summary Basic checks of java.lang.Class support for unnamed classes\n- *\/\n-\n-import java.lang.reflect.Modifier;\n-\n-public class TestUnnamedClass {\n-    public static void main(String... args) throws Exception {\n-        Class<?> unnamedClass = Class.forName(\"Unnamed\");\n-\n-        \/*\n-         * From JEP 445 JLS changes:\n-         *\n-         * \"An unnamed class compilation unit implicitly declares a class that satisfies the following\n-         * properties:\n-         * It is always a top level class.\n-         * It is always an unnamed class (it has no canonical or fully qualified name (6.7)).\n-         * It is never abstract (8.1.1.1).\n-         * It is always final (8.1.1.2).\n-         * It is always a member of an unnamed package (7.4.2) and has package access.\n-         * Its direct superclass type is always Object (8.1.4).\n-         * It never has any direct superinterface types (8.1.5).\n-         *\/\n-\n-        check(unnamedClass.isUnnamedClass(), \"Unnamed class was isUnnamedClass() false\");\n-\n-        check(!(unnamedClass.isInterface() ||\n-                unnamedClass.isEnum()      ||\n-                unnamedClass.isRecord()    ||\n-                unnamedClass.isHidden()),\n-              \"Unnamed class was not a normal class\");\n-\n-        check(!(unnamedClass.isLocalClass()  ||\n-                unnamedClass.isMemberClass() ||\n-                unnamedClass.isPrimitive()   ||\n-                unnamedClass.isArray()),\n-              \"Unnamed class was not top-level\");\n-\n-        check(\"Unnamed\".equals(unnamedClass.getName()),     \"Unexpected Class.getName result\");\n-        check(\"Unnamed\".equals(unnamedClass.getTypeName()), \"Unexpected Class.getTypeName result\");\n-        check(\"\".equals(unnamedClass.getSimpleName()),      \"Unexpected Class.getSimpleName result\");\n-        check(unnamedClass.getCanonicalName() == null,      \"Unexpected non-null Class.getCanonicalName\");\n-\n-        int modifiers = unnamedClass.getModifiers();\n-        check((modifiers & Modifier.ABSTRACT) == 0,    \"Unnamed class was abstract\");\n-        check((modifiers & Modifier.FINAL) != 0,       \"Unnamed class was not final\");\n-        check((modifiers & (Modifier.PUBLIC  |\n-                            Modifier.PRIVATE |\n-                            Modifier.PROTECTED)) == 0, \"Unnamed class was not package access\");\n-\n-        check(unnamedClass.isSynthetic(), \"Unnamed class was not synthetic\");\n-\n-        check(\"\".equals(unnamedClass.getPackage().getName()), \"Unnamed class not in an unnamed package\");\n-\n-        check(unnamedClass.getSuperclass() == Object.class, \"Superclass was not java.lang.Object\");\n-\n-        check(unnamedClass.getInterfaces().length == 0, \"Unnamed class had super interfaces\");\n-    }\n-\n-    private static void check(boolean predicate, String message) {\n-        if (!predicate) {\n-            throw new RuntimeException(message);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Class\/UnnamedClass\/TestUnnamedClass.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -544,1 +544,1 @@\n-        tr.contains(\"Error: Main method must return a value of type void in class Foo\");\n+        tr.contains(\"Error: Main method not found in class Foo\");\n@@ -549,1 +549,1 @@\n-        tr.contains(\"Error: Main method must return a value of type void in class Foo\");\n+        tr.contains(\"Error: Main method not found in class Foo\");\n@@ -570,1 +570,1 @@\n-        tr.contains(\"Error: Main method is not static in class Foo\");\n+        tr.contains(\"Error: Main method not found in class Foo\");\n@@ -575,1 +575,1 @@\n-        tr.contains(\"Error: Main method is not static in class Foo\");\n+        tr.contains(\"Error: Main method not found in class Foo\");\n","filename":"test\/jdk\/tools\/launcher\/Arrrghs.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-            \/\/ static dominating instance\n+            \/\/ instance dominating instance\n@@ -49,1 +49,0 @@\n-                    throw new AssertionError();\n@@ -52,0 +51,1 @@\n+                    throw new AssertionError();\n@@ -84,1 +84,1 @@\n-            \/\/ unnamed class static dominating instance\n+            \/\/ unnamed class dominating instance\n@@ -87,1 +87,0 @@\n-                throw new AssertionError();\n@@ -90,0 +89,1 @@\n+                throw new AssertionError();\n@@ -108,1 +108,1 @@\n-            \/\/ instance main dominating super static\n+            \/\/ instance main with args dominating super\n@@ -112,0 +112,1 @@\n+                    throw new AssertionError();\n@@ -116,1 +117,0 @@\n-                    throw new AssertionError();\n","filename":"test\/jdk\/tools\/launcher\/InstanceMainTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,2 +95,2 @@\n-                    .shouldContain(\"Error: Unable to initialize main class \" + MAIN_CLASS + \" in module \" + TEST_MODULE)\n-                    .shouldContain(\"Caused by: java.security.AccessControlException: access denied\")\n+                    .shouldContain(\"Error: Unable to load main class \" + MAIN_CLASS + \" in module \" + TEST_MODULE)\n+                    .shouldContain(\"Caused by: java.security.AccessControlException\")\n@@ -98,0 +98,1 @@\n+\n","filename":"test\/jdk\/tools\/launcher\/modules\/basic\/LauncherErrors.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Allow javadoc to process unnamed classes\n+ * @summary Allow javadoc to process implicit classes\n@@ -31,1 +31,1 @@\n- * @run main TestUnnamed\n+ * @run main TestImplicit\n@@ -42,1 +42,1 @@\n-public class TestUnnamed extends JavadocTester {\n+public class TestImplicit extends JavadocTester {\n@@ -49,1 +49,1 @@\n-        new TestUnnamed().runTests();\n+        new TestImplicit().runTests();\n@@ -53,1 +53,1 @@\n-    public void testUnnamed(Path base) throws IOException {\n+    public void testImplicit(Path base) throws IOException {\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnnamed\/TestImplicit.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnnamed\/TestUnnamed.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n- * Exemplar unnamed class.\n+ * Exemplar implicit class.\n@@ -28,1 +28,1 @@\n-public void main() {\n+void main() {\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/Implicit.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/jdk\/java\/lang\/Class\/UnnamedClass\/Unnamed.java","status":"renamed"},{"patch":"@@ -0,0 +1,8 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @compile\/fail\/ref=ImplicitClassRecovery.out -XDrawDiagnostics --enable-preview --source ${jdk.version} ImplicitClassRecovery.java\n+ *\/\n+public void main() {\n+    \/\/the following is intentionally missing a semicolon:\n+    System.err.println(\"Hello!\")\n+}\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ImplicitClassRecovery.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+ImplicitClassRecovery.java:7:33: compiler.err.expected: ';'\n+- compiler.note.preview.filename: ImplicitClassRecovery.java, DEFAULT\n+- compiler.note.preview.recompile\n+1 error\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ImplicitClassRecovery.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8315458\n+ * @enablePreview\n+ * @summary Make sure nesting classes don't create symbol conflicts with implicit name.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main NestedClasses\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import toolbox.ToolBox;\n+import toolbox.JavaTask;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+\n+public class NestedClasses {\n+    private static ToolBox TOOLBOX = new ToolBox();\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    public static void main(String... arg) throws IOException {\n+        compPass(\"A.java\", \"\"\"\n+            void main() {}\n+            class A {} \/\/ okay\n+            \"\"\");\n+\n+        compPass(\"A.java\", \"\"\"\n+            void main() {}\n+            class B {\n+               class A { } \/\/ okay\n+            }\n+            \"\"\");\n+\n+        compFail(\"A.java\", \"\"\"\n+            void main() {}\n+            class B {\n+               class B { } \/\/error\n+            }\n+            \"\"\");\n+    }\n+\n+    \/*\n+     * Test source for successful compile.\n+     *\/\n+    static void compPass(String fileName, String code) throws IOException {\n+        Path path = Path.of(fileName);\n+        Files.writeString(path, code);\n+        String output = new JavacTask(TOOLBOX)\n+                .files(List.of(path))\n+                .classpath(\".\")\n+                .options(\"-encoding\", \"utf8\", \"--enable-preview\", \"-source\", JAVA_VERSION)\n+                .run()\n+                .writeAll()\n+                .getOutput(Task.OutputKind.DIRECT);\n+\n+        if (output.contains(\"compiler.err\")) {\n+            throw new RuntimeException(\"Error detected\");\n+        }\n+    }\n+\n+    \/*\n+     * Test source for unsuccessful compile and specific error.\n+     *\/\n+    static void compFail(String fileName, String code) throws IOException {\n+        Path path = Path.of(fileName);\n+        Files.writeString(path, code);\n+        String output = new JavacTask(TOOLBOX)\n+                .files(List.of(path))\n+                .classpath(\".\")\n+                .options(\"-XDrawDiagnostics\", \"-encoding\", \"utf8\", \"--enable-preview\", \"-source\", JAVA_VERSION)\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutput(Task.OutputKind.DIRECT);\n+\n+        if (!output.contains(\"compiler.err\")) {\n+            throw new RuntimeException(\"No error detected\");\n+        }\n+    }\n+\n+ }\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/NestedClasses.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/NestedEnum.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/unnamedclass\/NestedEnum.java","status":"renamed"},{"patch":"@@ -0,0 +1,13 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8310314\n+ * @summary Ensure proper error position for the \"implicit classes not supported\" error\n+ * @compile\/fail\/ref=SourceLevelErrorPosition.out -XDrawDiagnostics SourceLevelErrorPosition.java\n+ *\/\n+class Nested {}\n+void main() {\n+    System.err.println(\"\");\n+}\n+void test() {\n+    System.err.println(\"\");\n+}\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/SourceLevelErrorPosition.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+SourceLevelErrorPosition.java:8:1: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.implicit.classes)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/SourceLevelErrorPosition.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8315458\n+ * @enablePreview\n+ * @build Implicit TestImplicitClass\n+ * @run main TestImplicitClass\n+ * @summary Basic checks of java.lang.Class support for implicit classes\n+ *\/\n+\n+import java.lang.reflect.Modifier;\n+\n+public class TestImplicitClass {\n+    public static void main(String... args) throws Exception {\n+        Class<?> implicitClass = Class.forName(\"Implicit\");\n+\n+        \/*\n+         * From JEP 463 JLS changes:\n+         *\n+         * \"An implicit class compilation unit implicitly declares a class that satisfies the following\n+         * properties:\n+         * It is always a top level class.\n+         * It is never abstract (8.1.1.1).\n+         * It is never synthetic (13.1.11)\n+         * It is always final (8.1.1.2).\n+         * It is always a member of unnamed package (7.4.2) and has package access.\n+         * Its direct superclass type is always Object (8.1.4).\n+         * It never has any direct superinterface types (8.1.5).\n+         *\/\n+\n+        check(!(implicitClass.isInterface() ||\n+                implicitClass.isEnum()      ||\n+                implicitClass.isRecord()    ||\n+                implicitClass.isHidden()),\n+              \"Implicit class was not a normal class\");\n+\n+        check(!(implicitClass.isLocalClass()  ||\n+                implicitClass.isMemberClass() ||\n+                implicitClass.isPrimitive()   ||\n+                implicitClass.isArray()),\n+              \"Implicit class was not top-level\");\n+\n+        check(\"Implicit\".equals(implicitClass.getName()),     \"Unexpected Class.getName result\");\n+        check(\"Implicit\".equals(implicitClass.getTypeName()), \"Unexpected Class.getTypeName result\");\n+        check(\"Implicit\".equals(implicitClass.getSimpleName()),      \"Unexpected Class.getSimpleName result\");\n+        check(\"Implicit\".equals(implicitClass.getCanonicalName()),      \"Unexpected Class.getCanonicalName result\");\n+\n+        int modifiers = implicitClass.getModifiers();\n+        check((modifiers & Modifier.ABSTRACT) == 0,    \"Implicit class was abstract\");\n+        check((modifiers & Modifier.FINAL) != 0,       \"Implicit class was not final\");\n+        check((modifiers & (Modifier.PUBLIC  |\n+                            Modifier.PRIVATE |\n+                            Modifier.PROTECTED)) == 0, \"Implicit class was not package access\");\n+\n+        check(!implicitClass.isSynthetic(), \"Implicit class was synthetic\");\n+\n+        check(\"\".equals(implicitClass.getPackage().getName()), \"Implicit class not in an implicit package\");\n+\n+        check(implicitClass.getSuperclass() == Object.class, \"Superclass was not java.lang.Object\");\n+\n+        check(implicitClass.getInterfaces().length == 0, \"Implicit class had super interfaces\");\n+    }\n+\n+    private static void check(boolean predicate, String message) {\n+        if (!predicate) {\n+            throw new RuntimeException(message);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/TestImplicitClass.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n- \/\/ key: compiler.misc.feature.unnamed.classes\n+ \/\/ key: compiler.misc.feature.implicit.classes\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClass.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitClassBad-Filename.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassBad-Filename.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n- \/\/ key: compiler.err.unnamed.class.should.not.have.package.declaration\n+ \/\/ key: compiler.err.implicit.class.should.not.have.package.declaration\n@@ -29,1 +29,1 @@\n-package unnamed.classes;\n+package implicit.classes;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitClassHasPackage.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassHasPackage.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n- \/\/ key: compiler.err.unnamed.class.does.not.have.main.method\n+ \/\/ key: compiler.err.implicit.class.does.not.have.main.method\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitClassNoMain.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassNoMain.java","status":"renamed"},{"patch":"@@ -567,1 +567,1 @@\n-                \"error: 'main' method is not declared 'public static'\");\n+                \"error: can't find main(String[]) method in class: NotStatic\");\n@@ -575,1 +575,1 @@\n-                \"error: 'main' method is not declared with a return type of 'void'\");\n+                \"error: can't find main(String[]) method in class: NotVoid\");\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2475,1 +2475,1 @@\n-                     \/*synthetic*\/ final class Test {\n+                     final class Test {\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8306112 8309568\n+ * @summary Test basic processing of implicitly declared classes.\n+ * @library \/tools\/javac\/lib\n+ * @modules java.compiler\n+ *          jdk.compiler\n+ * @build   JavacTestingAbstractProcessor TestImplicitClass\n+ * @compile         -processor TestImplicitClass            --enable-preview --release ${jdk.version}                            Anonymous.java\n+ * @clean Nameless.java\n+ * @compile\/process -processor TestImplicitClass -proc:only --enable-preview --release ${jdk.version} -Xprefer:newer -AclassOnly Anonymous Nameless\n+ *\/\n+\n+\/\/ The first @compile line processes Anonymous.java and a\n+\/\/ Nameless.java class generated using the Filer. Both of those implicitly\n+\/\/ declared classes are then compiled down to class files.  The second\n+\/\/ @compile line, as directed by -Xprefer:newer, builds and checks the\n+\/\/ language model objects constructed from those class files, ignoring\n+\/\/ any source files for those types.\n+\n+import java.lang.annotation.*;\n+import java.io.Writer;\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.Elements;\n+import static javax.lang.model.util.ElementFilter.*;\n+import javax.tools.JavaFileObject;\n+\n+\/**\n+ * Test annotation processing representation of implicitly classes\n+ * constructed from either a source file or a class file.\n+ *\/\n+@SuppressWarnings(\"preview\")\n+@SupportedOptions(\"classOnly\")\n+public class TestImplicitClass extends JavacTestingAbstractProcessor {\n+\n+    private static int round  = 0;\n+    private static int checkedClassesCount = 0;\n+    private static boolean classOnly = false;\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (round == 0) {\n+            classOnly = options.containsKey(\"classOnly\");\n+\n+            checkRoots(roundEnv); \/\/ Check any files from the comamnd line\n+\n+            \/\/ Don't generate any files if testing pre-existing class files\n+            if (!classOnly) {\n+                generateImplicitClass();\n+            }\n+        } else {\n+            if (!roundEnv.processingOver()) { \/\/ Test generated file(s)\n+                checkRoots(roundEnv);\n+            } else { \/\/ Should have checked at least one class before processing is over\n+                if (checkedClassesCount == 0) {\n+                    messager.printError(\"No implicitly declared classes checked.\");\n+                }\n+            }\n+        }\n+\n+        round++;\n+        return true;\n+    }\n+\n+    private void checkRoots(RoundEnvironment roundEnv) {\n+        int checks = 0;\n+        for (TypeElement type : typesIn(roundEnv.getRootElements())) {\n+            checks++;\n+            checkUnnamedClassProperties(type);\n+        }\n+        if (checks == 0) {\n+            messager.printError(\"No checking done of any candidate implicitly declared classes.\");\n+        }\n+    }\n+\n+    private void generateImplicitClass() {\n+        try {\n+            String unnamedSource = \"\"\"\n+            void main() {\n+                System.out.println(\"Nameless, but not voiceless.\");\n+            }\n+            \"\"\";\n+\n+            JavaFileObject outputFile = processingEnv.getFiler().createSourceFile(\"Nameless\");\n+            try(Writer w = outputFile.openWriter()) {\n+                w.append(unnamedSource);\n+            }\n+        } catch (java.io.IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    \/*\n+     * From JEP 445 JLS changes:\n+     *\n+     * \"An implicitly declared class compilation unit implicitly declares a class that\n+     * satisfies the following properties:\n+     * It is always a top level class.\n+     * It is never abstract (8.1.1.1).\n+     * It is always final (8.1.1.2).\n+     * It is always a member of an unnamed package (7.4.2) and has package access.\n+     * Its direct superclass type is always Object (8.1.4).\n+     * It never has any direct superinterface types (8.1.5).\n+     *\n+     * The body of the class contains every ClassMemberDeclaration\n+     * from the implicitly declared class compilation unit. It is not possible for\n+     * an implicitly declared class compilation unit to declare an instance\n+     * initializer, static initializer, or constructor.\n+     *\n+     * It has an implicitly declared default constructor (8.8.9).\n+     * All members of this class, including any implicitly declared\n+     * members, are subject to the usual rules for member declarations\n+     * in a class.\n+     *\n+     * It is a compile-time error if this class does not declare a candidate main method (12.1.4).\n+     *\/\n+    void checkUnnamedClassProperties(TypeElement implicitClass) {\n+        checkedClassesCount++;\n+        Name expectedName = implicitClass.getSimpleName();\n+\n+        System.out.println(\"Checking \" + expectedName);\n+\n+        if (implicitClass.getNestingKind() != NestingKind.TOP_LEVEL) {\n+            messager.printError(\"Implicitly declared class is not top-level.\", implicitClass);\n+        }\n+\n+        if (!implicitClass.getQualifiedName().equals(expectedName)) {\n+            messager.printError(\"Implicitly declared class qualified name does not match simple name.\", implicitClass);\n+        }\n+\n+        Name binaryName = elements.getBinaryName(implicitClass);\n+        if (!expectedName.equals(binaryName)) {\n+            messager.printError(\"Implicitly declared class has unexpected binary name\" + binaryName + \".\", implicitClass);\n+        }\n+\n+        if (implicitClass.getModifiers().contains(Modifier.ABSTRACT)) {\n+            messager.printError(\"Implicitly declared class is abstract.\", implicitClass);\n+        }\n+\n+        if (!implicitClass.getModifiers().contains(Modifier.FINAL)) {\n+            messager.printError(\"Implicitly declared class is _not_ final.\", implicitClass);\n+        }\n+\n+        if (!elements.getPackageOf(implicitClass).isUnnamed()) {\n+            messager.printError(\"Implicitly declared class is _not_ in an unnamed package.\", implicitClass);\n+        }\n+\n+        if (implicitClass.getModifiers().contains(Modifier.PUBLIC)  ||\n+            implicitClass.getModifiers().contains(Modifier.PRIVATE) ||\n+            implicitClass.getModifiers().contains(Modifier.PROTECTED)) {\n+            messager.printError(\"Implicitly declared class does _not_ have package access.\", implicitClass);\n+        }\n+\n+        if ( !types.isSameType(implicitClass.getSuperclass(),\n+                               elements.getTypeElement(\"java.lang.Object\").asType())) {\n+            messager.printError(\"Implicitly declared class does _not_ have java.lang.Object as a superclass.\", implicitClass);\n+        }\n+\n+        if (!implicitClass.getInterfaces().isEmpty()) {\n+            messager.printError(\"Implicitly declared class has superinterfaces.\", implicitClass);\n+        }\n+\n+        List<ExecutableElement> ctors = constructorsIn(implicitClass.getEnclosedElements());\n+        if (ctors.size() != 1 ) {\n+            messager.printError(\"Did not find exactly one constructor\", implicitClass);\n+        }\n+\n+        if (!classOnly) {\n+            \/\/ Mandated-ness of default constructors not preserved in class files\n+            ExecutableElement ctor = ctors.getFirst();\n+            if (elements.getOrigin(ctor) != Elements.Origin.MANDATED) {\n+                messager.printError(\"Constructor was not marked as mandated\", ctor);\n+            }\n+        }\n+\n+        List<ExecutableElement> methods = methodsIn(implicitClass.getEnclosedElements());\n+        \/\/ Just look for a method named \"main\"; don't check the other details.\n+        boolean mainFound = false;\n+        Name mainName = elements.getName(\"main\");\n+        for (var method : methods) {\n+            if (method.getSimpleName().equals(mainName)) {\n+                mainFound = true;\n+                break;\n+            }\n+        }\n+\n+        if (!mainFound) {\n+            messager.printError(\"No main method found\", implicitClass);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestImplicitClass.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -1,226 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8306112 8309568\n- * @summary Test basic processing of unnamed classes.\n- * @library \/tools\/javac\/lib\n- * @modules java.compiler\n- *          jdk.compiler\n- * @build   JavacTestingAbstractProcessor TestUnnamedClass\n- * @compile         -processor TestUnnamedClass            --enable-preview --release ${jdk.version}                            Anonymous.java\n- * @clean Nameless.java\n- * @compile\/process -processor TestUnnamedClass -proc:only --enable-preview --release ${jdk.version} -Xprefer:newer -AclassOnly Anonymous Nameless\n- *\/\n-\n-\/\/ The first @compile line processes Anonymous.java and a\n-\/\/ Nameless.java class generated using the Filer. Both of those\n-\/\/ unnamed classes are then compiled down to class files.  The second\n-\/\/ @compile line, as directed by -Xprefer:newer, builds and checks the\n-\/\/ language model objects constructed from those class files, ignoring\n-\/\/ any source files for those types.\n-\n-import java.lang.annotation.*;\n-import java.io.Writer;\n-import java.util.List;\n-import java.util.Set;\n-import javax.annotation.processing.*;\n-import javax.lang.model.element.*;\n-import javax.lang.model.util.Elements;\n-import static javax.lang.model.util.ElementFilter.*;\n-import javax.tools.JavaFileObject;\n-\n-\/**\n- * Test annotation processing representation of unnamed classes\n- * constructed from either a source file or a class file.\n- *\/\n-@SuppressWarnings(\"preview\")\n-@SupportedOptions(\"classOnly\")\n-public class TestUnnamedClass  extends JavacTestingAbstractProcessor {\n-\n-    private static int round  = 0;\n-    private static int checkedClassesCount = 0;\n-    private static boolean classOnly = false;\n-\n-    public boolean process(Set<? extends TypeElement> annotations,\n-                           RoundEnvironment roundEnv) {\n-        if (round == 0) {\n-            classOnly = options.containsKey(\"classOnly\");\n-\n-            checkRoots(roundEnv); \/\/ Check any files from the comamnd line\n-\n-            \/\/ Don't generate any files if testing pre-existing class files\n-            if (!classOnly) {\n-                generateUnnamed();\n-            }\n-        } else {\n-            if (!roundEnv.processingOver()) { \/\/ Test generated file(s)\n-                checkRoots(roundEnv);\n-            } else { \/\/ Should have checked at least one class before processing is over\n-                if (checkedClassesCount == 0) {\n-                    messager.printError(\"No unnamed classes checked.\");\n-                }\n-            }\n-        }\n-\n-        round++;\n-        return true;\n-    }\n-\n-    private void checkRoots(RoundEnvironment roundEnv) {\n-        int checks = 0;\n-        for (TypeElement type : typesIn(roundEnv.getRootElements())) {\n-            checks++;\n-            checkUnnamedClassProperties(type);\n-        }\n-        if (checks == 0) {\n-            messager.printError(\"No checking done of any candidate unnamed classes.\");\n-        }\n-    }\n-\n-    private void generateUnnamed() {\n-        try {\n-            String unnamedSource = \"\"\"\n-            void main() {\n-                System.out.println(\"Nameless, but not voiceless.\");\n-            }\n-            \"\"\";\n-\n-            JavaFileObject outputFile = processingEnv.getFiler().createSourceFile(\"Nameless\");\n-            try(Writer w = outputFile.openWriter()) {\n-                w.append(unnamedSource);\n-            }\n-        } catch (java.io.IOException ioe) {\n-            throw new RuntimeException(ioe);\n-        }\n-    }\n-\n-    \/*\n-     * From JEP 445 JLS changes:\n-     *\n-     * \"An unnamed class compilation unit implicitly declares a class that satisfies the following\n-     * properties:\n-     * It is always a top level class.\n-     * It is always an unnamed class (it has no canonical or fully qualified name (6.7)).\n-     * It is never abstract (8.1.1.1).\n-     * It is always final (8.1.1.2).\n-     * It is always a member of an unnamed package (7.4.2) and has package access.\n-     * Its direct superclass type is always Object (8.1.4).\n-     * It never has any direct superinterface types (8.1.5).\n-     *\n-     * The body of the class contains every ClassMemberDeclaration\n-     * from the unnamed class compilation unit. It is not possible for\n-     * an unnamed class compilation unit to declare an instance\n-     * initializer, static initializer, or constructor.\n-     *\n-     * It has an implicitly declared default constructor (8.8.9).\n-     * All members of this class, including any implicitly declared\n-     * members, are subject to the usual rules for member declarations\n-     * in a class.\n-     *\n-     * It is a compile-time error if this class does not declare a candidate main method (12.1.4).\n-     *\/\n-    void checkUnnamedClassProperties(TypeElement unnamedClass) {\n-        checkedClassesCount++;\n-        Name expectedName = unnamedClass.getSimpleName();\n-\n-        System.out.println(\"Checking \" + expectedName);\n-\n-        if (unnamedClass.getNestingKind() != NestingKind.TOP_LEVEL) {\n-            messager.printError(\"Unnamed class is not top-level.\", unnamedClass);\n-        }\n-\n-        if (!unnamedClass.isUnnamed()) {\n-            messager.printError(\"Unnamed class is _not_ indicated as such.\", unnamedClass);\n-        }\n-\n-        if (unnamedClass.getSimpleName().isEmpty()) {\n-            messager.printError(\"Unnamed class has an empty simple name.\", unnamedClass);\n-        }\n-\n-        if (!unnamedClass.getQualifiedName().isEmpty()) {\n-            messager.printError(\"Unnamed class does _not_ have an empty qualified name.\", unnamedClass);\n-        }\n-\n-        Name binaryName = elements.getBinaryName(unnamedClass);\n-        if (!expectedName.equals(binaryName)) {\n-            messager.printError(\"Unnamed has unexpected binary name\" + binaryName + \".\", unnamedClass);\n-        }\n-\n-        if (unnamedClass.getModifiers().contains(Modifier.ABSTRACT)) {\n-            messager.printError(\"Unnamed class is abstract.\", unnamedClass);\n-        }\n-\n-        if (!unnamedClass.getModifiers().contains(Modifier.FINAL)) {\n-            messager.printError(\"Unnamed class is _not_ final.\", unnamedClass);\n-        }\n-\n-        if (!elements.getPackageOf(unnamedClass).isUnnamed()) {\n-            messager.printError(\"Unnamed class is _not_ in an unnamed package.\", unnamedClass);\n-        }\n-\n-        if (unnamedClass.getModifiers().contains(Modifier.PUBLIC)  ||\n-            unnamedClass.getModifiers().contains(Modifier.PRIVATE) ||\n-            unnamedClass.getModifiers().contains(Modifier.PROTECTED)) {\n-            messager.printError(\"Unnamed class does _not_ have package access.\", unnamedClass);\n-        }\n-\n-        if ( !types.isSameType(unnamedClass.getSuperclass(),\n-                               elements.getTypeElement(\"java.lang.Object\").asType())) {\n-            messager.printError(\"Unnamed class does _not_ have java.lang.Object as a superclass.\", unnamedClass);\n-        }\n-\n-        if (!unnamedClass.getInterfaces().isEmpty()) {\n-            messager.printError(\"Unnamed class has superinterfaces.\", unnamedClass);\n-        }\n-\n-        List<ExecutableElement> ctors = constructorsIn(unnamedClass.getEnclosedElements());\n-        if (ctors.size() != 1 ) {\n-            messager.printError(\"Did not find exactly one constructor\", unnamedClass);\n-        }\n-\n-        if (!classOnly) {\n-            \/\/ Mandated-ness of default constructors not preserved in class files\n-            ExecutableElement ctor = ctors.getFirst();\n-            if (elements.getOrigin(ctor) != Elements.Origin.MANDATED) {\n-                messager.printError(\"Constructor was not marked as mandated\", ctor);\n-            }\n-        }\n-\n-        List<ExecutableElement> methods = methodsIn(unnamedClass.getEnclosedElements());\n-        \/\/ Just look for a method named \"main\"; don't check the other details.\n-        boolean mainFound = false;\n-        Name mainName = elements.getName(\"main\");\n-        for (var method : methods) {\n-            if (method.getSimpleName().equals(mainName)) {\n-                mainFound = true;\n-                break;\n-            }\n-        }\n-\n-        if (!mainFound) {\n-            messager.printError(\"No main mehtod found\", unnamedClass);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedClass.java","additions":0,"deletions":226,"binary":false,"changes":226,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-\/**\n- * @test \/nodynamiccopyright\/\n- * @compile\/fail\/ref=UnnamedClassRecovery.out -XDrawDiagnostics --enable-preview --source ${jdk.version} UnnamedClassRecovery.java\n- *\/\n-public void main() {\n-    \/\/the following is intentionally missing a semicolon:\n-    System.err.println(\"Hello!\")\n-}\n","filename":"test\/langtools\/tools\/javac\/unnamed\/UnnamedClassRecovery.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-UnnamedClassRecovery.java:7:33: compiler.err.expected: ';'\n-- compiler.note.preview.filename: UnnamedClassRecovery.java, DEFAULT\n-- compiler.note.preview.recompile\n-1 error\n","filename":"test\/langtools\/tools\/javac\/unnamed\/UnnamedClassRecovery.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,13 +0,0 @@\n-\/**\n- * @test \/nodynamiccopyright\/\n- * @bug 8310314\n- * @summary Ensure proper error position for the \"unnamed classes not supported\" error\n- * @compile\/fail\/ref=SourceLevelErrorPosition.out -XDrawDiagnostics SourceLevelErrorPosition.java\n- *\/\n-class Nested {}\n-void main() {\n-    System.err.println(\"\");\n-}\n-void test() {\n-    System.err.println(\"\");\n-}\n","filename":"test\/langtools\/tools\/javac\/unnamedclass\/SourceLevelErrorPosition.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-SourceLevelErrorPosition.java:8:1: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.unnamed.classes)\n-1 error\n","filename":"test\/langtools\/tools\/javac\/unnamedclass\/SourceLevelErrorPosition.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"}]}