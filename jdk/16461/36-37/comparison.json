{"files":[{"patch":"@@ -0,0 +1,217 @@\n+\/*\r\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+\/*\r\n+ * @test\r\n+ * @bug 8306112 8309568\r\n+ * @summary Test basic processing of implicitly declared classes.\r\n+ * @library \/tools\/javac\/lib\r\n+ * @modules java.compiler\r\n+ *          jdk.compiler\r\n+ * @build   JavacTestingAbstractProcessor TestImplicitClass\r\n+ * @compile         -processor TestImplicitClass            --enable-preview --release ${jdk.version}                            Anonymous.java\r\n+ * @clean Nameless.java\r\n+ * @compile\/process -processor TestImplicitClass -proc:only --enable-preview --release ${jdk.version} -Xprefer:newer -AclassOnly Anonymous Nameless\r\n+ *\/\r\n+\r\n+\/\/ The first @compile line processes Anonymous.java and a\r\n+\/\/ Nameless.java class generated using the Filer. Both of those implicitly\r\n+\/\/ declared classes are then compiled down to class files.  The second\r\n+\/\/ @compile line, as directed by -Xprefer:newer, builds and checks the\r\n+\/\/ language model objects constructed from those class files, ignoring\r\n+\/\/ any source files for those types.\r\n+\r\n+import java.lang.annotation.*;\r\n+import java.io.Writer;\r\n+import java.util.List;\r\n+import java.util.Set;\r\n+import javax.annotation.processing.*;\r\n+import javax.lang.model.element.*;\r\n+import javax.lang.model.util.Elements;\r\n+import static javax.lang.model.util.ElementFilter.*;\r\n+import javax.tools.JavaFileObject;\r\n+\r\n+\/**\r\n+ * Test annotation processing representation of implicitly classes\r\n+ * constructed from either a source file or a class file.\r\n+ *\/\r\n+@SuppressWarnings(\"preview\")\r\n+@SupportedOptions(\"classOnly\")\r\n+public class TestImplicitClass extends JavacTestingAbstractProcessor {\r\n+\r\n+    private static int round  = 0;\r\n+    private static int checkedClassesCount = 0;\r\n+    private static boolean classOnly = false;\r\n+\r\n+    public boolean process(Set<? extends TypeElement> annotations,\r\n+                           RoundEnvironment roundEnv) {\r\n+        if (round == 0) {\r\n+            classOnly = options.containsKey(\"classOnly\");\r\n+\r\n+            checkRoots(roundEnv); \/\/ Check any files from the comamnd line\r\n+\r\n+            \/\/ Don't generate any files if testing pre-existing class files\r\n+            if (!classOnly) {\r\n+                generateImplicitClass();\r\n+            }\r\n+        } else {\r\n+            if (!roundEnv.processingOver()) { \/\/ Test generated file(s)\r\n+                checkRoots(roundEnv);\r\n+            } else { \/\/ Should have checked at least one class before processing is over\r\n+                if (checkedClassesCount == 0) {\r\n+                    messager.printError(\"No implicitly declared classes checked.\");\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        round++;\r\n+        return true;\r\n+    }\r\n+\r\n+    private void checkRoots(RoundEnvironment roundEnv) {\r\n+        int checks = 0;\r\n+        for (TypeElement type : typesIn(roundEnv.getRootElements())) {\r\n+            checks++;\r\n+            checkUnnamedClassProperties(type);\r\n+        }\r\n+        if (checks == 0) {\r\n+            messager.printError(\"No checking done of any candidate implicitly declared classes.\");\r\n+        }\r\n+    }\r\n+\r\n+    private void generateImplicitClass() {\r\n+        try {\r\n+            String unnamedSource = \"\"\"\r\n+            void main() {\r\n+                System.out.println(\"Nameless, but not voiceless.\");\r\n+            }\r\n+            \"\"\";\r\n+\r\n+            JavaFileObject outputFile = processingEnv.getFiler().createSourceFile(\"Nameless\");\r\n+            try(Writer w = outputFile.openWriter()) {\r\n+                w.append(unnamedSource);\r\n+            }\r\n+        } catch (java.io.IOException ioe) {\r\n+            throw new RuntimeException(ioe);\r\n+        }\r\n+    }\r\n+\r\n+    \/*\r\n+     * From JEP 445 JLS changes:\r\n+     *\r\n+     * \"An implicitly declared class compilation unit implicitly declares a class that\r\n+     * satisfies the following properties:\r\n+     * It is always a top level class.\r\n+     * It is never abstract (8.1.1.1).\r\n+     * It is always final (8.1.1.2).\r\n+     * It is always a member of an unnamed package (7.4.2) and has package access.\r\n+     * Its direct superclass type is always Object (8.1.4).\r\n+     * It never has any direct superinterface types (8.1.5).\r\n+     *\r\n+     * The body of the class contains every ClassMemberDeclaration\r\n+     * from the implicitly declared class compilation unit. It is not possible for\r\n+     * an implicitly declared class compilation unit to declare an instance\r\n+     * initializer, static initializer, or constructor.\r\n+     *\r\n+     * It has an implicitly declared default constructor (8.8.9).\r\n+     * All members of this class, including any implicitly declared\r\n+     * members, are subject to the usual rules for member declarations\r\n+     * in a class.\r\n+     *\r\n+     * It is a compile-time error if this class does not declare a candidate main method (12.1.4).\r\n+     *\/\r\n+    void checkUnnamedClassProperties(TypeElement implicitClass) {\r\n+        checkedClassesCount++;\r\n+        Name expectedName = implicitClass.getSimpleName();\r\n+\r\n+        System.out.println(\"Checking \" + expectedName);\r\n+\r\n+        if (implicitClass.getNestingKind() != NestingKind.TOP_LEVEL) {\r\n+            messager.printError(\"Implicitly declared class is not top-level.\", implicitClass);\r\n+        }\r\n+\r\n+        if (!implicitClass.getQualifiedName().equals(expectedName)) {\r\n+            messager.printError(\"Implicitly declared class qualified name does not match simple name.\", implicitClass);\r\n+        }\r\n+\r\n+        Name binaryName = elements.getBinaryName(implicitClass);\r\n+        if (!expectedName.equals(binaryName)) {\r\n+            messager.printError(\"Implicitly declared class has unexpected binary name\" + binaryName + \".\", implicitClass);\r\n+        }\r\n+\r\n+        if (implicitClass.getModifiers().contains(Modifier.ABSTRACT)) {\r\n+            messager.printError(\"Implicitly declared class is abstract.\", implicitClass);\r\n+        }\r\n+\r\n+        if (!implicitClass.getModifiers().contains(Modifier.FINAL)) {\r\n+            messager.printError(\"Implicitly declared class is _not_ final.\", implicitClass);\r\n+        }\r\n+\r\n+        if (!elements.getPackageOf(implicitClass).isUnnamed()) {\r\n+            messager.printError(\"Implicitly declared class is _not_ in an unnamed package.\", implicitClass);\r\n+        }\r\n+\r\n+        if (implicitClass.getModifiers().contains(Modifier.PUBLIC)  ||\r\n+            implicitClass.getModifiers().contains(Modifier.PRIVATE) ||\r\n+            implicitClass.getModifiers().contains(Modifier.PROTECTED)) {\r\n+            messager.printError(\"Implicitly declared class does _not_ have package access.\", implicitClass);\r\n+        }\r\n+\r\n+        if ( !types.isSameType(implicitClass.getSuperclass(),\r\n+                               elements.getTypeElement(\"java.lang.Object\").asType())) {\r\n+            messager.printError(\"Implicitly declared class does _not_ have java.lang.Object as a superclass.\", implicitClass);\r\n+        }\r\n+\r\n+        if (!implicitClass.getInterfaces().isEmpty()) {\r\n+            messager.printError(\"Implicitly declared class has superinterfaces.\", implicitClass);\r\n+        }\r\n+\r\n+        List<ExecutableElement> ctors = constructorsIn(implicitClass.getEnclosedElements());\r\n+        if (ctors.size() != 1 ) {\r\n+            messager.printError(\"Did not find exactly one constructor\", implicitClass);\r\n+        }\r\n+\r\n+        if (!classOnly) {\r\n+            \/\/ Mandated-ness of default constructors not preserved in class files\r\n+            ExecutableElement ctor = ctors.getFirst();\r\n+            if (elements.getOrigin(ctor) != Elements.Origin.MANDATED) {\r\n+                messager.printError(\"Constructor was not marked as mandated\", ctor);\r\n+            }\r\n+        }\r\n+\r\n+        List<ExecutableElement> methods = methodsIn(implicitClass.getEnclosedElements());\r\n+        \/\/ Just look for a method named \"main\"; don't check the other details.\r\n+        boolean mainFound = false;\r\n+        Name mainName = elements.getName(\"main\");\r\n+        for (var method : methods) {\r\n+            if (method.getSimpleName().equals(mainName)) {\r\n+                mainFound = true;\r\n+                break;\r\n+            }\r\n+        }\r\n+\r\n+        if (!mainFound) {\r\n+            messager.printError(\"No main method found\", implicitClass);\r\n+        }\r\n+    }\r\n+}\r\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestImplicitClass.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"}]}