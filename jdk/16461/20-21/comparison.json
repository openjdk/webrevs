{"files":[{"patch":"@@ -3716,1 +3716,1 @@\n-            \/* includeStatic *\/ true);\n+            \/* includeStatic *\/ true, \/* publicOnly *\/ true);\n@@ -3725,3 +3725,4 @@\n-                                                         boolean includeStatic) {\n-        \/\/ 1st check declared public methods\n-        Method[] methods = privateGetDeclaredMethods(\/* publicOnly *\/ true);\n+                                                         boolean includeStatic,\n+                                                         boolean publicOnly) {\n+        \/\/ 1st check declared methods\n+        Method[] methods = privateGetDeclaredMethods(publicOnly);\n@@ -3741,1 +3742,1 @@\n-            res = sc.getMethodsRecursive(name, parameterTypes, includeStatic);\n+            res = sc.getMethodsRecursive(name, parameterTypes, includeStatic, publicOnly);\n@@ -3748,2 +3749,1 @@\n-                res, intf.getMethodsRecursive(name, parameterTypes,\n-                                              \/* includeStatic *\/ false));\n+                res, intf.getMethodsRecursive(name, parameterTypes, includeStatic, publicOnly));\n@@ -4790,0 +4790,52 @@\n+\n+    private Method getAnyMethod(String name, Class<?>... parameterTypes) {\n+        Objects.requireNonNull(name, \"name must not be null\");\n+        Objects.requireNonNull(parameterTypes, \"parameterTypes must not be null\");\n+        PublicMethods.MethodList res = getMethodsRecursive(name, parameterTypes, true, false);\n+        return res == null ? null : getReflectionFactory().copyMethod(res.getMostSpecific());\n+    }\n+\n+    \/**\n+     * Return the first method that meets the requirements of an application main method.\n+     * The method must:\n+     * <ul>\n+     * <li>be declared this class's hierarchy<\/li>\n+     * <li>have the name \"main\"<\/li>\n+     * <li>have no arguments or a single argument of type {@code String[]}<\/li>\n+     * <li>have the return type of void<\/li>\n+     * <li>be public, protected or package private<\/li>\n+     * <li>not be abstract<\/li>\n+     * <\/ul>\n+     * Main methods that have a {@code String[]} argument will be chosen over main\n+     * methods with no argument.\n+     * @apiNote The method returned may be declared in this class, a parent class\n+     * or as a default method of an interface that the class or parent class\n+     * implements. It is not possible to declare a static main method and instance main\n+     * method with the same signature in the same class. (@jls 8.4.2) states that\n+     * \"It is a compile-time error to declare two methods with override-equivalent\n+     * signatures in a class.\"\n+     * @return the candidate main method or null if none found\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.IMPLICIT_CLASSES)\n+    public Method getMainMethod() {\n+        boolean isPreview = PreviewFeatures.isEnabled();\n+        Method mainMethod = getAnyMethod(\"main\", String[].class);\n+\n+        if (isPreview && mainMethod == null) {\n+            mainMethod = getAnyMethod(\"main\");\n+        }\n+\n+        if (mainMethod != null) {\n+            int mods = mainMethod.getModifiers();\n+\n+            if (Modifier.isPrivate(mods) || Modifier.isAbstract(mods) ||\n+                    mainMethod.getReturnType() != void.class) {\n+                mainMethod = null;\n+            } else if (!isPreview && !(Modifier.isStatic(mods) && Modifier.isPublic(mods))) {\n+                mainMethod = null;\n+            }\n+        }\n+\n+        return mainMethod;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":59,"deletions":7,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1,151 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.misc;\n-\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-\n-public class MainMethodFinder {\n-    \/**\n-     * {@return true if the method meets the requirements of a main method}\n-     *\n-     * @param method  method to test\n-     *\/\n-    private static boolean isMainMethod(Method method) {\n-        int mods = method.getModifiers();\n-        return !Modifier.isPrivate(mods) &&\n-               !Modifier.isAbstract(mods) &&\n-               method.getReturnType() == void.class;\n-    }\n-\n-    \/**\n-     * {@return a public main method accessable from the specified class}\n-     *\n-     * @param mainClass    Main class to start search from.\n-     * @param noArgs       true if no argument otherwise expects one String[] argument\n-     *\/\n-    private static Method getPublicMain(Class<?> mainClass, boolean noArgs) {\n-        try {\n-            \/\/ Search public methods\n-            Method mainMethod = noArgs ? mainClass.getMethod(\"main\")\n-                                       : mainClass.getMethod(\"main\", String[].class);\n-\n-            if (isMainMethod(mainMethod)) {\n-                return mainMethod;\n-            }\n-        } catch (NoSuchMethodException ex) {\n-            \/\/ fall through\n-        }\n-\n-        return null;\n-    }\n-\n-    \/**\n-     * {@return a non-private main method declared in the specified class}\n-     *\n-     * @param mainClass    Main class to start search from.\n-     * @param noArgs       true if no argument otherwise expects one String[] argument\n-     *\/\n-    private static Method getNonPrivateMain(Class<?> mainClass, boolean noArgs) {\n-        try {\n-            \/\/ Search public methods\n-            Method mainMethod = noArgs ? mainClass.getDeclaredMethod(\"main\")\n-                                       : mainClass.getDeclaredMethod(\"main\", String[].class);\n-\n-            if (isMainMethod(mainMethod)) {\n-                return mainMethod;\n-            }\n-        } catch (NoSuchMethodException ex) {\n-            \/\/ fall through\n-        }\n-\n-        return null;\n-    }\n-\n-    \/**\n-     * Search up the superclass hierarchy for a qualified main method.\n-     *\n-     * @param mainClass    Main class to start search from.\n-     * @param noArgs       true if no argument otherwise expects one String[] argument\n-     *\n-     * @return main method meeting requirements\n-     *\/\n-    private static Method findMainMethod(Class<?> mainClass, boolean noArgs) {\n-        Method mainMethod = getPublicMain(mainClass, noArgs);\n-\n-        if (mainMethod != null) {\n-            return mainMethod;\n-        }\n-\n-        \/\/ Search up hierarchy\n-        for ( ;\n-             mainClass != null && mainClass != Object.class;\n-             mainClass = mainClass.getSuperclass()) {\n-            mainMethod = getNonPrivateMain(mainClass, noArgs);\n-\n-            if (mainMethod != null) {\n-                return mainMethod;\n-            }\n-\n-            for (Class<?> interf : mainClass.getInterfaces()) {\n-                mainMethod = getNonPrivateMain(mainClass, noArgs);\n-\n-                if (mainMethod != null) {\n-                    return mainMethod;\n-                }\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    \/**\n-     * {@return qualified main method}\n-     *\n-     * @param mainClass main class\n-     *\n-     * @throws NoSuchMethodException when no main method found\n-     *\/\n-    public static Method findMainMethod(Class<?> mainClass) throws NoSuchMethodException {\n-        boolean useTraditionMain = !PreviewFeatures.isEnabled();\n-        boolean isTraditionalMain = false;\n-\n-        Method mainMethod = findMainMethod(mainClass, false);\n-\n-        if (mainMethod == null) {\n-            mainMethod = findMainMethod(mainClass, true);\n-        } else {\n-            int mods = mainMethod.getModifiers();\n-            isTraditionalMain = Modifier.isStatic(mods) && Modifier.isPublic(mods);\n-        }\n-\n-        if (mainMethod == null || useTraditionMain && !isTraditionalMain) {\n-            throw new NoSuchMethodException(mainClass.getName() + \".main(String[])\");\n-        }\n-\n-        return mainMethod;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MainMethodFinder.java","additions":0,"deletions":151,"binary":false,"changes":151,"status":"deleted"},{"patch":"@@ -74,1 +74,0 @@\n-import jdk.internal.misc.MainMethodFinder;\n@@ -897,5 +896,7 @@\n-            mainMethod = MainMethodFinder.findMainMethod(mainClass);\n-        } catch (NoSuchMethodException nsme) {\n-            \/\/ invalid main or not FX application, abort with an error\n-            abort(null, \"java.launcher.cls.error2\", mainClass.getName(),\n-                  JAVAFX_APPLICATION_CLASS_NAME);\n+            mainMethod = mainClass.getMainMethod();\n+\n+            if (mainMethod == null) {\n+                \/\/ invalid main or not FX application, abort with an error\n+                abort(null, \"java.launcher.cls.error2\", mainClass.getName(),\n+                      JAVAFX_APPLICATION_CLASS_NAME);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-import jdk.internal.misc.MainMethodFinder;\n@@ -437,4 +436,3 @@\n-        Method mainMethod;\n-        try {\n-            mainMethod = MainMethodFinder.findMainMethod(appClass);\n-        } catch (NoSuchMethodException e) {\n+        Method mainMethod = appClass.getMainMethod();\n+\n+        if (mainMethod == null) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"}]}