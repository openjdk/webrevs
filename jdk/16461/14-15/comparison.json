{"files":[{"patch":"@@ -36,1 +36,0 @@\n-     * @param argCount  number of expected arguments (0 or 1)\n@@ -38,1 +37,1 @@\n-    private static boolean isMainMethod(Method method, int argCount) {\n+    private static boolean isMainMethod(Method method) {\n@@ -40,4 +39,1 @@\n-                method.getParameterCount() == argCount &&\n-                (argCount == 0 || method.getParameterTypes()[0] == String[].class) &&\n-                method.getReturnType() == void.class &&\n-                \"main\".equals(method.getName());\n+                method.getReturnType() == void.class;\n@@ -55,5 +51,19 @@\n-        int argCount = noArgs ? 0 : 1;\n-        for ( ; mainClass != null && mainClass != Object.class; mainClass = mainClass.getSuperclass()) {\n-            for (Method method : mainClass.getDeclaredMethods()) {\n-                if (isMainMethod(method, argCount)) {\n-                    return method;\n+        try {\n+            Method mainMethod = noArgs ? mainClass.getMethod(\"main\")\n+                                       : mainClass.getMethod(\"main\", String[].class);\n+\n+            if (isMainMethod(mainMethod)) {\n+                return mainMethod;\n+            }\n+        } catch (Exception ex) {\n+            \/\/ pass through\n+        }\n+\n+        for ( ;\n+              mainClass != null && mainClass != Object.class;\n+              mainClass = mainClass.getSuperclass()) {\n+            try {\n+                Method mainMethod = noArgs ? mainClass.getDeclaredMethod(\"main\")\n+                                           : mainClass.getDeclaredMethod(\"main\", String[].class);\n+                if (isMainMethod(mainMethod)) {\n+                    return mainMethod;\n@@ -61,0 +71,2 @@\n+            } catch (Exception ex) {\n+                \/\/ pass through\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MainMethodFinder.java","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -712,1 +712,2 @@\n-     * 2. If the main class extends FX Application then call on FXHelper to\n+     * 2. Checks for a valid main method.\n+     * 3. If the main class extends FX Application then call on FXHelper to\n@@ -755,0 +756,1 @@\n+        validateMainMethod(mainClass);\n@@ -891,20 +893,2 @@\n-    \/*\n-     * main type flags\n-     *\/\n-    private static final int MAIN_WITHOUT_ARGS = 1;\n-    private static final int MAIN_NONSTATIC = 2;\n-\n-    \/*\n-     * Return whether the main method is non-static and\/or has no arguments\n-     * so that launcher invokes the method correctly.\n-     *\/\n-    public static int getMainType(Method mainMethod) {\n-        int mods = mainMethod.getModifiers();\n-        boolean isStatic = Modifier.isStatic(mods);\n-        boolean noArgs = mainMethod.getParameterCount() == 0;\n-        return (isStatic ? 0 : MAIN_NONSTATIC) | (noArgs ? MAIN_WITHOUT_ARGS : 0);\n-    }\n-\n-    \/\/ Check the existence and signature of main and abort if incorrect\n-    \/\/ Return main method.\n-    public static Method validateMainMethod(Class<?> mainClass) {\n+    \/\/ Check the existence and signature of main and abort if incorrect.\n+    private static void validateMainMethod(Class<?> mainClass) {\n@@ -929,1 +913,14 @@\n-        if (!Modifier.isStatic(mainMethod.getModifiers())) {\n+        int mods = mainMethod.getModifiers();\n+        boolean isStatic = Modifier.isStatic(mods);\n+        boolean isPublic = Modifier.isPublic(mods);\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n+\n+        if (!PreviewFeatures.isEnabled()) {\n+            if (!isStatic || !isPublic || noArgs) {\n+                  abort(null, \"java.launcher.cls.error2\", mainClass.getName(),\n+                       JAVAFX_APPLICATION_CLASS_NAME);\n+            }\n+            return;\n+        }\n+\n+        if (!isStatic) {\n@@ -933,1 +930,0 @@\n-                mainMethod = null;\n@@ -939,1 +935,0 @@\n-                    mainMethod = null;\n@@ -943,1 +938,0 @@\n-                mainMethod = null;\n@@ -946,2 +940,0 @@\n-\n-        return mainMethod;\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":19,"deletions":27,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -390,0 +390,63 @@\n+#define CHECK_EXCEPTION_FAIL() \\\n+    do { \\\n+        if ((*env)->ExceptionOccurred(env)) { \\\n+            (*env)->ExceptionClear(env); \\\n+            return 0; \\\n+        } \\\n+    } while (JNI_FALSE)\n+\n+\n+#define CHECK_EXCEPTION_NULL_FAIL(mainObject) \\\n+    do { \\\n+        if ((*env)->ExceptionOccurred(env)) { \\\n+            (*env)->ExceptionClear(env); \\\n+            return 0; \\\n+        } else if (mainObject == NULL) { \\\n+            return 0; \\\n+        } \\\n+    } while (JNI_FALSE)\n+\n+int\n+invokeStaticMainWithArgs(JNIEnv *env, jclass mainClass, jobjectArray mainArgs) {\n+    jmethodID mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n+                                  \"([Ljava\/lang\/String;)V\");\n+    CHECK_EXCEPTION_FAIL();\n+    (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n+    return 1;\n+}\n+\n+\n+int\n+invokeInstanceMainWithArgs(JNIEnv *env, jclass mainClass, jobjectArray mainArgs) {\n+    jmethodID constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+    CHECK_EXCEPTION_FAIL();\n+    jobject mainObject = (*env)->NewObject(env, mainClass, constructor);\n+    CHECK_EXCEPTION_NULL_FAIL(mainObject);\n+    jmethodID mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n+                                 \"([Ljava\/lang\/String;)V\");\n+    CHECK_EXCEPTION_FAIL();\n+    (*env)->CallVoidMethod(env, mainObject, mainID, mainArgs);\n+    return 1;\n+ }\n+\n+int\n+invokeStaticMainWithoutArgs(JNIEnv *env, jclass mainClass) {\n+    jmethodID mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n+                                       \"()V\");\n+    CHECK_EXCEPTION_FAIL();\n+    (*env)->CallStaticVoidMethod(env, mainClass, mainID);\n+    return 1;\n+}\n+\n+int\n+invokeInstanceMainWithoutArgs(JNIEnv *env, jclass mainClass) {\n+    jmethodID constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+    CHECK_EXCEPTION_FAIL();\n+    jobject mainObject = (*env)->NewObject(env, mainClass, constructor);\n+    CHECK_EXCEPTION_NULL_FAIL(mainObject);\n+    jmethodID mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n+                                 \"()V\");\n+    CHECK_EXCEPTION_FAIL();\n+    (*env)->CallVoidMethod(env, mainObject, mainID);\n+    return 1;\n+}\n@@ -407,6 +470,0 @@\n-    jmethodID validateMainMethod;\n-    jobject mainMethod;\n-    jmethodID mainID;\n-    int mainType;\n-    jmethodID constructor;\n-    jobject mainObject;\n@@ -527,30 +584,1 @@\n-    NULL_CHECK_RETURN_VALUE(appClass, -1);\n-\n-    \/*  Get launcher helper class. *\/\n-    helperClass = GetLauncherHelperClass(env);\n-\n-    \/*  Validate and fetch main method from application class. *\/\n-    validateMainMethod = (*env)->GetStaticMethodID(env, helperClass,\n-                                         \"validateMainMethod\",\n-                                         \"(Ljava\/lang\/Class;)Ljava\/lang\/reflect\/Method;\");\n-    CHECK_EXCEPTION_NULL_LEAVE(validateMainMethod);\n-    mainMethod = (*env)->CallStaticObjectMethod(env, helperClass, validateMainMethod, mainClass);\n-    NULL_CHECK_RETURN_VALUE(mainMethod, -1);\n-\n-    \/*\n-     * validateMainMethod ensures that the main method's signature is correct,\n-     * therefore further checking is not required.\n-     *\/\n-#define MAIN_WITHOUT_ARGS 1\n-#define MAIN_NONSTATIC 2\n-\n-    \/*\n-     * getMainType determines whether the main method is static and whether it has a\n-     * String[] argument.\n-     *\/\n-    jmethodID getMainType = (*env)->GetStaticMethodID(env, helperClass,\n-                                                      \"getMainType\",\n-                                                      \"(Ljava\/lang\/reflect\/Method;)I\");\n-    CHECK_EXCEPTION_NULL_LEAVE(getMainType);\n-    mainType = (*env)->CallStaticIntMethod(env, helperClass, getMainType, mainMethod);\n-    CHECK_EXCEPTION_LEAVE(-1);\n+    CHECK_EXCEPTION_NULL_LEAVE(appClass);\n@@ -559,6 +587,2 @@\n-    if ((mainType & MAIN_WITHOUT_ARGS) == 0) {\n-        mainArgs = CreateApplicationArgs(env, argv, argc);\n-        CHECK_EXCEPTION_NULL_LEAVE(mainArgs);\n-    } else {\n-        mainArgs = NULL;\n-    }\n+    mainArgs = CreateApplicationArgs(env, argv, argc);\n+    CHECK_EXCEPTION_NULL_LEAVE(mainArgs);\n@@ -585,39 +609,6 @@\n-\n-\n-    switch (mainType) {\n-    case 0: {\n-        mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n-                                           \"([Ljava\/lang\/String;)V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-        (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n-        break;\n-        }\n-    case MAIN_WITHOUT_ARGS: {\n-        mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n-                                           \"()V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-        (*env)->CallStaticVoidMethod(env, mainClass, mainID);\n-        break;\n-        }\n-    case MAIN_NONSTATIC: {\n-        constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(constructor);\n-        mainObject = (*env)->NewObject(env, mainClass, constructor);\n-        CHECK_EXCEPTION_NULL_LEAVE(mainObject);\n-        mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n-                                     \"([Ljava\/lang\/String;)V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-        (*env)->CallVoidMethod(env, mainObject, mainID, mainArgs);\n-        break;\n-        }\n-    case MAIN_NONSTATIC | MAIN_WITHOUT_ARGS: {\n-        constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(constructor);\n-        mainObject = (*env)->NewObject(env, mainClass, constructor);\n-        CHECK_EXCEPTION_NULL_LEAVE(mainObject);\n-        mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n-                                     \"()V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-        (*env)->CallVoidMethod(env, mainObject, mainID);\n-        break;\n-        }\n+    if (!invokeStaticMainWithArgs(env, mainClass, mainArgs) &&\n+        !invokeInstanceMainWithArgs(env, mainClass, mainArgs) &&\n+        !invokeStaticMainWithoutArgs(env, mainClass) &&\n+        !invokeInstanceMainWithoutArgs(env, mainClass)) {\n+        ret = 1;\n+        LEAVE();\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":72,"deletions":81,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -4015,1 +4015,1 @@\n-        List<JCTree> topLevelDefs = isImplicitClass ?  construcImplictClass(defs.toList()) : defs.toList();\n+        List<JCTree> topLevelDefs = isImplicitClass ?  constructImplictClass(defs.toList()) : defs.toList();\n@@ -4031,1 +4031,1 @@\n-    private List<JCTree> construcImplictClass(List<JCTree> origDefs) {\n+    private List<JCTree> constructImplictClass(List<JCTree> origDefs) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+compiler\/ciReplay\/TestInliningProtectionDomain.java 8319841 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -544,1 +544,1 @@\n-        tr.contains(\"Error: Main method must return a value of type void in class Foo\");\n+        tr.contains(\"Error: Main method not found in class Foo\");\n@@ -549,1 +549,1 @@\n-        tr.contains(\"Error: Main method must return a value of type void in class Foo\");\n+        tr.contains(\"Error: Main method not found in class Foo\");\n@@ -570,1 +570,1 @@\n-        tr.contains(\"Error: Main method is not static in class Foo\");\n+        tr.contains(\"Error: Main method not found in class Foo\");\n@@ -575,1 +575,1 @@\n-        tr.contains(\"Error: Main method is not static in class Foo\");\n+        tr.contains(\"Error: Main method not found in class Foo\");\n","filename":"test\/jdk\/tools\/launcher\/Arrrghs.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-            \/\/ static dominating instance\n+            \/\/ instance dominating instance\n@@ -49,1 +49,0 @@\n-                    throw new AssertionError();\n@@ -52,0 +51,1 @@\n+                    throw new AssertionError();\n@@ -84,1 +84,1 @@\n-            \/\/ unnamed class static dominating instance\n+            \/\/ unnamed class dominating instance\n@@ -87,1 +87,0 @@\n-                throw new AssertionError();\n@@ -90,0 +89,1 @@\n+                throw new AssertionError();\n@@ -108,1 +108,1 @@\n-            \/\/ instance main dominating super static\n+            \/\/ instance main with args dominating super\n@@ -112,0 +112,1 @@\n+                    throw new AssertionError();\n@@ -116,1 +117,0 @@\n-                    throw new AssertionError();\n","filename":"test\/jdk\/tools\/launcher\/InstanceMainTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -95,2 +95,2 @@\n-                    .shouldContain(\"Error: Unable to initialize main class \" + MAIN_CLASS + \" in module \" + TEST_MODULE)\n-                    .shouldContain(\"Caused by: java.security.AccessControlException: access denied\")\n+                    .shouldContain(\"Error: Unable to load main class \" + MAIN_CLASS + \" in module \" + TEST_MODULE)\n+                    .shouldContain(\"java.security.AccessControlException\")\n@@ -98,0 +98,1 @@\n+\n","filename":"test\/jdk\/tools\/launcher\/modules\/basic\/LauncherErrors.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}