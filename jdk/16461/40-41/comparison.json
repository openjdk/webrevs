{"files":[{"patch":"@@ -1,217 +1,217 @@\n-\/*\r\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-\/*\r\n- * @test\r\n- * @bug 8306112 8309568\r\n- * @summary Test basic processing of implicitly declared classes.\r\n- * @library \/tools\/javac\/lib\r\n- * @modules java.compiler\r\n- *          jdk.compiler\r\n- * @build   JavacTestingAbstractProcessor TestImplicitClass\r\n- * @compile         -processor TestImplicitClass            --enable-preview --release ${jdk.version}                            Anonymous.java\r\n- * @clean Nameless.java\r\n- * @compile\/process -processor TestImplicitClass -proc:only --enable-preview --release ${jdk.version} -Xprefer:newer -AclassOnly Anonymous Nameless\r\n- *\/\r\n-\r\n-\/\/ The first @compile line processes Anonymous.java and a\r\n-\/\/ Nameless.java class generated using the Filer. Both of those implicitly\r\n-\/\/ declared classes are then compiled down to class files.  The second\r\n-\/\/ @compile line, as directed by -Xprefer:newer, builds and checks the\r\n-\/\/ language model objects constructed from those class files, ignoring\r\n-\/\/ any source files for those types.\r\n-\r\n-import java.lang.annotation.*;\r\n-import java.io.Writer;\r\n-import java.util.List;\r\n-import java.util.Set;\r\n-import javax.annotation.processing.*;\r\n-import javax.lang.model.element.*;\r\n-import javax.lang.model.util.Elements;\r\n-import static javax.lang.model.util.ElementFilter.*;\r\n-import javax.tools.JavaFileObject;\r\n-\r\n-\/**\r\n- * Test annotation processing representation of implicitly classes\r\n- * constructed from either a source file or a class file.\r\n- *\/\r\n-@SuppressWarnings(\"preview\")\r\n-@SupportedOptions(\"classOnly\")\r\n-public class TestImplicitClass extends JavacTestingAbstractProcessor {\r\n-\r\n-    private static int round  = 0;\r\n-    private static int checkedClassesCount = 0;\r\n-    private static boolean classOnly = false;\r\n-\r\n-    public boolean process(Set<? extends TypeElement> annotations,\r\n-                           RoundEnvironment roundEnv) {\r\n-        if (round == 0) {\r\n-            classOnly = options.containsKey(\"classOnly\");\r\n-\r\n-            checkRoots(roundEnv); \/\/ Check any files from the comamnd line\r\n-\r\n-            \/\/ Don't generate any files if testing pre-existing class files\r\n-            if (!classOnly) {\r\n-                generateImplicitClass();\r\n-            }\r\n-        } else {\r\n-            if (!roundEnv.processingOver()) { \/\/ Test generated file(s)\r\n-                checkRoots(roundEnv);\r\n-            } else { \/\/ Should have checked at least one class before processing is over\r\n-                if (checkedClassesCount == 0) {\r\n-                    messager.printError(\"No implicitly declared classes checked.\");\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        round++;\r\n-        return true;\r\n-    }\r\n-\r\n-    private void checkRoots(RoundEnvironment roundEnv) {\r\n-        int checks = 0;\r\n-        for (TypeElement type : typesIn(roundEnv.getRootElements())) {\r\n-            checks++;\r\n-            checkUnnamedClassProperties(type);\r\n-        }\r\n-        if (checks == 0) {\r\n-            messager.printError(\"No checking done of any candidate implicitly declared classes.\");\r\n-        }\r\n-    }\r\n-\r\n-    private void generateImplicitClass() {\r\n-        try {\r\n-            String unnamedSource = \"\"\"\r\n-            void main() {\r\n-                System.out.println(\"Nameless, but not voiceless.\");\r\n-            }\r\n-            \"\"\";\r\n-\r\n-            JavaFileObject outputFile = processingEnv.getFiler().createSourceFile(\"Nameless\");\r\n-            try(Writer w = outputFile.openWriter()) {\r\n-                w.append(unnamedSource);\r\n-            }\r\n-        } catch (java.io.IOException ioe) {\r\n-            throw new RuntimeException(ioe);\r\n-        }\r\n-    }\r\n-\r\n-    \/*\r\n-     * From JEP 445 JLS changes:\r\n-     *\r\n-     * \"An implicitly declared class compilation unit implicitly declares a class that\r\n-     * satisfies the following properties:\r\n-     * It is always a top level class.\r\n-     * It is never abstract (8.1.1.1).\r\n-     * It is always final (8.1.1.2).\r\n-     * It is always a member of an unnamed package (7.4.2) and has package access.\r\n-     * Its direct superclass type is always Object (8.1.4).\r\n-     * It never has any direct superinterface types (8.1.5).\r\n-     *\r\n-     * The body of the class contains every ClassMemberDeclaration\r\n-     * from the implicitly declared class compilation unit. It is not possible for\r\n-     * an implicitly declared class compilation unit to declare an instance\r\n-     * initializer, static initializer, or constructor.\r\n-     *\r\n-     * It has an implicitly declared default constructor (8.8.9).\r\n-     * All members of this class, including any implicitly declared\r\n-     * members, are subject to the usual rules for member declarations\r\n-     * in a class.\r\n-     *\r\n-     * It is a compile-time error if this class does not declare a candidate main method (12.1.4).\r\n-     *\/\r\n-    void checkUnnamedClassProperties(TypeElement implicitClass) {\r\n-        checkedClassesCount++;\r\n-        Name expectedName = implicitClass.getSimpleName();\r\n-\r\n-        System.out.println(\"Checking \" + expectedName);\r\n-\r\n-        if (implicitClass.getNestingKind() != NestingKind.TOP_LEVEL) {\r\n-            messager.printError(\"Implicitly declared class is not top-level.\", implicitClass);\r\n-        }\r\n-\r\n-        if (!implicitClass.getQualifiedName().equals(expectedName)) {\r\n-            messager.printError(\"Implicitly declared class qualified name does not match simple name.\", implicitClass);\r\n-        }\r\n-\r\n-        Name binaryName = elements.getBinaryName(implicitClass);\r\n-        if (!expectedName.equals(binaryName)) {\r\n-            messager.printError(\"Implicitly declared class has unexpected binary name\" + binaryName + \".\", implicitClass);\r\n-        }\r\n-\r\n-        if (implicitClass.getModifiers().contains(Modifier.ABSTRACT)) {\r\n-            messager.printError(\"Implicitly declared class is abstract.\", implicitClass);\r\n-        }\r\n-\r\n-        if (!implicitClass.getModifiers().contains(Modifier.FINAL)) {\r\n-            messager.printError(\"Implicitly declared class is _not_ final.\", implicitClass);\r\n-        }\r\n-\r\n-        if (!elements.getPackageOf(implicitClass).isUnnamed()) {\r\n-            messager.printError(\"Implicitly declared class is _not_ in an unnamed package.\", implicitClass);\r\n-        }\r\n-\r\n-        if (implicitClass.getModifiers().contains(Modifier.PUBLIC)  ||\r\n-            implicitClass.getModifiers().contains(Modifier.PRIVATE) ||\r\n-            implicitClass.getModifiers().contains(Modifier.PROTECTED)) {\r\n-            messager.printError(\"Implicitly declared class does _not_ have package access.\", implicitClass);\r\n-        }\r\n-\r\n-        if ( !types.isSameType(implicitClass.getSuperclass(),\r\n-                               elements.getTypeElement(\"java.lang.Object\").asType())) {\r\n-            messager.printError(\"Implicitly declared class does _not_ have java.lang.Object as a superclass.\", implicitClass);\r\n-        }\r\n-\r\n-        if (!implicitClass.getInterfaces().isEmpty()) {\r\n-            messager.printError(\"Implicitly declared class has superinterfaces.\", implicitClass);\r\n-        }\r\n-\r\n-        List<ExecutableElement> ctors = constructorsIn(implicitClass.getEnclosedElements());\r\n-        if (ctors.size() != 1 ) {\r\n-            messager.printError(\"Did not find exactly one constructor\", implicitClass);\r\n-        }\r\n-\r\n-        if (!classOnly) {\r\n-            \/\/ Mandated-ness of default constructors not preserved in class files\r\n-            ExecutableElement ctor = ctors.getFirst();\r\n-            if (elements.getOrigin(ctor) != Elements.Origin.MANDATED) {\r\n-                messager.printError(\"Constructor was not marked as mandated\", ctor);\r\n-            }\r\n-        }\r\n-\r\n-        List<ExecutableElement> methods = methodsIn(implicitClass.getEnclosedElements());\r\n-        \/\/ Just look for a method named \"main\"; don't check the other details.\r\n-        boolean mainFound = false;\r\n-        Name mainName = elements.getName(\"main\");\r\n-        for (var method : methods) {\r\n-            if (method.getSimpleName().equals(mainName)) {\r\n-                mainFound = true;\r\n-                break;\r\n-            }\r\n-        }\r\n-\r\n-        if (!mainFound) {\r\n-            messager.printError(\"No main method found\", implicitClass);\r\n-        }\r\n-    }\r\n-}\r\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8306112 8309568\n+ * @summary Test basic processing of implicitly declared classes.\n+ * @library \/tools\/javac\/lib\n+ * @modules java.compiler\n+ *          jdk.compiler\n+ * @build   JavacTestingAbstractProcessor TestImplicitClass\n+ * @compile         -processor TestImplicitClass            --enable-preview --release ${jdk.version}                            Anonymous.java\n+ * @clean Nameless.java\n+ * @compile\/process -processor TestImplicitClass -proc:only --enable-preview --release ${jdk.version} -Xprefer:newer -AclassOnly Anonymous Nameless\n+ *\/\n+\n+\/\/ The first @compile line processes Anonymous.java and a\n+\/\/ Nameless.java class generated using the Filer. Both of those implicitly\n+\/\/ declared classes are then compiled down to class files.  The second\n+\/\/ @compile line, as directed by -Xprefer:newer, builds and checks the\n+\/\/ language model objects constructed from those class files, ignoring\n+\/\/ any source files for those types.\n+\n+import java.lang.annotation.*;\n+import java.io.Writer;\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.Elements;\n+import static javax.lang.model.util.ElementFilter.*;\n+import javax.tools.JavaFileObject;\n+\n+\/**\n+ * Test annotation processing representation of implicitly classes\n+ * constructed from either a source file or a class file.\n+ *\/\n+@SuppressWarnings(\"preview\")\n+@SupportedOptions(\"classOnly\")\n+public class TestImplicitClass extends JavacTestingAbstractProcessor {\n+\n+    private static int round  = 0;\n+    private static int checkedClassesCount = 0;\n+    private static boolean classOnly = false;\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (round == 0) {\n+            classOnly = options.containsKey(\"classOnly\");\n+\n+            checkRoots(roundEnv); \/\/ Check any files from the comamnd line\n+\n+            \/\/ Don't generate any files if testing pre-existing class files\n+            if (!classOnly) {\n+                generateImplicitClass();\n+            }\n+        } else {\n+            if (!roundEnv.processingOver()) { \/\/ Test generated file(s)\n+                checkRoots(roundEnv);\n+            } else { \/\/ Should have checked at least one class before processing is over\n+                if (checkedClassesCount == 0) {\n+                    messager.printError(\"No implicitly declared classes checked.\");\n+                }\n+            }\n+        }\n+\n+        round++;\n+        return true;\n+    }\n+\n+    private void checkRoots(RoundEnvironment roundEnv) {\n+        int checks = 0;\n+        for (TypeElement type : typesIn(roundEnv.getRootElements())) {\n+            checks++;\n+            checkUnnamedClassProperties(type);\n+        }\n+        if (checks == 0) {\n+            messager.printError(\"No checking done of any candidate implicitly declared classes.\");\n+        }\n+    }\n+\n+    private void generateImplicitClass() {\n+        try {\n+            String unnamedSource = \"\"\"\n+            void main() {\n+                System.out.println(\"Nameless, but not voiceless.\");\n+            }\n+            \"\"\";\n+\n+            JavaFileObject outputFile = processingEnv.getFiler().createSourceFile(\"Nameless\");\n+            try(Writer w = outputFile.openWriter()) {\n+                w.append(unnamedSource);\n+            }\n+        } catch (java.io.IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    \/*\n+     * From JEP 445 JLS changes:\n+     *\n+     * \"An implicitly declared class compilation unit implicitly declares a class that\n+     * satisfies the following properties:\n+     * It is always a top level class.\n+     * It is never abstract (8.1.1.1).\n+     * It is always final (8.1.1.2).\n+     * It is always a member of an unnamed package (7.4.2) and has package access.\n+     * Its direct superclass type is always Object (8.1.4).\n+     * It never has any direct superinterface types (8.1.5).\n+     *\n+     * The body of the class contains every ClassMemberDeclaration\n+     * from the implicitly declared class compilation unit. It is not possible for\n+     * an implicitly declared class compilation unit to declare an instance\n+     * initializer, static initializer, or constructor.\n+     *\n+     * It has an implicitly declared default constructor (8.8.9).\n+     * All members of this class, including any implicitly declared\n+     * members, are subject to the usual rules for member declarations\n+     * in a class.\n+     *\n+     * It is a compile-time error if this class does not declare a candidate main method (12.1.4).\n+     *\/\n+    void checkUnnamedClassProperties(TypeElement implicitClass) {\n+        checkedClassesCount++;\n+        Name expectedName = implicitClass.getSimpleName();\n+\n+        System.out.println(\"Checking \" + expectedName);\n+\n+        if (implicitClass.getNestingKind() != NestingKind.TOP_LEVEL) {\n+            messager.printError(\"Implicitly declared class is not top-level.\", implicitClass);\n+        }\n+\n+        if (!implicitClass.getQualifiedName().equals(expectedName)) {\n+            messager.printError(\"Implicitly declared class qualified name does not match simple name.\", implicitClass);\n+        }\n+\n+        Name binaryName = elements.getBinaryName(implicitClass);\n+        if (!expectedName.equals(binaryName)) {\n+            messager.printError(\"Implicitly declared class has unexpected binary name\" + binaryName + \".\", implicitClass);\n+        }\n+\n+        if (implicitClass.getModifiers().contains(Modifier.ABSTRACT)) {\n+            messager.printError(\"Implicitly declared class is abstract.\", implicitClass);\n+        }\n+\n+        if (!implicitClass.getModifiers().contains(Modifier.FINAL)) {\n+            messager.printError(\"Implicitly declared class is _not_ final.\", implicitClass);\n+        }\n+\n+        if (!elements.getPackageOf(implicitClass).isUnnamed()) {\n+            messager.printError(\"Implicitly declared class is _not_ in an unnamed package.\", implicitClass);\n+        }\n+\n+        if (implicitClass.getModifiers().contains(Modifier.PUBLIC)  ||\n+            implicitClass.getModifiers().contains(Modifier.PRIVATE) ||\n+            implicitClass.getModifiers().contains(Modifier.PROTECTED)) {\n+            messager.printError(\"Implicitly declared class does _not_ have package access.\", implicitClass);\n+        }\n+\n+        if ( !types.isSameType(implicitClass.getSuperclass(),\n+                               elements.getTypeElement(\"java.lang.Object\").asType())) {\n+            messager.printError(\"Implicitly declared class does _not_ have java.lang.Object as a superclass.\", implicitClass);\n+        }\n+\n+        if (!implicitClass.getInterfaces().isEmpty()) {\n+            messager.printError(\"Implicitly declared class has superinterfaces.\", implicitClass);\n+        }\n+\n+        List<ExecutableElement> ctors = constructorsIn(implicitClass.getEnclosedElements());\n+        if (ctors.size() != 1 ) {\n+            messager.printError(\"Did not find exactly one constructor\", implicitClass);\n+        }\n+\n+        if (!classOnly) {\n+            \/\/ Mandated-ness of default constructors not preserved in class files\n+            ExecutableElement ctor = ctors.getFirst();\n+            if (elements.getOrigin(ctor) != Elements.Origin.MANDATED) {\n+                messager.printError(\"Constructor was not marked as mandated\", ctor);\n+            }\n+        }\n+\n+        List<ExecutableElement> methods = methodsIn(implicitClass.getEnclosedElements());\n+        \/\/ Just look for a method named \"main\"; don't check the other details.\n+        boolean mainFound = false;\n+        Name mainName = elements.getName(\"main\");\n+        for (var method : methods) {\n+            if (method.getSimpleName().equals(mainName)) {\n+                mainFound = true;\n+                break;\n+            }\n+        }\n+\n+        if (!mainFound) {\n+            messager.printError(\"No main method found\", implicitClass);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestImplicitClass.java","additions":217,"deletions":217,"binary":false,"changes":434,"status":"modified"}]}