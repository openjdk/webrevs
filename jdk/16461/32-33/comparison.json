{"files":[{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- import java.lang.reflect.Method;\n-\n-\/**\n- * @test\n- * @bug 8320255\n- * @enablePreview\n- * @summary Verify Class::findMainMethod handles expected variations.\n- *\/\n-\n- public class FindMainMethod {\n-    private static boolean hasErrors = false;\n-\n-    public static void main(String [] args) {\n-        foundMain(FindMainMethod.class);\n-        noMain(A.class);\n-        foundMain(B.class);\n-        foundMain(C.class);\n-        foundMain(D.class);\n-        foundMain(E.class);\n-        foundMain(F.class);\n-        foundMain(G.class);\n-        foundMain(H.class);\n-        foundMain(I.class);\n-        noMain(J.class);\n-        noMain(K.class);\n-        noMain(L.class);\n-        noMain(M.class);\n-        foundMain(N.class);\n-        foundMain(O.class);\n-        foundMain(P.class);\n-        foundMain(Q.class);\n-        foundMain(Record.class);\n-        foundMain(Color.class);\n-        foundMain(Root.class, Super.class);\n-        foundMain(RootStatic.class, SuperStatic.class);\n-        foundMain(Interface.class);\n-        foundMain(RootInterface.class, Interface.class);\n-        oneArg(ChooseOne.class);\n-        oneArg(InheritOne.class);\n-        oneArg(ImplementOne.class);\n-\n-        if (hasErrors) {\n-            throw new RuntimeException(\"Has Errors\");\n-        }\n-    }\n-\n-    private static void foundMain(Class<?> root) {\n-        foundMain(root, root);\n-    }\n-\n-    private static void foundMain(Class<?> root, Class<?> declared) {\n-        Method main = root.findMainMethod();\n-        test(main != null, \"No main found in \" + root);\n-        test(main != null && main.getDeclaringClass() == declared, \"Wrong main found for \" + root);\n-    }\n-\n-    private static void noMain(Class<?> root) {\n-        Method main = root.findMainMethod();\n-        test(main == null, \"Main in wrong class from \" + root);\n-    }\n-\n-    private static void oneArg(Class<?> root) {\n-        Method main = root.findMainMethod();\n-        test(main.getParameterCount() == 1, \"Main found with no arguments in \" + root);\n-    }\n-\n-\n-    private static void test(boolean test, String message) {\n-        if (!test) {\n-            System.err.println(\"Failure: \" + message);\n-            hasErrors = true;\n-        }\n-    }\n-}\n-\n-class A {  }\n-class B { public static void main(String [] args) {} }\n-class C { public static void main() {} }\n-class D { public void main(String [] args) {} }\n-class E { public void main() {} }\n-class F { protected static void main(String [] args) {} }\n-class G { protected static void main() {} }\n-class H { protected void main(String [] args) {} }\n-class I { protected void main() {} }\n-class J { private static void main(String [] args) {} }\n-class K { private static void main() {} }\n-class L { private void main(String [] args) {} }\n-class M { private void main() {} }\n-class N { static void main(String [] args) {} }\n-class O { static void main() {} }\n-class P { void main(String [] args) {} }\n-class Q { void main() {} }\n-\n-record Record(int a) { public static void main(String [] args) {} }\n-enum Color { RED, GREEN, BLUE; public static void main(String [] args) {} }\n-\n-class Super { public void main(String [] args) {} }\n-class Root extends Super {}\n-\n-class SuperStatic { public static void main(String [] args) {} }\n-class RootStatic extends SuperStatic {}\n-\n-interface Interface { default void main(String [] args) {} }\n-class RootInterface implements Interface {}\n-\n-class ChooseOne { public static void main(String [] args) {} public static void main() {} }\n-class InheritOne extends SuperStatic { public static void main() {} }\n-class ImplementOne implements Interface { public static void main() {} }\n","filename":"test\/jdk\/java\/lang\/Class\/findMainMethod\/FindMainMethod.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"}]}