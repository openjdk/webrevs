{"files":[{"patch":"@@ -35,1 +35,1 @@\n-     * @param method    method to test\n+     * @param method  method to test\n@@ -38,2 +38,4 @@\n-        return !Modifier.isPrivate(method.getModifiers()) &&\n-                method.getReturnType() == void.class;\n+        int mods = method.getModifiers();\n+        return !Modifier.isPrivate(mods) &&\n+               !Modifier.isAbstract(mods) &&\n+               method.getReturnType() == void.class;\n@@ -43,1 +45,1 @@\n-     * Search up the superclass hierarchy for a qualified main method.\n+     * {@return a public main method accessable from the specified class}\n@@ -47,2 +49,0 @@\n-     *\n-     * @return main method meeting requirements\n@@ -50,1 +50,1 @@\n-    private static Method findMainMethod(Class<?> mainClass, boolean noArgs) {\n+    private static Method getPublicMain(Class<?> mainClass, boolean noArgs) {\n@@ -60,1 +60,23 @@\n-            \/\/ pass through\n+            \/\/ fall through\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * {@return a non-private main method declared in the specified class}\n+     *\n+     * @param mainClass    Main class to start search from.\n+     * @param noArgs       true if no argument otherwise expects one String[] argument\n+     *\/\n+    private static Method getNonPrivateMain(Class<?> mainClass, boolean noArgs) {\n+        try {\n+            \/\/ Search public methods\n+            Method mainMethod = noArgs ? mainClass.getDeclaredMethod(\"main\")\n+                                       : mainClass.getDeclaredMethod(\"main\", String[].class);\n+\n+            if (isMainMethod(mainMethod)) {\n+                return mainMethod;\n+            }\n+        } catch (NoSuchMethodException ex) {\n+            \/\/ fall through\n@@ -63,1 +85,19 @@\n-        \/\/ Search all methods\n+        return null;\n+    }\n+\n+    \/**\n+     * Search up the superclass hierarchy for a qualified main method.\n+     *\n+     * @param mainClass    Main class to start search from.\n+     * @param noArgs       true if no argument otherwise expects one String[] argument\n+     *\n+     * @return main method meeting requirements\n+     *\/\n+    private static Method findMainMethod(Class<?> mainClass, boolean noArgs) {\n+        Method mainMethod = getPublicMain(mainClass, noArgs);\n+\n+        if (mainMethod != null) {\n+            return mainMethod;\n+        }\n+\n+        \/\/ Search up hierarchy\n@@ -65,6 +105,12 @@\n-              mainClass != null && mainClass != Object.class;\n-              mainClass = mainClass.getSuperclass()) {\n-            try {\n-                Method mainMethod = noArgs ? mainClass.getDeclaredMethod(\"main\")\n-                                           : mainClass.getDeclaredMethod(\"main\", String[].class);\n-                if (isMainMethod(mainMethod)) {\n+             mainClass != null && mainClass != Object.class;\n+             mainClass = mainClass.getSuperclass()) {\n+            mainMethod = getNonPrivateMain(mainClass, noArgs);\n+\n+            if (mainMethod != null) {\n+                return mainMethod;\n+            }\n+\n+            for (Class<?> interf : mainClass.getInterfaces()) {\n+                mainMethod = getNonPrivateMain(mainClass, noArgs);\n+\n+                if (mainMethod != null) {\n@@ -73,2 +119,0 @@\n-            } catch (NoSuchMethodException ex) {\n-                \/\/ pass through\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MainMethodFinder.java","additions":61,"deletions":17,"binary":false,"changes":78,"status":"modified"}]}