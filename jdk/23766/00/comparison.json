{"files":[{"patch":"@@ -2105,1 +2105,1 @@\n-  __ atomic_addw(noreg, 1, r10);\n+  __ atomic_add(noreg, 1, r10);\n@@ -2153,1 +2153,1 @@\n-  __ cmpw(rscratch1, rscratch2);\n+  __ cmp(rscratch1, rscratch2);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2319,1 +2319,1 @@\n-  if (TraceBytecodesAt > 0 && TraceBytecodesAt < max_intx) {\n+  if (TraceBytecodesAt > 0) {\n@@ -2323,1 +2323,1 @@\n-    __ lwa(R12_scratch2, offs2, R12_scratch2);\n+    __ ld(R12_scratch2, offs2, R12_scratch2);\n@@ -2337,1 +2337,1 @@\n-  if (TraceBytecodesAt > 0 && TraceBytecodesAt < max_intx) {\n+  if (TraceBytecodesAt > 0) {\n@@ -2347,1 +2347,1 @@\n-  __ lwz(R12_scratch2, offs, R11_scratch1);\n+  __ ld(R12_scratch2, offs, R11_scratch1);\n@@ -2349,1 +2349,1 @@\n-  __ stw(R12_scratch2, offs, R11_scratch1);\n+  __ std(R12_scratch2, offs, R11_scratch1);\n@@ -2398,1 +2398,1 @@\n-  __ lwa(R12_scratch2, offs2, R12_scratch2);\n+  __ ld(R12_scratch2, offs2, R12_scratch2);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1849,1 +1849,1 @@\n-  __ atomic_addw(noreg, 1, x7);\n+  __ atomic_add(noreg, 1, x7);\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2320,1 +2320,1 @@\n-    __ load_sized_value(Z_tmp_1, Address(Z_tmp_1), 4, false \/*signed*\/);\n+    __ load_sized_value(Z_tmp_1, Address(Z_tmp_1), 8, false \/*signed*\/);\n@@ -2350,1 +2350,1 @@\n-  __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);\n+  __ add2mem_64(Address(Z_R1_scratch), 1, Z_R0_scratch);\n@@ -2397,1 +2397,1 @@\n-  __ load_sized_value(Z_tmp_1, Address(Z_tmp_1), 4, false \/*signed*\/);\n+  __ load_sized_value(Z_tmp_1, Address(Z_tmp_1), 8, false \/*signed*\/);\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1877,0 +1877,1 @@\n+  #ifndef _LP64\n@@ -1878,0 +1879,3 @@\n+  #else\n+  __ incrementq(ExternalAddress((address) &BytecodeCounter::_counter_value), rscratch1);\n+  #endif\n@@ -1917,0 +1921,1 @@\n+  #ifndef _LP64\n@@ -1920,0 +1925,4 @@\n+  #else\n+  __ mov64(rscratch1, StopInterpreterAt);\n+  __ cmp64(rscratch1, ExternalAddress((address) &BytecodeCounter::_counter_value), rscratch2);\n+  #endif\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-int   BytecodeCounter::_counter_value = 0;\n+uintx BytecodeCounter::_counter_value = 0;\n@@ -58,1 +58,1 @@\n-    \"%d bytecodes executed in %.1fs (%.3fMHz)\",\n+    \"%zu bytecodes executed in %.1fs (%.3fMHz)\",\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeHistogram.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  NOT_PRODUCT(static int   _counter_value;)\n+  NOT_PRODUCT(static uintx _counter_value;)\n@@ -46,1 +46,1 @@\n-  static int    counter_value()            PRODUCT_RETURN0 NOT_PRODUCT({ return _counter_value; });\n+  static uintx  counter_value()            PRODUCT_RETURN0 NOT_PRODUCT({ return _counter_value; });\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeHistogram.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-        st->print(\"%8d  %4d  \" INTPTR_FORMAT \" \" INTPTR_FORMAT \" %s\",\n+        st->print(\"%8zu  %4d  \" INTPTR_FORMAT \" \" INTPTR_FORMAT \" %s\",\n@@ -135,1 +135,1 @@\n-        st->print(\"%8d  %4d  %s\",\n+        st->print(\"%8zu  %4d  %s\",\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1559,1 +1559,1 @@\n-  develop(intx, StopInterpreterAt, 0,                                       \\\n+  develop(uintx, StopInterpreterAt, 0,                                      \\\n@@ -1562,1 +1562,1 @@\n-  develop(intx, TraceBytecodesAt, 0,                                        \\\n+  develop(uintx, TraceBytecodesAt, 0,                                       \\\n@@ -1565,1 +1565,1 @@\n-  develop(intx, TraceBytecodesStopAt, 0,                                    \\\n+  develop(uintx, TraceBytecodesStopAt, 0,                                   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-    tty->print_cr(\"[BytecodeCounter::counter_value = %d]\", BytecodeCounter::counter_value());\n+    tty->print_cr(\"[BytecodeCounter::counter_value = %zu]\", BytecodeCounter::counter_value());\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350642\n+ * @requires vm.debug & vm.bits == \"64\"\n+ * @summary Test the output for CountBytecodes and validate that the counter\n+ *          does not overflow for more than 2^32 bytecodes counted.\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=300 CountBytecodesTest\n+ *\/\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class CountBytecodesTest {\n+    private final static long iterations = (1L << 32) \/ 9;\n+\n+    public static void main(String args[]) throws Exception {\n+        if (args.length == 1 && args[0].equals(\"test\")) {\n+            for (long i = 0; i < iterations; i++) {\n+                \/\/ Just iterating is enough to execute and count bytecodes.\n+                \/\/ According to javap -c this loop translates to the following 9 bytecodes:\n+                \/\/ 19: lload_1\n+                \/\/ 20: ldc2_w        #17\n+                \/\/ 23: lcmp\n+                \/\/ 24: ifge          34\n+                \/\/ 27: lload_1\n+                \/\/ 28: lconst_1\n+                \/\/ 29: ladd\n+                \/\/ 30: lstore_1\n+                \/\/ 31: goto          19\n+                \/\/\n+                \/\/ Thus we can divide the 2^32 by 9 to set the minimum number of iterations\n+                \/\/ while maintaining execution of more than 2^32 bytecodes.\n+            }\n+        } else {\n+            OutputAnalyzer output = ProcessTools.executeTestJava(\"-Xint\", \"-XX:+CountBytecodes\", \"CountBytecodesTest\", \"test\");\n+            output.shouldHaveExitValue(0);\n+\n+            \/\/ Output format: [BytecodeCounter::counter_value = 38676232802]\n+            output.stdoutShouldContain(\"BytecodeCounter::counter_value\");\n+            String bytecodesStr = output.firstMatch(\"BytecodeCounter::counter_value\\s*=\\s*(\\\\d+)\", 1);\n+            long bytecodes = Long.parseLong(bytecodesStr);\n+\n+            System.out.println(\"Executed bytecodes: \" + bytecodes);\n+\n+            Asserts.assertGTE(bytecodes, 4294967296L);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/CountBytecodesTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"}]}