{"files":[{"patch":"@@ -1722,1 +1722,1 @@\n-  create_assertion_predicates_at_loop(peeled_loop_head, remaining_loop_head, node_in_original_loop_body, false);\n+  create_assertion_predicates_at_loop(peeled_loop_head, remaining_loop_head, node_in_original_loop_body, true);\n@@ -1742,0 +1742,3 @@\n+\/\/\n+\/\/ The post loop is cloned before the pre loop. Do not kill the old Template Assertion Predicates, yet. We need to clone\n+\/\/ from them when creating the pre loop. Only then we can kill them.\n@@ -1752,1 +1755,1 @@\n-                                                         const bool clone_template) {\n+                                                         const bool kill_old_template) {\n@@ -1754,1 +1757,1 @@\n-                                                                       clone_template);\n+                                                                       kill_old_template);\n@@ -1763,1 +1766,1 @@\n-                                                                      bool clone_template) {\n+                                                                      const bool kill_old_template) {\n@@ -1767,1 +1770,1 @@\n-  create_assertion_predicates_at_loop(source_loop_head, target_loop_head, _node_in_loop_body, clone_template);\n+  create_assertion_predicates_at_loop(source_loop_head, target_loop_head, _node_in_loop_body, kill_old_template);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -996,1 +996,1 @@\n-                                           const NodeInLoopBody& _node_in_loop_body, bool clone_template);\n+                                           const NodeInLoopBody& _node_in_loop_body, bool kill_old_template);\n@@ -999,1 +999,2 @@\n-                                                        const NodeInLoopBody& _node_in_loop_body, bool clone_template);\n+                                                        const NodeInLoopBody& _node_in_loop_body,\n+                                                        bool kill_old_template);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -963,1 +963,1 @@\n-                                                                   const bool clone_template)\n+                                                                   bool kill_old_template)\n@@ -970,1 +970,0 @@\n-      _has_hoisted_check_parse_predicates(false),\n@@ -972,11 +971,1 @@\n-      _clone_template(clone_template) {}\n-\n-\/\/ Keep track of whether we are in the correct Predicate Block where Template Assertion Predicates can be found.\n-\/\/ The PredicateIterator will always start at the loop entry and first visits the Loop Limit Check Predicate Block.\n-void CreateAssertionPredicatesVisitor::visit(const ParsePredicate& parse_predicate) {\n-  Deoptimization::DeoptReason deopt_reason = parse_predicate.head()->deopt_reason();\n-  if (deopt_reason == Deoptimization::Reason_predicate ||\n-      deopt_reason == Deoptimization::Reason_profile_predicate) {\n-    _has_hoisted_check_parse_predicates = true;\n-  }\n-}\n+      _kill_old_template(kill_old_template) {}\n@@ -984,0 +973,1 @@\n+\/\/ Clone Template Assertion Predicate and create an Initialized Assertion Predicate from it.\n@@ -985,13 +975,6 @@\n-  if (!_has_hoisted_check_parse_predicates) {\n-    \/\/ Only process if we are in the correct Predicate Block.\n-    return;\n-  }\n-  if (_clone_template) {\n-    TemplateAssertionPredicate cloned_template_assertion_predicate =\n-        clone_template_and_replace_init_input(template_assertion_predicate);\n-    initialize_from_template(template_assertion_predicate, cloned_template_assertion_predicate.tail());\n-    _current_predicate_chain_head = cloned_template_assertion_predicate.head();\n-  } else {\n-    InitializedAssertionPredicate initialized_assertion_predicate =\n-        initialize_from_template(template_assertion_predicate, _old_target_loop_entry);\n-    _current_predicate_chain_head = initialized_assertion_predicate.head();\n+  TemplateAssertionPredicate cloned_template_assertion_predicate =\n+      clone_template_and_replace_init_input(template_assertion_predicate);\n+  initialize_from_template(template_assertion_predicate, cloned_template_assertion_predicate.tail());\n+  _current_predicate_chain_head = cloned_template_assertion_predicate.head();\n+  if (_kill_old_template) {\n+    template_assertion_predicate.kill(_phase->igvn());\n@@ -1113,2 +1096,1 @@\n-      _phase(phase),\n-      _has_hoisted_check_parse_predicates(false) {}\n+      _phase(phase) {}\n@@ -1119,6 +1101,0 @@\n-  Deoptimization::DeoptReason deopt_reason = parse_predicate.head()->deopt_reason();\n-  if (deopt_reason == Deoptimization::Reason_predicate ||\n-      deopt_reason == Deoptimization::Reason_profile_predicate) {\n-    _has_hoisted_check_parse_predicates = true;\n-  }\n-\n@@ -1133,5 +1109,0 @@\n-  if (!_has_hoisted_check_parse_predicates) {\n-    \/\/ Only process if we are in the correct Predicate Block.\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":10,"deletions":39,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1094,1 +1094,0 @@\n-  bool _has_hoisted_check_parse_predicates;\n@@ -1096,1 +1095,1 @@\n-  const bool _clone_template;\n+  const bool _kill_old_template;\n@@ -1107,1 +1106,1 @@\n-                                   const NodeInLoopBody& node_in_loop_body, bool clone_template);\n+                                   const NodeInLoopBody& node_in_loop_body, bool kill_old_template);\n@@ -1112,1 +1111,0 @@\n-  void visit(const ParsePredicate& parse_predicate) override;\n@@ -1181,1 +1179,0 @@\n-  bool _has_hoisted_check_parse_predicates;\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8288981 8350579\n+ * @bug 8288981 8350579 8350577\n@@ -34,3 +34,3 @@\n- *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n- *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n- *                   compiler.predicates.TestAssertionPredicates Xbatch\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   compiler.predicates.assertion.TestAssertionPredicates Xbatch\n@@ -41,2 +41,1 @@\n- * @bug 8288981 8350579\n-\n+ * @bug 8288981 8350579 8350577\n@@ -45,3 +44,3 @@\n- *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n- *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n- *                   compiler.predicates.TestAssertionPredicates NoTieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   compiler.predicates.assertion.TestAssertionPredicates NoTieredCompilation\n@@ -52,1 +51,1 @@\n- * @bug 8288981 8350579\n+ * @bug 8288981 8350579 8350577\n@@ -55,4 +54,15 @@\n- *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n- *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n- *                   -XX:CompileCommand=inline,compiler.predicates.TestAssertionPredicates::inline\n- *                   compiler.predicates.TestAssertionPredicates Xcomp\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=inline,compiler.predicates.assertion.TestAssertionPredicates::inline\n+ *                   compiler.predicates.assertion.TestAssertionPredicates Xcomp\n+ *\/\n+\n+\/*\n+ * @test id=XcompNoTiered\n+ * @bug 8288981 8350577\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=inline,compiler.predicates.assertion.TestAssertionPredicates::inline\n+ *                   compiler.predicates.assertion.TestAssertionPredicates XcompNoTiered\n@@ -63,1 +73,1 @@\n- * @bug 8288981 8350579\n+ * @bug 8288981 8350579 8350577\n@@ -67,3 +77,68 @@\n- *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n- *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n- *                   compiler.predicates.TestAssertionPredicates LoopMaxUnroll0\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   compiler.predicates.assertion.TestAssertionPredicates LoopMaxUnroll0\n+ *\/\n+\n+\/*\n+ * @test id=LoopMaxUnroll2\n+ * @bug 8288981 8350577\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xcomp -XX:LoopMaxUnroll=2\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   compiler.predicates.assertion.TestAssertionPredicates LoopMaxUnroll2\n+ *\/\n+\n+\/*\n+ * @test id=LoopUnrollLimit40\n+ * @bug 8288981 8350577\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xcomp -XX:LoopUnrollLimit=40\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   compiler.predicates.assertion.TestAssertionPredicates LoopUnrollLimit40\n+ *\/\n+\n+\/*\n+ * @test id=LoopUnrollLimit150\n+ * @bug 8288981 8350577\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xcomp -XX:LoopUnrollLimit=150\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   compiler.predicates.assertion.TestAssertionPredicates LoopUnrollLimit150\n+ *\/\n+\n+\/*\n+ * @test id=UseProfiledLoopPredicateFalse\n+ * @bug 8288981 8350577\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xcomp -XX:-UseProfiledLoopPredicate\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   compiler.predicates.assertion.TestAssertionPredicates NoProfiledLoopPredicate\n+ *\/\n+\n+\/*\n+ * @test id=DataUpdate\n+ * @key randomness\n+ * @bug 8288981 8350577\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   compiler.predicates.assertion.TestAssertionPredicates DataUpdate\n+ *\/\n+\n+\/*\n+ * @test id=CloneDown\n+ * @bug 8288981 8350577\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xcomp -XX:-BlockLayoutByFrequency -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   compiler.predicates.assertion.TestAssertionPredicates CloneDown\n@@ -74,1 +149,2 @@\n- * @bug 8288981 8350579\n+ * @key randomness\n+ * @bug 8288981 8350579 8350577\n@@ -77,3 +153,3 @@\n- *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n- *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n- *                   compiler.predicates.TestAssertionPredicates Stress\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   compiler.predicates.assertion.TestAssertionPredicates Stress\n@@ -84,1 +160,2 @@\n- * @bug 8288981 8350579\n+ * @key randomness\n+ * @bug 8288981 8350579 8350577\n@@ -87,3 +164,3 @@\n- *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n- *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n- *                   compiler.predicates.TestAssertionPredicates Stress\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   compiler.predicates.assertion.TestAssertionPredicates Stress\n@@ -94,1 +171,1 @@\n- * @bug 8288981 8350579\n+ * @bug 8288981 8350579 8350577\n@@ -98,3 +175,3 @@\n- *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n- *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n- *                   compiler.predicates.TestAssertionPredicates NoLoopPredication\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   compiler.predicates.assertion.TestAssertionPredicates NoLoopPredication\n@@ -105,3 +182,2 @@\n- * @bug 8288981 8350579\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *                    compiler.predicates.TestAssertionPredicates NoFlags\n+ * @bug 8288981 8350579 8350577\n+ * @run main compiler.predicates.assertion.TestAssertionPredicates NoFlags\n@@ -110,1 +186,1 @@\n-package compiler.predicates;\n+package compiler.predicates.assertion;\n@@ -117,0 +193,2 @@\n+    static int[] iArrNull = null;\n+    static int[][] iArr2D = new int[10][10];\n@@ -118,0 +196,2 @@\n+    static float[] fArr = new float[10];\n+    static float[][] fArr2D = new float[10][10];\n@@ -119,1 +199,2 @@\n-    static boolean flag;\n+    static boolean flag, flag2, flagTrue = true;\n+    static boolean flagFalse, flagFalse2;\n@@ -122,0 +203,1 @@\n+    static long lFld, lFldOne = 1;\n@@ -123,0 +205,1 @@\n+    static short sFld;\n@@ -124,0 +207,8 @@\n+    static byte byFld;\n+    volatile byte byFldVol;\n+\n+    static class Foo {\n+        int iFld;\n+    }\n+\n+    static Foo foo = new Foo();\n@@ -143,0 +234,1 @@\n+            case \"NoProfiledLoopPredicate\" -> testWithPartialPeelingFirst();\n@@ -144,0 +236,6 @@\n+                testPeeling();\n+                testPeelingTwice();\n+                testPeelingThreeTimes();\n+                testUnswitchingThenPeeling();\n+                testPeelingThenUnswitchingThenPeeling();\n+                testPeelingThenUnswitchingThenPeelingThenPreMainPost();\n@@ -147,0 +245,10 @@\n+            case \"LoopMaxUnroll2\" -> {\n+                testPeelMainLoopAfterUnrollingThenPreMainPost();\n+                testPeelMainLoopAfterUnrolling2();\n+            }\n+            case \"LoopUnrollLimit40\" -> testPeelMainLoopAfterUnrollingThenPreMainPostThenUnrolling();\n+            case \"LoopUnrollLimit150\" -> {\n+                testUnrolling8();\n+                testUnrolling16();\n+                testPeelingUnrolling16();\n+            }\n@@ -148,0 +256,5 @@\n+                testPreMainPost();\n+                testUnrolling2();\n+                testUnrolling4();\n+                testPeelingThenPreMainPost();\n+                testUnswitchingThenPeelingThenPreMainPost();\n@@ -149,0 +262,22 @@\n+                test8288981();\n+                test8288941();\n+                testRemovingParsePredicatesThenMissingTemplates();\n+                iFld = -1;\n+                test8292507();\n+                TestAssertionPredicates t = new TestAssertionPredicates();\n+                t.test8296077();\n+                test8308504No2();\n+                test8307131();\n+                test8308392No1();\n+                iFld = -50000;\n+                test8308392No2();\n+                test8308392No3();\n+                test8308392No4();\n+                test8308392No5();\n+                test8308392No6();\n+                test8308392No7();\n+                iFld = 0;\n+                test8308392No8();\n+                runTest8308392No9();\n+                test8308392No10();\n+                testSplitIfCloneDownWithOpaqueAssertionPredicate();\n@@ -150,3 +285,5 @@\n-            case \"NoLoopPredication\", \"NoFlags\", \"Stress\" -> {\n-                for (int i = 0; i < 10000; i++) {\n-                    runAllTests();\n+            case \"XcompNoTiered\" -> {\n+                TestAssertionPredicates t = new TestAssertionPredicates();\n+                for (int i = 0; i < 10; i++) {\n+                    t.test8308504();\n+                    test8308504No2();\n@@ -155,0 +292,20 @@\n+            case \"DataUpdate\" -> {\n+                for (int i = 0; i < 10; i++) {\n+                    \/\/ The following tests create large arrays. Limit the number of invocations to reduce the time spent.\n+                    flag = !flag;\n+                    testDataUpdateUnswitchingPeelingUnroll();\n+                    testDataUpdateUnswitchUnroll();\n+                    testDataUpdateUnroll();\n+                    testDataUpdatePeelingUnroll();\n+                }\n+            }\n+            case \"CloneDown\" -> {\n+                for (int i = 0; i < 100; i++) {\n+                    \/\/ The following tests create large arrays. Limit the number of invocations to reduce the time spent.\n+                    testTrySplitUpNonOpaqueExpressionNode();\n+                    testTrySplitUpOpaqueLoopInit();\n+                }\n+            }\n+            case \"NoLoopPredication\", \"NoFlags\", \"Stress\" -> {\n+                runAllFastTests();\n+            }\n@@ -159,10 +316,465 @@\n-    static void runAllTests() {\n-        testTemplateAssertionPredicateNotRemovedHalt();\n-        testTemplateAssertionPredicateNotRemovedMalformedGraph();\n-        testDyingRuntimePredicate();\n-        testDyingNegatedRuntimePredicate();\n-        testDyingInitializedAssertionPredicate();\n-        test8305428();\n-        test8305428No2();\n-        test8320920();\n-        test8332501();\n+    \/\/ Runs almost all tests except for the heavy ones like the testData*() tests.\n+    static void runAllFastTests() {\n+        for (int i = 0; i < 10000; i++) {\n+            testPeeling();\n+            testPeelingTwice();\n+            testPeelingThreeTimes();\n+            testUnswitchingThenPeeling();\n+            testPeelingThenUnswitchingThenPeeling();\n+            testPeelingThenUnswitchingThenPeelingThenPreMainPost();\n+            testDyingRuntimePredicate();\n+            testDyingNegatedRuntimePredicate();\n+            testPeelMainLoopAfterUnrollingThenPreMainPost();\n+            testPeelMainLoopAfterUnrolling2();\n+            testUnrolling8();\n+            testUnrolling16();\n+            testPeelingUnrolling16();\n+            testPreMainPost();\n+            testUnrolling2();\n+            testUnrolling4();\n+            testPeelingThenPreMainPost();\n+            testUnswitchingThenPeelingThenPreMainPost();\n+            testDyingInitializedAssertionPredicate();\n+            test8288981();\n+            test8288941();\n+            testRemovingParsePredicatesThenMissingTemplates();\n+            iFld = -1;\n+            test8292507();\n+            test8307131();\n+            test8308392No1();\n+            iFld = -50000;\n+            test8308392No2();\n+            test8308392No3();\n+            test8308392No4();\n+            test8308392No5();\n+            test8308392No6();\n+            test8308392No7();\n+            iFld = 0;\n+            test8308392No8();\n+            runTest8308392No9();\n+            test8308392No10();\n+            testSplitIfCloneDownWithOpaqueAssertionPredicate();\n+            testTemplateAssertionPredicateNotRemovedHalt();\n+            testTemplateAssertionPredicateNotRemovedMalformedGraph();\n+            testDyingRuntimePredicate();\n+            testDyingNegatedRuntimePredicate();\n+            testDyingInitializedAssertionPredicate();\n+            test8305428();\n+            test8305428No2();\n+            test8320920();\n+            test8332501();\n+            test8308504();\n+            test8308504No2();\n+            testBackToBackLoopLimitCheckPredicate();\n+            testTrySplitUpNonOpaqueExpressionNode();\n+            testTrySplitUpOpaqueLoopInit();\n+        }\n+    }\n+\n+        \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::*\n+    static void testPreMainPost() {\n+        int x = 0;\n+        for (int i = 1; i > five; i -= 2) {\n+            x = iArr[i];\n+            if (x == i) {\n+                iFld = 34;\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::*\n+    static void testUnrolling2() {\n+        for (int i = 3; i > five; i -= 2) {\n+            int x = 0;\n+            x = iArr[i];\n+            if (x == i) {\n+                iFld = 34;\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::*\n+    static void testUnrolling4() {\n+        int x = 0;\n+        for (int i = 7; i > five; i -= 2) {\n+            x = iArr[i];\n+            if (x == i) {\n+                iFld = 34;\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:LoopUnrollLimit=150 -XX:CompileCommand=compileonly,Test*::*\n+    static void testUnrolling8() {\n+        int x = 0;\n+        for (int i = 15; i > five; i -= 2) {\n+            x = iArr[i];\n+            if (x == i) {\n+                iFld = 34;\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:LoopUnrollLimit=150 -XX:CompileCommand=compileonly,Test*::*\n+    static void testUnrolling16() {\n+        int x = 0;\n+        for (int i = 31; i > five; i -= 2) {\n+            x = iArr[i];\n+            if (x == i) {\n+                iFld = 34;\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:LoopUnrollLimit=150 -XX:CompileCommand=compileonly,Test*::*\n+    \/\/ Loop is first peeled and then unrolled.\n+    static void testPeelingUnrolling16() {\n+        int three = 0;\n+        int limit = 2;\n+        long l1 = 34L;\n+        long l2 = 35L;\n+        long l3 = 36L;\n+        long l4 = 37L;\n+\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            three = 33;\n+        }\n+\n+        for (int i = 33; i > five; i -= 2) {\n+            int x = iArr[i];\n+            if (x == i) {\n+                iFld += 34;\n+            }\n+\n+            if (i > three) {\n+                \/\/ DivLs add 30 to the loop body count and we hit LoopUnrollLimit.\n+                \/\/ After CCP, these statements are folded away and we can unroll this loop.\n+                l1 \/= lFld;\n+                l2 \/= lFld;\n+                l3 \/= lFld;\n+                l4 \/= lFld;\n+            }\n+\n+            if (flag) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:LoopMaxUnroll=0 -XX:CompileCommand=compileonly,Test*::*\n+    static void testPeeling() {\n+        for (int i = 1; i > five; i -= 2) {\n+            int arrLoad = iArr[i];\n+\n+            if (flag) {\n+                return;\n+            }\n+\n+            if (arrLoad == i) {\n+                iFld = 34;\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:LoopMaxUnroll=0 -XX:CompileCommand=compileonly,Test*::*\n+    private static void testPeelingTwice() {\n+        for (int i = 3; i > five; i -= 2) {\n+            int arrLoad = iArr[i];\n+\n+            if (flag) {\n+                iFld2 = 3;\n+                return;\n+            }\n+\n+            if (i < 2 && flag2) {\n+                return;\n+            }\n+\n+            if (arrLoad == i) {\n+                iFld = 34;\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:LoopMaxUnroll=0 -XX:CompileCommand=compileonly,Test*::*\n+    private static void testPeelingThreeTimes() {\n+        for (int i = 5; i > five; i -= 2) {\n+            int arrLoad = iArr[i];\n+\n+            if (iFld2 == 4) {\n+                iFld2 = 20;\n+                return;\n+            }\n+\n+            if (i < 4 && iFld2 == 3) {\n+                iFld2 = 42;\n+                return;\n+            }\n+\n+            if (i < 2 && iFld2 == 2) {\n+                iFld2 = 52;\n+                return;\n+            }\n+\n+            if (arrLoad == i) {\n+                iFld = 34;\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:LoopMaxUnroll=0 -XX:CompileCommand=compileonly,Test*::*\n+    static void testUnswitchingThenPeeling() {\n+        for (int i = 1; i > five; i -= 2) {\n+            iFld = iArr[i];\n+\n+            if (flag2) {\n+                iFld2 = 24;\n+            }\n+\n+            if (flag) {\n+                return;\n+            }\n+\n+            if (iFld == i) {\n+                iFld = 34;\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::test* -XX:LoopMaxUnroll=0\n+    static void testPeelingThenUnswitchingThenPeeling() {\n+        int zero = 34;\n+        int limit = 2;\n+\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+        for (int i = 3; i > five; i -= 2) {\n+            iFld = iArr[i];\n+            if (iFld == i) {\n+                fFld = 324;\n+            }\n+\n+            if (flag) { \/\/ 1) Triggers loop peeling\n+                return;\n+            }\n+\n+            int k = iFld2 + i * zero; \/\/ loop variant before CCP\n+\n+            if (k == 34) { \/\/ 2) After CCP loop invariant -> triggers loop unswitching\n+                iFld = 3;\n+\n+            } else {\n+                iFld = iArr2[i]; \/\/ 3) After loop unswitching, triggers loop peeling again.\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::test* -XX:LoopMaxUnroll=0\n+    static void testPeelingThenUnswitchingThenPeelingThenPreMainPost() {\n+        int zero = 34;\n+        int limit = 2;\n+\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+        for (int i = 5; i > five; i -= 2) {\n+            iFld = iArr[i];\n+            if (iFld == i) {\n+                fFld = 324;\n+            }\n+\n+            if (flag) { \/\/ 1) Triggers loop peeling\n+                return;\n+            }\n+\n+            int k = iFld2 + i * zero; \/\/ loop variant before CCP\n+\n+            if (k == 34) { \/\/ 2) After CCP loop invariant -> triggers loop unswitching\n+                iFld = 3;\n+\n+            } else {\n+                iFld = iArr2[i]; \/\/ 3) After loop unswitching, triggers loop peeling again, then pre\/main\/post\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::*\n+    static void testPeelingThenPreMainPost() {\n+        int three = 0;\n+        int limit = 2;\n+        long l1 = 34L;\n+        long l2 = 35L;\n+\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            three = 3;\n+        }\n+\n+        for (int i = 3; i > five; i -= 2) {\n+            iFld = iArr[i];\n+            if (iFld == i) {\n+                iFld = 34;\n+            }\n+\n+            if (i > three) {\n+                \/\/ DivLs add 30 to the loop body count and we hit LoopUnrollLimit.\n+                \/\/ After CCP, these statements are folded away and we can unroll this loop.\n+                l1 \/= lFld;\n+                l2 \/= lFld;\n+            }\n+\n+            if (flag) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::*\n+    static void testUnswitchingThenPeelingThenPreMainPost() {\n+        int three = 0;\n+        int limit = 2;\n+        long l1 = 34L;\n+        long l2 = 35L;\n+\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            three = 3;\n+        }\n+\n+        for (int i = 3; i > five; i -= 2) {\n+            iFld = iArr[i];\n+            if (iFld == i) {\n+                iFld = 34;\n+            }\n+\n+            if (i > three) {\n+                \/\/ DivLs add 30 to the loop body count and we hit LoopUnrollLimit.\n+                \/\/ After CCP, these statements are folded away and we can unroll this loop.\n+                l1 \/= lFld;\n+                l2 \/= lFld;\n+            }\n+\n+            if (flag2) {\n+                iFld2 = 34;\n+            }\n+\n+            if (flag) {\n+                return;\n+            }\n+        }\n+    }\n+\n+      \/\/ -XX:-UseProfiledLoopPredicate -Xcomp -XX:CompileCommand=compileonly,Test*::test*\n+    static void testWithPartialPeelingFirst() {\n+        int i = 3;\n+\n+        if (i > five) {\n+            while (true) {\n+\n+                \/\/ Found as loop head in ciTypeFlow, but both path inside loop -> head not cloned.\n+                \/\/ As a result, this head has the safepoint as backedge instead of the loop exit test\n+                \/\/ and we cannot create a counted loop (yet). We first need to partial peel.\n+                if (flag) {\n+                }\n+\n+                \/\/ Loop exit test.\n+                if (i <= five) {\n+                    break;\n+                }\n+                \/\/ <-- Partial Peeling CUT -->\n+                \/\/ Safepoint\n+                iFld = iArr[i];\n+                if (iFld == i) {\n+                    fFld = 324;\n+                }\n+                i--;\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::test* -XX:LoopUnrollLimit=40\n+    static void testPeelMainLoopAfterUnrollingThenPreMainPostThenUnrolling() {\n+        int zero = 34;\n+        int limit = 2;\n+\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+        \/\/ 1) Pre\/Main\/Post\n+        \/\/ 2) Unroll\n+        \/\/ 3) Peel main loop\n+        \/\/ 4) Pre\/Main\/Post peeled main loop\n+        \/\/ 5) Unroll new main loop\n+        for (int i = 13; i > five; i -= 2) {\n+            iFld = iArr[i];\n+            if (iFld == i) {\n+                fFld = 324;\n+            }\n+            if (i < 13) { \/\/ Always true and folded in main loop because of executing pre-loop at least once -> i = [min_short..11]\n+\n+                int k = iFld2 + i * zero; \/\/ Loop variant before CCP\n+                if (k  == 40) { \/\/ After CCP: Loop Invariant -> Triggers Loop Peeling of main loop\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::test* -XX:LoopMaxUnroll=2\n+    static void testPeelMainLoopAfterUnrollingThenPreMainPost() {\n+        int zero = 34;\n+        int limit = 2;\n+\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+        for (int i = 9; i > five; i -= 2) {\n+            iFld = iArr[i];\n+            if (iFld == i) {\n+                fFld = 324;\n+            }\n+            if (i < 9) { \/\/ Always true and folded in main loop because of executing pre-loop at least once -> i = [min_short..7]\n+                int k = iFld2 + i * zero; \/\/ Loop variant before CCP\n+                if (k  == 40) { \/\/ 2) After CCP: Loop Invariant -> Triggers Loop Peeling of main loop\n+                    return;\n+                } else {\n+                    iFld3 = iArr2[i]; \/\/ After Peeling Main Loop: Check can be eliminated with Range Check Elimination -> 3) apply Pre\/Main\/Post and then 4) Range Check Elimination\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::test* -XX:LoopMaxUnroll=2\n+    static void testPeelMainLoopAfterUnrolling2() {\n+        int zero = 34;\n+        int limit = 2;\n+\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+        for (int i = 7; i > five; i -= 2) {\n+            iFld = iArr[i];\n+            if (iFld == i) {\n+                fFld = 324;\n+            }\n+            if (i < 7) { \/\/ Always true and folded in main loop because of executing pre-loop at least once -> i = [min_short..5]\n+\n+                int k = iFld2 + i * zero; \/\/ Loop variant before CCP\n+                if (k  == 40) { \/\/ 2) After CCP: Loop Invariant -> Triggers Loop Peeling of main loop\n+                    return;\n+                }\n+\n+            }\n+        }\n@@ -400,1 +1012,293 @@\n-    \/**\n+    \/*\n+     * Tests to verify correct data dependencies update when splitting loops for which we created Hoisted Predicates.\n+     * If they are not updated correctly, we could wrongly execute an out-of-bounds load resulting in a segfault.\n+     *\/\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::test* -XX:+StressGCM -XX:CompileCommand=dontinline,*::dontInline\n+    static void testDataUpdateUnswitchingPeelingUnroll() {\n+        long l1 = 34L;\n+        long l2 = 566L;\n+\n+        int hundred = 0;\n+        for (int i = 0; i < 8; i++) {\n+            if ((i % 2) == 0) {\n+                hundred = 100;\n+            }\n+        }\n+\n+        Foo[] fooArr;\n+        int limit;\n+        if (flag) {\n+            limit = 3;\n+            fooArr = new Foo[20000001];\n+        } else {\n+            limit = 5;\n+            fooArr = new Foo[40000001];\n+        }\n+        for (int i = 0; i < limit; i++) {\n+            fooArr[10000000 * i] = foo;\n+        }\n+        \/\/ 9) This loop is not optimized in any way because we have a call inside the loop. This loop is only required\n+        \/\/    to trigger a crash.\n+        \/\/ 10) During GCM with StressGCM, we could schedule the LoadN from the main loop before checking if we should\n+        \/\/     enter the main loop. When 'flag' is true, we only have an array of size 20000001. We then perform\n+        \/\/     the LoadN[3*10000000] and crash when the memory is unmapped.\n+        for (float f = 0; f < 1.6f; f += 0.5f) {\n+            \/\/ 2) Loop is unswitched\n+            \/\/ 3) Both loop are peeled (we focus on one of those since both are almost identical except for the\n+            \/\/    unswitched condition):\n+            \/\/      Peeled iteration [i = 0]\n+            \/\/      Loop [i = 1..4, stride = 1]\n+            \/\/ 4) Loop unroll policy now returns true.\n+            \/\/    Peeled iteration [i = 0]\n+            \/\/    - Loop is pre-main-posted\n+            \/\/        Loop-pre[i = 1..4, stride = 1]\n+            \/\/        Loop-main[i = 2..4, stride = 1]\n+            \/\/        Loop-post[i = 2..4, stride = 1]\n+            \/\/    - Loop is unrolled once\n+            \/\/        Loop-pre[i = 1..4, stride = 1]\n+            \/\/        Loop-main[i = 2..4, stride = 2]\n+            \/\/        Loop-post[i = 2..4, stride = 1]\n+            \/\/ 5) During IGVN, we find that the backedge is never taken for main loop (we would over-iteratre) and it\n+            \/\/    collapses to a single iteration.\n+            \/\/ 6) After loop opts, the pre-loop is removed.\n+            for (int i = 0; i < limit; i++) {\n+                \/\/ 1) Hoisted with a Hoisted Range Check Predicate\n+                \/\/ 7) The 'i = 1' value is propagated to the single main loop iteration and we have the following\n+                \/\/    fixed-index accesses:\n+                \/\/      LoadN[2*10000000];\n+                \/\/      LoadN[3*10000000];\n+                \/\/ 8) Without explicitly pinning the LoadN from the main loop at the main loop entry (i.e. below the\n+                \/\/    zero trip guard), they are still pinned below the Hoisted Range Check Predicate before the loop.\n+                fooArr[i * 10000000].iFld += 34;\n+                if (flagFalse) {\n+                    return; \/\/Enables peeling\n+                }\n+\n+                \/\/ 3) hundred only known to be 100 after second loop opts -> becomes dead.\n+                \/\/    The expense statements are folded away and we can unroll this loop because we are below the\n+                \/\/    LoopUnrollLimit again.\n+                if (i > hundred) {\n+                    \/\/ DivLs add 30 to the loop body count and we hit LoopUnrollLimit -> loop not unrolled\n+                    l1 \/= lFld;\n+                    l2 \/= lFld;\n+                }\n+\n+                if (flagFalse2) { \/\/ Loop invariant -> enables Loop Unswitching\n+                    iFld += 34;\n+                }\n+\n+\n+            }\n+            dontInline(); \/\/ Ensure that float loop is not peeled\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::test* -XX:+StressGCM -XX:CompileCommand=dontinline,*::dontInline\n+    static void testDataUpdateUnswitchUnroll() {\n+        long l1 = 34L;\n+        long l2 = 566L;\n+\n+        int hundred = 0;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                hundred = 100;\n+            }\n+        }\n+\n+        Foo[] fooArr;\n+        int limit;\n+        if (flag) {\n+            limit = 2;\n+            fooArr = new Foo[10000001];\n+        } else {\n+            limit = 3;\n+            fooArr = new Foo[20000001];\n+        }\n+        for (int i = 0; i < limit; i++) {\n+            fooArr[10000000 * i] = foo;\n+        }\n+        \/\/ 9) This loop is not optimized in any way because we have a call inside the loop. This loop is only required\n+        \/\/    to trigger a crash.\n+        \/\/ 10) During GCM with StressGCM, we could schedule the LoadN from the main loop before checking if we should\n+        \/\/     enter the main loop. When 'flag' is true, we only have an array of size 10000001. We then perform\n+        \/\/     the LoadN[2*10000000] and crash when the memory is unmapped.\n+        for (float f = 0; f < 1.6f; f += 0.5f) {\n+            \/\/ 2) Loop is unswitched\n+            \/\/ 4) Loop unroll policy now returns true.\n+            \/\/    - Loop is pre-main-posted\n+            \/\/        Loop-pre[i = 0..2, stride = 1]\n+            \/\/        Loop-main[i = 1..2, stride = 1]\n+            \/\/        Loop-post[i = 1..2, stride = 1]\n+            \/\/    - Loop is unrolled once\n+            \/\/        Loop-pre[i = 0..2, stride = 1]\n+            \/\/        Loop-main[i = 1..2, stride = 2]\n+            \/\/        Loop-post[i = 1..2, stride = 1]\n+            \/\/ 5) During IGVN, we find that the backedge is never taken for main loop and it collapses to a single\n+            \/\/    iteration.\n+            \/\/ 6) After loop opts, the pre-loop is removed.\n+            for (int i = 0; i < limit; i++) {\n+                \/\/ 1) Hoisted with a Hoisted Range Check Predicate\n+                \/\/ 7) The 'i = 1' value is propagated to the single main loop iteration and we have the following\n+                \/\/    fixed-index accesses:\n+                \/\/      LoadN[1*10000000];\n+                \/\/      LoadN[2*10000000];\n+                \/\/ 8) Without explicitly pinning the LoadN from the main loop at the main loop entry (i.e. below the\n+                \/\/    zero trip guard), they are still pinned below the Hoisted Range Check Predicate before the loop.\n+                fooArr[i * 10000000].iFld += 34;\n+\n+                \/\/ 3) hundred only known to be 100 after second loop opts -> becomes dead.\n+                \/\/    The expense statements are folded away and we can unroll this loop because we are below the\n+                \/\/    LoopUnrollLimit again.\n+                if (i > hundred) {\n+                    \/\/ DivLs add 30 to the loop body count and we hit LoopUnrollLimit -> loop not unrolled\n+                    l1 \/= lFld;\n+                    l2 \/= lFld;\n+                }\n+\n+                if (flag) { \/\/ invariant -> enabled Loop Unswitching\n+                    iFld = 34;\n+                }\n+            }\n+            dontInline(); \/\/ Ensure that float loop is not peeled\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::test* -XX:+StressGCM -XX:CompileCommand=dontinline,*::dontInline\n+    static void testDataUpdateUnroll() {\n+        long l1 = 34L;\n+        long l2 = 566L;\n+\n+        int hundred = 0;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                hundred = 100;\n+            }\n+        }\n+\n+        Foo[] fooArr;\n+        int limit;\n+        if (flag) {\n+            limit = 2;\n+            fooArr = new Foo[10000001];\n+        } else {\n+            limit = 3;\n+            fooArr = new Foo[20000001];\n+        }\n+        for (int i = 0; i < limit; i++) {\n+            fooArr[10000000 * i] = foo;\n+        }\n+        \/\/ 8) This loop is not optimized in any way because we have a call inside the loop. This loop is only required\n+        \/\/    to trigger a crash.\n+        \/\/ 9) During GCM with StressGCM, we could schedule the LoadN from the main loop before checking if we should\n+        \/\/    enter the main loop. When 'flag' is true, we only have an array of size 10000001. We then perform\n+        \/\/    the LoadN[2*10000000] and crash when the memory is unmapped.\n+        for (float f = 0; f < 1.6f; f += 0.5f) {\n+            \/\/ 3) Loop unroll policy now returns true.\n+            \/\/    - Loop is pre-main-posted\n+            \/\/        Loop-pre[i = 0..2, stride = 1]\n+            \/\/        Loop-main[i = 1..2, stride = 1]\n+            \/\/        Loop-post[i = 1..2, stride = 1]\n+            \/\/    - Loop is unrolled once\n+            \/\/        Loop-pre[i = 0..2, stride = 1]\n+            \/\/        Loop-main[i = 1..2, stride = 2]\n+            \/\/        Loop-post[i = 1..2, stride = 1]\n+            \/\/ 4) During IGVN, we find that the backedge is never taken for main loop and it collapses to a single\n+            \/\/    iteration.\n+            \/\/ 5) After loop opts, the pre-loop is removed.\n+            for (int i = 0; i < limit; i++) {\n+                \/\/ 1) Hoisted with a Hoisted Range Check Predicate\n+                \/\/ 6) The 'i = 1' value is propagated to the single main loop iteration and we have the following\n+                \/\/    fixed-index accesses:\n+                \/\/      LoadN[1*10000000];\n+                \/\/      LoadN[2*10000000];\n+                \/\/ 7) Without explicitly pinning the LoadN from the main loop at the main loop entry (i.e. below the\n+                \/\/    zero trip guard), they are still pinned below the Hoisted Range Check Predicate before the loop.\n+                fooArr[i * 10000000].iFld += 34;\n+\n+                \/\/ 2) hundred only known to be 100 after second loop opts -> becomes dead.\n+                \/\/    The expense statements are folded away and we can unroll this loop because we are below the\n+                \/\/    LoopUnrollLimit again.\n+                if (i > hundred) {\n+                    \/\/ DivLs add 30 to the loop body count and we hit LoopUnrollLimit -> loop not unrolled\n+                    l1 \/= lFld;\n+                    l2 \/= lFld;\n+                }\n+            }\n+            dontInline(); \/\/ Ensure that float loop is not peeled\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::test* -XX:+StressGCM -XX:CompileCommand=dontinline,*::dontInline\n+    static void testDataUpdatePeelingUnroll() {\n+        long l1 = 34L;\n+        long l2 = 566L;\n+\n+        int hundred = 0;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                hundred = 100;\n+            }\n+        }\n+\n+        Foo[] fooArr;\n+        int limit;\n+        if (flag) {\n+            limit = 3;\n+            fooArr = new Foo[20000001];\n+        } else {\n+            limit = 5;\n+            fooArr = new Foo[40000001];\n+        }\n+        for (int i = 0; i < limit; i++) {\n+            fooArr[10000000 * i] = foo;\n+        }\n+        \/\/ 9) This loop is not optimized in any way because we have a call inside the loop. This loop is only required\n+        \/\/    to trigger a crash.\n+        \/\/ 10) During GCM with StressGCM, we could schedule the LoadN from the main loop before checking if we should\n+        \/\/     enter the main loop. When 'flag' is true, we only have an array of size 20000001. We then perform\n+        \/\/     the LoadN[3*10000000] and crash when the memory is unmapped.\n+        for (float f = 0; f < 1.6f; f += 0.5f) {\n+            \/\/ 2) Loop is peeled:\n+            \/\/      Peeled iteration [i = 0]\n+            \/\/      Loop [i = 1..4, stride = 1]\n+            \/\/ 4) Loop unroll policy now returns true.\n+            \/\/    Peeled iteration [i = 0]\n+            \/\/    - Loop is pre-main-posted\n+            \/\/        Loop-pre[i = 1..4, stride = 1]\n+            \/\/        Loop-main[i = 2..4, stride = 1]\n+            \/\/        Loop-post[i = 2..4, stride = 1]\n+            \/\/    - Loop is unrolled once\n+            \/\/        Loop-pre[i = 1..4, stride = 1]\n+            \/\/        Loop-main[i = 2..4, stride = 2]\n+            \/\/        Loop-post[i = 2..4, stride = 1]\n+            \/\/ 5) During IGVN, we find that the backedge is never taken for main loop (we would over-iteratre) and it\n+            \/\/    collapses to a single iteration.\n+            \/\/ 6) After loop opts, the pre-loop is removed.\n+            for (int i = 0; i < limit; i++) {\n+                \/\/ 1) Hoisted with a Hoisted Range Check Predicate\n+                \/\/ 7) The 'i = 1' value is propagated to the single main loop iteration and we have the following\n+                \/\/    fixed-index accesses:\n+                \/\/      LoadN[2*10000000];\n+                \/\/      LoadN[3*10000000];\n+                \/\/ 8) Without explicitly pinning the LoadN from the main loop at the main loop entry (i.e. below the\n+                \/\/    zero trip guard), they are still pinned below the Hoisted Range Check Predicate before the loop.\n+                fooArr[i * 10000000].iFld += 34;\n+                if (flagFalse) {\n+                    return; \/\/ Enables peeling\n+                }\n+\n+                \/\/ 3) hundred only known to be 100 after second loop opts -> becomes dead.\n+                \/\/    The expense statements are folded away and we can unroll this loop because we are below the\n+                \/\/    LoopUnrollLimit again.\n+                if (i > hundred) {\n+                    \/\/ DivLs add 30 to the loop body count and we hit LoopUnrollLimit -> loop not unrolled\n+                    l1 \/= lFld;\n+                    l2 \/= lFld;\n+                }\n+            }\n+            dontInline(); \/\/ Ensure that float loop is not peeled\n+        }\n+    }\n+\n+    \/*\n@@ -471,0 +1375,789 @@\n+\n+        \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::*\n+    static void test8288981() {\n+        int x = 1;\n+        \/\/ Sufficiently many iterations to trigger OSR\n+        for (int j = 0; j < 50_000; j++) {\n+            for (int i = 1; i > x; --i) {\n+                float v = fArr[0] + fFld;\n+                fArr2D[i + 1][x] = v;\n+                iFld += v;\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::*\n+    static void test8292507() {\n+        int i = iFld, j, iArr[] = new int[40];\n+        while (i > 0) {\n+            for (j = i; 1 > j; ++j) {\n+                try {\n+                    iArr[j] = 0;\n+                    iArr[1] = iFld = 0;\n+                } catch (ArithmeticException a_e) {\n+                }\n+                switch (i) {\n+                    case 4:\n+                    case 43:\n+                        iFld2 = j;\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::*\n+    static void test8307131() {\n+        int i21 = 6, i, i23 = 3, y, iArr2[] = new int[40];\n+        for (i = 50000; 3 < i; i--) {\n+            for (y = 2; y > i; y--) {\n+                try {\n+                    i21 = i23 \/ 416 \/ iArr2[y];\n+                } catch (ArithmeticException a_e) {\n+                }\n+                i23 -= 3;\n+            }\n+        }\n+        i21 -= 2;\n+    }\n+\n+    void test8296077() {\n+        int i4 = 4, iArr1[] = new int[10];\n+        float f2;\n+        for (f2 = 7; f2 > 4; --f2) {}\n+\n+        float f4 = five;\n+        while (f4 < 50000) {\n+            for (int i7 = (int) f4; 1 > i7; i7++) {\n+                iArr1[i7] = 5;\n+                if (i4 != 0) {\n+                    return;\n+                }\n+                byFldVol = 2;\n+                try {\n+                    iArr1[(int) f4] = i4 = iArr1[(int) f4 + 1] % iArr1[(int) f2];\n+                } catch (ArithmeticException a_e) {\n+                }\n+            }\n+            f4++;\n+        }\n+    }\n+\n+    static void test8308392No1() {\n+        int i10, i16;\n+        try {\n+            for (i10 = 61; i10 < 50000 ; i10++) {\n+                for (i16 = 2; i16 > i10; i16--) {\n+                    sFld *= iArr2D[i16][i16] = byFld *= sFld;\n+                }\n+            }\n+        } catch (NegativeArraySizeException exc3) {\n+        }\n+    }\n+\n+    static void test8308392No2() {\n+        try {\n+            int j, k, i19 = 8;\n+\n+            for (int i = 0; i < 10; i++) {\n+                for (j = 2; j < 3; ) {\n+                    if (flagTrue) {\n+                        iFld++;\n+                        iFld2 = 34 \/ iFld; \/\/ Will eventually divide by zero and break infinite loop.\n+                    }\n+                    for (k = 2; k > j; --k) {\n+                        i19 *= fArr2D[k][j] += i;\n+                    }\n+                }\n+            }\n+\n+        } catch (ArithmeticException e) {\n+            \/\/ Expected\n+        }\n+    }\n+    static void test8308392No3() {\n+        int i18, i19, i21, i22 = 1, iArr2[][] = new int[40][];\n+        double dArr[] = new double[40];\n+\n+        i18 = 1;\n+        for (i19 = 5; i19 < 50000; i19++) {\n+            for (i21 = i18; i21 < 4; ++i21) {\n+                switch (i19) {\n+                    case 4:\n+                        iArr2[i21 - 1][i18] = 3;\n+                        try {\n+                            iFld = 2 % iFld;\n+                            iFld = i22;\n+                        } catch (ArithmeticException a_e) {\n+                        }\n+                        break;\n+                    case 45:\n+                        i22 += dArr[i22];\n+                }\n+            }\n+        }\n+    }\n+\n+    static void test8308392No4() {\n+        int i20, i22 = 6, i25;\n+        for (i20 = 50000; i20 > 3; i20--) {\n+            for (i25 = 1; i25 > i22; i25--) {\n+                iArr2D[i25 + 1][i22] += fFld -= iFld;\n+            }\n+        }\n+    }\n+\n+    static void test8308392No5() {\n+        float f1;\n+        int i20, i23, i25 = 5, i26 = 4, i27;\n+        long lArr[][] = new long[10][10];\n+        for (f1 = 40; f1 > 3; --f1) {\n+            for (i20 = 2; 11 > i20; i20++) {\n+                for (i23 = 1; i23 < 11; ) {\n+                    i23++;\n+                    for (i27 = (int) f1; i27 < 1; ++i27) {\n+                        iFld = 3;\n+                        lArr[i27][i25] = 5;\n+                        if (flag) {\n+                            i26 += i25;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void test8308392No6() {\n+        int i, i1, i2, i23 = 7, i24;\n+        double dArr1[][] = new double[10][];\n+        boolean bArr[] = new boolean[10];\n+        for (i = 9; i < 88; i++) {\n+            i2 = 1;\n+            do {\n+                i1 = Short.reverseBytes((short) 0);\n+                for (i24 = 1; i2 < i24; --i24) {\n+                    i1 %= dArr1[i24 + 1][i];\n+                    switch (i23) {\n+                        case 0:\n+                            bArr[i] = false;\n+                    }\n+                }\n+                i2++;\n+            } while (i2 < 50000);\n+        }\n+    }\n+\n+    static void test8308392No7() {\n+        int i16 = 2, i17 = 1, i18, i20, i21, i23;\n+        double d2 = 86.53938;\n+        long lArr[][] = new long[10][];\n+        for (i18 = 1; i18 < 10; i18++) {\n+            i20 = 1;\n+            while (i20 < 5000) {\n+                for (i21 = i23 = 1; i23 > i20; --i23) {\n+                    d2 *= i16 >>= lArr[i23 + 1][i20] >>= i17;\n+                }\n+                i20++;\n+            }\n+        }\n+    }\n+    static void test8308392No8() {\n+        int i21, i22, i25 = 1, i26 = 032, i28;\n+        i21 = iFld;\n+        while (--i21 > 0) {\n+            for (i22 = 2; i22 < 71; i22++) {\n+                for (i28 = 2; i28 > i21; --i28) {\n+                    i25 %= i26;\n+                    iArr2D[i28][1] ^= 5;\n+                }\n+            }\n+            i21--;\n+        }\n+    }\n+\n+    static void runTest8308392No9() {\n+        try {\n+            test8308392No9();\n+        } catch (ArithmeticException | ArrayIndexOutOfBoundsException e) {\n+            \/\/ Expected.\n+        }\n+    }\n+\n+    static void test8308392No9() {\n+        for (int i20 = 60; ; i20--) {\n+            for (int i22 = 2; i22 > i20; --i22) {\n+                fFld += 5;\n+                iFld = iFld \/ 9 \/ iArr[i22];\n+            }\n+        }\n+    }\n+\n+    static void test8308392No10() {\n+        int i14, i16 = -27148, i18, i21;\n+        for (i14 = 21; i16 < 9; ++i16) {\n+            for (i18 = 2; i14 < i18; i18--) {\n+                iArr2D[i18][i18] -= lFld = i18;\n+            }\n+            for (i21 = 1; i21 < 2; i21++) {}\n+        }\n+    }\n+\n+    \/\/ -Xcomp -XX:-TieredCompilation\n+    static void test8308504() {\n+        int iArr[][] = new int[400][400];\n+        for (int i16 = 294; i16 > 6; --i16) {\n+            for (int i21 = 1; i21 < 87; ++i21) {\n+                for (int i23 = 2; i23 > i21; i23--) {\n+                    switch (118) {\n+                        case 118:\n+                            iFld *= 3.4f;\n+                            iArr[i23][i16] *= 5;\n+                    }\n+                }\n+            }\n+        }\n+        System.nanoTime(); \/\/ Unloaded, triggers deopt\n+    }\n+\n+    \/\/ -Xcomp -XX:-TieredCompilation\n+    static void test8308504No2() {\n+        int iArr[][] = new int[400][400];\n+        for (int i = 294; i > 6; i--) {\n+            for (int j = 1; j < 87; j++) {\n+                for (int k = 2; k > j; k--) {\n+                    iFld *= 3.4f;\n+                    iArr[k][i] *= 5;\n+                }\n+            }\n+        }\n+        Math.pow(2, 3); \/\/ Unloaded, triggers deopt\n+    }\n+\n+    static void testSplitIfCloneDownWithOpaqueAssertionPredicate() {\n+        int p = 0, j;\n+        if (flag) {\n+            iArr[3] = 3;\n+            dontInline();\n+        }\n+        int i = 1;\n+        while (++i < 4) {\n+            if (flag) {\n+                p = 8;\n+            }\n+            iArr[i - 1] = 4;\n+            for (j = 1; j < 3; ++j) {\n+                iArr[j] = 34;\n+            }\n+        }\n+        long n = p;\n+    }\n+\n+    static void testTrySplitUpNonOpaqueExpressionNode() {\n+        int zero = 34;\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            flag = !flag;\n+            flag2 = !flag2;\n+            iFld = flag ? 50 : -50;\n+            zero = 0;\n+        }\n+\n+        for (int t = 0; t < 100; t++) {\n+            \/\/ 4) Graph looks like this now:\n+            \/\/ Split If is applied because the graph has the following shape:\n+            \/\/\n+            \/\/        Region  # **REGION**\n+            \/\/          |\n+            \/\/   NULL  Phi[new int[100], iArr2]  # 'iArr'\n+            \/\/     \\  \/\n+            \/\/     CmpU   \\\n+            \/\/      |     |\n+            \/\/     Bool   | # Hoisted NullCheck from 2b)\n+            \/\/      |     |\n+            \/\/     If     \/\n+            \/\/\n+            \/\/\n+            \/\/ We find that we can split the If through the Region because we have a Phi input for the condition CmpU\n+            \/\/\n+            \/\/ 5) We apply Split-If to split the If through the region. This requires that we also handle all the Phi nodes\n+            \/\/    belonging to the region to split through. We need to empty the block ('--- BLOCK start\/end ---') by\n+            \/\/    checking all users of the Phi* node. This is done removing all user of the\n+            \/\/    phi nodes belonging to the Region to split the If through. phi nodes.\n+            \/\/    This requires that we split up all users of the phi recursively through the phi. The new users of the Phis\n+            \/\/    are then revisited again since Split-If is applied iteratively for all nodes. We stop the \"splitting up\"\n+            \/\/    when a user of a Phi node has its get_ctrl() at a different node than the region to split through.\n+            \/\/\n+            \/\/    We have the following graph before Split If:\n+            \/\/\n+            \/\/        Region  # **REGION**\n+            \/\/                 |\n+            \/\/                Phi\n+            \/\/                 |\n+            \/\/               LoadUB  # 'flag2'loaded either from the merged memory state of the region\n+            \/\/                 |\n+            \/\/                CmpI\n+            \/\/                 |\n+            \/\/                Bool\n+            \/\/                 |\n+            \/\/               CmoveI  # From 1)\n+            \/\/                 |\n+            \/\/              ConvI2L\n+            \/\/                 |\n+            \/\/                AddL   # First node part of Template Assertion Predicate expression of 3b).\n+            \/\/                 |\n+            \/\/               CmpUL\n+            \/\/                 |\n+            \/\/  OpaqueTemplateAssertionPredicate\n+            \/\/\n+            \/\/ 6) We start applying Split If and iteratively split users of Phi nodes up. We find that all nodes including\n+            \/\/    the AddL, can be split through the new phis because they have their get_ctrl() set to the REGION.\n+            \/\/    Why isnt the control of the AddL not set to the latest control (which we usually do when having the\n+            \/\/    same loop depth) at 3b) where the Template Assertion Predicate Expression node belongs to?\n+            \/\/    The reason is that during build_loop_late_post_work(), we skip all predicates to not interfere with\n+            \/\/    Loop Predication, including the NullCheck from 2b) . Thus, we move late control up to REGION because the\n+            \/\/    if\/else is already removed with a CMove in 1).\n+            \/\/\n+            \/\/ 7) When splitting the AddL node, have the following graph:\n+            \/\/\n+             \/\/     Region    # **REGION**\n+            \/\/        |\n+            \/\/        |   OpaqueLoopInit\n+            \/\/        |        |\n+            \/\/       Phi    ConvI2L\n+            \/\/         \\    \/\n+            \/\/          AddL\n+            \/\/\n+            \/\/    We find that it's part of a Template Assertion Predicate Expression. We do not want to split such a node\n+            \/\/    to not introduce a Phi node within the expression which would mess with pattern matching to find the\n+            \/\/    OpaqueLoop* nodes from the Template Assertion Predicate If. As a solution, we \"clone down\" the Template\n+            \/\/    Assertion Predicate Expression by creating a clone of the entire Template Assertion Predicate Expression.\n+            \/\/    We then feed the Phi for the new Region, after splitting the If, into the AddL as part of the\n+            \/\/    Template Assertion Predicate Expression.\n+            \/\/\n+            \/\/    Note: When trying to split AddL, we first try to split its inputs, i.e. ConvI2L. But ConvI2L has its\n+            \/\/          get_ctrl() outside of the outer \"for (t = ...)\" loop because the OpaqueLoopInit node has a constant\n+            \/\/          as input and thus build_loop_late_post_work() will make sure that late control does not have a\n+            \/\/          deeper nesting than early. In testTrySplitUpOpaqueLoopInit(), we remove the outer loop and\n+            \/\/          therefore try to split up the OpaqueLoopInit node first which will initiate the \"clone down\".\n+\n+            int[] iArr;\n+            if (flag) {\n+                iArr = new int[100];\n+            } else {\n+                dontInline();\n+                iArr = iArr2;\n+            }\n+\n+            \/\/ **REGION**\n+            \/\/ - Phi[new int[100], iArr2] = Phi[DecodeN[int:100], DecodeN[n>=0]] # 'iArr'\n+            \/\/ - Phi[flag, flag]  # 'flag' -> once loaded from the if-branch and once from the else-branch related memory\n+\n+            \/\/ --- BLOCK start ---\n+\n+            \/\/ 1) Replaced with CMove:\n+            \/\/     a = CMove(flag, 3, 4)\n+            \/\/\n+            \/\/    Note: Even though we run with -Xcomp where we don't know the frequency, we still cmove because of\n+            \/\/          -XX:-BlockLayoutByFrequency\n+            int a;\n+            if (flag2) {\n+                a = 4;\n+            } else {\n+                a = 3;\n+            }\n+            \/\/ --- BLOCK end ---\n+\n+            \/\/ 2b) Hoisted Check Predicate: NullCheck(iArr)\n+            \/\/ 3b) Hoisted Check Predicate: RangeCheck(iArr) + TAPs(iArr)\n+            for (int i = 0; i < 100; i++) {\n+                \/\/ 2a) Null check hoisted with a Hoisted Check Predicate -> put at 2b)\n+                \/\/ 3a) Range check hoisted with a Hoisted Check Predicate + Template Assertion Predicates -> put at 3b)\n+                iArr[i + a] = 34;\n+                \/\/ 8) After CCP, we find that this condition equals to \"0 < iFld\". Since this is loop-invariant and\n+                \/\/    a loop-exit, we apply Loop Peeling which verifies that we do not have a Template Assertion\n+                \/\/    Predicate with a Phi node.\n+                if (i * zero < iFld) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test above but this time the \"clone down\" is initiated when trying to split up an OpaqueLoopInitNode.\n+    static void testTrySplitUpOpaqueLoopInit() {\n+            int zero = 34;\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+        \/\/ 4) Graph looks like this now:\n+        \/\/ Split If is applied because the graph has the following shape:\n+        \/\/\n+        \/\/        Region  # **REGION**\n+        \/\/          |\n+        \/\/   NULL  Phi[new int[100], iArr2]  # 'iArr'\n+        \/\/     \\  \/\n+        \/\/     CmpU   \\\n+        \/\/      |     |\n+        \/\/     Bool   | # Hoisted NullCheck from 2b)\n+        \/\/      |     |\n+        \/\/     If     \/\n+        \/\/\n+        \/\/\n+        \/\/ We find that we can split the If through the Region because we have a Phi input for the condition CmpU\n+        \/\/\n+        \/\/ 5) We apply Split-If to split the If through the region. This requires that we also handle all the Phi nodes\n+        \/\/    belonging to the region to split through. We need to empty the block ('--- BLOCK start\/end ---') by\n+        \/\/    checking all users of the Phi* node. This is done removing all user of the\n+        \/\/    phi nodes belonging to the Region to split the If through. phi nodes.\n+        \/\/    This requires that we split up all users of the phi recursively through the phi. The new users of the Phis\n+        \/\/    are then revisited again since Split-If is applied iteratively for all nodes. We stop the \"splitting up\"\n+        \/\/    when a user of a Phi node has its get_ctrl() at a different node than the region to split through.\n+        \/\/\n+        \/\/    We have the following graph before Split If:\n+        \/\/\n+        \/\/        Region  # **REGION**\n+        \/\/                 |\n+        \/\/                Phi\n+        \/\/                 |\n+        \/\/               LoadUB  # 'flag2'loaded either from the merged memory state of the region\n+        \/\/                 |\n+        \/\/                CmpI\n+        \/\/                 |\n+        \/\/                Bool\n+        \/\/                 |\n+        \/\/               CmoveI  # From 1)\n+        \/\/                 |\n+        \/\/              ConvI2L\n+        \/\/                 |\n+        \/\/                AddL   # First node part of Template Assertion Predicate expression of 3b).\n+        \/\/                 |\n+        \/\/               CmpUL\n+        \/\/                 |\n+        \/\/  OpaqueTemplateAssertionPredicate\n+        \/\/\n+        \/\/ 6) We start applying Split If and iteratively split users of Phi nodes up. We find that all nodes including\n+        \/\/    the AddL, can be split through the new phis because they have their get_ctrl() set to the REGION.\n+        \/\/    Why isnt the control of the AddL not set to the latest control (which we usually do when having the\n+        \/\/    same loop depth) at 3b) where the Template Assertion Predicate Expression node belongs to?\n+        \/\/    The reason is that during build_loop_late_post_work(), we skip all predicates to not interfere with\n+        \/\/    Loop Predication, including the NullCheck from 2b) . Thus, we move late control up to REGION because the\n+        \/\/    if\/else is already removed with a CMove in 1).\n+        \/\/\n+        \/\/ 7) When splitting the AddL node, have the following graph:\n+        \/\/\n+         \/\/     Region    # **REGION**\n+        \/\/        |\n+        \/\/        |   OpaqueLoopInit\n+        \/\/        |        |\n+        \/\/       Phi    ConvI2L\n+        \/\/         \\    \/\n+        \/\/          AddL\n+        \/\/\n+        \/\/    We find that it's part of a Template Assertion Predicate Expression. We do not want to split such a node\n+        \/\/    to not introduce a Phi node within the expression which would mess with pattern matching to find the\n+        \/\/    OpaqueLoop* nodes from the Template Assertion Predicate If. As a solution, we \"clone down\" the Template\n+        \/\/    Assertion Predicate Expression by creating a clone of the entire Template Assertion Predicate Expression.\n+        \/\/    We then feed the Phi for the new Region, after splitting the If, into the AddL as part of the\n+        \/\/    Template Assertion Predicate Expression.\n+        \/\/\n+        \/\/    Note: The difference to testTrySplitUpNonOpaqueExpressionNode() above is that when trying to split AddL,\n+        \/\/          we first split up its inputs recursively if they also have get_ctrl() at the region to split through.\n+        \/\/          This is the case for ConvI2L and OpaqueLoopInit. Therefore, the split of OpaqueLoopInit will\n+        \/\/          initiate the \"clone down\".\n+\n+        int[] iArr;\n+        if (flag) {\n+            iArr = new int[100];\n+        } else {\n+            dontInline();\n+            iArr = iArr2;\n+        }\n+\n+        \/\/ **REGION**\n+        \/\/ - Phi[new int[100], iArr2] = Phi[DecodeN[int:100], DecodeN[n>=0]] # 'iArr'\n+        \/\/ - Phi[flag, flag]  # 'flag' -> once loaded from the if-branch and once from the else-branch related memory\n+\n+        \/\/ --- BLOCK start ---\n+\n+        \/\/ 1) Replaced with CMove:\n+        \/\/     a = CMove(flag, 3, 4)\n+        \/\/\n+        \/\/    Note: Even though we run with -Xcomp where we don't know the frequency, we still cmove because of\n+        \/\/          -XX:-BlockLayoutByFrequency\n+        int a;\n+        if (flag2) {\n+            a = 4;\n+        } else {\n+            a = 3;\n+        }\n+        \/\/ --- BLOCK end ---\n+\n+        \/\/ 2b) Hoisted Check Predicate: NullCheck(iArr)\n+        \/\/ 3b) Hoisted Check Predicate: RangeCheck(iArr) + TAPs(iArr)\n+        for (int i = 0; i < 100; i++) {\n+            \/\/ 2a) Null check hoisted with a Hoisted Check Predicate -> put at 2b)\n+            \/\/ 3a) Range check hoisted with a Hoisted Check Predicate + Template Assertion Predicates -> put at 3b)\n+            iArr[i + a] = 34;\n+            \/\/ 8) After CCP, we find that this condition equals to \"0 < iFld\". Since this is loop-invariant and\n+            \/\/    a loop-exit, we apply Loop Peeling which verifies that we do not have a Template Assertion\n+            \/\/    Predicate with a Phi node.\n+            if (i * zero < iFld) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    static void testBackToBackLoopLimitCheckPredicate() {\n+        int i = 34;\n+        if (flag) {}\n+        while (i < 50) {\n+            i++;\n+        }\n+        for (int j = 0; j < 4; j++) {\n+            iArr[j] += 34;\n+        }\n+    }\n+\n+   \/\/ -Xcomp -XX:CompileCommand=compileonly,Test*::*\n+    static int test8288941() {\n+        int e = 8, g = 5, j;\n+        int h = 1;\n+        while (++h < 100000) {\n+            for (j = 1; j > h; j--) {\n+                try {\n+                    iFld = 0;\n+                    g = iArr[1] \/ e;\n+                } catch (ArithmeticException ae) {\n+                }\n+                iArr[j + 1] = 4;\n+                if (e == 9) {\n+                    iFld2 = 3;\n+                }\n+            }\n+        }\n+        return g;\n+    }\n+\n+    \/\/ JDK-8288941, -Xcomp -XX:CompileCommand=compileonly,Test::test\n+    static void testRemovingParsePredicatesThenMissingTemplates() {\n+        int one = 34;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            one = 1; \/\/ Only known to be 1 after CCP.\n+        }\n+\n+        long l1 = 34L;\n+        long l2 = 566L;\n+\n+        \/\/ 10) After IGVN, the StoreF has lost most of its out edges due to the removal of the MergeMems into the UCTs\n+        \/\/     of the Parse Predicates.\n+        \/\/ 11) policy_maximally_unroll() now returns true and we can maximally unroll this loop.\n+        int j;\n+        for (j = 0; j < 4; j++) {\n+            \/\/ 1) StoreF has a huge number of MergeMem uses for the UCTs of all the loops further down. As a result,\n+            \/\/    policy_maximally_unroll() will return false because est_loop_unroll_sz() -> est_loop_flow_merge_sz()\n+            \/\/    counts all out edges to nodes outside the loop to estimate the cost of merging nodes when cloning the\n+            \/\/    loop. This count is larger then the unroll limit and we do not apply MaxUnroll.\n+            \/\/ Note: This is a store to a float array to not interfere with the int array store in the next loop below.\n+            fArr[j] = 34;\n+\n+            \/\/ 2) DivLs add 30 to the loop body count and we hit LoopUnrollLimit which avoids normal Loop unrolling and\n+            \/\/    thus pre\/main\/post loop creation. Therefore, we currently cannot split this loop in any way.\n+            l1 \/= lFldOne;\n+            l2 \/= lFldOne;\n+        }\n+\n+\n+        long l3 = 34L;\n+        long l4 = 566L;\n+        \/\/ 13) Since the DivL nodes are now removed, the LoopUnrollLimit is not reached and we can finally pre\/main\/post\n+        \/\/     and unroll this loop - with Template Assertion Predicates above but no more Parse Predicates!\n+        \/\/ 14) We currently do not clone\/update\/establish Template Assertion Predicates once Parse Predicates are removed.\n+        \/\/     Therefore, we create pre\/main\/post loops without Template Assertion Predicates and without Initialized\n+        \/\/     Assertion Predicates.\n+        int x = 0;\n+        for (int i = 1; i > five; i -= 2) {\n+\n+            \/\/ 3)  Loop Predication will hoist the range check out of the loop together with a Template Assertion Predicate.\n+            \/\/ 15) After pre\/main\/post: the CastII for the array index get the new iv type [-1..-32767] and is replaced by\n+            \/\/     top. Data dies but there is no Intialized Assertion Predicate above the main loop and we are left with\n+            \/\/     a broken graph. We assert when running with -XX:+AbortVMOnCompilationFailure due to a malformed graph.\n+            int arrLoad = iArr[i];\n+            if (arrLoad == i) {\n+                iFld = 34;\n+            }\n+\n+            \/\/ 4)  This check is non-loop invariant, so Loop Unswitching cannot be applied, either.\n+            \/\/ 12) After maximally unrolling the loop above, we know that j == 4 and thus \"j+(i*-1) = 4+[-1..32767] < 3\" is\n+            \/\/     always false. The branch is cleaned up in the next IGVN round which also removes the expensive DivL nodes.\n+            if (j+(i*-1) < 3) {\n+\n+                \/\/ 5) As above: We hit the LoopUnrollLimit which avoids normal Loop unrolling and thus pre\/main\/post loop\n+                \/\/    creation. Therefore, we currently cannot split this loop in any way.\n+                l3 \/= lFldOne;\n+                l4 \/= lFldOne;\n+            }\n+        }\n+\n+        \/\/ Many non-counted loops that are not optimized but all have Parse Predicates with UCTs + a safepoint in the loop body.\n+        \/\/ The StoreF from the loop above will be merged with a MergeMem into all these UCTs.\n+        \/\/\n+        \/\/ 6) After CCP, we find that 'one' is 1. Therefore, all loops will only iterate for a single iteration and the loop\n+        \/\/    backedges die. These are cleaned up in the next round of IGVN.\n+        \/\/ 7) In the next loop opts phase after CCP, we find that all these Parse Predicates above the loops are now useless.\n+        \/\/    We mark them as such but will only clean them up in the next round of IGVN.\n+        \/\/ 8) Since we do not apply any major loop optimization like loop splitting, we remove the remaining Parse Predicates\n+        \/\/    (see \"PredicatesOff\" when running with -XX:+TraceLoopOpts). We set major progress again to see if we can continue\n+        \/\/    to apply more loop optimizations.\n+        \/\/ 9) IGVN runs and cleans up all the Parse Predicates and its UCTs.\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+        for (int i = 0; i < one; i++) {\n+           if (i < 2) {\n+               i++;\n+           }\n+        }\n+    }\n+\n+    \/\/ Not inlined.\n+    static void dontInline() {\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestAssertionPredicates.java","additions":1742,"deletions":49,"binary":false,"changes":1791,"status":"modified"}]}