{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import java.io.UncheckedIOException;\n@@ -70,1 +71,1 @@\n-    private DesktopIntegration(BuildEnv env, LinuxPackage pkg, LinuxLauncher launcher) throws IOException {\n+    private DesktopIntegration(BuildEnv env, LinuxPackage pkg, LinuxLauncher launcher) {\n@@ -91,4 +92,8 @@\n-            final Path nullPath = null;\n-            if (curIconResource.get().saveToFile(nullPath) != OverridableResource.Source.DefaultResource) {\n-                \/\/ This launcher has custom icon configured.\n-                withDesktopFile = true;\n+            try {\n+                if (curIconResource.get().saveToFile((Path)null) != OverridableResource.Source.DefaultResource) {\n+                    \/\/ This launcher has custom icon configured.\n+                    withDesktopFile = true;\n+                }\n+            } catch (IOException ex) {\n+                \/\/ Should never happen as `saveToFile((Path)null)` should not perform any actual I\/O operations.\n+                throw new UncheckedIOException(ex);\n@@ -138,1 +143,1 @@\n-            }).map(toFunction(l -> {\n+            }).map(l -> {\n@@ -140,1 +145,1 @@\n-            })).toList();\n+            }).toList();\n@@ -144,1 +149,1 @@\n-    static ShellCustomAction create(BuildEnv env, Package pkg) throws IOException {\n+    static ShellCustomAction create(BuildEnv env, Package pkg) {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,7 +28,0 @@\n-import jdk.jpackage.internal.model.LinuxPackage;\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.LinuxDebPackage;\n-import java.io.IOException;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.Files;\n@@ -36,9 +29,0 @@\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n-\n-import java.nio.file.attribute.PosixFilePermission;\n-import java.nio.file.attribute.PosixFilePermissions;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n@@ -46,10 +30,4 @@\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.AppImageLayout;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n+import jdk.jpackage.internal.model.LinuxDebPackage;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.Result;\n@@ -59,4 +37,0 @@\n-    private static final String TOOL_DPKG_DEB = \"dpkg-deb\";\n-    private static final String TOOL_DPKG = \"dpkg\";\n-    private static final String TOOL_FAKEROOT = \"fakeroot\";\n-\n@@ -67,317 +41,0 @@\n-    @Override\n-    protected void doValidate(BuildEnv env, LinuxPackage pkg) throws ConfigException {\n-\n-        \/\/ Show warning if license file is missing\n-        if (pkg.licenseFile().isEmpty()) {\n-            Log.verbose(I18N.getString(\"message.debs-like-licenses\"));\n-        }\n-    }\n-\n-    @Override\n-    protected List<ToolValidator> getToolValidators() {\n-        return Stream.of(TOOL_DPKG_DEB, TOOL_DPKG, TOOL_FAKEROOT).map(\n-                ToolValidator::new).toList();\n-    }\n-\n-    @Override\n-    protected void createConfigFiles(Map<String, String> replacementData,\n-            BuildEnv env, LinuxPackage pkg) throws IOException {\n-        prepareProjectConfig(replacementData, env, pkg);\n-        adjustPermissionsRecursive(env.appImageDir());\n-    }\n-\n-    @Override\n-    protected Path buildPackageBundle(BuildEnv env, LinuxPackage pkg,\n-            Path outputParentDir) throws PackagerException, IOException {\n-        return buildDeb(env, pkg, outputParentDir);\n-    }\n-\n-    private static final Pattern PACKAGE_NAME_REGEX = Pattern.compile(\"^(^\\\\S+):\");\n-\n-    @Override\n-    protected void initLibProvidersLookup(LibProvidersLookup libProvidersLookup) {\n-\n-        libProvidersLookup.setPackageLookup(file -> {\n-            Path realPath = file.toRealPath();\n-\n-            try {\n-                \/\/ Try the real path first as it works better on newer Ubuntu versions\n-                return findProvidingPackages(realPath);\n-            } catch (IOException ex) {\n-                \/\/ Try the default path if differ\n-                if (!realPath.toString().equals(file.toString())) {\n-                    return findProvidingPackages(file);\n-                } else {\n-                    throw ex;\n-                }\n-            }\n-        });\n-    }\n-\n-    private static Stream<String> findProvidingPackages(Path file) throws IOException {\n-        \/\/\n-        \/\/ `dpkg -S` command does glob pattern lookup. If not the absolute path\n-        \/\/ to the file is specified it might return mltiple package names.\n-        \/\/ Even for full paths multiple package names can be returned as\n-        \/\/ it is OK for multiple packages to provide the same file. `\/opt`\n-        \/\/ directory is such an example. So we have to deal with multiple\n-        \/\/ packages per file situation.\n-        \/\/\n-        \/\/ E.g.: `dpkg -S libc.so.6` command reports three packages:\n-        \/\/ libc6-x32: \/libx32\/libc.so.6\n-        \/\/ libc6:amd64: \/lib\/x86_64-linux-gnu\/libc.so.6\n-        \/\/ libc6-i386: \/lib32\/libc.so.6\n-        \/\/ `:amd64` is architecture suffix and can (should) be dropped.\n-        \/\/ Still need to decide what package to choose from three.\n-        \/\/ libc6-x32 and libc6-i386 both depend on libc6:\n-        \/\/ $ dpkg -s libc6-x32\n-        \/\/ Package: libc6-x32\n-        \/\/ Status: install ok installed\n-        \/\/ Priority: optional\n-        \/\/ Section: libs\n-        \/\/ Installed-Size: 10840\n-        \/\/ Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>\n-        \/\/ Architecture: amd64\n-        \/\/ Source: glibc\n-        \/\/ Version: 2.23-0ubuntu10\n-        \/\/ Depends: libc6 (= 2.23-0ubuntu10)\n-        \/\/\n-        \/\/ We can dive into tracking dependencies, but this would be overly\n-        \/\/ complicated.\n-        \/\/\n-        \/\/ For simplicity lets consider the following rules:\n-        \/\/ 1. If there is one item in `dpkg -S` output, accept it.\n-        \/\/ 2. If there are multiple items in `dpkg -S` output and there is at\n-        \/\/  least one item with the default arch suffix (DEB_ARCH),\n-        \/\/  accept only these items.\n-        \/\/ 3. If there are multiple items in `dpkg -S` output and there are\n-        \/\/  no with the default arch suffix (DEB_ARCH), accept all items.\n-        \/\/ So lets use this heuristics: don't accept packages for whom\n-        \/\/  `dpkg -p` command fails.\n-        \/\/ 4. Arch suffix should be stripped from accepted package names.\n-        \/\/\n-\n-        Set<String> archPackages = new HashSet<>();\n-        Set<String> otherPackages = new HashSet<>();\n-\n-        var debArch = LinuxPackageArch.getValue(LINUX_DEB);\n-\n-        Executor.of(TOOL_DPKG, \"-S\", file.toString())\n-                .saveOutput(true).executeExpectSuccess()\n-                .getOutput().forEach(line -> {\n-                    Matcher matcher = PACKAGE_NAME_REGEX.matcher(line);\n-                    if (matcher.find()) {\n-                        String name = matcher.group(1);\n-                        if (name.endsWith(\":\" + debArch)) {\n-                            \/\/ Strip arch suffix\n-                            name = name.substring(0,\n-                                    name.length() - (debArch.length() + 1));\n-                            archPackages.add(name);\n-                        } else {\n-                            otherPackages.add(name);\n-                        }\n-                    }\n-                });\n-\n-        if (!archPackages.isEmpty()) {\n-            return archPackages.stream();\n-        }\n-        return otherPackages.stream();\n-    }\n-\n-    @Override\n-    protected List<ConfigException> verifyOutputBundle(BuildEnv env, LinuxPackage pkg,\n-            Path packageBundle) {\n-        List<ConfigException> errors = new ArrayList<>();\n-\n-        String controlFileName = \"control\";\n-\n-        List<PackageProperty> properties = List.of(\n-                new PackageProperty(\"Package\", pkg.packageName(),\n-                        \"APPLICATION_PACKAGE\", controlFileName),\n-                new PackageProperty(\"Version\", ((LinuxDebPackage)pkg).versionWithRelease(),\n-                        \"APPLICATION_VERSION_WITH_RELEASE\",\n-                        controlFileName),\n-                new PackageProperty(\"Architecture\", pkg.arch(), \"APPLICATION_ARCH\", controlFileName));\n-\n-        List<String> cmdline = new ArrayList<>(List.of(TOOL_DPKG_DEB, \"-f\",\n-                packageBundle.toString()));\n-        properties.forEach(property -> cmdline.add(property.name));\n-        try {\n-            Map<String, String> actualValues = Executor.of(cmdline.toArray(String[]::new))\n-                    .saveOutput(true)\n-                    .executeExpectSuccess()\n-                    .getOutput().stream()\n-                            .map(line -> line.split(\":\\\\s+\", 2))\n-                            .collect(Collectors.toMap(\n-                                    components -> components[0],\n-                                    components -> components[1]));\n-            properties.forEach(property -> errors.add(property.verifyValue(\n-                    actualValues.get(property.name))));\n-        } catch (IOException ex) {\n-            \/\/ Ignore error as it is not critical. Just report it.\n-            Log.verbose(ex);\n-        }\n-\n-        return errors;\n-    }\n-\n-    \/*\n-     * set permissions with a string like \"rwxr-xr-x\"\n-     *\n-     * This cannot be directly backport to 22u which is built with 1.6\n-     *\/\n-    private void setPermissions(Path file, String permissions) {\n-        Set<PosixFilePermission> filePermissions =\n-                PosixFilePermissions.fromString(permissions);\n-        try {\n-            if (Files.exists(file)) {\n-                Files.setPosixFilePermissions(file, filePermissions);\n-            }\n-        } catch (IOException ex) {\n-            Log.error(ex.getMessage());\n-            Log.verbose(ex);\n-        }\n-\n-    }\n-\n-    public static boolean isDebian() {\n-        \/\/ we are just going to run \"dpkg -s coreutils\" and assume Debian\n-        \/\/ or deritive if no error is returned.\n-        try {\n-            Executor.of(TOOL_DPKG, \"-s\", \"coreutils\").executeExpectSuccess();\n-            return true;\n-        } catch (IOException e) {\n-            \/\/ just fall thru\n-        }\n-        return false;\n-    }\n-\n-    private void adjustPermissionsRecursive(Path dir) throws IOException {\n-        Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n-            @Override\n-            public FileVisitResult visitFile(Path file,\n-                    BasicFileAttributes attrs)\n-                    throws IOException {\n-                if (file.endsWith(\".so\") || !Files.isExecutable(file)) {\n-                    setPermissions(file, \"rw-r--r--\");\n-                } else if (Files.isExecutable(file)) {\n-                    setPermissions(file, \"rwxr-xr-x\");\n-                }\n-                return FileVisitResult.CONTINUE;\n-            }\n-\n-            @Override\n-            public FileVisitResult postVisitDirectory(Path dir, IOException e)\n-                    throws IOException {\n-                if (e == null) {\n-                    setPermissions(dir, \"rwxr-xr-x\");\n-                    return FileVisitResult.CONTINUE;\n-                } else {\n-                    \/\/ directory iteration failed\n-                    throw e;\n-                }\n-            }\n-        });\n-    }\n-\n-    private class DebianFile {\n-\n-        DebianFile(Path dstFilePath, String comment) {\n-            this.dstFilePath = dstFilePath;\n-            this.comment = comment;\n-        }\n-\n-        DebianFile setExecutable() {\n-            permissions = \"rwxr-xr-x\";\n-            return this;\n-        }\n-\n-        void create(Map<String, String> data, Function<String, OverridableResource> resourceFactory)\n-                throws IOException {\n-            resourceFactory.apply(\"template.\" + dstFilePath.getFileName().toString())\n-                    .setCategory(I18N.getString(comment))\n-                    .setSubstitutionData(data)\n-                    .saveToFile(dstFilePath);\n-            if (permissions != null) {\n-                setPermissions(dstFilePath, permissions);\n-            }\n-        }\n-\n-        private final Path dstFilePath;\n-        private final String comment;\n-        private String permissions;\n-    }\n-\n-    private void prepareProjectConfig(Map<String, String> data, BuildEnv env, LinuxPackage pkg) throws IOException {\n-\n-        Path configDir = env.appImageDir().resolve(\"DEBIAN\");\n-        List<DebianFile> debianFiles = new ArrayList<>();\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"control\"),\n-                \"resource.deb-control-file\"));\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"preinst\"),\n-                \"resource.deb-preinstall-script\").setExecutable());\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"prerm\"),\n-                \"resource.deb-prerm-script\").setExecutable());\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"postinst\"),\n-                \"resource.deb-postinstall-script\").setExecutable());\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"postrm\"),\n-                \"resource.deb-postrm-script\").setExecutable());\n-\n-        ((LinuxDebPackage)pkg).relativeCopyrightFilePath().ifPresent(copyrightFile -> {\n-            debianFiles.add(new DebianFile(env.appImageDir().resolve(copyrightFile),\n-                    \"resource.copyright-file\"));\n-        });\n-\n-        for (DebianFile debianFile : debianFiles) {\n-            debianFile.create(data, env::createResource);\n-        }\n-    }\n-\n-    @Override\n-    protected Map<String, String> createReplacementData(BuildEnv env, LinuxPackage pkg) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n-\n-        String licenseText = pkg.licenseFile().map(toFunction(Files::readString)).orElse(\"Unknown\");\n-\n-        data.put(\"APPLICATION_MAINTAINER\", ((LinuxDebPackage) pkg).maintainer());\n-        data.put(\"APPLICATION_SECTION\", pkg.category().orElseThrow());\n-        data.put(\"APPLICATION_COPYRIGHT\", pkg.app().copyright());\n-        data.put(\"APPLICATION_LICENSE_TEXT\", licenseText);\n-        data.put(\"APPLICATION_ARCH\", pkg.arch());\n-        data.put(\"APPLICATION_INSTALLED_SIZE\", Long.toString(\n-                AppImageLayout.toPathGroup(env.appImageLayout()).sizeInBytes() >> 10));\n-        data.put(\"APPLICATION_HOMEPAGE\", pkg.aboutURL().map(\n-                value -> \"Homepage: \" + value).orElse(\"\"));\n-        data.put(\"APPLICATION_VERSION_WITH_RELEASE\", ((LinuxDebPackage) pkg).versionWithRelease());\n-\n-        return data;\n-    }\n-\n-    private Path buildDeb(BuildEnv env, LinuxPackage pkg, Path outdir) throws IOException {\n-        Path outFile = outdir.resolve(pkg.packageFileNameWithSuffix());\n-        Log.verbose(I18N.format(\"message.outputting-to-location\", outFile.toAbsolutePath()));\n-\n-        List<String> cmdline = new ArrayList<>();\n-        cmdline.addAll(List.of(TOOL_FAKEROOT, TOOL_DPKG_DEB));\n-        if (Log.isVerbose()) {\n-            cmdline.add(\"--verbose\");\n-        }\n-        cmdline.addAll(List.of(\"-b\", env.appImageDir().toString(),\n-                outFile.toAbsolutePath().toString()));\n-\n-        \/\/ run dpkg\n-        RetryExecutor.retryOnKnownErrorMessage(\n-                \"semop(1): encountered an error: Invalid argument\").execute(\n-                        cmdline.toArray(String[]::new));\n-\n-        Log.verbose(I18N.format(\"message.output-to-location\", outFile.toAbsolutePath()));\n-\n-        return outFile;\n-    }\n-\n@@ -395,2 +52,13 @@\n-    public boolean supported(boolean runtimeInstaller) {\n-        return OperatingSystem.isLinux() && (new ToolValidator(TOOL_DPKG_DEB).validate() == null);\n+    public Path execute(Map<String, ? super Object> params, Path outputParentDir) throws PackagerException {\n+\n+        return Packager.<LinuxDebPackage>build().outputDir(outputParentDir)\n+                .pkg(LinuxFromParams.DEB_PACKAGE.fetchFrom(params))\n+                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, pkg, outputDir) -> {\n+                    return new LinuxDebPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n+                }).execute(LinuxPackagingPipeline.build());\n+    }\n+\n+    @Override\n+    protected Result<LinuxDebSystemEnvironment> sysEnv() {\n+        return sysEnv;\n@@ -401,1 +69,4 @@\n-        return isDebian();\n+        return sysEnv.value()\n+                .map(LinuxSystemEnvironment::nativePackageType)\n+                .map(StandardPackageType.LINUX_DEB::equals)\n+                .orElse(false);\n@@ -403,0 +74,2 @@\n+\n+    private final Result<LinuxDebSystemEnvironment> sysEnv = LinuxDebSystemEnvironment.create(SYS_ENV);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":23,"deletions":350,"binary":false,"changes":373,"status":"modified"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LinuxDebPackage;\n+\n+final class LinuxDebPackager extends LinuxPackager<LinuxDebPackage> {\n+\n+    LinuxDebPackager(BuildEnv env, LinuxDebPackage pkg, Path outputDir, LinuxDebSystemEnvironment sysEnv) {\n+        super(env, pkg, outputDir, sysEnv);\n+        this.sysEnv = Objects.requireNonNull(sysEnv);\n+    }\n+\n+    @Override\n+    protected void createConfigFiles(Map<String, String> replacementData) throws IOException {\n+        prepareProjectConfig(replacementData);\n+        adjustPermissionsRecursive();\n+    }\n+\n+    @Override\n+    protected void initLibProvidersLookup(LibProvidersLookup libProvidersLookup) {\n+\n+        libProvidersLookup.setPackageLookup(file -> {\n+            Path realPath = file.toRealPath();\n+\n+            try {\n+                \/\/ Try the real path first as it works better on newer Ubuntu versions\n+                return findProvidingPackages(realPath, sysEnv.dpkg());\n+            } catch (IOException ex) {\n+                \/\/ Try the default path if differ\n+                if (!realPath.equals(file)) {\n+                    return findProvidingPackages(file, sysEnv.dpkg());\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected List<? extends Exception> findErrorsInOutputPackage() throws IOException {\n+        List<ConfigException> errors = new ArrayList<>();\n+\n+        var controlFileName = \"control\";\n+\n+        List<PackageProperty> properties = List.of(\n+                new PackageProperty(\"Package\", pkg.packageName(),\n+                        \"APPLICATION_PACKAGE\", controlFileName),\n+                new PackageProperty(\"Version\", pkg.versionWithRelease(),\n+                        \"APPLICATION_VERSION_WITH_RELEASE\",\n+                        controlFileName),\n+                new PackageProperty(\"Architecture\", pkg.arch(), \"APPLICATION_ARCH\", controlFileName));\n+\n+        List<String> cmdline = new ArrayList<>(List.of(\n+                sysEnv.dpkgdeb().toString(), \"-f\", outputPackageFile().toString()));\n+\n+        properties.forEach(property -> cmdline.add(property.name));\n+\n+        Map<String, String> actualValues = Executor.of(cmdline.toArray(String[]::new))\n+                .saveOutput(true)\n+                .executeExpectSuccess()\n+                .getOutput().stream()\n+                        .map(line -> line.split(\":\\\\s+\", 2))\n+                        .collect(Collectors.toMap(\n+                                components -> components[0],\n+                                components -> components[1]));\n+\n+        for (var property : properties) {\n+            Optional.ofNullable(property.verifyValue(actualValues.get(property.name))).ifPresent(errors::add);\n+        }\n+\n+        return errors;\n+    }\n+\n+    @Override\n+    protected Map<String, String> createReplacementData() throws IOException {\n+        Map<String, String> data = new HashMap<>();\n+\n+        String licenseText = pkg.licenseFile().map(toFunction(Files::readString)).orElse(\"Unknown\");\n+\n+        data.put(\"APPLICATION_MAINTAINER\", pkg.maintainer());\n+        data.put(\"APPLICATION_SECTION\", pkg.category().orElseThrow());\n+        data.put(\"APPLICATION_COPYRIGHT\", pkg.app().copyright());\n+        data.put(\"APPLICATION_LICENSE_TEXT\", licenseText);\n+        data.put(\"APPLICATION_ARCH\", pkg.arch());\n+        data.put(\"APPLICATION_INSTALLED_SIZE\", Long.toString(\n+                AppImageLayout.toPathGroup(env.appImageLayout()).sizeInBytes() >> 10));\n+        data.put(\"APPLICATION_HOMEPAGE\", pkg.aboutURL().map(\n+                value -> \"Homepage: \" + value).orElse(\"\"));\n+        data.put(\"APPLICATION_VERSION_WITH_RELEASE\", pkg.versionWithRelease());\n+\n+        return data;\n+    }\n+\n+    @Override\n+    protected void buildPackage() throws IOException {\n+\n+        Path debFile = outputPackageFile();\n+\n+        Log.verbose(I18N.format(\"message.outputting-to-location\", debFile.toAbsolutePath()));\n+\n+        List<String> cmdline = new ArrayList<>();\n+        Stream.of(sysEnv.fakeroot(), sysEnv.dpkgdeb()).map(Path::toString).forEach(cmdline::add);\n+        if (Log.isVerbose()) {\n+            cmdline.add(\"--verbose\");\n+        }\n+        cmdline.addAll(List.of(\"-b\", env.appImageDir().toString(), debFile.toAbsolutePath().toString()));\n+\n+        \/\/ run dpkg\n+        RetryExecutor.retryOnKnownErrorMessage(\n+                \"semop(1): encountered an error: Invalid argument\").execute(\n+                        cmdline.toArray(String[]::new));\n+\n+        Log.verbose(I18N.format(\"message.output-to-location\", debFile.toAbsolutePath()));\n+    }\n+\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n+        super.accept(pipelineBuilder);\n+\n+        \/\/ Build deb config files after app image contents are ready because\n+        \/\/ it calculates the size of the image and saves the value in one of the config files.\n+        pipelineBuilder.configuredTasks().filter(task -> {\n+            return PackageTaskID.CREATE_CONFIG_FILES.equals(task.task());\n+        }).findFirst().orElseThrow()\n+                .addDependencies(PrimaryTaskID.BUILD_APPLICATION_IMAGE, PrimaryTaskID.COPY_APP_IMAGE)\n+                .add();\n+    }\n+\n+    private void adjustPermissionsRecursive() throws IOException {\n+        Files.walkFileTree(env.appImageDir(), new SimpleFileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                if (file.endsWith(\".so\") || !Files.isExecutable(file)) {\n+                    Files.setPosixFilePermissions(file, SO_PERMISSIONS);\n+                } else if (Files.isExecutable(file)) {\n+                    Files.setPosixFilePermissions(file, EXECUTABLE_PERMISSIONS);\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {\n+                if (e == null) {\n+                    Files.setPosixFilePermissions(dir, FOLDER_PERMISSIONS);\n+                    return FileVisitResult.CONTINUE;\n+                } else {\n+                    \/\/ directory iteration failed\n+                    throw e;\n+                }\n+            }\n+        });\n+    }\n+\n+    private void prepareProjectConfig(Map<String, String> data) throws IOException {\n+\n+        Path configDir = env.appImageDir().resolve(\"DEBIAN\");\n+        List<DebianFile> debianFiles = new ArrayList<>();\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"control\"),\n+                \"resource.deb-control-file\"));\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"preinst\"),\n+                \"resource.deb-preinstall-script\").setExecutable());\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"prerm\"),\n+                \"resource.deb-prerm-script\").setExecutable());\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"postinst\"),\n+                \"resource.deb-postinstall-script\").setExecutable());\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"postrm\"),\n+                \"resource.deb-postrm-script\").setExecutable());\n+\n+        pkg.relativeCopyrightFilePath().ifPresent(copyrightFile -> {\n+            debianFiles.add(new DebianFile(env.appImageDir().resolve(copyrightFile),\n+                    \"resource.copyright-file\"));\n+        });\n+\n+        for (DebianFile debianFile : debianFiles) {\n+            debianFile.create(data, env::createResource);\n+        }\n+    }\n+\n+    private static Stream<String> findProvidingPackages(Path file, Path dpkg) throws IOException {\n+        \/\/\n+        \/\/ `dpkg -S` command does glob pattern lookup. If not the absolute path\n+        \/\/ to the file is specified it might return mltiple package names.\n+        \/\/ Even for full paths multiple package names can be returned as\n+        \/\/ it is OK for multiple packages to provide the same file. `\/opt`\n+        \/\/ directory is such an example. So we have to deal with multiple\n+        \/\/ packages per file situation.\n+        \/\/\n+        \/\/ E.g.: `dpkg -S libc.so.6` command reports three packages:\n+        \/\/ libc6-x32: \/libx32\/libc.so.6\n+        \/\/ libc6:amd64: \/lib\/x86_64-linux-gnu\/libc.so.6\n+        \/\/ libc6-i386: \/lib32\/libc.so.6\n+        \/\/ `:amd64` is architecture suffix and can (should) be dropped.\n+        \/\/ Still need to decide what package to choose from three.\n+        \/\/ libc6-x32 and libc6-i386 both depend on libc6:\n+        \/\/ $ dpkg -s libc6-x32\n+        \/\/ Package: libc6-x32\n+        \/\/ Status: install ok installed\n+        \/\/ Priority: optional\n+        \/\/ Section: libs\n+        \/\/ Installed-Size: 10840\n+        \/\/ Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>\n+        \/\/ Architecture: amd64\n+        \/\/ Source: glibc\n+        \/\/ Version: 2.23-0ubuntu10\n+        \/\/ Depends: libc6 (= 2.23-0ubuntu10)\n+        \/\/\n+        \/\/ We can dive into tracking dependencies, but this would be overly\n+        \/\/ complicated.\n+        \/\/\n+        \/\/ For simplicity lets consider the following rules:\n+        \/\/ 1. If there is one item in `dpkg -S` output, accept it.\n+        \/\/ 2. If there are multiple items in `dpkg -S` output and there is at\n+        \/\/  least one item with the default arch suffix (DEB_ARCH),\n+        \/\/  accept only these items.\n+        \/\/ 3. If there are multiple items in `dpkg -S` output and there are\n+        \/\/  no with the default arch suffix (DEB_ARCH), accept all items.\n+        \/\/ So lets use this heuristics: don't accept packages for whom\n+        \/\/  `dpkg -p` command fails.\n+        \/\/ 4. Arch suffix should be stripped from accepted package names.\n+        \/\/\n+\n+        Set<String> archPackages = new HashSet<>();\n+        Set<String> otherPackages = new HashSet<>();\n+\n+        var debArch = LinuxPackageArch.getValue(LINUX_DEB);\n+\n+        Executor.of(dpkg.toString(), \"-S\", file.toString())\n+                .saveOutput(true).executeExpectSuccess()\n+                .getOutput().forEach(line -> {\n+                    Matcher matcher = PACKAGE_NAME_REGEX.matcher(line);\n+                    if (matcher.find()) {\n+                        String name = matcher.group(1);\n+                        if (name.endsWith(\":\" + debArch)) {\n+                            \/\/ Strip arch suffix\n+                            name = name.substring(0,\n+                                    name.length() - (debArch.length() + 1));\n+                            archPackages.add(name);\n+                        } else {\n+                            otherPackages.add(name);\n+                        }\n+                    }\n+                });\n+\n+        if (!archPackages.isEmpty()) {\n+            return archPackages.stream();\n+        }\n+        return otherPackages.stream();\n+    }\n+\n+\n+    private static final class DebianFile {\n+\n+        DebianFile(Path dstFilePath, String comment) {\n+            this.dstFilePath = Objects.requireNonNull(dstFilePath);\n+            this.comment = Objects.requireNonNull(comment);\n+        }\n+\n+        DebianFile setExecutable() {\n+            permissions = EXECUTABLE_PERMISSIONS;\n+            return this;\n+        }\n+\n+        void create(Map<String, String> data, Function<String, OverridableResource> resourceFactory)\n+                throws IOException {\n+            resourceFactory.apply(\"template.\" + dstFilePath.getFileName().toString())\n+                    .setCategory(I18N.getString(comment))\n+                    .setSubstitutionData(data)\n+                    .saveToFile(dstFilePath);\n+            if (permissions != null) {\n+                Files.setPosixFilePermissions(dstFilePath, permissions);\n+            }\n+        }\n+\n+        private final Path dstFilePath;\n+        private final String comment;\n+        private Set<PosixFilePermission> permissions;\n+    }\n+\n+\n+    private final LinuxDebSystemEnvironment sysEnv;\n+\n+    private static final Pattern PACKAGE_NAME_REGEX = Pattern.compile(\"^(^\\\\S+):\");\n+\n+    private static final Set<PosixFilePermission> EXECUTABLE_PERMISSIONS = PosixFilePermissions.fromString(\"rwxr-xr-x\");\n+    private static final Set<PosixFilePermission> FOLDER_PERMISSIONS = PosixFilePermissions.fromString(\"rwxr-xr-x\");\n+    private static final Set<PosixFilePermission> SO_PERMISSIONS = PosixFilePermissions.fromString(\"rw-r--r--\");\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebPackager.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.LinuxSystemEnvironment.mixin;\n+\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxDebSystemEnvironment extends LinuxSystemEnvironment, LinuxDebSystemEnvironmentMixin {\n+\n+    static Result<LinuxDebSystemEnvironment> create(Result<LinuxSystemEnvironment> base) {\n+        return mixin(LinuxDebSystemEnvironment.class, base, LinuxDebSystemEnvironmentMixin::create);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebSystemEnvironment.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxDebSystemEnvironmentMixin {\n+    Path dpkg();\n+    Path dpkgdeb();\n+    Path fakeroot();\n+\n+    record Stub(Path dpkg, Path dpkgdeb, Path fakeroot) implements LinuxDebSystemEnvironmentMixin {\n+    }\n+\n+    static Result<LinuxDebSystemEnvironmentMixin> create() {\n+        final var errors = Stream.of(Internal.TOOL_DPKG_DEB, Internal.TOOL_DPKG, Internal.TOOL_FAKEROOT)\n+                .map(ToolValidator::new)\n+                .map(ToolValidator::validate)\n+                .filter(Objects::nonNull)\n+                .toList();\n+        if (errors.isEmpty()) {\n+            return Result.ofValue(new Stub(Internal.TOOL_DPKG, Internal.TOOL_DPKG_DEB, Internal.TOOL_FAKEROOT));\n+        } else {\n+            return Result.ofErrors(errors);\n+        }\n+    }\n+\n+    static final class Internal {\n+\n+        private static final Path TOOL_DPKG_DEB = Path.of(\"dpkg-deb\");\n+        private static final Path TOOL_DPKG = Path.of(\"dpkg\");\n+        private static final Path TOOL_FAKEROOT = Path.of(\"fakeroot\");\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebSystemEnvironmentMixin.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.jpackage.internal.model.LinuxDebPackage;\n@@ -44,1 +45,1 @@\n-import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.LinuxRpmPackage;\n@@ -79,1 +80,1 @@\n-    private static LinuxPackage createLinuxRpmPackage(\n+    private static LinuxRpmPackage createLinuxRpmPackage(\n@@ -91,1 +92,1 @@\n-    private static LinuxPackage createLinuxDebPackage(\n+    private static LinuxDebPackage createLinuxDebPackage(\n@@ -100,1 +101,8 @@\n-        return pkgBuilder.create();\n+        final var pkg = pkgBuilder.create();\n+\n+        \/\/ Show warning if license file is missing\n+        if (pkg.licenseFile().isEmpty()) {\n+            Log.verbose(I18N.getString(\"message.debs-like-licenses\"));\n+        }\n+\n+        return pkg;\n@@ -106,1 +114,1 @@\n-    static final BundlerParamInfo<LinuxPackage> RPM_PACKAGE = createPackageBundlerParam(\n+    static final BundlerParamInfo<LinuxRpmPackage> RPM_PACKAGE = createPackageBundlerParam(\n@@ -109,1 +117,1 @@\n-    static final BundlerParamInfo<LinuxPackage> DEB_PACKAGE = createPackageBundlerParam(\n+    static final BundlerParamInfo<LinuxDebPackage> DEB_PACKAGE = createPackageBundlerParam(\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromParams.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    private LinuxLaunchersAsServices(BuildEnv env, Package pkg) throws IOException {\n+    private LinuxLaunchersAsServices(BuildEnv env, Package pkg) {\n@@ -61,1 +61,1 @@\n-    static ShellCustomAction create(BuildEnv env, Package pkg) throws IOException {\n+    static ShellCustomAction create(BuildEnv env, Package pkg) {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxLaunchersAsServices.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,6 +27,0 @@\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n@@ -35,6 +29,0 @@\n-import java.util.function.Predicate;\n-import java.util.stream.Stream;\n-import jdk.jpackage.internal.PackagingPipeline.PackageBuildEnv;\n-import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n-import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n-import jdk.jpackage.internal.model.AppImageLayout;\n@@ -42,1 +30,0 @@\n-import jdk.jpackage.internal.model.LinuxDebPackage;\n@@ -44,2 +31,1 @@\n-import jdk.jpackage.internal.model.Package;\n-import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.util.Result;\n@@ -50,4 +36,1 @@\n-        this.pkgParam = pkgParam;\n-        customActions = List.of(new CustomActionInstance(\n-                DesktopIntegration::create), new CustomActionInstance(\n-                LinuxLaunchersAsServices::create));\n+        this.pkgParam = Objects.requireNonNull(pkgParam);\n@@ -61,8 +44,8 @@\n-        LinuxPackage pkg = pkgParam.fetchFrom(params);\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-        for (var validator: getToolValidators()) {\n-            ConfigException ex = validator.validate();\n-            if (ex != null) {\n-                throw ex;\n-            }\n+        pkgParam.fetchFrom(params);\n+        BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+\n+        LinuxSystemEnvironment sysEnv;\n+        try {\n+            sysEnv = sysEnv().orElseThrow();\n+        } catch (RuntimeException ex) {\n+            throw ConfigException.rethrowConfigException(ex);\n@@ -72,3 +55,2 @@\n-            withFindNeededPackages = false;\n-            Log.verbose(MessageFormat.format(I18N.getString(\n-                    \"message.not-default-bundler-no-dependencies-lookup\"),\n+            Log.verbose(I18N.format(\n+                    \"message.not-default-bundler-no-dependencies-lookup\",\n@@ -76,12 +58,6 @@\n-        } else {\n-            withFindNeededPackages = LibProvidersLookup.supported();\n-            if (!withFindNeededPackages) {\n-                final String advice;\n-                if (\"deb\".equals(getID())) {\n-                    advice = \"message.deb-ldd-not-available.advice\";\n-                } else {\n-                    advice = \"message.rpm-ldd-not-available.advice\";\n-                }\n-                \/\/ Let user know package dependencies will not be generated.\n-                Log.error(String.format(\"%s\\n%s\", I18N.getString(\n-                        \"message.ldd-not-available\"), I18N.getString(advice)));\n+        } else if (!sysEnv.soLookupAvailable()) {\n+            final String advice;\n+            if (\"deb\".equals(getID())) {\n+                advice = \"message.deb-ldd-not-available.advice\";\n+            } else {\n+                advice = \"message.rpm-ldd-not-available.advice\";\n@@ -89,0 +65,3 @@\n+            \/\/ Let user know package dependencies will not be generated.\n+            Log.error(String.format(\"%s\\n%s\", I18N.getString(\n+                    \"message.ldd-not-available\"), I18N.getString(advice)));\n@@ -91,3 +70,0 @@\n-        \/\/ Packaging specific validation\n-        doValidate(env, pkg);\n-\n@@ -103,103 +79,2 @@\n-    public final Path execute(Map<String, ? super Object> params,\n-            Path outputParentDir) throws PackagerException {\n-        IOUtils.writableOutputDir(outputParentDir);\n-\n-        \/\/ Order is important!\n-        final LinuxPackage pkg = pkgParam.fetchFrom(params);\n-        final var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-        final var pipelineBuilder = LinuxPackagingPipeline.build()\n-                .excludeDirFromCopying(outputParentDir)\n-                .task(PackageTaskID.CREATE_PACKAGE_FILE)\n-                        .packageAction(this::buildPackage)\n-                        .add();\n-\n-        final var createConfigFilesTaskBuilder = pipelineBuilder\n-                .task(PackageTaskID.CREATE_CONFIG_FILES)\n-                .packageAction(this::buildConfigFiles);\n-\n-        if (pkg instanceof LinuxDebPackage) {\n-            \/\/ Build deb config files after app image contents are ready because\n-            \/\/ it calculates the size of the image and saves the value in one of the config files.\n-            createConfigFilesTaskBuilder.addDependencies(PrimaryTaskID.BUILD_APPLICATION_IMAGE, PrimaryTaskID.COPY_APP_IMAGE);\n-        }\n-\n-        createConfigFilesTaskBuilder.add();\n-\n-        pipelineBuilder.create().execute(env, pkg, outputParentDir);\n-\n-        return outputParentDir.resolve(pkg.packageFileNameWithSuffix()).toAbsolutePath();\n-    }\n-\n-    private void buildConfigFiles(PackageBuildEnv<LinuxPackage, AppImageLayout> env) throws PackagerException, IOException {\n-        for (var ca : customActions) {\n-            ca.init(env.env(), env.pkg());\n-        }\n-\n-        Map<String, String> data = createDefaultReplacementData(env.env(), env.pkg());\n-\n-        for (var ca : customActions) {\n-            ShellCustomAction.mergeReplacementData(data, ca.instance.create());\n-        }\n-\n-        data.putAll(createReplacementData(env.env(), env.pkg()));\n-\n-        createConfigFiles(Collections.unmodifiableMap(data), env.env(), env.pkg());\n-    }\n-\n-    private void buildPackage(PackageBuildEnv<LinuxPackage, AppImageLayout> env) throws PackagerException, IOException {\n-        Path packageBundle = buildPackageBundle(env.env(), env.pkg(), env.outputDir());\n-\n-        verifyOutputBundle(env.env(), env.pkg(), packageBundle).stream()\n-                .filter(Objects::nonNull)\n-                .forEachOrdered(ex -> {\n-            Log.verbose(ex.getLocalizedMessage());\n-            Log.verbose(ex.getAdvice());\n-        });\n-    }\n-\n-    private List<String> getListOfNeededPackages(BuildEnv env) throws IOException {\n-\n-        final List<String> caPackages = customActions.stream()\n-                .map(ca -> ca.instance)\n-                .map(ShellCustomAction::requiredPackages)\n-                .flatMap(List::stream).toList();\n-\n-        final List<String> neededLibPackages;\n-        if (withFindNeededPackages) {\n-            LibProvidersLookup lookup = new LibProvidersLookup();\n-            initLibProvidersLookup(lookup);\n-\n-            neededLibPackages = lookup.execute(env.appImageDir());\n-        } else {\n-            neededLibPackages = Collections.emptyList();\n-            Log.info(I18N.getString(\"warning.foreign-app-image\"));\n-        }\n-\n-        \/\/ Merge all package lists together.\n-        \/\/ Filter out empty names, sort and remove duplicates.\n-        List<String> result = Stream.of(caPackages, neededLibPackages).flatMap(\n-                List::stream).filter(Predicate.not(String::isEmpty)).sorted().distinct().toList();\n-\n-        Log.verbose(String.format(\"Required packages: %s\", result));\n-\n-        return result;\n-    }\n-\n-    private Map<String, String> createDefaultReplacementData(BuildEnv env, LinuxPackage pkg) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n-\n-        data.put(\"APPLICATION_PACKAGE\", pkg.packageName());\n-        data.put(\"APPLICATION_VENDOR\", pkg.app().vendor());\n-        data.put(\"APPLICATION_VERSION\", pkg.version());\n-        data.put(\"APPLICATION_DESCRIPTION\", pkg.description());\n-\n-        String defaultDeps = String.join(\", \", getListOfNeededPackages(env));\n-        String customDeps = pkg.additionalDependencies().orElse(\"\");\n-        if (!customDeps.isEmpty() && !defaultDeps.isEmpty()) {\n-            customDeps = \", \" + customDeps;\n-        }\n-        data.put(\"PACKAGE_DEFAULT_DEPENDENCIES\", defaultDeps);\n-        data.put(\"PACKAGE_CUSTOM_DEPENDENCIES\", customDeps);\n-\n-        return data;\n+    public boolean supported(boolean runtimeInstaller) {\n+        return sysEnv().hasValue();\n@@ -208,20 +83,1 @@\n-    protected abstract List<ConfigException> verifyOutputBundle(\n-            BuildEnv env, LinuxPackage pkg, Path packageBundle);\n-\n-    protected abstract void initLibProvidersLookup(LibProvidersLookup libProvidersLookup);\n-\n-    protected abstract List<ToolValidator> getToolValidators();\n-\n-    protected abstract void doValidate(BuildEnv env, LinuxPackage pkg)\n-            throws ConfigException;\n-\n-    protected abstract Map<String, String> createReplacementData(\n-            BuildEnv env, LinuxPackage pkg) throws IOException;\n-\n-    protected abstract void createConfigFiles(\n-            Map<String, String> replacementData,\n-            BuildEnv env, LinuxPackage pkg) throws IOException;\n-\n-    protected abstract Path buildPackageBundle(\n-            BuildEnv env, LinuxPackage pkg, Path outputParentDir) throws\n-            PackagerException, IOException;\n+    protected abstract Result<? extends LinuxSystemEnvironment> sysEnv();\n@@ -230,2 +86,0 @@\n-    private boolean withFindNeededPackages;\n-    private final List<CustomActionInstance> customActions;\n@@ -233,14 +87,1 @@\n-    private static final class CustomActionInstance {\n-\n-        CustomActionInstance(ShellCustomActionFactory factory) {\n-            this.factory = factory;\n-        }\n-\n-        void init(BuildEnv env, Package pkg) throws IOException {\n-            instance = factory.create(env, pkg);\n-            Objects.requireNonNull(instance);\n-        }\n-\n-        private final ShellCustomActionFactory factory;\n-        ShellCustomAction instance;\n-    }\n+    static final Result<LinuxSystemEnvironment> SYS_ENV = LinuxSystemEnvironment.create();\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBundler.java","additions":25,"deletions":184,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.PackagerException;\n+\n+abstract class LinuxPackager<T extends LinuxPackage> implements Consumer<PackagingPipeline.Builder> {\n+\n+    LinuxPackager(BuildEnv env, T pkg, Path outputDir, LinuxSystemEnvironment sysEnv) {\n+        this.env = Objects.requireNonNull(env);\n+        this.pkg = Objects.requireNonNull(pkg);\n+        this.outputDir = Objects.requireNonNull(outputDir);\n+        this.withRequiredPackagesLookup = sysEnv.soLookupAvailable() && sysEnv.nativePackageType().equals(pkg.type());\n+\n+        customActions = List.of(\n+                DesktopIntegration.create(env, pkg),\n+                LinuxLaunchersAsServices.create(env, pkg));\n+    }\n+\n+    enum LinuxPackageTaskID implements TaskID {\n+        INIT_REQUIRED_PACKAGES,\n+        VERIFY_PACKAGE\n+    }\n+\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n+        pipelineBuilder.excludeDirFromCopying(outputDir)\n+                .task(PackageTaskID.CREATE_CONFIG_FILES)\n+                        .action(this::buildConfigFiles)\n+                        .add()\n+                .task(LinuxPackageTaskID.INIT_REQUIRED_PACKAGES)\n+                        .addDependencies(PrimaryTaskID.BUILD_APPLICATION_IMAGE, PrimaryTaskID.COPY_APP_IMAGE)\n+                        .addDependent(PackageTaskID.CREATE_CONFIG_FILES)\n+                        .action(this::initRequiredPackages)\n+                        .add()\n+                .task(LinuxPackageTaskID.VERIFY_PACKAGE)\n+                        .addDependencies(PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .addDependent(PrimaryTaskID.PACKAGE)\n+                        .action(this::verifyOutputPackage)\n+                        .add()\n+                .task(PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .action(this::buildPackage)\n+                        .add();\n+    }\n+\n+    protected final Path outputPackageFile() {\n+        return outputDir.resolve(pkg.packageFileNameWithSuffix());\n+    }\n+\n+    protected abstract void buildPackage() throws IOException;\n+\n+    protected abstract List<? extends Exception> findErrorsInOutputPackage() throws IOException;\n+\n+    protected abstract void createConfigFiles(Map<String, String> replacementData) throws IOException;\n+\n+    protected abstract Map<String, String> createReplacementData() throws IOException;\n+\n+    protected abstract void initLibProvidersLookup(LibProvidersLookup libProvidersLookup);\n+\n+    private void buildConfigFiles() throws PackagerException, IOException {\n+\n+        final var data = createDefaultReplacementData();\n+\n+        for (var ca : customActions) {\n+            ShellCustomAction.mergeReplacementData(data, ca.create());\n+        }\n+\n+        data.putAll(createReplacementData());\n+\n+        createConfigFiles(Collections.unmodifiableMap(data));\n+    }\n+\n+    private Map<String, String> createDefaultReplacementData() {\n+        Map<String, String> data = new HashMap<>();\n+\n+        data.put(\"APPLICATION_PACKAGE\", pkg.packageName());\n+        data.put(\"APPLICATION_VENDOR\", pkg.app().vendor());\n+        data.put(\"APPLICATION_VERSION\", pkg.version());\n+        data.put(\"APPLICATION_DESCRIPTION\", pkg.description());\n+\n+        String defaultDeps = String.join(\", \", requiredPackages);\n+        String customDeps = pkg.additionalDependencies().orElse(\"\");\n+        if (!customDeps.isEmpty() && !defaultDeps.isEmpty()) {\n+            customDeps = \", \" + customDeps;\n+        }\n+        data.put(\"PACKAGE_DEFAULT_DEPENDENCIES\", defaultDeps);\n+        data.put(\"PACKAGE_CUSTOM_DEPENDENCIES\", customDeps);\n+\n+        return data;\n+    }\n+\n+    private void initRequiredPackages() throws IOException {\n+\n+        final List<String> caPackages = customActions.stream()\n+                .map(ShellCustomAction::requiredPackages)\n+                .flatMap(List::stream).toList();\n+\n+        final List<String> neededLibPackages;\n+        if (withRequiredPackagesLookup) {\n+            neededLibPackages = findRequiredPackages();\n+        } else {\n+            neededLibPackages = Collections.emptyList();\n+            Log.info(I18N.getString(\"warning.foreign-app-image\"));\n+        }\n+\n+        \/\/ Merge all package lists together.\n+        \/\/ Filter out empty names, sort and remove duplicates.\n+        Stream.of(caPackages, neededLibPackages)\n+                .flatMap(List::stream)\n+                .filter(Predicate.not(String::isEmpty))\n+                .sorted().distinct().forEach(requiredPackages::add);\n+\n+        Log.verbose(String.format(\"Required packages: %s\", requiredPackages));\n+    }\n+\n+    private List<String> findRequiredPackages() throws IOException {\n+        var lookup = new LibProvidersLookup();\n+        initLibProvidersLookup(lookup);\n+        return lookup.execute(env.appImageDir());\n+    }\n+\n+    private void verifyOutputPackage() {\n+        final List<? extends Exception> errors;\n+        try {\n+            errors = findErrorsInOutputPackage();\n+        } catch (Exception ex) {\n+            \/\/ Ignore error as it is not critical. Just report it.\n+            Log.verbose(ex);\n+            return;\n+        }\n+\n+        for (var ex : errors) {\n+            Log.verbose(ex.getLocalizedMessage());\n+            if (ex instanceof ConfigException cfgEx) {\n+                Log.verbose(cfgEx.getAdvice());\n+            }\n+        }\n+    }\n+\n+    protected final BuildEnv env;\n+    protected final T pkg;\n+    protected final Path outputDir;\n+    private final boolean withRequiredPackagesLookup;\n+    private final List<String> requiredPackages = new ArrayList<>();\n+    private final List<ShellCustomAction> customActions;\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackager.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -30,4 +29,0 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n@@ -35,7 +30,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.DottedVersion;\n-import jdk.jpackage.internal.model.LinuxPackage;\n@@ -43,1 +31,0 @@\n-import jdk.jpackage.internal.model.Package;\n@@ -45,0 +32,2 @@\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.Result;\n@@ -47,11 +36,0 @@\n-\/**\n- * There are two command line options to configure license information for RPM\n- * packaging: --linux-rpm-license-type and --license-file. Value of\n- * --linux-rpm-license-type command line option configures \"License:\" section\n- * of RPM spec. Value of --license-file command line option specifies a license\n- * file to be added to the package. License file is a sort of documentation file\n- * but it will be installed even if user selects an option to install the\n- * package without documentation. --linux-rpm-license-type is the primary option\n- * to set license information. --license-file makes little sense in case of RPM\n- * packaging.\n- *\/\n@@ -60,7 +38,0 @@\n-    private static final String DEFAULT_SPEC_TEMPLATE = \"template.spec\";\n-\n-    public static final String TOOL_RPM = \"rpm\";\n-    public static final String TOOL_RPMBUILD = \"rpmbuild\";\n-    public static final DottedVersion TOOL_RPMBUILD_MIN_VERSION = DottedVersion.lazy(\n-            \"4.10\");\n-\n@@ -71,140 +42,0 @@\n-    @Override\n-    protected void doValidate(BuildEnv env, LinuxPackage pkg) throws ConfigException {\n-    }\n-\n-    private static ToolValidator createRpmbuildToolValidator() {\n-        Pattern pattern = Pattern.compile(\" (\\\\d+\\\\.\\\\d+)\");\n-        return new ToolValidator(TOOL_RPMBUILD).setMinimalVersion(\n-                TOOL_RPMBUILD_MIN_VERSION).setVersionParser(lines -> {\n-                    String versionString = lines.limit(1).collect(\n-                            Collectors.toList()).get(0);\n-                    Matcher matcher = pattern.matcher(versionString);\n-                    if (matcher.find()) {\n-                        return matcher.group(1);\n-                    }\n-                    return null;\n-                });\n-    }\n-\n-    @Override\n-    protected List<ToolValidator> getToolValidators() {\n-        return List.of(createRpmbuildToolValidator());\n-    }\n-\n-    protected void createConfigFiles(Map<String, String> replacementData,\n-            BuildEnv env, LinuxPackage pkg) throws IOException {\n-        Path specFile = specFile(env, pkg);\n-\n-        \/\/ prepare spec file\n-        env.createResource(DEFAULT_SPEC_TEMPLATE)\n-                .setCategory(I18N.getString(\"resource.rpm-spec-file\"))\n-                .setSubstitutionData(replacementData)\n-                .saveToFile(specFile);\n-    }\n-\n-    @Override\n-    protected Path buildPackageBundle(BuildEnv env, LinuxPackage pkg,\n-            Path outputParentDir) throws PackagerException, IOException {\n-        return buildRPM(env, pkg, outputParentDir);\n-    }\n-\n-    private static Path installPrefix(LinuxPackage pkg) {\n-        Path path = pkg.relativeInstallDir();\n-        if (!pkg.isInstallDirInUsrTree()) {\n-            path = path.getParent();\n-        }\n-        return Path.of(\"\/\").resolve(path);\n-    }\n-\n-    @Override\n-    protected Map<String, String> createReplacementData(BuildEnv env, LinuxPackage pkg) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n-\n-        data.put(\"APPLICATION_RELEASE\", pkg.release().orElseThrow());\n-        data.put(\"APPLICATION_PREFIX\", installPrefix(pkg).toString());\n-        data.put(\"APPLICATION_DIRECTORY\", Path.of(\"\/\").resolve(pkg.relativeInstallDir()).toString());\n-        data.put(\"APPLICATION_SUMMARY\", pkg.app().name());\n-        data.put(\"APPLICATION_LICENSE_TYPE\", ((LinuxRpmPackage)pkg).licenseType());\n-\n-        String licenseFile = pkg.licenseFile().map(v -> {\n-            return v.toAbsolutePath().normalize().toString();\n-        }).orElse(null);\n-        data.put(\"APPLICATION_LICENSE_FILE\", licenseFile);\n-        data.put(\"APPLICATION_GROUP\", pkg.category().orElse(\"\"));\n-\n-        data.put(\"APPLICATION_URL\", pkg.aboutURL().orElse(\"\"));\n-\n-        return data;\n-    }\n-\n-    @Override\n-    protected void initLibProvidersLookup(LibProvidersLookup libProvidersLookup) {\n-        libProvidersLookup.setPackageLookup(file -> {\n-            return Executor.of(TOOL_RPM,\n-                \"-q\", \"--queryformat\", \"%{name}\\\\n\",\n-                \"-q\", \"--whatprovides\", file.toString())\n-                .saveOutput(true).executeExpectSuccess().getOutput().stream();\n-        });\n-    }\n-\n-    @Override\n-    protected List<ConfigException> verifyOutputBundle(BuildEnv env, LinuxPackage pkg,\n-            Path packageBundle) {\n-        List<ConfigException> errors = new ArrayList<>();\n-\n-        String specFileName = specFile(env, pkg).getFileName().toString();\n-\n-        try {\n-            List<PackageProperty> properties = List.of(\n-                    new PackageProperty(\"Name\", pkg.packageName(),\n-                            \"APPLICATION_PACKAGE\", specFileName),\n-                    new PackageProperty(\"Version\", pkg.version(),\n-                            \"APPLICATION_VERSION\", specFileName),\n-                    new PackageProperty(\"Release\", pkg.release().orElseThrow(),\n-                            \"APPLICATION_RELEASE\", specFileName),\n-                    new PackageProperty(\"Arch\", pkg.arch(), null, specFileName));\n-\n-            List<String> actualValues = Executor.of(TOOL_RPM, \"-qp\", \"--queryformat\",\n-                    properties.stream().map(entry -> String.format(\"%%{%s}\",\n-                    entry.name)).collect(Collectors.joining(\"\\\\n\")),\n-                    packageBundle.toString()).saveOutput(true).executeExpectSuccess().getOutput();\n-\n-            Iterator<String> actualValuesIt = actualValues.iterator();\n-            properties.forEach(property -> errors.add(property.verifyValue(\n-                    actualValuesIt.next())));\n-        } catch (IOException ex) {\n-            \/\/ Ignore error as it is not critical. Just report it.\n-            Log.verbose(ex);\n-        }\n-\n-        return errors;\n-    }\n-\n-    private Path specFile(BuildEnv env, Package pkg) {\n-        return env.buildRoot().resolve(Path.of(\"SPECS\", pkg.packageName() + \".spec\"));\n-    }\n-\n-    private Path buildRPM(BuildEnv env, Package pkg, Path outdir) throws IOException {\n-\n-        Path rpmFile = outdir.toAbsolutePath().resolve(pkg.packageFileNameWithSuffix());\n-\n-        Log.verbose(I18N.format(\"message.outputting-bundle-location\", rpmFile.getParent()));\n-\n-        \/\/run rpmbuild\n-        Executor.of(TOOL_RPMBUILD,\n-                \"-bb\", specFile(env, pkg).toAbsolutePath().toString(),\n-                \"--define\", String.format(\"%%_sourcedir %s\",\n-                        env.appImageDir().toAbsolutePath()),\n-                \/\/ save result to output dir\n-                \"--define\", String.format(\"%%_rpmdir %s\", rpmFile.getParent()),\n-                \/\/ do not use other system directories to build as current user\n-                \"--define\", String.format(\"%%_topdir %s\",\n-                        env.buildRoot().toAbsolutePath()),\n-                \"--define\", String.format(\"%%_rpmfilename %s\", rpmFile.getFileName())\n-        ).executeExpectSuccess();\n-\n-        Log.verbose(I18N.format(\"message.output-bundle-location\", rpmFile.getParent()));\n-\n-        return rpmFile;\n-    }\n-\n@@ -222,2 +53,13 @@\n-    public boolean supported(boolean runtimeInstaller) {\n-        return OperatingSystem.isLinux() && (createRpmbuildToolValidator().validate() == null);\n+    public Path execute(Map<String, ? super Object> params, Path outputParentDir) throws PackagerException {\n+\n+        return Packager.<LinuxRpmPackage>build().outputDir(outputParentDir)\n+                .pkg(LinuxFromParams.RPM_PACKAGE.fetchFrom(params))\n+                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, pkg, outputDir) -> {\n+                    return new LinuxRpmPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n+                }).execute(LinuxPackagingPipeline.build());\n+    }\n+\n+    @Override\n+    protected Result<LinuxRpmSystemEnvironment> sysEnv() {\n+        return sysEnv;\n@@ -228,1 +70,4 @@\n-        return !LinuxDebBundler.isDebian();\n+        return sysEnv.value()\n+                .map(LinuxSystemEnvironment::nativePackageType)\n+                .map(StandardPackageType.LINUX_RPM::equals)\n+                .orElse(false);\n@@ -230,0 +75,2 @@\n+\n+    private final Result<LinuxRpmSystemEnvironment> sysEnv = LinuxRpmSystemEnvironment.create(SYS_ENV);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmBundler.java","additions":21,"deletions":174,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LinuxRpmPackage;\n+\n+\n+\/**\n+ * There are two command line options to configure license information for RPM\n+ * packaging: --linux-rpm-license-type and --license-file. Value of\n+ * --linux-rpm-license-type command line option configures \"License:\" section\n+ * of RPM spec. Value of --license-file command line option specifies a license\n+ * file to be added to the package. License file is a sort of documentation file\n+ * but it will be installed even if user selects an option to install the\n+ * package without documentation. --linux-rpm-license-type is the primary option\n+ * to set license information. --license-file makes little sense in case of RPM\n+ * packaging.\n+ *\/\n+final class LinuxRpmPackager extends LinuxPackager<LinuxRpmPackage> {\n+\n+    LinuxRpmPackager(BuildEnv env, LinuxRpmPackage pkg, Path outputDir, LinuxRpmSystemEnvironment sysEnv) {\n+        super(env, pkg, outputDir, sysEnv);\n+        this.sysEnv = Objects.requireNonNull(sysEnv);\n+    }\n+\n+    @Override\n+    protected void createConfigFiles(Map<String, String> replacementData) throws IOException {\n+        Path specFile = specFile();\n+\n+        \/\/ prepare spec file\n+        env.createResource(\"template.spec\")\n+                .setCategory(I18N.getString(\"resource.rpm-spec-file\"))\n+                .setSubstitutionData(replacementData)\n+                .saveToFile(specFile);\n+    }\n+\n+    @Override\n+    protected Map<String, String> createReplacementData() {\n+        Map<String, String> data = new HashMap<>();\n+\n+        data.put(\"APPLICATION_RELEASE\", pkg.release().orElseThrow());\n+        data.put(\"APPLICATION_PREFIX\", installPrefix().toString());\n+        data.put(\"APPLICATION_DIRECTORY\", Path.of(\"\/\").resolve(pkg.relativeInstallDir()).toString());\n+        data.put(\"APPLICATION_SUMMARY\", pkg.app().name());\n+        data.put(\"APPLICATION_LICENSE_TYPE\", pkg.licenseType());\n+\n+        String licenseFile = pkg.licenseFile().map(v -> {\n+            return v.toAbsolutePath().normalize().toString();\n+        }).orElse(null);\n+        data.put(\"APPLICATION_LICENSE_FILE\", licenseFile);\n+        data.put(\"APPLICATION_GROUP\", pkg.category().orElse(\"\"));\n+\n+        data.put(\"APPLICATION_URL\", pkg.aboutURL().orElse(\"\"));\n+\n+        return data;\n+    }\n+\n+    @Override\n+    protected void initLibProvidersLookup(LibProvidersLookup libProvidersLookup) {\n+        libProvidersLookup.setPackageLookup(file -> {\n+            return Executor.of(sysEnv.rpm().toString(),\n+                \"-q\", \"--queryformat\", \"%{name}\\\\n\",\n+                \"-q\", \"--whatprovides\", file.toString()\n+            ).saveOutput(true).executeExpectSuccess().getOutput().stream();\n+        });\n+    }\n+\n+    @Override\n+    protected List<? extends Exception> findErrorsInOutputPackage() throws IOException {\n+        List<ConfigException> errors = new ArrayList<>();\n+\n+        var specFileName = specFile().getFileName().toString();\n+\n+        var properties = List.of(\n+                new PackageProperty(\"Name\", pkg.packageName(),\n+                        \"APPLICATION_PACKAGE\", specFileName),\n+                new PackageProperty(\"Version\", pkg.version(),\n+                        \"APPLICATION_VERSION\", specFileName),\n+                new PackageProperty(\"Release\", pkg.release().orElseThrow(),\n+                        \"APPLICATION_RELEASE\", specFileName),\n+                new PackageProperty(\"Arch\", pkg.arch(), null, specFileName));\n+\n+        var actualValues = Executor.of(\n+                sysEnv.rpm().toString(),\n+                \"-qp\",\n+                \"--queryformat\", properties.stream().map(e -> String.format(\"%%{%s}\", e.name)).collect(joining(\"\\\\n\")),\n+                outputPackageFile().toString()\n+        ).saveOutput(true).executeExpectSuccess().getOutput();\n+\n+        for (int i = 0; i != properties.size(); i++) {\n+            Optional.ofNullable(properties.get(i).verifyValue(actualValues.get(i))).ifPresent(errors::add);\n+        }\n+\n+        return errors;\n+    }\n+\n+    @Override\n+    protected void buildPackage() throws IOException {\n+\n+        Path rpmFile = outputPackageFile();\n+\n+        Log.verbose(I18N.format(\"message.outputting-bundle-location\", rpmFile.getParent()));\n+\n+        \/\/run rpmbuild\n+        Executor.of(sysEnv.rpmbuild().toString(),\n+                \"-bb\", specFile().toAbsolutePath().toString(),\n+                \"--define\", String.format(\"%%_sourcedir %s\",\n+                        env.appImageDir().toAbsolutePath()),\n+                \/\/ save result to output dir\n+                \"--define\", String.format(\"%%_rpmdir %s\", rpmFile.getParent()),\n+                \/\/ do not use other system directories to build as current user\n+                \"--define\", String.format(\"%%_topdir %s\",\n+                        env.buildRoot().toAbsolutePath()),\n+                \"--define\", String.format(\"%%_rpmfilename %s\", rpmFile.getFileName())\n+        ).executeExpectSuccess();\n+\n+        Log.verbose(I18N.format(\"message.output-bundle-location\", rpmFile.getParent()));\n+    }\n+\n+    private Path installPrefix() {\n+        Path path = pkg.relativeInstallDir();\n+        if (!pkg.isInstallDirInUsrTree()) {\n+            path = path.getParent();\n+        }\n+        return Path.of(\"\/\").resolve(path);\n+    }\n+\n+    private Path specFile() {\n+        return env.buildRoot().resolve(Path.of(\"SPECS\", pkg.packageName() + \".spec\"));\n+    }\n+\n+    private final LinuxRpmSystemEnvironment sysEnv;\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmPackager.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.LinuxSystemEnvironment.mixin;\n+\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxRpmSystemEnvironment extends LinuxSystemEnvironment, LinuxRpmSystemEnvironmentMixin {\n+\n+    static Result<LinuxRpmSystemEnvironment> create(Result<LinuxSystemEnvironment> base) {\n+        return mixin(LinuxRpmSystemEnvironment.class, base, LinuxRpmSystemEnvironmentMixin::create);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmSystemEnvironment.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.model.DottedVersion;\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxRpmSystemEnvironmentMixin {\n+    Path rpm();\n+    Path rpmbuild();\n+\n+    record Stub(Path rpm, Path rpmbuild) implements LinuxRpmSystemEnvironmentMixin {\n+    }\n+\n+    static Result<LinuxRpmSystemEnvironmentMixin> create() {\n+\n+        final var errors = Stream.of(\n+                Internal.createRpmbuildToolValidator(),\n+                new ToolValidator(Internal.TOOL_RPM)\n+        ).map(ToolValidator::validate).filter(Objects::nonNull).toList();\n+\n+        if (errors.isEmpty()) {\n+            return Result.ofValue(new Stub(Internal.TOOL_RPM, Internal.TOOL_RPMBUILD));\n+        } else {\n+            return Result.ofErrors(errors);\n+        }\n+    }\n+\n+    static final class Internal {\n+        private static ToolValidator createRpmbuildToolValidator() {\n+            Pattern pattern = Pattern.compile(\" (\\\\d+\\\\.\\\\d+)\");\n+            return new ToolValidator(TOOL_RPMBUILD).setMinimalVersion(\n+                    TOOL_RPMBUILD_MIN_VERSION).setVersionParser(lines -> {\n+                        String versionString = lines.limit(1).findFirst().orElseThrow();\n+                        Matcher matcher = pattern.matcher(versionString);\n+                        if (matcher.find()) {\n+                            return matcher.group(1);\n+                        }\n+                        return null;\n+                    });\n+        }\n+\n+        private static final Path TOOL_RPM = Path.of(\"rpm\");\n+        private static final Path TOOL_RPMBUILD = Path.of(\"rpmbuild\");\n+        private static final DottedVersion TOOL_RPMBUILD_MIN_VERSION = DottedVersion.lazy(\"4.10\");\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmSystemEnvironmentMixin.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxSystemEnvironment extends SystemEnvironment {\n+    boolean soLookupAvailable();\n+    PackageType nativePackageType();\n+\n+    static Result<LinuxSystemEnvironment> create() {\n+        return detectNativePackageType().map(LinuxSystemEnvironment::create).orElseGet(() -> {\n+            return Result.ofError(new RuntimeException(\"Unknown native package type\"));\n+        });\n+    }\n+\n+    static Optional<PackageType> detectNativePackageType() {\n+        if (Internal.isDebian()) {\n+            return Optional.of(StandardPackageType.LINUX_DEB);\n+        } else if (Internal.isRpm()) {\n+            return Optional.of(StandardPackageType.LINUX_RPM);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    static Result<LinuxSystemEnvironment> create(PackageType nativePackageType) {\n+        return Result.ofValue(new Stub(LibProvidersLookup.supported(),\n+                Objects.requireNonNull(nativePackageType)));\n+    }\n+\n+    static <T, U extends LinuxSystemEnvironment> U createWithMixin(Class<U> type, LinuxSystemEnvironment base, T mixin) {\n+        return CompositeProxy.create(type, base, mixin);\n+    }\n+\n+    static <T, U extends LinuxSystemEnvironment> Result<U> mixin(Class<U> type,\n+            Result<LinuxSystemEnvironment> base, Supplier<Result<T>> mixinResultSupplier) {\n+        final var mixin = mixinResultSupplier.get();\n+\n+        final List<Exception> errors = new ArrayList<>();\n+        errors.addAll(base.errors());\n+        errors.addAll(mixin.errors());\n+\n+        if (errors.isEmpty()) {\n+            return Result.ofValue(createWithMixin(type, base.orElseThrow(), mixin.orElseThrow()));\n+        } else {\n+            return Result.ofErrors(errors);\n+        }\n+    }\n+\n+    record Stub(boolean soLookupAvailable, PackageType nativePackageType) implements LinuxSystemEnvironment {\n+    }\n+\n+    static final class Internal {\n+\n+        private static boolean isDebian() {\n+            \/\/ we are just going to run \"dpkg -s coreutils\" and assume Debian\n+            \/\/ or derivative if no error is returned.\n+            try {\n+                Executor.of(\"dpkg\", \"-s\", \"coreutils\").executeExpectSuccess();\n+                return true;\n+            } catch (IOException e) {\n+                \/\/ just fall thru\n+                return false;\n+            }\n+        }\n+\n+        private static boolean isRpm() {\n+            \/\/ we are just going to run \"rpm -q rpm\" and assume RPM\n+            \/\/ or derivative if no error is returned.\n+            try {\n+                Executor.of(\"rpm\", \"-q\", \"rpm\").executeExpectSuccess();\n+                return true;\n+            } catch (IOException e) {\n+                \/\/ just fall thru\n+                return false;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxSystemEnvironment.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.file.Files;\n@@ -32,0 +31,1 @@\n+import java.util.Optional;\n@@ -33,0 +33,1 @@\n+import jdk.jpackage.internal.model.MacDmgPackage;\n@@ -34,0 +35,1 @@\n+import jdk.jpackage.internal.util.Result;\n@@ -73,2 +75,1 @@\n-        final var pkg = MacFromParams.DMG_PACKAGE.fetchFrom(params);\n-        var env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+        var pkg = MacFromParams.DMG_PACKAGE.fetchFrom(params);\n@@ -76,1 +77,1 @@\n-        final var packager = MacDmgPackager.build().outputDir(outputParentDir).pkg(pkg).env(env);\n+        Log.verbose(I18N.format(\"message.building-dmg\", pkg.app().name()));\n@@ -78,3 +79,6 @@\n-        MacDmgPackager.findSetFileUtility().ifPresent(packager::setFileUtility);\n-\n-        return packager.execute();\n+        return Packager.<MacDmgPackage>build().outputDir(outputParentDir)\n+                .pkg(pkg)\n+                .env(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n+                    return new MacDmgPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n+                }).execute(MacPackagingPipeline.build(Optional.of(pkg)));\n@@ -85,17 +89,1 @@\n-        return isSupported();\n-    }\n-\n-    public static final String[] required =\n-            {\"\/usr\/bin\/hdiutil\", \"\/usr\/bin\/osascript\"};\n-    public static boolean isSupported() {\n-        try {\n-            for (String s : required) {\n-                Path f = Path.of(s);\n-                if (!Files.exists(f) || !Files.isExecutable(f)) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        } catch (Exception e) {\n-            return false;\n-        }\n+        return sysEnv.hasValue();\n@@ -108,0 +96,2 @@\n+\n+    private final Result<MacDmgSystemEnvironment> sysEnv = MacDmgSystemEnvironment.create();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":14,"deletions":24,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -39,2 +39,1 @@\n-import java.util.Optional;\n-import java.util.stream.Stream;\n+import java.util.function.Consumer;\n@@ -42,1 +41,0 @@\n-import jdk.jpackage.internal.PackagingPipeline.StartupParameters;\n@@ -45,1 +43,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -49,1 +46,2 @@\n-record MacDmgPackager(MacDmgPackage pkg, BuildEnv env, Path hdiutil, Path outputDir, Optional<Path> setFileUtility) {\n+record MacDmgPackager(BuildEnv env, MacDmgPackage pkg, Path outputDir,\n+        MacDmgSystemEnvironment sysEnv) implements Consumer<PackagingPipeline.Builder> {\n@@ -52,1 +50,0 @@\n-        Objects.requireNonNull(pkg);\n@@ -54,1 +51,1 @@\n-        Objects.requireNonNull(hdiutil);\n+        Objects.requireNonNull(pkg);\n@@ -56,5 +53,1 @@\n-        Objects.requireNonNull(setFileUtility);\n-    }\n-\n-    static Builder build() {\n-        return new Builder();\n+        Objects.requireNonNull(sysEnv);\n@@ -63,76 +56,2 @@\n-    static final class Builder extends PackagerBuilder<MacDmgPackage, Builder> {\n-\n-        Builder hdiutil(Path v) {\n-            hdiutil = v;\n-            return this;\n-        }\n-\n-        Builder setFileUtility(Path v) {\n-            setFileUtility = v;\n-            return this;\n-        }\n-\n-        Path execute() throws PackagerException {\n-            Log.verbose(MessageFormat.format(I18N.getString(\"message.building-dmg\"),\n-                    pkg.app().name()));\n-\n-            IOUtils.writableOutputDir(outputDir);\n-\n-            return execute(MacPackagingPipeline.build(Optional.of(pkg)));\n-        }\n-\n-        @Override\n-        protected void configurePackagingPipeline(PackagingPipeline.Builder pipelineBuilder,\n-                StartupParameters startupParameters) {\n-            final var packager = new MacDmgPackager(pkg, startupParameters.packagingEnv(),\n-                    validatedHdiutil(), outputDir, Optional.ofNullable(setFileUtility));\n-            packager.applyToPipeline(pipelineBuilder);\n-        }\n-\n-        private Path validatedHdiutil() {\n-            return Optional.ofNullable(hdiutil).orElse(HDIUTIL);\n-        }\n-\n-        private Path hdiutil;\n-        private Path setFileUtility;\n-    }\n-\n-    \/\/ Location of SetFile utility may be different depending on MacOS version\n-    \/\/ We look for several known places and if none of them work will\n-    \/\/ try to find it\n-    static Optional<Path> findSetFileUtility() {\n-        String typicalPaths[] = {\"\/Developer\/Tools\/SetFile\",\n-                \"\/usr\/bin\/SetFile\", \"\/Developer\/usr\/bin\/SetFile\"};\n-\n-        final var setFilePath = Stream.of(typicalPaths).map(Path::of).filter(Files::isExecutable).findFirst();\n-        if (setFilePath.isPresent()) {\n-            \/\/ Validate SetFile, if Xcode is not installed it will run, but exit with error\n-            \/\/ code\n-            try {\n-                if (Executor.of(setFilePath.orElseThrow().toString(), \"-h\").setQuiet(true).execute() == 0) {\n-                    return setFilePath;\n-                }\n-            } catch (Exception ignored) {\n-                \/\/ No need for generic find attempt. We found it, but it does not work.\n-                \/\/ Probably due to missing xcode.\n-                return Optional.empty();\n-            }\n-        }\n-\n-        \/\/ generic find attempt\n-        try {\n-            final var executor = Executor.of(\"\/usr\/bin\/xcrun\", \"-find\", \"SetFile\");\n-            final var code = executor.setQuiet(true).saveOutput(true).execute();\n-            if (code == 0 && executor.getOutput().isEmpty()) {\n-                final var firstLine = executor.getOutput().getFirst();\n-                Path f = Path.of(firstLine);\n-                if (Files.exists(f) && Files.isExecutable(f)) {\n-                    return Optional.of(f.toAbsolutePath());\n-                }\n-            }\n-        } catch (IOException ignored) {}\n-\n-        return Optional.empty();\n-    }\n-\n-    private void applyToPipeline(PackagingPipeline.Builder pipelineBuilder) {\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n@@ -321,1 +240,1 @@\n-                hdiutil.toString(),\n+                sysEnv.hdiutil().toString(),\n@@ -344,1 +263,1 @@\n-                hdiutil.toString(),\n+                sysEnv.hdiutil().toString(),\n@@ -360,1 +279,1 @@\n-                hdiutil.toString(),\n+                sysEnv.hdiutil().toString(),\n@@ -385,1 +304,1 @@\n-                pb = new ProcessBuilder(\"\/usr\/bin\/osascript\",\n+                pb = new ProcessBuilder(sysEnv.osascript().toString(),\n@@ -400,1 +319,1 @@\n-            if (setFileUtility.isPresent()) {\n+            if (sysEnv.setFileUtility().isPresent()) {\n@@ -409,1 +328,1 @@\n-                            setFileUtility.orElseThrow().toString(),\n+                            sysEnv.setFileUtility().orElseThrow().toString(),\n@@ -416,1 +335,1 @@\n-                            setFileUtility.orElseThrow().toString(),\n+                            sysEnv.setFileUtility().orElseThrow().toString(),\n@@ -431,1 +350,1 @@\n-                    hdiutil.toString(),\n+                    sysEnv.hdiutil().toString(),\n@@ -454,1 +373,1 @@\n-                                hdiutil.toString(),\n+                                sysEnv.hdiutil().toString(),\n@@ -467,1 +386,1 @@\n-                hdiutil.toString(),\n+                sysEnv.hdiutil().toString(),\n@@ -484,1 +403,1 @@\n-                        hdiutil.toString(),\n+                        sysEnv.hdiutil().toString(),\n@@ -499,1 +418,1 @@\n-                    hdiutil.toString(),\n+                    sysEnv.hdiutil().toString(),\n@@ -530,2 +449,0 @@\n-\n-    private static final Path HDIUTIL = Path.of(\"\/usr\/bin\/hdiutil\");\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackager.java","additions":19,"deletions":102,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.Result;\n+\n+record MacDmgSystemEnvironment(Path hdiutil, Path osascript, Optional<Path> setFileUtility) implements SystemEnvironment {\n+\n+    MacDmgSystemEnvironment {\n+    }\n+\n+    static Result<MacDmgSystemEnvironment> create() {\n+        final var errors = Stream.of(HDIUTIL, OSASCRIPT)\n+                .map(ToolValidator::new)\n+                .map(ToolValidator::checkExistsOnly)\n+                .map(ToolValidator::validate)\n+                .filter(Objects::nonNull)\n+                .toList();\n+        if (errors.isEmpty()) {\n+            return Result.ofValue(new MacDmgSystemEnvironment(HDIUTIL, OSASCRIPT, findSetFileUtility()));\n+        } else {\n+            return Result.ofErrors(errors);\n+        }\n+    }\n+\n+    \/\/ Location of SetFile utility may be different depending on MacOS version\n+    \/\/ We look for several known places and if none of them work will\n+    \/\/ try to find it\n+    private static Optional<Path> findSetFileUtility() {\n+        String typicalPaths[] = {\"\/Developer\/Tools\/SetFile\",\n+                \"\/usr\/bin\/SetFile\", \"\/Developer\/usr\/bin\/SetFile\"};\n+\n+        final var setFilePath = Stream.of(typicalPaths).map(Path::of).filter(Files::isExecutable).findFirst();\n+        if (setFilePath.isPresent()) {\n+            \/\/ Validate SetFile, if Xcode is not installed it will run, but exit with error\n+            \/\/ code\n+            try {\n+                if (Executor.of(setFilePath.orElseThrow().toString(), \"-h\").setQuiet(true).execute() == 0) {\n+                    return setFilePath;\n+                }\n+            } catch (Exception ignored) {\n+                \/\/ No need for generic find attempt. We found it, but it does not work.\n+                \/\/ Probably due to missing xcode.\n+                return Optional.empty();\n+            }\n+        }\n+\n+        \/\/ generic find attempt\n+        try {\n+            final var executor = Executor.of(\"\/usr\/bin\/xcrun\", \"-find\", \"SetFile\");\n+            final var code = executor.setQuiet(true).saveOutput(true).execute();\n+            if (code == 0 && !executor.getOutput().isEmpty()) {\n+                final var firstLine = executor.getOutput().getFirst();\n+                Path f = Path.of(firstLine);\n+                if (new ToolValidator(f).checkExistsOnly().validate() == null) {\n+                    return Optional.of(f.toAbsolutePath());\n+                }\n+            }\n+        } catch (IOException ignored) {}\n+\n+        return Optional.empty();\n+    }\n+\n+    private static final Path HDIUTIL = Path.of(\"\/usr\/bin\/hdiutil\");\n+    private static final Path OSASCRIPT = Path.of(\"\/usr\/bin\/osascript\");\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgSystemEnvironment.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -32,0 +33,1 @@\n+import jdk.jpackage.internal.model.MacPkgPackage;\n@@ -52,1 +54,1 @@\n-            final var pkgPkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n+            final var pkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n@@ -75,2 +77,1 @@\n-        final var pkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n-        var env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+        var pkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n@@ -78,1 +79,1 @@\n-        final var packager = MacPkgPackager.build().outputDir(outputParentDir).pkg(pkg).env(env);\n+        Log.verbose(I18N.format(\"message.building-pkg\", pkg.app().name()));\n@@ -80,1 +81,6 @@\n-        return packager.execute();\n+        return Packager.<MacPkgPackage>build().outputDir(outputParentDir)\n+                .pkg(pkg)\n+                .env(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n+                    return new MacPkgPackager(env, pkg, outputDir);\n+                }).execute(MacPackagingPipeline.build(Optional.of(pkg)));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.function.Consumer;\n@@ -55,1 +56,0 @@\n-import jdk.jpackage.internal.PackagingPipeline.StartupParameters;\n@@ -58,1 +58,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -63,1 +62,13 @@\n-record MacPkgPackager(MacPkgPackage pkg, BuildEnv env, Optional<Services> services, Path outputDir) {\n+record MacPkgPackager(BuildEnv env, MacPkgPackage pkg, Optional<Services> services,\n+        Path outputDir) implements Consumer<PackagingPipeline.Builder> {\n+\n+    MacPkgPackager {\n+        Objects.requireNonNull(env);\n+        Objects.requireNonNull(pkg);\n+        Objects.requireNonNull(services);\n+        Objects.requireNonNull(outputDir);\n+    }\n+\n+    MacPkgPackager(BuildEnv env, MacPkgPackage pkg, Path outputDir) {\n+        this(env, pkg, createServices(env, pkg), outputDir);\n+    }\n@@ -72,31 +83,0 @@\n-    static Builder build() {\n-        return new Builder();\n-    }\n-\n-    static final class Builder extends PackagerBuilder<MacPkgPackage, Builder> {\n-\n-        Path execute() throws PackagerException {\n-            Log.verbose(MessageFormat.format(I18N.getString(\"message.building-pkg\"),\n-                    pkg.app().name()));\n-\n-            IOUtils.writableOutputDir(outputDir);\n-\n-            return execute(MacPackagingPipeline.build(Optional.of(pkg)));\n-        }\n-\n-        @Override\n-        protected void configurePackagingPipeline(PackagingPipeline.Builder pipelineBuilder,\n-                StartupParameters startupParameters) {\n-            final var packager = new MacPkgPackager(pkg, startupParameters.packagingEnv(), createServices(), outputDir);\n-            packager.applyToPipeline(pipelineBuilder);\n-        }\n-\n-        private Optional<Services> createServices() {\n-            if (pkg.app().isService()) {\n-                return Optional.of(Services.create(pkg, env));\n-            } else {\n-                return Optional.empty();\n-            }\n-        }\n-    }\n-\n@@ -233,1 +213,2 @@\n-    private void applyToPipeline(PackagingPipeline.Builder pipelineBuilder) {\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n@@ -562,0 +543,8 @@\n+    private static Optional<Services> createServices(BuildEnv env, MacPkgPackage pkg) {\n+        if (pkg.app().isService()) {\n+            return Optional.of(Services.create(pkg, env));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgPackager.java","additions":24,"deletions":35,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.PackagerException;\n+\n+final class Packager<T extends Package> {\n+\n+    static <T extends Package> Packager<T> build() {\n+        return new Packager<>();\n+    }\n+\n+    Packager<T> pkg(T v) {\n+        pkg = v;\n+        return this;\n+    }\n+\n+    Packager<T> env(BuildEnv v) {\n+        env = v;\n+        return this;\n+    }\n+\n+    Packager<T> outputDir(Path v) {\n+        outputDir = v;\n+        return this;\n+    }\n+\n+    Packager<T> pipelineBuilderMutatorFactory(PipelineBuilderMutatorFactory<T> v) {\n+        pipelineBuilderMutatorFactory = v;\n+        return this;\n+    }\n+\n+    T pkg() {\n+        return Objects.requireNonNull(pkg);\n+    }\n+\n+    Path outputDir() {\n+        return Objects.requireNonNull(outputDir);\n+    }\n+\n+    BuildEnv env() {\n+        return Objects.requireNonNull(env);\n+    }\n+\n+    Path execute(PackagingPipeline.Builder pipelineBuilder) throws PackagerException {\n+        Objects.requireNonNull(pkg);\n+        Objects.requireNonNull(env);\n+        Objects.requireNonNull(outputDir);\n+\n+        IOUtils.writableOutputDir(outputDir);\n+\n+        final var startupParameters = pipelineBuilder.createStartupParameters(env, pkg, outputDir);\n+\n+        pipelineBuilderMutatorFactory().ifPresent(factory -> {\n+            factory.create(startupParameters.packagingEnv(), pkg, outputDir).accept(pipelineBuilder);\n+        });\n+\n+        pipelineBuilder.create().execute(startupParameters);\n+\n+        return outputDir.resolve(pkg.packageFileNameWithSuffix());\n+    }\n+\n+\n+    @FunctionalInterface\n+    interface PipelineBuilderMutatorFactory<T extends Package> {\n+        Consumer<PackagingPipeline.Builder> create(BuildEnv env, T pkg, Path outputDir);\n+    }\n+\n+\n+    private Optional<PipelineBuilderMutatorFactory<T>> pipelineBuilderMutatorFactory() {\n+        return Optional.ofNullable(pipelineBuilderMutatorFactory);\n+    }\n+\n+    private T pkg;\n+    private BuildEnv env;\n+    private Path outputDir;\n+    private PipelineBuilderMutatorFactory<T> pipelineBuilderMutatorFactory;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Packager.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import jdk.jpackage.internal.PackagingPipeline.StartupParameters;\n-import jdk.jpackage.internal.model.Package;\n-import jdk.jpackage.internal.model.PackagerException;\n-\n-abstract class PackagerBuilder<T extends Package, U extends PackagerBuilder<T, U>> {\n-\n-    U pkg(T v) {\n-        pkg = v;\n-        return thiz();\n-    }\n-\n-    U env(BuildEnv v) {\n-        env = v;\n-        return thiz();\n-    }\n-\n-    U outputDir(Path v) {\n-        outputDir = v;\n-        return thiz();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private U thiz() {\n-        return (U)this;\n-    }\n-\n-    protected abstract void configurePackagingPipeline(PackagingPipeline.Builder pipelineBuilder,\n-            StartupParameters startupParameters);\n-\n-    Path execute(PackagingPipeline.Builder pipelineBuilder) throws PackagerException {\n-        Objects.requireNonNull(pkg);\n-        Objects.requireNonNull(env);\n-        Objects.requireNonNull(outputDir);\n-\n-        final var startupParameters = pipelineBuilder.createStartupParameters(env, pkg, outputDir);\n-\n-        configurePackagingPipeline(pipelineBuilder, startupParameters);\n-\n-        pipelineBuilder.create().execute(startupParameters);\n-\n-        return outputDir.resolve(pkg.packageFileNameWithSuffix());\n-    }\n-\n-    protected T pkg;\n-    protected BuildEnv env;\n-    protected Path outputDir;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagerBuilder.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+public interface SystemEnvironment {\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/SystemEnvironment.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -27,3 +27,0 @@\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.DottedVersion;\n@@ -31,0 +28,1 @@\n+import java.nio.file.Files;\n@@ -32,1 +30,0 @@\n-import java.text.MessageFormat;\n@@ -35,1 +32,1 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.Objects;\n@@ -39,0 +36,3 @@\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.DottedVersion;\n@@ -41,1 +41,1 @@\n-public final class ToolValidator {\n+final class ToolValidator {\n@@ -48,3 +48,1 @@\n-        this.toolPath = toolPath;\n-        args = new ArrayList<>();\n-\n+        this.toolPath = Objects.requireNonNull(toolPath);\n@@ -54,3 +52,0 @@\n-\n-        setToolNotFoundErrorHandler(null);\n-        setToolOldVersionErrorHandler(null);\n@@ -70,1 +65,11 @@\n-        return setMinimalVersion(t -> DottedVersion.compareComponents(v, DottedVersion.lazy(t)));\n+        return setMinimalVersion(new Comparable<String>() {\n+            @Override\n+            public int compareTo(String o) {\n+                return DottedVersion.compareComponents(v, DottedVersion.lazy(o));\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return v.toString();\n+            }\n+        });\n@@ -78,2 +83,1 @@\n-    ToolValidator setToolNotFoundErrorHandler(\n-            BiFunction<String, IOException, ConfigException> v) {\n+    ToolValidator setToolNotFoundErrorHandler(Function<Path, ConfigException> v) {\n@@ -84,1 +88,1 @@\n-    ToolValidator setToolOldVersionErrorHandler(BiFunction<String, String, ConfigException> v) {\n+    ToolValidator setToolOldVersionErrorHandler(BiFunction<Path, String, ConfigException> v) {\n@@ -89,0 +93,9 @@\n+    ToolValidator checkExistsOnly(boolean v) {\n+        checkExistsOnly = v;\n+        return this;\n+    }\n+\n+    ToolValidator checkExistsOnly() {\n+        return checkExistsOnly(true);\n+    }\n+\n@@ -90,0 +103,15 @@\n+        if (checkExistsOnly) {\n+            if (Files.isExecutable(toolPath) && !Files.isDirectory(toolPath)) {\n+                return null;\n+            } else if (Files.exists(toolPath)) {\n+                return new ConfigException(\n+                        I18N.format(\"error.tool-not-executable\", toolPath), (String)null);\n+            } else if (toolNotFoundErrorHandler != null) {\n+                return toolNotFoundErrorHandler.apply(toolPath);\n+            } else {\n+                return new ConfigException(\n+                        I18N.format(\"error.tool-not-found\", toolPath),\n+                        I18N.format(\"error.tool-not-found.advice\", toolPath));\n+            }\n+        }\n+\n@@ -92,1 +120,3 @@\n-        cmdline.addAll(args);\n+        if (args != null) {\n+            cmdline.addAll(args);\n+        }\n@@ -94,8 +124,5 @@\n-        String name = IOUtils.getFileName(toolPath).toString();\n-        try {\n-            ProcessBuilder pb = new ProcessBuilder(cmdline);\n-            AtomicBoolean canUseTool = new AtomicBoolean();\n-            if (minimalVersion == null) {\n-                \/\/ No version check.\n-                canUseTool.setPlain(true);\n-            }\n+        boolean canUseTool[] = new boolean[1];\n+        if (minimalVersion == null) {\n+            \/\/ No version check.\n+            canUseTool[0] = true;\n+        }\n@@ -103,2 +130,4 @@\n-            String[] version = new String[1];\n-            Executor.of(pb).setQuiet(true).setOutputConsumer(lines -> {\n+        String[] version = new String[1];\n+\n+        try {\n+            Executor.of(cmdline.toArray(String[]::new)).setQuiet(true).setOutputConsumer(lines -> {\n@@ -107,2 +136,2 @@\n-                    if (minimalVersion.compareTo(version[0]) < 0) {\n-                        canUseTool.setPlain(true);\n+                    if (version[0] != null && minimalVersion.compareTo(version[0]) <= 0) {\n+                        canUseTool[0] = true;\n@@ -112,11 +141,0 @@\n-\n-            if (!canUseTool.getPlain()) {\n-                if (toolOldVersionErrorHandler != null) {\n-                    return toolOldVersionErrorHandler.apply(name, version[0]);\n-                }\n-                return new ConfigException(MessageFormat.format(I18N.getString(\n-                        \"error.tool-old-version\"), name, minimalVersion),\n-                        MessageFormat.format(I18N.getString(\n-                                \"error.tool-old-version.advice\"), name,\n-                                minimalVersion));\n-            }\n@@ -124,7 +142,1 @@\n-            if (toolNotFoundErrorHandler != null) {\n-                return toolNotFoundErrorHandler.apply(name, e);\n-            }\n-            return new ConfigException(MessageFormat.format(I18N.getString(\n-                    \"error.tool-not-found\"), name, e.getMessage()),\n-                    MessageFormat.format(I18N.getString(\n-                            \"error.tool-not-found.advice\"), name), e);\n+            return new ConfigException(I18N.format(\"error.tool-error\", toolPath, e.getMessage()), null, e);\n@@ -133,2 +145,10 @@\n-        \/\/ All good. Tool can be used.\n-        return null;\n+        if (canUseTool[0]) {\n+            \/\/ All good. Tool can be used.\n+            return null;\n+        } else if (toolOldVersionErrorHandler != null) {\n+            return toolOldVersionErrorHandler.apply(toolPath, version[0]);\n+        } else {\n+            return new ConfigException(\n+                    I18N.format(\"error.tool-old-version\", toolPath, minimalVersion),\n+                    I18N.format(\"error.tool-old-version.advice\", toolPath, minimalVersion));\n+        }\n@@ -141,2 +161,3 @@\n-    private BiFunction<String, IOException, ConfigException> toolNotFoundErrorHandler;\n-    private BiFunction<String, String, ConfigException> toolOldVersionErrorHandler;\n+    private Function<Path, ConfigException> toolNotFoundErrorHandler;\n+    private BiFunction<Path, String, ConfigException> toolOldVersionErrorHandler;\n+    private boolean checkExistsOnly;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ToolValidator.java","additions":72,"deletions":51,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -69,4 +69,7 @@\n-error.tool-not-found=Can not find {0}. Reason: {1}\n-error.tool-not-found.advice=Please install {0}\n-error.tool-old-version=Can not find {0} {1} or newer\n-error.tool-old-version.advice=Please install {0} {1} or newer\n+error.tool-error=Can not validate \"{0}\". Reason: {1}\n+error.tool-not-executable=\"{0}\" is not executable\n+error.tool-not-found=Can not find \"{0}\"\n+error.tool-not-found.advice=Please install \"{0}\"\n+error.tool-old-version=Can not find \"{0}\" {1} or newer\n+error.tool-old-version.advice=Please install \"{0}\" {1} or newer\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.StreamSupport;\n+\n+\n+public record Result<T>(Optional<T> value, Collection<? extends Exception> errors) {\n+    public Result {\n+        if (value.isEmpty() == errors.isEmpty()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        if (value.isEmpty() && errors.isEmpty()) {\n+            throw new IllegalArgumentException(\"Error collection must be non-empty\");\n+        }\n+\n+    }\n+\n+    public T orElseThrow() {\n+        firstError().ifPresent(ex -> {\n+            rethrowUnchecked(ex);\n+        });\n+        return value.orElseThrow();\n+    }\n+\n+    public boolean hasValue() {\n+        return value.isPresent();\n+    }\n+\n+    public boolean hasErrors() {\n+        return !errors.isEmpty();\n+    }\n+\n+    public <U> Result<U> map(Function<T, U> conv) {\n+        return new Result<>(value.map(conv), errors);\n+    }\n+\n+    public <U> Result<U> flatMap(Function<T, Result<U>> conv) {\n+        return value.map(conv).orElseGet(() -> {\n+            return new Result<>(Optional.empty(), errors);\n+        });\n+    }\n+\n+    public Result<T> mapErrors(UnaryOperator<Collection<? extends Exception>> errorsMapper) {\n+        return new Result<>(value, errorsMapper.apply(errors));\n+    }\n+\n+    public <U> Result<U> mapErrors() {\n+        return new Result<>(Optional.empty(), errors);\n+    }\n+\n+    public Result<T> peekErrors(Consumer<Collection<? extends Exception>> consumer) {\n+        if (hasErrors()) {\n+            consumer.accept(errors);\n+        }\n+        return this;\n+    }\n+\n+    public Result<T> peekValue(Consumer<T> consumer) {\n+        value.ifPresent(consumer);\n+        return this;\n+    }\n+\n+    public Optional<? extends Exception> firstError() {\n+        return errors.stream().findFirst();\n+    }\n+\n+    public static <T> Result<T> create(Supplier<T> supplier) {\n+        try {\n+            return ofValue(supplier.get());\n+        } catch (Exception ex) {\n+            return ofError(ex);\n+        }\n+    }\n+\n+    public static <T> Result<T> ofValue(T value) {\n+        return new Result<>(Optional.of(value), List.of());\n+    }\n+\n+    public static <T> Result<T> ofErrors(Collection<? extends Exception> errors) {\n+        return new Result<>(Optional.empty(), List.copyOf(errors));\n+    }\n+\n+    public static <T> Result<T> ofError(Exception error) {\n+        return ofErrors(List.of(error));\n+    }\n+\n+    public static boolean allHaveValues(Iterable<? extends Result<?>> results) {\n+        return StreamSupport.stream(results.spliterator(), false).allMatch(Result::hasValue);\n+    }\n+\n+    public static boolean allHaveValues(Result<?>... results) {\n+        return allHaveValues(List.of(results));\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/Result.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -27,5 +27,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n@@ -33,1 +28,0 @@\n-import java.nio.file.StandardCopyOption;\n@@ -37,1 +31,1 @@\n-import jdk.jpackage.internal.model.WinExePackage;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n@@ -82,1 +76,1 @@\n-        var pkg = WinFromParams.MSI_PACKAGE.fetchFrom(params);\n+        var pkg = WinFromParams.EXE_PACKAGE.fetchFrom(params);\n@@ -85,22 +79,11 @@\n-        IOUtils.writableOutputDir(outdir);\n-\n-        Path msiDir = env.buildRoot().resolve(\"msi\");\n-        toRunnable(() -> Files.createDirectories(msiDir)).run();\n-\n-        \/\/ Write msi to temporary directory.\n-        Path msi = msiBundler.execute(params, msiDir);\n-\n-        try {\n-            new ScriptRunner()\n-            .setDirectory(msi.getParent())\n-            .setResourceCategoryId(\"resource.post-msi-script\")\n-            .setScriptNameSuffix(\"post-msi\")\n-            .setEnvironmentVariable(\"JpMsiFile\", msi.toAbsolutePath().toString())\n-            .run(env, pkg.packageName());\n-\n-            var exePkg = new WinExePackageBuilder(pkg).icon(ICON.fetchFrom(params)).create();\n-            return buildEXE(env, exePkg, msi, outdir);\n-        } catch (IOException|ConfigException ex) {\n-            Log.verbose(ex);\n-            throw new PackagerException(ex);\n-        }\n+        var msiOutputDir = env.buildRoot().resolve(\"msi\");\n+\n+        return Packager.<WinMsiPackage>build().outputDir(msiOutputDir)\n+                .pkg(pkg.msiPackage())\n+                .env(env)\n+                .pipelineBuilderMutatorFactory((packagingEnv, msiPackage, _) -> {\n+                    var msiPackager = new WinMsiPackager(packagingEnv, msiPackage,\n+                            msiOutputDir, msiBundler.sysEnv.orElseThrow());\n+                    var exePackager = new WinExePackager(packagingEnv, pkg, outdir, msiOutputDir);\n+                    return msiPackager.andThen(exePackager);\n+                }).execute(WinPackagingPipeline.build());\n@@ -109,28 +92,1 @@\n-    private Path buildEXE(BuildEnv env, WinExePackage pkg, Path msi,\n-            Path outdir) throws IOException {\n-\n-        Log.verbose(I18N.format(\"message.outputting-to-location\", outdir.toAbsolutePath()));\n-\n-        \/\/ Copy template msi wrapper next to msi file\n-        final Path exePath = msi.getParent().resolve(pkg.packageFileNameWithSuffix());\n-\n-        env.createResource(\"msiwrapper.exe\")\n-                .setCategory(I18N.getString(\"resource.installer-exe\"))\n-                .setPublicName(\"installer.exe\")\n-                .saveToFile(exePath);\n-\n-        new ExecutableRebrander(pkg, env::createResource, resourceLock -> {\n-            \/\/ Embed msi in msi wrapper exe.\n-            embedMSI(resourceLock, msi.toAbsolutePath().toString());\n-        }).execute(env, exePath, pkg.icon());\n-\n-        Path dstExePath = outdir.resolve(exePath.getFileName());\n-\n-        Files.copy(exePath, dstExePath, StandardCopyOption.REPLACE_EXISTING);\n-\n-        dstExePath.toFile().setExecutable(true);\n-\n-        Log.verbose(I18N.format(\"message.output-location\", outdir.toAbsolutePath()));\n-\n-        return dstExePath;\n-    }\n+    static native int embedMSI(long resourceLock, String msiPath);\n@@ -139,2 +95,0 @@\n-\n-    private static native int embedMSI(long resourceLock, String msiPath);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":14,"deletions":60,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.WinExePackage;\n+\n+final record WinExePackager(BuildEnv env, WinExePackage pkg, Path outputDir, Path msiOutputDir) implements Consumer<PackagingPipeline.Builder> {\n+\n+    WinExePackager {\n+        Objects.requireNonNull(env);\n+        Objects.requireNonNull(pkg);\n+        Objects.requireNonNull(outputDir);\n+        Objects.requireNonNull(msiOutputDir);\n+    }\n+\n+    enum ExePackageTaskID implements TaskID {\n+        RUN_POST_MSI_USER_SCRIPT,\n+        WRAP_MSI_IN_EXE\n+    }\n+\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n+        pipelineBuilder.excludeDirFromCopying(outputDir)\n+                .task(ExePackageTaskID.RUN_POST_MSI_USER_SCRIPT)\n+                        .action(this::runPostMsiScript)\n+                        .addDependency(PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .add()\n+                .task(ExePackageTaskID.WRAP_MSI_IN_EXE)\n+                        .action(this::wrapMsiInExe)\n+                        .addDependency(ExePackageTaskID.RUN_POST_MSI_USER_SCRIPT)\n+                        .addDependent(PrimaryTaskID.PACKAGE)\n+                        .add();\n+    }\n+\n+    private Path msi() {\n+        return msiOutputDir.resolve(pkg.msiPackage().packageFileNameWithSuffix());\n+    }\n+\n+    private void runPostMsiScript() throws IOException {\n+        new ScriptRunner()\n+        .setDirectory(msiOutputDir)\n+        .setResourceCategoryId(\"resource.post-msi-script\")\n+        .setScriptNameSuffix(\"post-msi\")\n+        .setEnvironmentVariable(\"JpMsiFile\", msi().toAbsolutePath().toString())\n+        .run(env, pkg.msiPackage().packageName());\n+    }\n+\n+    private void wrapMsiInExe() throws IOException {\n+\n+        Log.verbose(I18N.format(\"message.outputting-to-location\", outputDir.toAbsolutePath()));\n+\n+        final var msi = msi();\n+\n+        \/\/ Copy template msi wrapper next to msi file\n+        final Path exePath = msi.getParent().resolve(pkg.packageFileNameWithSuffix());\n+\n+        env.createResource(\"msiwrapper.exe\")\n+                .setCategory(I18N.getString(\"resource.installer-exe\"))\n+                .setPublicName(\"installer.exe\")\n+                .saveToFile(exePath);\n+\n+        new ExecutableRebrander(pkg, env::createResource, resourceLock -> {\n+            \/\/ Embed msi in msi wrapper exe.\n+            WinExeBundler.embedMSI(resourceLock, msi.toAbsolutePath().toString());\n+        }).execute(env, exePath, pkg.icon());\n+\n+        Path dstExePath = outputDir.resolve(exePath.getFileName());\n+\n+        Files.createDirectories(dstExePath.getParent());\n+        Files.copy(exePath, dstExePath, StandardCopyOption.REPLACE_EXISTING);\n+\n+        dstExePath.toFile().setExecutable(true);\n+\n+        Log.verbose(I18N.format(\"message.output-location\", outputDir.toAbsolutePath()));\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExePackager.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n@@ -44,0 +45,1 @@\n+import jdk.jpackage.internal.model.WinExePackage;\n@@ -102,0 +104,11 @@\n+    private static WinExePackage createWinExePackage(Map<String, ? super Object> params) throws ConfigException, IOException {\n+\n+        final var msiPkg = MSI_PACKAGE.fetchFrom(params);\n+\n+        final var pkgBuilder = new WinExePackageBuilder(msiPkg);\n+\n+        ICON.copyInto(params, pkgBuilder::icon);\n+\n+        return pkgBuilder.create();\n+    }\n+\n@@ -108,0 +121,3 @@\n+    static final BundlerParamInfo<WinExePackage> EXE_PACKAGE = createPackageBundlerParam(\n+            WinFromParams::createWinExePackage);\n+\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinFromParams.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,7 +30,0 @@\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.nio.charset.Charset;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n@@ -38,6 +31,0 @@\n-import java.nio.file.PathMatcher;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n@@ -45,13 +32,0 @@\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import javax.xml.xpath.XPath;\n-import javax.xml.xpath.XPathConstants;\n-import javax.xml.xpath.XPathExpressionException;\n-import javax.xml.xpath.XPathFactory;\n-import jdk.jpackage.internal.PackagingPipeline.PackageBuildEnv;\n-import jdk.jpackage.internal.model.AppImageLayout;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n@@ -59,1 +33,0 @@\n-import jdk.jpackage.internal.model.Package;\n@@ -61,1 +34,0 @@\n-import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -63,3 +35,1 @@\n-import org.w3c.dom.Document;\n-import org.w3c.dom.NodeList;\n-import org.xml.sax.SAXException;\n+import jdk.jpackage.internal.util.Result;\n@@ -67,61 +37,0 @@\n-\/**\n- * WinMsiBundler\n- *\n- * Produces .msi installer from application image. Uses WiX Toolkit to build\n- * .msi installer.\n- * <p>\n- * {@link #execute} method creates a number of source files with the description\n- * of installer to be processed by WiX tools. Generated source files are stored\n- * in \"config\" subdirectory next to \"app\" subdirectory in the root work\n- * directory. The following WiX source files are generated:\n- * <ul>\n- * <li>main.wxs. Main source file with the installer description\n- * <li>bundle.wxf. Source file with application and Java run-time directory tree\n- * description.\n- * <li>ui.wxf. Source file with UI description of the installer.\n- * <\/ul>\n- *\n- * <p>\n- * main.wxs file is a copy of main.wxs resource from\n- * jdk.jpackage.internal.resources package. It is parametrized with the\n- * following WiX variables:\n- * <ul>\n- * <li>JpAppName. Name of the application. Set to the value of --name command\n- * line option\n- * <li>JpAppVersion. Version of the application. Set to the value of\n- * --app-version command line option\n- * <li>JpAppVendor. Vendor of the application. Set to the value of --vendor\n- * command line option\n- * <li>JpAppDescription. Description of the application. Set to the value of\n- * --description command line option\n- * <li>JpProductCode. Set to product code UUID of the application. Random value\n- * generated by jpackage every time {@link #execute} method is called\n- * <li>JpProductUpgradeCode. Set to upgrade code UUID of the application. Random\n- * value generated by jpackage every time {@link #execute} method is called if\n- * --win-upgrade-uuid command line option is not specified. Otherwise this\n- * variable is set to the value of --win-upgrade-uuid command line option\n- * <li>JpAllowUpgrades. Set to \"yes\", but all that matters is it is defined.\n- * <li>JpAllowDowngrades. Defined for application installers, and undefined for\n- * Java runtime installers.\n- * <li>JpConfigDir. Absolute path to the directory with generated WiX source\n- * files.\n- * <li>JpIsSystemWide. Set to \"yes\" if --win-per-user-install command line\n- * option was not specified. Undefined otherwise\n- * <li>JpAppSizeKb. Set to estimated size of the application in kilobytes\n- * <li>JpHelpURL. Set to value of --win-help-url command line option if it\n- * was specified. Undefined otherwise\n- * <li>JpAboutURL. Set to value of --about-url command line option if it\n- * was specified. Undefined otherwise\n- * <li>JpUpdateURL. Set to value of --win-update-url command line option if it\n- * was specified. Undefined otherwise\n- * <\/ul>\n- *\n- * <p>\n- * ui.wxf file is generated based on --license-file, --win-shortcut-prompt,\n- * --win-dir-chooser command line options. It is parametrized with the following\n- * WiX variables:\n- * <ul>\n- * <li>JpLicenseRtf. Set to the value of --license-file command line option.\n- * Undefined if --license-file command line option was not specified\n- * <\/ul>\n- *\/\n@@ -131,8 +40,0 @@\n-        wixFragments = Stream.of(\n-                Map.entry(\"bundle.wxf\", new WixAppImageFragmentBuilder()),\n-                Map.entry(\"ui.wxf\", new WixUiFragmentBuilder()),\n-                Map.entry(\"os-condition.wxf\", OSVersionCondition.createWixFragmentBuilder())\n-        ).<WixFragmentBuilder>map(e -> {\n-            e.getValue().setOutputFileName(e.getKey());\n-            return e.getValue();\n-        }).toList();\n@@ -159,2 +60,5 @@\n-            if (wixToolset == null) {\n-                wixToolset = WixTool.createToolset();\n+            try {\n+                sysEnv.orElseThrow();\n+                return true;\n+            } catch (RuntimeException ex) {\n+                ConfigException.rethrowConfigException(ex);\n@@ -162,1 +66,0 @@\n-            return true;\n@@ -187,3 +90,1 @@\n-            if (wixToolset == null) {\n-                wixToolset = WixTool.createToolset();\n-            }\n+            final var wixToolset = sysEnv.orElseThrow().wixToolset();\n@@ -197,6 +98,0 @@\n-            wixFragments.forEach(wixFragment -> wixFragment.setWixVersion(wixToolset.getVersion(),\n-                    wixToolset.getType()));\n-\n-            wixFragments.stream().map(WixFragmentBuilder::getLoggableWixFeatures).flatMap(\n-                    List::stream).distinct().toList().forEach(Log::verbose);\n-\n@@ -209,31 +104,0 @@\n-    private void prepareProto(Package pkg, BuildEnv env, AppImageLayout appImageLayout) throws\n-            PackagerException, IOException {\n-\n-        \/\/ Configure installer icon\n-        if (appImageLayout instanceof RuntimeLayout runtimeLayout) {\n-            \/\/ Use icon from java launcher.\n-            \/\/ Assume java.exe exists in Java Runtime being packed.\n-            \/\/ Ignore custom icon if any as we don't want to copy anything in\n-            \/\/ Java Runtime image.\n-            installerIcon = runtimeLayout.runtimeDirectory().resolve(Path.of(\"bin\", \"java.exe\"));\n-        } else if (appImageLayout instanceof ApplicationLayout appLayout) {\n-            installerIcon = appLayout.launchersDirectory().resolve(\n-                    pkg.app().mainLauncher().orElseThrow().executableNameWithSuffix());\n-        }\n-        installerIcon = installerIcon.toAbsolutePath();\n-\n-        pkg.licenseFile().ifPresent(licenseFile -> {\n-            \/\/ need to copy license file to the working directory\n-            \/\/ and convert to rtf if needed\n-            Path destFile = env.configDir().resolve(licenseFile.getFileName());\n-\n-            try {\n-                IOUtils.copyFile(licenseFile, destFile);\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-            }\n-            destFile.toFile().setWritable(true);\n-            ensureByMutationFileIsRTF(destFile);\n-        });\n-    }\n-\n@@ -244,310 +108,6 @@\n-        IOUtils.writableOutputDir(outputParentDir);\n-\n-        \/\/ Order is important!\n-        var pkg = WinFromParams.MSI_PACKAGE.fetchFrom(params);\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-        WinPackagingPipeline.build()\n-                .excludeDirFromCopying(outputParentDir)\n-                .task(PackagingPipeline.PackageTaskID.CREATE_CONFIG_FILES)\n-                        .packageAction(this::prepareConfigFiles)\n-                        .add()\n-                .task(PackagingPipeline.PackageTaskID.CREATE_PACKAGE_FILE)\n-                        .packageAction(this::buildPackage)\n-                        .add()\n-                .create().execute(env, pkg, outputParentDir);\n-\n-        return outputParentDir.resolve(pkg.packageFileNameWithSuffix()).toAbsolutePath();\n-    }\n-\n-    private void prepareConfigFiles(PackageBuildEnv<WinMsiPackage, AppImageLayout> env) throws PackagerException, IOException {\n-        prepareProto(env.pkg(), env.env(), env.resolvedLayout());\n-        for (var wixFragment : wixFragments) {\n-            wixFragment.initFromParams(env.env(), env.pkg());\n-            wixFragment.addFilesToConfigRoot();\n-        }\n-\n-        final var msiOut = env.outputDir().resolve(env.pkg().packageFileNameWithSuffix());\n-\n-        Log.verbose(I18N.format(\"message.preparing-msi-config\", msiOut.toAbsolutePath()));\n-\n-        final var wixVars = createWixVars(env);\n-\n-        final var wixObjDir = env.env().buildRoot().resolve(\"wixobj\");\n-\n-        final var configDir = env.env().configDir();\n-\n-        final var wixPipelineBuilder = WixPipeline.build()\n-                .setWixObjDir(wixObjDir)\n-                .setWorkDir(env.env().appImageDir())\n-                .addSource(configDir.resolve(\"main.wxs\"), wixVars);\n-\n-        for (var wixFragment : wixFragments) {\n-            wixFragment.configureWixPipeline(wixPipelineBuilder);\n-        }\n-\n-        switch (wixToolset.getType()) {\n-            case Wix3 -> {\n-                wixPipelineBuilder.addLightOptions(\"-sice:ICE27\");\n-\n-                if (!env.pkg().isSystemWideInstall()) {\n-                    wixPipelineBuilder.addLightOptions(\"-sice:ICE91\");\n-                }\n-            }\n-            case Wix4 -> {\n-            }\n-            default -> {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-\n-        var primaryWxlFiles = Stream.of(\"de\", \"en\", \"ja\", \"zh_CN\").map(loc -> {\n-            return configDir.resolve(\"MsiInstallerStrings_\" + loc + \".wxl\");\n-        }).toList();\n-\n-        var wixResources = new WixSourceConverter.ResourceGroup(wixToolset.getType());\n-\n-        \/\/ Copy standard l10n files.\n-        for (var path : primaryWxlFiles) {\n-            var name = path.getFileName().toString();\n-            wixResources.addResource(env.env().createResource(name).setPublicName(name).setCategory(\n-                    I18N.getString(\"resource.wxl-file\")), path);\n-        }\n-\n-        wixResources.addResource(env.env().createResource(\"main.wxs\").setPublicName(\"main.wxs\").\n-                setCategory(I18N.getString(\"resource.main-wix-file\")), configDir.resolve(\"main.wxs\"));\n-\n-        wixResources.addResource(env.env().createResource(\"overrides.wxi\").setPublicName(\n-                \"overrides.wxi\").setCategory(I18N.getString(\"resource.overrides-wix-file\")),\n-                configDir.resolve(\"overrides.wxi\"));\n-\n-        \/\/ Filter out custom l10n files that were already used to\n-        \/\/ override primary l10n files. Ignore case filename comparison,\n-        \/\/ both lists are expected to be short.\n-        List<Path> customWxlFiles = env.env().resourceDir()\n-                .map(WinMsiBundler::getWxlFilesFromDir)\n-                .orElseGet(Collections::emptyList)\n-                .stream()\n-                .filter(custom -> primaryWxlFiles.stream().noneMatch(primary ->\n-                        primary.getFileName().toString().equalsIgnoreCase(\n-                                custom.getFileName().toString())))\n-                .peek(custom -> Log.verbose(I18N.format(\n-                        \"message.using-custom-resource\", String.format(\"[%s]\",\n-                                I18N.getString(\"resource.wxl-file\")),\n-                        custom.getFileName()))).toList();\n-\n-        \/\/ Copy custom l10n files.\n-        for (var path : customWxlFiles) {\n-            var name = path.getFileName().toString();\n-            wixResources.addResource(env.env().createResource(name).setPublicName(name).\n-                    setSourceOrder(OverridableResource.Source.ResourceDir).setCategory(I18N.\n-                    getString(\"resource.wxl-file\")), configDir.resolve(name));\n-        }\n-\n-        \/\/ Save all WiX resources into config dir.\n-        wixResources.saveResources();\n-\n-        \/\/ All l10n files are supplied to WiX with \"-loc\", but only\n-        \/\/ Cultures from custom files and a single primary Culture are\n-        \/\/ included into \"-cultures\" list\n-        for (var wxl : primaryWxlFiles) {\n-            wixPipelineBuilder.addLightOptions(\"-loc\", wxl.toString());\n-        }\n-\n-        List<String> cultures = new ArrayList<>();\n-        for (var wxl : customWxlFiles) {\n-            wxl = configDir.resolve(wxl.getFileName());\n-            wixPipelineBuilder.addLightOptions(\"-loc\", wxl.toString());\n-            cultures.add(getCultureFromWxlFile(wxl));\n-        }\n-\n-        \/\/ Append a primary culture bases on runtime locale.\n-        final Path primaryWxlFile = configDir.resolve(\n-                I18N.getString(\"resource.wxl-file-name\"));\n-        cultures.add(getCultureFromWxlFile(primaryWxlFile));\n-\n-        \/\/ Build ordered list of unique cultures.\n-        Set<String> uniqueCultures = new LinkedHashSet<>();\n-        uniqueCultures.addAll(cultures);\n-        switch (wixToolset.getType()) {\n-            case Wix3 -> {\n-                wixPipelineBuilder.addLightOptions(uniqueCultures.stream().collect(Collectors.joining(\";\",\n-                        \"-cultures:\", \"\")));\n-            }\n-            case Wix4 -> {\n-                uniqueCultures.forEach(culture -> {\n-                    wixPipelineBuilder.addLightOptions(\"-culture\", culture);\n-                });\n-            }\n-            default -> {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-\n-        Files.createDirectories(wixObjDir);\n-        wixPipeline = wixPipelineBuilder.create(wixToolset);\n-    }\n-\n-    private void buildPackage(PackageBuildEnv<WinMsiPackage, AppImageLayout> env) throws PackagerException, IOException {\n-        final var msiOut = env.outputDir().resolve(env.pkg().packageFileNameWithSuffix());\n-        Log.verbose(I18N.format(\"message.generating-msi\", msiOut.toAbsolutePath()));\n-        wixPipeline.buildMsi(msiOut.toAbsolutePath());\n-    }\n-\n-    private Map<String, String> createWixVars(PackageBuildEnv<WinMsiPackage, AppImageLayout> env) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n-\n-        final var pkg = env.pkg();\n-\n-        data.put(\"JpProductCode\", pkg.productCode().toString());\n-        data.put(\"JpProductUpgradeCode\", pkg.upgradeCode().toString());\n-\n-        Log.verbose(I18N.format(\"message.product-code\", pkg.productCode()));\n-        Log.verbose(I18N.format(\"message.upgrade-code\", pkg.upgradeCode()));\n-\n-        data.put(\"JpAllowUpgrades\", \"yes\");\n-        if (!pkg.isRuntimeInstaller()) {\n-            data.put(\"JpAllowDowngrades\", \"yes\");\n-        }\n-\n-        data.put(\"JpAppName\", pkg.packageName());\n-        data.put(\"JpAppDescription\", pkg.description());\n-        data.put(\"JpAppVendor\", pkg.app().vendor());\n-        data.put(\"JpAppVersion\", pkg.version());\n-        if (Files.exists(installerIcon)) {\n-            data.put(\"JpIcon\", installerIcon.toString());\n-        }\n-\n-        pkg.helpURL().ifPresent(value -> {\n-            data.put(\"JpHelpURL\", value);\n-        });\n-\n-        pkg.updateURL().ifPresent(value -> {\n-            data.put(\"JpUpdateURL\", value);\n-        });\n-\n-        pkg.aboutURL().ifPresent(value -> {\n-            data.put(\"JpAboutURL\", value);\n-        });\n-\n-        data.put(\"JpAppSizeKb\", Long.toString(AppImageLayout.toPathGroup(\n-                env.resolvedLayout()).sizeInBytes() >> 10));\n-\n-        data.put(\"JpConfigDir\", env.env().configDir().toAbsolutePath().toString());\n-\n-        if (pkg.isSystemWideInstall()) {\n-            data.put(\"JpIsSystemWide\", \"yes\");\n-        }\n-\n-        return data;\n-    }\n-\n-    private static List<Path> getWxlFilesFromDir(Path dir) {\n-        final String glob = \"glob:**\/*.wxl\";\n-        final PathMatcher pathMatcher = FileSystems.getDefault().getPathMatcher(\n-                glob);\n-\n-        try (var walk = Files.walk(dir, 1)) {\n-            return walk\n-                    .filter(Files::isReadable)\n-                    .filter(pathMatcher::matches)\n-                    .sorted((a, b) -> a.getFileName().toString().compareToIgnoreCase(b.getFileName().toString()))\n-                    .toList();\n-        } catch (IOException ex) {\n-            throw new UncheckedIOException(ex);\n-        }\n-    }\n-\n-    private static String getCultureFromWxlFile(Path wxlPath) {\n-        try {\n-            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n-            factory.setNamespaceAware(false);\n-            DocumentBuilder builder = factory.newDocumentBuilder();\n-\n-            Document doc = builder.parse(wxlPath.toFile());\n-\n-            XPath xPath = XPathFactory.newInstance().newXPath();\n-            NodeList nodes = (NodeList) xPath.evaluate(\n-                    \"\/\/WixLocalization\/@Culture\", doc, XPathConstants.NODESET);\n-            if (nodes.getLength() != 1) {\n-                throw new IOException(I18N.format(\n-                        \"error.extract-culture-from-wix-l10n-file\",\n-                        wxlPath.toAbsolutePath().normalize()));\n-            }\n-\n-            return nodes.item(0).getNodeValue();\n-        } catch (XPathExpressionException | ParserConfigurationException\n-                | SAXException ex) {\n-            throw new UncheckedIOException(new IOException(\n-                    I18N.format(\"error.read-wix-l10n-file\", wxlPath.toAbsolutePath().normalize()), ex));\n-        } catch (IOException ex) {\n-            throw new UncheckedIOException(ex);\n-        }\n-    }\n-\n-    private static void ensureByMutationFileIsRTF(Path f) {\n-        try {\n-            boolean existingLicenseIsRTF = false;\n-\n-            try (InputStream fin = Files.newInputStream(f)) {\n-                byte[] firstBits = new byte[7];\n-\n-                if (fin.read(firstBits) == firstBits.length) {\n-                    String header = new String(firstBits);\n-                    existingLicenseIsRTF = \"{\\\\rtf1\\\\\".equals(header);\n-                }\n-            }\n-\n-            if (!existingLicenseIsRTF) {\n-                List<String> oldLicense = Files.readAllLines(f);\n-                try (Writer w = Files.newBufferedWriter(\n-                        f, Charset.forName(\"Windows-1252\"))) {\n-                    w.write(\"{\\\\rtf1\\\\ansi\\\\ansicpg1252\\\\deff0\\\\deflang1033\"\n-                            + \"{\\\\fonttbl{\\\\f0\\\\fnil\\\\fcharset0 Arial;}}\\n\"\n-                            + \"\\\\viewkind4\\\\uc1\\\\pard\\\\sa200\\\\sl276\"\n-                            + \"\\\\slmult1\\\\lang9\\\\fs20 \");\n-                    oldLicense.forEach(l -> {\n-                        try {\n-                            for (char c : l.toCharArray()) {\n-                                \/\/ 0x00 <= ch < 0x20 Escaped (\\'hh)\n-                                \/\/ 0x20 <= ch < 0x80 Raw(non - escaped) char\n-                                \/\/ 0x80 <= ch <= 0xFF Escaped(\\ 'hh)\n-                                \/\/ 0x5C, 0x7B, 0x7D (special RTF characters\n-                                \/\/ \\,{,})Escaped(\\'hh)\n-                                \/\/ ch > 0xff Escaped (\\\\ud###?)\n-                                if (c < 0x10) {\n-                                    w.write(\"\\\\'0\");\n-                                    w.write(Integer.toHexString(c));\n-                                } else if (c > 0xff) {\n-                                    w.write(\"\\\\ud\");\n-                                    w.write(Integer.toString(c));\n-                                    \/\/ \\\\uc1 is in the header and in effect\n-                                    \/\/ so we trail with a replacement char if\n-                                    \/\/ the font lacks that character - '?'\n-                                    w.write(\"?\");\n-                                } else if ((c < 0x20) || (c >= 0x80) ||\n-                                        (c == 0x5C) || (c == 0x7B) ||\n-                                        (c == 0x7D)) {\n-                                    w.write(\"\\\\'\");\n-                                    w.write(Integer.toHexString(c));\n-                                } else {\n-                                    w.write(c);\n-                                }\n-                            }\n-                            \/\/ blank lines are interpreted as paragraph breaks\n-                            if (l.length() < 1) {\n-                                w.write(\"\\\\par\");\n-                            } else {\n-                                w.write(\" \");\n-                            }\n-                            w.write(\"\\r\\n\");\n-                        } catch (IOException e) {\n-                            Log.verbose(e);\n-                        }\n-                    });\n-                    w.write(\"}\\r\\n\");\n-                }\n-            }\n-        } catch (IOException e) {\n-            Log.verbose(e);\n-        }\n+        return Packager.<WinMsiPackage>build().outputDir(outputParentDir)\n+                .pkg(WinFromParams.MSI_PACKAGE.fetchFrom(params))\n+                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, pkg, outputDir) -> {\n+                    return new WinMsiPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n+                }).execute(WinPackagingPipeline.build());\n@@ -556,4 +116,1 @@\n-    private Path installerIcon;\n-    private WixToolset wixToolset;\n-    private WixPipeline wixPipeline;\n-    private final List<WixFragmentBuilder> wixFragments;\n+    final Result<WinSystemEnvironment> sysEnv = WinSystemEnvironment.create();\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":14,"deletions":457,"binary":false,"changes":471,"status":"modified"},{"patch":"@@ -0,0 +1,486 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+\/**\n+ * WinMsiPackager\n+ *\n+ * Produces .msi installer from application image. Uses WiX Toolkit to build\n+ * .msi installer.\n+ * <p>\n+ * Creates a number of source files with the description\n+ * of installer to be processed by WiX tools. Generated source files are stored\n+ * in \"config\" subdirectory next to \"app\" subdirectory in the root work\n+ * directory. The following WiX source files are generated:\n+ * <ul>\n+ * <li>main.wxs. Main source file with the installer description\n+ * <li>bundle.wxf. Source file with application and Java run-time directory tree\n+ * description.\n+ * <li>ui.wxf. Source file with UI description of the installer.\n+ * <\/ul>\n+ *\n+ * <p>\n+ * main.wxs file is a copy of main.wxs resource from\n+ * jdk.jpackage.internal.resources package. It is parametrized with the\n+ * following WiX variables:\n+ * <ul>\n+ * <li>JpAppName. Name of the application. Set to the value of --name command\n+ * line option\n+ * <li>JpAppVersion. Version of the application. Set to the value of\n+ * --app-version command line option\n+ * <li>JpAppVendor. Vendor of the application. Set to the value of --vendor\n+ * command line option\n+ * <li>JpAppDescription. Description of the application. Set to the value of\n+ * --description command line option\n+ * <li>JpProductCode. Set to product code UUID of the application. Random value\n+ * generated by jpackage every time {@link #execute} method is called\n+ * <li>JpProductUpgradeCode. Set to upgrade code UUID of the application. Random\n+ * value generated by jpackage every time {@link #execute} method is called if\n+ * --win-upgrade-uuid command line option is not specified. Otherwise this\n+ * variable is set to the value of --win-upgrade-uuid command line option\n+ * <li>JpAllowUpgrades. Set to \"yes\", but all that matters is it is defined.\n+ * <li>JpAllowDowngrades. Defined for application installers, and undefined for\n+ * Java runtime installers.\n+ * <li>JpConfigDir. Absolute path to the directory with generated WiX source\n+ * files.\n+ * <li>JpIsSystemWide. Set to \"yes\" if --win-per-user-install command line\n+ * option was not specified. Undefined otherwise\n+ * <li>JpAppSizeKb. Set to estimated size of the application in kilobytes\n+ * <li>JpHelpURL. Set to value of --win-help-url command line option if it\n+ * was specified. Undefined otherwise\n+ * <li>JpAboutURL. Set to value of --about-url command line option if it\n+ * was specified. Undefined otherwise\n+ * <li>JpUpdateURL. Set to value of --win-update-url command line option if it\n+ * was specified. Undefined otherwise\n+ * <\/ul>\n+ *\n+ * <p>\n+ * ui.wxf file is generated based on --license-file, --win-shortcut-prompt,\n+ * --win-dir-chooser command line options. It is parametrized with the following\n+ * WiX variables:\n+ * <ul>\n+ * <li>JpLicenseRtf. Set to the value of --license-file command line option.\n+ * Undefined if --license-file command line option was not specified\n+ * <\/ul>\n+ *\/\n+final class WinMsiPackager implements Consumer<PackagingPipeline.Builder> {\n+\n+    WinMsiPackager(BuildEnv env, WinMsiPackage pkg, Path outputDir, WixToolset wixToolset) {\n+        this.pkg = Objects.requireNonNull(pkg);\n+        this.env = Objects.requireNonNull(env);\n+        this.outputDir = Objects.requireNonNull(outputDir);\n+        this.wixToolset = Objects.requireNonNull(wixToolset);\n+\n+        wixFragments = Stream.of(\n+                Map.entry(\"bundle.wxf\", new WixAppImageFragmentBuilder()),\n+                Map.entry(\"ui.wxf\", new WixUiFragmentBuilder()),\n+                Map.entry(\"os-condition.wxf\", OSVersionCondition.createWixFragmentBuilder())\n+        ).<WixFragmentBuilder>map(e -> {\n+            e.getValue().setOutputFileName(e.getKey());\n+            return e.getValue();\n+        }).toList();\n+\n+        \/\/ Configure installer icon\n+        if (env.appImageLayout() instanceof RuntimeLayout runtimeLayout) {\n+            \/\/ Use icon from java launcher.\n+            \/\/ Assume java.exe exists in Java Runtime being packed.\n+            \/\/ Ignore custom icon if any as we don't want to copy anything in\n+            \/\/ Java Runtime image.\n+            installerIcon = runtimeLayout.runtimeDirectory().resolve(Path.of(\"bin\", \"java.exe\")).toAbsolutePath();\n+        } else {\n+            installerIcon = env.asApplicationLayout().orElseThrow().launchersDirectory().resolve(\n+                    pkg.app().mainLauncher().orElseThrow().executableNameWithSuffix()).toAbsolutePath();\n+        }\n+\n+        wixFragments.forEach(wixFragment -> wixFragment.setWixVersion(wixToolset.getVersion(),\n+                wixToolset.getType()));\n+\n+        wixFragments.stream().map(WixFragmentBuilder::getLoggableWixFeatures).flatMap(\n+                List::stream).distinct().toList().forEach(Log::verbose);\n+    }\n+\n+    WinMsiPackager(BuildEnv env, WinMsiPackage pkg, Path outputDir, WinSystemEnvironment sysEnv) {\n+        this(env, pkg, outputDir, sysEnv.wixToolset());\n+    }\n+\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n+        pipelineBuilder.excludeDirFromCopying(outputDir)\n+                .task(PackagingPipeline.PackageTaskID.CREATE_CONFIG_FILES)\n+                        .action(this::prepareConfigFiles)\n+                        .add()\n+                .task(PackagingPipeline.PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .action(this::buildPackage)\n+                        .add();\n+    }\n+\n+    private void prepareConfigFiles() throws PackagerException, IOException {\n+\n+        pkg.licenseFile().ifPresent(licenseFile -> {\n+            \/\/ need to copy license file to the working directory\n+            \/\/ and convert to rtf if needed\n+            Path destFile = env.configDir().resolve(licenseFile.getFileName());\n+\n+            try {\n+                IOUtils.copyFile(licenseFile, destFile);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+            destFile.toFile().setWritable(true);\n+            ensureByMutationFileIsRTF(destFile);\n+        });\n+\n+        for (var wixFragment : wixFragments) {\n+            wixFragment.initFromParams(env, pkg);\n+            wixFragment.addFilesToConfigRoot();\n+        }\n+\n+        final var msiOut = outputDir.resolve(pkg.packageFileNameWithSuffix());\n+\n+        Log.verbose(I18N.format(\"message.preparing-msi-config\", msiOut.toAbsolutePath()));\n+\n+        final var wixVars = createWixVars();\n+\n+        final var wixObjDir = env.buildRoot().resolve(\"wixobj\");\n+\n+        final var configDir = env.configDir();\n+\n+        final var wixPipelineBuilder = WixPipeline.build()\n+                .setWixObjDir(wixObjDir)\n+                .setWorkDir(env.appImageDir())\n+                .addSource(configDir.resolve(\"main.wxs\"), wixVars);\n+\n+        for (var wixFragment : wixFragments) {\n+            wixFragment.configureWixPipeline(wixPipelineBuilder);\n+        }\n+\n+        switch (wixToolset.getType()) {\n+            case Wix3 -> {\n+                wixPipelineBuilder.addLightOptions(\"-sice:ICE27\");\n+\n+                if (!pkg.isSystemWideInstall()) {\n+                    wixPipelineBuilder.addLightOptions(\"-sice:ICE91\");\n+                }\n+            }\n+            case Wix4 -> {\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        var primaryWxlFiles = Stream.of(\"de\", \"en\", \"ja\", \"zh_CN\").map(loc -> {\n+            return configDir.resolve(\"MsiInstallerStrings_\" + loc + \".wxl\");\n+        }).toList();\n+\n+        var wixResources = new WixSourceConverter.ResourceGroup(wixToolset.getType());\n+\n+        \/\/ Copy standard l10n files.\n+        for (var path : primaryWxlFiles) {\n+            var name = path.getFileName().toString();\n+            wixResources.addResource(env.createResource(name).setPublicName(name).setCategory(\n+                    I18N.getString(\"resource.wxl-file\")), path);\n+        }\n+\n+        wixResources.addResource(env.createResource(\"main.wxs\").setPublicName(\"main.wxs\").\n+                setCategory(I18N.getString(\"resource.main-wix-file\")), configDir.resolve(\"main.wxs\"));\n+\n+        wixResources.addResource(env.createResource(\"overrides.wxi\").setPublicName(\n+                \"overrides.wxi\").setCategory(I18N.getString(\"resource.overrides-wix-file\")),\n+                configDir.resolve(\"overrides.wxi\"));\n+\n+        \/\/ Filter out custom l10n files that were already used to\n+        \/\/ override primary l10n files. Ignore case filename comparison,\n+        \/\/ both lists are expected to be short.\n+        List<Path> customWxlFiles = env.resourceDir()\n+                .map(WinMsiPackager::getWxlFilesFromDir)\n+                .orElseGet(Collections::emptyList)\n+                .stream()\n+                .filter(custom -> primaryWxlFiles.stream().noneMatch(primary ->\n+                        primary.getFileName().toString().equalsIgnoreCase(\n+                                custom.getFileName().toString())))\n+                .peek(custom -> Log.verbose(I18N.format(\n+                        \"message.using-custom-resource\", String.format(\"[%s]\",\n+                                I18N.getString(\"resource.wxl-file\")),\n+                        custom.getFileName()))).toList();\n+\n+        \/\/ Copy custom l10n files.\n+        for (var path : customWxlFiles) {\n+            var name = path.getFileName().toString();\n+            wixResources.addResource(env.createResource(name).setPublicName(name).\n+                    setSourceOrder(OverridableResource.Source.ResourceDir).setCategory(I18N.\n+                    getString(\"resource.wxl-file\")), configDir.resolve(name));\n+        }\n+\n+        \/\/ Save all WiX resources into config dir.\n+        wixResources.saveResources();\n+\n+        \/\/ All l10n files are supplied to WiX with \"-loc\", but only\n+        \/\/ Cultures from custom files and a single primary Culture are\n+        \/\/ included into \"-cultures\" list\n+        for (var wxl : primaryWxlFiles) {\n+            wixPipelineBuilder.addLightOptions(\"-loc\", wxl.toString());\n+        }\n+\n+        List<String> cultures = new ArrayList<>();\n+        for (var wxl : customWxlFiles) {\n+            wxl = configDir.resolve(wxl.getFileName());\n+            wixPipelineBuilder.addLightOptions(\"-loc\", wxl.toString());\n+            cultures.add(getCultureFromWxlFile(wxl));\n+        }\n+\n+        \/\/ Append a primary culture bases on runtime locale.\n+        final Path primaryWxlFile = configDir.resolve(\n+                I18N.getString(\"resource.wxl-file-name\"));\n+        cultures.add(getCultureFromWxlFile(primaryWxlFile));\n+\n+        \/\/ Build ordered list of unique cultures.\n+        Set<String> uniqueCultures = new LinkedHashSet<>();\n+        uniqueCultures.addAll(cultures);\n+        switch (wixToolset.getType()) {\n+            case Wix3 -> {\n+                wixPipelineBuilder.addLightOptions(uniqueCultures.stream().collect(Collectors.joining(\";\",\n+                        \"-cultures:\", \"\")));\n+            }\n+            case Wix4 -> {\n+                uniqueCultures.forEach(culture -> {\n+                    wixPipelineBuilder.addLightOptions(\"-culture\", culture);\n+                });\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        Files.createDirectories(wixObjDir);\n+        wixPipeline = wixPipelineBuilder.create(wixToolset);\n+    }\n+\n+    private void buildPackage() throws PackagerException, IOException {\n+        final var msiOut = outputDir.resolve(pkg.packageFileNameWithSuffix());\n+        Log.verbose(I18N.format(\"message.generating-msi\", msiOut.toAbsolutePath()));\n+        wixPipeline.buildMsi(msiOut.toAbsolutePath());\n+    }\n+\n+    private Map<String, String> createWixVars() throws IOException {\n+        Map<String, String> data = new HashMap<>();\n+\n+        data.put(\"JpProductCode\", pkg.productCode().toString());\n+        data.put(\"JpProductUpgradeCode\", pkg.upgradeCode().toString());\n+\n+        Log.verbose(I18N.format(\"message.product-code\", pkg.productCode()));\n+        Log.verbose(I18N.format(\"message.upgrade-code\", pkg.upgradeCode()));\n+\n+        data.put(\"JpAllowUpgrades\", \"yes\");\n+        if (!pkg.isRuntimeInstaller()) {\n+            data.put(\"JpAllowDowngrades\", \"yes\");\n+        }\n+\n+        data.put(\"JpAppName\", pkg.packageName());\n+        data.put(\"JpAppDescription\", pkg.description());\n+        data.put(\"JpAppVendor\", pkg.app().vendor());\n+        data.put(\"JpAppVersion\", pkg.version());\n+        if (Files.exists(installerIcon)) {\n+            data.put(\"JpIcon\", installerIcon.toString());\n+        }\n+\n+        pkg.helpURL().ifPresent(value -> {\n+            data.put(\"JpHelpURL\", value);\n+        });\n+\n+        pkg.updateURL().ifPresent(value -> {\n+            data.put(\"JpUpdateURL\", value);\n+        });\n+\n+        pkg.aboutURL().ifPresent(value -> {\n+            data.put(\"JpAboutURL\", value);\n+        });\n+\n+        data.put(\"JpAppSizeKb\", Long.toString(AppImageLayout.toPathGroup(\n+                env.appImageLayout()).sizeInBytes() >> 10));\n+\n+        data.put(\"JpConfigDir\", env.configDir().toAbsolutePath().toString());\n+\n+        if (pkg.isSystemWideInstall()) {\n+            data.put(\"JpIsSystemWide\", \"yes\");\n+        }\n+\n+        return data;\n+    }\n+\n+    private static List<Path> getWxlFilesFromDir(Path dir) {\n+        final String glob = \"glob:**\/*.wxl\";\n+        final PathMatcher pathMatcher = FileSystems.getDefault().getPathMatcher(\n+                glob);\n+\n+        try (var walk = Files.walk(dir, 1)) {\n+            return walk\n+                    .filter(Files::isReadable)\n+                    .filter(pathMatcher::matches)\n+                    .sorted((a, b) -> a.getFileName().toString().compareToIgnoreCase(b.getFileName().toString()))\n+                    .toList();\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private static String getCultureFromWxlFile(Path wxlPath) {\n+        try {\n+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+            factory.setNamespaceAware(false);\n+            DocumentBuilder builder = factory.newDocumentBuilder();\n+\n+            Document doc = builder.parse(wxlPath.toFile());\n+\n+            XPath xPath = XPathFactory.newInstance().newXPath();\n+            NodeList nodes = (NodeList) xPath.evaluate(\n+                    \"\/\/WixLocalization\/@Culture\", doc, XPathConstants.NODESET);\n+            if (nodes.getLength() != 1) {\n+                throw new RuntimeException(I18N.format(\n+                        \"error.extract-culture-from-wix-l10n-file\",\n+                        wxlPath.toAbsolutePath().normalize()));\n+            }\n+\n+            return nodes.item(0).getNodeValue();\n+        } catch (XPathExpressionException | ParserConfigurationException | SAXException ex) {\n+            throw new RuntimeException(I18N.format(\n+                    \"error.read-wix-l10n-file\", wxlPath.toAbsolutePath().normalize()), ex);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private static void ensureByMutationFileIsRTF(Path f) {\n+        try {\n+            boolean existingLicenseIsRTF = false;\n+\n+            try (InputStream fin = Files.newInputStream(f)) {\n+                byte[] firstBits = new byte[7];\n+\n+                if (fin.read(firstBits) == firstBits.length) {\n+                    String header = new String(firstBits);\n+                    existingLicenseIsRTF = \"{\\\\rtf1\\\\\".equals(header);\n+                }\n+            }\n+\n+            if (!existingLicenseIsRTF) {\n+                List<String> oldLicense = Files.readAllLines(f);\n+                try (Writer w = Files.newBufferedWriter(\n+                        f, Charset.forName(\"Windows-1252\"))) {\n+                    w.write(\"{\\\\rtf1\\\\ansi\\\\ansicpg1252\\\\deff0\\\\deflang1033\"\n+                            + \"{\\\\fonttbl{\\\\f0\\\\fnil\\\\fcharset0 Arial;}}\\n\"\n+                            + \"\\\\viewkind4\\\\uc1\\\\pard\\\\sa200\\\\sl276\"\n+                            + \"\\\\slmult1\\\\lang9\\\\fs20 \");\n+                    oldLicense.forEach(l -> {\n+                        try {\n+                            for (char c : l.toCharArray()) {\n+                                \/\/ 0x00 <= ch < 0x20 Escaped (\\'hh)\n+                                \/\/ 0x20 <= ch < 0x80 Raw(non - escaped) char\n+                                \/\/ 0x80 <= ch <= 0xFF Escaped(\\ 'hh)\n+                                \/\/ 0x5C, 0x7B, 0x7D (special RTF characters\n+                                \/\/ \\,{,})Escaped(\\'hh)\n+                                \/\/ ch > 0xff Escaped (\\\\ud###?)\n+                                if (c < 0x10) {\n+                                    w.write(\"\\\\'0\");\n+                                    w.write(Integer.toHexString(c));\n+                                } else if (c > 0xff) {\n+                                    w.write(\"\\\\ud\");\n+                                    w.write(Integer.toString(c));\n+                                    \/\/ \\\\uc1 is in the header and in effect\n+                                    \/\/ so we trail with a replacement char if\n+                                    \/\/ the font lacks that character - '?'\n+                                    w.write(\"?\");\n+                                } else if ((c < 0x20) || (c >= 0x80) ||\n+                                        (c == 0x5C) || (c == 0x7B) ||\n+                                        (c == 0x7D)) {\n+                                    w.write(\"\\\\'\");\n+                                    w.write(Integer.toHexString(c));\n+                                } else {\n+                                    w.write(c);\n+                                }\n+                            }\n+                            \/\/ blank lines are interpreted as paragraph breaks\n+                            if (l.length() < 1) {\n+                                w.write(\"\\\\par\");\n+                            } else {\n+                                w.write(\" \");\n+                            }\n+                            w.write(\"\\r\\n\");\n+                        } catch (IOException e) {\n+                            Log.verbose(e);\n+                        }\n+                    });\n+                    w.write(\"}\\r\\n\");\n+                }\n+            }\n+        } catch (IOException e) {\n+            Log.verbose(e);\n+        }\n+    }\n+\n+    private final WinMsiPackage pkg;\n+    private final BuildEnv env;\n+    private final Path outputDir;\n+    private final WixToolset wixToolset;\n+    private final List<WixFragmentBuilder> wixFragments;\n+    private final Path installerIcon;\n+    private WixPipeline wixPipeline;\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiPackager.java","additions":486,"deletions":0,"binary":false,"changes":486,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n+import java.util.Objects;\n+import jdk.jpackage.internal.util.Result;\n+\n+record WinSystemEnvironment(WixToolset wixToolset) implements SystemEnvironment {\n+\n+    WinSystemEnvironment {\n+        Objects.requireNonNull(wixToolset);\n+    }\n+\n+    static Result<WinSystemEnvironment> create() {\n+        return Result.create(toSupplier(WixTool::createToolset)).map(WinSystemEnvironment::new);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinSystemEnvironment.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -186,7 +186,6 @@\n-            final var validator = new ToolValidator(toolPath).setMinimalVersion(tool.minimalVersion).\n-                    setToolNotFoundErrorHandler((name, ex) -> {\n-                        return new ConfigException(\"\", \"\");\n-                    }).setToolOldVersionErrorHandler((name, version) -> {\n-                tooOld[0] = true;\n-                return null;\n-            });\n+            final var validator = new ToolValidator(toolPath)\n+                    .setMinimalVersion(tool.minimalVersion)\n+                    .setToolOldVersionErrorHandler((name, version) -> {\n+                        tooOld[0] = true;\n+                        return null;\n+                    });\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixTool.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-import jdk.jpackage.internal.model.DottedVersion;\n-import jdk.jpackage.internal.model.ConfigException;\n-import java.nio.file.Path;\n-import jdk.internal.util.OperatingSystem;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -33,0 +30,10 @@\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.DottedVersion;\n@@ -34,0 +41,4 @@\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -38,3 +49,4 @@\n-    @Test\n-    public void testAvailable() {\n-        assertNull(new ToolValidator(TOOL_JAVA).validate());\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testAvailable(boolean checkExistsOnly) {\n+        assertNull(new ToolValidator(TOOL_JAVA).checkExistsOnly(checkExistsOnly).validate());\n@@ -44,2 +56,98 @@\n-    public void testNotAvailable() {\n-        assertValidationFailure(new ToolValidator(TOOL_UNKNOWN).validate(), true);\n+    public void testAvailable_setCommandLine() {\n+        \/\/ java doesn't recognize \"--foo\" command line option, but the validation will\n+        \/\/ still pass as there is no minimal version specified and the validator ignores\n+        \/\/ the exit code\n+        assertNull(new ToolValidator(TOOL_JAVA).setCommandLine(\"--foo\").validate());\n+    }\n+\n+    enum TestAvailableMode {\n+        NO_VERSION(null),\n+        TOO_OLD(\"0.9\"),\n+        EQUALS(\"1.0\"),\n+        NEWER(\"1.1\");\n+\n+        TestAvailableMode(String parsedVersion) {\n+            this.parsedVersion = parsedVersion;\n+        }\n+\n+        final String parsedVersion;\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(TestAvailableMode.class)\n+    public void testAvailable(TestAvailableMode mode) {\n+        var minVer = TestAvailableMode.EQUALS.parsedVersion;\n+        var err = new ToolValidator(TOOL_JAVA).setVersionParser(lines -> {\n+            return mode.parsedVersion;\n+        }).setMinimalVersion(DottedVersion.greedy(minVer)).validate();\n+\n+        if (Set.of(TestAvailableMode.NO_VERSION, TestAvailableMode.TOO_OLD).contains(mode)) {\n+            var expectedMessage = I18N.format(\"error.tool-old-version\", TOOL_JAVA, minVer);\n+            var expectedAdvice = I18N.format(\"error.tool-old-version.advice\", TOOL_JAVA, minVer);\n+\n+            assertEquals(expectedMessage, err.getMessage());\n+            assertEquals(expectedAdvice, err.getAdvice());\n+        } else {\n+            assertNull(err);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(TestAvailableMode.class)\n+    public void testAvailable_setToolOldVersionErrorHandler(TestAvailableMode mode) {\n+        var handler = new ToolOldVersionErrorHandler();\n+        var minVer = TestAvailableMode.EQUALS.parsedVersion;\n+        var err = new ToolValidator(TOOL_JAVA).setVersionParser(lines -> {\n+            return mode.parsedVersion;\n+        }).setMinimalVersion(DottedVersion.greedy(minVer)).setToolOldVersionErrorHandler(handler).validate();\n+\n+        if (Set.of(TestAvailableMode.NO_VERSION, TestAvailableMode.TOO_OLD).contains(mode)) {\n+            assertSame(ToolOldVersionErrorHandler.ERR, err);\n+            handler.verifyCalled(Path.of(TOOL_JAVA), mode.parsedVersion);\n+        } else {\n+            assertNull(err);\n+            handler.verifyNotCalled();\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testNotAvailable(boolean checkExistsOnly, @TempDir Path dir) {\n+        var err = new ToolValidator(dir.resolve(\"foo\")).checkExistsOnly(checkExistsOnly).validate();\n+        if (checkExistsOnly) {\n+            assertValidationFailure(err, false);\n+        } else {\n+            assertValidationFailureNoAdvice(err, !checkExistsOnly);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testToolIsDirectory(boolean checkExistsOnly, @TempDir Path dir) {\n+        var err = new ToolValidator(dir).checkExistsOnly(checkExistsOnly).validate();\n+        assertValidationFailureNoAdvice(err, !checkExistsOnly);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testNotAvailable_setToolNotFoundErrorHandler(boolean checkExistsOnly, @TempDir Path dir) {\n+        var handler = new ToolNotFoundErrorHandler();\n+        var err = new ToolValidator(dir.resolve(\"foo\")).checkExistsOnly(checkExistsOnly)\n+                .setToolNotFoundErrorHandler(handler)\n+                .validate();\n+        if (checkExistsOnly) {\n+            handler.verifyCalled(dir.resolve(\"foo\"));\n+            assertSame(ToolNotFoundErrorHandler.ERR, err);\n+        } else {\n+            handler.verifyNotCalled();\n+            assertValidationFailureNoAdvice(err, !checkExistsOnly);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testToolIsDirectory_setToolNotFoundErrorHandler(boolean checkExistsOnly, @TempDir Path dir) {\n+        var handler = new ToolNotFoundErrorHandler();\n+        var err = new ToolValidator(dir).checkExistsOnly(checkExistsOnly).validate();\n+        handler.verifyNotCalled();\n+        assertValidationFailureNoAdvice(err, !checkExistsOnly);\n@@ -52,1 +160,1 @@\n-            throw new RuntimeException();\n+            throw new AssertionError();\n@@ -84,0 +192,61 @@\n+    private static void assertValidationFailureNoAdvice(ConfigException v, boolean withCause) {\n+        assertNotNull(v);\n+        assertNotEquals(\"\", v.getMessage().strip());\n+        assertNull(v.getAdvice());\n+        if (withCause) {\n+            assertNotNull(v.getCause());\n+        } else {\n+            assertNull(v.getCause());\n+        }\n+    }\n+\n+\n+    private static final class ToolNotFoundErrorHandler implements Function<Path, ConfigException> {\n+\n+        @Override\n+        public ConfigException apply(Path tool) {\n+            assertNotNull(tool);\n+            this.tool = tool;\n+            return ERR;\n+        }\n+\n+        void verifyCalled(Path expectedTool) {\n+            assertEquals(Objects.requireNonNull(expectedTool), tool);\n+        }\n+\n+        void verifyNotCalled() {\n+            assertNull(tool);\n+        }\n+\n+        private Path tool;\n+\n+        static final ConfigException ERR = new ConfigException(\"no tool\", \"install the tool\");\n+    }\n+\n+\n+    private static final class ToolOldVersionErrorHandler implements BiFunction<Path, String, ConfigException> {\n+\n+        @Override\n+        public ConfigException apply(Path tool, String parsedVersion) {\n+            assertNotNull(tool);\n+            this.tool = tool;\n+            this.parsedVersion = parsedVersion;\n+            return ERR;\n+        }\n+\n+        void verifyCalled(Path expectedTool, String expectedParsedVersion) {\n+            assertEquals(Objects.requireNonNull(expectedTool), tool);\n+            assertEquals(expectedParsedVersion, parsedVersion);\n+        }\n+\n+        void verifyNotCalled() {\n+            assertNull(tool);\n+        }\n+\n+        private Path tool;\n+        private String parsedVersion;\n+\n+        static final ConfigException ERR = new ConfigException(\"tool too old\", \"install the newer version\");\n+    }\n+\n+\n@@ -85,2 +254,0 @@\n-    private static final String TOOL_UNKNOWN = Path.of(System.getProperty(\n-            \"java.home\"), \"bin\").toString();\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/ToolValidatorTest.java","additions":179,"deletions":12,"binary":false,"changes":191,"status":"modified"}]}