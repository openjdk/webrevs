{"files":[{"patch":"@@ -6895,30 +6895,0 @@\n-\/\/ Store CMS card-mark Immediate\n-instruct storeimmCM0(immI0 zero, memory1 mem)\n-%{\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(INSN_COST);\n-  format %{ \"storestore (elided)\\n\\t\"\n-            \"strb zr, $mem\\t# byte\" %}\n-\n-  ins_encode(aarch64_enc_strb0(mem));\n-\n-  ins_pipe(istore_mem);\n-%}\n-\n-\/\/ Store CMS card-mark Immediate with intervening StoreStore\n-\/\/ needed when using CMS with no conditional card marking\n-instruct storeimmCM0_ordered(immI0 zero, memory1 mem)\n-%{\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"storestore\\n\\t\"\n-            \"dmb ishst\"\n-            \"\\n\\tstrb zr, $mem\\t# byte\" %}\n-\n-  ins_encode(aarch64_enc_strb0_ordered(mem));\n-\n-  ins_pipe(istore_mem);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -4229,12 +4229,0 @@\n-instruct storeCM(memoryB mem, store_RegI src) %{\n-  match(Set mem (StoreCM mem src));\n-  ins_cost(MEMORY_REF_COST);\n-\n-  size(4);\n-  format %{ \"STRB    $src,$mem\\t! CMS card-mark byte\" %}\n-  ins_encode %{\n-    __ strb($src$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(istore_mem_reg);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -6485,17 +6485,0 @@\n-\/\/----------Store Instructions With Zeros--------------------------------------\n-\n-instruct storeCM(memory mem, immI_0 zero) %{\n-  match(Set mem (StoreCM mem zero));\n-  ins_cost(MEMORY_REF_COST);\n-\n-  format %{ \"STB     #0, $mem \\t\/\/ CMS card-mark byte store\" %}\n-  size(8);\n-  ins_encode %{\n-    __ li(R0, 0);\n-    \/\/ No release barrier: Oops are allowed to get visible after marking.\n-    guarantee($mem$$base$$Register != R1_SP, \"use frame_slots_bias\");\n-    __ stb(R0, $mem$$disp, $mem$$base$$Register);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5038,35 +5038,0 @@\n-\/\/ Store Instructions\n-\/\/ Store CMS card-mark Immediate\n-instruct storeimmCM0(immI0 zero, memory mem)\n-%{\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(STORE_COST);\n-  format %{ \"storestore (elided)\\n\\t\"\n-            \"sb zr, $mem\\t# byte, #@storeimmCM0\" %}\n-\n-  ins_encode %{\n-    __ sb(zr, Address(as_Register($mem$$base), $mem$$disp));\n-  %}\n-\n-  ins_pipe(istore_mem);\n-%}\n-\n-\/\/ Store CMS card-mark Immediate with intervening StoreStore\n-\/\/ needed when using CMS with no conditional card marking\n-instruct storeimmCM0_ordered(immI0 zero, memory mem)\n-%{\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(ALU_COST + STORE_COST);\n-  format %{ \"membar(StoreStore)\\n\\t\"\n-            \"sb zr, $mem\\t# byte, #@storeimmCM0_ordered\" %}\n-\n-  ins_encode %{\n-    __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n-    __ sb(zr, Address(as_Register($mem$$base), $mem$$disp));\n-  %}\n-\n-  ins_pipe(istore_mem);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -4229,22 +4229,0 @@\n-instruct storeCM(memory mem, immI_0 src) %{\n-  match(Set mem (StoreCM mem src));\n-  ins_cost(MEMORY_REF_COST);\n-  \/\/ TODO: s390 port size(VARIABLE_SIZE);\n-  format %{ \"STC(Y)  $src,$mem\\t # CMS card-mark byte (must be 0!)\" %}\n-  ins_encode %{\n-    guarantee($mem$$index$$Register != Z_R0, \"content will not be used.\");\n-    if ($mem$$index$$Register != noreg) {\n-      \/\/ Can't use clear_mem --> load const zero and store character.\n-      __ load_const_optimized(Z_R0_scratch, (long)0);\n-      if (Immediate::is_uimm12($mem$$disp)) {\n-        __ z_stc(Z_R0_scratch, $mem$$Address);\n-      } else {\n-        __ z_stcy(Z_R0_scratch, $mem$$Address);\n-      }\n-    } else {\n-      __ clear_mem(Address($mem$$Address), 1);\n-    }\n-  %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -6325,11 +6325,0 @@\n-\/\/ Store CMS card-mark Immediate\n-instruct storeImmCM(memory mem, immI8 src) %{\n-  match(Set mem (StoreCM mem src));\n-\n-  ins_cost(150);\n-  format %{ \"MOV8   $mem,$src\\t! CMS card-mark imm0\" %}\n-  opcode(0xC6);               \/* C6 \/0 *\/\n-  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem), Con8or32(src), ClearInstMark);\n-  ins_pipe( ialu_mem_imm );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -5301,26 +5301,0 @@\n-\/\/ Store CMS card-mark Immediate\n-instruct storeImmCM0_reg(memory mem, immI_0 zero)\n-%{\n-  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movb    $mem, R12\\t# CMS card-mark byte 0 (R12_heapbase==0)\" %}\n-  ins_encode %{\n-    __ movb($mem$$Address, r12);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeImmCM0(memory mem, immI_0 src)\n-%{\n-  match(Set mem (StoreCM mem src));\n-\n-  ins_cost(150); \/\/ XXX\n-  format %{ \"movb    $mem, $src\\t# CMS card-mark byte 0\" %}\n-  ins_encode %{\n-    __ movb($mem$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -279,1 +279,0 @@\n-  if( strcmp(opType,\"StoreCM\")==0) return Form::idealB;\n","filename":"src\/hotspot\/share\/adlc\/forms.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3657,1 +3657,0 @@\n-    \"StoreCM\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -344,1 +344,0 @@\n-macro(StoreCM)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3054,46 +3054,0 @@\n-\/\/ Eliminate trivially redundant StoreCMs and accumulate their\n-\/\/ precedence edges.\n-void Compile::eliminate_redundant_card_marks(Node* n) {\n-  assert(n->Opcode() == Op_StoreCM, \"expected StoreCM\");\n-  if (n->in(MemNode::Address)->outcnt() > 1) {\n-    \/\/ There are multiple users of the same address so it might be\n-    \/\/ possible to eliminate some of the StoreCMs\n-    Node* mem = n->in(MemNode::Memory);\n-    Node* adr = n->in(MemNode::Address);\n-    Node* val = n->in(MemNode::ValueIn);\n-    Node* prev = n;\n-    bool done = false;\n-    \/\/ Walk the chain of StoreCMs eliminating ones that match.  As\n-    \/\/ long as it's a chain of single users then the optimization is\n-    \/\/ safe.  Eliminating partially redundant StoreCMs would require\n-    \/\/ cloning copies down the other paths.\n-    while (mem->Opcode() == Op_StoreCM && mem->outcnt() == 1 && !done) {\n-      if (adr == mem->in(MemNode::Address) &&\n-          val == mem->in(MemNode::ValueIn)) {\n-        \/\/ redundant StoreCM\n-        if (mem->req() > MemNode::OopStore) {\n-          \/\/ Hasn't been processed by this code yet.\n-          n->add_prec(mem->in(MemNode::OopStore));\n-        } else {\n-          \/\/ Already converted to precedence edge\n-          for (uint i = mem->req(); i < mem->len(); i++) {\n-            \/\/ Accumulate any precedence edges\n-            if (mem->in(i) != nullptr) {\n-              n->add_prec(mem->in(i));\n-            }\n-          }\n-          \/\/ Everything above this point has been processed.\n-          done = true;\n-        }\n-        \/\/ Eliminate the previous StoreCM\n-        prev->set_req(MemNode::Memory, mem->in(MemNode::Memory));\n-        assert(mem->outcnt() == 0, \"should be dead\");\n-        mem->disconnect_inputs(this);\n-      } else {\n-        prev = mem;\n-      }\n-      mem = prev->in(MemNode::Memory);\n-    }\n-  }\n-}\n-\n@@ -3269,12 +3223,0 @@\n-\n-  case Op_StoreCM:\n-    {\n-      \/\/ Convert OopStore dependence into precedence edge\n-      Node* prec = n->in(MemNode::OopStore);\n-      n->del_req(MemNode::OopStore);\n-      n->add_prec(prec);\n-      eliminate_redundant_card_marks(n);\n-    }\n-\n-    \/\/ fall through\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":58,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1218,1 +1218,0 @@\n-  void eliminate_redundant_card_marks(Node* n);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4012,4 +4012,0 @@\n-      if (use->Opcode() == Op_StoreCM && use->in(MemNode::OopStore) == n) {\n-        \/\/ Don't move related cardmark.\n-        continue;\n-      }\n@@ -4567,1 +4563,1 @@\n-              op == Op_CastP2X || op == Op_StoreCM ||\n+              op == Op_CastP2X ||\n@@ -4706,3 +4702,0 @@\n-        if (use->Opcode() == Op_StoreCM) { \/\/ Ignore cardmark stores\n-          continue;\n-        }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -219,10 +219,4 @@\n-\n-        \/\/ Only process precedence edges that are CFG nodes. Safepoints and control projections can be in the middle of a block\n-        if (is_CFG(m)) {\n-          node->rm_prec(i);\n-          if (n == nullptr) {\n-            n = m;\n-          } else {\n-            assert(is_dominator(n, m) || is_dominator(m, n), \"one must dominate the other\");\n-            n = is_dominator(n, m) ? m : n;\n-          }\n+        assert(is_CFG(m), \"must be a CFG node\");\n+        node->rm_prec(i);\n+        if (n == nullptr) {\n+          n = m;\n@@ -230,2 +224,2 @@\n-          assert(node->is_Mach(), \"sanity\");\n-          assert(node->as_Mach()->ideal_Opcode() == Op_StoreCM, \"must be StoreCM node\");\n+          assert(is_dominator(n, m) || is_dominator(m, n), \"one must dominate the other\");\n+          n = is_dominator(n, m) ? m : n;\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -381,20 +381,0 @@\n-  return st;\n-}\n-\n-\/\/ Card mark store. Must be ordered so that it will come after the store of\n-\/\/ the oop.\n-Node* IdealKit::storeCM(Node* ctl, Node* adr, Node *val, Node* oop_store, int oop_adr_idx,\n-                        BasicType bt,\n-                        int adr_idx) {\n-  assert(adr_idx != Compile::AliasIdxTop, \"use other store_to_memory factory\" );\n-  const TypePtr* adr_type = nullptr;\n-  debug_only(adr_type = C->get_adr_type(adr_idx));\n-  Node *mem = memory(adr_idx);\n-\n-  \/\/ Add required edge to oop_store, optimizer does not support precedence edges.\n-  \/\/ Convert required edge to precedence edge before allocation.\n-  Node* st = new StoreCMNode(ctl, mem, adr, adr_type, val, oop_store, oop_adr_idx);\n-\n-  st = transform(st);\n-  set_memory(st, adr_idx);\n-\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -237,9 +237,0 @@\n-  \/\/ Store a card mark ordered after store_oop\n-  Node* storeCM(Node* ctl,\n-                Node* adr,\n-                Node* val,\n-                Node* oop_store,\n-                int oop_adr_idx,\n-                BasicType bt,\n-                int adr_idx);\n-\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-    case Op_StoreCM:\n@@ -726,1 +725,0 @@\n-        case Op_StoreCM:\n@@ -1007,15 +1005,0 @@\n-\n-#ifdef ASSERT\n-      if (UseG1GC) {\n-        if( n->is_Mach() && n->as_Mach()->ideal_Opcode() == Op_StoreCM ) {\n-          \/\/ Check the precedence edges\n-          for (uint prec = n->req(); prec < n->len(); prec++) {\n-            Node* oop_store = n->in(prec);\n-            if (oop_store != nullptr) {\n-              assert(get_block_for_node(oop_store)->_dom_depth <= block->_dom_depth, \"oop_store must dominate card-mark\");\n-            }\n-          }\n-        }\n-      }\n-#endif\n-\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3819,1 +3819,1 @@\n-      if (opc == Op_StoreP || opc == Op_StoreN || opc == Op_StoreNKlass || opc == Op_StoreCM) {\n+      if (opc == Op_StoreP || opc == Op_StoreN || opc == Op_StoreNKlass) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3465,3 +3465,1 @@\n-  \/\/ unsafe if I have intervening uses...  Also disallowed for StoreCM\n-  \/\/ since they must follow each StoreP operation.  Redundant StoreCMs\n-  \/\/ are eliminated just before matching in final_graph_reshape.\n+  \/\/ unsafe if I have intervening uses.\n@@ -3477,1 +3475,1 @@\n-    while (st->is_Store() && st->outcnt() == 1 && st->Opcode() != Op_StoreCM) {\n+    while (st->is_Store() && st->outcnt() == 1) {\n@@ -3784,42 +3782,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* StoreCMNode::Identity(PhaseGVN* phase) {\n-  \/\/ No need to card mark when storing a null ptr\n-  Node* my_store = in(MemNode::OopStore);\n-  if (my_store->is_Store()) {\n-    const Type *t1 = phase->type( my_store->in(MemNode::ValueIn) );\n-    if( t1 == TypePtr::NULL_PTR ) {\n-      return in(MemNode::Memory);\n-    }\n-  }\n-  return this;\n-}\n-\n-\/\/=============================================================================\n-\/\/------------------------------Ideal---------------------------------------\n-Node *StoreCMNode::Ideal(PhaseGVN *phase, bool can_reshape){\n-  Node* progress = StoreNode::Ideal(phase, can_reshape);\n-  if (progress != nullptr) return progress;\n-\n-  Node* my_store = in(MemNode::OopStore);\n-  if (my_store->is_MergeMem()) {\n-    Node* mem = my_store->as_MergeMem()->memory_at(oop_alias_idx());\n-    set_req_X(MemNode::OopStore, mem, phase);\n-    return this;\n-  }\n-\n-  return nullptr;\n-}\n-\n-\/\/------------------------------Value-----------------------------------------\n-const Type* StoreCMNode::Value(PhaseGVN* phase) const {\n-  \/\/ Either input is TOP ==> the result is TOP (checked in StoreNode::Value).\n-  \/\/ If extra input is TOP ==> the result is TOP\n-  const Type* t = phase->type(in(MemNode::OopStore));\n-  if (t == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  return StoreNode::Value(phase);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":46,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-         ValueIn,               \/\/ Value to store\n-         OopStore               \/\/ Preceding oop store, only in StoreCM\n+         ValueIn                \/\/ Value to store\n@@ -780,30 +779,0 @@\n-\/\/------------------------------StoreCMNode-----------------------------------\n-\/\/ Store card-mark byte to memory for CM\n-\/\/ The last StoreCM before a SafePoint must be preserved and occur after its \"oop\" store\n-\/\/ Preceding equivalent StoreCMs may be eliminated.\n-class StoreCMNode : public StoreNode {\n- private:\n-  virtual uint hash() const { return StoreNode::hash() + _oop_alias_idx; }\n-  virtual bool cmp( const Node &n ) const {\n-    return _oop_alias_idx == ((StoreCMNode&)n)._oop_alias_idx\n-      && StoreNode::cmp(n);\n-  }\n-  virtual uint size_of() const { return sizeof(*this); }\n-  int _oop_alias_idx;   \/\/ The alias_idx of OopStore\n-\n-public:\n-  StoreCMNode( Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, int oop_alias_idx ) :\n-    StoreNode(c, mem, adr, at, val, oop_store, MemNode::release),\n-    _oop_alias_idx(oop_alias_idx) {\n-    assert(_oop_alias_idx >= Compile::AliasIdxRaw ||\n-           (_oop_alias_idx == Compile::AliasIdxBot && !Compile::current()->do_aliasing()),\n-           \"bad oop alias idx\");\n-  }\n-  virtual int Opcode() const;\n-  virtual Node* Identity(PhaseGVN* phase);\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual const Type* Value(PhaseGVN* phase) const;\n-  virtual BasicType memory_type() const { return T_VOID; } \/\/ unspecific\n-  int oop_alias_idx() const { return _oop_alias_idx; }\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1668,24 +1668,1 @@\n-        }\n-#ifdef ASSERT\n-          \/\/ Check that oop-store precedes the card-mark\n-        else if (mach->ideal_Opcode() == Op_StoreCM) {\n-          uint storeCM_idx = j;\n-          int count = 0;\n-          for (uint prec = mach->req(); prec < mach->len(); prec++) {\n-            Node *oop_store = mach->in(prec);  \/\/ Precedence edge\n-            if (oop_store == nullptr) continue;\n-            count++;\n-            uint i4;\n-            for (i4 = 0; i4 < last_inst; ++i4) {\n-              if (block->get_node(i4) == oop_store) {\n-                break;\n-              }\n-            }\n-            \/\/ Note: This test can provide a false failure if other precedence\n-            \/\/ edges have been added to the storeCMNode.\n-            assert(i4 == last_inst || i4 < storeCM_idx, \"CM card-mark executes before oop-store\");\n-          }\n-          assert(count > 0, \"storeCM expects at least one precedence edge\");\n-        }\n-#endif\n-        else if (!n->is_Proj()) {\n+        } else if (!n->is_Proj()) {\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -660,3 +660,0 @@\n-        } else if (out->Opcode() == Op_StoreCM && out->in(MemNode::OopStore) == n) {\n-          \/\/ StoreCM has an input edge used as a precedence edge.\n-          \/\/ Maybe an issue when oop stores are vectorized.\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1593,1 +1593,0 @@\n-  declare_c2_type(StoreCMNode, StoreNode)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}