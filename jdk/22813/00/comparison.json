{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-            catch( NoSuchMethodException | SecurityException e) {}\n+            catch( NoSuchMethodException e) {}\n","filename":"test\/jdk\/java\/beans\/Introspector\/8132566\/OverrideUserDefPropertyInfoTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,1 +120,1 @@\n-            for (Field field : getFields(type)) {\n+            for (Field field : type.getFields()) {\n@@ -242,3 +242,0 @@\n-        catch (SecurityException exception) {\n-            log(exception);\n-        }\n@@ -248,12 +245,0 @@\n-    private static final Field[] FIELDS = {};\n-\n-    private Field[] getFields(Class type) {\n-        try {\n-            return type.getFields();\n-        }\n-        catch (SecurityException exception) {\n-            log(exception);\n-        }\n-        return FIELDS;\n-    }\n-\n","filename":"test\/jdk\/java\/beans\/XMLEncoder\/BeanValidator.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,7 +29,0 @@\n-import java.util.Vector;\n-import java.util.Stack;\n-import java.util.Hashtable;\n-import java.lang.Math;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n@@ -46,3 +39,1 @@\n- * Subclasses of AbstractObjectInputStream must define SerializablePermission\n- * \"enableAbstractSubclass\" within a security policy file or this\n- * constructor will throw a SecurityException. Implementations of this\n+ * Implementations of this\n@@ -152,7 +143,0 @@\n-     * Add the following line to the security policy file to enable\n-     * subclassing.\n-     *\n-     * <PRE>\n-     *     permission SerializablePermission \"enableAbstractSubclass\" ;\n-     * <\/PRE><p>\n-     *\n@@ -161,2 +145,0 @@\n-     * @exception SecurityException if subclass does not have SerializablePermiision\n-     *            \"enableAbstractSubclass\".\n@@ -289,1 +271,1 @@\n-    protected abstract boolean enableResolveObject(boolean enable) throws SecurityException;\n+    protected abstract boolean enableResolveObject(boolean enable);\n","filename":"test\/jdk\/java\/io\/Serializable\/subclass\/AbstractObjectInputStream.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -48,3 +48,1 @@\n- * Subclasses of AbstractObjectOututStream must have SerializablePermission\n- * \"enableAbstractSubclass\" or this constructor will throw a\n- * SecurityException.Implementations of this class should protect themselves\n+ * Implementations of this class should protect themselves\n@@ -145,7 +143,0 @@\n-     * Add the following line to the security policy file to enable\n-     * subclassing.\n-     *\n-     * <PRE>\n-     *     permission SerializablePermission \"enableAbstractSubclass\" ;\n-     * <\/PRE><p>\n-     *\n@@ -234,1 +225,1 @@\n-    protected abstract boolean enableReplaceObject(boolean enable) throws SecurityException;\n+    protected abstract boolean enableReplaceObject(boolean enable);\n","filename":"test\/jdk\/java\/io\/Serializable\/subclass\/AbstractObjectOutputStream.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,7 +34,0 @@\n- *          Also, would be appropriate that this program verify\n- *          that if SerializablePermission \"enableSubclassImplementation\"\n- *          is not in the security policy and security is enabled, that\n- *          a security exception is thrown when constructing the\n- *          ObjectOutputStream subclass.\n- *\n- *\n@@ -132,2 +125,0 @@\n-        boolean expectSecurityException = false;\n-\n","filename":"test\/jdk\/java\/io\/Serializable\/subclass\/SubclassTest.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,14 +76,0 @@\n-            \/\/if currentDescriptor.isAssignable(Externalizable.class) {\n-            \/\/    Object[] argList = {this};\n-            \/\/    InvokeMethod(currentObject, readExternalMethod, argList);\n-            \/\/} else {\n-            \/\/    Does currentDescriptor have a readObject method\n-            \/\/    if it does\n-            \/\/        invokeMethod(this, readObjectMethod, {this});\n-            \/\/    else\n-            \/\/        defaultReadObject();\n-            \/\/}\n-            \/\/ check for replacement on currentObject.\n-            \/\/ if toplevel readobject\n-            \/\/    doObjectValidations.\n-\n@@ -248,38 +234,0 @@\n-\n-\n-    \/****************************************************************\/\n-\n-    \/* CODE LIFTED FROM ObjectStreamClass constuctor.\n-     * ObjectStreamClass.readObjectMethod is private.\n-     *\n-     * Look for the readObject method\n-     * Set the accessible flag on it here. ObjectOutputStream\n-     * will call it as necessary.\n-     *\/\n-    public static Method getReadObjectMethod(final Class<?> cl) {\n-\n-        Method readObjectMethod =\n-            java.security.AccessController.doPrivileged\n-            (new java.security.PrivilegedAction<Method>() {\n-                public Method run() {\n-                    Method m = null;\n-                    try {\n-                        Class<?>[] args = {ObjectInputStream.class};\n-                        m = cl.getDeclaredMethod(\"readObject\", args);\n-                        int mods = m.getModifiers();\n-                        \/\/ Method must be private and non-static\n-                        if (!Modifier.isPrivate(mods) ||\n-                            Modifier.isStatic(mods)) {\n-                            m = null;\n-                        } else {\n-                            m.setAccessible(true);\n-                        }\n-                    } catch (NoSuchMethodException e) {\n-                        m = null;\n-                    }\n-                    return m;\n-                }\n-            });\n-        return readObjectMethod;\n-    }\n-\n@@ -288,36 +236,1 @@\n-    \/* taken verbatim from ObjectInputStream. *\/\n-    private static void invokeMethod(final Object obj, final Method m,\n-                                        final Object[] argList)\n-        throws IOException\n-    {\n-        try {\n-            java.security.AccessController.doPrivileged\n-                (new java.security.PrivilegedExceptionAction<Void>() {\n-                    public Void run() throws InvocationTargetException,\n-                                        java.lang.IllegalAccessException {\n-                        m.invoke(obj, argList);\n-                        return null;\n-                    }\n-                });\n-        } catch (java.security.PrivilegedActionException e) {\n-            Exception ex = e.getException();\n-            if (ex instanceof InvocationTargetException) {\n-                Throwable t =\n-                        ((InvocationTargetException)ex).getTargetException();\n-                if (t instanceof IOException)\n-                    throw (IOException)t;\n-                else if (t instanceof RuntimeException)\n-                    throw (RuntimeException) t;\n-                else if (t instanceof Error)\n-                    throw (Error) t;\n-                else\n-                    throw new Error(\"interal error\");\n-            } else {\n-                \/\/ IllegalAccessException cannot happen\n-            }\n-        }\n-    }\n-\n-    protected boolean enableResolveObject(boolean enable)\n-        throws SecurityException\n-    {\n+    protected boolean enableResolveObject(boolean enable) {\n","filename":"test\/jdk\/java\/io\/Serializable\/subclass\/XObjectInputStream.java","additions":2,"deletions":89,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-    \/* CODE LIFTED FROM ObjectStreamClass constuctor.\n+    \/* CODE LIFTED FROM ObjectStreamClass constructor.\n@@ -305,24 +305,15 @@\n-\n-        Method writeObjectMethod =\n-            java.security.AccessController.doPrivileged\n-            (new java.security.PrivilegedAction<Method>() {\n-                public Method run() {\n-                    Method m = null;\n-                    try {\n-                        Class<?>[] args = {ObjectOutputStream.class};\n-                        m = cl.getDeclaredMethod(\"writeObject\", args);\n-                        int mods = m.getModifiers();\n-                        \/\/ Method must be private and non-static\n-                        if (!Modifier.isPrivate(mods) ||\n-                            Modifier.isStatic(mods)) {\n-                            m = null;\n-                        } else {\n-                            m.setAccessible(true);\n-                        }\n-                    } catch (NoSuchMethodException e) {\n-                        m = null;\n-                    }\n-                    return m;\n-                }\n-            });\n-        return writeObjectMethod;\n+        try {\n+            Class<?>[] args = {ObjectOutputStream.class};\n+            Method m = cl.getDeclaredMethod(\"writeObject\", args);\n+            int mods = m.getModifiers();\n+            \/\/ Method must be private and non-static\n+            if (!Modifier.isPrivate(mods) ||\n+                Modifier.isStatic(mods)) {\n+                return null;\n+            } else {\n+                m.setAccessible(true);\n+                return m;\n+            }\n+        } catch (NoSuchMethodException e) {\n+            return null;\n+        }\n@@ -339,24 +330,13 @@\n-            java.security.AccessController.doPrivileged\n-                (new java.security.PrivilegedExceptionAction<Void>() {\n-                    public Void run() throws InvocationTargetException,\n-                                        java.lang.IllegalAccessException {\n-                        m.invoke(obj, argList);\n-                        return null;\n-                    }\n-                });\n-        } catch (java.security.PrivilegedActionException e) {\n-            Exception ex = e.getException();\n-            if (ex instanceof InvocationTargetException) {\n-                Throwable t =\n-                        ((InvocationTargetException)ex).getTargetException();\n-                if (t instanceof IOException)\n-                    throw (IOException)t;\n-                else if (t instanceof RuntimeException)\n-                    throw (RuntimeException) t;\n-                else if (t instanceof Error)\n-                    throw (Error) t;\n-                else\n-                    throw new Error(\"interal error\");\n-            } else {\n-                \/\/ IllegalAccessException cannot happen\n-            }\n+            m.invoke(obj, argList);\n+        } catch (InvocationTargetException ex) {\n+            Throwable t = ex.getTargetException();\n+            if (t instanceof IOException)\n+                throw (IOException)t;\n+            else if (t instanceof RuntimeException)\n+                throw (RuntimeException) t;\n+            else if (t instanceof Error)\n+                throw (Error) t;\n+            else\n+                throw new Error(\"intenral error\");\n+        } catch (IllegalAccessException iae) {\n+            \/\/ IllegalAccessException can not happen\n","filename":"test\/jdk\/java\/io\/Serializable\/subclass\/XObjectOutputStream.java","additions":29,"deletions":49,"binary":false,"changes":78,"status":"modified"}]}