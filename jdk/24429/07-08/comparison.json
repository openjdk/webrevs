{"files":[{"patch":"@@ -29,2 +29,0 @@\n-import java.security.AlgorithmParametersSpi;\n-import java.security.NoSuchAlgorithmException;\n@@ -66,1 +64,1 @@\n-abstract class PBMAC1Parameters extends AlgorithmParametersSpi {\n+final public class PBMAC1Parameters {\n@@ -93,1 +91,1 @@\n-    protected void engineInit(byte[] encoded) throws IOException {\n+    public void engineInit(byte[] encoded) throws IOException {\n@@ -194,1 +192,1 @@\n-    protected String engineToString() {\n+    public String engineToString() {\n@@ -198,4 +196,5 @@\n-    public static final class General extends PBMAC1Parameters {\n-        public General() throws NoSuchAlgorithmException {\n-            super();\n-        }\n+    public byte[] getSalt() {\n+        return salt;\n+    }\n+    public int getIterations() {\n+        return iCount;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBMAC1Parameters.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -547,4 +547,0 @@\n-        psA(\"AlgorithmParameters\", \"PBMAC1\",\n-                \"com.sun.crypto.provider.PBMAC1Parameters$General\",\n-                null);\n-\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.security.AlgorithmParameters;\n+import java.security.MessageDigest;\n@@ -31,0 +31,1 @@\n+import java.security.UnrecoverableKeyException;\n@@ -32,2 +33,0 @@\n-import java.security.spec.InvalidParameterSpecException;\n-import java.util.Objects;\n@@ -36,0 +35,4 @@\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n@@ -37,0 +40,1 @@\n+import javax.security.auth.DestroyFailedException;\n@@ -38,0 +42,1 @@\n+import com.sun.crypto.provider.PBMAC1Parameters;\n@@ -51,0 +56,1 @@\n+    private static final Debug debug = Debug.getInstance(\"pkcs12\");\n@@ -52,1 +58,0 @@\n-    private final AlgorithmParameters digestAlgorithmParams;\n@@ -54,2 +59,2 @@\n-    private byte[] macSalt;\n-    private int iterations;\n+    private final byte[] macSalt;\n+    private final int iterations;\n@@ -83,1 +88,0 @@\n-        this.digestAlgorithmParams = digestAlgorithmId.getParameters();\n@@ -89,1 +93,1 @@\n-            PBEParameterSpec pbeSpec;\n+            PBMAC1Parameters algParams;\n@@ -91,10 +95,2 @@\n-            try {\n-                pbeSpec =\n-                        this.digestAlgorithmParams.getParameterSpec(\n-                        PBEParameterSpec.class);\n-            } catch (InvalidParameterSpecException ipse) {\n-                throw new IOException(\n-                        \"Invalid PBE algorithm parameters\");\n-            }\n-            this.iterations = pbeSpec.getIterationCount();\n-            this.macSalt = pbeSpec.getSalt();\n+            algParams = new PBMAC1Parameters();\n+            algParams.engineInit(digestAlgorithmId.getEncodedParams());\n@@ -102,3 +98,2 @@\n-            String ps = this.digestAlgorithmParams.toString();\n-            this.kdfHmac = getKdfHmac(ps);\n-            this.Hmac = getHmac(ps);\n+            this.iterations = algParams.getIterations();\n+            this.macSalt = algParams.getSalt();\n@@ -106,9 +101,3 @@\n-            if (!this.kdfHmac.equals(this.Hmac)) {\n-                throw new IOException(\"PRF and Hmac must be same\");\n-            }\n-            if (!(this.kdfHmac.equals(\"HmacSHA512\") ||\n-                    this.kdfHmac.equals(\"HmacSHA256\"))) {\n-                throw new IOException(\"unsupported PBMAC1 Hmac\");\n-            }\n-\n-            this.Hmac = this.kdfHmac;\n+            String ps = algParams.engineToString();\n+            this.kdfHmac = parseKdfHmac(ps);\n+            this.Hmac = parseHmac(ps);\n@@ -126,1 +115,1 @@\n-            String kdfHmac, int keyLength) throws NoSuchAlgorithmException {\n+            String kdfHmac, String Hmac, int keyLength) throws NoSuchAlgorithmException {\n@@ -139,1 +128,0 @@\n-        this.digestAlgorithmParams = algid.getParameters();\n@@ -159,1 +147,1 @@\n-            this.Hmac = kdfHmac;\n+            this.Hmac = Hmac;\n@@ -174,0 +162,152 @@\n+    \/*\n+     * Destroy the key obtained from getPBEKey().\n+     *\/\n+    static void destroyPBEKey(SecretKey key) {\n+        try {\n+            key.destroy();\n+        } catch (DestroyFailedException e) {\n+            \/\/ Accept this\n+        }\n+    }\n+\n+    \/**\n+     * Retries an action with password \"\\0\" if \"\" fails.\n+     * @param <T> the return type\n+     *\/\n+    @FunctionalInterface\n+    private interface RetryWithZero<T> {\n+\n+        T tryOnce(char[] password) throws Exception;\n+\n+        static <S> S run(RetryWithZero<S> f, char[] password) throws Exception {\n+            try {\n+                return f.tryOnce(password);\n+            } catch (Exception e) {\n+                if (password.length == 0) {\n+                    \/\/ Retry using an empty password with a NUL terminator.\n+                    if (debug != null) {\n+                        debug.println(\"Retry with a NUL password\");\n+                    }\n+                    return f.tryOnce(new char[1]);\n+                }\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    void processMacData(AlgorithmParameterSpec params,\n+            MacData macData, char[] password, byte[] data, String macAlgorithm)\n+            throws  Exception {\n+        final String kdfHmac;\n+        final String Hmac;\n+\n+        if (macAlgorithm.startsWith(\"PBEWith\")) {\n+            kdfHmac = macData.getKdfHmac();\n+            Hmac = macData.getHmac();\n+        } else {\n+            kdfHmac = macAlgorithm;\n+            Hmac = macAlgorithm;\n+        }\n+\n+        var skf = SecretKeyFactory.getInstance(\n+                kdfHmac.equals(\"HmacSHA512\") ?\n+                \"PBKDF2WithHmacSHA512\" : \"PBKDF2WithHmacSHA256\");\n+\n+        RetryWithZero.run(pass -> {\n+            SecretKey pbeKey = skf.generateSecret(new PBEKeySpec(pass,\n+                    ((PBEParameterSpec)params).getSalt(),\n+                    ((PBEParameterSpec)params).getIterationCount(),\n+                    Hmac.equals(\"HmacSHA512\") ? 64*8 : 32*8));\n+            Mac m = Mac.getInstance(Hmac);\n+            try {\n+                m.init(pbeKey);\n+            } finally {\n+                destroyPBEKey(pbeKey);\n+            }\n+            m.update(data);\n+            byte[] macResult = m.doFinal();\n+\n+            if (debug != null) {\n+                debug.println(\"Checking keystore integrity \" +\n+                        \"(\" + m.getAlgorithm() + \" iterations: \"\n+                        + macData.getIterations() + \")\");\n+            }\n+\n+            if (!MessageDigest.isEqual(macData.getDigest(), macResult)) {\n+                throw new UnrecoverableKeyException(\"Failed PKCS12\" +\n+                        \" integrity checking\");\n+            }\n+            return (Void) null;\n+        }, password);\n+    }\n+\n+    \/*\n+     * Calculate MAC using HMAC algorithm (required for password integrity)\n+     *\n+     * Hash-based MAC algorithm combines secret key with message digest to\n+     * create a message authentication code (MAC)\n+     *\/\n+    public static byte[] calculateMac(char[] passwd, byte[] data, boolean newKeystore,\n+            String macAlgorithm, int macIterationCount, byte[] salt)\n+        throws IOException, NoSuchAlgorithmException\n+    {\n+        final byte[] mData;\n+        final PBEParameterSpec params;\n+        final MacData macData;\n+        String algName = \"PBMAC1\";\n+        String kdfHmac = null;\n+        String Hmac = null;\n+\n+        if (newKeystore) {\n+            if (macAlgorithm.startsWith(\"PBEWith\")) {\n+                kdfHmac = MacData.parseKdfHmac(macAlgorithm);\n+                Hmac = MacData.parseHmac(macAlgorithm);\n+                if (Hmac == null) {\n+                    Hmac = kdfHmac;\n+                }\n+            }\n+        } else {\n+            String tmp = MacData.parseKdfHmac(macAlgorithm);\n+            if (tmp != null) {\n+                kdfHmac = tmp;\n+                Hmac = MacData.parseHmac(macAlgorithm);\n+            }\n+        }\n+        \/\/ Fall back to old way of computing MAC\n+        if (kdfHmac == null) {\n+            algName = macAlgorithm.substring(7);\n+            kdfHmac = macAlgorithm;\n+            Hmac = macAlgorithm;\n+        }\n+\n+        params = new PBEParameterSpec(salt, macIterationCount);\n+\n+        var skf = SecretKeyFactory.getInstance(kdfHmac.equals(\"HmacSHA512\") ?\n+                \"PBKDF2WithHmacSHA512\" : \"PBKDF2WithHmacSHA256\");\n+        try {\n+            int keyLength = Hmac.equals(\"HmacSHA512\") ? 64*8 : 32*8;\n+\n+            SecretKey pbeKey = skf.generateSecret(new PBEKeySpec(passwd,\n+                    params.getSalt(), macIterationCount, keyLength));\n+\n+            Mac m = Mac.getInstance(Hmac);\n+            try {\n+                m.init(pbeKey);\n+            } finally {\n+                destroyPBEKey(pbeKey);\n+            }\n+            m.update(data);\n+            byte[] macResult = m.doFinal();\n+\n+            \/\/ encode as MacData\n+            macData = new MacData(algName, macResult, params,\n+                    kdfHmac, Hmac, keyLength);\n+            DerOutputStream bytes = new DerOutputStream();\n+            bytes.write(macData.getEncoded());\n+            mData = bytes.toByteArray();\n+        } catch (Exception e) {\n+            throw new IOException(\"calculateMac failed: \" + e, e);\n+        }\n+        return mData;\n+    }\n+\n@@ -194,0 +334,4 @@\n+    String getHmac() {\n+        return this.Hmac;\n+    }\n+\n@@ -285,1 +429,1 @@\n-    public String getKdfHmac(String text) {\n+    public static String parseKdfHmac(String text) {\n@@ -289,3 +433,3 @@\n-        String regex = Pattern.quote(word1) + \"(.*?)\" + Pattern.quote(word2);\n-        Pattern pattern = Pattern.compile(regex);\n-        Matcher matcher = pattern.matcher(text);\n+        String regex1 = Pattern.quote(word1) + \"(.*?)\" + Pattern.quote(word2);\n+        Pattern pattern1 = Pattern.compile(regex1);\n+        Matcher matcher1 = pattern1.matcher(text);\n@@ -293,4 +437,8 @@\n-        if (matcher.find()) {\n-            return matcher.group(1);\n-        } else {\n-            return null;\n+        String regex2 = Pattern.quote(word1) + \"(.*?)$\";\n+        Pattern pattern2 = Pattern.compile(regex2);\n+        Matcher matcher2 = pattern2.matcher(text);\n+\n+        if (matcher1.find()) {\n+            return matcher1.group(1);\n+        } else if (matcher2.find()) {\n+                return matcher2.group(1);\n@@ -298,0 +446,1 @@\n+        return null;\n@@ -300,1 +449,1 @@\n-    public static String getHmac(String text) {\n+    public static String parseHmac(String text) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/MacData.java","additions":191,"deletions":42,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -176,1 +176,0 @@\n-    private String pbmac1Hmac = null;\n@@ -1256,1 +1255,2 @@\n-            byte[] macData = calculateMac(password, authenticatedSafe);\n+            byte[] macData = MacData.calculateMac(password, authenticatedSafe,\n+                   newKeystore, macAlgorithm, macIterationCount, getSalt());\n@@ -1471,73 +1471,0 @@\n-    \/*\n-     * Calculate MAC using HMAC algorithm (required for password integrity)\n-     *\n-     * Hash-based MAC algorithm combines secret key with message digest to\n-     * create a message authentication code (MAC)\n-     *\/\n-    private byte[] calculateMac(char[] passwd, byte[] data)\n-        throws IOException, NoSuchAlgorithmException\n-    {\n-        final byte[] mData;\n-        final PBEParameterSpec params;\n-        final String algName;\n-        final MacData macData;\n-        String kdfHmac;\n-        int writeIterationCount = macIterationCount;\n-\n-        if (newKeystore) {\n-            if (macAlgorithm.startsWith(\"PBEWith\") ||\n-                    defaultMacAlgorithm().startsWith(\"PBEWith\")) {\n-                kdfHmac = defaultMacAlgorithm().replace(\"PBEWith\", \"\");\n-                if (!(kdfHmac.equals(\"HmacSHA512\") ||\n-                        kdfHmac.equals(\"HmacSHA256\"))) {\n-                    kdfHmac = pbmac1Hmac; \/\/ use value associated with keystore\n-                }\n-                algName = \"PBMAC1\";\n-                \/\/ Override with value of security property.\n-                writeIterationCount = defaultMacIterationCount();\n-            } else {\n-                algName = macAlgorithm.substring(7);\n-                kdfHmac = macAlgorithm;\n-            }\n-        } else {\n-            if (pbmac1Hmac != null) { \/\/ have PBMAC1 keystore\n-                kdfHmac = pbmac1Hmac;\n-                algName = \"PBMAC1\";\n-            } else {\n-                algName = macAlgorithm.substring(7);\n-                kdfHmac = macAlgorithm;\n-            }\n-        }\n-\n-        params = new PBEParameterSpec(getSalt(), writeIterationCount);\n-\n-        var skf = SecretKeyFactory.getInstance(kdfHmac.equals(\"HmacSHA512\") ?\n-                \"PBKDF2WithHmacSHA512\" : \"PBKDF2WithHmacSHA256\");\n-        try {\n-            int keyLength = kdfHmac.equals(\"HmacSHA512\") ? 64*8 : 32*8;\n-\n-            SecretKey pbeKey = skf.generateSecret(new PBEKeySpec(passwd,\n-                    params.getSalt(), writeIterationCount, keyLength));\n-\n-            Mac m = Mac.getInstance(kdfHmac);\n-            try {\n-                m.init(pbeKey);\n-            } finally {\n-                destroyPBEKey(pbeKey);\n-            }\n-            m.update(data);\n-            byte[] macResult = m.doFinal();\n-\n-            \/\/ encode as MacData\n-            macData = new MacData(algName, macResult, params,\n-                    kdfHmac, keyLength);\n-            DerOutputStream bytes = new DerOutputStream();\n-            bytes.write(macData.getEncoded());\n-            mData = bytes.toByteArray();\n-        } catch (Exception e) {\n-            throw new IOException(\"calculateMac failed: \" + e, e);\n-        }\n-        return mData;\n-    }\n-\n-\n@@ -1951,45 +1878,0 @@\n-    private void processMacData(AlgorithmParameterSpec params,\n-            MacData macData, char[] password, byte[] data, String macAlgorithm)\n-            throws  Exception {\n-        final String kdfHmac;\n-        String tmp;\n-\n-        tmp = macAlgorithm.replace(\"PBEWith\", \"\");\n-        if (!(tmp.equals(\"HmacSHA512\") || tmp.equals(\"HmacSHA256\"))) {\n-            kdfHmac = macAlgorithm;\n-        } else {\n-            kdfHmac = tmp;\n-        }\n-\n-        var skf = SecretKeyFactory.getInstance(\n-                macAlgorithm.contains(\"HmacSHA512\") ?\n-                \"PBKDF2WithHmacSHA512\" : \"PBKDF2WithHmacSHA256\");\n-\n-        RetryWithZero.run(pass -> {\n-            SecretKey pbeKey = skf.generateSecret(new PBEKeySpec(pass,\n-                    ((PBEParameterSpec)params).getSalt(),\n-                    ((PBEParameterSpec)params).getIterationCount(),\n-                    kdfHmac.equals(\"HmacSHA512\") ? 64*8 : 32*8));\n-            Mac m = Mac.getInstance(kdfHmac);\n-            try {\n-                m.init(pbeKey);\n-            } finally {\n-                destroyPBEKey(pbeKey);\n-            }\n-            m.update(data);\n-            byte[] macResult = m.doFinal();\n-\n-            if (debug != null) {\n-                debug.println(\"Checking keystore integrity \" +\n-                        \"(\" + m.getAlgorithm() + \" iterations: \"\n-                        + macData.getIterations() + \")\");\n-            }\n-\n-            if (!MessageDigest.isEqual(macData.getDigest(), macResult)) {\n-                throw new UnrecoverableKeyException(\"Failed PKCS12\" +\n-                        \" integrity checking\");\n-            }\n-            return (Void) null;\n-        }, password);\n-    }\n-\n@@ -2206,9 +2088,2 @@\n-\n-                        String pbmac1KdfHmac = macData.getKdfHmac();\n-                        pbmac1Hmac = pbmac1KdfHmac;\n-                        macIterationCount = ic;\n-                        macAlgorithm = \"PBEWith\" + pbmac1KdfHmac;\n-                        PBEParameterSpec params =\n-                                new PBEParameterSpec(salt, ic);\n-                        processMacData(params, macData, password, authSafeData,\n-                                macAlgorithm);\n+                        macAlgorithm = \"PBEWith\" + macData.getKdfHmac()\n+                        + \"And\" + macData.getHmac();\n@@ -2216,1 +2091,0 @@\n-\n@@ -2220,6 +2094,0 @@\n-                        macIterationCount = ic;\n-\n-                        PBEParameterSpec params =\n-                                new PBEParameterSpec(salt, ic);\n-                        processMacData(params, macData, password, authSafeData,\n-                                macAlgorithm);\n@@ -2227,0 +2095,4 @@\n+                    macIterationCount = ic;\n+                    PBEParameterSpec params = new PBEParameterSpec(salt, ic);\n+                    macData.processMacData(params, macData, password, authSafeData,\n+                            macAlgorithm);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/PKCS12KeyStore.java","additions":8,"deletions":136,"binary":false,"changes":144,"status":"modified"}]}