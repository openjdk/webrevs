{"files":[{"patch":"@@ -244,4 +244,0 @@\n-        if (pBKDF2_params.tag != DerValue.tag_Sequence) {\n-            throw new IOException(\"PBKDF2 parameter parsing error: \"\n-                + \"not an ASN.1 SEQUENCE tag\");\n-        }\n@@ -307,3 +303,4 @@\n-        pBES2_params.write(DerValue.tag_Sequence,\n-                \/\/ keysize encoded as octets\n-                PBKDF2Parameters.encode(salt, iCount, keysize\/8, kdfAlgo_OID));\n+\n+        \/\/ keysize encoded as octets\n+        pBES2_params.writeBytes(PBKDF2Parameters.encode(salt, iCount,\n+                keysize\/8, kdfAlgo_OID));\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+\n+    \/\/ The following three fields are for PBMAC1.\n@@ -135,1 +137,25 @@\n-    private static byte[] getMac(String macAlgorithm, char[] password,\n+    \/**\n+     * Computes a MAC on the data.\n+     *\n+     * This is a two-step process: first generate a key and then use the\n+     * key to generate the MAC. PBMAC1 and non-PBMAC1 keys use different\n+     * key factories. PBMAC1 uses a pseudorandom function (kdfHmac)\n+     * to generate keys while non-PBMAC1 does not. The MAC is computed\n+     * according to the specified hmac algorithm.\n+     *\n+     * @param macAlgorithm the algorithm used to compute the MAC\n+     * @param password the password used to generate the key\n+     * @param params a PBEParameterSpec object\n+     * @param data the data on which the MAC is computed\n+     * @param kdfHmac the pseudorandom function used to compute the key\n+     * for PBMAC1\n+     * @param hmac the algorithm used to compute the MAC\n+     * @param keyLength the length of the key generated by the pseudorandom\n+     * function\n+     *\n+     * @return the computed MAC as a byte array\n+     *\n+     * @exception NoSuchAlgorithmException if either kdfHmac or hmac is\n+     * unknown to the Mac or SecretKeyFactory\n+     *\/\n+    private static byte[] calculateMac(String macAlgorithm, char[] password,\n@@ -138,2 +164,2 @@\n-            throws NoSuchAlgorithmException, InvalidKeySpecException,\n-            InvalidKeyException, InvalidAlgorithmParameterException {\n+            throws InvalidAlgorithmParameterException, InvalidKeyException,\n+            InvalidKeySpecException, NoSuchAlgorithmException {\n@@ -141,1 +167,1 @@\n-        SecretKey pbeKey;\n+        SecretKey pbeKey = null;\n@@ -146,3 +172,7 @@\n-        \/\/ The Hmac has to be extracted from the algorithm name for\n-        \/\/ PBMAC1 algorithms. For non-PBMAC1 macAlgorithms, the name\n-        \/\/ and Hmac are the same.\n+        \/*\n+         * The Hmac has to be extracted from the algorithm name for\n+         * PBMAC1 algorithms. For non-PBMAC1 macAlgorithms, the name\n+         * and Hmac are the same.\n+         *\n+         * The prefix used in Algorithm names is guaranteed to be lowercase.\n+         *\/\n@@ -160,1 +190,0 @@\n-        pbeKey = skf.generateSecret(keySpec);\n@@ -163,0 +192,1 @@\n+            pbeKey = skf.generateSecret(keySpec);\n@@ -168,0 +198,2 @@\n+            m.update(data);\n+            return m.doFinal();\n@@ -170,1 +202,1 @@\n-            sun.security.util.KeyUtil.destroySecretKeys(pbeKey);\n+            KeyUtil.destroySecretKeys(pbeKey);\n@@ -172,2 +204,0 @@\n-        m.update(data);\n-        return m.doFinal();\n@@ -176,4 +206,15 @@\n-    void processMacData(char[] password, byte[] data)\n-            throws InvalidKeySpecException,\n-            NoSuchAlgorithmException, UnrecoverableKeyException,\n-            InvalidKeyException, InvalidAlgorithmParameterException {\n+    \/**\n+     * Verify Mac on the data.\n+     *\n+     * Calculate Mac on the data and compare with Mac found in input stream.\n+     *\n+     * @param password the password used to generate the key\n+     * @param data the data on which the MAC is computed\n+     *\n+     * @exception UnrecoverableKeyException if calculated Mac and\n+     * Mac found in input stream are different\n+     *\/\n+    void verifyMac(char[] password, byte[] data)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException,\n+            InvalidKeySpecException, NoSuchAlgorithmException,\n+            UnrecoverableKeyException {\n@@ -181,1 +222,1 @@\n-        byte[] macResult = getMac(this.macAlgorithm, password,\n+        byte[] macResult = calculateMac(this.macAlgorithm, password,\n@@ -198,1 +239,7 @@\n-     * Calculate MAC using HMAC algorithm (required for password integrity)\n+     * Gathers parameters and generates a MAC of the data\n+     *\n+     * @param password the password used to generate the key\n+     * @param data the data on which the MAC is computed\n+     * @param macAlgorithm the algorithm used to compute the MAC\n+     * @param macIterationCount the iteration count\n+     * @param salt the salt\n@@ -200,2 +247,3 @@\n-     * Hash-based MAC algorithm combines secret key with message digest to\n-     * create a message authentication code (MAC)\n+     * @exception IOException if the MAC cannot be calculated\n+     *\n+     * @return the computed MAC as a byte array\n@@ -203,1 +251,1 @@\n-    static byte[] calculateMac(char[] passwd, byte[] data,\n+    static byte[] generateMac(char[] passwd, byte[] data,\n@@ -212,0 +260,1 @@\n+        \/\/ The prefix used in Algorithm names is guaranteed to be lowercase.\n@@ -231,1 +280,1 @@\n-            byte[] macResult = getMac(macAlgorithm, passwd, params, data,\n+            byte[] macResult = calculateMac(macAlgorithm, passwd, params, data,\n@@ -248,4 +297,0 @@\n-    byte[] getSalt() {\n-        return this.macSalt;\n-    }\n-\n@@ -257,2 +302,2 @@\n-     * Returns the ASN.1 encoding of this object.\n-     * @return the ASN.1 encoding.\n+     * Returns the ASN.1 encoding.\n+     * @return the ASN.1 encoding\n@@ -264,1 +309,1 @@\n-            throws NoSuchAlgorithmException, IOException {\n+            throws IOException, NoSuchAlgorithmException {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/MacData.java","additions":73,"deletions":28,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.security.NoSuchAlgorithmException;\n@@ -31,0 +32,1 @@\n+import sun.security.x509.AlgorithmId;\n@@ -109,4 +111,0 @@\n-        if (pBKDF2_params.tag != DerValue.tag_Sequence) {\n-            throw new IOException(\"PBKDF2 parameter parsing error: \"\n-                + \"not an ASN.1 SEQUENCE tag\");\n-        }\n@@ -121,1 +119,2 @@\n-            String kdfHmac, String hmac, byte[] digest) {\n+            String kdfHmac, String hmac, byte[] digest)\n+            throws IOException, NoSuchAlgorithmException {\n@@ -128,5 +127,0 @@\n-        DerOutputStream tmp4 = new DerOutputStream();\n-\n-        \/\/ messageAuthScheme AlgorithmIdentifier {{PBMAC1-MACs}}\n-        tmp4.putOID(ObjectIdentifier.of(KnownOIDs.findMatch(hmac)));\n-        tmp4.putNull();\n@@ -135,1 +129,1 @@\n-        tmp3.write(DerValue.tag_Sequence, PBKDF2Parameters.encode(salt,\n+        tmp3.writeBytes(PBKDF2Parameters.encode(salt,\n@@ -137,1 +131,3 @@\n-        tmp3.write(DerValue.tag_Sequence, tmp4);\n+\n+        \/\/ messageAuthScheme AlgorithmIdentifier {{PBMAC1-MACs}}\n+        tmp3.write(AlgorithmId.get(hmac));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/PBMAC1Parameters.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-                    sun.security.util.KeyUtil.destroySecretKeys(skey);\n+                    KeyUtil.destroySecretKeys(skey);\n@@ -891,1 +891,1 @@\n-                sun.security.util.KeyUtil.destroySecretKeys(skey);\n+                KeyUtil.destroySecretKeys(skey);\n@@ -1241,1 +1241,1 @@\n-            byte[] macData = MacData.calculateMac(password, authenticatedSafe,\n+            byte[] macData = MacData.generateMac(password, authenticatedSafe,\n@@ -1825,1 +1825,1 @@\n-                sun.security.util.KeyUtil.destroySecretKeys(skey);\n+                KeyUtil.destroySecretKeys(skey);\n@@ -2035,1 +2035,1 @@\n-                            sun.security.util.KeyUtil.destroySecretKeys(skey);\n+                            KeyUtil.destroySecretKeys(skey);\n@@ -2074,1 +2074,1 @@\n-                        macData.processMacData(pass, authSafeData);\n+                        macData.verifyMac(pass, authSafeData);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/PKCS12KeyStore.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import sun.security.x509.AlgorithmId;\n+\n@@ -92,0 +94,4 @@\n+        if (pBKDF2_params.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"PBKDF2 parameter parsing error: \"\n+                + \"not an ASN.1 SEQUENCE tag\");\n+        }\n@@ -155,4 +161,0 @@\n-        \/\/ prf AlgorithmIdentifier {{PBKDF2-PRFs}}\n-        tmp1.putOID(prf);\n-        tmp1.putNull();\n-\n@@ -162,1 +164,3 @@\n-        tmp0.write(DerValue.tag_Sequence, tmp1);\n+\n+        \/\/ prf AlgorithmIdentifier {{PBKDF2-PRFs}}\n+        tmp0.write(new AlgorithmId(prf));\n@@ -168,1 +172,2 @@\n-        return out.toByteArray();\n+        return new DerOutputStream().write(DerValue.tag_Sequence, out)\n+                .toByteArray();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/PBKDF2Parameters.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1344,2 +1344,2 @@\n-# file. This can be any HmacPBE or PBEWith<mac> algorithm defined in the\n-# Mac section of the Java Security Standard Algorithm Names Specification,\n+# file. This can be any HmacPBE<digest> or PBEWith<mac> algorithm defined in\n+# the Mac section of the Java Security Standard Algorithm Names Specification,\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343232\n+ * @summary Verify correctness of the structure of PKCS12 PBMAC1\n+ *          keystores created with various property values.\n+ *          Verify that keystores load correctly from an input stream.\n+ * @modules java.base\/sun.security.util\n+ * @library \/test\/lib\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.DerUtils;\n+import sun.security.util.KnownOIDs;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+\n+public class PBMAC1Test {\n+\n+    static final char[] PASSWORD = \"1234\".toCharArray();\n+\n+    public static void main(String[] args) throws Exception {\n+        create();\n+        migrate();\n+        overflow();\n+    }\n+\n+    \/\/ PBMAC1 inside PKCS12\n+    \/\/0019:008B  [2]     SEQUENCE\n+    \/\/001C:007B  [20]         SEQUENCE\n+    \/\/001E:0057  [200]             SEQUENCE\n+    \/\/0020:000B  [2000]                 OID 1.2.840.113549.1.5.14 (PBMAC1)\n+    \/\/002B:004A  [2001]                 SEQUENCE\n+    \/\/002D:003A  [20010]                     SEQUENCE\n+    \/\/002F:000B  [200100]                         OID 1.2.840.113549.1.5.12 (PBKDF2WithHmacSHA1)\n+    \/\/003A:002D  [200101]                         SEQUENCE\n+    \/\/003C:0016  [2001010]                             OCTET STRING (20 bytes of salt)\n+    \/\/0052:0004  [2001011]                             INTEGER 10000\n+    \/\/0056:0003  [2001012]                             INTEGER 32\n+    \/\/0059:000E  [2001013]                             SEQUENCE\n+    \/\/005B:000A  [20010130]                                 OID 1.2.840.113549.2.9 (HmacSHA256)\n+    \/\/0065:0002  [20010131]                                 NULL\n+    \/\/0067:000E  [20011]                     SEQUENCE\n+    \/\/0069:000A  [200110]                         OID 1.2.840.113549.2.9 (HmacSHA256)\n+    \/\/0073:0002  [200111]                         NULL\n+    \/\/0075:0022  [201]             OCTET STRING (32 bytes of mac)\n+    \/\/0097:000A  [21]         OCTET STRING (8 bytes of useless salt)\n+    \/\/00A1:0003  [22]         INTEGER 1\n+    static void create() throws Exception {\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"pbewithhmacsha256\");\n+        var der = emptyP12();\n+        DerUtils.checkAlg(der, \"2000\", KnownOIDs.PBMAC1);\n+        DerUtils.checkAlg(der, \"200100\", KnownOIDs.PBKDF2WithHmacSHA1);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA256);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA256);\n+        DerUtils.checkInt(der, \"2001011\", 10000);\n+        DerUtils.checkInt(der, \"2001012\", 32);\n+\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"PBEWITHHMACSHA512\");\n+        der = emptyP12();\n+        DerUtils.checkAlg(der, \"2000\", KnownOIDs.PBMAC1);\n+        DerUtils.checkAlg(der, \"200100\", KnownOIDs.PBKDF2WithHmacSHA1);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA512);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA512);\n+        DerUtils.checkInt(der, \"2001011\", 10000);\n+        DerUtils.checkInt(der, \"2001012\", 64);\n+\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"PBEWiThHmAcSHA512\/224\");\n+        der = emptyP12();\n+        DerUtils.checkAlg(der, \"2000\", KnownOIDs.PBMAC1);\n+        DerUtils.checkAlg(der, \"200100\", KnownOIDs.PBKDF2WithHmacSHA1);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA512$224);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA512$224);\n+        DerUtils.checkInt(der, \"2001011\", 10000);\n+        DerUtils.checkInt(der, \"2001012\", 28);\n+\n+        \/\/ As strange as I can...\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\",\n+                \"PBEWithHmacSHA512\/224AndHmacSHA3-384\");\n+        der = emptyP12();\n+        DerUtils.checkAlg(der, \"2000\", KnownOIDs.PBMAC1);\n+        DerUtils.checkAlg(der, \"200100\", KnownOIDs.PBKDF2WithHmacSHA1);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA512$224);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA3_384);\n+        DerUtils.checkInt(der, \"2001011\", 10000);\n+        DerUtils.checkInt(der, \"2001012\", 48);\n+\n+        \/\/ Bad alg names\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"PBEWithHmacSHA456\");\n+        var reason = Asserts.assertThrows(NoSuchAlgorithmException.class,\n+                () -> emptyP12()).getMessage();\n+        Asserts.assertTrue(reason.contains(\"Algorithm hmacsha456 not available\"), reason);\n+    }\n+\n+    static void migrate() throws Exception {\n+        \/\/ A pkcs12 file using PBEWithHmacSHA256 but key length is 8\n+        var sha2p12 = \"\"\"\n+                MIGhAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBiDB5MFUGCSqGSIb3DQEFDjBIMDgGCSqGSIb3DQEF\n+                DDArBBSV6e5xI+9AYtGHQlDI0X4pmvWLBQICJxACAQgwDAYIKoZIhvcNAgkFADAMBggqhkiG9w0C\n+                CQUABCAaaSO6JgEh1lDo1pvAC0CF5HqgIFBvzt1+GZlgFy7xFQQITk9UIFVTRUQCAQE=\n+                \"\"\";\n+        var der = Base64.getMimeDecoder().decode(sha2p12);\n+        DerUtils.checkInt(der, \"2001012\", 8); \/\/ key length used to be 8\n+\n+        der = loadAndStore(sha2p12);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA256);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA256);\n+        DerUtils.checkInt(der, \"2001012\", 32); \/\/ key length changed to 32\n+    }\n+\n+    static void overflow() throws Exception {\n+\n+        \/\/ Cannot create new\n+        System.setProperty(\"keystore.pkcs12.macIterationCount\", \"5000001\");\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"pbewithhmacsha256\");\n+        Asserts.assertThrows(IllegalArgumentException.class, PBMAC1Test::emptyP12);\n+        System.clearProperty(\"keystore.pkcs12.macAlgorithm\");\n+        Asserts.assertThrows(IllegalArgumentException.class, PBMAC1Test::emptyP12);\n+\n+        \/\/ IC=5000001 using old algorithm\n+        var bigICt = \"\"\"\n+                MGYCAQMwEQYJKoZIhvcNAQcBoAQEAjAAME4wMTANBglghkgBZQMEAgEFAAQgyLBK5h9\/E\/2o7l2A\n+                eALbI1otiS8kT3C41Ef3T38OMjUEFIic7isrAJNr+3+8fUbnMtmB0qytAgNMS0E=\n+                \"\"\";\n+\n+        \/\/ IC=5000000 using old algorithm\n+        var smallICt = \"\"\"\n+                MGYCAQMwEQYJKoZIhvcNAQcBoAQEAjAAME4wMTANBglghkgBZQMEAgEFAAQgR61YZLW6H81rkGTk\n+                XfuU138mkIugdoQBhuNsnvWuBtQEFJ0wmMlpoUiji8PlvwCrmMbqWW4XAgNMS0A=\n+                \"\"\";\n+\n+        \/\/ IC=5000001 using PBMAC1\n+        var bigICp = \"\"\"\n+                MIGiAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBiTB6MFYGCSqGSIb3DQEFDjBJMDkGCSqGSIb3DQEF\n+                DDAsBBQFNf\/gHCO5jNT429D6Q5gxTKHqVAIDTEtBAgEgMAwGCCqGSIb3DQIJBQAwDAYIKoZIhvcN\n+                AgkFAAQgwEVMcyMPQXJSXUIbWqNWjMArtnXDlNUGnKD+19B7QFkECE5PVCBVU0VEAgEB\n+                \"\"\";\n+\n+        \/\/ IC=5000000 using PBMAC1\n+        var smallICp = \"\"\"\n+                MIGiAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBiTB6MFYGCSqGSIb3DQEFDjBJMDkGCSqGSIb3DQEF\n+                DDAsBBS\/ZFfC7swsDHvaCXwyQkuMrZ7dbgIDTEtAAgEgMAwGCCqGSIb3DQIJBQAwDAYIKoZIhvcN\n+                AgkFAAQgCRvE7LDbzkcYOVv\/7iBv0KB3DoUkwnpTI0nsonVfv9UECE5PVCBVU0VEAgEB\"\"\";\n+\n+        loadAndStore(smallICp);\n+        loadAndStore(smallICt);\n+\n+        Asserts.assertTrue(Asserts.assertThrows(IOException.class, () -> loadAndStore(bigICp))\n+                .getMessage().contains(\"MAC iteration count too large: 5000001\"));\n+        Asserts.assertTrue(Asserts.assertThrows(IOException.class, () -> loadAndStore(bigICt))\n+                .getMessage().contains(\"MAC iteration count too large: 5000001\"));\n+    }\n+\n+    static byte[] emptyP12() throws Exception {\n+        var ks = KeyStore.getInstance(\"pkcs12\");\n+        ks.load(null, null);\n+        var os = new ByteArrayOutputStream();\n+        ks.store(os, PASSWORD);\n+        return os.toByteArray();\n+    }\n+\n+    static byte[] loadAndStore(String data) throws Exception {\n+        var bytes = Base64.getMimeDecoder().decode(data);\n+        var ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(new ByteArrayInputStream(bytes), PASSWORD);\n+        var baos = new ByteArrayOutputStream();\n+        ks.store(baos, PASSWORD);\n+        var newBytes = baos.toByteArray();\n+        var bais = new ByteArrayInputStream(newBytes);\n+        ks.load(bais, PASSWORD);\n+        return newBytes;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs12\/PBMAC1Test.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"}]}