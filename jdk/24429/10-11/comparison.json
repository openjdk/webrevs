{"files":[{"patch":"@@ -70,1 +70,1 @@\n-    private final transient Cleaner.Cleanable cleaner;\n+    private transient Cleaner.Cleanable cleaner;\n@@ -228,0 +228,7 @@\n+    public void destroy() { \n+        if (cleaner != null) {\n+            cleaner.clean();\n+            cleaner = null;\n+        }   \n+    }   \n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,186 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.crypto.provider;\n-\n-import java.io.IOException;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.security.spec.InvalidParameterSpecException;\n-import javax.crypto.spec.PBEParameterSpec;\n-\n-import sun.security.util.*;\n-\n-\/**\n- * This class implements the parameter set used with password-based\n- * mac scheme 1 (PBMAC1), which is defined in PKCS#5 as follows:\n- *\n- * <pre>\n- * -- PBMAC1\n- *\n- * PBMAC1Algorithms ALGORITHM-IDENTIFIER ::=\n- *   { {PBMAC1-params IDENTIFIED BY id-PBMAC1}, ...}\n- *\n- * id-PBMAC1 OBJECT IDENTIFIER ::= {pkcs-5 14}\n- *\n- * PBMAC1-params ::= SEQUENCE {\n- *   keyDerivationFunc AlgorithmIdentifier {{PBMAC1-KDFs}},\n- *   messageAuthScheme AlgorithmIdentifier {{PBMAC1-MACs}} }\n- *\n- * PBMAC1-KDFs ALGORITHM-IDENTIFIER ::=\n- *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }\n- *\n- * PBMAC1-MACs ALGORITHM-IDENTIFIER ::= { ... }\n- *\n- * -- PBKDF2\n- *\n- * {@link PBKDF2Parameters}\n- *\n- * <\/pre>\n- *\n- * @since 26\n- *\/\n-final public class PBMAC1Parameters {\n-\n-    private byte[] salt = null;\n-\n-    \/\/ Iteration count\n-    private int iCount = 0;\n-\n-    private String prfAlgo;\n-    private String hmacAlgo;\n-\n-    \/\/ the key derivation function (default is HmacSHA1)\n-    private final ObjectIdentifier kdfAlgo_OID =\n-            ObjectIdentifier.of(KnownOIDs.HmacSHA1);\n-\n-    \/\/ length of key generated by the kdf\n-    private int keyLength = -1;\n-\n-    protected void Init(AlgorithmParameterSpec paramSpec)\n-            throws InvalidParameterSpecException {\n-        if (!(paramSpec instanceof PBEParameterSpec pbeParamSpec)) {\n-            throw new InvalidParameterSpecException\n-                    (\"Inappropriate parameter specification\");\n-        }\n-        salt = pbeParamSpec.getSalt().clone();\n-        iCount = pbeParamSpec.getIterationCount();\n-    }\n-\n-    public void Init(byte[] encoded) throws IOException {\n-        DerValue pBMAC1_params = new DerValue(encoded);\n-        if (pBMAC1_params.tag != DerValue.tag_Sequence) {\n-            throw new IOException(\"PBMAC1 parameter parsing error: \"\n-                    + \"not an ASN.1 SEQUENCE tag\");\n-        }\n-        DerValue[] Info = (new DerInputStream(pBMAC1_params.toByteArray()))\n-                .getSequence(2);\n-        if (Info.length != 2) {\n-            throw new IOException(\"PBMAC1 parameter parsing error: \"\n-                + \"expected length not 2\");\n-        }\n-        ObjectIdentifier OID = Info[1].data.getOID();\n-        KnownOIDs o = KnownOIDs.findMatch(OID.toString());\n-        if (o == null || (!o.stdName().equals(\"HmacSHA1\") &&\n-                !o.stdName().equals(\"HmacSHA224\") &&\n-                !o.stdName().equals(\"HmacSHA256\") &&\n-                !o.stdName().equals(\"HmacSHA384\") &&\n-                !o.stdName().equals(\"HmacSHA512\") &&\n-                !o.stdName().equals(\"HmacSHA512\/224\") &&\n-                !o.stdName().equals(\"HmacSHA512\/256\"))) {\n-            throw new IOException(\"PBMAC1 parameter parsing error: \"\n-                    + \"expecting the object identifier for a HmacSHA key \"\n-                    + \"derivation function\");\n-        }\n-        \/\/ Hmac function used to compute the MAC\n-        this.hmacAlgo = o.stdName();\n-\n-        DerValue kdf = pBMAC1_params.data.getDerValue();\n-        var kdfParams = new PBKDF2Parameters(kdf);\n-        this.prfAlgo = kdfParams.getPrfAlgo();\n-        this.salt = kdfParams.getSalt();\n-        this.iCount = kdfParams.getIterationCount();\n-\n-        \/\/ Key length must be present even though it is not used.\n-        keyLength = kdfParams.getKeyLength();\n-        if (keyLength == -1) {\n-            throw new IOException(\"PBMAC1 parameter parsing \"\n-                    + \"error: missing keyLength field\");\n-        }\n-    }\n-\n-    protected void Init(byte[] encoded, String decodingMethod)\n-            throws IOException {\n-        Init(encoded);\n-    }\n-\n-    protected byte[] getEncoded() throws IOException {\n-        DerOutputStream out = new DerOutputStream();\n-\n-        DerOutputStream pBMAC1_params = new DerOutputStream();\n-\n-        DerOutputStream keyDerivationFunc = new DerOutputStream();\n-        keyDerivationFunc.putOID(\n-                sun.security.util.PBKDF2Parameters.pkcs5PBKDF2_OID);\n-\n-        DerOutputStream pBKDF2_params = new DerOutputStream();\n-        pBKDF2_params.putOctetString(salt); \/\/ choice: 'specified OCTET STRING'\n-        pBKDF2_params.putInteger(iCount);\n-\n-        if (keyLength > 0) {\n-            pBKDF2_params.putInteger(keyLength \/ 8); \/\/ derived key length (in octets)\n-        }\n-\n-        DerOutputStream prf = new DerOutputStream();\n-        \/\/ algorithm is id-hmacWith<MD>\n-        prf.putOID(kdfAlgo_OID);\n-        \/\/ parameters is 'NULL'\n-        prf.putNull();\n-        pBKDF2_params.write(DerValue.tag_Sequence, prf);\n-\n-        keyDerivationFunc.write(DerValue.tag_Sequence, pBKDF2_params);\n-        pBMAC1_params.write(DerValue.tag_Sequence, keyDerivationFunc);\n-\n-        out.write(DerValue.tag_Sequence, pBMAC1_params);\n-\n-        return out.toByteArray();\n-    }\n-\n-    protected byte[] getEncoded(String encodingMethod) throws IOException {\n-        return getEncoded();\n-    }\n-\n-    public String getPrf() {\n-        return this.prfAlgo;\n-    }\n-    public String getHmac() {\n-        return this.hmacAlgo;\n-    }\n-    public byte[] getSalt() {\n-        return this.salt;\n-    }\n-    public int getIterations() {\n-        return this.iCount;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBMAC1Parameters.java","additions":0,"deletions":186,"binary":false,"changes":186,"status":"deleted"},{"patch":"@@ -43,1 +43,0 @@\n-import com.sun.crypto.provider.PBMAC1Parameters;\n@@ -68,3 +67,0 @@\n-    \/\/ the ASN.1 encoded contents of this class\n-    private byte[] encoded = null;\n-\n@@ -97,5 +93,2 @@\n-            algParams = new PBMAC1Parameters();\n-            algParams.Init(digestAlgorithmId.getEncodedParams());\n-\n-            this.iterations = algParams.getIterations();\n-            this.macSalt = algParams.getSalt();\n+            algParams = new PBMAC1Parameters(\n+                    digestAlgorithmId.getEncodedParams());\n@@ -103,1 +96,3 @@\n-            this.kdfHmac = algParams.getPrf();\n+            this.iterations = algParams.getKdfParams().getIterationCount();\n+            this.macSalt = algParams.getKdfParams().getSalt();\n+            this.kdfHmac = algParams.getKdfParams().getPrfAlgo();\n@@ -162,4 +157,0 @@\n-\n-        \/\/ delay the generation of ASN.1 encoding until\n-        \/\/ getEncoded() is called\n-        this.encoded = null;\n@@ -179,1 +170,1 @@\n-    static Mac getMac(String macAlgorithm, char[] password,\n+    private static Mac getMac(String macAlgorithm, char[] password,\n@@ -188,0 +179,1 @@\n+        PBEKeySpec keySpec;\n@@ -192,0 +184,2 @@\n+            keySpec = new PBEKeySpec(password, params.getSalt(),\n+                    params.getIterationCount(), keyLength);\n@@ -197,1 +191,1 @@\n-            PBEKeySpec keySpec = new PBEKeySpec(password);\n+            keySpec = new PBEKeySpec(password);\n@@ -201,0 +195,1 @@\n+        keySpec.clearPassword();\n@@ -204,1 +199,1 @@\n-                 m.init(pbeKey);\n+                m.init(pbeKey);\n@@ -206,1 +201,1 @@\n-                 m.init(pbeKey, params);\n+                m.init(pbeKey, params);\n@@ -244,1 +239,1 @@\n-    public static byte[] calculateMac(char[] passwd, byte[] data,\n+    static byte[] calculateMac(char[] passwd, byte[] data,\n@@ -251,2 +246,2 @@\n-        String kdfHmac = null;\n-        String hmac = null;\n+        String kdfHmac;\n+        String hmac;\n@@ -262,1 +257,1 @@\n-        } else if (macAlgorithm.equals(\"HmacPBESHA256\")) {\n+        } else if (macAlgorithm.startsWith(\"HmacPBE\")) {\n@@ -308,1 +303,1 @@\n-    public byte[] getEncoded() throws NoSuchAlgorithmException, IOException {\n+    byte[] getEncoded() throws NoSuchAlgorithmException, IOException {\n@@ -359,3 +354,1 @@\n-            encoded = out.toByteArray();\n-\n-            return encoded.clone();\n+            return out.toByteArray();\n@@ -364,3 +357,0 @@\n-        if (this.encoded != null)\n-            return this.encoded.clone();\n-\n@@ -388,3 +378,1 @@\n-        this.encoded = out.toByteArray();\n-\n-        return this.encoded.clone();\n+        return out.toByteArray();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/MacData.java","additions":20,"deletions":32,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs12;\n+\n+import java.io.IOException;\n+\n+import sun.security.util.*;\n+\n+\/**\n+ * This class implements the parameter set used with password-based\n+ * mac scheme 1 (PBMAC1), which is defined in PKCS#5 as follows:\n+ *\n+ * <pre>\n+ * -- PBMAC1\n+ *\n+ * PBMAC1Algorithms ALGORITHM-IDENTIFIER ::=\n+ *   { {PBMAC1-params IDENTIFIED BY id-PBMAC1}, ...}\n+ *\n+ * id-PBMAC1 OBJECT IDENTIFIER ::= {pkcs-5 14}\n+ *\n+ * PBMAC1-params ::= SEQUENCE {\n+ *   keyDerivationFunc AlgorithmIdentifier {{PBMAC1-KDFs}},\n+ *   messageAuthScheme AlgorithmIdentifier {{PBMAC1-MACs}} }\n+ *\n+ * PBMAC1-KDFs ALGORITHM-IDENTIFIER ::=\n+ *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }\n+ *\n+ * PBMAC1-MACs ALGORITHM-IDENTIFIER ::= { ... }\n+ *\n+ * -- PBKDF2\n+ *\n+ * See sun.security.util.PBKDF2Parameters.\n+ *\n+ * <\/pre>\n+ *\n+ * @since 26\n+ *\/\n+final class PBMAC1Parameters {\n+\n+    private final String hmacAlgo;\n+    private final PBKDF2Parameters kdfParams;\n+\n+    \/\/ length of key generated by the kdf\n+    private final int keyLength;\n+\n+    public PBMAC1Parameters(byte[] encoded) throws IOException {\n+        DerValue pBMAC1_params = new DerValue(encoded);\n+        if (pBMAC1_params.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"PBMAC1 parameter parsing error: \"\n+                    + \"not an ASN.1 SEQUENCE tag\");\n+        }\n+        DerValue[] info = new DerInputStream(pBMAC1_params.toByteArray())\n+                .getSequence(2);\n+        if (info.length != 2) {\n+            throw new IOException(\"PBMAC1 parameter parsing error: \"\n+                + \"expected length not 2\");\n+        }\n+        ObjectIdentifier OID = info[1].data.getOID();\n+        KnownOIDs o = KnownOIDs.findMatch(OID.toString());\n+        if (o == null || (!o.stdName().equals(\"HmacSHA1\") &&\n+                !o.stdName().equals(\"HmacSHA224\") &&\n+                !o.stdName().equals(\"HmacSHA256\") &&\n+                !o.stdName().equals(\"HmacSHA384\") &&\n+                !o.stdName().equals(\"HmacSHA512\") &&\n+                !o.stdName().equals(\"HmacSHA512\/224\") &&\n+                !o.stdName().equals(\"HmacSHA512\/256\"))) {\n+            throw new IOException(\"PBMAC1 parameter parsing error: \"\n+                    + \"expecting the object identifier for a HmacSHA key \"\n+                    + \"derivation function\");\n+        }\n+        \/\/ Hmac function used to compute the MAC\n+        this.hmacAlgo = o.stdName();\n+\n+        DerValue kdf = pBMAC1_params.data.getDerValue();\n+        this.kdfParams = new PBKDF2Parameters(kdf);\n+\n+        \/\/ Key length must be present even though it is not used.\n+        keyLength = kdfParams.getKeyLength();\n+        if (keyLength == -1) {\n+            throw new IOException(\"PBMAC1 parameter parsing \"\n+                    + \"error: missing keyLength field\");\n+        }\n+    }\n+\n+    public PBKDF2Parameters getKdfParams() {\n+        return this.kdfParams;\n+    }\n+\n+    public String getHmac() {\n+        return this.hmacAlgo;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/PBMAC1Parameters.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -2082,0 +2082,2 @@\n+                    \/\/ Store MAC algorithm of keystore that was just loaded.\n+                    macAlgorithm = macData.getMacAlgorithm();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/PKCS12KeyStore.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-final public class PBKDF2Parameters {\n+public final class PBKDF2Parameters {\n@@ -83,4 +83,0 @@\n-    \/\/ the pseudorandom function (default is HmacSHA1)\n-    private ObjectIdentifier kdfAlgo_OID =\n-            ObjectIdentifier.of(KnownOIDs.HmacSHA1);\n-\n@@ -125,1 +121,2 @@\n-            kdfAlgo_OID = prf.data.getOID();\n+            \/\/ the pseudorandom function (default is HmacSHA1)\n+            ObjectIdentifier kdfAlgo_OID = prf.data.getOID();\n@@ -147,2 +144,1 @@\n-     * @return the salt. Returns a new array\n-     * each time this method is called.\n+     * @return the salt\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/PBKDF2Parameters.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * \n+ *\n","filename":"test\/jdk\/sun\/security\/pkcs12\/PBMAC1Encoding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}