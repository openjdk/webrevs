{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import sun.security.util.PBKDF2Parameters;\n@@ -96,1 +97,1 @@\n-            ObjectIdentifier.of(KnownOIDs.PBKDF2WithHmacSHA1);\n+            ObjectIdentifier.of(KnownOIDs.PBKDF2);\n@@ -227,0 +228,4 @@\n+            if (pBES2_params.tag != DerValue.tag_Sequence) {\n+                throw new IOException(\"PBE parameter parsing error: \"\n+                    + \"not an ASN.1 SEQUENCE tag\");\n+            }\n@@ -230,14 +235,1 @@\n-        String kdfAlgo = parseKDF(kdf);\n-\n-        if (pBES2_params.tag != DerValue.tag_Sequence) {\n-            throw new IOException(\"PBE parameter parsing error: \"\n-                + \"not an ASN.1 SEQUENCE tag\");\n-        }\n-        String cipherAlgo = parseES(pBES2_params.data.getDerValue());\n-\n-        this.pbes2AlgorithmName = \"PBEWith\" + kdfAlgo + \"And\" + cipherAlgo;\n-    }\n-\n-    private String parseKDF(DerValue keyDerivationFunc) throws IOException {\n-\n-        if (!pkcs5PBKDF2_OID.equals(keyDerivationFunc.data.getOID())) {\n+        if (!pkcs5PBKDF2_OID.equals(kdf.data.getOID())) {\n@@ -247,1 +239,1 @@\n-        if (keyDerivationFunc.tag != DerValue.tag_Sequence) {\n+        if (kdf.tag != DerValue.tag_Sequence) {\n@@ -251,15 +243,1 @@\n-        DerValue pBKDF2_params = keyDerivationFunc.data.getDerValue();\n-        if (pBKDF2_params.tag != DerValue.tag_Sequence) {\n-            throw new IOException(\"PBE parameter parsing error: \"\n-                + \"not an ASN.1 SEQUENCE tag\");\n-        }\n-        DerValue specified = pBKDF2_params.data.getDerValue();\n-        \/\/ the 'specified' ASN.1 CHOICE for 'salt' is supported\n-        if (specified.tag == DerValue.tag_OctetString) {\n-            salt = specified.getOctetString();\n-        } else {\n-            \/\/ the 'otherSource' ASN.1 CHOICE for 'salt' is not supported\n-            throw new IOException(\"PBE parameter parsing error: \"\n-                + \"not an ASN.1 OCTET STRING tag\");\n-        }\n-        iCount = pBKDF2_params.data.getInteger();\n+        DerValue pBKDF2_params = kdf.data.getDerValue();\n@@ -267,5 +245,5 @@\n-        \/\/ keyLength INTEGER (1..MAX) OPTIONAL,\n-        var ksDer = pBKDF2_params.data.getOptional(DerValue.tag_Integer);\n-        if (ksDer.isPresent()) {\n-            keysize = ksDer.get().getInteger() * 8; \/\/ keysize (in bits)\n-        }\n+        var kdfParams = new PBKDF2Parameters(pBKDF2_params);\n+        String kdfAlgo = kdfParams.getPrfAlgo();\n+        salt = kdfParams.getSalt();\n+        iCount = kdfParams.getIterationCount();\n+        keysize = kdfParams.getKeyLength();\n@@ -273,25 +251,3 @@\n-        \/\/ prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1\n-        String kdfAlgo;\n-        var prfDer = pBKDF2_params.data.getOptional(DerValue.tag_Sequence);\n-        if (prfDer.isPresent()) {\n-            DerValue prf = prfDer.get();\n-            kdfAlgo_OID = prf.data.getOID();\n-            KnownOIDs o = KnownOIDs.findMatch(kdfAlgo_OID.toString());\n-            if (o == null || (!o.stdName().equals(\"HmacSHA1\") &&\n-                    !o.stdName().equals(\"HmacSHA224\") &&\n-                    !o.stdName().equals(\"HmacSHA256\") &&\n-                    !o.stdName().equals(\"HmacSHA384\") &&\n-                    !o.stdName().equals(\"HmacSHA512\") &&\n-                    !o.stdName().equals(\"HmacSHA512\/224\") &&\n-                    !o.stdName().equals(\"HmacSHA512\/256\"))) {\n-                throw new IOException(\"PBE parameter parsing error: \"\n-                        + \"expecting the object identifier for a HmacSHA key \"\n-                        + \"derivation function\");\n-            }\n-            kdfAlgo = o.stdName();\n-            prf.data.getOptional(DerValue.tag_Null);\n-            prf.data.atEnd();\n-        } else {\n-            kdfAlgo = \"HmacSHA1\";\n-        }\n-        return kdfAlgo;\n+        String cipherAlgo = parseES(pBES2_params.data.getDerValue());\n+\n+        this.pbes2AlgorithmName = \"PBEWith\" + kdfAlgo + \"And\" + cipherAlgo;\n@@ -348,20 +304,3 @@\n-        DerOutputStream keyDerivationFunc = new DerOutputStream();\n-        keyDerivationFunc.putOID(pkcs5PBKDF2_OID);\n-\n-        DerOutputStream pBKDF2_params = new DerOutputStream();\n-        pBKDF2_params.putOctetString(salt); \/\/ choice: 'specified OCTET STRING'\n-        pBKDF2_params.putInteger(iCount);\n-\n-        if (keysize > 0) {\n-            pBKDF2_params.putInteger(keysize \/ 8); \/\/ derived key length (in octets)\n-        }\n-\n-        DerOutputStream prf = new DerOutputStream();\n-        \/\/ algorithm is id-hmacWith<MD>\n-        prf.putOID(kdfAlgo_OID);\n-        \/\/ parameters is 'NULL'\n-        prf.putNull();\n-        pBKDF2_params.write(DerValue.tag_Sequence, prf);\n-\n-        keyDerivationFunc.write(DerValue.tag_Sequence, pBKDF2_params);\n-        pBES2_params.write(DerValue.tag_Sequence, keyDerivationFunc);\n+        \/\/ keysize encoded as octets\n+        pBES2_params.writeBytes(PBKDF2Parameters.encode(salt, iCount,\n+                keysize\/8, kdfAlgo_OID));\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":21,"deletions":82,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-final class PBKDF2KeyImpl implements javax.crypto.interfaces.PBEKey {\n+public final class PBKDF2KeyImpl implements javax.crypto.interfaces.PBEKey {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.io.*;\n+import java.io.IOException;\n@@ -30,0 +30,7 @@\n+import java.security.spec.InvalidKeySpecException;\n+import static java.util.Locale.ENGLISH;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n@@ -31,4 +38,0 @@\n-import sun.security.util.DerInputStream;\n-import sun.security.util.DerOutputStream;\n-import sun.security.util.DerValue;\n-import sun.security.x509.AlgorithmId;\n@@ -36,0 +39,2 @@\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n@@ -39,1 +44,20 @@\n- * A MacData type, as defined in PKCS#12.\n+ * The MacData type, as defined in PKCS#12.\n+ *\n+ * The ASN.1 definition is as follows:\n+ *\n+ * <pre>\n+ *\n+ * MacData ::= SEQUENCE {\n+ *     mac        DigestInfo,\n+ *     macSalt    OCTET STRING,\n+ *     iterations INTEGER DEFAULT 1\n+ *      -- Note: The default is for historical reasons and its use is\n+ *      -- deprecated.\n+ * }\n+ *\n+ * DigestInfo ::= SEQUENCE {\n+ *     digestAlgorithm DigestAlgorithmIdentifier,\n+ *     digest OCTET STRING\n+ * }\n+ *\n+ * <\/pre>\n@@ -46,2 +70,2 @@\n-    private final String digestAlgorithmName;\n-    private AlgorithmParameters digestAlgorithmParams;\n+    private static final Debug debug = Debug.getInstance(\"pkcs12\");\n+    private final String macAlgorithm;\n@@ -52,2 +76,4 @@\n-    \/\/ the ASN.1 encoded contents of this class\n-    private byte[] encoded = null;\n+    \/\/ The following three fields are for PBMAC1.\n+    private final int keyLength;\n+    private final String kdfHmac;\n+    private final String hmac;\n@@ -73,2 +99,2 @@\n-        this.digestAlgorithmName = digestAlgorithmId.getName();\n-        this.digestAlgorithmParams = digestAlgorithmId.getParameters();\n+        String digestAlgorithmName = digestAlgorithmId.getName();\n+\n@@ -78,2 +104,10 @@\n-        \/\/ Get the salt.\n-        this.macSalt = macData[1].getOctetString();\n+        if (digestAlgorithmName.equals(\"PBMAC1\")) {\n+            PBMAC1Parameters algParams;\n+\n+            algParams = new PBMAC1Parameters(digestAlgorithmId\n+                    .getEncodedParams());\n+\n+            this.iterations = algParams.getKdfParams().getIterationCount();\n+            this.macSalt = algParams.getKdfParams().getSalt();\n+            this.kdfHmac = algParams.getKdfParams().getPrfAlgo();\n+            this.keyLength = algParams.getKdfParams().getKeyLength();\n@@ -81,3 +115,6 @@\n-        \/\/ Iterations is optional. The default value is 1.\n-        if (macData.length > 2) {\n-            this.iterations = macData[2].getInteger();\n+            \/\/ Implementations MUST NOT accept params that omit keyLength.\n+            if (this.keyLength == -1) {\n+                throw new IOException(\"error: missing keyLength field\");\n+            }\n+            this.hmac = algParams.getHmac();\n+            this.macAlgorithm = \"pbewith\" + this.kdfHmac + \"and\" + this.hmac;\n@@ -85,1 +122,12 @@\n-            this.iterations = 1;\n+            this.kdfHmac = null;\n+            this.hmac = null;\n+            this.keyLength = -1;\n+            this.macSalt = macData[1].getOctetString();\n+            if (macData.length > 2) {\n+                this.iterations = macData[2].getInteger();\n+            } else {\n+                this.iterations = 1;\n+            }\n+            \/\/ Remove \"-\" from digest algorithm names\n+            this.macAlgorithm = \"hmacpbe\"\n+                    + digestAlgorithmName.replace(\"-\", \"\");\n@@ -89,17 +137,48 @@\n-    MacData(String algName, byte[] digest, byte[] salt, int iterations)\n-        throws NoSuchAlgorithmException\n-    {\n-        if (algName == null)\n-           throw new NullPointerException(\"the algName parameter \" +\n-                                               \"must be non-null\");\n-\n-        AlgorithmId algid = AlgorithmId.get(algName);\n-        this.digestAlgorithmName = algid.getName();\n-        this.digestAlgorithmParams = algid.getParameters();\n-\n-        if (digest == null) {\n-            throw new NullPointerException(\"the digest \" +\n-                                           \"parameter must be non-null\");\n-        } else if (digest.length == 0) {\n-            throw new IllegalArgumentException(\"the digest \" +\n-                                                \"parameter must not be empty\");\n+    \/**\n+     * Computes a MAC on the data.\n+     *\n+     * This is a two-step process: first generate a key and then use the\n+     * key to generate the MAC. PBMAC1 and non-PBMAC1 keys use different\n+     * key factories. PBMAC1 uses a pseudorandom function (kdfHmac)\n+     * to generate keys while non-PBMAC1 does not. The MAC is computed\n+     * according to the specified hmac algorithm.\n+     *\n+     * @param macAlgorithm the algorithm used to compute the MAC\n+     * @param password the password used to generate the key\n+     * @param params a PBEParameterSpec object\n+     * @param data the data on which the MAC is computed\n+     * @param kdfHmac the pseudorandom function used to compute the key\n+     * for PBMAC1\n+     * @param hmac the algorithm used to compute the MAC\n+     * @param keyLength the length of the key generated by the pseudorandom\n+     * function\n+     *\n+     * @return the computed MAC as a byte array\n+     *\n+     * @exception NoSuchAlgorithmException if either kdfHmac or hmac is\n+     * unknown to the Mac or SecretKeyFactory\n+     *\/\n+    private static byte[] calculateMac(String macAlgorithm, char[] password,\n+            PBEParameterSpec params, byte[] data,\n+            String kdfHmac, String hmac, int keyLength)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException,\n+            InvalidKeySpecException, NoSuchAlgorithmException {\n+        SecretKeyFactory skf;\n+        SecretKey pbeKey = null;\n+        Mac m;\n+\n+        PBEKeySpec keySpec;\n+\n+        \/*\n+         * The Hmac has to be extracted from the algorithm name for\n+         * PBMAC1 algorithms. For non-PBMAC1 macAlgorithms, the name\n+         * and Hmac are the same.\n+         *\n+         * The prefix used in Algorithm names is guaranteed to be lowercase.\n+         *\/\n+        if (macAlgorithm.startsWith(\"pbewith\")) {\n+            m = Mac.getInstance(hmac);\n+            int len = keyLength == -1 ? m.getMacLength()*8 : keyLength;\n+            skf = SecretKeyFactory.getInstance(\"PBKDF2With\" +kdfHmac);\n+            keySpec = new PBEKeySpec(password, params.getSalt(),\n+                    params.getIterationCount(), len);\n@@ -107,1 +186,3 @@\n-            this.digest = digest.clone();\n+            m = Mac.getInstance(macAlgorithm);\n+            skf = SecretKeyFactory.getInstance(\"PBE\");\n+            keySpec = new PBEKeySpec(password);\n@@ -110,2 +191,14 @@\n-        this.macSalt = salt;\n-        this.iterations = iterations;\n+        try {\n+            pbeKey = skf.generateSecret(keySpec);\n+            if (macAlgorithm.startsWith(\"pbewith\")) {\n+                m.init(pbeKey);\n+            } else {\n+                m.init(pbeKey, params);\n+            }\n+            m.update(data);\n+            return m.doFinal();\n+        } finally {\n+            keySpec.clearPassword();\n+            KeyUtil.destroySecretKeys(pbeKey);\n+        }\n+    }\n@@ -113,3 +206,25 @@\n-        \/\/ delay the generation of ASN.1 encoding until\n-        \/\/ getEncoded() is called\n-        this.encoded = null;\n+    \/**\n+     * Verify Mac on the data.\n+     *\n+     * Calculate Mac on the data and compare with Mac found in input stream.\n+     *\n+     * @param password the password used to generate the key\n+     * @param data the data on which the MAC is computed\n+     *\n+     * @exception UnrecoverableKeyException if calculated Mac and\n+     * Mac found in input stream are different\n+     *\/\n+    void verifyMac(char[] password, byte[] data)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException,\n+            InvalidKeySpecException, NoSuchAlgorithmException,\n+            UnrecoverableKeyException {\n+\n+        byte[] macResult = calculateMac(this.macAlgorithm, password,\n+                new PBEParameterSpec(this.macSalt, this.iterations),\n+                data, this.kdfHmac, this.hmac, this.keyLength);\n+\n+        if (debug != null) {\n+            debug.println(\"Checking keystore integrity \" +\n+                    \"(\" + this.macAlgorithm + \" iterations: \"\n+                    + this.iterations + \")\");\n+        }\n@@ -117,0 +232,4 @@\n+        if (!MessageDigest.isEqual(this.digest, macResult)) {\n+            throw new UnrecoverableKeyException(\"Failed PKCS12\" +\n+                    \" integrity checking\");\n+        }\n@@ -119,3 +238,40 @@\n-    String getDigestAlgName() {\n-        return digestAlgorithmName;\n-    }\n+    \/*\n+     * Gathers parameters and generates a MAC of the data\n+     *\n+     * @param password the password used to generate the key\n+     * @param data the data on which the MAC is computed\n+     * @param macAlgorithm the algorithm used to compute the MAC\n+     * @param macIterationCount the iteration count\n+     * @param salt the salt\n+     *\n+     * @exception IOException if the MAC cannot be calculated\n+     *\n+     * @return the computed MAC as a byte array\n+     *\/\n+    static byte[] generateMac(char[] passwd, byte[] data,\n+            String macAlgorithm, int macIterationCount, byte[] salt)\n+            throws IOException, NoSuchAlgorithmException {\n+        final PBEParameterSpec params;\n+        String algName;\n+        String kdfHmac;\n+        String hmac;\n+\n+        macAlgorithm = macAlgorithm.toLowerCase(ENGLISH);\n+        \/\/ The prefix used in Algorithm names is guaranteed to be lowercase.\n+        if (macAlgorithm.startsWith(\"pbewith\")) {\n+            algName = \"PBMAC1\";\n+            kdfHmac = MacData.parseKdfHmac(macAlgorithm);\n+            hmac = MacData.parseHmac(macAlgorithm);\n+            if (hmac == null) {\n+                hmac = kdfHmac;\n+            }\n+        } else if (macAlgorithm.startsWith(\"hmacpbe\")) {\n+            algName = macAlgorithm.substring(7);\n+            kdfHmac = null;\n+            hmac = macAlgorithm;\n+        } else {\n+            throw new ParsingException(\"unexpected algorithm '\"\n+                    + macAlgorithm + \"'\");\n+        }\n+\n+        params = new PBEParameterSpec(salt, macIterationCount);\n@@ -123,2 +279,12 @@\n-    byte[] getSalt() {\n-        return macSalt;\n+        try {\n+            byte[] macResult = calculateMac(macAlgorithm, passwd, params, data,\n+                    kdfHmac, hmac, -1);\n+\n+            DerOutputStream bytes = new DerOutputStream();\n+            bytes.write(encode(algName, macResult, params, kdfHmac, hmac,\n+                    macResult.length));\n+            return bytes.toByteArray();\n+        } catch (InvalidKeySpecException | InvalidKeyException |\n+                    InvalidAlgorithmParameterException e) {\n+            throw new IOException(\"calculateMac failed: \" + e, e);\n+        }\n@@ -127,2 +293,2 @@\n-    int getIterations() {\n-        return iterations;\n+    String getMacAlgorithm() {\n+        return this.macAlgorithm;\n@@ -131,2 +297,2 @@\n-    byte[] getDigest() {\n-        return digest;\n+    int getIterations() {\n+        return this.iterations;\n@@ -136,3 +302,3 @@\n-     * Returns the ASN.1 encoding of this object.\n-     * @return the ASN.1 encoding.\n-     * @exception IOException if error occurs when constructing its\n+     * Returns the ASN.1 encoding.\n+     * @return the ASN.1 encoding\n+     * @exception NoSuchAlgorithmException if error occurs when constructing its\n@@ -141,4 +307,6 @@\n-    public byte[] getEncoded() throws NoSuchAlgorithmException\n-    {\n-        if (this.encoded != null)\n-            return this.encoded.clone();\n+    static byte[] encode(String algName, byte[] digest, PBEParameterSpec p,\n+            String kdfHmac, String hmac, int keyLength)\n+            throws IOException, NoSuchAlgorithmException {\n+\n+        final int iterations = p.getIterationCount();\n+        final byte[] macSalt = p.getSalt();\n@@ -146,1 +314,0 @@\n-        DerOutputStream out = new DerOutputStream();\n@@ -148,0 +315,1 @@\n+        DerOutputStream out = new DerOutputStream();\n@@ -149,4 +317,4 @@\n-        DerOutputStream tmp2 = new DerOutputStream();\n-        \/\/ encode encryption algorithm\n-        AlgorithmId algid = AlgorithmId.get(digestAlgorithmName);\n-        algid.encode(tmp2);\n+        if (algName.equals(\"PBMAC1\")) {\n+            DerOutputStream tmp1 = new DerOutputStream();\n+            DerOutputStream tmp2 = new DerOutputStream();\n+            DerOutputStream tmp3 = new DerOutputStream();\n@@ -154,2 +322,2 @@\n-        \/\/ encode digest data\n-        tmp2.putOctetString(digest);\n+            tmp3.writeBytes(PBMAC1Parameters.encode(macSalt, iterations,\n+                    keyLength, kdfHmac, hmac));\n@@ -157,1 +325,3 @@\n-        tmp.write(DerValue.tag_Sequence, tmp2);\n+            \/\/ id-PBMAC1 OBJECT IDENTIFIER ::= { pkcs-5 14 }\n+            tmp2.putOID(ObjectIdentifier.of(KnownOIDs.PBMAC1));\n+            tmp2.write(tmp3);\n@@ -159,2 +329,2 @@\n-        \/\/ encode salt\n-        tmp.putOctetString(macSalt);\n+            tmp1.write(DerValue.tag_Sequence, tmp2);\n+            tmp1.putOctetString(digest);\n@@ -162,2 +332,11 @@\n-        \/\/ encode iterations\n-        tmp.putInteger(iterations);\n+            tmp.write(DerValue.tag_Sequence, tmp1);\n+            tmp.putOctetString(\n+                    new byte[]{ 'N', 'O', 'T', ' ', 'U', 'S', 'E', 'D' });\n+            \/\/ Unused, but must have non-zero positive value.\n+            tmp.putInteger(1);\n+        } else {\n+            final AlgorithmId digestAlgorithm = AlgorithmId.get(algName);\n+            DerOutputStream tmp2 = new DerOutputStream();\n+\n+            tmp2.write(digestAlgorithm);\n+            tmp2.putOctetString(digest);\n@@ -165,0 +344,5 @@\n+            \/\/ wrap into a SEQUENCE\n+            tmp.write(DerValue.tag_Sequence, tmp2);\n+            tmp.putOctetString(macSalt);\n+            tmp.putInteger(iterations);\n+        }\n@@ -167,1 +351,2 @@\n-        this.encoded = out.toByteArray();\n+        return out.toByteArray();\n+    }\n@@ -169,1 +354,10 @@\n-        return this.encoded.clone();\n+    private static String parseKdfHmac(String text) {\n+        int index1 = text.indexOf(\"with\") + 4;\n+        int index2 = text.indexOf(\"and\");\n+        if (index1 == 3) { \/\/ -1 + 4\n+            return null;\n+        } else if (index2 == -1) {\n+            return text.substring(index1);\n+        } else {\n+            return text.substring(index1, index2);\n+        }\n@@ -172,0 +366,8 @@\n+    private static String parseHmac(String text) {\n+        int index1 = text.indexOf(\"and\") + 3;\n+        if (index1 == 2) { \/\/ -1 + 3\n+            return null;\n+        } else {\n+            return text.substring(index1);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/MacData.java","additions":274,"deletions":72,"binary":false,"changes":346,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs12;\n+\n+import java.io.IOException;\n+import java.security.NoSuchAlgorithmException;\n+\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n+\n+\/**\n+ * This class implements the parameter set used with password-based\n+ * mac scheme 1 (PBMAC1), which is defined in PKCS#5 as follows:\n+ *\n+ * <pre>\n+ * -- PBMAC1\n+ *\n+ * PBMAC1Algorithms ALGORITHM-IDENTIFIER ::=\n+ *   { {PBMAC1-params IDENTIFIED BY id-PBMAC1}, ...}\n+ *\n+ * id-PBMAC1 OBJECT IDENTIFIER ::= {pkcs-5 14}\n+ *\n+ * PBMAC1-params ::= SEQUENCE {\n+ *   keyDerivationFunc AlgorithmIdentifier {{PBMAC1-KDFs}},\n+ *   messageAuthScheme AlgorithmIdentifier {{PBMAC1-MACs}} }\n+ *\n+ * PBMAC1-KDFs ALGORITHM-IDENTIFIER ::=\n+ *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }\n+ *\n+ * PBMAC1-MACs ALGORITHM-IDENTIFIER ::= { ... }\n+ *\n+ * -- PBKDF2\n+ *\n+ * See sun.security.util.PBKDF2Parameters.\n+ *\n+ * <\/pre>\n+ *\n+ * @since 26\n+ *\/\n+final class PBMAC1Parameters {\n+\n+    static final ObjectIdentifier pkcs5PBKDF2_OID =\n+            ObjectIdentifier.of(KnownOIDs.PBKDF2);\n+\n+    private final String hmacAlgo;\n+    private final PBKDF2Parameters kdfParams;\n+\n+    PBMAC1Parameters(byte[] encoded) throws IOException {\n+        DerValue pBMAC1_params = new DerValue(encoded);\n+        if (pBMAC1_params.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"PBMAC1 parameter parsing error: \"\n+                    + \"not an ASN.1 SEQUENCE tag\");\n+        }\n+        DerValue[] info = new DerInputStream(pBMAC1_params.toByteArray())\n+                .getSequence(2);\n+        if (info.length != 2) {\n+            throw new IOException(\"PBMAC1 parameter parsing error: \"\n+                + \"expected length not 2\");\n+        }\n+        ObjectIdentifier OID = info[1].data.getOID();\n+        KnownOIDs o = KnownOIDs.findMatch(OID.toString());\n+        if (o == null || (!o.stdName().equals(\"HmacSHA1\") &&\n+                !o.stdName().equals(\"HmacSHA224\") &&\n+                !o.stdName().equals(\"HmacSHA256\") &&\n+                !o.stdName().equals(\"HmacSHA384\") &&\n+                !o.stdName().equals(\"HmacSHA512\") &&\n+                !o.stdName().equals(\"HmacSHA512\/224\") &&\n+                !o.stdName().equals(\"HmacSHA512\/256\"))) {\n+            throw new IOException(\"PBMAC1 parameter parsing error: \"\n+                    + \"expecting the object identifier for a HmacSHA key \"\n+                    + \"derivation function\");\n+        }\n+        \/\/ Hmac function used to compute the MAC\n+        this.hmacAlgo = o.stdName();\n+\n+        \/\/DerValue kdf = pBMAC1_params.data.getDerValue();\n+        DerValue kdf = info[0];\n+\n+        if (!pkcs5PBKDF2_OID.equals(kdf.data.getOID())) {\n+            throw new IOException(\"PBKDF2 parameter parsing error: \"\n+                + \"expecting the object identifier for PBKDF2\");\n+        }\n+        if (kdf.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"PBKDF2 parameter parsing error: \"\n+                + \"not an ASN.1 SEQUENCE tag\");\n+        }\n+        DerValue pBKDF2_params = kdf.data.getDerValue();\n+\n+        this.kdfParams = new PBKDF2Parameters(pBKDF2_params);\n+    }\n+\n+    \/*\n+     * Encode PBMAC1 parameters from components.\n+     *\/\n+    static byte[] encode(byte[] salt, int iterationCount, int keyLength,\n+            String kdfHmac, String hmac) throws NoSuchAlgorithmException {\n+\n+        DerOutputStream out = new DerOutputStream();\n+\n+        \/\/ keyDerivationFunc AlgorithmIdentifier {{PBMAC1-KDFs}}\n+        out.writeBytes(PBKDF2Parameters.encode(salt,\n+                iterationCount, keyLength, kdfHmac));\n+\n+        \/\/ messageAuthScheme AlgorithmIdentifier {{PBMAC1-MACs}}\n+        out.write(AlgorithmId.get(hmac));\n+        return new DerOutputStream().write(DerValue.tag_Sequence, out)\n+                .toByteArray();\n+    }\n+\n+    PBKDF2Parameters getKdfParams() {\n+        return this.kdfParams;\n+    }\n+\n+    String getHmac() {\n+        return this.hmacAlgo;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/PBMAC1Parameters.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,13 +29,1 @@\n-import java.security.MessageDigest;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.Key;\n-import java.security.KeyFactory;\n-import java.security.KeyStore;\n-import java.security.KeyStoreSpi;\n-import java.security.KeyStoreException;\n-import java.security.PKCS12Attribute;\n-import java.security.PrivateKey;\n-import java.security.UnrecoverableEntryException;\n-import java.security.UnrecoverableKeyException;\n-import java.security.SecureRandom;\n-import java.security.Security;\n+import java.security.*;\n@@ -43,0 +31,1 @@\n+import java.security.cert.CertificateException;\n@@ -45,1 +34,0 @@\n-import java.security.cert.CertificateException;\n@@ -51,6 +39,3 @@\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n-import java.security.AlgorithmParameters;\n-import java.security.InvalidAlgorithmParameterException;\n-import javax.crypto.spec.PBEParameterSpec;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n@@ -58,0 +43,1 @@\n+import javax.crypto.spec.PBEParameterSpec;\n@@ -59,4 +45,0 @@\n-import javax.crypto.SecretKeyFactory;\n-import javax.crypto.SecretKey;\n-import javax.crypto.Cipher;\n-import javax.crypto.Mac;\n@@ -67,2 +49,0 @@\n-import sun.security.tools.KeyStoreUtil;\n-import sun.security.util.*;\n@@ -70,1 +50,0 @@\n-import sun.security.x509.AlgorithmId;\n@@ -73,0 +52,3 @@\n+import sun.security.tools.KeyStoreUtil;\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n@@ -75,0 +57,2 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -369,1 +353,1 @@\n-                    destroyPBEKey(skey);\n+                    KeyUtil.destroySecretKeys(skey);\n@@ -858,11 +842,0 @@\n-    \/*\n-     * Destroy the key obtained from getPBEKey().\n-     *\/\n-    private void destroyPBEKey(SecretKey key) {\n-        try {\n-            key.destroy();\n-        } catch (DestroyFailedException e) {\n-            \/\/ Accept this\n-        }\n-    }\n-\n@@ -918,1 +891,1 @@\n-                destroyPBEKey(skey);\n+                KeyUtil.destroySecretKeys(skey);\n@@ -1268,1 +1241,2 @@\n-            byte[] macData = calculateMac(password, authenticatedSafe);\n+            byte[] macData = MacData.generateMac(password, authenticatedSafe,\n+                    macAlgorithm, macIterationCount, getSalt());\n@@ -1483,42 +1457,0 @@\n-    \/*\n-     * Calculate MAC using HMAC algorithm (required for password integrity)\n-     *\n-     * Hash-based MAC algorithm combines secret key with message digest to\n-     * create a message authentication code (MAC)\n-     *\/\n-    private byte[] calculateMac(char[] passwd, byte[] data)\n-        throws IOException\n-    {\n-        byte[] mData;\n-        String algName = macAlgorithm.substring(7);\n-\n-        try {\n-            \/\/ Generate a random salt.\n-            byte[] salt = getSalt();\n-\n-            \/\/ generate MAC (MAC key is generated within JCE)\n-            Mac m = Mac.getInstance(macAlgorithm);\n-            PBEParameterSpec params =\n-                        new PBEParameterSpec(salt, macIterationCount);\n-            SecretKey key = getPBEKey(passwd);\n-            try {\n-                m.init(key, params);\n-            } finally {\n-                destroyPBEKey(key);\n-            }\n-            m.update(data);\n-            byte[] macResult = m.doFinal();\n-\n-            \/\/ encode as MacData\n-            MacData macData = new MacData(algName, macResult, salt,\n-                    macIterationCount);\n-            DerOutputStream bytes = new DerOutputStream();\n-            bytes.write(macData.getEncoded());\n-            mData = bytes.toByteArray();\n-        } catch (Exception e) {\n-            throw new IOException(\"calculateMac failed: \" + e, e);\n-        }\n-        return mData;\n-    }\n-\n-\n@@ -1893,1 +1825,1 @@\n-                destroyPBEKey(skey);\n+                KeyUtil.destroySecretKeys(skey);\n@@ -2103,1 +2035,1 @@\n-                            destroyPBEKey(skey);\n+                            KeyUtil.destroySecretKeys(skey);\n@@ -2138,7 +2070,2 @@\n-                    String algName =\n-                            macData.getDigestAlgName().toUpperCase(Locale.ENGLISH);\n-\n-                    \/\/ Change SHA-1 to SHA1\n-                    algName = algName.replace(\"-\", \"\");\n-\n-                    macAlgorithm = \"HmacPBE\" + algName;\n+                    \/\/ Store MAC algorithm of keystore that was just loaded.\n+                    macAlgorithm = macData.getMacAlgorithm();\n@@ -2146,6 +2073,0 @@\n-\n-                    \/\/ generate MAC (MAC key is created within JCE)\n-                    Mac m = Mac.getInstance(macAlgorithm);\n-                    PBEParameterSpec params =\n-                            new PBEParameterSpec(macData.getSalt(), ic);\n-\n@@ -2153,18 +2074,1 @@\n-                        SecretKey key = getPBEKey(pass);\n-                        try {\n-                            m.init(key, params);\n-                        } finally {\n-                            destroyPBEKey(key);\n-                        }\n-                        m.update(authSafeData);\n-                        byte[] macResult = m.doFinal();\n-\n-                        if (debug != null) {\n-                            debug.println(\"Checking keystore integrity \" +\n-                                    \"(\" + m.getAlgorithm() + \" iterations: \" + ic + \")\");\n-                        }\n-\n-                        if (!MessageDigest.isEqual(macData.getDigest(), macResult)) {\n-                            throw new UnrecoverableKeyException(\"Failed PKCS12\" +\n-                                    \" integrity checking\");\n-                        }\n+                        macData.verifyMac(pass, authSafeData);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/PKCS12KeyStore.java","additions":21,"deletions":117,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import com.sun.crypto.provider.PBKDF2KeyImpl;\n@@ -472,0 +473,2 @@\n+                } else if (k instanceof PBKDF2KeyImpl p2k) {\n+                    p2k.clear();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-    PBKDF2WithHmacSHA1(\"1.2.840.113549.1.5.12\"),\n+    PBKDF2(\"1.2.840.113549.1.5.12\", \"PBKDF2WithHmacSHA1\"),\n@@ -213,0 +213,1 @@\n+    PBMAC1(\"1.2.840.113549.1.5.14\"),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.io.IOException;\n+\n+import sun.security.util.KnownOIDs;\n+import sun.security.x509.AlgorithmId;\n+\n+\/**\n+ * This class implements the parameter set used with password-based\n+ * key derivation function 2 (PBKDF2), which is defined in PKCS#5 as follows:\n+ *\n+ * <pre>\n+ *\n+ * PBKDF2Algorithms ALGORITHM-IDENTIFIER ::=\n+ *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ...}\n+ *\n+ * id-PBKDF2 OBJECT IDENTIFIER ::= {pkcs-5 12}\n+ *\n+ * PBKDF2-params ::= SEQUENCE {\n+ *     salt CHOICE {\n+ *       specified OCTET STRING,\n+ *       otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}\n+ *     },\n+ *     iterationCount INTEGER (1..MAX),\n+ *     keyLength INTEGER (1..MAX) OPTIONAL,\n+ *     prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1\n+ * }\n+ *\n+ * PBKDF2-SaltSources ALGORITHM-IDENTIFIER ::= { ... }\n+ *\n+ * PBKDF2-PRFs ALGORITHM-IDENTIFIER ::= {\n+ *     {NULL IDENTIFIED BY id-hmacWithSHA1} |\n+ *     {NULL IDENTIFIED BY id-hmacWithSHA224} |\n+ *     {NULL IDENTIFIED BY id-hmacWithSHA256} |\n+ *     {NULL IDENTIFIED BY id-hmacWithSHA384} |\n+ *     {NULL IDENTIFIED BY id-hmacWithSHA512}, ... }\n+ *\n+ * algid-hmacWithSHA1 AlgorithmIdentifier {{PBKDF2-PRFs}} ::=\n+ *     {algorithm id-hmacWithSHA1, parameters NULL : NULL}\n+ *\n+ * id-hmacWithSHA1 OBJECT IDENTIFIER ::= {digestAlgorithm 7}\n+ *\n+ * For more information, see\n+ * <a href=\"https:\/\/tools.ietf.org\/html\/rfc8018\">RFC 8018:\n+ * PKCS #5: Password-Based Cryptography Specification<\/a>.\n+ *\n+ * <\/pre>\n+ *\/\n+public final class PBKDF2Parameters {\n+\n+    private final byte[] salt;\n+\n+    private final int iterationCount;\n+\n+    \/\/ keyLength in bits, or -1 if not present\n+    private final int keyLength;\n+\n+    private final String prfAlgo;\n+\n+    \/**\n+     * Initialize PBKDF2Parameters from a DER encoded\n+     * parameter block.\n+     *\n+     * @param pBKDF2_params the DER encoding of the parameter block\n+     *\n+     * @throws IOException for parsing errors in the input stream\n+     *\/\n+    public PBKDF2Parameters(DerValue pBKDF2_params) throws IOException {\n+\n+        if (pBKDF2_params.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"PBKDF2 parameter parsing error: \"\n+                + \"not an ASN.1 SEQUENCE tag\");\n+        }\n+        DerValue specified = pBKDF2_params.data.getDerValue();\n+        \/\/ the 'specified' ASN.1 CHOICE for 'salt' is supported\n+        if (specified.tag == DerValue.tag_OctetString) {\n+            salt = specified.getOctetString();\n+        } else {\n+            \/\/ the 'otherSource' ASN.1 CHOICE for 'salt' is not supported\n+            throw new IOException(\"PBKDF2 parameter parsing error: \"\n+                + \"not an ASN.1 OCTET STRING tag\");\n+        }\n+        iterationCount = pBKDF2_params.data.getInteger();\n+\n+        \/\/ keyLength INTEGER (1..MAX) OPTIONAL,\n+        var ksDer = pBKDF2_params.data.getOptional(DerValue.tag_Integer);\n+        if (ksDer.isPresent()) {\n+            keyLength = ksDer.get().getInteger() * 8; \/\/ keyLength (in bits)\n+        } else {\n+            keyLength = -1;\n+        }\n+\n+        \/\/ prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1\n+        var prfDer = pBKDF2_params.data.getOptional(DerValue.tag_Sequence);\n+        if (prfDer.isPresent()) {\n+            DerValue prf = prfDer.get();\n+            \/\/ the pseudorandom function (default is HmacSHA1)\n+            ObjectIdentifier kdfAlgo_OID = prf.data.getOID();\n+            KnownOIDs o = KnownOIDs.findMatch(kdfAlgo_OID.toString());\n+            if (o == null || (!o.stdName().equals(\"HmacSHA1\") &&\n+                    !o.stdName().equals(\"HmacSHA224\") &&\n+                    !o.stdName().equals(\"HmacSHA256\") &&\n+                    !o.stdName().equals(\"HmacSHA384\") &&\n+                    !o.stdName().equals(\"HmacSHA512\") &&\n+                    !o.stdName().equals(\"HmacSHA512\/224\") &&\n+                    !o.stdName().equals(\"HmacSHA512\/256\"))) {\n+                throw new IOException(\"PBKDF2 parameter parsing error: \"\n+                        + \"expecting the object identifier for a HmacSHA \"\n+                        + \"pseudorandom function\");\n+            }\n+            prfAlgo = o.stdName();\n+            prf.data.getOptional(DerValue.tag_Null);\n+            prf.data.atEnd();\n+        } else {\n+            prfAlgo = \"HmacSHA1\";\n+        }\n+    }\n+\n+    public static byte[] encode(byte[] salt, int iterationCount,\n+            int keyLength, String kdfHmac) {\n+        ObjectIdentifier prf =\n+               ObjectIdentifier.of(KnownOIDs.findMatch(kdfHmac));\n+        return PBKDF2Parameters.encode(salt, iterationCount, keyLength, prf);\n+    }\n+\n+    \/*\n+     * Encode PBKDF2 parameters from components.\n+     * The outer algorithm ID is also encoded in addition to the parameters.\n+     *\/\n+    public static byte[] encode(byte[] salt, int iterationCount,\n+            int keyLength, ObjectIdentifier prf) {\n+        assert keyLength != -1;\n+\n+        DerOutputStream out = new DerOutputStream();\n+        DerOutputStream tmp0 = new DerOutputStream();\n+\n+        tmp0.putOctetString(salt);\n+        tmp0.putInteger(iterationCount);\n+        tmp0.putInteger(keyLength);\n+\n+        \/\/ prf AlgorithmIdentifier {{PBKDF2-PRFs}}\n+        tmp0.write(new AlgorithmId(prf));\n+\n+        \/\/ id-PBKDF2 OBJECT IDENTIFIER ::= {pkcs-5 12}\n+        out.putOID(ObjectIdentifier.of(KnownOIDs.PBKDF2));\n+        out.write(DerValue.tag_Sequence, tmp0);\n+\n+        return new DerOutputStream().write(DerValue.tag_Sequence, out)\n+                .toByteArray();\n+    }\n+\n+    \/**\n+     * Returns the salt.\n+     *\n+     * @return the salt\n+     *\/\n+    public byte[] getSalt() {\n+        return this.salt;\n+    }\n+\n+    \/**\n+     * Returns the iteration count.\n+     *\n+     * @return the iteration count\n+     *\/\n+    public int getIterationCount() {\n+        return this.iterationCount;\n+    }\n+\n+    \/**\n+     * Returns size of key generated by PBKDF2, or -1 if not found\/set.\n+     *\n+     * @return size of key generated by PBKDF2, or -1 if not found\/set\n+     *\/\n+    public int getKeyLength() {\n+        return this.keyLength;\n+    }\n+\n+    \/**\n+     * Returns name of Hmac.\n+     *\n+     * @return name of Hmac\n+     *\/\n+    public String getPrfAlgo() {\n+        return this.prfAlgo;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/PBKDF2Parameters.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -1344,2 +1344,3 @@\n-# file. This can be any HmacPBE algorithm defined in the Mac section of the\n-# Java Security Standard Algorithm Names Specification. When set to \"NONE\",\n+# file. This can be any HmacPBE<digest> or PBEWith<mac> algorithm defined in\n+# the Mac section of the Java Security Standard Algorithm Names Specification,\n+# for example, HmacPBESHA256 or PBEWithHmacSHA256. When set to \"NONE\",\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343232\n+ * @summary Verify correctness of the structure of PKCS12 PBMAC1\n+ *          keystores created with various property values.\n+ *          Verify that keystores load correctly from an input stream.\n+ * @modules java.base\/sun.security.util\n+ * @library \/test\/lib\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.DerUtils;\n+import sun.security.util.KnownOIDs;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+\n+public class PBMAC1Test {\n+\n+    static final char[] PASSWORD = \"1234\".toCharArray();\n+\n+    public static void main(String[] args) throws Exception {\n+        create();\n+        migrate();\n+        overflow();\n+    }\n+\n+    \/\/ PBMAC1 inside PKCS12\n+    \/\/0019:008B  [2]     SEQUENCE\n+    \/\/001C:007B  [20]         SEQUENCE\n+    \/\/001E:0057  [200]             SEQUENCE\n+    \/\/0020:000B  [2000]                 OID 1.2.840.113549.1.5.14 (PBMAC1)\n+    \/\/002B:004A  [2001]                 SEQUENCE\n+    \/\/002D:003A  [20010]                     SEQUENCE\n+    \/\/002F:000B  [200100]                         OID 1.2.840.113549.1.5.12 (PBKDF2)\n+    \/\/003A:002D  [200101]                         SEQUENCE\n+    \/\/003C:0016  [2001010]                             OCTET STRING (20 bytes of salt)\n+    \/\/0052:0004  [2001011]                             INTEGER 10000\n+    \/\/0056:0003  [2001012]                             INTEGER 32\n+    \/\/0059:000E  [2001013]                             SEQUENCE\n+    \/\/005B:000A  [20010130]                                 OID 1.2.840.113549.2.9 (HmacSHA256)\n+    \/\/0065:0002  [20010131]                                 NULL\n+    \/\/0067:000E  [20011]                     SEQUENCE\n+    \/\/0069:000A  [200110]                         OID 1.2.840.113549.2.9 (HmacSHA256)\n+    \/\/0073:0002  [200111]                         NULL\n+    \/\/0075:0022  [201]             OCTET STRING (32 bytes of mac)\n+    \/\/0097:000A  [21]         OCTET STRING (8 bytes of useless salt)\n+    \/\/00A1:0003  [22]         INTEGER 1\n+    static void create() throws Exception {\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"pbewithhmacsha256\");\n+        var der = emptyP12();\n+        DerUtils.checkAlg(der, \"2000\", KnownOIDs.PBMAC1);\n+        DerUtils.checkAlg(der, \"200100\", KnownOIDs.PBKDF2);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA256);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA256);\n+        DerUtils.checkInt(der, \"2001011\", 10000);\n+        DerUtils.checkInt(der, \"2001012\", 32);\n+\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"PBEWITHHMACSHA512\");\n+        der = emptyP12();\n+        DerUtils.checkAlg(der, \"2000\", KnownOIDs.PBMAC1);\n+        DerUtils.checkAlg(der, \"200100\", KnownOIDs.PBKDF2);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA512);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA512);\n+        DerUtils.checkInt(der, \"2001011\", 10000);\n+        DerUtils.checkInt(der, \"2001012\", 64);\n+\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"PBEWiThHmAcSHA512\/224\");\n+        der = emptyP12();\n+        DerUtils.checkAlg(der, \"2000\", KnownOIDs.PBMAC1);\n+        DerUtils.checkAlg(der, \"200100\", KnownOIDs.PBKDF2);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA512$224);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA512$224);\n+        DerUtils.checkInt(der, \"2001011\", 10000);\n+        DerUtils.checkInt(der, \"2001012\", 28);\n+\n+        \/\/ As strange as I can...\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\",\n+                \"PBEWithHmacSHA512\/224AndHmacSHA3-384\");\n+        der = emptyP12();\n+        DerUtils.checkAlg(der, \"2000\", KnownOIDs.PBMAC1);\n+        DerUtils.checkAlg(der, \"200100\", KnownOIDs.PBKDF2);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA512$224);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA3_384);\n+        DerUtils.checkInt(der, \"2001011\", 10000);\n+        DerUtils.checkInt(der, \"2001012\", 48);\n+\n+        \/\/ Bad alg names\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"PBEWithHmacSHA456\");\n+        var reason = Asserts.assertThrows(NoSuchAlgorithmException.class,\n+                () -> emptyP12()).getMessage();\n+        Asserts.assertTrue(reason.contains(\"Algorithm hmacsha456 not available\"), reason);\n+    }\n+\n+    static void migrate() throws Exception {\n+        \/\/ A pkcs12 file using PBEWithHmacSHA256 but key length is 8\n+        var sha2p12 = \"\"\"\n+                MIGhAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBiDB5MFUGCSqGSIb3DQEFDjBIMDgGCSqGSIb3DQEF\n+                DDArBBSV6e5xI+9AYtGHQlDI0X4pmvWLBQICJxACAQgwDAYIKoZIhvcNAgkFADAMBggqhkiG9w0C\n+                CQUABCAaaSO6JgEh1lDo1pvAC0CF5HqgIFBvzt1+GZlgFy7xFQQITk9UIFVTRUQCAQE=\n+                \"\"\";\n+        var der = Base64.getMimeDecoder().decode(sha2p12);\n+        DerUtils.checkInt(der, \"2001012\", 8); \/\/ key length used to be 8\n+\n+        der = loadAndStore(sha2p12);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA256);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA256);\n+        DerUtils.checkInt(der, \"2001012\", 32); \/\/ key length changed to 32\n+    }\n+\n+    static void overflow() throws Exception {\n+\n+        \/\/ Cannot create new\n+        System.setProperty(\"keystore.pkcs12.macIterationCount\", \"5000001\");\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"pbewithhmacsha256\");\n+        Asserts.assertThrows(IllegalArgumentException.class, PBMAC1Test::emptyP12);\n+        System.clearProperty(\"keystore.pkcs12.macAlgorithm\");\n+        Asserts.assertThrows(IllegalArgumentException.class, PBMAC1Test::emptyP12);\n+\n+        \/\/ IC=5000001 using old algorithm\n+        var bigICt = \"\"\"\n+                MGYCAQMwEQYJKoZIhvcNAQcBoAQEAjAAME4wMTANBglghkgBZQMEAgEFAAQgyLBK5h9\/E\/2o7l2A\n+                eALbI1otiS8kT3C41Ef3T38OMjUEFIic7isrAJNr+3+8fUbnMtmB0qytAgNMS0E=\n+                \"\"\";\n+\n+        \/\/ IC=5000000 using old algorithm\n+        var smallICt = \"\"\"\n+                MGYCAQMwEQYJKoZIhvcNAQcBoAQEAjAAME4wMTANBglghkgBZQMEAgEFAAQgR61YZLW6H81rkGTk\n+                XfuU138mkIugdoQBhuNsnvWuBtQEFJ0wmMlpoUiji8PlvwCrmMbqWW4XAgNMS0A=\n+                \"\"\";\n+\n+        \/\/ IC=5000001 using PBMAC1\n+        var bigICp = \"\"\"\n+                MIGiAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBiTB6MFYGCSqGSIb3DQEFDjBJMDkGCSqGSIb3DQEF\n+                DDAsBBQFNf\/gHCO5jNT429D6Q5gxTKHqVAIDTEtBAgEgMAwGCCqGSIb3DQIJBQAwDAYIKoZIhvcN\n+                AgkFAAQgwEVMcyMPQXJSXUIbWqNWjMArtnXDlNUGnKD+19B7QFkECE5PVCBVU0VEAgEB\n+                \"\"\";\n+\n+        \/\/ IC=5000000 using PBMAC1\n+        var smallICp = \"\"\"\n+                MIGiAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBiTB6MFYGCSqGSIb3DQEFDjBJMDkGCSqGSIb3DQEF\n+                DDAsBBS\/ZFfC7swsDHvaCXwyQkuMrZ7dbgIDTEtAAgEgMAwGCCqGSIb3DQIJBQAwDAYIKoZIhvcN\n+                AgkFAAQgCRvE7LDbzkcYOVv\/7iBv0KB3DoUkwnpTI0nsonVfv9UECE5PVCBVU0VEAgEB\"\"\";\n+\n+        loadAndStore(smallICp);\n+        loadAndStore(smallICt);\n+\n+        Asserts.assertTrue(Asserts.assertThrows(IOException.class, () -> loadAndStore(bigICp))\n+                .getMessage().contains(\"MAC iteration count too large: 5000001\"));\n+        Asserts.assertTrue(Asserts.assertThrows(IOException.class, () -> loadAndStore(bigICt))\n+                .getMessage().contains(\"MAC iteration count too large: 5000001\"));\n+\n+        \/\/ Incorrect Salt\n+        var incorrectSalt = \"\"\"\n+                MIGdAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBhDB1MFEGCSqGSIb3DQEFDjBEMDYGCSqGSIb3DQEF\n+                DDApBBSakVhBLltKvqUj6EAxvWqJi+gc7AICJxACASAwCgYIKoZIhvcNAgkwCgYIKoZIhvcNAgkE\n+                IG+euEHE8iN\/2C7txbCjCJ9mU4TgEsHPsC9L3Rxa7malBAhOT1QgVVNFRAIBAQ==\"\"\";\n+        Asserts.assertTrue(Asserts.assertThrows(IOException.class, () -> loadAndStore(incorrectSalt))\n+                .getMessage().contains(\"Integrity check failed\"));\n+\n+        \/\/ Incorrect Iteration Count\n+        var incorrectIC = \"\"\"\n+                MIGdAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBhDB1MFEGCSqGSIb3DQEFDjBEMDYGCSqGSIb3DQEF\n+                DDApBBSZkVhBLltKvqUj6EAxvWqJi+gc7AICKBACASAwCgYIKoZIhvcNAgkwCgYIKoZIhvcNAgkE\n+                IG+euEHE8iN\/2C7txbCjCJ9mU4TgEsHPsC9L3Rxa7malBAhOT1QgVVNFRAIBAQ==\"\"\";\n+        Asserts.assertTrue(Asserts.assertThrows(IOException.class, () -> loadAndStore(incorrectIC))\n+                .getMessage().contains(\"Integrity check failed\"));\n+\n+        \/\/ Missing Key Length\n+        var missingKeyLength = \"\"\"\n+                MIGaAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBgTByME4GCSqGSIb3DQEFDjBBMDMGCSqGSIb3DQEF\n+                DDAmBBSZkVhBLltKvqUj6EAxvWqJi+gc7AICJxAwCgYIKoZIhvcNAgkwCgYIKoZIhvcNAgkEIG+e\n+                uEHE8iN\/2C7txbCjCJ9mU4TgEsHPsC9L3Rxa7malBAhOT1QgVVNFRAIBAQ==\"\"\";\n+        Asserts.assertTrue(Asserts.assertThrows(IOException.class, () -> loadAndStore(missingKeyLength))\n+                .getMessage().contains(\"missing keyLength field\"));\n+    }\n+\n+    static byte[] emptyP12() throws Exception {\n+        var ks = KeyStore.getInstance(\"pkcs12\");\n+        ks.load(null, null);\n+        var os = new ByteArrayOutputStream();\n+        ks.store(os, PASSWORD);\n+        return os.toByteArray();\n+    }\n+\n+    static byte[] loadAndStore(String data) throws Exception {\n+        var bytes = Base64.getMimeDecoder().decode(data);\n+        var ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(new ByteArrayInputStream(bytes), PASSWORD);\n+        var baos = new ByteArrayOutputStream();\n+        ks.store(baos, PASSWORD);\n+        var newBytes = baos.toByteArray();\n+        var bais = new ByteArrayInputStream(newBytes);\n+        ks.load(bais, PASSWORD);\n+        return newBytes;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs12\/PBMAC1Test.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @bug 8076190 8242151 8153005 8266293\n+ * @bug 8076190 8242151 8153005 8266293 8343232\n@@ -247,1 +247,1 @@\n-                checkAlg(data, \"110c11011100\", PBKDF2WithHmacSHA1);\n+                checkAlg(data, \"110c11011100\", PBKDF2);\n@@ -260,1 +260,1 @@\n-            checkAlg(data, \"110c010c0100100\", PBKDF2WithHmacSHA1);\n+            checkAlg(data, \"110c010c0100100\", PBKDF2);\n","filename":"test\/jdk\/sun\/security\/pkcs12\/ParamsPreferences.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}