{"files":[{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.foreign.Arena;\n@@ -51,1 +52,1 @@\n-    enum dtype { BYTE, HEAP, DIRECT };\n+    enum dtype { BYTE, HEAP, DIRECT, MEMORY_SEGMENT };\n@@ -63,0 +64,1 @@\n+    Arena arena;\n@@ -156,0 +158,8 @@\n+        this(algo, ops, null);\n+    }\n+\n+    AEADBufferTest(String algo, List<dtype> ops, Arena arena) {\n+        if (arena == null && ops.contains(dtype.MEMORY_SEGMENT)) {\n+            throw new RuntimeException(\"Arena must not be null if ops contains MEMORY_SEGMENT\");\n+        }\n+        this.arena = arena;\n@@ -436,0 +446,15 @@\n+                    case MEMORY_SEGMENT -> {\n+                        ByteBuffer b = arena.allocate(plen + outOfs).asByteBuffer();\n+                        b.position(outOfs);\n+                        b.put(pt, dataoffset + inOfs, plen);\n+                        b.flip();\n+                        b.position(outOfs);\n+                        ByteBuffer out = arena.allocate(olen).asByteBuffer();\n+                        out.position(outOfs);\n+                        rlen = cipher.update(b, out);\n+                        byte[] o = new byte[rlen];\n+                        out.flip();\n+                        out.position(outOfs);\n+                        out.get(o, 0, rlen);\n+                        ba.write(o);\n+                    }\n@@ -491,0 +516,17 @@\n+                    case MEMORY_SEGMENT -> {\n+                        ByteBuffer b = arena.allocate(plen+inOfs).asByteBuffer();\n+                        b.limit(b.capacity());\n+                        b.position(inOfs);\n+                        b.put(pt, dataoffset + inOfs, plen);\n+                        b.flip();\n+                        b.position(inOfs);\n+                        ByteBuffer out = arena.allocate(olen).asByteBuffer();\n+                        out.limit(out.capacity());\n+                        out.position(outOfs);\n+                        rlen = cipher.doFinal(b, out);\n+                        byte[] o = new byte[rlen];\n+                        out.flip();\n+                        out.position(outOfs);\n+                        out.get(o, 0, rlen);\n+                        ba.write(o);\n+                    }\n@@ -580,0 +622,6 @@\n+            case MEMORY_SEGMENT -> {\n+                bbin = arena.allocate(data.length).asByteBuffer();\n+                bbout = bbin.duplicate();\n+                bbin.put(data, 0, input.length + inOfs);\n+                bbin.flip();\n+            }\n@@ -597,1 +645,1 @@\n-                    case HEAP, DIRECT -> {\n+                    case HEAP, DIRECT, MEMORY_SEGMENT -> {\n@@ -626,1 +674,1 @@\n-                    case HEAP, DIRECT -> {\n+                    case HEAP, DIRECT, MEMORY_SEGMENT -> {\n@@ -663,187 +711,246 @@\n-        \/\/ **** GCM Tests\n-\n-        \/\/ Test single byte array\n-        new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE)).test();\n-        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE)));\n-        \/\/ Test update-doFinal with byte arrays\n-        new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE)).test();\n-        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE)));\n-        \/\/ Test update-update-doFinal with byte arrays\n-        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).test();\n-        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)));\n-\n-        \/\/ Test single heap bytebuffer\n-        new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP)).test();\n-        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP)));\n-        \/\/ Test update-doFinal with heap bytebuffer\n-        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.HEAP, dtype.HEAP)).test();\n-        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP, dtype.HEAP)));\n-        \/\/ Test update-update-doFinal with heap bytebuffer\n-        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)).test();\n-        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)));\n-\n-        \/\/ Test single direct bytebuffer\n-        new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.DIRECT)).test();\n-        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.DIRECT)));\n-        \/\/ Test update-doFinal with direct bytebuffer\n-        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.DIRECT)).test();\n-        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.DIRECT)));\n-        \/\/ Test update-update-doFinal with direct bytebuffer\n-        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).test();\n-        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)));\n-\n-        \/\/ Test update-update-doFinal with byte arrays and preset data sizes\n-        t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).dataSegments(\n-            new int[] { 1, 1, AEADBufferTest.REMAINDER});\n-        t.clone().test();\n-        offsetTests(t.clone());\n-\n-        \/\/ Test update-doFinal with a byte array and a direct bytebuffer\n-        t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.BYTE, dtype.DIRECT)).differentBufferOnly();\n-        t.clone().test();\n-        offsetTests(t.clone());\n-        \/\/ Test update-doFinal with a byte array and heap and direct bytebuffer\n-        t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT)).differentBufferOnly();\n-        t.clone().test();\n-        offsetTests(t.clone());\n-\n-        \/\/ Test update-doFinal with a direct bytebuffer and a byte array.\n-        t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly();\n-        t.clone().test();\n-        offsetTests(t.clone());\n-\n-        \/\/ Test update-doFinal with a direct bytebuffer and a byte array with\n-        \/\/ preset data sizes.\n-        t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly().\n-            dataSegments(new int[] { 20, AEADBufferTest.REMAINDER });\n-        t.clone().test();\n-        offsetTests(t.clone());\n-        \/\/ Test update-update-doFinal with a direct and heap bytebuffer and a\n-        \/\/ byte array with preset data sizes.\n-        t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.BYTE, dtype.HEAP)).\n-            differentBufferOnly().dataSet(5).\n-            dataSegments(new int[] { 5000, 1000, AEADBufferTest.REMAINDER });\n-        t.clone().test();\n-        offsetTests(t.clone());\n-\n-        \/\/ Test update-update-doFinal with byte arrays, incrementing through\n-        \/\/ every data size combination for the Data set 0\n-        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).incrementalSegments().\n-            dataSet(0).test();\n-        \/\/ Test update-update-doFinal with direct bytebuffers, incrementing through\n-        \/\/ every data size combination for the Data set 0\n-        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n-            incrementalSegments().dataSet(0).test();\n-\n-        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n-            dataSegments(new int[] { 49, 0, 2 }).dataSet(0).test();\n-\n-        \/\/ **** CC20P1305 Tests\n-\n-        \/\/ Test single byte array\n-        new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE)).test();\n-        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE)));\n-        \/\/ Test update-doFinal with byte arrays\n-        new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE, dtype.BYTE)).test();\n-        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE, dtype.BYTE)));\n-        \/\/ Test update-update-doFinal with byte arrays\n-        new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).test();\n-        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)));\n-\n-        \/\/ Test single heap bytebuffer\n-        new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.HEAP)).test();\n-        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.HEAP)));\n-        \/\/ Test update-doFinal with heap bytebuffer\n-        new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.HEAP, dtype.HEAP)).test();\n-        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.HEAP, dtype.HEAP)));\n-        \/\/ Test update-update-doFinal with heap bytebuffer\n-        new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)).test();\n-        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)));\n-\n-        \/\/ Test single direct bytebuffer\n-        new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.DIRECT)).test();\n-        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.DIRECT)));\n-        \/\/ Test update-doFinal with direct bytebuffer\n-        new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.DIRECT, dtype.DIRECT)).test();\n-        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.DIRECT, dtype.DIRECT)));\n-        \/\/ Test update-update-doFinal with direct bytebuffer\n-        new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).test();\n-        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)));\n-\n-        \/\/ Test update-update-doFinal with byte arrays and preset data sizes\n-        t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).dataSegments(\n-            new int[] { 1, 1, AEADBufferTest.REMAINDER});\n-        t.clone().test();\n-        offsetTests(t.clone());\n-\n-        \/\/ Test update-doFinal with a byte array and a direct bytebuffer\n-        t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.BYTE, dtype.DIRECT)).differentBufferOnly();\n-        t.clone().test();\n-        offsetTests(t.clone());\n-        \/\/ Test update-doFinal with a byte array and heap and direct bytebuffer\n-        t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT)).differentBufferOnly();\n-        t.clone().test();\n-        offsetTests(t.clone());\n-\n-        \/\/ Test update-doFinal with a direct bytebuffer and a byte array.\n-        t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly();\n-        t.clone().test();\n-        offsetTests(t.clone());\n-\n-        \/\/ Test update-doFinal with a direct bytebuffer and a byte array with\n-        \/\/ preset data sizes.\n-        t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly().\n-            dataSegments(new int[] { 20, AEADBufferTest.REMAINDER });\n-        t.clone().test();\n-        offsetTests(t.clone());\n-        \/\/ Test update-update-doFinal with a direct and heap bytebuffer and a\n-        \/\/ byte array with preset data sizes.\n-        t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.DIRECT, dtype.BYTE, dtype.HEAP)).\n-            differentBufferOnly().dataSet(1).\n-            dataSegments(new int[] { 5000, 1000, AEADBufferTest.REMAINDER });\n-        t.clone().test();\n-        offsetTests(t.clone());\n-\n-        \/\/ Test update-update-doFinal with byte arrays, incrementing through\n-        \/\/ every data size combination for the Data set 0\n-        new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).incrementalSegments().\n-            dataSet(0).test();\n-        \/\/ Test update-update-doFinal with direct bytebuffers, incrementing through\n-        \/\/ every data size combination for the Data set 0\n-        new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n-            incrementalSegments().dataSet(0).test();\n-\n-        new AEADBufferTest(\"ChaCha20-Poly1305\",\n-            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n-            dataSegments(new int[] { 49, 0, 2 }).dataSet(0).test();\n+        try(Arena arena = Arena.ofConfined()) {\n+            \/\/ **** GCM Tests\n+\n+            \/\/ Test single byte array\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE)).test();\n+            offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE)));\n+            \/\/ Test update-doFinal with byte arrays\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE)).test();\n+            offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE)));\n+            \/\/ Test update-update-doFinal with byte arrays\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).test();\n+            offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)));\n+\n+            \/\/ Test single heap bytebuffer\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP)).test();\n+            offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP)));\n+            \/\/ Test update-doFinal with heap bytebuffer\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.HEAP, dtype.HEAP)).test();\n+            offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP, dtype.HEAP)));\n+            \/\/ Test update-update-doFinal with heap bytebuffer\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)).test();\n+            offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)));\n+\n+            \/\/ Test single direct bytebuffer\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.DIRECT)).test();\n+            offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.DIRECT)));\n+            \/\/ Test update-doFinal with direct bytebuffer\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.DIRECT, dtype.DIRECT)).test();\n+            offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.DIRECT, dtype.DIRECT)));\n+            \/\/ Test update-update-doFinal with direct bytebuffer\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).test();\n+            offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)));\n+\n+            \/\/ Test single memory segment bytebuffer\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.MEMORY_SEGMENT), arena).test();\n+            offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.MEMORY_SEGMENT), arena));\n+            \/\/ Test update-doFinal with direct bytebuffer\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.MEMORY_SEGMENT, dtype.MEMORY_SEGMENT), arena).test();\n+            offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.MEMORY_SEGMENT, dtype.MEMORY_SEGMENT), arena));\n+            \/\/ Test update-update-doFinal with direct bytebuffer\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.MEMORY_SEGMENT, dtype.MEMORY_SEGMENT, dtype.MEMORY_SEGMENT), arena).test();\n+            offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.MEMORY_SEGMENT, dtype.MEMORY_SEGMENT, dtype.MEMORY_SEGMENT), arena));\n+\n+            \/\/ Test update-update-doFinal with byte arrays and preset data sizes\n+            t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).dataSegments(\n+                    new int[]{1, 1, AEADBufferTest.REMAINDER});\n+            t.clone().test();\n+            offsetTests(t.clone());\n+\n+            \/\/ Test update-doFinal with a byte array and a direct bytebuffer\n+            t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.BYTE, dtype.DIRECT)).differentBufferOnly();\n+            t.clone().test();\n+            offsetTests(t.clone());\n+            \/\/ Test update-doFinal with a byte array and heap and direct bytebuffer\n+            t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT)).differentBufferOnly();\n+            t.clone().test();\n+            offsetTests(t.clone());\n+            \/\/ Test update-doFinal with a byte array and heap and direct and memory segment bytebuffer\n+            t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT, dtype.MEMORY_SEGMENT), arena).differentBufferOnly();\n+            t.clone().test();\n+            offsetTests(t.clone());\n+\n+            \/\/ Test update-doFinal with a direct bytebuffer and a byte array.\n+            t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly();\n+            t.clone().test();\n+            offsetTests(t.clone());\n+\n+            \/\/ Test update-doFinal with a direct bytebuffer and a byte array with\n+            \/\/ preset data sizes.\n+            t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly().\n+                    dataSegments(new int[]{20, AEADBufferTest.REMAINDER});\n+            t.clone().test();\n+            offsetTests(t.clone());\n+            \/\/ Test update-update-doFinal with a direct and heap bytebuffer and a\n+            \/\/ byte array with preset data sizes.\n+            t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.DIRECT, dtype.BYTE, dtype.HEAP)).\n+                    differentBufferOnly().dataSet(5).\n+                    dataSegments(new int[]{5000, 1000, AEADBufferTest.REMAINDER});\n+            t.clone().test();\n+            offsetTests(t.clone());\n+            \/\/ Test update-update-doFinal with a direct and heap and memory segment\n+            \/\/ bytebuffer and a byte array with preset data sizes.\n+            t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.DIRECT, dtype.BYTE, dtype.HEAP, dtype.MEMORY_SEGMENT), arena).\n+                    differentBufferOnly().dataSet(5).\n+                    dataSegments(new int[]{5000, 1000, AEADBufferTest.REMAINDER});\n+            t.clone().test();\n+            offsetTests(t.clone());\n+\n+            \/\/ Test update-update-doFinal with byte arrays, incrementing through\n+            \/\/ every data size combination for the Data set 0\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).incrementalSegments().\n+                    dataSet(0).test();\n+            \/\/ Test update-update-doFinal with direct bytebuffers, incrementing through\n+            \/\/ every data size combination for the Data set 0\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n+                    incrementalSegments().dataSet(0).test();\n+\n+            new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+                    List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n+                    dataSegments(new int[]{49, 0, 2}).dataSet(0).test();\n+\n+            \/\/ **** CC20P1305 Tests\n+\n+            \/\/ Test single byte array\n+            new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE)).test();\n+            offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE)));\n+            \/\/ Test update-doFinal with byte arrays\n+            new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE, dtype.BYTE)).test();\n+            offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE, dtype.BYTE)));\n+            \/\/ Test update-update-doFinal with byte arrays\n+            new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).test();\n+            offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)));\n+\n+            \/\/ Test single heap bytebuffer\n+            new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.HEAP)).test();\n+            offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.HEAP)));\n+            \/\/ Test update-doFinal with heap bytebuffer\n+            new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.HEAP, dtype.HEAP)).test();\n+            offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.HEAP, dtype.HEAP)));\n+            \/\/ Test update-update-doFinal with heap bytebuffer\n+            new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)).test();\n+            offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)));\n+\n+            \/\/ Test single direct bytebuffer\n+            new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.DIRECT)).test();\n+            offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.DIRECT)));\n+            \/\/ Test update-doFinal with direct bytebuffer\n+            new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.DIRECT, dtype.DIRECT)).test();\n+            offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.DIRECT, dtype.DIRECT)));\n+            \/\/ Test update-update-doFinal with direct bytebuffer\n+            new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).test();\n+            offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)));\n+\n+            \/\/ Test single direct bytebuffer\n+            new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.MEMORY_SEGMENT), arena).test();\n+            offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.MEMORY_SEGMENT), arena));\n+            \/\/ Test update-doFinal with direct bytebuffer\n+            new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.MEMORY_SEGMENT, dtype.MEMORY_SEGMENT), arena).test();\n+            offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.MEMORY_SEGMENT, dtype.MEMORY_SEGMENT), arena));\n+            \/\/ Test update-update-doFinal with direct bytebuffer\n+            new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.MEMORY_SEGMENT, dtype.MEMORY_SEGMENT, dtype.MEMORY_SEGMENT), arena).test();\n+            offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.MEMORY_SEGMENT, dtype.MEMORY_SEGMENT, dtype.MEMORY_SEGMENT), arena));\n+\n+            \/\/ Test update-update-doFinal with byte arrays and preset data sizes\n+            t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).dataSegments(\n+                    new int[]{1, 1, AEADBufferTest.REMAINDER});\n+            t.clone().test();\n+            offsetTests(t.clone());\n+\n+            \/\/ Test update-doFinal with a byte array and a direct bytebuffer\n+            t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.BYTE, dtype.DIRECT)).differentBufferOnly();\n+            t.clone().test();\n+            offsetTests(t.clone());\n+            \/\/ Test update-doFinal with a byte array and heap and direct bytebuffer\n+            t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT)).differentBufferOnly();\n+            t.clone().test();\n+            offsetTests(t.clone());\n+\n+            \/\/ Test update-doFinal with a byte array and heap and direct and memory segment bytebuffer\n+            t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT, dtype.MEMORY_SEGMENT), arena).\n+                    differentBufferOnly();\n+            t.clone().test();\n+            offsetTests(t.clone());\n+\n+            \/\/ Test update-doFinal with a direct bytebuffer and a byte array.\n+            t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly();\n+            t.clone().test();\n+            offsetTests(t.clone());\n+\n+            \/\/ Test update-doFinal with a direct bytebuffer and a byte array with\n+            \/\/ preset data sizes.\n+            t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly().\n+                    dataSegments(new int[]{20, AEADBufferTest.REMAINDER});\n+            t.clone().test();\n+            offsetTests(t.clone());\n+            \/\/ Test update-update-doFinal with a direct and heap bytebuffer and a\n+            \/\/ byte array with preset data sizes.\n+            t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.DIRECT, dtype.BYTE, dtype.HEAP)).\n+                    differentBufferOnly().dataSet(1).\n+                    dataSegments(new int[]{5000, 1000, AEADBufferTest.REMAINDER});\n+            t.clone().test();\n+            offsetTests(t.clone());\n+\n+            \/\/ Test update-update-doFinal with a direct and heap and memory segment\n+            \/\/ bytebuffer and a byte array with preset data sizes.\n+            t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.DIRECT, dtype.BYTE, dtype.HEAP, dtype.MEMORY_SEGMENT), arena).\n+                    differentBufferOnly().dataSet(1).\n+                    dataSegments(new int[]{5000, 1000, AEADBufferTest.REMAINDER});\n+            t.clone().test();\n+            offsetTests(t.clone());\n+\n+            \/\/ Test update-update-doFinal with byte arrays, incrementing through\n+            \/\/ every data size combination for the Data set 0\n+            new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).incrementalSegments().\n+                    dataSet(0).test();\n+            \/\/ Test update-update-doFinal with direct bytebuffers, incrementing through\n+            \/\/ every data size combination for the Data set 0\n+            new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n+                    incrementalSegments().dataSet(0).test();\n+\n+            new AEADBufferTest(\"ChaCha20-Poly1305\",\n+                    List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n+                    dataSegments(new int[]{49, 0, 2}).dataSet(0).test();\n+        }\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/AEADBufferTest.java","additions":297,"deletions":190,"binary":false,"changes":487,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.Arena;\n@@ -120,0 +121,4 @@\n+        try(Arena arena = Arena.ofConfined()) {\n+            new GCMShortBuffer(arena.allocate(13).asByteBuffer());\n+            new GCMShortBuffer(arena.allocate(50).asByteBuffer());\n+        }\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMShortBuffer.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.Arena;\n@@ -53,0 +54,3 @@\n+            try (Arena arena = Arena.ofConfined()) {\n+                cipher.doFinal(arena.allocate(0).asByteBuffer(), arena.allocate(0).asByteBuffer());\n+            }\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMShortInput.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.Arena;\n@@ -80,22 +81,67 @@\n-        for (int i = 0; i < 3; i++) {\n-            for (outOfs = -1; outOfs <= 1; outOfs++) {\n-\n-                Cipher cipher = Cipher.getInstance(algorithm);\n-                cipher.init(Cipher.ENCRYPT_MODE, key, params);\n-\n-                \/\/ Offset on the particular ByteBuffer (aka position())\n-                int inOfsInBuf = 1;\n-                int outOfsInBuf = inOfsInBuf + outOfs;\n-                int sliceLen = cipher.getOutputSize(baseBuf.length);\n-                int bufferSize = sliceLen + Math.max(inOfsInBuf, outOfsInBuf);\n-                byte[] buffer;\n-                \/\/ Create overlapping input and output buffers\n-                switch (i) {\n-                    case 0 -> {\n-                        buffer = new byte[bufferSize];\n-                        output = ByteBuffer.wrap(buffer, outOfsInBuf, sliceLen).\n-                            slice();\n-                        input = ByteBuffer.wrap(buffer, inOfsInBuf, sliceLen).\n-                            slice();\n-                        System.out.println(\"Using array-backed ByteBuffer\");\n-                        in = input.duplicate();\n+        try(Arena arena = Arena.ofConfined()) {\n+            for (int i = 0; i < 4; i++) {\n+                for (outOfs = -1; outOfs <= 1; outOfs++) {\n+\n+                    Cipher cipher = Cipher.getInstance(algorithm);\n+                    cipher.init(Cipher.ENCRYPT_MODE, key, params);\n+\n+                    \/\/ Offset on the particular ByteBuffer (aka position())\n+                    int inOfsInBuf = 1;\n+                    int outOfsInBuf = inOfsInBuf + outOfs;\n+                    int sliceLen = cipher.getOutputSize(baseBuf.length);\n+                    int bufferSize = sliceLen + Math.max(inOfsInBuf, outOfsInBuf);\n+                    byte[] buffer;\n+                    \/\/ Create overlapping input and output buffers\n+                    switch (i) {\n+                        case 0 -> {\n+                            buffer = new byte[bufferSize];\n+                            output = ByteBuffer.wrap(buffer, outOfsInBuf, sliceLen).\n+                                    slice();\n+                            input = ByteBuffer.wrap(buffer, inOfsInBuf, sliceLen).\n+                                    slice();\n+                            System.out.println(\"Using array-backed ByteBuffer\");\n+                            in = input.duplicate();\n+                        }\n+                        case 1 -> {\n+                            buffer = new byte[bufferSize];\n+                            output = ByteBuffer.wrap(buffer, outOfsInBuf, sliceLen).\n+                                    slice();\n+                            input = ByteBuffer.wrap(buffer, inOfsInBuf, sliceLen).\n+                                    slice();\n+\n+                            System.out.println(\"Using read-only array-backed \" +\n+                                    \"ByteBuffer\");\n+                            in = input.asReadOnlyBuffer();\n+                        }\n+                        case 2 -> {\n+                            System.out.println(\"Using direct ByteBuffer\");\n+                            ByteBuffer buf = ByteBuffer.allocateDirect(bufferSize);\n+                            output = buf.duplicate();\n+                            output.position(outOfsInBuf);\n+                            output.limit(sliceLen + outOfsInBuf);\n+                            output = output.slice();\n+\n+                            input = buf.duplicate();\n+                            input.position(inOfsInBuf);\n+                            input.limit(sliceLen + inOfsInBuf);\n+                            input = input.slice();\n+\n+                            in = input.duplicate();\n+                        }\n+\n+                        case 3 -> {\n+                            System.out.println(\"Using memory-segment ByteBuffer\");\n+                            ByteBuffer buf = arena.allocate(bufferSize).asByteBuffer();\n+                            output = buf.duplicate();\n+                            output.position(outOfsInBuf);\n+                            output.limit(sliceLen + outOfsInBuf);\n+                            output = output.slice();\n+\n+                            input = buf.duplicate();\n+                            input.position(inOfsInBuf);\n+                            input.limit(sliceLen + inOfsInBuf);\n+                            input = input.slice();\n+\n+                            in = input.duplicate();\n+                        }\n+                        default -> throw new Exception(\"Unknown index \" + i);\n@@ -103,31 +149,0 @@\n-                    case 1 -> {\n-                        buffer = new byte[bufferSize];\n-                        output = ByteBuffer.wrap(buffer, outOfsInBuf, sliceLen).\n-                            slice();\n-                        input = ByteBuffer.wrap(buffer, inOfsInBuf, sliceLen).\n-                            slice();\n-\n-                        System.out.println(\"Using read-only array-backed \" +\n-                            \"ByteBuffer\");\n-                        in = input.asReadOnlyBuffer();\n-                    }\n-                    case 2 -> {\n-                        System.out.println(\"Using direct ByteBuffer\");\n-                        ByteBuffer buf = ByteBuffer.allocateDirect(bufferSize);\n-                        output = buf.duplicate();\n-                        output.position(outOfsInBuf);\n-                        output.limit(sliceLen + outOfsInBuf);\n-                        output = output.slice();\n-\n-                        input = buf.duplicate();\n-                        input.position(inOfsInBuf);\n-                        input.limit(sliceLen + inOfsInBuf);\n-                        input = input.slice();\n-\n-                        in = input.duplicate();\n-                    }\n-                    default -> throw new Exception(\"Unknown index \" + i);\n-                }\n-\n-                System.out.println(\"inOfsInBuf  = \" + inOfsInBuf);\n-                System.out.println(\"outOfsInBuf = \" + outOfsInBuf);\n@@ -135,4 +150,2 @@\n-                \/\/ Copy data into shared buffer\n-                input.put(baseBuf);\n-                input.flip();\n-                in.limit(input.limit());\n+                    System.out.println(\"inOfsInBuf  = \" + inOfsInBuf);\n+                    System.out.println(\"outOfsInBuf = \" + outOfsInBuf);\n@@ -140,11 +153,2 @@\n-                try {\n-                    int ctSize = cipher.doFinal(in, output);\n-\n-                    \/\/ Get ready to decrypt\n-                    byte[] tmp = new byte[ctSize];\n-                    output.flip();\n-                    output.get(tmp);\n-                    output.clear();\n-\n-                    input.clear();\n-                    input.put(tmp);\n+                    \/\/ Copy data into shared buffer\n+                    input.put(baseBuf);\n@@ -152,2 +156,0 @@\n-\n-                    in.clear();\n@@ -156,12 +158,31 @@\n-                    cipher.init(Cipher.DECRYPT_MODE, key, params);\n-                    cipher.doFinal(in, output);\n-\n-                    output.flip();\n-                    ByteBuffer b = ByteBuffer.wrap(baseBuf);\n-                    if (b.compareTo(output) != 0) {\n-                        System.err.println(\n-                            \"\\nresult   (\" + output + \"):\\n\" +\n-                            byteToHex(output) +\n-                            \"\\nexpected (\" + b + \"):\\n\" +\n-                            byteToHex(b));\n-                        throw new Exception(\"Mismatch\");\n+                    try {\n+                        int ctSize = cipher.doFinal(in, output);\n+\n+                        \/\/ Get ready to decrypt\n+                        byte[] tmp = new byte[ctSize];\n+                        output.flip();\n+                        output.get(tmp);\n+                        output.clear();\n+\n+                        input.clear();\n+                        input.put(tmp);\n+                        input.flip();\n+\n+                        in.clear();\n+                        in.limit(input.limit());\n+\n+                        cipher.init(Cipher.DECRYPT_MODE, key, params);\n+                        cipher.doFinal(in, output);\n+\n+                        output.flip();\n+                        ByteBuffer b = ByteBuffer.wrap(baseBuf);\n+                        if (b.compareTo(output) != 0) {\n+                            System.err.println(\n+                                    \"\\nresult   (\" + output + \"):\\n\" +\n+                                            byteToHex(output) +\n+                                            \"\\nexpected (\" + b + \"):\\n\" +\n+                                            byteToHex(b));\n+                            throw new Exception(\"Mismatch\");\n+                        }\n+                    } catch (Exception e) {\n+                        throw new Exception(\"Error with base offset \" + outOfs, e);\n@@ -169,2 +190,0 @@\n-                } catch (Exception e) {\n-                    throw new Exception(\"Error with base offset \" + outOfs, e);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/OverlapByteBuffer.java","additions":103,"deletions":84,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.lang.foreign.Arena;\n@@ -220,2 +221,0 @@\n-        ByteBuffer AAD_and_Text_Buf = ByteBuffer.allocate(bufSize);\n-        AAD_and_Text_Buf.put(AAD_and_Text, 0, AAD_and_Text.length);\n@@ -223,8 +222,20 @@\n-        \/\/ do test\n-        runGCMWithSameBuffer(Cipher.ENCRYPT_MODE, AAD_and_Text_Buf, offset,\n-                textLength, params);\n-        int tagLength = c.getParameters()\n-                .getParameterSpec(GCMParameterSpec.class).getTLen() \/ 8;\n-        AAD_and_Text_Buf.limit(AADLength + offset + textLength + tagLength);\n-        runGCMWithSameBuffer(Cipher.DECRYPT_MODE, AAD_and_Text_Buf, offset,\n-                textLength + tagLength, params);\n+        try (Arena arena = Arena.ofConfined()) {\n+            for (int i = 0; i < 2; ++i) {\n+                ByteBuffer AAD_and_Text_Buf = switch (i) {\n+                    case 0 -> ByteBuffer.allocate(bufSize);\n+                    case 1 -> arena.allocate(bufSize).asByteBuffer();\n+                    default -> throw new RuntimeException(\"Unknown test case\");\n+                };\n+\n+                AAD_and_Text_Buf.put(AAD_and_Text, 0, AAD_and_Text.length);\n+\n+                \/\/ do test\n+                runGCMWithSameBuffer(Cipher.ENCRYPT_MODE, AAD_and_Text_Buf, offset,\n+                        textLength, params);\n+                int tagLength = c.getParameters()\n+                        .getParameterSpec(GCMParameterSpec.class).getTLen() \/ 8;\n+                AAD_and_Text_Buf.limit(AADLength + offset + textLength + tagLength);\n+                runGCMWithSameBuffer(Cipher.DECRYPT_MODE, AAD_and_Text_Buf, offset,\n+                        textLength + tagLength, params);\n+            }\n+        }\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/SameBuffer.java","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.foreign.Arena;\n@@ -46,0 +47,2 @@\n+    enum BufferType { DIRECT, HEAP, MEMORY_SEGMENT };\n+\n@@ -323,1 +326,1 @@\n-    void executeByteBuffer(TestVector tv, boolean direct, int offset) throws Exception {\n+    void executeByteBuffer(TestVector tv, BufferType bufferType, int offset) throws Exception {\n@@ -331,49 +334,25 @@\n-        if (direct) {\n-            System.out.print(\"Test #\" + tv.id + \": ByteBuffer Direct.\");\n-            src = ByteBuffer.allocateDirect(tv.plainText.length + offset);\n-            ctdst = ByteBuffer.allocateDirect(tv.cipherText.length + tv.tag.length + offset);\n-            ptdst = ByteBuffer.allocateDirect(tv.plainText.length + offset);\n-        } else {\n-            System.out.print(\"Test #\" + tv.id + \": ByteBuffer Heap.\");\n-            src = ByteBuffer.allocate(tv.plainText.length + offset);\n-            ctdst = ByteBuffer.allocate(tv.cipherText.length + tv.tag.length + offset);\n-            ptdst = ByteBuffer.allocate(tv.plainText.length + offset);\n-        }\n-\n-        byte[] plainText;\n-\n-        if (offset > 0) {\n-            System.out.println(\"  offset = \" + offset);\n-            plainText = new byte[tv.plainText.length + offset];\n-            System.arraycopy(tv.plainText, 0, plainText, offset,\n-                tv.plainText.length);\n-        } else {\n-            System.out.println();\n-            plainText = tv.plainText;\n-        }\n-\n-        src.put(plainText);\n-        src.position(offset);\n-        ctdst.position(offset);\n-        ctdst.mark();\n-        ptdst.position(offset);\n-        ptdst.mark();\n-\n-        try {\n-            c.init(Cipher.ENCRYPT_MODE, tv.key, tv.spec);\n-            c.updateAAD(tv.aad);\n-            c.doFinal(src, ctdst);\n-\n-            ctdst.reset();\n-            ByteBuffer tag = ctdst.duplicate();\n-            tag.position(tag.limit() - tv.tag.length);\n-\n-            c.init(Cipher.DECRYPT_MODE, tv.key, tv.spec);\n-            c.updateAAD(tv.aad);\n-            c.doFinal(ctdst, ptdst); \/\/ should fail if tag mismatched\n-\n-            ptdst.reset();\n-            \/\/ check encryption\/decryption results just to be sure\n-            if (ptdst.compareTo(ByteBuffer.wrap(tv.plainText)) != 0) {\n-                System.out.println(\"\\t PlainText diff failed for test# \" + tv.id);\n-                testFailed = true;\n+        try (Arena arena = Arena.ofConfined()) {\n+            switch (bufferType) {\n+                case DIRECT: {\n+                    System.out.print(\"Test #\" + tv.id + \": ByteBuffer Direct.\");\n+                    src = ByteBuffer.allocateDirect(tv.plainText.length + offset);\n+                    ctdst = ByteBuffer.allocateDirect(tv.cipherText.length + tv.tag.length + offset);\n+                    ptdst = ByteBuffer.allocateDirect(tv.plainText.length + offset);\n+                }\n+                break;\n+                case HEAP: {\n+                    System.out.print(\"Test #\" + tv.id + \": ByteBuffer Heap.\");\n+                    src = ByteBuffer.allocate(tv.plainText.length + offset);\n+                    ctdst = ByteBuffer.allocate(tv.cipherText.length + tv.tag.length + offset);\n+                    ptdst = ByteBuffer.allocate(tv.plainText.length + offset);\n+                }\n+                break;\n+                case MEMORY_SEGMENT: {\n+                    System.out.print(\"Test #\" + tv.id + \": ByteBuffer MemorySegment.\");\n+                    src = arena.allocate(tv.plainText.length + offset).asByteBuffer();\n+                    ctdst = arena.allocate(tv.cipherText.length + tv.tag.length + offset).asByteBuffer();\n+                    ptdst = arena.allocate(tv.plainText.length + offset).asByteBuffer();\n+                }\n+                break;\n+                default:\n+                    throw new RuntimeException(\"Unsupported buffer type \" + bufferType);\n@@ -382,6 +361,1 @@\n-            ctdst.reset();\n-            ctdst.limit(ctdst.limit() - tv.tag.length);\n-            if (ctdst.compareTo(ByteBuffer.wrap(tv.cipherText)) != 0) {\n-                System.out.println(\"\\t CipherText diff failed for test# \" + tv.id);\n-                testFailed = true;\n-            }\n+            byte[] plainText;\n@@ -389,3 +363,8 @@\n-            int mismatch = 0;\n-            for (int i = 0; i < tv.tag.length; i++) {\n-                mismatch |= tag.get() ^ tv.tag[i];\n+            if (offset > 0) {\n+                System.out.println(\"  offset = \" + offset);\n+                plainText = new byte[tv.plainText.length + offset];\n+                System.arraycopy(tv.plainText, 0, plainText, offset,\n+                        tv.plainText.length);\n+            } else {\n+                System.out.println();\n+                plainText = tv.plainText;\n@@ -393,3 +372,47 @@\n-            if (mismatch != 0) {\n-                System.out.println(\"\\t Tag diff failed for test# \" + tv.id);\n-                testFailed = true;\n+\n+            src.put(plainText);\n+            src.position(offset);\n+            ctdst.position(offset);\n+            ctdst.mark();\n+            ptdst.position(offset);\n+            ptdst.mark();\n+\n+            try {\n+                c.init(Cipher.ENCRYPT_MODE, tv.key, tv.spec);\n+                c.updateAAD(tv.aad);\n+                c.doFinal(src, ctdst);\n+\n+                ctdst.reset();\n+                ByteBuffer tag = ctdst.duplicate();\n+                tag.position(tag.limit() - tv.tag.length);\n+\n+                c.init(Cipher.DECRYPT_MODE, tv.key, tv.spec);\n+                c.updateAAD(tv.aad);\n+                c.doFinal(ctdst, ptdst); \/\/ should fail if tag mismatched\n+\n+                ptdst.reset();\n+                \/\/ check encryption\/decryption results just to be sure\n+                if (ptdst.compareTo(ByteBuffer.wrap(tv.plainText)) != 0) {\n+                    System.out.println(\"\\t PlainText diff failed for test# \" + tv.id);\n+                    testFailed = true;\n+                }\n+\n+                ctdst.reset();\n+                ctdst.limit(ctdst.limit() - tv.tag.length);\n+                if (ctdst.compareTo(ByteBuffer.wrap(tv.cipherText)) != 0) {\n+                    System.out.println(\"\\t CipherText diff failed for test# \" + tv.id);\n+                    testFailed = true;\n+                }\n+\n+                int mismatch = 0;\n+                for (int i = 0; i < tv.tag.length; i++) {\n+                    mismatch |= tag.get() ^ tv.tag[i];\n+                }\n+                if (mismatch != 0) {\n+                    System.out.println(\"\\t Tag diff failed for test# \" + tv.id);\n+                    testFailed = true;\n+                }\n+            } catch (Exception ex) {\n+                \/\/ continue testing other test vectors\n+                System.out.println(\"\\t Failed Test Vector ( #\" + tv.id + \") : \" + tv);\n+                ex.printStackTrace();\n@@ -397,4 +420,0 @@\n-        } catch (Exception ex) {\n-            \/\/ continue testing other test vectors\n-            System.out.println(\"\\t Failed Test Vector ( #\" + tv.id + \") : \" + tv);\n-            ex.printStackTrace();\n@@ -408,4 +427,6 @@\n-            test.executeByteBuffer(tv, false, 0);\n-            test.executeByteBuffer(tv, true, 0);\n-            test.executeByteBuffer(tv, false, 2);\n-            test.executeByteBuffer(tv, true, 2);\n+            test.executeByteBuffer(tv, BufferType.HEAP, 0);\n+            test.executeByteBuffer(tv, BufferType.DIRECT, 0);\n+            test.executeByteBuffer(tv, BufferType.MEMORY_SEGMENT, 0);\n+            test.executeByteBuffer(tv, BufferType.HEAP, 2);\n+            test.executeByteBuffer(tv, BufferType.DIRECT, 2);\n+            test.executeByteBuffer(tv, BufferType.MEMORY_SEGMENT, 2);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AES\/TestKATForGCM.java","additions":91,"deletions":70,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.foreign.Arena;\n@@ -203,1 +204,7 @@\n-            if (runByteBuffer(test)) {\n+            if (runByteBuffer(test, true)) {\n+                testsPassed++;\n+            }\n+\n+            System.out.println(\"*** Test \" + ++testNumber + \": \" +\n+                    test.testName);\n+            if (runByteBuffer(test, false)) {\n@@ -363,1 +370,1 @@\n-    private static boolean runByteBuffer(TestData testData)\n+    private static boolean runByteBuffer(TestData testData, boolean heap)\n@@ -375,19 +382,12 @@\n-        ByteBuffer bbIn = ByteBuffer.wrap(testData.input);\n-        ByteBuffer bbEncOut = ByteBuffer.allocate(\n-                mambo.getOutputSize(testData.input.length));\n-        ByteBuffer bbExpOut = ByteBuffer.wrap(testData.expOutput);\n-\n-        mambo.doFinal(bbIn, bbEncOut);\n-        bbIn.rewind();\n-        bbEncOut.rewind();\n-\n-        if (bbEncOut.compareTo(bbExpOut) != 0) {\n-            System.out.println(\"ERROR - Output Mismatch!\");\n-            System.out.println(\"Expected:\\n\" +\n-                    dumpHexBytes(bbExpOut, 16, \"\\n\", \" \"));\n-            System.out.println(\"Actual:\\n\" +\n-                    dumpHexBytes(bbEncOut, 16, \"\\n\", \" \"));\n-            System.out.println();\n-        } else {\n-            encRes = true;\n-        }\n+        try (Arena arena = Arena.ofConfined()) {\n+            ByteBuffer bbIn = ByteBuffer.wrap(testData.input);\n+            ByteBuffer bbEncOut;\n+            ByteBuffer bbExpOut = ByteBuffer.wrap(testData.expOutput);\n+            if (heap) {\n+                bbEncOut = ByteBuffer.allocate(\n+                        mambo.getOutputSize(testData.input.length));\n+            } else {\n+                bbEncOut = arena.allocate(\n+                        mambo.getOutputSize(testData.input.length))\n+                        .asByteBuffer();\n+            }\n@@ -395,6 +395,14 @@\n-        \/\/ Decrypt the result of the encryption operation\n-        mambo = Cipher.getInstance(\"ChaCha20\");\n-        mambo.init(Cipher.DECRYPT_MODE, mamboKey, mamboSpec);\n-        System.out.print(\"Decrypt - \");\n-        ByteBuffer bbDecOut = ByteBuffer.allocate(\n-                mambo.getOutputSize(bbEncOut.remaining()));\n+            mambo.doFinal(bbIn, bbEncOut);\n+            bbIn.rewind();\n+            bbEncOut.rewind();\n+\n+            if (bbEncOut.compareTo(bbExpOut) != 0) {\n+                System.out.println(\"ERROR - Output Mismatch!\");\n+                System.out.println(\"Expected:\\n\" +\n+                        dumpHexBytes(bbExpOut, 16, \"\\n\", \" \"));\n+                System.out.println(\"Actual:\\n\" +\n+                        dumpHexBytes(bbEncOut, 16, \"\\n\", \" \"));\n+                System.out.println();\n+            } else {\n+                encRes = true;\n+            }\n@@ -402,3 +410,13 @@\n-        mambo.doFinal(bbEncOut, bbDecOut);\n-        bbEncOut.rewind();\n-        bbDecOut.rewind();\n+            \/\/ Decrypt the result of the encryption operation\n+            mambo = Cipher.getInstance(\"ChaCha20\");\n+            mambo.init(Cipher.DECRYPT_MODE, mamboKey, mamboSpec);\n+            System.out.print(\"Decrypt - \");\n+            ByteBuffer bbDecOut;\n+            if (heap) {\n+                bbDecOut = ByteBuffer.allocate(\n+                        mambo.getOutputSize(bbEncOut.remaining()));\n+            } else {\n+                bbDecOut = arena.allocate(\n+                        mambo.getOutputSize(bbEncOut.remaining()))\n+                        .asByteBuffer();\n+            }\n@@ -406,9 +424,14 @@\n-        if (bbDecOut.compareTo(bbIn) != 0) {\n-            System.out.println(\"ERROR - Output Mismatch!\");\n-            System.out.println(\"Expected:\\n\" +\n-                    dumpHexBytes(bbIn, 16, \"\\n\", \" \"));\n-            System.out.println(\"Actual:\\n\" +\n-                    dumpHexBytes(bbDecOut, 16, \"\\n\", \" \"));\n-            System.out.println();\n-        } else {\n-            decRes = true;\n+            mambo.doFinal(bbEncOut, bbDecOut);\n+            bbEncOut.rewind();\n+            bbDecOut.rewind();\n+\n+            if (bbDecOut.compareTo(bbIn) != 0) {\n+                System.out.println(\"ERROR - Output Mismatch!\");\n+                System.out.println(\"Expected:\\n\" +\n+                        dumpHexBytes(bbIn, 16, \"\\n\", \" \"));\n+                System.out.println(\"Actual:\\n\" +\n+                        dumpHexBytes(bbDecOut, 16, \"\\n\", \" \"));\n+                System.out.println();\n+            } else {\n+                decRes = true;\n+            }\n@@ -416,1 +439,0 @@\n-\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/ChaCha20KAT.java","additions":62,"deletions":40,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.lang.foreign.Arena;\n@@ -30,0 +31,1 @@\n+import java.util.function.Function;\n@@ -122,1 +124,1 @@\n-        if (!largeByteBufferTest(theMac)) {\n+        if (!largeByteBufferTest(theMac, this::generateRandomByteBuffer)) {\n@@ -128,1 +130,1 @@\n-        if (!emptyByteBufferTest(theMac)) {\n+        if (!emptyByteBufferTest(theMac, this::generateRandomByteBuffer)) {\n@@ -133,0 +135,16 @@\n+        try(Arena arena = Arena.ofConfined()) {\n+            \/\/ Do large ByteBuffer test case\n+            if (!largeByteBufferTest(theMac,\n+                    (size) -> arena.allocate(size).asByteBuffer())) {\n+                System.out.println(\"Large MemorySegment ByteBuffer test case failed.\");\n+                return false;\n+            }\n+\n+            \/\/ Do empty ByteBuffer test case\n+            if (!emptyByteBufferTest(theMac,\n+                    (size) -> arena.allocate(size).asByteBuffer())) {\n+                System.out.println(\"Empty MemorySegment ByteBuffer test case failed.\");\n+                return false;\n+            }\n+        }\n+\n@@ -151,2 +169,3 @@\n-    protected boolean largeByteBufferTest(Mac theMac) {\n-        ByteBuffer buf = generateRandomByteBuffer(LARGE_SIZE);\n+    protected boolean largeByteBufferTest(Mac theMac,\n+                              Function<Integer, ByteBuffer> createBuffer) {\n+        ByteBuffer buf = createBuffer.apply(LARGE_SIZE);\n@@ -182,2 +201,2 @@\n-    protected boolean emptyByteBufferTest(Mac theMac) {\n-        ByteBuffer buf = generateRandomByteBuffer(0);\n+    protected boolean emptyByteBufferTest(Mac theMac, Function<Integer, ByteBuffer> createBuffer) {\n+        ByteBuffer buf = createBuffer.apply(0);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/PBE\/PBMacBuffer.java","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,5 @@\n-import java.util.*;\n-import java.nio.*;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.nio.ByteBuffer;\n@@ -80,0 +83,12 @@\n+\n+        \/\/ test 4: ByteBuffer backed by a MemorySegment\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(t.length);\n+            ByteBuffer b5 = segment.asByteBuffer();\n+            b5.put(t);\n+            b5.clear();\n+            byte [] d5 = digest(md, b5, random);\n+            if (Arrays.equals(d1, d5) == false) {\n+                throw new Exception(\"Test 4 failed\");\n+            }\n+        }\n","filename":"test\/jdk\/java\/security\/MessageDigest\/ByteBuffers.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,4 +34,9 @@\n-import java.util.*;\n-import java.nio.*;\n-\n-import java.security.*;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.Signature;\n+import java.util.Random;\n+import java.nio.ByteBuffer;\n@@ -83,0 +88,9 @@\n+        \/\/ test 4: ByteBuffer with backing MemorySegment\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(t.length);\n+            ByteBuffer b5 = segment.asByteBuffer();\n+            b5.put(t);\n+            b5.clear();\n+            verify(sig, signature, b5, random);\n+        }\n+\n","filename":"test\/jdk\/java\/security\/Signature\/ByteBuffers.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,4 @@\n-import java.util.*;\n-import java.nio.*;\n+import java.lang.foreign.Arena;\n+import java.util.Random;\n+import java.util.Arrays;\n+import java.nio.ByteBuffer;\n@@ -37,1 +39,2 @@\n-import java.security.*;\n+import java.security.Provider;\n+import java.security.Security;\n@@ -39,2 +42,3 @@\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -63,6 +67,7 @@\n-        \/\/ create ByteBuffers for input (i1, i2, i3) and fill them\n-        ByteBuffer i0 = ByteBuffer.allocate(n + 256);\n-        i0.position(random.nextInt(256));\n-        i0.limit(i0.position() + n);\n-        ByteBuffer i1 = i0.slice();\n-        i1.put(t);\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ create ByteBuffers for input (i1, i2, i3) and fill them\n+            ByteBuffer i0 = ByteBuffer.allocate(n + 256);\n+            i0.position(random.nextInt(256));\n+            i0.limit(i0.position() + n);\n+            ByteBuffer i1 = i0.slice();\n+            i1.put(t);\n@@ -70,2 +75,2 @@\n-        ByteBuffer i2 = ByteBuffer.allocateDirect(t.length);\n-        i2.put(t);\n+            ByteBuffer i2 = ByteBuffer.allocateDirect(t.length);\n+            i2.put(t);\n@@ -73,2 +78,2 @@\n-        i1.clear();\n-        ByteBuffer i3 = i1.asReadOnlyBuffer();\n+            i1.clear();\n+            ByteBuffer i3 = i1.asReadOnlyBuffer();\n@@ -76,4 +81,3 @@\n-        ByteBuffer o0 = ByteBuffer.allocate(n + 512);\n-        o0.position(random.nextInt(256));\n-        o0.limit(o0.position() + n + 256);\n-        ByteBuffer o1 = o0.slice();\n+            ByteBuffer i4 = arena.allocate(t.length).asByteBuffer();\n+            i4.put(t);\n+            i4.clear();\n@@ -81,1 +85,4 @@\n-        ByteBuffer o2 = ByteBuffer.allocateDirect(t.length + 256);\n+            ByteBuffer o0 = ByteBuffer.allocate(n + 512);\n+            o0.position(random.nextInt(256));\n+            o0.limit(o0.position() + n + 256);\n+            ByteBuffer o1 = o0.slice();\n@@ -83,6 +90,19 @@\n-        crypt(cipher, i1, o1, outBytes, random);\n-        crypt(cipher, i2, o1, outBytes, random);\n-        crypt(cipher, i3, o1, outBytes, random);\n-        crypt(cipher, i1, o2, outBytes, random);\n-        crypt(cipher, i2, o2, outBytes, random);\n-        crypt(cipher, i3, o2, outBytes, random);\n+            ByteBuffer o2 = ByteBuffer.allocateDirect(t.length + 256);\n+\n+            ByteBuffer o3 = arena.allocate(t.length).asByteBuffer();\n+\n+            crypt(cipher, i1, o1, outBytes, random);\n+            crypt(cipher, i2, o1, outBytes, random);\n+            crypt(cipher, i3, o1, outBytes, random);\n+            crypt(cipher, i4, o1, outBytes, random);\n+\n+            crypt(cipher, i1, o2, outBytes, random);\n+            crypt(cipher, i2, o2, outBytes, random);\n+            crypt(cipher, i3, o2, outBytes, random);\n+            crypt(cipher, i4, o2, outBytes, random);\n+\n+            crypt(cipher, i1, o3, outBytes, random);\n+            crypt(cipher, i2, o3, outBytes, random);\n+            crypt(cipher, i3, o3, outBytes, random);\n+            crypt(cipher, i4, o3, outBytes, random);\n+        }\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/ByteBuffers.java","additions":47,"deletions":27,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,3 @@\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.lang.foreign.Arena;\n@@ -71,0 +72,7 @@\n+        try(Arena arena = Arena.ofConfined()) {\n+            bb = arena.allocate(bytes.length).asByteBuffer();\n+            bb.put(bytes);\n+            bb.clear();\n+            updateAADPass(bb);\n+        }\n+\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/GCMAPI.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.lang.foreign.Arena;\n@@ -51,1 +52,1 @@\n-    private static final boolean DEBUG = false;\n+    private static final boolean DEBUG = Boolean.getBoolean(\"test.debug\");\n@@ -68,1 +69,1 @@\n-        ALLOCATE, DIRECT, WRAP;\n+        ALLOCATE, DIRECT, WRAP, MEMORY_SEGMENT;\n@@ -72,1 +73,0 @@\n-\n@@ -107,1 +107,9 @@\n-        \/\/ Test#3: against ByteBuffer wrapping existing array\n+        \/\/ Test#3: against ByteBuffer backed by MemorySegment\n+        try (Arena arena = Arena.ofConfined()) {\n+            prepareBuffers(BufferType.MEMORY_SEGMENT, useRO, buf.length,\n+                    buf, 0, PLAINTEXT_SIZE, offset, arena);\n+            runTest(offset, expectedPT, expectedCT);\n+            System.out.println(\"\\tMEMSEGMENT: passed\");\n+        }\n+\n+        \/\/ Test#4: against ByteBuffer wrapping existing array\n@@ -120,0 +128,6 @@\n+        prepareBuffers(type, useRO, bufSz, in, inOfs, inLen, outOfs, null);\n+    }\n+\n+    private static void prepareBuffers(BufferType type,\n+                                       boolean useRO, int bufSz, byte[] in, int inOfs, int inLen,\n+                                       int outOfs, Arena arena) {\n@@ -145,0 +159,12 @@\n+            case MEMORY_SEGMENT:\n+                if (arena == null) {\n+                    throw new RuntimeException(\n+                            \"arena argument cannot be null for MEMORY_SEGMENT buffers.\");\n+                }\n+                outBuf = arena.allocate(bufSz).asByteBuffer();\n+                inBuf = outBuf.slice();\n+                inBuf.put(in, inOfs, inLen);\n+                inBuf.rewind();\n+                inBuf.limit(inLen);\n+                outBuf.position(outOfs);\n+                break;\n@@ -150,0 +176,1 @@\n+            System.out.println(\"Buffer type: \" + type);\n","filename":"test\/jdk\/javax\/crypto\/CipherSpi\/CipherByteBufferOverwriteTest.java","additions":32,"deletions":5,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.lang.foreign.Arena;\n@@ -77,23 +78,32 @@\n-        for (int size = 0; size <= testSizes; size++) {\n-            boolean output = (size % outputFrequency) == 0;\n-            if (output) {\n-                System.out.print(\"\\nTesting buffer size: \" + size + \":\");\n-            }\n-\n-            int outSize = cipher.getOutputSize(size);\n-\n-            try {\n-                encrypt(cipher, size,\n-                        ByteBuffer.allocate(size),\n-                        ByteBuffer.allocate(outSize),\n-                        ByteBuffer.allocateDirect(size),\n-                        ByteBuffer.allocateDirect(outSize),\n-                        output);\n-            } catch (Exception e) {\n-                System.out.print(\"\\n    Failed with size \" + size);\n-                failedOnce = true;\n-                failedReason = e;\n-\n-                \/\/ If we got an exception, let's be safe for future\n-                \/\/ testing and reset the cipher to a known good state.\n-                cipher.init(Cipher.ENCRYPT_MODE, key);\n+        try (Arena arena = Arena.ofConfined()) {\n+            for (int size = 0; size <= testSizes; size++) {\n+                boolean output = (size % outputFrequency) == 0;\n+                if (output) {\n+                    System.out.print(\"\\nTesting buffer size: \" + size + \":\");\n+                }\n+\n+                int outSize = cipher.getOutputSize(size);\n+\n+                try {\n+                    encrypt(cipher, size,\n+                            ByteBuffer.allocate(size),\n+                            ByteBuffer.allocate(outSize),\n+                            ByteBuffer.allocateDirect(size),\n+                            ByteBuffer.allocateDirect(outSize),\n+                            output);\n+\n+                    encrypt(cipher, size,\n+                            ByteBuffer.allocate(size),\n+                            ByteBuffer.allocate(outSize),\n+                            arena.allocate(size).asByteBuffer(),\n+                            arena.allocate(outSize).asByteBuffer(),\n+                            output);\n+                } catch (Exception e) {\n+                    System.out.print(\"\\n    Failed with size \" + size);\n+                    failedOnce = true;\n+                    failedReason = e;\n+\n+                    \/\/ If we got an exception, let's be safe for future\n+                    \/\/ testing and reset the cipher to a known good state.\n+                    cipher.init(Cipher.ENCRYPT_MODE, key);\n+                }\n@@ -105,0 +115,1 @@\n+\n","filename":"test\/jdk\/javax\/crypto\/CipherSpi\/DirectBBRemaining.java","additions":35,"deletions":24,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.lang.foreign.Arena;\n@@ -80,2 +81,3 @@\n-        for (int t = 1; t <= multiples; t++) {\n-            int size = t * dataSize;\n+        try (Arena arena = Arena.ofConfined()) {\n+            for (int t = 1; t <= multiples; t++) {\n+                int size = t * dataSize;\n@@ -83,1 +85,1 @@\n-            System.out.println(\"\\nTesting data size: \" + size);\n+                System.out.println(\"\\nTesting data size: \" + size);\n@@ -85,10 +87,17 @@\n-            try {\n-                decrypt(cipher, key, s, dataChunk, t,\n-                        ByteBuffer.allocate(dataSize),\n-                        ByteBuffer.allocate(size),\n-                        ByteBuffer.allocateDirect(dataSize),\n-                        ByteBuffer.allocateDirect(size));\n-            } catch (Exception e) {\n-                System.out.println(\"\\tFailed with data size \" + size);\n-                failedOnce = true;\n-                failedReason = e;\n+                try {\n+                    decrypt(cipher, key, s, dataChunk, t,\n+                            ByteBuffer.allocate(dataSize),\n+                            ByteBuffer.allocate(size),\n+                            ByteBuffer.allocateDirect(dataSize),\n+                            ByteBuffer.allocateDirect(size));\n+\n+                    decrypt(cipher, key, s, dataChunk, t,\n+                            ByteBuffer.allocate(dataSize),\n+                            ByteBuffer.allocate(size),\n+                            arena.allocate(dataSize).asByteBuffer(),\n+                            arena.allocate(size).asByteBuffer());\n+                } catch (Exception e) {\n+                    System.out.println(\"\\tFailed with data size \" + size);\n+                    failedOnce = true;\n+                    failedReason = e;\n+                }\n","filename":"test\/jdk\/javax\/crypto\/CipherSpi\/TestGCMWithByteBuffer.java","additions":23,"deletions":14,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,4 @@\n-import java.util.*;\n-import java.nio.*;\n+import java.lang.foreign.Arena;\n+import java.util.Random;\n+import java.util.Arrays;\n+import java.nio.ByteBuffer;\n@@ -37,1 +39,2 @@\n-import java.security.*;\n+import java.security.Provider;\n+import java.security.Security;\n@@ -80,0 +83,8 @@\n+        \/\/ test 4: ByteBuffer from MemorySegment\n+        try (Arena arena = Arena.ofConfined()) {\n+            ByteBuffer b5 = arena.allocate(t.length).asByteBuffer();\n+            b5.put(t);\n+            b5.clear();\n+            verify(mac, macValue, b5, random);\n+        }\n+\n","filename":"test\/jdk\/javax\/crypto\/Mac\/ByteBuffers.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.Arena;\n@@ -44,1 +45,1 @@\n-public class TestCipherTextStealingMultipart extends PKCS11Test {\n+public class TestCipherTextStealingMultipart extends PKCS11Test implements AutoCloseable {\n@@ -57,0 +58,10 @@\n+    private final Arena arena;\n+\n+    public TestCipherTextStealingMultipart() {\n+        arena = Arena.ofConfined();\n+    }\n+\n+    public void close() {\n+        arena.close();\n+    }\n+\n@@ -108,1 +119,1 @@\n-    private enum OutputType {BYTE_ARRAY, DIRECT_BYTE_BUFFER}\n+    private enum OutputType {BYTE_ARRAY, DIRECT_BYTE_BUFFER, MEMSEGMENT_BYTE_BUFFER}\n@@ -126,0 +137,1 @@\n+                case MEMSEGMENT_BYTE_BUFFER -> \"MemorySegment ByteBuffer\";\n@@ -132,1 +144,1 @@\n-    private static ByteBuffer encryptOrDecryptMultipart(int operation,\n+    private ByteBuffer encryptOrDecryptMultipart(int operation,\n@@ -164,0 +176,14 @@\n+            } case MEMSEGMENT_BYTE_BUFFER -> {\n+                output = arena.allocate(totalLength).asByteBuffer();\n+                for (byte[] inputChunk : inputChunks) {\n+                    output.put(cipher.update(inputChunk));\n+                }\n+                \/\/ Check that the output array offset does not affect the\n+                \/\/ penultimate block length calculation.\n+                ByteBuffer tmpOut =arena.allocate(\n+                        cipher.getOutputSize(0) + outOfs)\n+                        .asByteBuffer();\n+                tmpOut.position(outOfs);\n+                cipher.doFinal(ByteBuffer.allocate(0), tmpOut);\n+                tmpOut.position(outOfs);\n+                output.put(tmpOut);\n@@ -169,1 +195,1 @@\n-    private static void doMultipart(int... chunkSizes) throws Exception {\n+    private void doMultipart(int... chunkSizes) throws Exception {\n@@ -211,1 +237,3 @@\n-        main(new TestCipherTextStealingMultipart(), args);\n+        try(TestCipherTextStealingMultipart testClass = new TestCipherTextStealingMultipart()) {\n+            main(testClass, args);\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCipherTextStealingMultipart.java","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.foreign.Arena;\n@@ -38,0 +39,2 @@\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n@@ -73,0 +76,11 @@\n+        testWithBuffers(bs, plainArr, c, key, plainArr2, ByteBuffer::allocate);\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            testWithBuffers(bs, plainArr, c, key, plainArr2,\n+                    (size) -> arena.allocate(size).asByteBuffer());\n+        }\n+    }\n+\n+    private static void testWithBuffers(int bs, byte[] plainArr, Cipher c, Key key,\n+                                        byte[] plainArr2, IntFunction<ByteBuffer> allocator) throws Exception {\n+        int off;\n@@ -74,1 +88,1 @@\n-        ByteBuffer plainBuf = ByteBuffer.allocate(bs);\n+        ByteBuffer plainBuf = allocator.apply(bs);\n@@ -79,1 +93,1 @@\n-        ByteBuffer encBuf = ByteBuffer.allocate(c.getOutputSize(plainBuf.limit()));\n+        ByteBuffer encBuf = allocator.apply(c.getOutputSize(plainBuf.limit()));\n@@ -89,1 +103,1 @@\n-        ByteBuffer plainBuf2 = ByteBuffer.allocate(c.getOutputSize(encBuf.limit()));\n+        ByteBuffer plainBuf2 = allocator.apply(c.getOutputSize(encBuf.limit()));\n@@ -100,1 +114,0 @@\n-\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestPaddingOOB.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.Arena;\n@@ -135,31 +136,74 @@\n-                             AlgorithmParameters params, int firstBlkSize,\n-                             byte[] in, byte[] answer) throws Exception {\n-        \/\/ test setup\n-        long startTime, endTime;\n-        cipher.init(mode, key, params);\n-        int outLen = cipher.getOutputSize(in.length);\n-        \/\/debugOut(\"Estimated output size = \" + outLen + \"\\n\");\n-\n-        \/\/ test data preparation\n-        ByteBuffer inBuf = ByteBuffer.allocate(in.length);\n-        inBuf.put(in);\n-        inBuf.position(0);\n-        ByteBuffer inDirectBuf = ByteBuffer.allocateDirect(in.length);\n-        inDirectBuf.put(in);\n-        inDirectBuf.position(0);\n-        ByteBuffer outBuf = ByteBuffer.allocate(outLen);\n-        ByteBuffer outDirectBuf = ByteBuffer.allocateDirect(outLen);\n-\n-        \/\/ test#1: byte[] in + byte[] out\n-        \/\/debugOut(\"Test#1:\\n\");\n-\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\n-        startTime = System.nanoTime();\n-        byte[] temp = cipher.update(in, 0, firstBlkSize);\n-        if (temp != null && temp.length > 0) {\n-            baos.write(temp, 0, temp.length);\n-        }\n-        temp = cipher.doFinal(in, firstBlkSize, in.length - firstBlkSize);\n-        if (temp != null && temp.length > 0) {\n-            baos.write(temp, 0, temp.length);\n+            AlgorithmParameters params, int firstBlkSize,\n+            byte[] in, byte[] answer) throws Exception {\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ test setup\n+            long startTime, endTime;\n+            cipher.init(mode, key, params);\n+            int outLen = cipher.getOutputSize(in.length);\n+            \/\/debugOut(\"Estimated output size = \" + outLen + \"\\n\");\n+\n+            \/\/ test data preparation\n+            ByteBuffer inBuf = ByteBuffer.allocate(in.length);\n+            inBuf.put(in);\n+            inBuf.position(0);\n+            ByteBuffer inDirectBuf = ByteBuffer.allocateDirect(in.length);\n+            inDirectBuf.put(in);\n+            inDirectBuf.position(0);\n+            ByteBuffer outBuf = ByteBuffer.allocate(outLen);\n+            ByteBuffer outDirectBuf = ByteBuffer.allocateDirect(outLen);\n+            ByteBuffer inMemSegment = arena.allocate(in.length).asByteBuffer();\n+            inMemSegment.put(in);\n+            inMemSegment.position(0);\n+            ByteBuffer outMemSegment = arena.allocate(outLen).asByteBuffer();\n+\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+            startTime = System.nanoTime();\n+            byte[] temp = cipher.update(in, 0, firstBlkSize);\n+            if (temp != null && temp.length > 0) {\n+                baos.write(temp, 0, temp.length);\n+            }\n+            temp = cipher.doFinal(in, firstBlkSize, in.length - firstBlkSize);\n+            if (temp != null && temp.length > 0) {\n+                baos.write(temp, 0, temp.length);\n+            }\n+            byte[] testOut1 = baos.toByteArray();\n+            endTime = System.nanoTime();\n+            perfOut(\"stream InBuf + stream OutBuf\", endTime - startTime);\n+            match(testOut1, answer);\n+\n+            \/\/ test#2: Non-direct Buffer in + non-direct Buffer out\n+            execTest(cipher, answer, inBuf, outBuf, \"non-direct InBuf + non-direct OutBuf\");\n+\n+            \/\/ test#3: Direct Buffer in + direc Buffer out\n+            execTest(cipher, answer, inDirectBuf, outDirectBuf, \"direct InBuf + direct OutBuf\");\n+\n+            inDirectBuf.position(0);\n+            outBuf.position(0);\n+\n+            execTest(cipher, answer, inDirectBuf, outBuf, \"direct InBuf + non-direct OutBuf\");\n+\n+            \/\/ test#5: Non-direct Buffer in + direct Buffer out\n+            inBuf.position(0);\n+            outDirectBuf.position(0);\n+            execTest(cipher, answer, inBuf, outDirectBuf, \"non-direct InBuf + direct OutBuf\");\n+\n+            outDirectBuf.position(0);\n+            execTest(cipher, answer, inMemSegment, outMemSegment, \"memsegment InBuf + memsegment OutBuf\");\n+\n+            inMemSegment.position(0);\n+            execTest(cipher, answer, inMemSegment, outDirectBuf, \"memsegment InBuf + direct outbuf\");\n+\n+            inMemSegment.position(0);\n+            outBuf.position(0);\n+            execTest(cipher, answer, inMemSegment, outBuf, \"memsegment InBuf + non-direct Outbuf\");\n+\n+            inBuf.position(0);\n+            outMemSegment.position(0);\n+            execTest(cipher, answer, inBuf, outMemSegment, \"non-direct InBuf + memsegment Outbuf\");\n+\n+            inDirectBuf.position(0);\n+            outMemSegment.position(0);\n+            execTest(cipher, answer, inDirectBuf, outMemSegment, \"direct InBuf + memsegment Outbuf\");\n+\n+            debugBuf.setLength(0);\n@@ -167,65 +211,10 @@\n-        byte[] testOut1 = baos.toByteArray();\n-        endTime = System.nanoTime();\n-        perfOut(\"stream InBuf + stream OutBuf\", endTime - startTime);\n-        match(testOut1, answer);\n-\n-        \/\/ test#2: Non-direct Buffer in + non-direct Buffer out\n-        \/\/debugOut(\"Test#2:\\n\");\n-        \/\/debugOut(\"inputBuf: \" + inBuf + \"\\n\");\n-        \/\/debugOut(\"outputBuf: \" + outBuf + \"\\n\");\n-\n-        startTime = System.nanoTime();\n-        cipher.update(inBuf, outBuf);\n-        cipher.doFinal(inBuf, outBuf);\n-        endTime = System.nanoTime();\n-        perfOut(\"non-direct InBuf + non-direct OutBuf\", endTime - startTime);\n-        match(outBuf, answer);\n-\n-        \/\/ test#3: Direct Buffer in + direc Buffer out\n-        \/\/debugOut(\"Test#3:\\n\");\n-        \/\/debugOut(\"(pre) inputBuf: \" + inDirectBuf + \"\\n\");\n-        \/\/debugOut(\"(pre) outputBuf: \" + outDirectBuf + \"\\n\");\n-\n-        startTime = System.nanoTime();\n-        cipher.update(inDirectBuf, outDirectBuf);\n-        cipher.doFinal(inDirectBuf, outDirectBuf);\n-        endTime = System.nanoTime();\n-        perfOut(\"direct InBuf + direct OutBuf\", endTime - startTime);\n-\n-        \/\/debugOut(\"(post) inputBuf: \" + inDirectBuf + \"\\n\");\n-        \/\/debugOut(\"(post) outputBuf: \" + outDirectBuf + \"\\n\");\n-        match(outDirectBuf, answer);\n-\n-        \/\/ test#4: Direct Buffer in + non-direct Buffer out\n-        \/\/debugOut(\"Test#4:\\n\");\n-        inDirectBuf.position(0);\n-        outBuf.position(0);\n-        \/\/debugOut(\"inputBuf: \" + inDirectBuf + \"\\n\");\n-        \/\/debugOut(\"outputBuf: \" + outBuf + \"\\n\");\n-\n-        startTime = System.nanoTime();\n-        cipher.update(inDirectBuf, outBuf);\n-        cipher.doFinal(inDirectBuf, outBuf);\n-        endTime = System.nanoTime();\n-        perfOut(\"direct InBuf + non-direct OutBuf\", endTime - startTime);\n-        match(outBuf, answer);\n-\n-        \/\/ test#5: Non-direct Buffer in + direct Buffer out\n-        \/\/debugOut(\"Test#5:\\n\");\n-        inBuf.position(0);\n-        outDirectBuf.position(0);\n-\n-        \/\/debugOut(\"(pre) inputBuf: \" + inBuf + \"\\n\");\n-        \/\/debugOut(\"(pre) outputBuf: \" + outDirectBuf + \"\\n\");\n-\n-        startTime = System.nanoTime();\n-        cipher.update(inBuf, outDirectBuf);\n-        cipher.doFinal(inBuf, outDirectBuf);\n-        endTime = System.nanoTime();\n-        perfOut(\"non-direct InBuf + direct OutBuf\", endTime - startTime);\n-\n-        \/\/debugOut(\"(post) inputBuf: \" + inBuf + \"\\n\");\n-        \/\/debugOut(\"(post) outputBuf: \" + outDirectBuf + \"\\n\");\n-        match(outDirectBuf, answer);\n-\n-        debugBuf.setLength(0);\n+    }\n+\n+    private static void execTest(Cipher cipher, byte[] answer,\n+                                 ByteBuffer inbuf, ByteBuffer outbuf, String message) throws Exception {\n+        long startTime = System.nanoTime();\n+        cipher.update(inbuf, outbuf);\n+        cipher.doFinal(inbuf, outbuf);\n+        long endTime = System.nanoTime();\n+        perfOut(message, endTime - startTime);\n+        match(outbuf, answer);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphers.java","additions":85,"deletions":96,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.foreign.Arena;\n@@ -126,80 +127,87 @@\n-        \/\/ test data preparation\n-        ByteBuffer inBuf = ByteBuffer.allocate(in.length);\n-        inBuf.put(in);\n-        inBuf.position(0);\n-        ByteBuffer inDirectBuf = ByteBuffer.allocateDirect(in.length);\n-        inDirectBuf.put(in);\n-        inDirectBuf.position(0);\n-        ByteBuffer outBuf = ByteBuffer.allocate(outLen);\n-        ByteBuffer outDirectBuf = ByteBuffer.allocateDirect(outLen);\n-\n-        \/\/ test#1: byte[] in + byte[] out\n-        debugBuf.append(\"Test#1:\\n\");\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        byte[] testOut1 = cipher.update(in, 0, 16);\n-        if (testOut1 != null) baos.write(testOut1, 0, testOut1.length);\n-        testOut1 = cipher.doFinal(in, 16, in.length-16);\n-        if (testOut1 != null) baos.write(testOut1, 0, testOut1.length);\n-        testOut1 = baos.toByteArray();\n-        match(testOut1, answer);\n-\n-        \/\/ test#2: Non-direct Buffer in + non-direct Buffer out\n-        debugBuf.append(\"Test#2:\\n\");\n-        debugBuf.append(\"inputBuf: \" + inBuf + \"\\n\");\n-        debugBuf.append(\"outputBuf: \" + outBuf + \"\\n\");\n-        cipher.update(inBuf, outBuf);\n-        cipher.doFinal(inBuf, outBuf);\n-        match(outBuf, answer);\n-\n-        \/\/ test#3: Direct Buffer in + direc Buffer out\n-        debugBuf.append(\"Test#3:\\n\");\n-        debugBuf.append(\"(pre) inputBuf: \" + inDirectBuf + \"\\n\");\n-        debugBuf.append(\"(pre) outputBuf: \" + outDirectBuf + \"\\n\");\n-        cipher.update(inDirectBuf, outDirectBuf);\n-        cipher.doFinal(inDirectBuf, outDirectBuf);\n-\n-        debugBuf.append(\"(post) inputBuf: \" + inDirectBuf + \"\\n\");\n-        debugBuf.append(\"(post) outputBuf: \" + outDirectBuf + \"\\n\");\n-        match(outDirectBuf, answer);\n-\n-        \/\/ test#4: Direct Buffer in + non-direct Buffer out\n-        debugBuf.append(\"Test#4:\\n\");\n-        inDirectBuf.position(0);\n-        outBuf.position(0);\n-        debugBuf.append(\"inputBuf: \" + inDirectBuf + \"\\n\");\n-        debugBuf.append(\"outputBuf: \" + outBuf + \"\\n\");\n-        cipher.update(inDirectBuf, outBuf);\n-        cipher.doFinal(inDirectBuf, outBuf);\n-        match(outBuf, answer);\n-\n-        \/\/ test#5: Non-direct Buffer in + direct Buffer out\n-        debugBuf.append(\"Test#5:\\n\");\n-        inBuf.position(0);\n-        outDirectBuf.position(0);\n-\n-        debugBuf.append(\"(pre) inputBuf: \" + inBuf + \"\\n\");\n-        debugBuf.append(\"(pre) outputBuf: \" + outDirectBuf + \"\\n\");\n-\n-        cipher.update(inBuf, outDirectBuf);\n-        cipher.doFinal(inBuf, outDirectBuf);\n-\n-        debugBuf.append(\"(post) inputBuf: \" + inBuf + \"\\n\");\n-        debugBuf.append(\"(post) outputBuf: \" + outDirectBuf + \"\\n\");\n-        match(outDirectBuf, answer);\n-\n-        \/\/ test#6: Streams\n-        debugBuf.append(\"Test#6: Streaming\\n\");\n-        outBuf.position(0);\n-        InputStream stream =\n-            new CipherInputStream(new ByteArrayInputStream(in), cipher);\n-        byte[] data = new byte[1024];\n-        int bytesRead = 0;\n-        try {\n-            while (bytesRead >= 0) {\n-                bytesRead = stream.read(data);\n-                if (bytesRead == -1)\n-                    break;\n-                debugBuf.append(\"bytesRead: \" + bytesRead);\n-                debugBuf.append(\"\\toutBuf.position(): \" + outBuf.position() +\n-                    \"\\n\");\n-                outBuf.put(data, 0 , bytesRead);\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ test data preparation\n+            ByteBuffer inBuf = ByteBuffer.allocate(in.length);\n+            inBuf.put(in);\n+            inBuf.position(0);\n+            ByteBuffer inDirectBuf = ByteBuffer.allocateDirect(in.length);\n+            inDirectBuf.put(in);\n+            inDirectBuf.position(0);\n+            ByteBuffer outBuf = ByteBuffer.allocate(outLen);\n+            ByteBuffer outDirectBuf = ByteBuffer.allocateDirect(outLen);\n+            ByteBuffer inMemBuf = arena.allocate(in.length).asByteBuffer();\n+            ByteBuffer outMemBuf = arena.allocate(outLen).asByteBuffer();\n+\n+            \/\/ test#1: byte[] in + byte[] out\n+            debugBuf.append(\"Test#1:\\n\");\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            byte[] testOut1 = cipher.update(in, 0, 16);\n+            if (testOut1 != null) baos.write(testOut1, 0, testOut1.length);\n+            testOut1 = cipher.doFinal(in, 16, in.length - 16);\n+            if (testOut1 != null) baos.write(testOut1, 0, testOut1.length);\n+            testOut1 = baos.toByteArray();\n+            match(testOut1, answer);\n+\n+            \/\/ test#2: Non-direct Buffer in + non-direct Buffer out\n+            debugBuf.append(\"Test#2:\\n\");\n+            debugBuf.append(\"inputBuf: \" + inBuf + \"\\n\");\n+            debugBuf.append(\"outputBuf: \" + outBuf + \"\\n\");\n+            cipher.update(inBuf, outBuf);\n+            cipher.doFinal(inBuf, outBuf);\n+            match(outBuf, answer);\n+\n+            \/\/ test#3: Direct Buffer in + direc Buffer out\n+            debugBuf.append(\"Test#3:\\n\");\n+            debugBuf.append(\"(pre) inputBuf: \" + inDirectBuf + \"\\n\");\n+            debugBuf.append(\"(pre) outputBuf: \" + outDirectBuf + \"\\n\");\n+            cipher.update(inDirectBuf, outDirectBuf);\n+            cipher.doFinal(inDirectBuf, outDirectBuf);\n+\n+            debugBuf.append(\"(post) inputBuf: \" + inDirectBuf + \"\\n\");\n+            debugBuf.append(\"(post) outputBuf: \" + outDirectBuf + \"\\n\");\n+            match(outDirectBuf, answer);\n+\n+            \/\/ test#4: Direct Buffer in + non-direct Buffer out\n+            debugBuf.append(\"Test#4:\\n\");\n+            inDirectBuf.position(0);\n+            outBuf.position(0);\n+            debugBuf.append(\"inputBuf: \" + inDirectBuf + \"\\n\");\n+            debugBuf.append(\"outputBuf: \" + outBuf + \"\\n\");\n+            cipher.update(inDirectBuf, outBuf);\n+            cipher.doFinal(inDirectBuf, outBuf);\n+            match(outBuf, answer);\n+\n+            \/\/ test#5: Non-direct Buffer in + direct Buffer out\n+            debugBuf.append(\"Test#5:\\n\");\n+            inBuf.position(0);\n+            outDirectBuf.position(0);\n+\n+            debugBuf.append(\"(pre) inputBuf: \" + inBuf + \"\\n\");\n+            debugBuf.append(\"(pre) outputBuf: \" + outDirectBuf + \"\\n\");\n+\n+            cipher.update(inBuf, outDirectBuf);\n+            cipher.doFinal(inBuf, outDirectBuf);\n+\n+            debugBuf.append(\"(post) inputBuf: \" + inBuf + \"\\n\");\n+            debugBuf.append(\"(post) outputBuf: \" + outDirectBuf + \"\\n\");\n+            match(outDirectBuf, answer);\n+\n+            \/\/ test#6: Streams\n+            debugBuf.append(\"Test#6: Streaming\\n\");\n+            outBuf.position(0);\n+            InputStream stream =\n+                    new CipherInputStream(new ByteArrayInputStream(in), cipher);\n+            byte[] data = new byte[1024];\n+            int bytesRead = 0;\n+            try {\n+                while (bytesRead >= 0) {\n+                    bytesRead = stream.read(data);\n+                    if (bytesRead == -1)\n+                        break;\n+                    debugBuf.append(\"bytesRead: \" + bytesRead);\n+                    debugBuf.append(\"\\toutBuf.position(): \" + outBuf.position() +\n+                            \"\\n\");\n+                    outBuf.put(data, 0, bytesRead);\n+                }\n+            } catch (Exception ex) {\n+                debugBuf.append(\"Caught Exception during stream reading\\n\");\n+                throw ex;\n@@ -207,3 +215,1 @@\n-        } catch (Exception ex) {\n-            debugBuf.append(\"Caught Exception during stream reading\\n\");\n-            throw ex;\n+            match(outBuf, answer);\n@@ -211,2 +217,0 @@\n-        match(outBuf, answer);\n-\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphersNoPad.java","additions":89,"deletions":85,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.lang.foreign.Arena;\n@@ -36,1 +37,2 @@\n-import java.security.*;\n+import java.security.MessageDigest;\n+import java.security.Provider;\n@@ -99,0 +101,11 @@\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            ByteBuffer b5 = arena.allocate(n).asByteBuffer();\n+            b5.put(data);\n+            b5.clear();\n+            byte[] d5 = digest(md, b5);\n+            if (Arrays.equals(d1, d5) == false) {\n+                throw new Exception(\"Test 4 failed\");\n+            }\n+        }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/MessageDigest\/ByteBuffers.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.lang.foreign.Arena;\n@@ -87,0 +88,8 @@\n+        \/\/ test 4: ByteBuffer from MemorySegment\n+        try (Arena arena = Arena.ofConfined()) {\n+            ByteBuffer b5 = arena.allocate(t.length).asByteBuffer();\n+            b5.put(t);\n+            b5.clear();\n+            verify(sig, signature, b5, random);\n+        }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/ByteBuffers.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"}]}