{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,5 @@\n-import java.util.*;\n-import java.nio.*;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.nio.ByteBuffer;\n@@ -80,0 +83,12 @@\n+\n+        \/\/ test 4: ByteBuffer backed by a MemorySegment\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(t.length);\n+            ByteBuffer b5 = segment.asByteBuffer();\n+            b5.put(t);\n+            b5.clear();\n+            byte [] d5 = digest(md, b5, random);\n+            if (Arrays.equals(d1, d5) == false) {\n+                throw new Exception(\"Test 4 failed\");\n+            }\n+        }\n","filename":"test\/jdk\/java\/security\/MessageDigest\/ByteBuffers.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,4 +34,9 @@\n-import java.util.*;\n-import java.nio.*;\n-\n-import java.security.*;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.Signature;\n+import java.util.Random;\n+import java.nio.ByteBuffer;\n@@ -83,0 +88,9 @@\n+        \/\/ test 4: ByteBuffer with backing MemorySegment\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(t.length);\n+            ByteBuffer b5 = segment.asByteBuffer();\n+            b5.put(t);\n+            b5.clear();\n+            verify(sig, signature, b5, random);\n+        }\n+\n","filename":"test\/jdk\/java\/security\/Signature\/ByteBuffers.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,4 @@\n-import java.util.*;\n-import java.nio.*;\n+import java.lang.foreign.Arena;\n+import java.util.Random;\n+import java.util.Arrays;\n+import java.nio.ByteBuffer;\n@@ -37,1 +39,2 @@\n-import java.security.*;\n+import java.security.Provider;\n+import java.security.Security;\n@@ -39,2 +42,3 @@\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -63,6 +67,7 @@\n-        \/\/ create ByteBuffers for input (i1, i2, i3) and fill them\n-        ByteBuffer i0 = ByteBuffer.allocate(n + 256);\n-        i0.position(random.nextInt(256));\n-        i0.limit(i0.position() + n);\n-        ByteBuffer i1 = i0.slice();\n-        i1.put(t);\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ create ByteBuffers for input (i1, i2, i3) and fill them\n+            ByteBuffer i0 = ByteBuffer.allocate(n + 256);\n+            i0.position(random.nextInt(256));\n+            i0.limit(i0.position() + n);\n+            ByteBuffer i1 = i0.slice();\n+            i1.put(t);\n@@ -70,2 +75,2 @@\n-        ByteBuffer i2 = ByteBuffer.allocateDirect(t.length);\n-        i2.put(t);\n+            ByteBuffer i2 = ByteBuffer.allocateDirect(t.length);\n+            i2.put(t);\n@@ -73,2 +78,2 @@\n-        i1.clear();\n-        ByteBuffer i3 = i1.asReadOnlyBuffer();\n+            i1.clear();\n+            ByteBuffer i3 = i1.asReadOnlyBuffer();\n@@ -76,4 +81,3 @@\n-        ByteBuffer o0 = ByteBuffer.allocate(n + 512);\n-        o0.position(random.nextInt(256));\n-        o0.limit(o0.position() + n + 256);\n-        ByteBuffer o1 = o0.slice();\n+            ByteBuffer i4 = arena.allocate(t.length).asByteBuffer();\n+            i4.put(t);\n+            i4.clear();\n@@ -81,1 +85,4 @@\n-        ByteBuffer o2 = ByteBuffer.allocateDirect(t.length + 256);\n+            ByteBuffer o0 = ByteBuffer.allocate(n + 512);\n+            o0.position(random.nextInt(256));\n+            o0.limit(o0.position() + n + 256);\n+            ByteBuffer o1 = o0.slice();\n@@ -83,6 +90,19 @@\n-        crypt(cipher, i1, o1, outBytes, random);\n-        crypt(cipher, i2, o1, outBytes, random);\n-        crypt(cipher, i3, o1, outBytes, random);\n-        crypt(cipher, i1, o2, outBytes, random);\n-        crypt(cipher, i2, o2, outBytes, random);\n-        crypt(cipher, i3, o2, outBytes, random);\n+            ByteBuffer o2 = ByteBuffer.allocateDirect(t.length + 256);\n+\n+            ByteBuffer o3 = arena.allocate(t.length).asByteBuffer();\n+\n+            crypt(cipher, i1, o1, outBytes, random);\n+            crypt(cipher, i2, o1, outBytes, random);\n+            crypt(cipher, i3, o1, outBytes, random);\n+            crypt(cipher, i4, o1, outBytes, random);\n+\n+            crypt(cipher, i1, o2, outBytes, random);\n+            crypt(cipher, i2, o2, outBytes, random);\n+            crypt(cipher, i3, o2, outBytes, random);\n+            crypt(cipher, i4, o2, outBytes, random);\n+\n+            crypt(cipher, i1, o3, outBytes, random);\n+            crypt(cipher, i2, o3, outBytes, random);\n+            crypt(cipher, i3, o3, outBytes, random);\n+            crypt(cipher, i4, o3, outBytes, random);\n+        }\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/ByteBuffers.java","additions":47,"deletions":27,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,3 @@\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.lang.foreign.Arena;\n@@ -71,0 +72,7 @@\n+        try(Arena arena = Arena.ofConfined()) {\n+            bb = arena.allocate(bytes.length).asByteBuffer();\n+            bb.put(bytes);\n+            bb.clear();\n+            updateAADPass(bb);\n+        }\n+\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/GCMAPI.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.lang.foreign.Arena;\n@@ -51,1 +52,1 @@\n-    private static final boolean DEBUG = false;\n+    private static final boolean DEBUG = Boolean.getBoolean(\"test.debug\");\n@@ -68,1 +69,1 @@\n-        ALLOCATE, DIRECT, WRAP;\n+        ALLOCATE, DIRECT, WRAP, MEMORY_SEGMENT;\n@@ -72,1 +73,0 @@\n-\n@@ -107,1 +107,9 @@\n-        \/\/ Test#3: against ByteBuffer wrapping existing array\n+        \/\/ Test#3: against ByteBuffer backed by MemorySegment\n+        try (Arena arena = Arena.ofConfined()) {\n+            prepareBuffers(BufferType.MEMORY_SEGMENT, useRO, buf.length,\n+                    buf, 0, PLAINTEXT_SIZE, offset, arena);\n+            runTest(offset, expectedPT, expectedCT);\n+            System.out.println(\"\\tMEMSEGMENT: passed\");\n+        }\n+\n+        \/\/ Test#4: against ByteBuffer wrapping existing array\n@@ -120,0 +128,6 @@\n+        prepareBuffers(type, useRO, bufSz, in, inOfs, inLen, outOfs, null);\n+    }\n+\n+    private static void prepareBuffers(BufferType type,\n+                                       boolean useRO, int bufSz, byte[] in, int inOfs, int inLen,\n+                                       int outOfs, Arena arena) {\n@@ -145,0 +159,8 @@\n+            case MEMORY_SEGMENT:\n+                outBuf = arena.allocate(bufSz).asByteBuffer();\n+                inBuf = outBuf.slice();\n+                inBuf.put(in, inOfs, inLen);\n+                inBuf.rewind();\n+                inBuf.limit(inLen);\n+                outBuf.position(outOfs);\n+                break;\n@@ -150,0 +172,1 @@\n+            System.out.println(\"Buffer type: \" + type);\n","filename":"test\/jdk\/javax\/crypto\/CipherSpi\/CipherByteBufferOverwriteTest.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.lang.foreign.Arena;\n@@ -77,23 +78,32 @@\n-        for (int size = 0; size <= testSizes; size++) {\n-            boolean output = (size % outputFrequency) == 0;\n-            if (output) {\n-                System.out.print(\"\\nTesting buffer size: \" + size + \":\");\n-            }\n-\n-            int outSize = cipher.getOutputSize(size);\n-\n-            try {\n-                encrypt(cipher, size,\n-                        ByteBuffer.allocate(size),\n-                        ByteBuffer.allocate(outSize),\n-                        ByteBuffer.allocateDirect(size),\n-                        ByteBuffer.allocateDirect(outSize),\n-                        output);\n-            } catch (Exception e) {\n-                System.out.print(\"\\n    Failed with size \" + size);\n-                failedOnce = true;\n-                failedReason = e;\n-\n-                \/\/ If we got an exception, let's be safe for future\n-                \/\/ testing and reset the cipher to a known good state.\n-                cipher.init(Cipher.ENCRYPT_MODE, key);\n+        try (Arena arena = Arena.ofConfined()) {\n+            for (int size = 0; size <= testSizes; size++) {\n+                boolean output = (size % outputFrequency) == 0;\n+                if (output) {\n+                    System.out.print(\"\\nTesting buffer size: \" + size + \":\");\n+                }\n+\n+                int outSize = cipher.getOutputSize(size);\n+\n+                try {\n+                    encrypt(cipher, size,\n+                            ByteBuffer.allocate(size),\n+                            ByteBuffer.allocate(outSize),\n+                            ByteBuffer.allocateDirect(size),\n+                            ByteBuffer.allocateDirect(outSize),\n+                            output);\n+\n+                    encrypt(cipher, size,\n+                            ByteBuffer.allocate(size),\n+                            ByteBuffer.allocate(outSize),\n+                            arena.allocate(size).asByteBuffer(),\n+                            arena.allocate(outSize).asByteBuffer(),\n+                            output);\n+                } catch (Exception e) {\n+                    System.out.print(\"\\n    Failed with size \" + size);\n+                    failedOnce = true;\n+                    failedReason = e;\n+\n+                    \/\/ If we got an exception, let's be safe for future\n+                    \/\/ testing and reset the cipher to a known good state.\n+                    cipher.init(Cipher.ENCRYPT_MODE, key);\n+                }\n@@ -105,0 +115,1 @@\n+\n","filename":"test\/jdk\/javax\/crypto\/CipherSpi\/DirectBBRemaining.java","additions":35,"deletions":24,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.lang.foreign.Arena;\n@@ -80,2 +81,3 @@\n-        for (int t = 1; t <= multiples; t++) {\n-            int size = t * dataSize;\n+        try (Arena arena = Arena.ofConfined()) {\n+            for (int t = 1; t <= multiples; t++) {\n+                int size = t * dataSize;\n@@ -83,1 +85,1 @@\n-            System.out.println(\"\\nTesting data size: \" + size);\n+                System.out.println(\"\\nTesting data size: \" + size);\n@@ -85,10 +87,17 @@\n-            try {\n-                decrypt(cipher, key, s, dataChunk, t,\n-                        ByteBuffer.allocate(dataSize),\n-                        ByteBuffer.allocate(size),\n-                        ByteBuffer.allocateDirect(dataSize),\n-                        ByteBuffer.allocateDirect(size));\n-            } catch (Exception e) {\n-                System.out.println(\"\\tFailed with data size \" + size);\n-                failedOnce = true;\n-                failedReason = e;\n+                try {\n+                    decrypt(cipher, key, s, dataChunk, t,\n+                            ByteBuffer.allocate(dataSize),\n+                            ByteBuffer.allocate(size),\n+                            ByteBuffer.allocateDirect(dataSize),\n+                            ByteBuffer.allocateDirect(size));\n+\n+                    decrypt(cipher, key, s, dataChunk, t,\n+                            ByteBuffer.allocate(dataSize),\n+                            ByteBuffer.allocate(size),\n+                            arena.allocate(dataSize).asByteBuffer(),\n+                            arena.allocate(size).asByteBuffer());\n+                } catch (Exception e) {\n+                    System.out.println(\"\\tFailed with data size \" + size);\n+                    failedOnce = true;\n+                    failedReason = e;\n+                }\n","filename":"test\/jdk\/javax\/crypto\/CipherSpi\/TestGCMWithByteBuffer.java","additions":23,"deletions":14,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,4 @@\n-import java.util.*;\n-import java.nio.*;\n+import java.lang.foreign.Arena;\n+import java.util.Random;\n+import java.util.Arrays;\n+import java.nio.ByteBuffer;\n@@ -37,1 +39,2 @@\n-import java.security.*;\n+import java.security.Provider;\n+import java.security.Security;\n@@ -80,0 +83,8 @@\n+        \/\/ test 4: ByteBuffer from MemorySegment\n+        try (Arena arena = Arena.ofConfined()) {\n+            ByteBuffer b5 = arena.allocate(t.length).asByteBuffer();\n+            b5.put(t);\n+            b5.clear();\n+            verify(mac, macValue, b5, random);\n+        }\n+\n","filename":"test\/jdk\/javax\/crypto\/Mac\/ByteBuffers.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.Arena;\n@@ -44,1 +45,1 @@\n-public class TestCipherTextStealingMultipart extends PKCS11Test {\n+public class TestCipherTextStealingMultipart extends PKCS11Test implements AutoCloseable {\n@@ -57,0 +58,10 @@\n+    private final Arena arena;\n+\n+    public TestCipherTextStealingMultipart() {\n+        arena = Arena.ofConfined();\n+    }\n+\n+    public void close() {\n+        arena.close();\n+    }\n+\n@@ -108,1 +119,1 @@\n-    private enum OutputType {BYTE_ARRAY, DIRECT_BYTE_BUFFER}\n+    private enum OutputType {BYTE_ARRAY, DIRECT_BYTE_BUFFER, MEMSEGMENT_BYTE_BUFFER}\n@@ -126,0 +137,1 @@\n+                case MEMSEGMENT_BYTE_BUFFER -> \"MemorySegment ByteBuffer\";\n@@ -132,1 +144,1 @@\n-    private static ByteBuffer encryptOrDecryptMultipart(int operation,\n+    private ByteBuffer encryptOrDecryptMultipart(int operation,\n@@ -164,0 +176,14 @@\n+            } case MEMSEGMENT_BYTE_BUFFER -> {\n+                output = arena.allocate(totalLength).asByteBuffer();\n+                for (byte[] inputChunk : inputChunks) {\n+                    output.put(cipher.update(inputChunk));\n+                }\n+                \/\/ Check that the output array offset does not affect the\n+                \/\/ penultimate block length calculation.\n+                ByteBuffer tmpOut =arena.allocate(\n+                        cipher.getOutputSize(0) + outOfs)\n+                        .asByteBuffer();\n+                tmpOut.position(outOfs);\n+                cipher.doFinal(ByteBuffer.allocate(0), tmpOut);\n+                tmpOut.position(outOfs);\n+                output.put(tmpOut);\n@@ -169,1 +195,1 @@\n-    private static void doMultipart(int... chunkSizes) throws Exception {\n+    private void doMultipart(int... chunkSizes) throws Exception {\n@@ -211,1 +237,3 @@\n-        main(new TestCipherTextStealingMultipart(), args);\n+        try(TestCipherTextStealingMultipart testClass = new TestCipherTextStealingMultipart()) {\n+            main(testClass, args);\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCipherTextStealingMultipart.java","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.foreign.Arena;\n@@ -38,0 +39,2 @@\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n@@ -73,0 +76,11 @@\n+        testWithBuffers(bs, plainArr, c, key, plainArr2, ByteBuffer::allocate);\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            testWithBuffers(bs, plainArr, c, key, plainArr2,\n+                    (size) -> arena.allocate(size).asByteBuffer());\n+        }\n+    }\n+\n+    private static void testWithBuffers(int bs, byte[] plainArr, Cipher c, Key key,\n+                                        byte[] plainArr2, IntFunction<ByteBuffer> allocator) throws Exception {\n+        int off;\n@@ -74,1 +88,1 @@\n-        ByteBuffer plainBuf = ByteBuffer.allocate(bs);\n+        ByteBuffer plainBuf = allocator.apply(bs);\n@@ -79,1 +93,1 @@\n-        ByteBuffer encBuf = ByteBuffer.allocate(c.getOutputSize(plainBuf.limit()));\n+        ByteBuffer encBuf = allocator.apply(c.getOutputSize(plainBuf.limit()));\n@@ -89,1 +103,1 @@\n-        ByteBuffer plainBuf2 = ByteBuffer.allocate(c.getOutputSize(encBuf.limit()));\n+        ByteBuffer plainBuf2 = allocator.apply(c.getOutputSize(encBuf.limit()));\n@@ -100,1 +114,0 @@\n-\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestPaddingOOB.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.Arena;\n@@ -135,31 +136,74 @@\n-                             AlgorithmParameters params, int firstBlkSize,\n-                             byte[] in, byte[] answer) throws Exception {\n-        \/\/ test setup\n-        long startTime, endTime;\n-        cipher.init(mode, key, params);\n-        int outLen = cipher.getOutputSize(in.length);\n-        \/\/debugOut(\"Estimated output size = \" + outLen + \"\\n\");\n-\n-        \/\/ test data preparation\n-        ByteBuffer inBuf = ByteBuffer.allocate(in.length);\n-        inBuf.put(in);\n-        inBuf.position(0);\n-        ByteBuffer inDirectBuf = ByteBuffer.allocateDirect(in.length);\n-        inDirectBuf.put(in);\n-        inDirectBuf.position(0);\n-        ByteBuffer outBuf = ByteBuffer.allocate(outLen);\n-        ByteBuffer outDirectBuf = ByteBuffer.allocateDirect(outLen);\n-\n-        \/\/ test#1: byte[] in + byte[] out\n-        \/\/debugOut(\"Test#1:\\n\");\n-\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\n-        startTime = System.nanoTime();\n-        byte[] temp = cipher.update(in, 0, firstBlkSize);\n-        if (temp != null && temp.length > 0) {\n-            baos.write(temp, 0, temp.length);\n-        }\n-        temp = cipher.doFinal(in, firstBlkSize, in.length - firstBlkSize);\n-        if (temp != null && temp.length > 0) {\n-            baos.write(temp, 0, temp.length);\n+            AlgorithmParameters params, int firstBlkSize,\n+            byte[] in, byte[] answer) throws Exception {\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ test setup\n+            long startTime, endTime;\n+            cipher.init(mode, key, params);\n+            int outLen = cipher.getOutputSize(in.length);\n+            \/\/debugOut(\"Estimated output size = \" + outLen + \"\\n\");\n+\n+            \/\/ test data preparation\n+            ByteBuffer inBuf = ByteBuffer.allocate(in.length);\n+            inBuf.put(in);\n+            inBuf.position(0);\n+            ByteBuffer inDirectBuf = ByteBuffer.allocateDirect(in.length);\n+            inDirectBuf.put(in);\n+            inDirectBuf.position(0);\n+            ByteBuffer outBuf = ByteBuffer.allocate(outLen);\n+            ByteBuffer outDirectBuf = ByteBuffer.allocateDirect(outLen);\n+            ByteBuffer inMemSegment = arena.allocate(in.length).asByteBuffer();\n+            inMemSegment.put(in);\n+            inMemSegment.position(0);\n+            ByteBuffer outMemSegment = arena.allocate(outLen).asByteBuffer();\n+\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+            startTime = System.nanoTime();\n+            byte[] temp = cipher.update(in, 0, firstBlkSize);\n+            if (temp != null && temp.length > 0) {\n+                baos.write(temp, 0, temp.length);\n+            }\n+            temp = cipher.doFinal(in, firstBlkSize, in.length - firstBlkSize);\n+            if (temp != null && temp.length > 0) {\n+                baos.write(temp, 0, temp.length);\n+            }\n+            byte[] testOut1 = baos.toByteArray();\n+            endTime = System.nanoTime();\n+            perfOut(\"stream InBuf + stream OutBuf\", endTime - startTime);\n+            match(testOut1, answer);\n+\n+            \/\/ test#2: Non-direct Buffer in + non-direct Buffer out\n+            execTest(cipher, answer, inBuf, outBuf, \"non-direct InBuf + non-direct OutBuf\");\n+\n+            \/\/ test#3: Direct Buffer in + direc Buffer out\n+            execTest(cipher, answer, inDirectBuf, outDirectBuf, \"direct InBuf + direct OutBuf\");\n+\n+            inDirectBuf.position(0);\n+            outBuf.position(0);\n+\n+            execTest(cipher, answer, inDirectBuf, outBuf, \"direct InBuf + non-direct OutBuf\");\n+\n+            \/\/ test#5: Non-direct Buffer in + direct Buffer out\n+            inBuf.position(0);\n+            outDirectBuf.position(0);\n+            execTest(cipher, answer, inBuf, outDirectBuf, \"non-direct InBuf + direct OutBuf\");\n+\n+            outDirectBuf.position(0);\n+            execTest(cipher, answer, inMemSegment, outMemSegment, \"memsegment InBuf + memsegment OutBuf\");\n+\n+            inMemSegment.position(0);\n+            execTest(cipher, answer, inMemSegment, outDirectBuf, \"memsegment InBuf + direct outbuf\");\n+\n+            inMemSegment.position(0);\n+            outBuf.position(0);\n+            execTest(cipher, answer, inMemSegment, outBuf, \"memsegment InBuf + non-direct Outbuf\");\n+\n+            inBuf.position(0);\n+            outMemSegment.position(0);\n+            execTest(cipher, answer, inBuf, outMemSegment, \"non-direct InBuf + memsegment Outbuf\");\n+\n+            inDirectBuf.position(0);\n+            outMemSegment.position(0);\n+            execTest(cipher, answer, inDirectBuf, outMemSegment, \"direct InBuf + memsegment Outbuf\");\n+\n+            debugBuf.setLength(0);\n@@ -167,65 +211,10 @@\n-        byte[] testOut1 = baos.toByteArray();\n-        endTime = System.nanoTime();\n-        perfOut(\"stream InBuf + stream OutBuf\", endTime - startTime);\n-        match(testOut1, answer);\n-\n-        \/\/ test#2: Non-direct Buffer in + non-direct Buffer out\n-        \/\/debugOut(\"Test#2:\\n\");\n-        \/\/debugOut(\"inputBuf: \" + inBuf + \"\\n\");\n-        \/\/debugOut(\"outputBuf: \" + outBuf + \"\\n\");\n-\n-        startTime = System.nanoTime();\n-        cipher.update(inBuf, outBuf);\n-        cipher.doFinal(inBuf, outBuf);\n-        endTime = System.nanoTime();\n-        perfOut(\"non-direct InBuf + non-direct OutBuf\", endTime - startTime);\n-        match(outBuf, answer);\n-\n-        \/\/ test#3: Direct Buffer in + direc Buffer out\n-        \/\/debugOut(\"Test#3:\\n\");\n-        \/\/debugOut(\"(pre) inputBuf: \" + inDirectBuf + \"\\n\");\n-        \/\/debugOut(\"(pre) outputBuf: \" + outDirectBuf + \"\\n\");\n-\n-        startTime = System.nanoTime();\n-        cipher.update(inDirectBuf, outDirectBuf);\n-        cipher.doFinal(inDirectBuf, outDirectBuf);\n-        endTime = System.nanoTime();\n-        perfOut(\"direct InBuf + direct OutBuf\", endTime - startTime);\n-\n-        \/\/debugOut(\"(post) inputBuf: \" + inDirectBuf + \"\\n\");\n-        \/\/debugOut(\"(post) outputBuf: \" + outDirectBuf + \"\\n\");\n-        match(outDirectBuf, answer);\n-\n-        \/\/ test#4: Direct Buffer in + non-direct Buffer out\n-        \/\/debugOut(\"Test#4:\\n\");\n-        inDirectBuf.position(0);\n-        outBuf.position(0);\n-        \/\/debugOut(\"inputBuf: \" + inDirectBuf + \"\\n\");\n-        \/\/debugOut(\"outputBuf: \" + outBuf + \"\\n\");\n-\n-        startTime = System.nanoTime();\n-        cipher.update(inDirectBuf, outBuf);\n-        cipher.doFinal(inDirectBuf, outBuf);\n-        endTime = System.nanoTime();\n-        perfOut(\"direct InBuf + non-direct OutBuf\", endTime - startTime);\n-        match(outBuf, answer);\n-\n-        \/\/ test#5: Non-direct Buffer in + direct Buffer out\n-        \/\/debugOut(\"Test#5:\\n\");\n-        inBuf.position(0);\n-        outDirectBuf.position(0);\n-\n-        \/\/debugOut(\"(pre) inputBuf: \" + inBuf + \"\\n\");\n-        \/\/debugOut(\"(pre) outputBuf: \" + outDirectBuf + \"\\n\");\n-\n-        startTime = System.nanoTime();\n-        cipher.update(inBuf, outDirectBuf);\n-        cipher.doFinal(inBuf, outDirectBuf);\n-        endTime = System.nanoTime();\n-        perfOut(\"non-direct InBuf + direct OutBuf\", endTime - startTime);\n-\n-        \/\/debugOut(\"(post) inputBuf: \" + inBuf + \"\\n\");\n-        \/\/debugOut(\"(post) outputBuf: \" + outDirectBuf + \"\\n\");\n-        match(outDirectBuf, answer);\n-\n-        debugBuf.setLength(0);\n+    }\n+\n+    private static void execTest(Cipher cipher, byte[] answer,\n+                                 ByteBuffer inbuf, ByteBuffer outbuf, String message) throws Exception {\n+        long startTime = System.nanoTime();\n+        cipher.update(inbuf, outbuf);\n+        cipher.doFinal(inbuf, outbuf);\n+        long endTime = System.nanoTime();\n+        perfOut(message, endTime - startTime);\n+        match(outbuf, answer);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphers.java","additions":85,"deletions":96,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.foreign.Arena;\n@@ -126,80 +127,87 @@\n-        \/\/ test data preparation\n-        ByteBuffer inBuf = ByteBuffer.allocate(in.length);\n-        inBuf.put(in);\n-        inBuf.position(0);\n-        ByteBuffer inDirectBuf = ByteBuffer.allocateDirect(in.length);\n-        inDirectBuf.put(in);\n-        inDirectBuf.position(0);\n-        ByteBuffer outBuf = ByteBuffer.allocate(outLen);\n-        ByteBuffer outDirectBuf = ByteBuffer.allocateDirect(outLen);\n-\n-        \/\/ test#1: byte[] in + byte[] out\n-        debugBuf.append(\"Test#1:\\n\");\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        byte[] testOut1 = cipher.update(in, 0, 16);\n-        if (testOut1 != null) baos.write(testOut1, 0, testOut1.length);\n-        testOut1 = cipher.doFinal(in, 16, in.length-16);\n-        if (testOut1 != null) baos.write(testOut1, 0, testOut1.length);\n-        testOut1 = baos.toByteArray();\n-        match(testOut1, answer);\n-\n-        \/\/ test#2: Non-direct Buffer in + non-direct Buffer out\n-        debugBuf.append(\"Test#2:\\n\");\n-        debugBuf.append(\"inputBuf: \" + inBuf + \"\\n\");\n-        debugBuf.append(\"outputBuf: \" + outBuf + \"\\n\");\n-        cipher.update(inBuf, outBuf);\n-        cipher.doFinal(inBuf, outBuf);\n-        match(outBuf, answer);\n-\n-        \/\/ test#3: Direct Buffer in + direc Buffer out\n-        debugBuf.append(\"Test#3:\\n\");\n-        debugBuf.append(\"(pre) inputBuf: \" + inDirectBuf + \"\\n\");\n-        debugBuf.append(\"(pre) outputBuf: \" + outDirectBuf + \"\\n\");\n-        cipher.update(inDirectBuf, outDirectBuf);\n-        cipher.doFinal(inDirectBuf, outDirectBuf);\n-\n-        debugBuf.append(\"(post) inputBuf: \" + inDirectBuf + \"\\n\");\n-        debugBuf.append(\"(post) outputBuf: \" + outDirectBuf + \"\\n\");\n-        match(outDirectBuf, answer);\n-\n-        \/\/ test#4: Direct Buffer in + non-direct Buffer out\n-        debugBuf.append(\"Test#4:\\n\");\n-        inDirectBuf.position(0);\n-        outBuf.position(0);\n-        debugBuf.append(\"inputBuf: \" + inDirectBuf + \"\\n\");\n-        debugBuf.append(\"outputBuf: \" + outBuf + \"\\n\");\n-        cipher.update(inDirectBuf, outBuf);\n-        cipher.doFinal(inDirectBuf, outBuf);\n-        match(outBuf, answer);\n-\n-        \/\/ test#5: Non-direct Buffer in + direct Buffer out\n-        debugBuf.append(\"Test#5:\\n\");\n-        inBuf.position(0);\n-        outDirectBuf.position(0);\n-\n-        debugBuf.append(\"(pre) inputBuf: \" + inBuf + \"\\n\");\n-        debugBuf.append(\"(pre) outputBuf: \" + outDirectBuf + \"\\n\");\n-\n-        cipher.update(inBuf, outDirectBuf);\n-        cipher.doFinal(inBuf, outDirectBuf);\n-\n-        debugBuf.append(\"(post) inputBuf: \" + inBuf + \"\\n\");\n-        debugBuf.append(\"(post) outputBuf: \" + outDirectBuf + \"\\n\");\n-        match(outDirectBuf, answer);\n-\n-        \/\/ test#6: Streams\n-        debugBuf.append(\"Test#6: Streaming\\n\");\n-        outBuf.position(0);\n-        InputStream stream =\n-            new CipherInputStream(new ByteArrayInputStream(in), cipher);\n-        byte[] data = new byte[1024];\n-        int bytesRead = 0;\n-        try {\n-            while (bytesRead >= 0) {\n-                bytesRead = stream.read(data);\n-                if (bytesRead == -1)\n-                    break;\n-                debugBuf.append(\"bytesRead: \" + bytesRead);\n-                debugBuf.append(\"\\toutBuf.position(): \" + outBuf.position() +\n-                    \"\\n\");\n-                outBuf.put(data, 0 , bytesRead);\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ test data preparation\n+            ByteBuffer inBuf = ByteBuffer.allocate(in.length);\n+            inBuf.put(in);\n+            inBuf.position(0);\n+            ByteBuffer inDirectBuf = ByteBuffer.allocateDirect(in.length);\n+            inDirectBuf.put(in);\n+            inDirectBuf.position(0);\n+            ByteBuffer outBuf = ByteBuffer.allocate(outLen);\n+            ByteBuffer outDirectBuf = ByteBuffer.allocateDirect(outLen);\n+            ByteBuffer inMemBuf = arena.allocate(in.length).asByteBuffer();\n+            ByteBuffer outMemBuf = arena.allocate(outLen).asByteBuffer();\n+\n+            \/\/ test#1: byte[] in + byte[] out\n+            debugBuf.append(\"Test#1:\\n\");\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            byte[] testOut1 = cipher.update(in, 0, 16);\n+            if (testOut1 != null) baos.write(testOut1, 0, testOut1.length);\n+            testOut1 = cipher.doFinal(in, 16, in.length - 16);\n+            if (testOut1 != null) baos.write(testOut1, 0, testOut1.length);\n+            testOut1 = baos.toByteArray();\n+            match(testOut1, answer);\n+\n+            \/\/ test#2: Non-direct Buffer in + non-direct Buffer out\n+            debugBuf.append(\"Test#2:\\n\");\n+            debugBuf.append(\"inputBuf: \" + inBuf + \"\\n\");\n+            debugBuf.append(\"outputBuf: \" + outBuf + \"\\n\");\n+            cipher.update(inBuf, outBuf);\n+            cipher.doFinal(inBuf, outBuf);\n+            match(outBuf, answer);\n+\n+            \/\/ test#3: Direct Buffer in + direc Buffer out\n+            debugBuf.append(\"Test#3:\\n\");\n+            debugBuf.append(\"(pre) inputBuf: \" + inDirectBuf + \"\\n\");\n+            debugBuf.append(\"(pre) outputBuf: \" + outDirectBuf + \"\\n\");\n+            cipher.update(inDirectBuf, outDirectBuf);\n+            cipher.doFinal(inDirectBuf, outDirectBuf);\n+\n+            debugBuf.append(\"(post) inputBuf: \" + inDirectBuf + \"\\n\");\n+            debugBuf.append(\"(post) outputBuf: \" + outDirectBuf + \"\\n\");\n+            match(outDirectBuf, answer);\n+\n+            \/\/ test#4: Direct Buffer in + non-direct Buffer out\n+            debugBuf.append(\"Test#4:\\n\");\n+            inDirectBuf.position(0);\n+            outBuf.position(0);\n+            debugBuf.append(\"inputBuf: \" + inDirectBuf + \"\\n\");\n+            debugBuf.append(\"outputBuf: \" + outBuf + \"\\n\");\n+            cipher.update(inDirectBuf, outBuf);\n+            cipher.doFinal(inDirectBuf, outBuf);\n+            match(outBuf, answer);\n+\n+            \/\/ test#5: Non-direct Buffer in + direct Buffer out\n+            debugBuf.append(\"Test#5:\\n\");\n+            inBuf.position(0);\n+            outDirectBuf.position(0);\n+\n+            debugBuf.append(\"(pre) inputBuf: \" + inBuf + \"\\n\");\n+            debugBuf.append(\"(pre) outputBuf: \" + outDirectBuf + \"\\n\");\n+\n+            cipher.update(inBuf, outDirectBuf);\n+            cipher.doFinal(inBuf, outDirectBuf);\n+\n+            debugBuf.append(\"(post) inputBuf: \" + inBuf + \"\\n\");\n+            debugBuf.append(\"(post) outputBuf: \" + outDirectBuf + \"\\n\");\n+            match(outDirectBuf, answer);\n+\n+            \/\/ test#6: Streams\n+            debugBuf.append(\"Test#6: Streaming\\n\");\n+            outBuf.position(0);\n+            InputStream stream =\n+                    new CipherInputStream(new ByteArrayInputStream(in), cipher);\n+            byte[] data = new byte[1024];\n+            int bytesRead = 0;\n+            try {\n+                while (bytesRead >= 0) {\n+                    bytesRead = stream.read(data);\n+                    if (bytesRead == -1)\n+                        break;\n+                    debugBuf.append(\"bytesRead: \" + bytesRead);\n+                    debugBuf.append(\"\\toutBuf.position(): \" + outBuf.position() +\n+                            \"\\n\");\n+                    outBuf.put(data, 0, bytesRead);\n+                }\n+            } catch (Exception ex) {\n+                debugBuf.append(\"Caught Exception during stream reading\\n\");\n+                throw ex;\n@@ -207,3 +215,1 @@\n-        } catch (Exception ex) {\n-            debugBuf.append(\"Caught Exception during stream reading\\n\");\n-            throw ex;\n+            match(outBuf, answer);\n@@ -211,2 +217,0 @@\n-        match(outBuf, answer);\n-\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphersNoPad.java","additions":89,"deletions":85,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.lang.foreign.Arena;\n@@ -36,1 +37,2 @@\n-import java.security.*;\n+import java.security.MessageDigest;\n+import java.security.Provider;\n@@ -99,0 +101,11 @@\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            ByteBuffer b5 = arena.allocate(n).asByteBuffer();\n+            b5.put(data);\n+            b5.clear();\n+            byte[] d5 = digest(md, b5);\n+            if (Arrays.equals(d1, d5) == false) {\n+                throw new Exception(\"Test 4 failed\");\n+            }\n+        }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/MessageDigest\/ByteBuffers.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.lang.foreign.Arena;\n@@ -87,0 +88,8 @@\n+        \/\/ test 4: ByteBuffer from MemorySegment\n+        try (Arena arena = Arena.ofConfined()) {\n+            ByteBuffer b5 = arena.allocate(t.length).asByteBuffer();\n+            b5.put(t);\n+            b5.clear();\n+            verify(sig, signature, b5, random);\n+        }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/ByteBuffers.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"}]}