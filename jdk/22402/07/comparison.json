{"files":[{"patch":"@@ -66,5 +66,0 @@\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(id, getProperties());\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputNode.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.data.InputNode;\n@@ -28,1 +29,2 @@\n-import java.awt.Dimension;\n+import com.sun.hotspot.igv.layout.Vertex;\n+import java.awt.Point;\n@@ -30,2 +32,1 @@\n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.*;\n@@ -39,1 +40,1 @@\n-    private InputBlock inputBlock;\n+    protected final InputBlock inputBlock;\n@@ -41,1 +42,1 @@\n-    private Diagram diagram;\n+    private final Diagram diagram;\n@@ -62,2 +63,8 @@\n-    public Dimension getNodeOffset() {\n-        return new Dimension(0, -Figure.getVerticalOffset());\n+    public List<? extends Vertex> getVertices() {\n+        List<Vertex> vertices = new ArrayList<>();\n+        for (InputNode inputNode : inputBlock.getNodes()) {\n+            if (diagram.hasFigure(inputNode)) {\n+                vertices.add(diagram.getFigure(inputNode));\n+            }\n+        }\n+        return vertices;\n@@ -70,0 +77,13 @@\n+    @Override\n+    public void setPosition(Point p) {\n+        if (bounds != null) {\n+            bounds.setLocation(p);\n+        }\n+    }\n+\n+    @Override\n+    public Point getPosition() {\n+        return bounds.getLocation();\n+    }\n+\n+    @Override\n@@ -82,0 +102,13 @@\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) return true;\n+        if (obj == null || getClass() != obj.getClass()) return false;\n+        Block other = (Block) obj;\n+        return inputBlock.equals(other.inputBlock);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return inputBlock.hashCode();\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Block.java","additions":41,"deletions":8,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Objects;\n@@ -88,5 +89,0 @@\n-    @Override\n-    public boolean isVIP() {\n-        return true;\n-    }\n-\n@@ -107,0 +103,15 @@\n+\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (!(o instanceof BlockConnection that)) return false;\n+        return Objects.equals(this.sourceBlock, that.sourceBlock) &&\n+                Objects.equals(this.destinationBlock, that.destinationBlock) &&\n+                Objects.equals(this.label, that.label);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(sourceBlock, destinationBlock, label);\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/BlockConnection.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    private List<Figure> figures;\n+    private final Map<InputNode, Figure> figures;\n@@ -66,1 +66,1 @@\n-        this.figures = new ArrayList<>();\n+        this.figures = new LinkedHashMap<>();\n@@ -84,1 +84,1 @@\n-            this.figures.add(f);\n+            this.figures.put(n, f);\n@@ -116,1 +116,1 @@\n-        for (Figure f : figures) {\n+        for (Figure f : figures.values()) {\n@@ -136,0 +136,9 @@\n+    public boolean hasFigure(InputNode n) {\n+        return figures.containsKey(n);\n+    }\n+\n+    public Figure getFigure(InputNode n) {\n+        assert figures.containsKey(n);\n+        return figures.get(n);\n+    }\n+\n@@ -161,1 +170,1 @@\n-        return Collections.unmodifiableList(figures);\n+        return Collections.unmodifiableList(new ArrayList<>(figures.values()));\n@@ -170,1 +179,1 @@\n-    public void removeAllBlocks(Set<Block> blocksToRemove) {\n+    public void removeAllBlocks(Collection<Block> blocksToRemove) {\n@@ -185,1 +194,1 @@\n-    public void removeAllFigures(Set<Figure> figuresToRemove) {\n+    public void removeAllFigures(Collection<Figure> figuresToRemove) {\n@@ -188,1 +197,1 @@\n-        }\n+            figures.remove(f.getInputNode());\n@@ -190,5 +199,0 @@\n-        ArrayList<Figure> newFigures = new ArrayList<>();\n-        for (Figure f : this.figures) {\n-            if (!figuresToRemove.contains(f)) {\n-                newFigures.add(f);\n-            }\n@@ -196,1 +200,0 @@\n-        figures = newFigures;\n@@ -218,4 +221,3 @@\n-    public void removeFigure(Figure succ) {\n-        assert this.figures.contains(succ);\n-        freeFigure(succ);\n-        this.figures.remove(succ);\n+    public void removeFigure(Figure figure) {\n+        freeFigure(figure);\n+        this.figures.remove(figure.getInputNode());\n@@ -226,1 +228,1 @@\n-        for (Figure f : figures) {\n+        for (Figure f : figures.values()) {\n@@ -249,1 +251,1 @@\n-        List<Figure> tmpFigures = getFigures();\n+        Collection<Figure> tmpFigures = getFigures();\n@@ -281,1 +283,1 @@\n-        Properties.PropertySelector<Figure> selector = new Properties.PropertySelector<>(figures);\n+        Properties.PropertySelector<Figure> selector = new Properties.PropertySelector<>(figures.values());\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Diagram.java","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-    public static final int INSET = 8;\n@@ -38,5 +37,4 @@\n-    public static final int OVERLAPPING = 6;\n-    public static final int SLOT_START = 4;\n-    public static final int SLOT_OFFSET = 8;\n-    public static final int TOP_CFG_HEIGHT = 7;\n-    public static final int BOTTOM_CFG_HEIGHT = 6;\n+    public static final int SLOT_HEIGHT = 10;\n+    public static final int BORDER = 1;\n+    public static final int PADDING = 4;\n+    public static final int SLOT_OFFSET = 16;\n@@ -70,9 +68,6 @@\n-        String nodeText = diagram.getNodeText();\n-        int lines = nodeText.split(\"\\n\").length;\n-        if (hasInputList() && lines > 1) {\n-            lines++;\n-        }\n-        if (getProperties().get(\"extra_label\") != null) {\n-            lines++;\n-        }\n-        heightCash = lines * metrics.getHeight() + INSET;\n+        heightCash = getLines().length * metrics.getHeight() + 2 * PADDING;\n+        heightCash += getSlotsHeight();\n+    }\n+\n+    public int getSlotsHeight() {\n+        int slotHeight = 0;\n@@ -81,1 +76,1 @@\n-                heightCash += TOP_CFG_HEIGHT;\n+                slotHeight += Figure.SLOT_HEIGHT;\n@@ -84,1 +79,1 @@\n-                heightCash += BOTTOM_CFG_HEIGHT;\n+                slotHeight += Figure.SLOT_HEIGHT;\n@@ -87,0 +82,1 @@\n+        return slotHeight;\n@@ -120,10 +116,5 @@\n-            int max = 0;\n-            for (String s : getLines()) {\n-                int cur = metrics.stringWidth(s);\n-                if (cur > max) {\n-                    max = cur;\n-                }\n-            }\n-            widthCash = (int)(max * BOLD_LINE_FACTOR) + INSET;\n-            if (getWarning() != null) {\n-                widthCash += WARNING_WIDTH;\n+        widthCash = 0;\n+        for (String s : getLines()) {\n+            int cur = metrics.stringWidth(s);\n+            if (cur > widthCash) {\n+                widthCash = cur;\n@@ -131,2 +122,8 @@\n-            widthCash = Math.max(widthCash, Figure.getSlotsWidth(inputSlots));\n-            widthCash = Math.max(widthCash, Figure.getSlotsWidth(outputSlots));\n+        }\n+        widthCash += 2 * PADDING;\n+        if (getWarning() != null) {\n+            widthCash += WARNING_WIDTH + PADDING;\n+        }\n+        widthCash = Math.max(widthCash, Figure.getSlotsWidth(inputSlots));\n+        widthCash = Math.max(widthCash, Figure.getSlotsWidth(outputSlots));\n+        widthCash = (int)(widthCash * BOLD_LINE_FACTOR);\n@@ -234,1 +231,1 @@\n-    public InputSlot createInputSlot() {\n+    public void createInputSlot() {\n@@ -237,1 +234,0 @@\n-        return slot;\n@@ -344,1 +340,0 @@\n-                assert(inputLabel != null);\n@@ -382,2 +377,2 @@\n-        int width = Math.max(getWidth(), Figure.SLOT_WIDTH * (Math.max(inputSlots.size(), outputSlots.size()) + 1));\n-        int height = getHeight() + (diagram.isCFG() ? 0 : 2 * Figure.SLOT_WIDTH - 2 * Figure.OVERLAPPING);\n+        int width = getWidth();\n+        int height = getHeight();\n@@ -389,1 +384,2 @@\n-        if (!(o instanceof Figure)) {\n+        if (this == o) return true;\n+        if (!(o instanceof Figure other)) {\n@@ -392,1 +388,1 @@\n-        return getInputNode().equals(((Figure) o).getInputNode());\n+        return Objects.equals(this.getInputNode(), other.getInputNode());\n@@ -397,1 +393,1 @@\n-        return getInputNode().hashCode();\n+        return Objects.hash(getInputNode());\n@@ -405,4 +401,0 @@\n-    public static int getVerticalOffset() {\n-        return Figure.SLOT_WIDTH - Figure.OVERLAPPING;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Figure.java","additions":34,"deletions":42,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.Objects;\n@@ -44,1 +45,1 @@\n-    private String label;\n+    private final String label;\n@@ -124,0 +125,8 @@\n+    public Figure getFromFigure() {\n+        return outputSlot.getFigure();\n+    }\n+\n+    public Figure getToFigure() {\n+        return inputSlot.getFigure();\n+    }\n+\n@@ -139,5 +148,0 @@\n-    @Override\n-    public boolean isVIP() {\n-        return style == ConnectionStyle.BOLD;\n-    }\n-\n@@ -161,8 +165,4 @@\n-        if (!(o instanceof FigureConnection)) {\n-            return false;\n-        }\n-\n-        return getInputSlot().getFigure().equals(((FigureConnection)o).getInputSlot().getFigure())\n-                && getOutputSlot().getFigure().equals(((FigureConnection)o).getOutputSlot().getFigure())\n-                && getInputSlot().getPosition() == ((FigureConnection)o).getInputSlot().getPosition()\n-                && getOutputSlot().getPosition() == ((FigureConnection) o).getOutputSlot().getPosition();\n+        if (this == o) return true;\n+        if (!(o instanceof FigureConnection that)) return false;\n+        return Objects.equals(this.outputSlot, that.outputSlot) &&\n+                Objects.equals(this.inputSlot, that.inputSlot);\n@@ -171,0 +171,4 @@\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(outputSlot, inputSlot);\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/FigureConnection.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -75,1 +76,1 @@\n-        return new Point(gapAmount + Figure.getSlotsWidth(Figure.getAllBefore(getFigure().getInputSlots(), this)) + getWidth()\/2, -Figure.SLOT_START);\n+        return new Point(gapAmount + Figure.getSlotsWidth(Figure.getAllBefore(getFigure().getInputSlots(), this)) + getWidth()\/2, 0);\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/InputSlot.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.Objects;\n@@ -57,1 +58,1 @@\n-        return new Point(gapAmount + Figure.getSlotsWidth(Figure.getAllBefore(getFigure().getOutputSlots(), this)) + getWidth()\/2, Figure.SLOT_START);\n+        return new Point(gapAmount + Figure.getSlotsWidth(Figure.getAllBefore(getFigure().getOutputSlots(), this)) + getWidth()\/2, 0);\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/OutputSlot.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n+import java.util.*;\n@@ -48,2 +45,2 @@\n-    private int wantedIndex;\n-    private Source source;\n+    private final int wantedIndex;\n+    private final Source source;\n@@ -51,1 +48,0 @@\n-    private InputNode associatedNode;\n@@ -55,1 +51,1 @@\n-    private Figure figure;\n+    private final Figure figure;\n@@ -83,4 +79,0 @@\n-    public void setAssociatedNode(InputNode node) {\n-        associatedNode = node;\n-    }\n-\n@@ -88,2 +80,3 @@\n-        if (shortName == null || shortName.length() <= 1) {\n-            return Figure.SLOT_WIDTH;\n+        assert shortName != null;\n+        if (shortName.isEmpty()) {\n+            return 0;\n@@ -99,2 +92,2 @@\n-    public int getWantedIndex() {\n-        return wantedIndex;\n+    public int getHeight() {\n+        return Figure.SLOT_HEIGHT;\n@@ -114,1 +107,0 @@\n-\/\/        assert s.length() <= 2;\n@@ -141,1 +133,1 @@\n-        return getShortName() != null && getShortName().length() > 0;\n+        return getShortName() != null && !getShortName().isEmpty();\n@@ -156,1 +148,0 @@\n-        assert figure != null;\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Slot.java","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,4 +73,0 @@\n-    public boolean isVIP() {\n-        return false;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterEdge.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,4 +73,0 @@\n-\n-    public boolean isVIP() {\n-        return false;\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterIngoingConnection.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-        final ClusterNode thisBlockNode = blockNode;\n@@ -79,1 +78,1 @@\n-                p.x += blockNode.getBorder();\n+                p.x += ClusterNode.PADDING;\n@@ -85,1 +84,1 @@\n-                return thisBlockNode;\n+                return blockNode;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterInputSlotNode.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.awt.Rectangle;\n@@ -40,0 +41,1 @@\n+    public static final int PADDING = 8;\n@@ -48,2 +50,0 @@\n-    private final int border;\n-    private final Dimension nodeOffset;\n@@ -53,3 +53,1 @@\n-    public ClusterNode(Cluster cluster, String name, int border,\n-                       Dimension nodeOffset, int headerVerticalSpace,\n-                       Dimension emptySize) {\n+    public ClusterNode(Cluster cluster, String name, int headerVerticalSpace, Dimension emptySize) {\n@@ -61,2 +59,0 @@\n-        this.border = border;\n-        this.nodeOffset = nodeOffset;\n@@ -70,2 +66,2 @@\n-    public ClusterNode(Cluster cluster, String name) {\n-        this(cluster, name, 20, new Dimension(0, 0), 0, new Dimension(0, 0));\n+    public void updateClusterBounds() {\n+        cluster.setBounds(new Rectangle(position, size));\n@@ -148,2 +144,2 @@\n-            n.setPosition(new Point(n.getPosition().x - minX + nodeOffset.width,\n-                                    n.getPosition().y - minY + nodeOffset.height + headerVerticalSpace));\n+            n.setPosition(new Point(n.getPosition().x - minX,\n+                                    n.getPosition().y - minY + headerVerticalSpace));\n@@ -156,1 +152,1 @@\n-                p.y -= minY;\n+                p.y = p.y - minY + headerVerticalSpace;\n@@ -162,2 +158,2 @@\n-        size.width += 2 * border;\n-        size.height += 2 * border;\n+        size.width += 2 * PADDING;\n+        size.height += 2 * PADDING;\n@@ -184,1 +180,1 @@\n-            cur.translate(pos.x + border, pos.y + border);\n+            cur.translate(pos.x + PADDING, pos.y + PADDING);\n@@ -194,1 +190,1 @@\n-                    p2.translate(pos.x + border, pos.y + border);\n+                    p2.translate(pos.x + PADDING, pos.y + PADDING);\n@@ -221,4 +217,0 @@\n-    public int getBorder() {\n-        return border;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterNode.java","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,4 +72,0 @@\n-\n-    public boolean isVIP() {\n-        return false;\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterOutgoingConnection.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-        final ClusterNode thisBlockNode = blockNode;\n@@ -88,1 +87,1 @@\n-                p.x += blockNode.getBorder();\n+                p.x += ClusterNode.PADDING;\n@@ -94,1 +93,1 @@\n-                return thisBlockNode;\n+                return blockNode;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterOutputSlotNode.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,3 @@\n-import com.sun.hotspot.igv.layout.LayoutManager;\n-import com.sun.hotspot.igv.layout.*;\n+import com.sun.hotspot.igv.layout.Cluster;\n+import com.sun.hotspot.igv.layout.Link;\n+import com.sun.hotspot.igv.layout.Vertex;\n@@ -31,1 +32,1 @@\n-public class HierarchicalCFGLayoutManager implements LayoutManager {\n+public class HierarchicalCFGLayoutManager extends LayoutManager {\n@@ -33,1 +34,0 @@\n-    private static final int BLOCK_BORDER = 5;\n@@ -35,7 +35,9 @@\n-    \/\/ Lays out nodes within a single cluster (basic block).\n-    private LayoutManager subManager;\n-    \/\/ Lays out clusters in the CFG.\n-    private LayoutManager manager;\n-    private Set<Cluster> clusters;\n-\n-    public HierarchicalCFGLayoutManager() {\n+    private final HierarchicalLayoutManager manager;\n+    private final Set<? extends Cluster> clusters;\n+    private final Set<? extends Link> clusterLinks;\n+    Map<Cluster, ClusterNode> clusterNodesMap;\n+    Map<Link, ClusterEdge> clusterEdgesMap;\n+\n+    public HierarchicalCFGLayoutManager(Set<? extends Link> clusterLinks, Set<? extends Cluster> clusters) {\n+        this.clusterLinks = clusterLinks;\n+        this.clusters = clusters;\n@@ -46,0 +48,2 @@\n+        manager = new HierarchicalLayoutManager();\n+        manager.setLayoutSelfEdges(true);\n@@ -50,1 +54,0 @@\n-        subManager.setCutEdges(enable);\n@@ -54,14 +57,11 @@\n-    public void setSubManager(LayoutManager manager) {\n-        this.subManager = manager;\n-    }\n-\n-    public void setManager(LayoutManager manager) {\n-        this.manager = manager;\n-    }\n-\n-    public void setClusters(Set<Cluster> clusters) {\n-        this.clusters = clusters;\n-    }\n-\n-    public void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks) {\n-        doLayout(graph);\n+    private static void doLinearLayout(ClusterNode clusterNode) {\n+        Cluster cluster = clusterNode.getCluster();\n+        LayoutGraph graph = new LayoutGraph(clusterNode.getSubEdges(), clusterNode.getSubNodes());\n+        int curY = 0;\n+        for (Vertex vertex : cluster.getVertices()) {\n+            if (graph.containsVertex(vertex)) {\n+                vertex.setPosition(new Point(0, curY));\n+                curY += vertex.getSize().height;\n+            }\n+        }\n+        clusterNode.updateSize();\n@@ -71,1 +71,0 @@\n-\n@@ -73,3 +72,4 @@\n-        Map<Cluster, ClusterNode> clusterNode = createClusterNodes(graph);\n-        Set<ClusterEdge> clusterEdges = createClusterEdges(clusterNode);\n-        markRootClusters(clusterEdges);\n+        clusterNodesMap = createClusterNodes(graph.getVertices());\n+        assert clusterNodesMap.size() == clusters.size();\n+        clusterEdgesMap = createClusterEdges(clusterNodesMap);\n+        assert clusterEdgesMap.size() == clusterLinks.size();\n@@ -78,4 +78,9 @@\n-        for (Cluster c : clusters) {\n-            ClusterNode n = clusterNode.get(c);\n-            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<>());\n-            n.updateSize();\n+        for (ClusterNode clusterNode : clusterNodesMap.values()) {\n+            doLinearLayout(clusterNode);\n+        }\n+\n+        \/\/ mark root nodes\n+        LayoutGraph clusterGraph = new LayoutGraph(clusterEdgesMap.values(), clusterNodesMap.values());\n+        for (Vertex rootVertex : clusterGraph.findRootVertices()) {\n+            assert rootVertex instanceof ClusterNode;\n+            ((ClusterNode) rootVertex).setRoot(true);\n@@ -85,1 +90,1 @@\n-        manager.doLayout(new LayoutGraph(clusterEdges, new HashSet<>(clusterNode.values())), new HashSet<>());\n+        manager.doLayout(clusterGraph);\n@@ -88,2 +93,2 @@\n-        writeBackClusterBounds(clusterNode);\n-        writeBackClusterEdgePoints(graph, clusterEdges);\n+        writeBackClusterBounds();\n+        writeBackClusterEdgePoints();\n@@ -92,9 +97,8 @@\n-    private Map<Cluster, ClusterNode> createClusterNodes(LayoutGraph graph) {\n-        Map<Cluster, ClusterNode> clusterNode = new HashMap<>();\n-        for (Cluster c : clusters) {\n-            String blockLabel = \"B\" + c;\n-            Dimension emptySize = new Dimension(fontMetrics.stringWidth(blockLabel) + BLOCK_BORDER * 2,\n-                                                fontMetrics.getHeight() + BLOCK_BORDER);\n-            ClusterNode cn = new ClusterNode(c, c.toString(), BLOCK_BORDER, c.getNodeOffset(),\n-                                             fontMetrics.getHeight(), emptySize);\n-            clusterNode.put(c, cn);\n+    private Map<Cluster, ClusterNode> createClusterNodes(SortedSet<Vertex> vertices) {\n+        Map<Cluster, ClusterNode> clusterNodes = new HashMap<>();\n+        for (Cluster cluster : clusters) {\n+            String blockLabel = \"B\" + cluster;\n+            Dimension emptySize = new Dimension(fontMetrics.stringWidth(blockLabel) + ClusterNode.PADDING,\n+                                                fontMetrics.getHeight() + ClusterNode.PADDING);\n+            ClusterNode clusterNode = new ClusterNode(cluster, cluster.toString(), fontMetrics.getHeight(), emptySize);\n+            clusterNodes.put(cluster, clusterNode);\n@@ -103,4 +107,3 @@\n-        for (Vertex v : graph.getVertices()) {\n-            Cluster c = v.getCluster();\n-            assert c != null : \"Cluster of vertex \" + v + \" is null!\";\n-            clusterNode.get(c).addSubNode(v);\n+        for (Vertex vertex : vertices) {\n+            Cluster cluster = vertex.getCluster();\n+            clusterNodes.get(cluster).addSubNode(vertex);\n@@ -108,1 +111,1 @@\n-        return clusterNode;\n+        return clusterNodes;\n@@ -111,14 +114,2 @@\n-    private Set<ClusterEdge> createClusterEdges(Map<Cluster, ClusterNode> clusterNode) {\n-        Set<ClusterEdge> clusterEdges = new HashSet<>();\n-        for (Cluster c : clusters) {\n-            ClusterNode start = clusterNode.get(c);\n-            for (Cluster succ : c.getSuccessors()) {\n-                ClusterNode end = clusterNode.get(succ);\n-                if (end != null) {\n-                    ClusterEdge e = new ClusterEdge(start, end);\n-                    clusterEdges.add(e);\n-                }\n-            }\n-        }\n-        return clusterEdges;\n-    }\n+    private Map<Link, ClusterEdge> createClusterEdges(Map<Cluster, ClusterNode> clusterNodes) {\n+        Map<Link, ClusterEdge> clusterEdges = new HashMap<>();\n@@ -126,5 +117,6 @@\n-    private void markRootClusters(Set<ClusterEdge> clusterEdges) {\n-        Set<Vertex> roots = new LayoutGraph(clusterEdges).findRootVertices();\n-        for (Vertex v : roots) {\n-            assert v instanceof ClusterNode;\n-            ((ClusterNode) v).setRoot(true);\n+        for (Link clusterLink : clusterLinks) {\n+            ClusterNode fromClusterNode = clusterNodes.get(clusterLink.getFromCluster());\n+            ClusterNode toClusterNode = clusterNodes.get(clusterLink.getToCluster());\n+            assert fromClusterNode != null;\n+            assert toClusterNode != null;\n+            clusterEdges.put(clusterLink, new ClusterEdge(fromClusterNode, toClusterNode));\n@@ -132,0 +124,2 @@\n+\n+        return clusterEdges;\n@@ -134,4 +128,4 @@\n-    private void writeBackClusterBounds(Map<Cluster, ClusterNode> clusterNode) {\n-        for (Cluster c : clusters) {\n-            ClusterNode n = clusterNode.get(c);\n-            c.setBounds(new Rectangle(n.getPosition(), n.getSize()));\n+    private void writeBackClusterBounds() {\n+        assert clusterNodesMap.size() == clusters.size();\n+        for (ClusterNode clusterNode : clusterNodesMap.values()) {\n+            clusterNode.updateClusterBounds();\n@@ -141,10 +135,9 @@\n-    private void writeBackClusterEdgePoints(LayoutGraph graph, Set<ClusterEdge> clusterEdges) {\n-        \/\/ Map from \"primitive\" cluster edges to their input links.\n-        Map<AbstractMap.SimpleEntry<Cluster, Cluster>, Link> inputLink = new HashMap<>();\n-        for (Link l : graph.getLinks()) {\n-            inputLink.put(new AbstractMap.SimpleEntry<>(l.getFromCluster(), l.getToCluster()), l);\n-        }\n-        for (ClusterEdge ce : clusterEdges) {\n-            assert (ce.getControlPoints() != null);\n-            Link l = inputLink.get(new AbstractMap.SimpleEntry<>(ce.getFromCluster(), ce.getToCluster()));\n-            l.setControlPoints(ce.getControlPoints());\n+    private void writeBackClusterEdgePoints() {\n+        assert clusterEdgesMap.size() == clusterLinks.size();\n+        for (Link clusterLink : clusterLinks) {\n+            ClusterEdge clusterEdge = clusterEdgesMap.get(clusterLink);\n+            if (clusterEdge.getControlPoints() != null) {\n+                clusterLink.setControlPoints(clusterEdge.getControlPoints());\n+            } else {\n+                clusterLink.setControlPoints(new ArrayList<>());\n+            }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalCFGLayoutManager.java","additions":78,"deletions":85,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n-import java.awt.Point;\n-import java.awt.Rectangle;\n+import java.awt.*;\n@@ -30,0 +29,1 @@\n+import java.util.List;\n@@ -35,1 +35,1 @@\n-public class HierarchicalClusterLayoutManager implements LayoutManager {\n+public class HierarchicalClusterLayoutManager extends LayoutManager {\n@@ -37,4 +37,2 @@\n-    private HierarchicalLayoutManager.Combine combine;\n-    private LayoutManager subManager = new HierarchicalLayoutManager(combine);\n-    private LayoutManager manager = new HierarchicalLayoutManager(combine);\n-    private static final boolean TRACE = false;\n+    private final LayoutManager manager;\n+    private final HashMap<Cluster, ClusterNode> clusterNodes;\n@@ -42,2 +40,4 @@\n-    public HierarchicalClusterLayoutManager(HierarchicalLayoutManager.Combine combine) {\n-        this.combine = combine;\n+\n+    public HierarchicalClusterLayoutManager() {\n+        this.manager = new HierarchicalLayoutManager();\n+        this.clusterNodes = new HashMap<>();\n@@ -48,1 +48,0 @@\n-        subManager.setCutEdges(enable);\n@@ -52,11 +51,0 @@\n-    public void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks) {\n-        doLayout(graph);\n-    }\n-\n-    public void setSubManager(LayoutManager manager) {\n-        this.subManager = manager;\n-    }\n-\n-    public void setManager(LayoutManager manager) {\n-        this.manager = manager;\n-    }\n@@ -65,3 +53,1 @@\n-\n-        assert graph.verify();\n-\n+        clusterNodes.clear();\n@@ -72,1 +58,0 @@\n-        HashMap<Cluster, ClusterNode> clusterNodes = new HashMap<>();\n@@ -82,1 +67,7 @@\n-        Set<Cluster> cluster = graph.getClusters();\n+        Set<Cluster> clusters = new TreeSet<>();\n+        for (Vertex v : graph.getVertices()) {\n+            if (v.getCluster() != null) {\n+                clusters.add(v.getCluster());\n+            }\n+        }\n+\n@@ -84,1 +75,1 @@\n-        for (Cluster c : cluster) {\n+        for (Cluster c : clusters) {\n@@ -90,1 +81,8 @@\n-            ClusterNode cn = new ClusterNode(c, \"\" + z);\n+\n+            String blockLabel = \"B\" + c;\n+            Canvas canvas = new Canvas();\n+            FontMetrics fontMetrics = canvas.getFontMetrics(TITLE_FONT);\n+            Dimension emptySize = new Dimension(fontMetrics.stringWidth(blockLabel) + ClusterNode.PADDING * 2,\n+                    fontMetrics.getHeight() + ClusterNode.PADDING * 2);\n+            ClusterNode cn = new ClusterNode(c, \"\" + z, fontMetrics.getHeight(), emptySize);\n+\n@@ -96,15 +94,0 @@\n-        \/\/ Add cluster edges\n-        for (Cluster c : cluster) {\n-\n-            ClusterNode start = clusterNodes.get(c);\n-\n-            for (Cluster succ : c.getSuccessors()) {\n-                ClusterNode end = clusterNodes.get(succ);\n-                if (end != null && start != end) {\n-                    ClusterEdge e = new ClusterEdge(start, end);\n-                    clusterEdges.add(e);\n-                    interClusterEdges.add(e);\n-                }\n-            }\n-        }\n-\n@@ -126,7 +109,0 @@\n-            Port samePort = null;\n-            if (combine == HierarchicalLayoutManager.Combine.SAME_INPUTS) {\n-                samePort = toPort;\n-            } else if (combine == HierarchicalLayoutManager.Combine.SAME_OUTPUTS) {\n-                samePort = fromPort;\n-            }\n-\n@@ -140,2 +116,2 @@\n-                ClusterInputSlotNode inputSlotNode = null;\n-                ClusterOutputSlotNode outputSlotNode = null;\n+                ClusterInputSlotNode inputSlotNode;\n+                ClusterOutputSlotNode outputSlotNode;\n@@ -143,4 +119,2 @@\n-                if (samePort != null) {\n-                    outputSlotNode = clusterOutputSlotHash.get(fromCluster).get(samePort);\n-                    inputSlotNode = clusterInputSlotHash.get(toCluster).get(samePort);\n-                }\n+                outputSlotNode = clusterOutputSlotHash.get(fromCluster).get(fromPort);\n+                inputSlotNode = clusterInputSlotHash.get(toCluster).get(toPort);\n@@ -149,1 +123,1 @@\n-                    outputSlotNode = new ClusterOutputSlotNode(clusterNodes.get(fromCluster), \"Out \" + fromCluster.toString() + \" \" + samePort);\n+                    outputSlotNode = new ClusterOutputSlotNode(clusterNodes.get(fromCluster), \"Out \" + fromCluster.toString() + \" \" + fromPort);\n@@ -154,3 +128,1 @@\n-                    if (samePort != null) {\n-                        clusterOutputSlotHash.get(fromCluster).put(samePort, outputSlotNode);\n-                    }\n+                    clusterOutputSlotHash.get(fromCluster).put(fromPort, outputSlotNode);\n@@ -164,1 +136,4 @@\n-                    inputSlotNode = new ClusterInputSlotNode(clusterNodes.get(toCluster), \"In \" + toCluster.toString() + \" \" + samePort);\n+                    inputSlotNode = new ClusterInputSlotNode(\n+                            clusterNodes.get(toCluster),\n+                            \"In \" + toCluster.toString() + \" \" + toPort \/\/ Use toPort here\n+                    );\n@@ -170,1 +145,1 @@\n-                clusterInputSlotHash.get(toCluster).put(samePort, inputSlotNode);\n+                clusterInputSlotHash.get(toCluster).put(fromPort, inputSlotNode);\n@@ -181,8 +156,1 @@\n-        Timing t = null;\n-\n-        if (TRACE) {\n-            t = new Timing(\"Child timing\");\n-            t.start();\n-        }\n-\n-        for (Cluster c : cluster) {\n+        for (Cluster c : clusters) {\n@@ -190,1 +158,2 @@\n-            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<>());\n+            HierarchicalLayoutManager subManager = new HierarchicalLayoutManager();\n+            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()));\n@@ -194,1 +163,1 @@\n-        Set<Vertex> roots = new LayoutGraph(interClusterEdges).findRootVertices();\n+        Set<Vertex> roots = new LayoutGraph(interClusterEdges, new HashSet<>()).findRootVertices();\n@@ -200,1 +169,1 @@\n-        manager.doLayout(new LayoutGraph(clusterEdges, clusterNodeSet), interClusterEdges);\n+        manager.doLayout(new LayoutGraph(clusterEdges, clusterNodeSet));\n@@ -202,1 +171,1 @@\n-        for (Cluster c : cluster) {\n+        for (Cluster c : clusters) {\n@@ -207,7 +176,0 @@\n-        \/\/ TODO: handle case where blocks are not fully connected\n-\n-        if (TRACE) {\n-            t.stop();\n-            t.print();\n-        }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalClusterLayoutManager.java","additions":44,"deletions":82,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n-import com.sun.hotspot.igv.layout.LayoutManager;\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutNode.*;\n@@ -30,2 +29,0 @@\n-import com.sun.hotspot.igv.util.Statistics;\n-import java.awt.Dimension;\n@@ -39,79 +36,1 @@\n-public class HierarchicalLayoutManager implements LayoutManager {\n-\n-    public static final boolean TRACE = false;\n-    public static final boolean CHECK = false;\n-    public static final int SWEEP_ITERATIONS = 1;\n-    public static final int CROSSING_ITERATIONS = 2;\n-    public static final int DUMMY_HEIGHT = 1;\n-    public static final int DUMMY_WIDTH = 1;\n-    public static final int X_OFFSET = 8;\n-    public static final int LAYER_OFFSET = 8;\n-    public static final int MAX_LAYER_LENGTH = -1;\n-    public static final int MIN_LAYER_DIFFERENCE = 1;\n-    public static final int VIP_BONUS = 10;\n-\n-    public enum Combine {\n-\n-        NONE,\n-        SAME_INPUTS,\n-        SAME_OUTPUTS\n-    }\n-    \/\/ Options\n-    private final Combine combine;\n-    private final int dummyWidth;\n-    private final int dummyHeight;\n-    private int xOffset;\n-    private int layerOffset;\n-    private int maxLayerLength;\n-    private int minLayerDifference;\n-    private boolean layoutSelfEdges;\n-    \/\/ Algorithm global datastructures\n-    private Set<Link> reversedLinks;\n-    private Set<LayoutEdge> selfEdges;\n-    private List<LayoutNode> nodes;\n-    private HashMap<Vertex, LayoutNode> vertexToLayoutNode;\n-    private HashMap<Link, List<Point>> reversedLinkStartPoints;\n-    private HashMap<Link, List<Point>> reversedLinkEndPoints;\n-    private HashMap<Link, List<Point>> splitStartPoints;\n-    private HashMap<Link, List<Point>> splitEndPoints;\n-    private LayoutGraph graph;\n-    private List<LayoutNode>[] layers;\n-    private int layerCount;\n-    private Set<? extends Link> importantLinks;\n-    private final Set<Link> linksToFollow;\n-\n-    private abstract static class AlgorithmPart {\n-\n-        public void start() {\n-            if (CHECK) {\n-                preCheck();\n-            }\n-\n-            long start = 0;\n-            if (TRACE) {\n-                System.out.println(\"##################################################\");\n-                System.out.println(\"Starting part \" + this.getClass().getName());\n-                start = System.currentTimeMillis();\n-            }\n-            run();\n-            if (TRACE) {\n-                System.out.println(\"Timing for \" + this.getClass().getName() + \" is \" + (System.currentTimeMillis() - start));\n-                printStatistics();\n-            }\n-\n-            if (CHECK) {\n-                postCheck();\n-            }\n-        }\n-\n-        protected abstract void run();\n-\n-        protected void printStatistics() {\n-        }\n-\n-        protected void postCheck() {\n-        }\n-\n-        protected void preCheck() {\n-        }\n-    }\n+public class HierarchicalLayoutManager extends LayoutManager {\n@@ -119,11 +38,3 @@\n-    public HierarchicalLayoutManager(Combine b) {\n-        this.combine = b;\n-        this.dummyWidth = DUMMY_WIDTH;\n-        this.dummyHeight = DUMMY_HEIGHT;\n-        this.xOffset = X_OFFSET;\n-        this.layerOffset = LAYER_OFFSET;\n-        this.maxLayerLength = MAX_LAYER_LENGTH;\n-        this.minLayerDifference = MIN_LAYER_DIFFERENCE;\n-        this.layoutSelfEdges = false;\n-        this.linksToFollow = new HashSet<>();\n-    }\n+    int maxLayerLength;\n+    private LayoutGraph graph;\n+    private boolean layoutSelfEdges = false;\n@@ -131,2 +42,3 @@\n-    public void setXOffset(int xOffset) {\n-        this.xOffset = xOffset;\n+    public HierarchicalLayoutManager() {\n+        setCutEdges(false);\n+        setLayoutSelfEdges(false);\n@@ -135,2 +47,2 @@\n-    public void setLayerOffset(int layerOffset) {\n-        this.layerOffset = layerOffset;\n+    public void setLayoutSelfEdges(boolean layoutSelfEdges) {\n+        this.layoutSelfEdges = layoutSelfEdges;\n@@ -144,3 +56,3 @@\n-    public void setMinLayerDifference(int v) {\n-        minLayerDifference = v;\n-    }\n+    @Override\n+    public void doLayout(LayoutGraph layoutGraph) {\n+        layoutGraph.initializeLayout();\n@@ -148,3 +60,1 @@\n-    public void setLayoutSelfEdges(boolean layoutSelfEdges) {\n-        this.layoutSelfEdges = layoutSelfEdges;\n-    }\n+        removeSelfEdges(layoutGraph);\n@@ -152,3 +62,2 @@\n-    public List<LayoutNode> getNodes() {\n-        return nodes;\n-    }\n+        \/\/ STEP 1: Reverse edges\n+        ReverseEdges.apply(layoutGraph);\n@@ -156,14 +65,2 @@\n-    \/\/ Remove self-edges, possibly saving them into the selfEdges set.\n-    private void removeSelfEdges(boolean save) {\n-        for (LayoutNode node : nodes) {\n-            for (LayoutEdge e : new ArrayList<>(node.succs)) {\n-                if (e.to == node) {\n-                    if (save) {\n-                        selfEdges.add(e);\n-                    }\n-                    node.succs.remove(e);\n-                    node.preds.remove(e);\n-                }\n-            }\n-        }\n-    }\n+        \/\/ STEP 2: Assign layers and create dummy nodes\n+        LayerManager.apply(layoutGraph, maxLayerLength);\n@@ -171,3 +68,2 @@\n-    @Override\n-    public void doLayout(LayoutGraph graph) {\n-        doLayout(graph, new HashSet<>());\n+        \/\/ STEP 3: Crossing Reduction\n+        CrossingReduction.apply(layoutGraph);\n@@ -175,1 +71,2 @@\n-    }\n+        \/\/ STEP 4: Assign X coordinates\n+        AssignXCoordinates.apply(layoutGraph);\n@@ -177,23 +74,2 @@\n-    @Override\n-    public void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks) {\n-\n-        this.importantLinks = importantLinks;\n-        this.graph = graph;\n-\n-        vertexToLayoutNode = new HashMap<>();\n-        reversedLinks = new HashSet<>();\n-        selfEdges = new HashSet<>();\n-        reversedLinkStartPoints = new HashMap<>();\n-        reversedLinkEndPoints = new HashMap<>();\n-        nodes = new ArrayList<>();\n-        splitStartPoints = new HashMap<>();\n-        splitEndPoints = new HashMap<>();\n-\n-        \/\/ #############################################################\n-        \/\/ Step 1: Build up data structure\n-        new BuildDatastructure().start();\n-\n-        if (!layoutSelfEdges) {\n-            \/\/ Remove self-edges from the beginning.\n-            removeSelfEdges(false);\n-        }\n+        \/\/ STEP 5: Write back to interface\n+        WriteResult.apply(layoutGraph);\n@@ -201,3 +77,2 @@\n-        \/\/ #############################################################\n-        \/\/ STEP 2: Reverse edges, handle backedges\n-        new ReverseEdges().start();\n+        graph = layoutGraph;\n+    }\n@@ -205,5 +80,12 @@\n-        for (LayoutNode n : nodes) {\n-            ArrayList<LayoutEdge> tmpArr = new ArrayList<>();\n-            for (LayoutEdge e : n.succs) {\n-                if (importantLinks.contains(e.link)) {\n-                    tmpArr.add(e);\n+    \/**\n+     * Removes self-edges from nodes in the graph. If self-edges are to be included in the layout\n+     * (`layoutSelfEdges` is true), it stores them in the node for later processing and marks the graph\n+     * to display self-edges\n+     *\/\n+    private void removeSelfEdges(LayoutGraph graph) {\n+        for (LayoutNode node : graph.getLayoutNodes()) {\n+            \/\/ Collect self-edges first to avoid concurrent modification\n+            List<LayoutEdge> selfEdges = new ArrayList<>();\n+            for (LayoutEdge edge : node.getSuccessors()) {\n+                if (edge.getTo() == node) {\n+                    selfEdges.add(edge);\n@@ -213,3 +95,10 @@\n-            for (LayoutEdge e : tmpArr) {\n-                e.from.succs.remove(e);\n-                e.to.preds.remove(e);\n+            \/\/ Remove each self-edge\n+            for (LayoutEdge edge : selfEdges) {\n+                node.removeSuccessor(edge);\n+                node.removePredecessor(edge);\n+            }\n+            if (layoutSelfEdges) {\n+                for (LayoutEdge selfEdge : selfEdges) {\n+                    node.setSelfEdge(selfEdge);\n+                }\n+                graph.setShowSelfEdges(true);\n@@ -218,28 +107,2 @@\n-\n-        \/\/ Hide self-edges from the layout algorithm and save them for later.\n-        removeSelfEdges(true);\n-\n-        \/\/ #############################################################\n-        \/\/ STEP 3: Assign layers\n-        new AssignLayers().start();\n-\n-        \/\/ #############################################################\n-        \/\/ STEP 4: Create dummy nodes\n-        new CreateDummyNodes().start();\n-\n-        \/\/ #############################################################\n-        \/\/ STEP 5: Crossing Reduction\n-        new CrossingReduction().start();\n-\n-        \/\/ #############################################################\n-        \/\/ STEP 7: Assign X coordinates\n-        new AssignXCoordinates().start();\n-\n-        \/\/ #############################################################\n-        \/\/ STEP 6: Assign Y coordinates\n-        new AssignYCoordinates().start();\n-\n-        \/\/ Put saved self-edges back so that they are assigned points.\n-        for (LayoutEdge e : selfEdges) {\n-            e.from.succs.add(e);\n-            e.to.preds.add(e);\n+        if (layoutSelfEdges) {\n+            graph.setShowSelfEdges(true);\n@@ -247,4 +110,0 @@\n-\n-        \/\/ #############################################################\n-        \/\/ STEP 8: Write back to interface\n-        new WriteResult().start();\n@@ -253,1 +112,3 @@\n-    private class WriteResult extends AlgorithmPart {\n+    public List<LayoutNode> getNodes() {\n+        return graph.getAllNodes();\n+    }\n@@ -255,1 +116,1 @@\n-        private int pointCount;\n+    public static class ReverseEdges {\n@@ -257,2 +118,3 @@\n-        @Override\n-        protected void run() {\n+        static public void apply(LayoutGraph graph) {\n+            reverseRootInputs(graph);\n+            depthFirstSearch(graph);\n@@ -260,6 +122,2 @@\n-            HashMap<Vertex, Point> vertexPositions = new HashMap<>();\n-            HashMap<Link, List<Point>> linkPositions = new HashMap<>();\n-            for (Vertex v : graph.getVertices()) {\n-                LayoutNode n = vertexToLayoutNode.get(v);\n-                assert !vertexPositions.containsKey(v);\n-                vertexPositions.put(v, new Point(n.x + n.xOffset, n.y + n.yOffset));\n+            for (LayoutNode node : graph.getLayoutNodes()) {\n+                node.computeReversedLinkPoints(false);\n@@ -267,0 +125,1 @@\n+        }\n@@ -268,84 +127,5 @@\n-            for (LayoutNode n : nodes) {\n-\n-                for (LayoutEdge e : n.preds) {\n-                    if (e.link != null && !linkPositions.containsKey(e.link)) {\n-                        ArrayList<Point> points = new ArrayList<>();\n-\n-                        Point p = new Point(e.to.x + e.relativeTo, e.to.y + e.to.yOffset + e.link.getTo().getRelativePosition().y);\n-                        points.add(p);\n-                        if (e.to.inOffsets.containsKey(e.relativeTo)) {\n-                            points.add(new Point(p.x, p.y + e.to.inOffsets.get(e.relativeTo) + e.link.getTo().getRelativePosition().y));\n-                        }\n-\n-                        LayoutNode cur = e.from;\n-                        LayoutNode other = e.to;\n-                        LayoutEdge curEdge = e;\n-                        while (cur.vertex == null && cur.preds.size() != 0) {\n-                            if (points.size() > 1 && points.get(points.size() - 1).x == cur.x + cur.width \/ 2 && points.get(points.size() - 2).x == cur.x + cur.width \/ 2) {\n-                                points.remove(points.size() - 1);\n-                            }\n-                            points.add(new Point(cur.x + cur.width \/ 2, cur.y + cur.height));\n-                            if (points.size() > 1 && points.get(points.size() - 1).x == cur.x + cur.width \/ 2 && points.get(points.size() - 2).x == cur.x + cur.width \/ 2) {\n-                                points.remove(points.size() - 1);\n-                            }\n-                            points.add(new Point(cur.x + cur.width \/ 2, cur.y));\n-                            assert cur.preds.size() == 1;\n-                            curEdge = cur.preds.get(0);\n-                            cur = curEdge.from;\n-                        }\n-\n-                        p = new Point(cur.x + curEdge.relativeFrom, cur.y + cur.height - cur.bottomYOffset + (curEdge.link == null ? 0 : curEdge.link.getFrom().getRelativePosition().y));\n-                        if (curEdge.from.outOffsets.containsKey(curEdge.relativeFrom)) {\n-                            points.add(new Point(p.x, p.y + curEdge.from.outOffsets.get(curEdge.relativeFrom) + (curEdge.link == null ? 0 : curEdge.link.getFrom().getRelativePosition().y)));\n-                        }\n-                        points.add(p);\n-\n-                        Collections.reverse(points);\n-\n-                        if (cur.vertex == null && cur.preds.size() == 0) {\n-\n-                            if (reversedLinkEndPoints.containsKey(e.link)) {\n-                                for (Point p1 : reversedLinkEndPoints.get(e.link)) {\n-                                    points.add(new Point(p1.x + e.to.x, p1.y + e.to.y));\n-                                }\n-                            }\n-\n-                            if (splitStartPoints.containsKey(e.link)) {\n-                                points.add(0, null);\n-                                points.addAll(0, splitStartPoints.get(e.link));\n-\n-                                \/\/checkPoints(points);\n-                                if (reversedLinks.contains(e.link)) {\n-                                    Collections.reverse(points);\n-                                }\n-                                assert !linkPositions.containsKey(e.link);\n-                                linkPositions.put(e.link, points);\n-                            } else {\n-                                splitEndPoints.put(e.link, points);\n-                            }\n-\n-                        } else {\n-                            if (reversedLinks.contains(e.link)) {\n-                                Collections.reverse(points);\n-                                if (selfEdges.contains(e)) {\n-                                    \/\/ For self edges, it is enough with the\n-                                    \/\/ start and end points computed by ReverseEdges.\n-                                    points.clear();\n-                                }\n-                            }\n-                            if (reversedLinkStartPoints.containsKey(e.link)) {\n-                                for (Point p1 : reversedLinkStartPoints.get(e.link)) {\n-                                    points.add(new Point(p1.x + cur.x, p1.y + cur.y));\n-                                }\n-                            }\n-\n-                            if (reversedLinkEndPoints.containsKey(e.link)) {\n-                                for (Point p1 : reversedLinkEndPoints.get(e.link)) {\n-                                    points.add(0, new Point(p1.x + other.x, p1.y + other.y));\n-                                }\n-                            }\n-\n-                            assert !linkPositions.containsKey(e.link);\n-                            linkPositions.put(e.link, points);\n-                        }\n-                        pointCount += points.size();\n+        private static void reverseRootInputs(LayoutGraph graph) {\n+            for (LayoutNode node : graph.getLayoutNodes()) {\n+                if (node.getVertex().isRoot()) {\n+                    for (LayoutEdge predEdge : new ArrayList<>(node.getPredecessors())) {\n+                        reverseEdge(predEdge);\n@@ -354,0 +134,2 @@\n+            }\n+        }\n@@ -355,38 +137,2 @@\n-                for (LayoutEdge e : n.succs) {\n-                    if (e.link != null && !linkPositions.containsKey(e.link)) {\n-                        ArrayList<Point> points = new ArrayList<>();\n-                        Point p = new Point(e.from.x + e.relativeFrom, e.from.y + e.from.height - e.from.bottomYOffset + e.link.getFrom().getRelativePosition().y);\n-                        points.add(p);\n-                        if (e.from.outOffsets.containsKey(e.relativeFrom)) {\n-                            Point pOffset = new Point(p.x, p.y + e.from.outOffsets.get(e.relativeFrom) +\n-                                                      e.link.getFrom().getRelativePosition().y + e.from.yOffset);\n-                            if (!pOffset.equals(p)) {\n-                                points.add(pOffset);\n-                            }\n-                        }\n-\n-                        LayoutNode cur = e.to;\n-                        LayoutNode other = e.from;\n-                        LayoutEdge curEdge = e;\n-                        while (cur.vertex == null && !cur.succs.isEmpty()) {\n-                            if (points.size() > 1 && points.get(points.size() - 1).x == cur.x + cur.width \/ 2 && points.get(points.size() - 2).x == cur.x + cur.width \/ 2) {\n-                                points.remove(points.size() - 1);\n-                            }\n-                            points.add(new Point(cur.x + cur.width \/ 2, cur.y));\n-                            if (points.size() > 1 && points.get(points.size() - 1).x == cur.x + cur.width \/ 2 && points.get(points.size() - 2).x == cur.x + cur.width \/ 2) {\n-                                points.remove(points.size() - 1);\n-                            }\n-                            points.add(new Point(cur.x + cur.width \/ 2, cur.y + cur.height));\n-                            if (cur.succs.isEmpty()) {\n-                                break;\n-                            }\n-                            assert cur.succs.size() == 1;\n-                            curEdge = cur.succs.get(0);\n-                            cur = curEdge.to;\n-                        }\n-\n-                        p = new Point(cur.x + curEdge.relativeTo, cur.y + cur.yOffset + ((curEdge.link == null) ? 0 : curEdge.link.getTo().getRelativePosition().y));\n-                        points.add(p);\n-                        if (curEdge.to.inOffsets.containsKey(curEdge.relativeTo)) {\n-                            points.add(new Point(p.x, p.y + curEdge.to.inOffsets.get(curEdge.relativeTo) + ((curEdge.link == null) ? 0 : curEdge.link.getTo().getRelativePosition().y)));\n-                        }\n+        public static void reverseEdge(LayoutEdge edge) {\n+            edge.reverse();\n@@ -394,6 +140,4 @@\n-                        if (cur.succs.isEmpty() && cur.vertex == null) {\n-                            if (reversedLinkStartPoints.containsKey(e.link)) {\n-                                for (Point p1 : reversedLinkStartPoints.get(e.link)) {\n-                                    points.add(0, new Point(p1.x + other.x, p1.y + other.y));\n-                                }\n-                            }\n+            LayoutNode fromNode = edge.getFrom();\n+            LayoutNode toNode = edge.getTo();\n+            int relativeFrom = edge.getRelativeFromX();\n+            int relativeTo = edge.getRelativeToX();\n@@ -401,3 +145,4 @@\n-                            if (splitEndPoints.containsKey(e.link)) {\n-                                points.add(null);\n-                                points.addAll(splitEndPoints.get(e.link));\n+            edge.setFrom(toNode);\n+            edge.setTo(fromNode);\n+            edge.setRelativeFromX(relativeTo);\n+            edge.setRelativeToX(relativeFrom);\n@@ -405,9 +150,5 @@\n-                                if (reversedLinks.contains(e.link)) {\n-                                    Collections.reverse(points);\n-                                }\n-                                assert !linkPositions.containsKey(e.link);\n-                                linkPositions.put(e.link, points);\n-                            } else {\n-                                splitStartPoints.put(e.link, points);\n-                            }\n-                        } else {\n+            fromNode.removeSuccessor(edge);\n+            fromNode.addPredecessor(edge);\n+            toNode.removePredecessor(edge);\n+            toNode.addSuccessor(edge);\n+        }\n@@ -415,16 +156,3 @@\n-                            if (reversedLinkStartPoints.containsKey(e.link)) {\n-                                for (Point p1 : reversedLinkStartPoints.get(e.link)) {\n-                                    points.add(0, new Point(p1.x + other.x + other.xOffset, p1.y + other.y));\n-                                }\n-                            }\n-                            if (reversedLinkEndPoints.containsKey(e.link)) {\n-                                for (Point p1 : reversedLinkEndPoints.get(e.link)) {\n-                                    points.add(new Point(p1.x + cur.x + cur.xOffset, p1.y + cur.y));\n-                                }\n-                            }\n-                            if (reversedLinks.contains(e.link)) {\n-                                Collections.reverse(points);\n-                            }\n-                            assert !linkPositions.containsKey(e.link);\n-                            linkPositions.put(e.link, points);\n-                        }\n+        private static void depthFirstSearch(LayoutGraph graph) {\n+            Set<LayoutNode> visited = new HashSet<>();\n+            Set<LayoutNode> active = new HashSet<>();\n@@ -432,4 +160,3 @@\n-                        pointCount += points.size();\n-                    }\n-                }\n-            }\n+            for (LayoutNode startNode : graph.getLayoutNodes()) {\n+                Deque<LayoutNode> stack = new ArrayDeque<>();\n+                stack.push(startNode);\n@@ -437,7 +164,2 @@\n-            int minX = Integer.MAX_VALUE;\n-            int minY = Integer.MAX_VALUE;\n-            for (Vertex v : vertexPositions.keySet()) {\n-                Point p = vertexPositions.get(v);\n-                minX = Math.min(minX, p.x);\n-                minY = Math.min(minY, p.y);\n-            }\n+                while (!stack.isEmpty()) {\n+                    LayoutNode node = stack.pop();\n@@ -445,6 +167,3 @@\n-            for (Link l : linkPositions.keySet()) {\n-                List<Point> points = linkPositions.get(l);\n-                for (Point p : points) {\n-                    if (p != null) {\n-                        minX = Math.min(minX, p.x);\n-                        minY = Math.min(minY, p.y);\n+                    if (visited.contains(node)) {\n+                        active.remove(node);\n+                        continue;\n@@ -452,3 +171,0 @@\n-                }\n-\n-            }\n@@ -456,6 +172,3 @@\n-            for (Vertex v : vertexPositions.keySet()) {\n-                Point p = vertexPositions.get(v);\n-                p.x -= minX;\n-                p.y -= minY;\n-                v.setPosition(p);\n-            }\n+                    stack.push(node);\n+                    visited.add(node);\n+                    active.add(node);\n@@ -463,6 +176,7 @@\n-            for (Link l : linkPositions.keySet()) {\n-                List<Point> points = linkPositions.get(l);\n-                for (Point p : points) {\n-                    if (p != null) {\n-                        p.x -= minX;\n-                        p.y -= minY;\n+                    for (LayoutEdge edge : new ArrayList<>(node.getSuccessors())) {\n+                        LayoutNode successor = edge.getTo();\n+                        if (active.contains(successor)) {\n+                            reverseEdge(edge);\n+                        } else if (!visited.contains(successor)) {\n+                            stack.push(successor);\n+                        }\n@@ -471,11 +185,0 @@\n-                l.setControlPoints(points);\n-\n-            }\n-        }\n-\n-        @Override\n-        protected void printStatistics() {\n-            System.out.println(\"Number of nodes: \" + nodes.size());\n-            int edgeCount = 0;\n-            for (LayoutNode n : nodes) {\n-                edgeCount += n.succs.size();\n@@ -483,2 +186,0 @@\n-            System.out.println(\"Number of edges: \" + edgeCount);\n-            System.out.println(\"Number of points: \" + pointCount);\n@@ -488,78 +189,1 @@\n-    public static final Comparator<LayoutNode> nodePositionComparator = Comparator.comparingInt(n -> n.pos);\n-    public static final Comparator<LayoutNode> nodeProcessingDownComparator = (n1, n2) -> {\n-        int n1VIP = 0;\n-        for (LayoutEdge e : n1.preds) {\n-            if (e.vip) {\n-                n1VIP++;\n-            }\n-        }\n-        int n2VIP = 0;\n-        for (LayoutEdge e : n2.preds) {\n-            if (e.vip) {\n-                n2VIP++;\n-            }\n-        }\n-        if (n1VIP != n2VIP) {\n-            return n2VIP - n1VIP;\n-        }\n-        if (n1.vertex == null) {\n-            if (n2.vertex == null) {\n-                return 0;\n-            }\n-            return -1;\n-        }\n-        if (n2.vertex == null) {\n-            return 1;\n-        }\n-        return n1.preds.size() - n2.preds.size();\n-    };\n-    public static final Comparator<LayoutNode> nodeProcessingUpComparator = (n1, n2) -> {\n-        int n1VIP = 0;\n-        for (LayoutEdge e : n1.succs) {\n-            if (e.vip) {\n-                n1VIP++;\n-            }\n-        }\n-        int n2VIP = 0;\n-        for (LayoutEdge e : n2.succs) {\n-            if (e.vip) {\n-                n2VIP++;\n-            }\n-        }\n-        if (n1VIP != n2VIP) {\n-            return n2VIP - n1VIP;\n-        }\n-        if (n1.vertex == null) {\n-            if (n2.vertex == null) {\n-                return 0;\n-            }\n-            return -1;\n-        }\n-        if (n2.vertex == null) {\n-            return 1;\n-        }\n-        return n1.succs.size() - n2.succs.size();\n-    };\n-\n-    private class AssignXCoordinates extends AlgorithmPart {\n-\n-        private ArrayList<Integer>[] space;\n-        private ArrayList<LayoutNode>[] downProcessingOrder;\n-        private ArrayList<LayoutNode>[] upProcessingOrder;\n-\n-        private void initialPositions() {\n-            for (LayoutNode n : nodes) {\n-                n.x = space[n.layer].get(n.pos);\n-            }\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        private void createArrays() {\n-            space = new ArrayList[layers.length];\n-            downProcessingOrder = new ArrayList[layers.length];\n-            upProcessingOrder = new ArrayList[layers.length];\n-        }\n-\n-        @Override\n-        protected void run() {\n-            createArrays();\n+    public static class LayerManager {\n@@ -567,4 +191,2 @@\n-            for (int i = 0; i < layers.length; i++) {\n-                space[i] = new ArrayList<>();\n-                downProcessingOrder[i] = new ArrayList<>();\n-                upProcessingOrder[i] = new ArrayList<>();\n+        private static void assignLayerDownwards(LayoutGraph graph) {\n+            ArrayList<LayoutNode> workingList = new ArrayList<>();\n@@ -572,42 +194,5 @@\n-                int curX = 0;\n-                for (LayoutNode n : layers[i]) {\n-                    space[i].add(curX);\n-                    curX += n.width + xOffset;\n-                    downProcessingOrder[i].add(n);\n-                    upProcessingOrder[i].add(n);\n-                }\n-\n-                downProcessingOrder[i].sort(nodeProcessingDownComparator);\n-                upProcessingOrder[i].sort(nodeProcessingUpComparator);\n-            }\n-\n-            initialPositions();\n-            for (int i = 0; i < SWEEP_ITERATIONS; i++) {\n-                sweepDown();\n-                adjustSpace();\n-                sweepUp();\n-                adjustSpace();\n-            }\n-\n-            sweepDown();\n-            adjustSpace();\n-            sweepUp();\n-        }\n-\n-        private void adjustSpace() {\n-            for (int i = 0; i < layers.length; i++) {\n-                for (LayoutNode n : layers[i]) {\n-                    space[i].add(n.x);\n-                }\n-            }\n-        }\n-\n-        private int calculateOptimalDown(LayoutNode n) {\n-            int size = n.preds.size();\n-            if (size == 0) {\n-                return n.x;\n-            }\n-            int vipCount = 0;\n-            for (LayoutEdge e : n.preds) {\n-                if (e.vip) {\n-                    vipCount++;\n+            \/\/ add all root nodes to layer 0\n+            for (LayoutNode node : graph.getLayoutNodes()) {\n+                if (!node.hasPredecessors()) {\n+                    workingList.add(node);\n+                    node.setLayer(0);\n@@ -617,14 +202,24 @@\n-            if (vipCount == 0) {\n-                int[] values = new int[size];\n-                for (int i = 0; i < size; i++) {\n-                    LayoutEdge e = n.preds.get(i);\n-                    values[i] = e.from.x + e.relativeFrom - e.relativeTo;\n-                }\n-                return Statistics.median(values);\n-            } else {\n-                int z = 0;\n-                int[] values = new int[vipCount];\n-                for (int i = 0; i < size; i++) {\n-                    LayoutEdge e = n.preds.get(i);\n-                    if (e.vip) {\n-                        values[z++] = e.from.x + e.relativeFrom - e.relativeTo;\n+            \/\/ assign layers downwards starting from roots\n+            int layer = 1;\n+            while (!workingList.isEmpty()) {\n+                ArrayList<LayoutNode> newWorkingList = new ArrayList<>();\n+                for (LayoutNode node : workingList) {\n+                    for (LayoutEdge succEdge : node.getSuccessors()) {\n+                        LayoutNode succNode = succEdge.getTo();\n+                        if (succNode.getLayer() == -1) {\n+                            \/\/ This node was not assigned before.\n+                            boolean assignedPred = true;\n+                            for (LayoutEdge predEdge : succNode.getPredecessors()) {\n+                                LayoutNode predNode = predEdge.getFrom();\n+                                if (predNode.getLayer() == -1 || predNode.getLayer() >= layer) {\n+                                    \/\/ This now has an unscheduled successor or a successor that was scheduled only in this round.\n+                                    assignedPred = false;\n+                                    break;\n+                                }\n+                            }\n+                            if (assignedPred) {\n+                                \/\/ This successor node can be assigned.\n+                                succNode.setLayer(layer);\n+                                newWorkingList.add(succNode);\n+                            }\n+                        }\n@@ -633,15 +228,2 @@\n-                return Statistics.median(values);\n-            }\n-        }\n-\n-        private int calculateOptimalBoth(LayoutNode n) {\n-            if (n.preds.size() == n.succs.size()) {\n-                return n.x;\n-            }\n-\n-            int[] values = new int[n.preds.size() + n.succs.size()];\n-            int i = 0;\n-\n-            for (LayoutEdge e : n.preds) {\n-                values[i] = e.from.x + e.relativeFrom - e.relativeTo;\n-                i++;\n+                workingList = newWorkingList;\n+                layer++;\n@@ -650,3 +232,3 @@\n-            for (LayoutEdge e : n.succs) {\n-                values[i] = e.to.x + e.relativeTo - e.relativeFrom;\n-                i++;\n+            int layerCount = layer - 1;\n+            for (LayoutNode n : graph.getLayoutNodes()) {\n+                n.setLayer((layerCount - 1 - n.getLayer()));\n@@ -654,2 +236,0 @@\n-\n-            return Statistics.median(values);\n@@ -658,15 +238,31 @@\n-        private int calculateOptimalUp(LayoutNode n) {\n-            int size = n.succs.size();\n-            if (size == 0) {\n-                return n.x;\n-            }\n-            int[] values = new int[size];\n-            for (int i = 0; i < size; i++) {\n-                LayoutEdge e = n.succs.get(i);\n-                values[i] = e.to.x + e.relativeTo - e.relativeFrom;\n-                if (e.vip) {\n-                    return values[i];\n-                }\n-            }\n-            return Statistics.median(values);\n-        }\n+        private static void assignLayerUpwards(LayoutGraph graph) {\n+            ArrayList<LayoutNode> workingList = new ArrayList<>();\n+            \/\/ add all leaves to working list, reset layer of non-leave nodes\n+            for (LayoutNode node : graph.getLayoutNodes()) {\n+                if (!node.hasSuccessors()) {\n+                    workingList.add(node);\n+                } else {\n+                    node.setLayer(-1);\n+                }\n+            }\n+\n+            \/\/ assign layer upwards starting from leaves\n+            \/\/ sinks non-leave nodes down as much as possible\n+            int layer = 1;\n+            while (!workingList.isEmpty()) {\n+                ArrayList<LayoutNode> newWorkingList = new ArrayList<>();\n+                for (LayoutNode node : workingList) {\n+                    if (node.getLayer() < layer) {\n+                        for (LayoutEdge predEdge : node.getPredecessors()) {\n+                            LayoutNode predNode = predEdge.getFrom();\n+                            if (predNode.getLayer() == -1) {\n+                                \/\/ This node was not assigned before.\n+                                boolean assignedSucc = true;\n+                                for (LayoutEdge succEdge : predNode.getSuccessors()) {\n+                                    LayoutNode succNode = succEdge.getTo();\n+                                    if (succNode.getLayer() == -1 || succNode.getLayer() >= layer) {\n+                                        \/\/ This now has an unscheduled successor or a successor that was scheduled only in this round.\n+                                        assignedSucc = false;\n+                                        break;\n+                                    }\n+                                }\n@@ -674,6 +270,10 @@\n-        private void sweepUp() {\n-            for (int i = layers.length - 1; i >= 0; i--) {\n-                NodeRow r = new NodeRow(space[i]);\n-                for (LayoutNode n : upProcessingOrder[i]) {\n-                    int optimal = calculateOptimalUp(n);\n-                    r.insert(n, optimal);\n+                                if (assignedSucc) {\n+                                    \/\/ This predecessor node can be assigned.\n+                                    predNode.setLayer(layer);\n+                                    newWorkingList.add(predNode);\n+                                }\n+                            }\n+                        }\n+                    } else {\n+                        newWorkingList.add(node);\n+                    }\n@@ -681,2 +281,0 @@\n-            }\n-        }\n@@ -684,7 +282,2 @@\n-        private void sweepDown() {\n-            for (int i = 1; i < layers.length; i++) {\n-                NodeRow r = new NodeRow(space[i]);\n-                for (LayoutNode n : downProcessingOrder[i]) {\n-                    int optimal = calculateOptimalDown(n);\n-                    r.insert(n, optimal);\n-                }\n+                workingList = newWorkingList;\n+                layer++;\n@@ -692,2 +285,0 @@\n-        }\n-    }\n@@ -695,25 +286,3 @@\n-    public static class NodeRow {\n-\n-        private final TreeSet<LayoutNode> treeSet;\n-        private final ArrayList<Integer> space;\n-\n-        public NodeRow(ArrayList<Integer> space) {\n-            treeSet = new TreeSet<>(nodePositionComparator);\n-            this.space = space;\n-        }\n-\n-        public int offset(LayoutNode n1, LayoutNode n2) {\n-            int v1 = space.get(n1.pos) + n1.width;\n-            int v2 = space.get(n2.pos);\n-            return v2 - v1;\n-        }\n-\n-        public void insert(LayoutNode n, int pos) {\n-\n-            SortedSet<LayoutNode> headSet = treeSet.headSet(n);\n-\n-            LayoutNode leftNeighbor;\n-            int minX = Integer.MIN_VALUE;\n-            if (!headSet.isEmpty()) {\n-                leftNeighbor = headSet.last();\n-                minX = leftNeighbor.x + leftNeighbor.width + offset(leftNeighbor, n);\n+            int layerCount = layer - 1;\n+            for (LayoutNode n : graph.getLayoutNodes()) {\n+                n.setLayer((layerCount - 1 - n.getLayer()));\n@@ -722,29 +291,1 @@\n-            if (pos < minX) {\n-                n.x = minX;\n-            } else {\n-\n-                LayoutNode rightNeighbor;\n-                SortedSet<LayoutNode> tailSet = treeSet.tailSet(n);\n-                int maxX = Integer.MAX_VALUE;\n-                if (!tailSet.isEmpty()) {\n-                    rightNeighbor = tailSet.first();\n-                    maxX = rightNeighbor.x - offset(n, rightNeighbor) - n.width;\n-                }\n-\n-                n.x = Math.min(pos, maxX);\n-\n-                assert minX <= maxX : minX + \" vs \" + maxX;\n-            }\n-\n-            treeSet.add(n);\n-        }\n-    }\n-    private static final Comparator<LayoutNode> crossingNodeComparator = Comparator.comparingInt(n -> n.crossingNumber);\n-\n-    private class CrossingReduction extends AlgorithmPart {\n-\n-        @Override\n-        public void preCheck() {\n-            for (LayoutNode n : nodes) {\n-                assert n.layer < layerCount;\n-            }\n+            graph.initLayers(layerCount);\n@@ -753,3 +294,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        private void createLayers() {\n-            layers = new List[layerCount];\n@@ -757,3 +295,3 @@\n-            for (int i = 0; i < layerCount; i++) {\n-                layers[i] = new ArrayList<>();\n-            }\n+        static private void assignLayers(LayoutGraph graph) {\n+            assignLayerDownwards(graph);\n+            assignLayerUpwards(graph);\n@@ -762,3 +300,3 @@\n-        @Override\n-        protected void run() {\n-            createLayers();\n+        static private void createDummyNodes(LayoutGraph graph, int maxLayerLength) {\n+            List<LayoutNode> layoutNodes = new ArrayList<>(graph.getLayoutNodes());\n+            layoutNodes.sort(LAYOUT_NODE_DEGREE_COMPARATOR);\n@@ -768,7 +306,7 @@\n-            for (LayoutNode n : nodes) {\n-                if (n.layer == 0) {\n-                    layers[0].add(n);\n-                    visited.add(n);\n-                } else if (n.preds.isEmpty()) {\n-                    layers[n.layer].add(n);\n-                    visited.add(n);\n+            for (LayoutNode layoutNode : layoutNodes) {\n+                if (layoutNode.getLayer() == 0) {\n+                    graph.getLayer(0).add(layoutNode);\n+                    visited.add(layoutNode);\n+                } else if (!layoutNode.hasPredecessors()) {\n+                    graph.getLayer(layoutNode.getLayer()).add(layoutNode);\n+                    visited.add(layoutNode);\n@@ -778,9 +316,12 @@\n-            for (int i = 0; i < layers.length - 1; i++) {\n-                for (LayoutNode n : layers[i]) {\n-                    for (LayoutEdge e : n.succs) {\n-                        if (!visited.contains(e.to)) {\n-                            visited.add(e.to);\n-                            layers[i + 1].add(e.to);\n-                            if (!nodes.contains(e.to)) {\n-                                nodes.add(e.to);\n-                            }\n+            for (LayoutNode layoutNode : layoutNodes) {\n+                graph.createDummiesForNodeSuccessor(layoutNode, maxLayerLength);\n+            }\n+\n+            for (int i = 0; i < graph.getLayerCount() - 1; i++) {\n+                for (LayoutNode n : graph.getLayer(i)) {\n+                    for (LayoutEdge e : n.getSuccessors()) {\n+                        if (e.getTo().isDummy()) continue;\n+                        if (!visited.contains(e.getTo())) {\n+                            visited.add(e.getTo());\n+                            graph.getLayer(i + 1).add(e.getTo());\n+                            e.getTo().setLayer(i + 1);\n@@ -791,11 +332,0 @@\n-\n-            updatePositions();\n-\n-            initX();\n-\n-            \/\/ Optimize\n-            for (int i = 0; i < CROSSING_ITERATIONS; i++) {\n-                downSweep();\n-                upSweep();\n-            }\n-            downSweep();\n@@ -804,5 +334,4 @@\n-        private void initX() {\n-\n-            for (int i = 0; i < layers.length; i++) {\n-                updateXOfLayer(i);\n-            }\n+        static public void apply(LayoutGraph graph, int maxLayerLength) {\n+            assignLayers(graph);\n+            createDummyNodes(graph, maxLayerLength);\n+            graph.updatePositions();\n@@ -810,0 +339,1 @@\n+    }\n@@ -811,2 +341,1 @@\n-        private void updateXOfLayer(int index) {\n-            int x = 0;\n+    static class CrossingReduction {\n@@ -814,3 +343,4 @@\n-            for (LayoutNode n : layers[index]) {\n-                n.x = x;\n-                x += n.width + xOffset;\n+        public static void apply(LayoutGraph graph) {\n+            for (int i = 0; i < graph.getLayerCount(); i++) {\n+                graph.getLayer(i).updateNodeIndices();\n+                graph.getLayer(i).initXPositions();\n@@ -818,1 +348,0 @@\n-        }\n@@ -820,7 +349,3 @@\n-        private void updatePositions() {\n-            for (List<LayoutNode> layer : layers) {\n-                int z = 0;\n-                for (LayoutNode n : layer) {\n-                    n.pos = z;\n-                    z++;\n-                }\n+            for (int i = 0; i < CROSSING_ITERATIONS; i++) {\n+                downSweep(graph);\n+                upSweep(graph);\n@@ -828,0 +353,1 @@\n+            downSweep(graph);\n@@ -830,4 +356,1 @@\n-        private void downSweep() {\n-\n-            \/\/ Downsweep\n-            for (int i = 1; i < layerCount; i++) {\n+        private static void downSweep(LayoutGraph graph) {\n@@ -835,2 +358,3 @@\n-                for (LayoutNode n : layers[i]) {\n-                    n.crossingNumber = 0;\n+            for (int i = 1; i < graph.getLayerCount(); i++) {\n+                for (LayoutNode n : graph.getLayer(i)) {\n+                    n.setCrossingNumber(0);\n@@ -838,3 +362,1 @@\n-\n-                for (LayoutNode n : layers[i]) {\n-\n+                for (LayoutNode n : graph.getLayer(i)) {\n@@ -843,8 +365,3 @@\n-                    for (LayoutEdge e : n.preds) {\n-                        int cur = e.from.x + e.relativeFrom;\n-                        int factor = 1;\n-                        if (e.vip) {\n-                            factor = VIP_BONUS;\n-                        }\n-                        sum += cur * factor;\n-                        count += factor;\n+                    for (LayoutEdge e : n.getPredecessors()) {\n+                        sum += e.getStartX();\n+                        count++;\n@@ -855,1 +372,1 @@\n-                        n.crossingNumber = sum;\n+                        n.setCrossingNumber(sum);\n@@ -858,10 +375,4 @@\n-\n-                updateCrossingNumbers(i, true);\n-                layers[i].sort(crossingNodeComparator);\n-                updateXOfLayer(i);\n-\n-                int z = 0;\n-                for (LayoutNode n : layers[i]) {\n-                    n.pos = z;\n-                    z++;\n-                }\n+                updateCrossingNumbers(graph.getLayer(i), true);\n+                graph.getLayer(i).sort(NODE_CROSSING_COMPARATOR);\n+                graph.getLayer(i).initXPositions();\n+                graph.getLayer(i).updateNodeIndices();\n@@ -871,3 +382,3 @@\n-        private void updateCrossingNumbers(int index, boolean down) {\n-            for (int i = 0; i < layers[index].size(); i++) {\n-                LayoutNode n = layers[index].get(i);\n+        private static void updateCrossingNumbers(LayoutLayer layer, boolean down) {\n+            for (int i = 0; i < layer.size(); i++) {\n+                LayoutNode n = layer.get(i);\n@@ -876,1 +387,1 @@\n-                    prev = layers[index].get(i - 1);\n+                    prev = layer.get(i - 1);\n@@ -879,2 +390,2 @@\n-                if (i < layers[index].size() - 1) {\n-                    next = layers[index].get(i + 1);\n+                if (i < layer.size() - 1) {\n+                    next = layer.get(i + 1);\n@@ -882,2 +393,1 @@\n-\n-                boolean cond = n.succs.isEmpty();\n+                boolean cond = !n.hasSuccessors();\n@@ -885,1 +395,1 @@\n-                    cond = n.preds.isEmpty();\n+                    cond = !n.hasPredecessors();\n@@ -887,1 +397,0 @@\n-\n@@ -889,1 +398,0 @@\n-\n@@ -891,1 +399,1 @@\n-                        n.crossingNumber = (prev.crossingNumber + next.crossingNumber) \/ 2;\n+                        n.setCrossingNumber((prev.getCrossingNumber() + next.getCrossingNumber()) \/ 2);\n@@ -893,1 +401,1 @@\n-                        n.crossingNumber = prev.crossingNumber;\n+                        n.setCrossingNumber(prev.getCrossingNumber());\n@@ -895,1 +403,1 @@\n-                        n.crossingNumber = next.crossingNumber;\n+                        n.setCrossingNumber(next.getCrossingNumber());\n@@ -901,6 +409,4 @@\n-        private void upSweep() {\n-            \/\/ Upsweep\n-            for (int i = layerCount - 2; i >= 0; i--) {\n-\n-                for (LayoutNode n : layers[i]) {\n-                    n.crossingNumber = 0;\n+        private static void upSweep(LayoutGraph graph) {\n+            for (int i = graph.getLayerCount() - 2; i >= 0; i--) {\n+                for (LayoutNode n : graph.getLayer(i)) {\n+                    n.setCrossingNumber(0);\n@@ -908,3 +414,1 @@\n-\n-                for (LayoutNode n : layers[i]) {\n-\n+                for (LayoutNode n : graph.getLayer(i)) {\n@@ -913,8 +417,3 @@\n-                    for (LayoutEdge e : n.succs) {\n-                        int cur = e.to.x + e.relativeTo;\n-                        int factor = 1;\n-                        if (e.vip) {\n-                            factor = VIP_BONUS;\n-                        }\n-                        sum += cur * factor;\n-                        count += factor;\n+                    for (LayoutEdge e : n.getSuccessors()) {\n+                        sum += e.getEndX();\n+                        count++;\n@@ -922,1 +421,0 @@\n-\n@@ -925,1 +423,1 @@\n-                        n.crossingNumber = sum;\n+                        n.setCrossingNumber(sum);\n@@ -929,10 +427,4 @@\n-\n-                updateCrossingNumbers(i, false);\n-                layers[i].sort(crossingNodeComparator);\n-                updateXOfLayer(i);\n-\n-                int z = 0;\n-                for (LayoutNode n : layers[i]) {\n-                    n.pos = z;\n-                    z++;\n-                }\n+                updateCrossingNumbers(graph.getLayer(i), false);\n+                graph.getLayer(i).sort(NODE_CROSSING_COMPARATOR);\n+                graph.getLayer(i).initXPositions();\n+                graph.getLayer(i).updateNodeIndices();\n@@ -941,14 +433,0 @@\n-\n-        @Override\n-        public void postCheck() {\n-\n-            HashSet<LayoutNode> visited = new HashSet<>();\n-            for (int i = 0; i < layers.length; i++) {\n-                for (LayoutNode n : layers[i]) {\n-                    assert !visited.contains(n);\n-                    assert n.layer == i;\n-                    visited.add(n);\n-                }\n-            }\n-\n-        }\n@@ -957,22 +435,1 @@\n-    private class AssignYCoordinates extends AlgorithmPart {\n-\n-        @Override\n-        protected void run() {\n-            int curY = 0;\n-\n-            for (List<LayoutNode> layer : layers) {\n-                int maxHeight = 0;\n-                int baseLine = 0;\n-                int bottomBaseLine = 0;\n-                for (LayoutNode n : layer) {\n-                    maxHeight = Math.max(maxHeight, n.height - n.yOffset - n.bottomYOffset);\n-                    baseLine = Math.max(baseLine, n.yOffset);\n-                    bottomBaseLine = Math.max(bottomBaseLine, n.bottomYOffset);\n-                }\n-\n-                int maxXOffset = 0;\n-                for (LayoutNode n : layer) {\n-                    if (n.vertex == null) {\n-                        \/\/ Dummy node\n-                        n.y = curY;\n-                        n.height = maxHeight + baseLine + bottomBaseLine;\n+    static class AssignXCoordinates {\n@@ -980,3 +437,3 @@\n-                    } else {\n-                        n.y = curY + baseLine + (maxHeight - (n.height - n.yOffset - n.bottomYOffset)) \/ 2 - n.yOffset;\n-                    }\n+        private static List<ArrayList<Integer>> space;\n+        private static List<ArrayList<LayoutNode>> downProcessingOrder;\n+        private static List<ArrayList<LayoutNode>> upProcessingOrder;\n@@ -984,4 +441,4 @@\n-                    for (LayoutEdge e : n.succs) {\n-                        int curXOffset = Math.abs(n.x - e.to.x);\n-                        maxXOffset = Math.max(curXOffset, maxXOffset);\n-                    }\n+        private static final Comparator<LayoutNode> nodeProcessingDownComparator = (n1, n2) -> {\n+            if (n1.isDummy()) {\n+                if (n2.isDummy()) {\n+                    return 0;\n@@ -989,3 +446,1 @@\n-\n-                curY += maxHeight + baseLine + bottomBaseLine;\n-                curY += layerOffset + ((int) (Math.sqrt(maxXOffset) * 1.5));\n+                return -1;\n@@ -993,15 +448,5 @@\n-        }\n-    }\n-\n-    private class CreateDummyNodes extends AlgorithmPart {\n-\n-        private int oldNodeCount;\n-\n-        @Override\n-        protected void preCheck() {\n-            for (LayoutNode n : nodes) {\n-                for (LayoutEdge e : n.succs) {\n-                    assert e.from != null;\n-                    assert e.from == n;\n-                    assert e.from.layer < e.to.layer;\n-                }\n+            if (n2.isDummy()) {\n+                return 1;\n+            }\n+            return n1.getInDegree() - n2.getInDegree();\n+        };\n@@ -1009,3 +454,4 @@\n-                for (LayoutEdge e : n.preds) {\n-                    assert e.to != null;\n-                    assert e.to == n;\n+        private static final Comparator<LayoutNode> nodeProcessingUpComparator = (n1, n2) -> {\n+            if (n1.isDummy()) {\n+                if (n2.isDummy()) {\n+                    return 0;\n@@ -1013,0 +459,1 @@\n+                return -1;\n@@ -1014,98 +461,5 @@\n-        }\n-\n-        @Override\n-        protected void run() {\n-            oldNodeCount = nodes.size();\n-\n-            if (combine == Combine.SAME_OUTPUTS) {\n-\n-                Comparator<LayoutEdge> comparator = Comparator.comparingInt(e -> e.to.layer);\n-                HashMap<Integer, List<LayoutEdge>> portHash = new HashMap<>();\n-                ArrayList<LayoutNode> currentNodes = new ArrayList<>(nodes);\n-                for (LayoutNode n : currentNodes) {\n-                    portHash.clear();\n-\n-                    ArrayList<LayoutEdge> succs = new ArrayList<>(n.succs);\n-                    HashMap<Integer, LayoutNode> topNodeHash = new HashMap<>();\n-                    HashMap<Integer, HashMap<Integer, LayoutNode>> bottomNodeHash = new HashMap<>();\n-                    for (LayoutEdge e : succs) {\n-                        assert e.from.layer < e.to.layer;\n-                        if (e.from.layer != e.to.layer - 1) {\n-                            if (maxLayerLength != -1 && e.to.layer - e.from.layer > maxLayerLength) {\n-                                assert maxLayerLength > 2;\n-                                e.to.preds.remove(e);\n-                                e.from.succs.remove(e);\n-\n-                                LayoutEdge topEdge;\n-\n-                                if (combine == Combine.SAME_OUTPUTS && topNodeHash.containsKey(e.relativeFrom)) {\n-                                    LayoutNode topNode = topNodeHash.get(e.relativeFrom);\n-                                    topEdge = new LayoutEdge();\n-                                    topEdge.relativeFrom = e.relativeFrom;\n-                                    topEdge.from = e.from;\n-                                    topEdge.relativeTo = topNode.width \/ 2;\n-                                    topEdge.to = topNode;\n-                                    topEdge.link = e.link;\n-                                    topEdge.vip = e.vip;\n-                                    e.from.succs.add(topEdge);\n-                                    topNode.preds.add(topEdge);\n-                                } else {\n-\n-                                    LayoutNode topNode = new LayoutNode();\n-                                    topNode.layer = e.from.layer + 1;\n-                                    topNode.width = DUMMY_WIDTH;\n-                                    topNode.height = DUMMY_HEIGHT;\n-                                    nodes.add(topNode);\n-                                    topEdge = new LayoutEdge();\n-                                    topEdge.relativeFrom = e.relativeFrom;\n-                                    topEdge.from = e.from;\n-                                    topEdge.relativeTo = 0;\n-                                    topEdge.to = topNode;\n-                                    topEdge.link = e.link;\n-                                    topEdge.vip = e.vip;\n-                                    e.from.succs.add(topEdge);\n-                                    topNode.preds.add(topEdge);\n-                                    topNodeHash.put(e.relativeFrom, topNode);\n-                                    bottomNodeHash.put(e.relativeFrom, new HashMap<>());\n-                                }\n-\n-                                HashMap<Integer, LayoutNode> hash = bottomNodeHash.get(e.relativeFrom);\n-\n-                                LayoutNode bottomNode;\n-                                if (hash.containsKey(e.to.layer)) {\n-                                    bottomNode = hash.get(e.to.layer);\n-                                } else {\n-\n-                                    bottomNode = new LayoutNode();\n-                                    bottomNode.layer = e.to.layer - 1;\n-                                    bottomNode.width = DUMMY_WIDTH;\n-                                    bottomNode.height = DUMMY_HEIGHT;\n-                                    nodes.add(bottomNode);\n-                                    hash.put(e.to.layer, bottomNode);\n-                                }\n-\n-                                LayoutEdge bottomEdge = new LayoutEdge();\n-                                bottomEdge.relativeTo = e.relativeTo;\n-                                bottomEdge.to = e.to;\n-                                bottomEdge.relativeFrom = bottomNode.width \/ 2;\n-                                bottomEdge.from = bottomNode;\n-                                bottomEdge.link = e.link;\n-                                bottomEdge.vip = e.vip;\n-                                e.to.preds.add(bottomEdge);\n-                                bottomNode.succs.add(bottomEdge);\n-\n-                            } else {\n-                                Integer i = e.relativeFrom;\n-                                if (!portHash.containsKey(i)) {\n-                                    portHash.put(i, new ArrayList<>());\n-                                }\n-                                portHash.get(i).add(e);\n-                            }\n-                        }\n-                    }\n-\n-                    succs = new ArrayList<>(n.succs);\n-                    for (LayoutEdge e : succs) {\n-\n-                        Integer i = e.relativeFrom;\n-                        if (portHash.containsKey(i)) {\n+            if (n2.isDummy()) {\n+                return 1;\n+            }\n+            return n1.getOutDegree() - n2.getOutDegree();\n+        };\n@@ -1113,2 +467,4 @@\n-                            List<LayoutEdge> list = portHash.get(i);\n-                            list.sort(comparator);\n+        public static void apply(LayoutGraph graph) {\n+            space = new ArrayList<>(graph.getLayerCount());\n+            downProcessingOrder = new ArrayList<>(graph.getLayerCount());\n+            upProcessingOrder = new ArrayList<>(graph.getLayerCount());\n@@ -1116,3 +472,5 @@\n-                            if (list.size() == 1) {\n-                                processSingleEdge(list.get(0));\n-                            } else {\n+            for (int i = 0; i < graph.getLayerCount(); i++) {\n+                \/\/ Add a new empty list for each layer\n+                space.add(new ArrayList<>());\n+                downProcessingOrder.add(new ArrayList<>());\n+                upProcessingOrder.add(new ArrayList<>());\n@@ -1120,4 +478,5 @@\n-                                int maxLayer = list.get(0).to.layer;\n-                                for (LayoutEdge curEdge : list) {\n-                                    maxLayer = Math.max(maxLayer, curEdge.to.layer);\n-                                }\n+                int curX = 0;\n+                for (LayoutNode n : graph.getLayer(i)) {\n+                    \/\/ Add the current position to space and increment curX\n+                    space.get(i).add(curX);\n+                    curX += n.getOuterWidth() + NODE_OFFSET;\n@@ -1125,30 +484,4 @@\n-                                int cnt = maxLayer - n.layer - 1;\n-                                LayoutEdge[] edges = new LayoutEdge[cnt];\n-                                LayoutNode[] nodes = new LayoutNode[cnt];\n-                                edges[0] = new LayoutEdge();\n-                                edges[0].from = n;\n-                                edges[0].relativeFrom = i;\n-                                edges[0].vip = e.vip;\n-                                n.succs.add(edges[0]);\n-\n-                                nodes[0] = new LayoutNode();\n-                                nodes[0].width = dummyWidth;\n-                                nodes[0].height = dummyHeight;\n-                                nodes[0].layer = n.layer + 1;\n-                                nodes[0].preds.add(edges[0]);\n-                                edges[0].to = nodes[0];\n-                                edges[0].relativeTo = nodes[0].width \/ 2;\n-                                for (int j = 1; j < cnt; j++) {\n-                                    edges[j] = new LayoutEdge();\n-                                    edges[j].vip = e.vip;\n-                                    edges[j].from = nodes[j - 1];\n-                                    edges[j].relativeFrom = nodes[j - 1].width \/ 2;\n-                                    nodes[j - 1].succs.add(edges[j]);\n-                                    nodes[j] = new LayoutNode();\n-                                    nodes[j].width = dummyWidth;\n-                                    nodes[j].height = dummyHeight;\n-                                    nodes[j].layer = n.layer + j + 1;\n-                                    nodes[j].preds.add(edges[j]);\n-                                    edges[j].to = nodes[j];\n-                                    edges[j].relativeTo = nodes[j].width \/ 2;\n-                                }\n+                    \/\/ Add the current node to processing orders\n+                    downProcessingOrder.get(i).add(n);\n+                    upProcessingOrder.get(i).add(n);\n+                }\n@@ -1156,9 +489,4 @@\n-                                for (LayoutEdge curEdge : list) {\n-                                    assert curEdge.to.layer - n.layer - 2 >= 0;\n-                                    assert curEdge.to.layer - n.layer - 2 < cnt;\n-                                    LayoutNode anchor = nodes[curEdge.to.layer - n.layer - 2];\n-                                    anchor.succs.add(curEdge);\n-                                    curEdge.from = anchor;\n-                                    curEdge.relativeFrom = anchor.width \/ 2;\n-                                    n.succs.remove(curEdge);\n-                                }\n+                \/\/ Sort the processing orders\n+                downProcessingOrder.get(i).sort(nodeProcessingDownComparator);\n+                upProcessingOrder.get(i).sort(nodeProcessingUpComparator);\n+            }\n@@ -1166,1 +494,3 @@\n-                            }\n+            for (LayoutNode n : graph.getLayoutNodes()) {\n+                n.setX(space.get(n.getLayer()).get(n.getPos()));\n+            }\n@@ -1168,13 +498,2 @@\n-                            portHash.remove(i);\n-                        }\n-                    }\n-                }\n-            } else if (combine == Combine.SAME_INPUTS) {\n-                throw new UnsupportedOperationException(\"Currently not supported\");\n-            } else {\n-                ArrayList<LayoutNode> currentNodes = new ArrayList<>(nodes);\n-                for (LayoutNode n : currentNodes) {\n-                    for (LayoutEdge e : List.copyOf(n.succs)) {\n-                        processSingleEdge(e);\n-                    }\n-                }\n+            for (LayoutNode n : graph.getDummyNodes()) {\n+                n.setX(space.get(n.getLayer()).get(n.getPos()));\n@@ -1182,1 +501,0 @@\n-        }\n@@ -1184,7 +502,5 @@\n-        private void processSingleEdge(LayoutEdge e) {\n-            LayoutNode n = e.to;\n-            if (e.to.layer - 1 > e.from.layer) {\n-                LayoutEdge last = e;\n-                for (int i = n.layer - 1; i > last.from.layer; i--) {\n-                    last = addBetween(last, i);\n-                }\n+            for (int i = 0; i < SWEEP_ITERATIONS; i++) {\n+                sweepDown(graph);\n+                adjustSpace(graph);\n+                sweepUp(graph);\n+                adjustSpace(graph);\n@@ -1192,1 +508,0 @@\n-        }\n@@ -1194,20 +509,3 @@\n-        private LayoutEdge addBetween(LayoutEdge e, int layer) {\n-            LayoutNode n = new LayoutNode();\n-            n.width = DUMMY_WIDTH;\n-            n.height = DUMMY_HEIGHT;\n-            n.layer = layer;\n-            n.succs.add(e);\n-            nodes.add(n);\n-            LayoutEdge result = new LayoutEdge();\n-            result.vip = e.vip;\n-            n.preds.add(result);\n-            result.to = n;\n-            result.relativeTo = n.width \/ 2;\n-            result.from = e.from;\n-            result.relativeFrom = e.relativeFrom;\n-            result.link = e.link;\n-            e.relativeFrom = n.width \/ 2;\n-            e.from.succs.remove(e);\n-            e.from.succs.add(result);\n-            e.from = n;\n-            return result;\n+            sweepDown(graph);\n+            adjustSpace(graph);\n+            sweepUp(graph);\n@@ -1216,3 +514,6 @@\n-        @Override\n-        public void printStatistics() {\n-            System.out.println(\"Dummy nodes created: \" + (nodes.size() - oldNodeCount));\n+        private static void adjustSpace(LayoutGraph graph) {\n+            for (int i = 0; i < graph.getLayerCount(); i++) {\n+                for (LayoutNode n : graph.getLayer(i)) {\n+                    space.get(i).add(n.getX());\n+                }\n+            }\n@@ -1221,6 +522,6 @@\n-        @Override\n-        public void postCheck() {\n-            ArrayList<LayoutNode> currentNodes = new ArrayList<>(nodes);\n-            for (LayoutNode n : currentNodes) {\n-                for (LayoutEdge e : n.succs) {\n-                    assert e.from.layer == e.to.layer - 1;\n+        private static void sweepUp(LayoutGraph graph) {\n+            for (int i = graph.getLayerCount() - 1; i >= 0; i--) {\n+                NodeRow r = new NodeRow(space.get(i));\n+                for (LayoutNode n : upProcessingOrder.get(i)) {\n+                    int optimal = n.calculateOptimalXFromSuccessors(true);\n+                    r.insert(n, optimal);\n@@ -1229,0 +530,1 @@\n+        }\n@@ -1230,4 +532,6 @@\n-            for (int i = 0; i < layers.length; i++) {\n-                assert layers[i].size() > 0;\n-                for (LayoutNode n : layers[i]) {\n-                    assert n.layer == i;\n+        private static void sweepDown(LayoutGraph graph) {\n+            for (int i = 1; i < graph.getLayerCount(); i++) {\n+                NodeRow r = new NodeRow(space.get(i));\n+                for (LayoutNode n : downProcessingOrder.get(i)) {\n+                    int optimal = n.calculateOptimalXFromPredecessors(true);\n+                    r.insert(n, optimal);\n@@ -1239,1 +543,1 @@\n-    private class AssignLayers extends AlgorithmPart {\n+    public static class NodeRow {\n@@ -1241,5 +545,6 @@\n-        @Override\n-        public void preCheck() {\n-            for (LayoutNode n : nodes) {\n-                assert n.layer == -1;\n-            }\n+        private final TreeSet<LayoutNode> treeSet;\n+        private final ArrayList<Integer> space;\n+\n+        public NodeRow(ArrayList<Integer> space) {\n+            treeSet = new TreeSet<>(NODE_POS_COMPARATOR);\n+            this.space = space;\n@@ -1248,4 +553,4 @@\n-        @Override\n-        protected void run() {\n-            assignLayerDownwards();\n-            assignLayerUpwards();\n+        public int offset(LayoutNode n1, LayoutNode n2) {\n+            int v1 = space.get(n1.getPos()) + n1.getOuterWidth();\n+            int v2 = space.get(n2.getPos());\n+            return v2 - v1;\n@@ -1254,7 +559,9 @@\n-        private void assignLayerDownwards() {\n-            ArrayList<LayoutNode> hull = new ArrayList<>();\n-            for (LayoutNode n : nodes) {\n-                if (n.preds.isEmpty()) {\n-                    hull.add(n);\n-                    n.layer = 0;\n-                }\n+        public void insert(LayoutNode n, int pos) {\n+\n+            SortedSet<LayoutNode> headSet = treeSet.headSet(n);\n+\n+            LayoutNode leftNeighbor;\n+            int minX = Integer.MIN_VALUE;\n+            if (!headSet.isEmpty()) {\n+                leftNeighbor = headSet.last();\n+                minX = leftNeighbor.getOuterRight() + offset(leftNeighbor, n);\n@@ -1263,18 +570,3 @@\n-            int z = minLayerDifference;\n-            while (!hull.isEmpty()) {\n-                ArrayList<LayoutNode> newSet = new ArrayList<>();\n-                for (LayoutNode n : hull) {\n-                    for (LayoutEdge se : n.succs) {\n-                        LayoutNode s = se.to;\n-                        if (s.layer != -1) {\n-                            \/\/ This node was assigned before.\n-                        } else {\n-                            boolean unassignedPred = false;\n-                            for (LayoutEdge pe : s.preds) {\n-                                LayoutNode p = pe.from;\n-                                if (p.layer == -1 || p.layer >= z) {\n-                                    \/\/ This now has an unscheduled successor or a successor that was scheduled only in this round.\n-                                    unassignedPred = true;\n-                                    break;\n-                                }\n-                            }\n+            if (pos < minX) {\n+                n.setX(minX);\n+            } else {\n@@ -1282,8 +574,6 @@\n-                            if (unassignedPred) {\n-                                \/\/ This successor node can not yet be assigned.\n-                            } else {\n-                                s.layer = z;\n-                                newSet.add(s);\n-                            }\n-                        }\n-                    }\n+                LayoutNode rightNeighbor;\n+                SortedSet<LayoutNode> tailSet = treeSet.tailSet(n);\n+                int maxX = Integer.MAX_VALUE;\n+                if (!tailSet.isEmpty()) {\n+                    rightNeighbor = tailSet.first();\n+                    maxX = rightNeighbor.getX() - offset(n, rightNeighbor) - n.getOuterWidth();\n@@ -1292,2 +582,1 @@\n-                hull = newSet;\n-                z += minLayerDifference;\n+                n.setX(Math.min(pos, maxX));\n@@ -1296,4 +585,1 @@\n-            layerCount = z - minLayerDifference;\n-            for (LayoutNode n : nodes) {\n-                n.layer = (layerCount - 1 - n.layer);\n-            }\n+            treeSet.add(n);\n@@ -1301,0 +587,1 @@\n+    }\n@@ -1302,9 +589,1 @@\n-        private void assignLayerUpwards() {\n-            ArrayList<LayoutNode> hull = new ArrayList<>();\n-            for (LayoutNode n : nodes) {\n-                if (n.succs.isEmpty()) {\n-                    hull.add(n);\n-                } else {\n-                    n.layer = -1;\n-                }\n-            }\n+    public static class WriteResult {\n@@ -1312,19 +591,30 @@\n-            int z = minLayerDifference;\n-            while (!hull.isEmpty()) {\n-                ArrayList<LayoutNode> newSet = new ArrayList<>();\n-                for (LayoutNode n : hull) {\n-                    if (n.layer < z) {\n-                        for (LayoutEdge se : n.preds) {\n-                            LayoutNode s = se.from;\n-                            if (s.layer != -1) {\n-                                \/\/ This node was assigned before.\n-                            } else {\n-                                boolean unassignedSucc = false;\n-                                for (LayoutEdge pe : s.succs) {\n-                                    LayoutNode p = pe.to;\n-                                    if (p.layer == -1 || p.layer >= z) {\n-                                        \/\/ This now has an unscheduled successor or a successor that was scheduled only in this round.\n-                                        unassignedSucc = true;\n-                                        break;\n-                                    }\n-                                }\n+        private static HashMap<Link, List<Point>> computeLinkPositions(LayoutGraph graph) {\n+            HashMap<Link, List<Point>> linkToSplitEndPoints = new HashMap<>();\n+            HashMap<Link, List<Point>> linkPositions = new HashMap<>();\n+\n+            for (LayoutNode layoutNode : graph.getLayoutNodes()) {\n+                for (LayoutEdge predEdge : layoutNode.getPredecessors()) {\n+                    LayoutNode fromNode = predEdge.getFrom();\n+                    LayoutNode toNode = predEdge.getTo();\n+\n+                    ArrayList<Point> linkPoints = new ArrayList<>();\n+                    \/\/ input edge stub\n+                    linkPoints.add(new Point(predEdge.getEndX(), predEdge.getEndY()));\n+                    linkPoints.add(new Point(predEdge.getEndX(), graph.getLayer(toNode.getLayer()).getTop() - LAYER_OFFSET));\n+\n+                    LayoutEdge curEdge = predEdge;\n+                    while (fromNode.isDummy() && fromNode.hasPredecessors()) {\n+                        linkPoints.add(new Point(fromNode.getCenterX(), graph.getLayer(fromNode.getLayer()).getBottom() + LAYER_OFFSET));\n+                        linkPoints.add(new Point(fromNode.getCenterX(), graph.getLayer(fromNode.getLayer()).getTop() - LAYER_OFFSET));\n+                        curEdge = fromNode.getPredecessors().get(0);\n+                        fromNode = curEdge.getFrom();\n+                    }\n+                    linkPoints.add(new Point(curEdge.getStartX(), graph.getLayer(fromNode.getLayer()).getBottom() + LAYER_OFFSET));\n+                    \/\/ output edge stub\n+                    linkPoints.add(new Point(curEdge.getStartX(), curEdge.getStartY()));\n+\n+                    if (predEdge.isReversed()) {\n+                        for (Point relativeEnd : toNode.getReversedLinkEndPoints().get(predEdge.getLink())) {\n+                            Point endPoint = new Point(toNode.getLeft() + relativeEnd.x, toNode.getTop() + relativeEnd.y);\n+                            linkPoints.add(0, endPoint);\n+                        }\n@@ -1332,5 +622,5 @@\n-                                if (unassignedSucc) {\n-                                    \/\/ This predecessor node can not yet be assigned.\n-                                } else {\n-                                    s.layer = z;\n-                                    newSet.add(s);\n+                        if (!fromNode.isDummy()) {\n+                            if (fromNode.getReversedLinkStartPoints().containsKey(predEdge.getLink())) {\n+                                for (Point relativeStart : fromNode.getReversedLinkStartPoints().get(predEdge.getLink())) {\n+                                    Point startPoint = new Point(fromNode.getLeft() + relativeStart.x, fromNode.getTop() + relativeStart.y);\n+                                    linkPoints.add(startPoint);\n@@ -1341,1 +631,1 @@\n-                        newSet.add(n);\n+                        Collections.reverse(linkPoints);\n@@ -1343,1 +633,0 @@\n-                }\n@@ -1345,39 +634,3 @@\n-                hull = newSet;\n-                z += minLayerDifference;\n-            }\n-\n-            layerCount = z - minLayerDifference;\n-\n-            for (LayoutNode n : nodes) {\n-                n.layer = (layerCount - 1 - n.layer);\n-            }\n-        }\n-\n-        @Override\n-        public void postCheck() {\n-            for (LayoutNode n : nodes) {\n-                assert n.layer >= 0;\n-                assert n.layer < layerCount;\n-                for (LayoutEdge e : n.succs) {\n-                    assert e.from.layer < e.to.layer;\n-                }\n-            }\n-        }\n-    }\n-\n-    private class ReverseEdges extends AlgorithmPart {\n-\n-        private HashSet<LayoutNode> visited;\n-        private HashSet<LayoutNode> active;\n-\n-        @Override\n-        protected void run() {\n-\n-            \/\/ Reverse inputs of roots\n-            for (LayoutNode node : nodes) {\n-                if (node.vertex.isRoot()) {\n-                    boolean ok = true;\n-                    for (LayoutEdge e : node.preds) {\n-                        if (e.from.vertex.isRoot()) {\n-                            ok = false;\n-                            break;\n+                    if (fromNode.isDummy()) {\n+                        if (predEdge.isReversed()) {\n+                            Collections.reverse(linkPoints);\n@@ -1385,3 +638,4 @@\n-                    }\n-                    if (ok) {\n-                        reverseAllInputs(node);\n+                        linkToSplitEndPoints.put(predEdge.getLink(), linkPoints);\n+\n+                    } else {\n+                        linkPositions.put(predEdge.getLink(), linkPoints);\n@@ -1392,6 +646,3 @@\n-            \/\/ Start DFS and reverse back edges\n-            visited = new HashSet<>();\n-            active = new HashSet<>();\n-            for (LayoutNode node : nodes) {\n-                DFS(node);\n-            }\n+            for (LayoutNode layoutNode : graph.getLayoutNodes()) {\n+                for (LayoutEdge succEdge : layoutNode.getSuccessors()) {\n+                    if (succEdge.getLink() == null) continue;\n@@ -1399,1 +650,2 @@\n-            for (LayoutNode node : nodes) {\n+                    LayoutNode fromNode = succEdge.getFrom();\n+                    LayoutNode toNode = succEdge.getTo();\n@@ -1401,1 +653,3 @@\n-                SortedSet<Integer> reversedDown = new TreeSet<>();\n+                    ArrayList<Point> linkPoints = new ArrayList<>();\n+                    linkPoints.add(new Point(succEdge.getStartX(), fromNode.getBottom()));\n+                    linkPoints.add(new Point(succEdge.getStartX(), graph.getLayer(fromNode.getLayer()).getBottom() + LAYER_OFFSET));\n@@ -1403,7 +657,6 @@\n-                boolean hasSelfEdge = false;\n-                for (LayoutEdge e : node.succs) {\n-                    if (reversedLinks.contains(e.link)) {\n-                        reversedDown.add(e.relativeFrom);\n-                        if (e.from == e.to) {\n-                            hasSelfEdge = true;\n-                        }\n+                    LayoutEdge curEdge = succEdge;\n+                    while (toNode.isDummy() && toNode.hasSuccessors()) {\n+                        linkPoints.add(new Point(toNode.getCenterX(), graph.getLayer(toNode.getLayer()).getTop() - LAYER_OFFSET));\n+                        linkPoints.add(new Point(toNode.getCenterX(), graph.getLayer(toNode.getLayer()).getBottom() + LAYER_OFFSET));\n+                        curEdge = toNode.getSuccessors().get(0);\n+                        toNode = curEdge.getTo();\n@@ -1411,1 +664,2 @@\n-                }\n+                    linkPoints.add(new Point(curEdge.getEndX(), graph.getLayer(toNode.getLayer()).getTop() - LAYER_OFFSET));\n+                    linkPoints.add(new Point(curEdge.getEndX(), toNode.getTop()));\n@@ -1413,5 +667,2 @@\n-                \/\/ Whether the node has non-self reversed edges going downwards.\n-                \/\/ If so, reversed edges going upwards are drawn to the left.\n-                boolean hasReversedDown =\n-                    reversedDown.size() > 0 &&\n-                    !(reversedDown.size() == 1 && hasSelfEdge);\n+                    if (succEdge.isReversed()) {\n+                        Collections.reverse(linkPoints);\n@@ -1419,23 +670,5 @@\n-                SortedSet<Integer> reversedUp = null;\n-                if (hasReversedDown) {\n-                    reversedUp = new TreeSet<>();\n-                } else {\n-                    reversedUp = new TreeSet<>(Collections.reverseOrder());\n-                }\n-\n-                for (LayoutEdge e : node.preds) {\n-                    if (reversedLinks.contains(e.link)) {\n-                        reversedUp.add(e.relativeTo);\n-                    }\n-                }\n-\n-                final int offset = xOffset + DUMMY_WIDTH;\n-\n-                int curY = 0;\n-                int curWidth = node.width + reversedDown.size() * offset;\n-                for (int pos : reversedDown) {\n-                    ArrayList<LayoutEdge> reversedSuccs = new ArrayList<>();\n-                    for (LayoutEdge e : node.succs) {\n-                        if (e.relativeFrom == pos && reversedLinks.contains(e.link)) {\n-                            reversedSuccs.add(e);\n-                            e.relativeFrom = curWidth;\n+                        if (fromNode.getReversedLinkStartPoints().containsKey(succEdge.getLink())) {\n+                            for (Point relativeStart : fromNode.getReversedLinkStartPoints().get(succEdge.getLink())) {\n+                                Point startPoint = new Point(fromNode.getLeft() + relativeStart.x, fromNode.getTop() + relativeStart.y);\n+                                linkPoints.add(startPoint);\n+                            }\n@@ -1443,28 +676,0 @@\n-                    }\n-\n-                    ArrayList<Point> startPoints = new ArrayList<>();\n-                    startPoints.add(new Point(curWidth, curY));\n-                    startPoints.add(new Point(pos, curY));\n-                    startPoints.add(new Point(pos, reversedDown.size() * offset));\n-                    for (LayoutEdge e : reversedSuccs) {\n-                        reversedLinkStartPoints.put(e.link, startPoints);\n-                    }\n-\n-                    node.inOffsets.put(pos, -curY);\n-                    curY += offset;\n-                    node.height += offset;\n-                    node.yOffset += offset;\n-                    curWidth -= offset;\n-                }\n-\n-                int widthFactor = reversedDown.size();\n-                if (hasSelfEdge) {\n-                    widthFactor--;\n-                }\n-                node.width += widthFactor * offset;\n-\n-                int curX = 0;\n-                int minX = 0;\n-                if (hasReversedDown) {\n-                    minX = -offset * reversedUp.size();\n-                }\n@@ -1472,9 +677,6 @@\n-                int oldNodeHeight = node.height;\n-                for (int pos : reversedUp) {\n-                    ArrayList<LayoutEdge> reversedPreds = new ArrayList<>();\n-                    for (LayoutEdge e : node.preds) {\n-                        if (e.relativeTo == pos && reversedLinks.contains(e.link)) {\n-                            if (hasReversedDown) {\n-                                e.relativeTo = curX - offset;\n-                            } else {\n-                                e.relativeTo = node.width + offset;\n+                        if (!toNode.isDummy()) {\n+                            if (toNode.getReversedLinkEndPoints().containsKey(succEdge.getLink())) {\n+                                for (Point relativeEnd : toNode.getReversedLinkEndPoints().get(succEdge.getLink())) {\n+                                    Point endPoint = new Point(toNode.getLeft() + relativeEnd.x, toNode.getTop() + relativeEnd.y);\n+                                    linkPoints.add(0, endPoint);\n+                                }\n@@ -1482,2 +684,0 @@\n-\n-                            reversedPreds.add(e);\n@@ -1486,15 +686,0 @@\n-                    node.height += offset;\n-                    ArrayList<Point> endPoints = new ArrayList<>();\n-\n-                    node.width += offset;\n-                    if (hasReversedDown) {\n-                        curX -= offset;\n-                        endPoints.add(new Point(curX, node.height));\n-                    } else {\n-                        curX += offset;\n-                        endPoints.add(new Point(node.width, node.height));\n-                    }\n-\n-                    node.outOffsets.put(pos - minX, curX);\n-                    curX += offset;\n-                    node.bottomYOffset += offset;\n@@ -1502,4 +687,9 @@\n-                    endPoints.add(new Point(pos, node.height));\n-                    endPoints.add(new Point(pos, oldNodeHeight));\n-                    for (LayoutEdge e : reversedPreds) {\n-                        reversedLinkEndPoints.put(e.link, endPoints);\n+                    if (linkToSplitEndPoints.containsKey(succEdge.getLink())) {\n+                        if (succEdge.isReversed()) {\n+                            Collections.reverse(linkPoints);\n+                        }\n+                        linkPoints.add(null);\n+                        linkPoints.addAll(linkToSplitEndPoints.get(succEdge.getLink()));\n+                        if (succEdge.isReversed()) {\n+                            Collections.reverse(linkPoints);\n+                        }\n@@ -1507,0 +697,1 @@\n+                    linkPositions.put(succEdge.getLink(), linkPoints);\n@@ -1508,0 +699,1 @@\n+            }\n@@ -1509,7 +701,9 @@\n-                if (minX < 0) {\n-                    for (LayoutEdge e : node.preds) {\n-                        e.relativeTo -= minX;\n-                    }\n-\n-                    for (LayoutEdge e : node.succs) {\n-                        e.relativeFrom -= minX;\n+            if (graph.showSelfEdges()) {\n+                for (LayoutNode layoutNode : graph.getLayoutNodes()) {\n+                    if (layoutNode.hasSelfEdge()) {\n+                        LayoutEdge selfEdge = layoutNode.getSelfEdge();\n+                        ArrayList<Point> points = layoutNode.getSelfEdgePoints();\n+                        for (Point point : points) {\n+                            point.setLocation(point.getX() + layoutNode.getLeft(), point.getY() + layoutNode.getTop());\n+                        }\n+                        linkPositions.put(selfEdge.getLink(), points);\n@@ -1517,3 +711,0 @@\n-\n-                    node.xOffset = -minX;\n-                    node.width += -minX;\n@@ -1523,0 +714,1 @@\n+            return linkPositions;\n@@ -1525,7 +717,3 @@\n-        private void DFS(LayoutNode startNode) {\n-            if (visited.contains(startNode)) {\n-                return;\n-            }\n-\n-            Stack<LayoutNode> stack = new Stack<>();\n-            stack.push(startNode);\n+        public static void apply(LayoutGraph graph) {\n+            \/\/ Assign Y coordinates\n+            graph.positionLayers();\n@@ -1533,2 +721,2 @@\n-            while (!stack.empty()) {\n-                LayoutNode node = stack.pop();\n+            int minX = Integer.MAX_VALUE;\n+            int minY = Integer.MAX_VALUE;\n@@ -1536,5 +724,1 @@\n-                if (visited.contains(node)) {\n-                    \/\/ Node no longer active\n-                    active.remove(node);\n-                    continue;\n-                }\n+            HashMap<Link, List<Point>> linkPositions = computeLinkPositions(graph);\n@@ -1542,13 +726,5 @@\n-                \/\/ Repush immediately to know when no longer active\n-                stack.push(node);\n-                visited.add(node);\n-                active.add(node);\n-\n-                ArrayList<LayoutEdge> succs = new ArrayList<>(node.succs);\n-                for (LayoutEdge e : succs) {\n-                    if (active.contains(e.to)) {\n-                        assert visited.contains(e.to);\n-                        \/\/ Encountered back edge\n-                        reverseEdge(e);\n-                    } else if (!visited.contains(e.to) && (linksToFollow.size() == 0 || linksToFollow.contains(e.link))) {\n-                        stack.push(e.to);\n+            for (List<Point> points : linkPositions.values()) {\n+                for (Point point : points) {\n+                    if (point != null) {\n+                        minX = Math.min(minX, point.x);\n+                        minY = Math.min(minY, point.y);\n@@ -1558,1 +734,0 @@\n-        }\n@@ -1560,13 +735,3 @@\n-        private void reverseAllInputs(LayoutNode node) {\n-            for (LayoutEdge e : node.preds) {\n-                assert !reversedLinks.contains(e.link);\n-                reversedLinks.add(e.link);\n-                node.succs.add(e);\n-                e.from.preds.add(e);\n-                e.from.succs.remove(e);\n-                int oldRelativeFrom = e.relativeFrom;\n-                int oldRelativeTo = e.relativeTo;\n-                e.to = e.from;\n-                e.from = node;\n-                e.relativeFrom = oldRelativeTo;\n-                e.relativeTo = oldRelativeFrom;\n+            for (LayoutNode layoutNode : graph.getLayoutNodes()) {\n+                minX = Math.min(minX, layoutNode.getX());\n+                minY = Math.min(minY, layoutNode.getY());\n@@ -1574,6 +739,0 @@\n-            node.preds.clear();\n-        }\n-\n-        private void reverseEdge(LayoutEdge e) {\n-            assert !reversedLinks.contains(e.link);\n-            reversedLinks.add(e.link);\n@@ -1581,40 +740,3 @@\n-            LayoutNode oldFrom = e.from;\n-            LayoutNode oldTo = e.to;\n-            int oldRelativeFrom = e.relativeFrom;\n-            int oldRelativeTo = e.relativeTo;\n-\n-            e.from = oldTo;\n-            e.to = oldFrom;\n-            e.relativeFrom = oldRelativeTo;\n-            e.relativeTo = oldRelativeFrom;\n-\n-            oldFrom.succs.remove(e);\n-            oldFrom.preds.add(e);\n-            oldTo.preds.remove(e);\n-            oldTo.succs.add(e);\n-        }\n-\n-        @Override\n-        public void postCheck() {\n-\n-            for (LayoutNode n : nodes) {\n-\n-                HashSet<LayoutNode> curVisited = new HashSet<>();\n-                Queue<LayoutNode> queue = new LinkedList<>();\n-                for (LayoutEdge e : n.succs) {\n-                    LayoutNode s = e.to;\n-                    queue.add(s);\n-                    curVisited.add(s);\n-                }\n-\n-                while (!queue.isEmpty()) {\n-                    LayoutNode curNode = queue.remove();\n-\n-                    for (LayoutEdge e : curNode.succs) {\n-                        assert e.to != n;\n-                        if (!curVisited.contains(e.to)) {\n-                            queue.add(e.to);\n-                            curVisited.add(e.to);\n-                        }\n-                    }\n-                }\n+            for (LayoutNode dummyNode : graph.getDummyNodes()) {\n+                minX = Math.min(minX, dummyNode.getX());\n+                minY = Math.min(minY, dummyNode.getY());\n@@ -1622,6 +744,0 @@\n-        }\n-    }\n-    private final Comparator<Link> linkComparator = (l1, l2) -> {\n-        if (l1.isVIP() && !l2.isVIP()) {\n-            return -1;\n-        }\n@@ -1629,38 +745,2 @@\n-        if (!l1.isVIP() && l2.isVIP()) {\n-            return 1;\n-        }\n-\n-        int result = l1.getFrom().getVertex().compareTo(l2.getFrom().getVertex());\n-        if (result != 0) {\n-            return result;\n-        }\n-        result = l1.getTo().getVertex().compareTo(l2.getTo().getVertex());\n-        if (result != 0) {\n-            return result;\n-        }\n-        result = l1.getFrom().getRelativePosition().x - l2.getFrom().getRelativePosition().x;\n-        if (result != 0) {\n-            return result;\n-        }\n-        result = l1.getTo().getRelativePosition().x - l2.getTo().getRelativePosition().x;\n-        return result;\n-    };\n-\n-    private class BuildDatastructure extends AlgorithmPart {\n-\n-        @Override\n-        protected void run() {\n-            \/\/ Set up nodes\n-            List<Vertex> vertices = new ArrayList<>(graph.getVertices());\n-            \/\/ Order roots first to create more natural layer assignments.\n-            vertices.sort((Vertex a, Vertex b) ->\n-                    a.isRoot() == b.isRoot() ? a.compareTo(b) : Boolean.compare(b.isRoot(), a.isRoot()));\n-\n-            for (Vertex v : vertices) {\n-                LayoutNode node = new LayoutNode();\n-                Dimension size = v.getSize();\n-                node.width = (int) size.getWidth();\n-                node.height = (int) size.getHeight();\n-                node.vertex = v;\n-                nodes.add(node);\n-                vertexToLayoutNode.put(v, node);\n+            for (LayoutLayer layer : graph.getLayers()) {\n+                minY = Math.min(minY, layer.getTop());\n@@ -1669,15 +749,3 @@\n-            \/\/ Set up edges\n-            List<Link> links = new ArrayList<>(graph.getLinks());\n-            links.sort(linkComparator);\n-            for (Link l : links) {\n-                LayoutEdge edge = new LayoutEdge();\n-                assert vertexToLayoutNode.containsKey(l.getFrom().getVertex());\n-                assert vertexToLayoutNode.containsKey(l.getTo().getVertex());\n-                edge.from = vertexToLayoutNode.get(l.getFrom().getVertex());\n-                edge.to = vertexToLayoutNode.get(l.getTo().getVertex());\n-                edge.relativeFrom = l.getFrom().getRelativePosition().x;\n-                edge.relativeTo = l.getTo().getRelativePosition().x;\n-                edge.link = l;\n-                edge.vip = l.isVIP();\n-                edge.from.succs.add(edge);\n-                edge.to.preds.add(edge);\n+            for (LayoutNode layoutNode : graph.getLayoutNodes()) {\n+                layoutNode.setX(layoutNode.getX() - minX);\n+                layoutNode.setY(layoutNode.getY() - minY);\n@@ -1685,13 +753,3 @@\n-\n-            for (Link l : importantLinks) {\n-                if (!vertexToLayoutNode.containsKey(l.getFrom().getVertex())\n-                        || vertexToLayoutNode.containsKey(l.getTo().getVertex())) {\n-                    continue;\n-                }\n-                LayoutNode from = vertexToLayoutNode.get(l.getFrom().getVertex());\n-                LayoutNode to = vertexToLayoutNode.get(l.getTo().getVertex());\n-                for (LayoutEdge e : from.succs) {\n-                    if (e.to == to) {\n-                        linksToFollow.add(e.link);\n-                    }\n-                }\n+            for (LayoutNode dummyNode : graph.getDummyNodes()) {\n+                dummyNode.setX(dummyNode.getX() - minX);\n+                dummyNode.setY(dummyNode.getY() - minY);\n@@ -1699,4 +757,0 @@\n-        }\n-\n-        @Override\n-        public void postCheck() {\n@@ -1704,7 +758,3 @@\n-            assert vertexToLayoutNode.keySet().size() == nodes.size();\n-            assert nodes.size() == graph.getVertices().size();\n-\n-            for (Vertex v : graph.getVertices()) {\n-\n-                LayoutNode node = vertexToLayoutNode.get(v);\n-                assert node != null;\n+            for (LayoutLayer layer : graph.getLayers()) {\n+                layer.moveLayerVertically(-minY);\n+            }\n@@ -1712,3 +762,5 @@\n-                for (LayoutEdge e : node.succs) {\n-                    assert e.from == node;\n-                }\n+            \/\/ Shift vertices by minX\/minY\n+            for (LayoutNode layoutNode : graph.getLayoutNodes()) {\n+                Vertex vertex = layoutNode.getVertex();\n+                vertex.setPosition(new Point(layoutNode.getLeft(), layoutNode.getTop()));\n+            }\n@@ -1716,2 +768,9 @@\n-                for (LayoutEdge e : node.preds) {\n-                    assert e.to == node;\n+            \/\/ shift links by minX\/minY\n+            for (Map.Entry<Link, List<Point>> entry : linkPositions.entrySet()) {\n+                Link link = entry.getKey();\n+                List<Point> points = entry.getValue();\n+                for (Point p : points) {\n+                    if (p != null) {\n+                        p.x -= minX;\n+                        p.y -= minY;\n+                    }\n@@ -1720,0 +779,2 @@\n+                \/\/ write points back to links\n+                link.setControlPoints(points);\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalLayoutManager.java","additions":512,"deletions":1451,"binary":false,"changes":1963,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,2 @@\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutManager.LAYER_OFFSET;\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutManager.NODE_OFFSET;\n@@ -29,1 +30,0 @@\n-import com.sun.hotspot.igv.util.Statistics;\n@@ -36,4 +36,0 @@\n-    public static final int DUMMY_HEIGHT = 1;\n-    public static final int DUMMY_WIDTH = 1;\n-    public static final int X_OFFSET = 8;\n-    public static final int LAYER_OFFSET = 8;\n@@ -46,3 +42,1 @@\n-    private HashMap<Link, List<Point>> reversedLinkStartPoints;\n-    private HashMap<Link, List<Point>> reversedLinkEndPoints;\n-    private HashMap<Integer, List<LayoutNode>> layers;\n+    private HashMap<Integer, LayoutLayer> layers;\n@@ -97,1 +91,1 @@\n-        manager = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n+        manager = new HierarchicalLayoutManager();\n@@ -112,2 +106,2 @@\n-        if (n.preds.isEmpty() && n.succs.isEmpty()) {\n-            return n.x;\n+        if (n.getPredecessors().isEmpty() && n.getSuccessors().isEmpty()) {\n+            return n.getX();\n@@ -116,1 +110,1 @@\n-        int[] values = new int[n.preds.size() + n.succs.size()];\n+        int[] values = new int[n.getPredecessors().size() + n.getSuccessors().size()];\n@@ -119,2 +113,2 @@\n-        for (LayoutEdge e : n.preds) {\n-            values[i] = e.from.x + e.relativeFrom - e.relativeTo;\n+        for (LayoutEdge e : n.getPredecessors()) {\n+            values[i] = e.getFrom().getX() + e.getRelativeFromX() - e.getRelativeToX();\n@@ -124,2 +118,2 @@\n-        for (LayoutEdge e : n.succs) {\n-            values[i] = e.to.x + e.relativeTo - e.relativeFrom;\n+        for (LayoutEdge e : n.getSuccessors()) {\n+            values[i] = e.getTo().getX() + e.getRelativeToX() - e.getRelativeFromX();\n@@ -129,1 +123,1 @@\n-        return Statistics.median(values);\n+        return median(values);\n@@ -132,0 +126,22 @@\n+    public static int median(int[] values) {\n+        Arrays.sort(values);\n+        if (values.length % 2 == 0) {\n+            return (values[values.length \/ 2 - 1] + values[values.length \/ 2]) \/ 2;\n+        } else {\n+            return values[values.length \/ 2];\n+        }\n+    }\n+\n+    public static final Comparator<LayoutNode> nodeProcessingUpComparator = (n1, n2) -> {\n+        if (n1.getVertex() == null) {\n+            if (n2.getVertex() == null) {\n+                return 0;\n+            }\n+            return -1;\n+        }\n+        if (n2.getVertex() == null) {\n+            return 1;\n+        }\n+        return n1.getSuccessors().size() - n2.getSuccessors().size();\n+    };\n+\n@@ -141,1 +157,1 @@\n-        nodes.sort(HierarchicalLayoutManager.nodePositionComparator);\n+        nodes.sort(Comparator.comparingInt(LayoutNode::getPos));\n@@ -146,1 +162,1 @@\n-            curX += n.width + X_OFFSET;\n+            curX += n.getOuterWidth() + NODE_OFFSET;\n@@ -150,1 +166,1 @@\n-        nodeProcessingOrder.sort(HierarchicalLayoutManager.nodeProcessingUpComparator);\n+        nodeProcessingOrder.sort(nodeProcessingUpComparator);\n@@ -160,2 +176,2 @@\n-            n.succs.removeIf(e -> !nodes.contains(e.to));\n-            n.preds.removeIf(e -> !nodes.contains(e.from));\n+            n.getSuccessorsRaw().removeIf(e -> !nodes.contains(e.getTo()));\n+            n.getPredecessorsRaw().removeIf(e -> !nodes.contains(e.getFrom()));\n@@ -251,2 +267,2 @@\n-                    if (vertexToLayoutNode.get(l.getFrom().getVertex()).layer > vertexToLayoutNode\n-                            .get(l.getTo().getVertex()).layer) {\n+                    if (vertexToLayoutNode.get(l.getFrom().getVertex()).getLayer() > vertexToLayoutNode\n+                            .get(l.getTo().getVertex()).getLayer()) {\n@@ -268,1 +284,1 @@\n-        assert fromNode.layer > toNode.layer;\n+        assert fromNode.getLayer() > toNode.getLayer();\n@@ -276,132 +292,1 @@\n-        \/\/ Reset node data in case there were previous reversed edges\n-        node.width = (int) node.vertex.getSize().getWidth();\n-        node.height = (int) node.vertex.getSize().getHeight();\n-        node.yOffset = 0;\n-        node.bottomYOffset = 0;\n-        node.xOffset = 0;\n-        node.inOffsets.clear();\n-        node.outOffsets.clear();\n-\n-        SortedSet<Integer> reversedDown = new TreeSet<>();\n-\n-        \/\/ Reset relativeFrom for all succ edges\n-        for (LayoutEdge e : node.succs) {\n-            if (e.link == null) {\n-                continue;\n-            }\n-            e.relativeFrom = e.link.getFrom().getRelativePosition().x;\n-            if (reversedLinks.contains(e.link)) {\n-                e.relativeFrom = e.link.getTo().getRelativePosition().x;\n-                reversedDown.add(e.relativeFrom);\n-            }\n-        }\n-\n-        \/\/ Whether the node has non-self reversed edges going downwards.\n-        \/\/ If so, reversed edges going upwards are drawn to the left.\n-        boolean hasReversedDown = !reversedDown.isEmpty();\n-\n-        SortedSet<Integer> reversedUp;\n-        if (hasReversedDown) {\n-            reversedUp = new TreeSet<>();\n-        } else {\n-            reversedUp = new TreeSet<>(Collections.reverseOrder());\n-        }\n-\n-        \/\/ Reset relativeTo for all pred edges\n-        for (LayoutEdge e : node.preds) {\n-            if (e.link == null) {\n-                continue;\n-            }\n-            e.relativeTo = e.link.getTo().getRelativePosition().x;\n-            if (reversedLinks.contains(e.link)) {\n-                e.relativeTo = e.link.getFrom().getRelativePosition().x;\n-                reversedUp.add(e.relativeTo);\n-            }\n-        }\n-\n-        final int offset = X_OFFSET + DUMMY_WIDTH;\n-\n-        int curY = 0;\n-        int curWidth = node.width + reversedDown.size() * offset;\n-        for (int pos : reversedDown) {\n-            ArrayList<LayoutEdge> reversedSuccs = new ArrayList<>();\n-            for (LayoutEdge e : node.succs) {\n-                if (e.relativeFrom == pos && reversedLinks.contains(e.link)) {\n-                    reversedSuccs.add(e);\n-                    e.relativeFrom = curWidth;\n-                }\n-            }\n-\n-            ArrayList<Point> startPoints = new ArrayList<>();\n-            startPoints.add(new Point(curWidth, curY));\n-            startPoints.add(new Point(pos, curY));\n-            startPoints.add(new Point(pos, reversedDown.size() * offset));\n-            for (LayoutEdge e : reversedSuccs) {\n-                reversedLinkStartPoints.put(e.link, startPoints);\n-            }\n-\n-            node.inOffsets.put(pos, -curY);\n-            curY += offset;\n-            node.height += offset;\n-            node.yOffset += offset;\n-            curWidth -= offset;\n-        }\n-\n-        int widthFactor = reversedDown.size();\n-        node.width += widthFactor * offset;\n-\n-        int curX = 0;\n-        int minX = 0;\n-        if (hasReversedDown) {\n-            minX = -offset * reversedUp.size();\n-        }\n-\n-        int oldNodeHeight = node.height;\n-        for (int pos : reversedUp) {\n-            ArrayList<LayoutEdge> reversedPreds = new ArrayList<>();\n-            for (LayoutEdge e : node.preds) {\n-                if (e.relativeTo == pos && reversedLinks.contains(e.link)) {\n-                    if (hasReversedDown) {\n-                        e.relativeTo = curX - offset;\n-                    } else {\n-                        e.relativeTo = node.width + offset;\n-                    }\n-\n-                    reversedPreds.add(e);\n-                }\n-            }\n-            node.height += offset;\n-            ArrayList<Point> endPoints = new ArrayList<>();\n-\n-            node.width += offset;\n-            if (hasReversedDown) {\n-                curX -= offset;\n-                endPoints.add(new Point(curX, node.height));\n-            } else {\n-                curX += offset;\n-                endPoints.add(new Point(node.width, node.height));\n-            }\n-\n-            node.outOffsets.put(pos - minX, curX);\n-            curX += offset;\n-            node.bottomYOffset += offset;\n-\n-            endPoints.add(new Point(pos, node.height));\n-            endPoints.add(new Point(pos, oldNodeHeight));\n-            for (LayoutEdge e : reversedPreds) {\n-                reversedLinkEndPoints.put(e.link, endPoints);\n-            }\n-        }\n-\n-        if (minX < 0) {\n-            for (LayoutEdge e : node.preds) {\n-                e.relativeTo -= minX;\n-            }\n-\n-            for (LayoutEdge e : node.succs) {\n-                e.relativeFrom -= minX;\n-            }\n-\n-            node.xOffset = -minX;\n-            node.width -= minX;\n-        }\n+        node.computeReversedLinkPoints(false);\n@@ -421,2 +306,0 @@\n-        reversedLinkStartPoints = new HashMap<>();\n-        reversedLinkEndPoints = new HashMap<>();\n@@ -433,1 +316,1 @@\n-            nodes = manager.getNodes();\n+            nodes = new ArrayList<>(manager.getNodes());\n@@ -438,1 +321,1 @@\n-            new BuildDatastructure().run();\n+            new BuildDatastructures().run();\n@@ -474,1 +357,1 @@\n-    private class BuildDatastructure {\n+    private class BuildDatastructures {\n@@ -485,1 +368,1 @@\n-                if (node.vertex != null) {\n+                if (node.getVertex() != null) {\n@@ -487,1 +370,1 @@\n-                        if (vertex.equals(node.vertex)) {\n+                        if (vertex.equals(node.getVertex())) {\n@@ -489,2 +372,2 @@\n-                            if (node.width < (int) size.getWidth()) {\n-                                layersToUpdate.add(node.layer);\n+                            if (node.getOuterWidth() < (int) size.getWidth()) {\n+                                layersToUpdate.add(node.getLayer());\n@@ -492,3 +375,2 @@\n-                            node.width = (int) size.getWidth();\n-                            node.height = (int) size.getHeight();\n-                            node.vertex = vertex;\n+                            node.initSize();\n+                            node.setVertex(vertex);\n@@ -497,1 +379,1 @@\n-                    vertexToLayoutNode.put(node.vertex, node);\n+                    vertexToLayoutNode.put(node.getVertex(), node);\n@@ -499,2 +381,1 @@\n-                    node.height = DUMMY_HEIGHT;\n-                    node.width = DUMMY_WIDTH;\n+                    node.initSize();\n@@ -502,2 +383,2 @@\n-                for (LayoutEdge edge : node.preds) {\n-                    if (edge.link != null) {\n+                for (LayoutEdge edge : node.getPredecessors()) {\n+                    if (edge.getLink() != null) {\n@@ -505,3 +386,3 @@\n-                            if (link.equals(edge.link)) {\n-                                edge.link = link;\n-                                if (link.getTo().getVertex().equals(edge.from.vertex)) {\n+                            if (link.equals(edge.getLink())) {\n+                                edge.setLink(link);\n+                                if (link.getTo().getVertex().equals(edge.getFrom().getVertex())) {\n@@ -509,2 +390,2 @@\n-                                    edge.relativeFrom = link.getTo().getRelativePosition().x;\n-                                    edge.relativeTo = link.getFrom().getRelativePosition().x;\n+                                    edge.setRelativeFromX(link.getTo().getRelativePosition().x);\n+                                    edge.setRelativeToX(link.getFrom().getRelativePosition().x);\n@@ -512,2 +393,2 @@\n-                                    edge.relativeFrom = link.getFrom().getRelativePosition().x;\n-                                    edge.relativeTo = link.getTo().getRelativePosition().x;\n+                                    edge.setRelativeFromX(link.getFrom().getRelativePosition().x);\n+                                    edge.setRelativeToX(link.getTo().getRelativePosition().x);\n@@ -520,2 +401,2 @@\n-                for (LayoutEdge edge : node.succs) {\n-                    if (edge.link != null) {\n+                for (LayoutEdge edge : node.getSuccessors()) {\n+                    if (edge.getLink() != null) {\n@@ -523,3 +404,3 @@\n-                            if (link.equals(edge.link)) {\n-                                edge.link = link;\n-                                if (link.getTo().getVertex().equals(edge.from.vertex)) {\n+                            if (link.equals(edge.getLink())) {\n+                                edge.setLink(link);\n+                                if (link.getTo().getVertex().equals(edge.getFrom().getVertex())) {\n@@ -527,2 +408,2 @@\n-                                    edge.relativeFrom = link.getTo().getRelativePosition().x;\n-                                    edge.relativeTo = link.getFrom().getRelativePosition().x;\n+                                    edge.setRelativeFromX(link.getTo().getRelativePosition().x);\n+                                    edge.setRelativeToX(link.getFrom().getRelativePosition().x);\n@@ -530,2 +411,2 @@\n-                                    edge.relativeFrom = link.getFrom().getRelativePosition().x;\n-                                    edge.relativeTo = link.getTo().getRelativePosition().x;\n+                                    edge.setRelativeFromX(link.getFrom().getRelativePosition().x);\n+                                    edge.setRelativeToX(link.getTo().getRelativePosition().x);\n@@ -547,2 +428,2 @@\n-                if (!layers.containsKey(node.layer)) {\n-                    layers.put(node.layer, new ArrayList<>());\n+                if (!layers.containsKey(node.getLayer())) {\n+                    layers.put(node.getLayer(), new LayoutLayer());\n@@ -550,1 +431,1 @@\n-                layers.get(node.layer).add(node);\n+                layers.get(node.getLayer()).add(node);\n@@ -554,1 +435,1 @@\n-                    layers.put(i, new ArrayList<>());\n+                    layers.put(i, new LayoutLayer());\n@@ -581,1 +462,1 @@\n-            layerNodes.sort(HierarchicalLayoutManager.nodePositionComparator);\n+            layerNodes.sort(Comparator.comparingInt(LayoutNode::getPos));\n@@ -589,1 +470,1 @@\n-                    xCoord = layerNodes.get(i).x - node.width - 1;\n+                    xCoord = layerNodes.get(i).getX() - node.getOuterWidth() - 1;\n@@ -591,1 +472,1 @@\n-                    xCoord = layerNodes.get(i - 1).x + layerNodes.get(i - 1).width + 1;\n+                    xCoord = layerNodes.get(i - 1).getX() + layerNodes.get(i - 1).getOuterWidth() + 1;\n@@ -599,5 +480,5 @@\n-                    for (LayoutEdge edge : node.preds) {\n-                        if (edge.from.layer == layer - 1) {\n-                            int fromNodeXCoord = edge.from.x;\n-                            if (edge.from.vertex != null) {\n-                                fromNodeXCoord += edge.relativeFrom;\n+                    for (LayoutEdge edge : node.getPredecessors()) {\n+                        if (edge.getFrom().getLayer() == layer - 1) {\n+                            int fromNodeXCoord = edge.getFrom().getX();\n+                            if (edge.getFrom().getVertex() != null) {\n+                                fromNodeXCoord += edge.getRelativeFromX();\n@@ -606,2 +487,2 @@\n-                            if (node.vertex != null) {\n-                                toNodeXCoord += edge.relativeTo;\n+                            if (node.getVertex() != null) {\n+                                toNodeXCoord += edge.getRelativeToX();\n@@ -610,2 +491,2 @@\n-                                for (LayoutEdge e : n.succs) {\n-                                    if (e.to == null) {\n+                                for (LayoutEdge e : n.getSuccessors()) {\n+                                    if (e.getTo() == null) {\n@@ -614,3 +495,3 @@\n-                                    int compFromXCoord = e.from.x;\n-                                    if (e.from.vertex != null) {\n-                                        compFromXCoord += e.relativeFrom;\n+                                    int compFromXCoord = e.getFrom().getX();\n+                                    if (e.getFrom().getVertex() != null) {\n+                                        compFromXCoord += e.getRelativeFromX();\n@@ -618,3 +499,3 @@\n-                                    int compToXCoord = e.to.x;\n-                                    if (e.to.vertex != null) {\n-                                        compToXCoord += e.relativeTo;\n+                                    int compToXCoord = e.getTo().getX();\n+                                    if (e.getTo().getVertex() != null) {\n+                                        compToXCoord += e.getRelativeToX();\n@@ -636,5 +517,5 @@\n-                    for (LayoutEdge edge : node.succs) {\n-                        if (edge.to.layer == layer + 1) {\n-                            int toNodeXCoord = edge.to.x;\n-                            if (edge.to.vertex != null) {\n-                                toNodeXCoord += edge.relativeTo;\n+                    for (LayoutEdge edge : node.getSuccessors()) {\n+                        if (edge.getTo().getLayer() == layer + 1) {\n+                            int toNodeXCoord = edge.getTo().getX();\n+                            if (edge.getTo().getVertex() != null) {\n+                                toNodeXCoord += edge.getRelativeToX();\n@@ -643,2 +524,2 @@\n-                            if (node.vertex != null) {\n-                                fromNodeXCoord += edge.relativeFrom;\n+                            if (node.getVertex() != null) {\n+                                fromNodeXCoord += edge.getRelativeFromX();\n@@ -647,2 +528,2 @@\n-                                for (LayoutEdge e : n.preds) {\n-                                    if (e.from == null) {\n+                                for (LayoutEdge e : n.getPredecessors()) {\n+                                    if (e.getFrom() == null) {\n@@ -651,3 +532,3 @@\n-                                    int compFromXCoord = e.from.x;\n-                                    if (e.from.vertex != null) {\n-                                        compFromXCoord += e.relativeFrom;\n+                                    int compFromXCoord = e.getFrom().getX();\n+                                    if (e.getFrom().getVertex() != null) {\n+                                        compFromXCoord += e.getRelativeFromX();\n@@ -655,3 +536,3 @@\n-                                    int compToXCoord = e.to.x;\n-                                    if (e.to.vertex != null) {\n-                                        compToXCoord += e.relativeTo;\n+                                    int compToXCoord = e.getTo().getX();\n+                                    if (e.getTo().getVertex() != null) {\n+                                        compToXCoord += e.getRelativeToX();\n@@ -685,2 +566,2 @@\n-            node.layer = layer;\n-            List<LayoutNode> layerNodes = layers.getOrDefault(layer, new ArrayList<LayoutNode>());\n+            node.setLayer(layer);\n+            LayoutLayer layerNodes = layers.getOrDefault(layer, new LayoutLayer());\n@@ -689,1 +570,1 @@\n-                node.pos = 0;\n+                node.setPos(0);\n@@ -691,1 +572,1 @@\n-                node.pos = optimalPosition(node, layer);\n+                node.setPos(optimalPosition(node, layer));\n@@ -695,2 +576,2 @@\n-                if (n.pos >= node.pos) {\n-                    n.pos += 1;\n+                if (n.getPos() >= node.getPos()) {\n+                    n.setPos(n.getPos() + 1);\n@@ -705,2 +586,2 @@\n-            if (node.vertex != null) {\n-                vertexToLayoutNode.put(node.vertex, node);\n+            if (node.getVertex() != null) {\n+                vertexToLayoutNode.put(node.getVertex(), node);\n@@ -713,2 +594,2 @@\n-            LayoutNode n = e.to;\n-            if (e.to.layer - 1 > e.from.layer) {\n+            LayoutNode n = e.getTo();\n+            if (e.getTo().getLayer() - 1 > e.getFrom().getLayer()) {\n@@ -716,1 +597,1 @@\n-                for (int i = n.layer - 1; i > last.from.layer; i--) {\n+                for (int i = n.getLayer() - 1; i > last.getFrom().getLayer(); i--) {\n@@ -724,15 +605,7 @@\n-            n.width = DUMMY_WIDTH;\n-            n.height = DUMMY_HEIGHT;\n-            n.succs.add(e);\n-            LayoutEdge result = new LayoutEdge();\n-            result.vip = e.vip;\n-            n.preds.add(result);\n-            result.to = n;\n-            result.relativeTo = n.width \/ 2;\n-            result.from = e.from;\n-            result.relativeFrom = e.relativeFrom;\n-            result.link = e.link;\n-            e.relativeFrom = n.width \/ 2;\n-            e.from.succs.remove(e);\n-            e.from.succs.add(result);\n-            e.from = n;\n+            n.addSuccessor(e);\n+            LayoutEdge result = new LayoutEdge(e.getFrom(), n, e.getRelativeFromX(), n.getOuterWidth() \/ 2, e.getLink());\n+            n.addPredecessor(result);\n+            e.setRelativeFromX(n.getOuterWidth() \/ 2);\n+            e.getFrom().removeSuccessor(e);\n+            e.getFrom().addSuccessor(result);\n+            e.setFrom(n);\n@@ -744,2 +617,2 @@\n-            LayoutNode from = edge.from;\n-            LayoutNode to = edge.to;\n+            LayoutNode from = edge.getFrom();\n+            LayoutNode to = edge.getTo();\n@@ -748,1 +621,1 @@\n-            LayoutEdge edgeFromSamePort = new LayoutEdge();\n+            LayoutEdge edgeFromSamePort = null;\n@@ -750,2 +623,2 @@\n-            for (LayoutEdge e : edge.from.succs) {\n-                if (e.relativeFrom == edge.relativeFrom && e.to.vertex == null) {\n+            for (LayoutEdge e : edge.getFrom().getSuccessors()) {\n+                if (e.getRelativeFromX() == edge.getRelativeFromX() && e.getTo().getVertex() == null) {\n@@ -763,1 +636,1 @@\n-                while (curEdge.to.layer < to.layer - 1 && curEdge.to.vertex == null && newEdge) {\n+                while (curEdge.getTo().getLayer() < to.getLayer() - 1 && curEdge.getTo().getVertex() == null && newEdge) {\n@@ -767,2 +640,2 @@\n-                    if (curEdge.to.succs.size() == 1) {\n-                        curEdge = curEdge.to.succs.get(0);\n+                    if (curEdge.getTo().getSuccessors().size() == 1) {\n+                        curEdge = curEdge.getTo().getSuccessors().get(0);\n@@ -771,2 +644,2 @@\n-                        for (LayoutEdge e : curEdge.to.succs) {\n-                            if (e.to.vertex == null) {\n+                        for (LayoutEdge e : curEdge.getTo().getSuccessors()) {\n+                            if (e.getTo().getVertex() == null) {\n@@ -782,2 +655,2 @@\n-                if (curEdge.to.vertex != null) {\n-                    prevDummy = curEdge.from;\n+                if (curEdge.getTo().getVertex() != null) {\n+                    prevDummy = curEdge.getFrom();\n@@ -785,1 +658,1 @@\n-                    prevDummy = curEdge.to;\n+                    prevDummy = curEdge.getTo();\n@@ -788,4 +661,4 @@\n-                edge.from = prevDummy;\n-                edge.relativeFrom = prevDummy.width \/ 2;\n-                from.succs.remove(edge);\n-                prevDummy.succs.add(edge);\n+                edge.setFrom(prevDummy);\n+                edge.setRelativeFromX(prevDummy.getOuterWidth() \/ 2);\n+                from.removeSuccessor(edge);\n+                prevDummy.addSuccessor(edge);\n@@ -797,1 +670,1 @@\n-            if (node.layer == 0) {\n+            if (node.getLayer() == 0) {\n@@ -800,3 +673,3 @@\n-            int newLayer = node.layer - 1;\n-            for (LayoutEdge e : node.preds) {\n-                if (e.from.vertex != null && e.from.layer == newLayer) {\n+            int newLayer = node.getLayer() - 1;\n+            for (LayoutEdge e : node.getPredecessors()) {\n+                if (e.getFrom().getVertex() != null && e.getFrom().getLayer() == newLayer) {\n@@ -810,1 +683,1 @@\n-            if (node.layer == layers.keySet().size() - 1) {\n+            if (node.getLayer() == layers.keySet().size() - 1) {\n@@ -813,3 +686,3 @@\n-            int newLayer = node.layer + 1;\n-            for (LayoutEdge e : node.succs) {\n-                if (e.to.vertex != null && e.to.layer == newLayer) {\n+            int newLayer = node.getLayer() + 1;\n+            for (LayoutEdge e : node.getSuccessors()) {\n+                if (e.getTo().getVertex() != null && e.getTo().getLayer() == newLayer) {\n@@ -825,1 +698,1 @@\n-            List<LayoutEdge> previousPredEdges = List.copyOf(node.preds);\n+            List<LayoutEdge> previousPredEdges = List.copyOf(node.getPredecessors());\n@@ -827,7 +700,7 @@\n-                LayoutNode predNode = edge.from;\n-                assert predNode.vertex == null;\n-                for (LayoutEdge e : predNode.preds) {\n-                    e.to = edge.to;\n-                    e.relativeTo = edge.relativeTo;\n-                    node.preds.add(e);\n-                    node.preds.remove(edge);\n+                LayoutNode predNode = edge.getFrom();\n+                assert predNode.getVertex() == null;\n+                for (LayoutEdge e : predNode.getPredecessors()) {\n+                    e.setTo(edge.getTo());\n+                    e.setRelativeToX(edge.getRelativeToX());\n+                    node.addPredecessor(e);\n+                    node.removePredecessor(edge);\n@@ -839,1 +712,1 @@\n-            insertNode(node, node.layer - 1);\n+            insertNode(node, node.getLayer() - 1);\n@@ -841,1 +714,1 @@\n-            for (LayoutEdge edge : List.copyOf(node.succs)) {\n+            for (LayoutEdge edge : List.copyOf(node.getSuccessors())) {\n@@ -849,1 +722,1 @@\n-            List<LayoutEdge> previousSuccEdges = List.copyOf(node.succs);\n+            List<LayoutEdge> previousSuccEdges = List.copyOf(node.getSuccessors());\n@@ -851,7 +724,7 @@\n-                LayoutNode succNode = edge.to;\n-                assert succNode.vertex == null;\n-                for (LayoutEdge e : succNode.succs) {\n-                    e.from = edge.from;\n-                    e.relativeFrom = edge.relativeFrom;\n-                    node.succs.add(e);\n-                    node.succs.remove(edge);\n+                LayoutNode succNode = edge.getTo();\n+                assert succNode.getVertex() == null;\n+                for (LayoutEdge e : succNode.getSuccessors()) {\n+                    e.setFrom(edge.getFrom());\n+                    e.setRelativeFromX(edge.getRelativeFromX());\n+                    node.addSuccessor(e);\n+                    node.removeSuccessor(edge);\n@@ -863,1 +736,1 @@\n-            insertNode(node, node.layer + 1);\n+            insertNode(node, node.getLayer() + 1);\n@@ -865,1 +738,1 @@\n-            for (LayoutEdge edge : List.copyOf(node.preds)) {\n+            for (LayoutEdge edge : List.copyOf(node.getPredecessors())) {\n@@ -887,1 +760,1 @@\n-            int layer = node.layer + 1;\n+            int layer = node.getLayer() + 1;\n@@ -891,1 +764,1 @@\n-                List<LayoutNode> list = layers.get(i);\n+                LayoutLayer list = layers.get(i);\n@@ -893,1 +766,1 @@\n-                    n.layer = i + 1;\n+                    n.setLayer(i + 1);\n@@ -900,1 +773,1 @@\n-            List<LayoutNode> l = new ArrayList<>();\n+            LayoutLayer l = new LayoutLayer();\n@@ -905,1 +778,1 @@\n-                assert n.layer != layer;\n+                assert n.getLayer() != layer;\n@@ -914,3 +787,3 @@\n-                for (LayoutEdge e : n.succs) {\n-                    if (!portHashes.containsKey(e.relativeFrom)) {\n-                        portHashes.put(e.relativeFrom, new ArrayList<>());\n+                for (LayoutEdge e : n.getSuccessors()) {\n+                    if (!portHashes.containsKey(e.getRelativeFromX())) {\n+                        portHashes.put(e.getRelativeFromX(), new ArrayList<>());\n@@ -918,1 +791,1 @@\n-                    portHashes.get(e.relativeFrom).add(e);\n+                    portHashes.get(e.getRelativeFromX()).add(e);\n@@ -925,11 +798,4 @@\n-                    dummy.width = DUMMY_WIDTH;\n-                    dummy.height = DUMMY_HEIGHT;\n-\n-                    LayoutEdge newEdge = new LayoutEdge();\n-                    newEdge.from = n;\n-                    newEdge.relativeFrom = i;\n-                    newEdge.to = dummy;\n-                    newEdge.relativeTo = dummy.width \/ 2;\n-                    newEdge.link = edges.get(0).link; \/\/ issue?\n-                    n.succs.add(newEdge);\n-                    dummy.preds.add(newEdge);\n+\n+                    LayoutEdge newEdge = new LayoutEdge(n, dummy, i, dummy.getOuterWidth() \/ 2, edges.get(0).getLink());\n+                    n.addSuccessor(newEdge);\n+                    dummy.addPredecessor(newEdge);\n@@ -938,5 +804,5 @@\n-                        e.from = dummy;\n-                        e.relativeFrom = dummy.width \/ 2;\n-                        n.succs.remove(e);\n-                        dummy.succs.add(e);\n-                        assert e.to.layer == layer + 1;\n+                        e.setFrom(dummy);\n+                        e.setRelativeFromX(dummy.getOuterWidth() \/ 2);\n+                        n.removeSuccessor(e);\n+                        dummy.addSuccessor(e);\n+                        assert e.getTo().getLayer() == layer + 1;\n@@ -952,1 +818,1 @@\n-            assert node.layer == layer;\n+            assert node.getLayer() == layer;\n@@ -965,1 +831,1 @@\n-            if (toNode.layer == fromNode.layer) {\n+            if (toNode.getLayer() == fromNode.getLayer()) {\n@@ -969,8 +835,2 @@\n-            LayoutEdge edge = new LayoutEdge();\n-            edge.link = l;\n-            edge.from = fromNode;\n-            edge.relativeFrom = l.getFrom().getRelativePosition().x;\n-            edge.to = toNode;\n-            edge.relativeTo = l.getTo().getRelativePosition().x;\n-\n-            boolean reversedLink = fromNode.layer > toNode.layer;\n+            LayoutEdge edge = new LayoutEdge(fromNode, toNode, l.getFrom().getRelativePosition().x, l.getTo().getRelativePosition().x, l);\n+            boolean reversedLink = fromNode.getLayer() > toNode.getLayer();\n@@ -985,2 +845,2 @@\n-                int oldRelativeFrom = edge.relativeFrom;\n-                int oldRelativeTo = edge.relativeTo;\n+                int oldRelativeFrom = edge.getRelativeFromX();\n+                int oldRelativeTo = edge.getRelativeToX();\n@@ -988,4 +848,4 @@\n-                edge.from = fromNode;\n-                edge.to = toNode;\n-                edge.relativeFrom = oldRelativeTo;\n-                edge.relativeTo = oldRelativeFrom;\n+                edge.setFrom(fromNode);\n+                edge.setTo(toNode);\n+                edge.setRelativeFromX(oldRelativeTo);\n+                edge.setRelativeToX(oldRelativeFrom);\n@@ -994,2 +854,2 @@\n-            fromNode.succs.add(edge);\n-            toNode.preds.add(edge);\n+            fromNode.addSuccessor(edge);\n+            toNode.addPredecessor(edge);\n@@ -1001,1 +861,1 @@\n-            if (fromNode.layer != toNode.layer - 1) {\n+            if (fromNode.getLayer() != toNode.getLayer() - 1) {\n@@ -1035,1 +895,1 @@\n-                        if (fromNode.layer > i) {\n+                        if (fromNode.getLayer() > i) {\n@@ -1037,1 +897,1 @@\n-                        } else if (fromNode.layer == i) {\n+                        } else if (fromNode.getLayer() == i) {\n@@ -1040,1 +900,1 @@\n-                        curTotalEdgeLength += Math.abs(fromNode.layer - i);\n+                        curTotalEdgeLength += Math.abs(fromNode.getLayer() - i);\n@@ -1043,1 +903,1 @@\n-                        if (toNode.layer < i) {\n+                        if (toNode.getLayer() < i) {\n@@ -1045,1 +905,1 @@\n-                        } else if (toNode.layer == i) {\n+                        } else if (toNode.getLayer() == i) {\n@@ -1048,1 +908,1 @@\n-                        curTotalEdgeLength += Math.abs(i - toNode.layer);\n+                        curTotalEdgeLength += Math.abs(i - toNode.getLayer());\n@@ -1069,6 +929,1 @@\n-            LayoutNode node = new LayoutNode();\n-            Dimension size = action.vertex.getSize();\n-            node.width = (int) size.getWidth();\n-            node.height = (int) size.getHeight();\n-            node.vertex = action.vertex;\n-\n+            LayoutNode node = new LayoutNode(action.vertex);\n@@ -1084,1 +939,0 @@\n-                LayoutEdge e = new LayoutEdge();\n@@ -1087,5 +941,2 @@\n-                    e.to = node;\n-                    e.from = vertexToLayoutNode.get(l.getFrom().getVertex());\n-                    e.relativeFrom = l.getFrom().getRelativePosition().x;\n-                    e.relativeTo = l.getTo().getRelativePosition().x;\n-                    node.preds.add(e);\n+                    LayoutEdge e = new LayoutEdge(vertexToLayoutNode.get(l.getFrom().getVertex()), node, l.getFrom().getRelativePosition().x, l.getTo().getRelativePosition().x, null);\n+                    node.addPredecessor(e);\n@@ -1094,5 +945,2 @@\n-                    e.from = node;\n-                    e.to = vertexToLayoutNode.get(l.getTo().getVertex());\n-                    e.relativeFrom = l.getFrom().getRelativePosition().x;\n-                    e.relativeTo = l.getTo().getRelativePosition().x;\n-                    node.succs.add(e);\n+                    LayoutEdge e = new LayoutEdge(node, vertexToLayoutNode.get(l.getTo().getVertex()), l.getFrom().getRelativePosition().x, l.getTo().getRelativePosition().x, null);\n+                    node.addSuccessor(e);\n@@ -1102,2 +950,2 @@\n-            node.succs.clear();\n-            node.preds.clear();\n+            node.clearSuccessors();\n+            node.clearPredecessors();\n@@ -1119,1 +967,1 @@\n-            if (toNode.layer < fromNode.layer) {\n+            if (toNode.getLayer() < fromNode.getLayer()) {\n@@ -1121,1 +969,0 @@\n-                LayoutNode temp = toNode;\n@@ -1123,2 +970,0 @@\n-                fromNode = temp;\n-\n@@ -1126,2 +971,0 @@\n-                reversedLinkEndPoints.remove(l);\n-                reversedLinkStartPoints.remove(l);\n@@ -1132,1 +975,1 @@\n-            List<LayoutEdge> toNodePredsEdges = List.copyOf(toNode.preds);\n+            List<LayoutEdge> toNodePredsEdges = List.copyOf(toNode.getPredecessors());\n@@ -1134,1 +977,1 @@\n-                LayoutNode n = edge.from;\n+                LayoutNode n = edge.getFrom();\n@@ -1137,2 +980,2 @@\n-                if (edge.link != null && edge.link.equals(l)) {\n-                    toNode.preds.remove(edge);\n+                if (edge.getLink() != null && edge.getLink().equals(l)) {\n+                    toNode.removePredecessor(edge);\n@@ -1145,1 +988,1 @@\n-                if (n.vertex != null && n.vertex.equals(from)) {\n+                if (n.getVertex() != null && n.getVertex().equals(from)) {\n@@ -1147,1 +990,1 @@\n-                    n.succs.remove(edgeToRemove);\n+                    n.removeSuccessor(edgeToRemove);\n@@ -1153,1 +996,1 @@\n-                    while (n.vertex == null && found) {\n+                    while (n.getVertex() == null && found) {\n@@ -1156,1 +999,1 @@\n-                        if (n.succs.size() <= 1 && n.preds.size() <= 1) {\n+                        if (n.getSuccessors().size() <= 1 && n.getPredecessors().size() <= 1) {\n@@ -1166,2 +1009,2 @@\n-                        if (n.preds.size() == 1) {\n-                            n.succs.remove(edgeToRemove);\n+                        if (n.getPredecessors().size() == 1) {\n+                            n.removeSuccessor(edgeToRemove);\n@@ -1169,2 +1012,2 @@\n-                            edgeToRemove = n.preds.get(0);\n-                            n = edgeToRemove.from;\n+                            edgeToRemove = n.getPredecessors().get(0);\n+                            n = edgeToRemove.getFrom();\n@@ -1175,2 +1018,2 @@\n-                    n.succs.remove(edgeToRemove);\n-                    prev.preds.remove(edgeToRemove);\n+                    n.removeSuccessor(edgeToRemove);\n+                    prev.removePredecessor(edgeToRemove);\n@@ -1195,3 +1038,3 @@\n-            int layer = node.layer;\n-            int pos = node.pos;\n-            List<LayoutNode> remainingLayerNodes = layers.get(layer);\n+            int layer = node.getLayer();\n+            int pos = node.getPos();\n+            LayoutLayer remainingLayerNodes = layers.get(layer);\n@@ -1204,2 +1047,2 @@\n-                if (n.pos > pos) {\n-                    n.pos -= 1;\n+                if (n.getPos() > pos) {\n+                    n.setPos(n.getPos() - 1);\n@@ -1207,1 +1050,1 @@\n-                if (n.vertex != null || n.preds.size() > 1) {\n+                if (n.getVertex() != null || n.getPredecessors().size() > 1) {\n@@ -1215,1 +1058,1 @@\n-                    List<LayoutNode> list = layers.get(i);\n+                    LayoutLayer list = layers.get(i);\n@@ -1219,1 +1062,1 @@\n-                        n.layer -= 1;\n+                        n.setLayer(n.getLayer() - 1);\n@@ -1223,8 +1066,8 @@\n-                    if (n.preds.size() == 1) {\n-                        LayoutEdge predEdge = n.preds.get(0);\n-                        LayoutNode fromNode = predEdge.from;\n-                        fromNode.succs.remove(predEdge);\n-                        for (LayoutEdge e : n.succs) {\n-                            e.from = fromNode;\n-                            e.relativeFrom = predEdge.relativeFrom;\n-                            fromNode.succs.add(e);\n+                    if (n.getPredecessors().size() == 1) {\n+                        LayoutEdge predEdge = n.getPredecessors().get(0);\n+                        LayoutNode fromNode = predEdge.getFrom();\n+                        fromNode.removeSuccessor(predEdge);\n+                        for (LayoutEdge e : n.getSuccessors()) {\n+                            e.setFrom(fromNode);\n+                            e.setRelativeFromX(predEdge.getRelativeFromX());\n+                            fromNode.addSuccessor(e);\n@@ -1289,3 +1132,3 @@\n-                for (LayoutEdge e : n.preds) {\n-                    if (e.link != null) {\n-                        layoutedLinks.add(e.link);\n+                for (LayoutEdge e : n.getPredecessors()) {\n+                    if (e.getLink() != null) {\n+                        layoutedLinks.add(e.getLink());\n@@ -1294,1 +1137,1 @@\n-                if (n.vertex != null) {\n+                if (n.getVertex() != null) {\n@@ -1317,0 +1160,4 @@\n+            int currentY = 0;\n+            for (int i = 0; i < layers.size(); i++) {\n+                LayoutLayer layer = layers.get(i);\n+                layer.setTop(currentY);\n@@ -1318,8 +1165,9 @@\n-            \/\/ Reset all values before assigning y-coordinates\n-            for (LayoutNode n : nodes) {\n-                if (n.vertex != null) {\n-                    updateNodeWithReversedEdges(n);\n-                } else {\n-                    n.height = DUMMY_HEIGHT;\n-                }\n-                n.y = 0;\n+                \/\/ Calculate the maximum layer height and set it for the layer\n+                int maxLayerHeight = layer.calculateMaxLayerHeight();\n+                layer.setHeight(maxLayerHeight);\n+\n+                \/\/ Center nodes vertically within the layer\n+                layer.centerNodesVertically();\n+\n+                \/\/ Update currentY to account for the padded bottom of this layer\n+                currentY += layer.calculatePaddedHeight();\n@@ -1327,0 +1175,2 @@\n+        }\n+    }\n@@ -1328,1 +1178,1 @@\n-            int curY = 0;\n+    private class WriteResult {\n@@ -1330,10 +1180,3 @@\n-            for (int i = 0; i < layers.size(); i++) {\n-                List<LayoutNode> layer = layers.get(i);\n-                int maxHeight = 0;\n-                int baseLine = 0;\n-                int bottomBaseLine = 0;\n-                for (LayoutNode n : layer) {\n-                    maxHeight = Math.max(maxHeight, n.height - n.yOffset - n.bottomYOffset);\n-                    baseLine = Math.max(baseLine, n.yOffset);\n-                    bottomBaseLine = Math.max(bottomBaseLine, n.bottomYOffset);\n-                }\n+        private HashMap<Link, List<Point>> computeLinkPositions() {\n+            HashMap<Link, List<Point>> linkToSplitEndPoints = new HashMap<>();\n+            HashMap<Link, List<Point>> linkPositions = new HashMap<>();\n@@ -1341,6 +1184,27 @@\n-                int maxXOffset = 0;\n-                for (LayoutNode n : layer) {\n-                    if (n.vertex == null) {\n-                        \/\/ Dummy node\n-                        n.y = curY;\n-                        n.height = maxHeight + baseLine + bottomBaseLine;\n+            for (LayoutNode layoutNode : nodes) {\n+                if (layoutNode.isDummy()) continue;\n+                for (LayoutEdge predEdge : layoutNode.getPredecessors()) {\n+                    LayoutNode fromNode = predEdge.getFrom();\n+                    LayoutNode toNode = predEdge.getTo();\n+\n+                    ArrayList<Point> linkPoints = new ArrayList<>();\n+                    \/\/ input edge stub\n+                    linkPoints.add(new Point(predEdge.getEndX(), predEdge.getEndY()));\n+                    linkPoints.add(new Point(predEdge.getEndX(), layers.get(toNode.getLayer()).getTop() - LAYER_OFFSET));\n+\n+                    LayoutEdge curEdge = predEdge;\n+                    while (fromNode.isDummy() && fromNode.hasPredecessors()) {\n+                        linkPoints.add(new Point(fromNode.getCenterX(), layers.get(fromNode.getLayer()).getBottom() + LAYER_OFFSET));\n+                        linkPoints.add(new Point(fromNode.getCenterX(), layers.get(fromNode.getLayer()).getTop() - LAYER_OFFSET));\n+                        curEdge = fromNode.getPredecessors().get(0);\n+                        fromNode = curEdge.getFrom();\n+                    }\n+                    linkPoints.add(new Point(curEdge.getStartX(), layers.get(fromNode.getLayer()).getBottom() + LAYER_OFFSET));\n+                    \/\/ output edge stub\n+                    linkPoints.add(new Point(curEdge.getStartX(), curEdge.getStartY()));\n+\n+                    if (predEdge.isReversed()) {\n+                        for (Point relativeEnd : toNode.getReversedLinkEndPoints().get(predEdge.getLink())) {\n+                            Point endPoint = new Point(toNode.getLeft() + relativeEnd.x, toNode.getTop() + relativeEnd.y);\n+                            linkPoints.add(0, endPoint);\n+                        }\n@@ -1348,0 +1212,8 @@\n+                        if (!fromNode.isDummy()) {\n+                            if (fromNode.getReversedLinkStartPoints().containsKey(predEdge.getLink())) {\n+                                for (Point relativeStart : fromNode.getReversedLinkStartPoints().get(predEdge.getLink())) {\n+                                    Point startPoint = new Point(fromNode.getLeft() + relativeStart.x, fromNode.getTop() + relativeStart.y);\n+                                    linkPoints.add(startPoint);\n+                                }\n+                            }\n+                        }\n@@ -1349,1 +1221,1 @@\n-                        n.y = curY + baseLine + (maxHeight - (n.height - n.yOffset - n.bottomYOffset)) \/ 2 - n.yOffset;\n+                        Collections.reverse(linkPoints);\n@@ -1352,3 +1224,8 @@\n-                    for (LayoutEdge e : n.succs) {\n-                        int curXOffset = Math.abs(n.x - e.to.x);\n-                        maxXOffset = Math.max(curXOffset, maxXOffset);\n+                    if (fromNode.isDummy()) {\n+                        if (predEdge.isReversed()) {\n+                            Collections.reverse(linkPoints);\n+                        }\n+                        linkToSplitEndPoints.put(predEdge.getLink(), linkPoints);\n+\n+                    } else {\n+                        linkPositions.put(predEdge.getLink(), linkPoints);\n@@ -1357,3 +1234,0 @@\n-\n-                curY += maxHeight + baseLine + bottomBaseLine;\n-                curY += LAYER_OFFSET + ((int) (Math.sqrt(maxXOffset) * 1.5));\n@@ -1361,2 +1235,0 @@\n-        }\n-    }\n@@ -1364,1 +1236,4 @@\n-    private class WriteResult {\n+            for (LayoutNode layoutNode : nodes) {\n+                if (layoutNode.isDummy()) continue;\n+                for (LayoutEdge succEdge : layoutNode.getSuccessors()) {\n+                    if (succEdge.getLink() == null) continue;\n@@ -1366,2 +1241,2 @@\n-        private List<Point> edgePoints(LayoutEdge e) {\n-            ArrayList<Point> points = new ArrayList<>();\n+                    LayoutNode fromNode = succEdge.getFrom();\n+                    LayoutNode toNode = succEdge.getTo();\n@@ -1369,7 +1244,3 @@\n-            Point p = new Point(e.to.x + e.relativeTo,\n-                    e.to.y + e.to.yOffset + e.link.getTo().getRelativePosition().y);\n-            points.add(p);\n-            if (e.to.inOffsets.containsKey(e.relativeTo)) {\n-                points.add(new Point(p.x,\n-                        p.y + e.to.inOffsets.get(e.relativeTo) + e.link.getTo().getRelativePosition().y));\n-            }\n+                    ArrayList<Point> linkPoints = new ArrayList<>();\n+                    linkPoints.add(new Point(succEdge.getStartX(), fromNode.getBottom()));\n+                    linkPoints.add(new Point(succEdge.getStartX(), layers.get(fromNode.getLayer()).getBottom() + LAYER_OFFSET));\n@@ -1377,28 +1248,9 @@\n-            LayoutNode cur = e.from;\n-            LayoutEdge curEdge = e;\n-            while (cur.vertex == null && !cur.preds.isEmpty()) {\n-                if (points.size() > 1 && points.get(points.size() - 1).x == cur.x + cur.width \/ 2\n-                        && points.get(points.size() - 2).x == cur.x + cur.width \/ 2) {\n-                    \/\/ On the same vertical line, can remove previous point\n-                    points.remove(points.size() - 1);\n-                }\n-                \/\/ Top of the dummy node\n-                points.add(new Point(cur.x + cur.width \/ 2, cur.y + cur.height));\n-                if (points.size() > 1 && points.get(points.size() - 1).x == cur.x + cur.width \/ 2\n-                        && points.get(points.size() - 2).x == cur.x + cur.width \/ 2) {\n-                    points.remove(points.size() - 1);\n-                }\n-                \/\/ Bottom of the dummy node\n-                points.add(new Point(cur.x + cur.width \/ 2, cur.y));\n-                assert cur.preds.size() == 1;\n-                curEdge = cur.preds.get(0);\n-                cur = curEdge.from;\n-            }\n-\n-            p = new Point(cur.x + curEdge.relativeFrom, cur.y + cur.height - cur.bottomYOffset\n-                    + (curEdge.link == null ? 0 : curEdge.link.getFrom().getRelativePosition().y));\n-            if (curEdge.from.outOffsets.containsKey(curEdge.relativeFrom)) {\n-                points.add(new Point(p.x, p.y + curEdge.from.outOffsets.get(curEdge.relativeFrom)\n-                        + (curEdge.link == null ? 0 : curEdge.link.getFrom().getRelativePosition().y)));\n-            }\n-            points.add(p);\n+                    LayoutEdge curEdge = succEdge;\n+                    while (toNode.isDummy() && toNode.hasSuccessors()) {\n+                        linkPoints.add(new Point(toNode.getCenterX(), layers.get(toNode.getLayer()).getTop() - LAYER_OFFSET));\n+                        linkPoints.add(new Point(toNode.getCenterX(), layers.get(toNode.getLayer()).getBottom() + LAYER_OFFSET));\n+                        curEdge = toNode.getSuccessors().get(0);\n+                        toNode = curEdge.getTo();\n+                    }\n+                    linkPoints.add(new Point(curEdge.getEndX(), layers.get(toNode.getLayer()).getTop() - LAYER_OFFSET));\n+                    linkPoints.add(new Point(curEdge.getEndX(), toNode.getTop()));\n@@ -1406,1 +1258,2 @@\n-            Collections.reverse(points);\n+                    if (succEdge.isReversed()) {\n+                        Collections.reverse(linkPoints);\n@@ -1408,2 +1261,6 @@\n-            if (reversedLinks.contains(e.link)) {\n-                Collections.reverse(points);\n+                        if (fromNode.getReversedLinkStartPoints().containsKey(succEdge.getLink())) {\n+                            for (Point relativeStart : fromNode.getReversedLinkStartPoints().get(succEdge.getLink())) {\n+                                Point startPoint = new Point(fromNode.getLeft() + relativeStart.x, fromNode.getTop() + relativeStart.y);\n+                                linkPoints.add(startPoint);\n+                            }\n+                        }\n@@ -1411,4 +1268,9 @@\n-                assert reversedLinkStartPoints.containsKey(e.link);\n-                for (Point p1 : reversedLinkStartPoints.get(e.link)) {\n-                    points.add(new Point(p1.x + cur.x, p1.y + cur.y));\n-                }\n+                        if (!toNode.isDummy()) {\n+                            if (toNode.getReversedLinkEndPoints().containsKey(succEdge.getLink())) {\n+                                for (Point relativeEnd : toNode.getReversedLinkEndPoints().get(succEdge.getLink())) {\n+                                    Point endPoint = new Point(toNode.getLeft() + relativeEnd.x, toNode.getTop() + relativeEnd.y);\n+                                    linkPoints.add(0, endPoint);\n+                                }\n+                            }\n+                        }\n+                    }\n@@ -1416,3 +1278,11 @@\n-                assert reversedLinkEndPoints.containsKey(e.link);\n-                for (Point p1 : reversedLinkEndPoints.get(e.link)) {\n-                    points.add(0, new Point(p1.x + e.to.x, p1.y + e.to.y));\n+                    if (linkToSplitEndPoints.containsKey(succEdge.getLink())) {\n+                        if (succEdge.isReversed()) {\n+                            Collections.reverse(linkPoints);\n+                        }\n+                        linkPoints.add(null);\n+                        linkPoints.addAll(linkToSplitEndPoints.get(succEdge.getLink()));\n+                        if (succEdge.isReversed()) {\n+                            Collections.reverse(linkPoints);\n+                        }\n+                    }\n+                    linkPositions.put(succEdge.getLink(), linkPoints);\n@@ -1422,1 +1292,1 @@\n-            return points;\n+            return linkPositions;\n@@ -1425,0 +1295,1 @@\n+\n@@ -1427,1 +1298,1 @@\n-            HashMap<Link, List<Point>> linkPositions = new HashMap<>();\n+            HashMap<Link, List<Point>> linkPositions = computeLinkPositions();\n@@ -1429,1 +1300,0 @@\n-            for (LayoutNode n : nodes) {\n@@ -1431,15 +1301,4 @@\n-                if (n.vertex != null) {\n-                    assert !vertexPositions.containsKey(n.vertex);\n-                    vertexPositions.put(n.vertex, new Point(n.x + n.xOffset, n.y + n.yOffset));\n-                } else {\n-                    continue;\n-                }\n-\n-                \/\/ All edges can be drawn from bottom up, the links are stored in the preds list\n-                \/\/ of each node\n-                for (LayoutEdge e : n.preds) {\n-                    if (e.link != null && !linkPositions.containsKey(e.link)) {\n-                        List<Point> points = edgePoints(e);\n-                        assert !linkPositions.containsKey(e.link);\n-                        linkPositions.put(e.link, points);\n-                    }\n+            for (LayoutNode n : nodes) {\n+                if (n.getVertex() != null) {\n+                    assert !vertexPositions.containsKey(n.getVertex());\n+                    vertexPositions.put(n.getVertex(), new Point(n.getLeft(), n.getTop()));\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalStableLayoutManager.java","additions":368,"deletions":509,"binary":false,"changes":877,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,4 +77,0 @@\n-\n-    public boolean isVIP() {\n-        return false;\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/InterClusterConnection.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,8 @@\n+\/**\n+ * The LayoutEdge class represents a connection between two nodes (LayoutNode) in a hierarchical graph layout.\n+ * It stores information about the starting node (from), the ending node (to), and the positions where\n+ * the edge connects to these nodes. It also keeps track of whether the edge has been reversed,\n+ * which is useful for handling edges that go against the main flow in hierarchical layouts (like loops or back edges).\n+ * This class ensures that edges are drawn correctly between nodes,\n+ * helping to create clear and understandable visualizations of the graph.\n+ *\/\n@@ -31,8 +39,177 @@\n-        public LayoutNode from;\n-        public LayoutNode to;\n-        \/\/ Horizontal distance relative to start of 'from'.\n-        public int relativeFrom;\n-        \/\/ Horizontal distance relative to start of 'to'.\n-        public int relativeTo;\n-        public Link link;\n-        public boolean vip;\n+    private LayoutNode from;\n+    private LayoutNode to;\n+    \/\/ Horizontal distance relative to start of 'from'.\n+    private int relativeFromX;\n+    \/\/ Horizontal distance relative to start of 'to'.\n+    private int relativeToX;\n+    private Link link;\n+    private boolean isReversed;\n+\n+    \/**\n+     * Constructs a LayoutEdge between two nodes with the specified link.\n+     * The relative positions are set to zero by default.\n+     *\n+     * @param from The source LayoutNode.\n+     * @param to   The target LayoutNode.\n+     * @param link The Link associated with this edge.\n+     *\/\n+    public LayoutEdge(LayoutNode from, LayoutNode to, Link link) {\n+        this.from = from;\n+        this.to = to;\n+        this.link = link;\n+        this.isReversed = false;\n+    }\n+\n+    \/**\n+     * Constructs a LayoutEdge between two nodes with specified relative positions and link.\n+     *\n+     * @param from          The source LayoutNode.\n+     * @param to            The target LayoutNode.\n+     * @param relativeFromX The horizontal distance relative to the start of 'from' node.\n+     * @param relativeToX   The horizontal distance relative to the start of 'to' node.\n+     * @param link          The Link associated with this edge.\n+     *\/\n+    public LayoutEdge(LayoutNode from, LayoutNode to, int relativeFromX, int relativeToX, Link link) {\n+        this(from, to, link);\n+        this.relativeFromX = relativeFromX;\n+        this.relativeToX = relativeToX;\n+    }\n+\n+    \/**\n+     * Gets the absolute x-coordinate of the starting point of the edge.\n+     *\n+     * @return The x-coordinate of the edge's starting point.\n+     *\/\n+    public int getStartX() {\n+        return relativeFromX + from.getLeft();\n+    }\n+\n+    \/**\n+     * Gets the absolute y-coordinate of the starting point of the edge.\n+     *\n+     * @return The y-coordinate of the edge's starting point.\n+     *\/\n+    public int getStartY() {\n+        return from.getBottom();\n+    }\n+\n+    \/**\n+     * Gets the absolute x-coordinate of the ending point of the edge.\n+     *\n+     * @return The x-coordinate of the edge's ending point.\n+     *\/\n+    public int getEndX() {\n+        return relativeToX + to.getLeft();\n+    }\n+\n+    \/**\n+     * Gets the absolute y-coordinate of the ending point of the edge.\n+     *\n+     * @return The y-coordinate of the edge's ending point.\n+     *\/\n+    public int getEndY() {\n+        return to.getTop();\n+    }\n+\n+    \/**\n+     * Reverses the direction of the edge.\n+     * Marks the edge as reversed, which is used to represent back edges in hierarchical layouts.\n+     *\/\n+    public void reverse() {\n+        isReversed = !isReversed;\n+    }\n+\n+    \/**\n+     * Checks if the edge is reversed.\n+     *\n+     * @return True if the edge is reversed; false otherwise.\n+     *\/\n+    public boolean isReversed() {\n+        return isReversed;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Edge \" + from + \", \" + to;\n+    }\n+\n+    \/**\n+     * Gets the source node of the edge.\n+     *\n+     * @return The source LayoutNode.\n+     *\/\n+    public LayoutNode getFrom() {\n+        return from;\n+    }\n+\n+    \/**\n+     * Sets the source node of the edge.\n+     *\n+     * @param from The LayoutNode to set as the source.\n+     *\/\n+    public void setFrom(LayoutNode from) {\n+        this.from = from;\n+    }\n+\n+    \/**\n+     * Gets the target node of the edge.\n+     *\n+     * @return The target LayoutNode.\n+     *\/\n+    public LayoutNode getTo() {\n+        return to;\n+    }\n+\n+    \/**\n+     * Sets the target node of the edge.\n+     *\n+     * @param to The LayoutNode to set as the target.\n+     *\/\n+    public void setTo(LayoutNode to) {\n+        this.to = to;\n+    }\n+\n+    \/**\n+     * Gets the relative horizontal position from the source node's left boundary to the edge's starting point.\n+     *\n+     * @return The relative x-coordinate from the source node.\n+     *\/\n+    public int getRelativeFromX() {\n+        return relativeFromX;\n+    }\n+\n+    \/**\n+     * Sets the relative horizontal position from the source node's left boundary to the edge's starting point.\n+     *\n+     * @param relativeFromX The relative x-coordinate to set.\n+     *\/\n+    public void setRelativeFromX(int relativeFromX) {\n+        this.relativeFromX = relativeFromX;\n+    }\n+\n+    \/**\n+     * Gets the relative horizontal position from the target node's left boundary to the edge's ending point.\n+     *\n+     * @return The relative x-coordinate to the target node.\n+     *\/\n+    public int getRelativeToX() {\n+        return relativeToX;\n+    }\n+\n+    \/**\n+     * Sets the relative horizontal position from the target node's left boundary to the edge's ending point.\n+     *\n+     * @param relativeToX The relative x-coordinate to set.\n+     *\/\n+    public void setRelativeToX(int relativeToX) {\n+        this.relativeToX = relativeToX;\n+    }\n+\n+    \/**\n+     * Gets the Link associated with this edge.\n+     *\n+     * @return The Link object.\n+     *\/\n+    public Link getLink() {\n+        return link;\n+    }\n@@ -40,4 +217,2 @@\n-        @Override\n-        public String toString() {\n-            return \"Edge \" + from + \", \" + to;\n-        }\n+    public void setLink(Link link) {\n+        this.link = link;\n@@ -45,0 +220,1 @@\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutEdge.java","additions":189,"deletions":13,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -0,0 +1,433 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import com.sun.hotspot.igv.layout.Link;\n+import com.sun.hotspot.igv.layout.Port;\n+import com.sun.hotspot.igv.layout.Vertex;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+\n+\/**\n+ * The LayoutGraph class is responsible for organizing and arranging a graph's nodes and edges for visual display.\n+ * It takes a collection of nodes (Vertex) and connections between them (Link) and structures them into layers,\n+ * creating a hierarchical layout. The class handles complexities like edges that span multiple layers\n+ * by inserting temporary \"dummy\" nodes to maintain a clear hierarchy.\n+ * This organization helps ensure that when the graph is displayed, it is easy to understand and visually coherent,\n+ * making the relationships between nodes clear and straightforward.\n+ *\n+ * @author Thomas Wuerthinger\n+ *\/\n+public class LayoutGraph {\n+\n+    public static final Comparator<Link> LINK_COMPARATOR =\n+            Comparator.comparing((Link l) -> l.getFrom().getVertex())\n+                    .thenComparing(l -> l.getTo().getVertex())\n+                    .thenComparingInt(l -> l.getFrom().getRelativePosition().x)\n+                    .thenComparingInt(l -> l.getTo().getRelativePosition().x);\n+\n+    \/\/ Registered Graph Components: Links, Vertices, and Port Mappings\n+    private final Set<Link> links;\n+    private final SortedSet<Vertex> vertices;\n+    private final LinkedHashMap<Vertex, Set<Port>> inputPorts;\n+\n+    \/\/ Layout Management: LayoutNodes and LayoutLayers\n+    private final LinkedHashMap<Vertex, LayoutNode> layoutNodes;\n+    private final List<LayoutNode> dummyNodes;\n+    private final List<LayoutLayer> layers;\n+    private boolean showSelfEdges = false;\n+\n+    \/**\n+     * Constructs a new LayoutGraph using the provided collection of links and additional vertices.\n+     * Initializes the graph layout structure with the given links and includes any additional vertices.\n+     *\n+     * @param links              The collection of links that represent the edges of the graph.\n+     * @param additionalVertices The collection of additional vertices to be included in the graph.\n+     *\/\n+    public LayoutGraph(Collection<? extends Link> links, Collection<? extends Vertex> additionalVertices) {\n+        this.links = new HashSet<>(links);\n+        vertices = new TreeSet<>(additionalVertices);\n+        LinkedHashMap<Port, Set<Link>> portLinks = new LinkedHashMap<>(links.size());\n+        inputPorts = new LinkedHashMap<>(links.size());\n+        LinkedHashMap<Vertex, Set<Port>> outputPorts = new LinkedHashMap<>(links.size());\n+\n+        for (Link link : links) {\n+            assert link.getFrom() != null;\n+            assert link.getTo() != null;\n+            Port fromPort = link.getFrom();\n+            Port toPort = link.getTo();\n+            Vertex fromVertex = fromPort.getVertex();\n+            Vertex toVertex = toPort.getVertex();\n+\n+            vertices.add(fromVertex);\n+            vertices.add(toVertex);\n+\n+            outputPorts.computeIfAbsent(fromVertex, k -> new HashSet<>()).add(fromPort);\n+            inputPorts.computeIfAbsent(toVertex, k -> new HashSet<>()).add(toPort);\n+\n+            portLinks.computeIfAbsent(fromPort, k -> new HashSet<>()).add(link);\n+            portLinks.computeIfAbsent(toPort, k -> new HashSet<>()).add(link);\n+        }\n+\n+        \/\/ cleanup\n+        layoutNodes = new LinkedHashMap<>();\n+        dummyNodes = new ArrayList<>();\n+        layers = new ArrayList<>();\n+    }\n+\n+    public void clearLayout() {\n+        layoutNodes.clear();\n+        dummyNodes.clear();\n+        layers.clear();\n+    }\n+\n+    public boolean showSelfEdges() {\n+        return showSelfEdges;\n+    }\n+\n+    public void setShowSelfEdges(boolean showSelfEdges) {\n+        this.showSelfEdges = showSelfEdges;\n+    }\n+\n+    \/**\n+     * Initializes or resets the layout structures by clearing existing nodes, dummy nodes, and layers.\n+     * It then sets up the layout nodes for each vertex and creates layout edges based on the sorted links.\n+     *\/\n+    public void initializeLayout() {\n+        \/\/ Reset layout structures\n+        clearLayout();\n+\n+        \/\/ Set up layout nodes for each vertex\n+        for (Vertex vertex : getVertices()) {\n+            createLayoutNode(vertex);\n+        }\n+\n+        \/\/ Set up layout edges in a sorted order for reproducibility\n+        List<Link> sortedLinks = new ArrayList<>(links);\n+        sortedLinks.sort(LINK_COMPARATOR);\n+        for (Link link : sortedLinks) {\n+            createLayoutEdge(link);\n+        }\n+    }\n+\n+    \/**\n+     * Initializes the layers of the graph with the specified number of empty layers.\n+     *\n+     * @param layerCount The number of layers to initialize.\n+     *\/\n+    public void initLayers(int layerCount) {\n+        layers.clear();\n+        for (int i = 0; i < layerCount; i++) {\n+            layers.add(new LayoutLayer());\n+        }\n+    }\n+\n+    \/**\n+     * Retrieves an unmodifiable list of dummy nodes in the graph.\n+     *\n+     * @return An unmodifiable list containing all dummy nodes in the graph.\n+     *\/\n+    public List<LayoutNode> getDummyNodes() {\n+        return Collections.unmodifiableList(dummyNodes);\n+    }\n+\n+    \/**\n+     * Retrieves a collection of all layout nodes in the graph.\n+     *\n+     * @return A collection containing all LayoutNodes.\n+     *\/\n+    public Collection<LayoutNode> getLayoutNodes() {\n+        return Collections.unmodifiableCollection(layoutNodes.values());\n+    }\n+\n+    \/**\n+     * Retrieves a combined list of all nodes in the graph,\n+     * including both layout nodes and dummy nodes.\n+     *\n+     * @return An unmodifiable list containing all nodes in the graph.\n+     *\/\n+    public List<LayoutNode> getAllNodes() {\n+        List<LayoutNode> allNodes = new ArrayList<>();\n+        allNodes.addAll(layoutNodes.values());\n+        allNodes.addAll(dummyNodes);\n+        return Collections.unmodifiableList(allNodes);\n+    }\n+\n+    \/**\n+     * Retrieves an unmodifiable list of all layers in the graph.\n+     *\n+     * @return An unmodifiable list containing all layers.\n+     *\/\n+    public List<LayoutLayer> getLayers() {\n+        return Collections.unmodifiableList(layers);\n+    }\n+\n+    \/**\n+     * Returns the total number of layers in the graph.\n+     *\n+     * @return The number of layers.\n+     *\/\n+    public int getLayerCount() {\n+        return layers.size();\n+    }\n+\n+    \/**\n+     * Adds a LayoutNode to the specified layer and registers it in the graph.\n+     *\n+     * @param node        The LayoutNode to add to the layer.\n+     * @param layerNumber The index of the layer to which the node will be added.\n+     *\/\n+    public void addDummyToLayer(LayoutNode node, int layerNumber) {\n+        assert node.isDummy();\n+        node.setLayer(layerNumber);\n+        getLayer(layerNumber).add(node);\n+        dummyNodes.add(node);\n+    }\n+\n+    \/**\n+     * Updates the positions of all nodes in each layer.\n+     * Should be called after changes to node positions or layer compositions.\n+     *\/\n+    public void updatePositions() {\n+        for (LayoutLayer layer : layers) {\n+            layer.updateNodeIndices();\n+        }\n+    }\n+\n+    \/\/ Create and register LayoutNode\n+    public LayoutNode createLayoutNode(Vertex vertex) {\n+        if (!vertices.contains(vertex)) {\n+            throw new IllegalArgumentException(\"Vertex does not exist in the graph: \" + vertex);\n+        }\n+        LayoutNode node = new LayoutNode(vertex);\n+        layoutNodes.put(vertex, node);\n+        return node;\n+    }\n+\n+    \/**\n+     * Creates a LayoutEdge based on the given Link and connects it to the corresponding LayoutNodes.\n+     *\n+     * @param link The Link representing the edge in the graph.\n+     * @return The newly created LayoutEdge.\n+     *\/\n+    public LayoutEdge createLayoutEdge(Link link) {\n+        LayoutEdge edge = new LayoutEdge(\n+                layoutNodes.get(link.getFrom().getVertex()),\n+                layoutNodes.get(link.getTo().getVertex()),\n+                link.getFrom().getRelativePosition().x,\n+                link.getTo().getRelativePosition().x,\n+                link);\n+        edge.getFrom().addSuccessor(edge);\n+        edge.getTo().addPredecessor(edge);\n+        return edge;\n+    }\n+\n+    \/**\n+     * Retrieves the set of all links (edges) in the graph.\n+     *\n+     * @return A set containing all links in the graph.\n+     *\/\n+    public Set<Link> getLinks() {\n+        return links;\n+    }\n+\n+    \/**\n+     * Retrieves the set of all vertices in the graph, sorted in natural order.\n+     *\n+     * @return A sorted set of all vertices in the graph.\n+     *\/\n+    public SortedSet<Vertex> getVertices() {\n+        return vertices;\n+    }\n+\n+    \/**\n+     * Checks whether the graph contains the specified vertex.\n+     *\n+     * @param vertex The vertex to check for presence in the graph.\n+     * @return True if the vertex is present, false otherwise.\n+     *\/\n+    public boolean containsVertex(Vertex vertex) {\n+        return vertices.contains(vertex);\n+    }\n+\n+    \/**\n+     * Finds all root vertices in the graph (vertices with no incoming links).\n+     *\n+     * @return A set of root vertices.\n+     *\/\n+    public Set<Vertex> findRootVertices() {\n+        return vertices.stream()\n+                .filter(v -> inputPorts.getOrDefault(v, Collections.emptySet()).isEmpty())\n+                .collect(Collectors.toSet());\n+    }\n+\n+    \/**\n+     * Retrieves the LayoutLayer at the specified index.\n+     *\n+     * @param layerNr The index of the layer to retrieve.\n+     * @return The LayoutLayer at the specified index.\n+     *\/\n+    public LayoutLayer getLayer(int layerNr) {\n+        return layers.get(layerNr);\n+    }\n+\n+    \/**\n+     * Positions the layers vertically, calculating their heights and setting their positions.\n+     * Centers the nodes within each layer vertically.\n+     *\/\n+    public void positionLayers() {\n+        int currentY = 0;\n+        for (LayoutLayer layer : getLayers()) {\n+            layer.setTop(currentY);\n+\n+            \/\/ Calculate the maximum layer height and set it for the layer\n+            int maxLayerHeight = layer.calculateMaxLayerHeight();\n+            layer.setHeight(maxLayerHeight);\n+\n+            \/\/ Center nodes vertically within the layer\n+            layer.centerNodesVertically();\n+\n+            \/\/ Update currentY to account for the padded bottom of this layer\n+            currentY += layer.calculatePaddedHeight();\n+        }\n+    }\n+\n+    \/**\n+     * Inserts dummy nodes along the edges to successors of the specified node,\n+     * for edges that span more than one layer.\n+     * Can limit the maximum length of layers an edge spans using maxLayerLength.\n+     *\n+     * @param layoutNode     The node for which to create successor dummy nodes.\n+     * @param maxLayerLength The maximum number of layers an edge can span without splitting it\n+     *\/\n+    public void createDummiesForNodeSuccessor(LayoutNode layoutNode, int maxLayerLength) {\n+        LinkedHashMap<Integer, List<LayoutEdge>> portsToUnprocessedEdges = new LinkedHashMap<>();\n+        ArrayList<LayoutEdge> succs = new ArrayList<>(layoutNode.getSuccessors());\n+        LinkedHashMap<Integer, LayoutNode> portToTopNode = new LinkedHashMap<>();\n+        LinkedHashMap<Integer, LinkedHashMap<Integer, LayoutNode>> portToBottomNodeMapping = new LinkedHashMap<>();\n+        for (LayoutEdge succEdge : succs) {\n+            int startPort = succEdge.getRelativeFromX();\n+            LayoutNode fromNode = succEdge.getFrom();\n+            LayoutNode toNode = succEdge.getTo();\n+\n+            \/\/ edge is longer than one layer => needs dummy nodes\n+            if (fromNode.getLayer() != toNode.getLayer() - 1) {\n+                \/\/ the edge needs to be cut\n+                if (maxLayerLength != -1 && toNode.getLayer() - fromNode.getLayer() > maxLayerLength) {\n+                    \/\/ remove the succEdge before replacing it\n+                    toNode.removePredecessor(succEdge);\n+                    fromNode.removeSuccessor(succEdge);\n+\n+                    LayoutNode topCutNode = portToTopNode.get(startPort);\n+                    if (topCutNode == null) {\n+                        topCutNode = new LayoutNode();\n+                        topCutNode.setLayer(fromNode.getLayer() + 1);\n+                        addDummyToLayer(topCutNode, topCutNode.getLayer());\n+                        portToTopNode.put(startPort, topCutNode);\n+                        portToBottomNodeMapping.put(startPort, new LinkedHashMap<>());\n+                    }\n+                    LayoutEdge edgeToTopCut = new LayoutEdge(fromNode, topCutNode, succEdge.getRelativeFromX(), topCutNode.getWidth() \/ 2, succEdge.getLink());\n+                    if (succEdge.isReversed()) edgeToTopCut.reverse();\n+                    fromNode.addSuccessor(edgeToTopCut);\n+                    topCutNode.addPredecessor(edgeToTopCut);\n+\n+                    LinkedHashMap<Integer, LayoutNode> layerToBottomNode = portToBottomNodeMapping.get(startPort);\n+                    LayoutNode bottomCutNode = layerToBottomNode.get(toNode.getLayer());\n+                    if (bottomCutNode == null) {\n+                        bottomCutNode = new LayoutNode();\n+                        bottomCutNode.setLayer(toNode.getLayer() - 1);\n+                        addDummyToLayer(bottomCutNode, bottomCutNode.getLayer());\n+                        layerToBottomNode.put(toNode.getLayer(), bottomCutNode);\n+                    }\n+                    LayoutEdge bottomEdge = new LayoutEdge(bottomCutNode, toNode, bottomCutNode.getWidth() \/ 2, succEdge.getRelativeToX(), succEdge.getLink());\n+                    if (succEdge.isReversed()) bottomEdge.reverse();\n+                    toNode.addPredecessor(bottomEdge);\n+                    bottomCutNode.addSuccessor(bottomEdge);\n+\n+                } else { \/\/ the edge is not cut, but needs dummy nodes\n+                    portsToUnprocessedEdges.putIfAbsent(startPort, new ArrayList<>());\n+                    portsToUnprocessedEdges.get(startPort).add(succEdge);\n+                }\n+            }\n+        }\n+\n+        for (Map.Entry<Integer, List<LayoutEdge>> portToUnprocessedEdges : portsToUnprocessedEdges.entrySet()) {\n+            Integer startPort = portToUnprocessedEdges.getKey();\n+            List<LayoutEdge> unprocessedEdges = portToUnprocessedEdges.getValue();\n+            unprocessedEdges.sort(Comparator.comparingInt(e -> e.getTo().getLayer()));\n+\n+            if (unprocessedEdges.size() == 1) {\n+                \/\/ process a single edge\n+                LayoutEdge singleEdge = unprocessedEdges.get(0);\n+                LayoutNode fromNode = singleEdge.getFrom();\n+                if (singleEdge.getTo().getLayer() > fromNode.getLayer() + 1) {\n+                    LayoutEdge previousEdge = singleEdge;\n+                    for (int i = fromNode.getLayer() + 1; i < previousEdge.getTo().getLayer(); i++) {\n+                        LayoutNode dummyNode = new LayoutNode();\n+                        dummyNode.setLayer(i);\n+                        dummyNode.addPredecessor(previousEdge);\n+                        addDummyToLayer(dummyNode, dummyNode.getLayer());\n+                        LayoutEdge dummyEdge = new LayoutEdge(dummyNode, previousEdge.getTo(), dummyNode.getWidth() \/ 2, previousEdge.getRelativeToX(), singleEdge.getLink());\n+                        if (previousEdge.isReversed()) dummyEdge.reverse();\n+                        dummyNode.addSuccessor(dummyEdge);\n+                        previousEdge.setRelativeToX(dummyNode.getWidth() \/ 2);\n+                        previousEdge.getTo().removePredecessor(previousEdge);\n+                        previousEdge.getTo().addPredecessor(dummyEdge);\n+                        previousEdge.setTo(dummyNode);\n+                        previousEdge = dummyEdge;\n+                    }\n+                }\n+            } else {\n+                int lastLayer = unprocessedEdges.get(unprocessedEdges.size() - 1).getTo().getLayer();\n+                int dummyCnt = lastLayer - layoutNode.getLayer() - 1;\n+                LayoutEdge[] newDummyEdges = new LayoutEdge[dummyCnt];\n+                LayoutNode[] newDummyNodes = new LayoutNode[dummyCnt];\n+\n+                newDummyNodes[0] = new LayoutNode();\n+                newDummyNodes[0].setLayer(layoutNode.getLayer() + 1);\n+                newDummyEdges[0] = new LayoutEdge(layoutNode, newDummyNodes[0], startPort, newDummyNodes[0].getWidth() \/ 2, null);\n+                newDummyNodes[0].addPredecessor(newDummyEdges[0]);\n+                layoutNode.addSuccessor(newDummyEdges[0]);\n+                for (int j = 1; j < dummyCnt; j++) {\n+                    newDummyNodes[j] = new LayoutNode();\n+                    newDummyNodes[j].setLayer(layoutNode.getLayer() + j + 1);\n+                    newDummyEdges[j] = new LayoutEdge(newDummyNodes[j - 1], newDummyNodes[j], null);\n+                    newDummyNodes[j].addPredecessor(newDummyEdges[j]);\n+                    newDummyNodes[j - 1].addSuccessor(newDummyEdges[j]);\n+                }\n+                for (LayoutEdge unprocessedEdge : unprocessedEdges) {\n+                    LayoutNode anchorNode = newDummyNodes[unprocessedEdge.getTo().getLayer() - layoutNode.getLayer() - 2];\n+                    anchorNode.addSuccessor(unprocessedEdge);\n+                    unprocessedEdge.setFrom(anchorNode);\n+                    unprocessedEdge.setRelativeFromX(anchorNode.getWidth() \/ 2);\n+                    layoutNode.removeSuccessor(unprocessedEdge);\n+                }\n+                for (LayoutNode dummyNode : newDummyNodes) {\n+                    addDummyToLayer(dummyNode, dummyNode.getLayer());\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutGraph.java","additions":433,"deletions":0,"binary":false,"changes":433,"status":"added"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutManager.*;\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutNode.NODE_X_COMPARATOR;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+\/**\n+ * The LayoutLayer class represents a single horizontal layer in a hierarchical graph layout.\n+ * It holds a list of nodes (LayoutNode) that are all on the same vertical level.\n+ * This class provides simple methods to manage these nodes: you can add nodes to the layer,\n+ * calculate the maximum height needed to fit all nodes, center the nodes vertically within the layer, and set\n+ * their horizontal positions with proper spacing. In essence, LayoutLayer helps organize nodes neatly in a graph,\n+ * making it easier to display the graph clearly and understand the relationships between nodes.\n+ *\/\n+public class LayoutLayer extends ArrayList<LayoutNode> {\n+\n+    private int height = 0;\n+    private int y = 0;\n+\n+    \/**\n+     * Adds all LayoutNodes from the specified collection to this layer.\n+     * Updates the layer's height based on the nodes added.\n+     *\n+     * @param c The collection of LayoutNodes to be added.\n+     * @return true if this layer changed as a result of the call.\n+     *\/\n+    @Override\n+    public boolean addAll(Collection<? extends LayoutNode> c) {\n+        c.forEach(this::updateLayerHeight);\n+        return super.addAll(c);\n+    }\n+\n+    \/**\n+     * Adds a single LayoutNode to this layer.\n+     * Updates the layer's height based on the node added.\n+     *\n+     * @param n The LayoutNode to be added.\n+     * @return true if the node was added successfully.\n+     *\/\n+    @Override\n+    public boolean add(LayoutNode n) {\n+        updateLayerHeight(n);\n+        return super.add(n);\n+    }\n+\n+    \/**\n+     * Updates the layer's height if the outer height of the given node exceeds the current height.\n+     *\n+     * @param n The LayoutNode whose height is to be considered.\n+     *\/\n+    private void updateLayerHeight(LayoutNode n) {\n+        height = Math.max(height, n.getOuterHeight());\n+    }\n+\n+    \/**\n+     * Calculates and returns the maximum height among the nodes in this layer, including their margins.\n+     * Adjusts the top and bottom margins of non-dummy nodes to be equal, effectively centering them vertically.\n+     *\n+     * @return The maximum outer height of nodes in this layer.\n+     *\/\n+    public int calculateMaxLayerHeight() {\n+        int maxLayerHeight = 0;\n+        for (LayoutNode layoutNode : this) {\n+            if (!layoutNode.isDummy()) {\n+                \/\/ Center the node by setting equal top and bottom margins\n+                layoutNode.centerNode();\n+            }\n+            maxLayerHeight = Math.max(maxLayerHeight, layoutNode.getOuterHeight());\n+        }\n+        return maxLayerHeight;\n+    }\n+\n+    \/**\n+     * Calculates and returns the total height of this layer, including additional padding\n+     * based on the maximum horizontal offset among the edges of its nodes.\n+     * This padding helps in scaling the layer vertically to accommodate edge bends and crossings.\n+     *\n+     * @return The total padded height of the layer.\n+     *\/\n+    public int calculatePaddedHeight() {\n+        int maxXOffset = 0;\n+\n+        for (LayoutNode layoutNode : this) {\n+            for (LayoutEdge succEdge : layoutNode.getSuccessors()) {\n+                maxXOffset = Math.max(Math.abs(succEdge.getStartX() - succEdge.getEndX()), maxXOffset);\n+            }\n+        }\n+\n+        int scalePaddedBottom = this.getHeight();\n+        scalePaddedBottom += (int) (SCALE_LAYER_PADDING * Math.max((int) (Math.sqrt(maxXOffset) * 2), LAYER_OFFSET * 3));\n+        return scalePaddedBottom;\n+    }\n+\n+    \/**\n+     * Centers all nodes in this layer vertically within the layer's assigned space.\n+     * Adjusts each node's Y-coordinate so that it is centered based on the layer's top and height.\n+     *\/\n+    public void centerNodesVertically() {\n+        for (LayoutNode layoutNode : this) {\n+            int centeredY = getTop() + (getHeight() - layoutNode.getOuterHeight()) \/ 2;\n+            layoutNode.setY(centeredY);\n+        }\n+    }\n+\n+    \/**\n+     * Shifts the top Y-coordinate of this layer by the specified amount.\n+     * Useful for moving the entire layer up or down.\n+     *\n+     * @param shift The amount to shift the layer's top position. Positive values move it down.\n+     *\/\n+    public void moveLayerVertically(int shift) {\n+        y += shift;\n+    }\n+\n+    \/**\n+     * Gets the top Y-coordinate of this layer.\n+     *\n+     * @return The Y-coordinate representing the top of the layer.\n+     *\/\n+    public int getTop() {\n+        return y;\n+    }\n+\n+    \/**\n+     * Sets the top Y-coordinate of this layer.\n+     *\n+     * @param top The Y-coordinate representing the top of the layer.\n+     *\/\n+    public void setTop(int top) {\n+        y = top;\n+    }\n+\n+    \/**\n+     * Gets the bottom Y-coordinate of this layer.\n+     *\n+     * @return The Y-coordinate representing the bottom of the layer.\n+     *\/\n+    public int getBottom() {\n+        return y + height;\n+    }\n+\n+    \/**\n+     * Gets the height of this layer.\n+     *\n+     * @return The height of the layer.\n+     *\/\n+    public int getHeight() {\n+        return height;\n+    }\n+\n+    \/**\n+     * Sets the height of this layer.\n+     *\n+     * @param height The height to set for the layer.\n+     *\/\n+    public void setHeight(int height) {\n+        this.height = height;\n+    }\n+\n+    \/**\n+     * Initializes nodes' X positions with spacing.\n+     *\/\n+    public void initXPositions() {\n+        int curX = 0;\n+        for (LayoutNode node : this) {\n+            node.setX(curX);\n+            curX += node.getOuterWidth() + NODE_OFFSET;\n+        }\n+    }\n+\n+    \/**\n+     * Updates the position indices of the nodes in this layer based on their order in the list.\n+     * Useful after nodes have been added or removed to ensure position indices are consistent.\n+     *\/\n+    public void updateNodeIndices() {\n+        int pos = 0;\n+        for (LayoutNode layoutNode : this) {\n+            layoutNode.setPos(pos);\n+            pos++;\n+        }\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutLayer.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import java.awt.Font;\n+\n+\/**\n+ *\n+ * @author Thomas Wuerthinger\n+ *\/\n+public abstract class LayoutManager {\n+\n+    public static final Font TITLE_FONT = new Font(\"Arial\", Font.BOLD, 14);\n+    public static final int SWEEP_ITERATIONS = 1;\n+    public static final int CROSSING_ITERATIONS = 1;\n+    public static final int NODE_OFFSET = 8;\n+    public static final int LAYER_OFFSET = 8;\n+    public static final double SCALE_LAYER_PADDING = 1.5;\n+\n+    public abstract void setCutEdges(boolean enable);\n+\n+    public abstract void doLayout(LayoutGraph graph);\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutManager.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutManager.NODE_OFFSET;\n+import com.sun.hotspot.igv.layout.Link;\n@@ -27,0 +29,2 @@\n+import java.awt.Dimension;\n+import java.awt.Point;\n@@ -29,0 +33,9 @@\n+\/**\n+ * The LayoutNode class represents a node in a hierarchical graph layout.\n+ * It can be either an actual node from the original graph or a temporary \"dummy\" node added during the layout process\n+ * to handle complex edge connections.\n+ * This class stores important layout information like the node's position (x and y coordinates),\n+ * size (width and height), layer level, and connections to other nodes through incoming and outgoing edges.\n+ * It provides methods to calculate optimal positions, manage margins, and handle reversed edges,\n+ * all aimed at arranging the nodes neatly in layers to create a clear and visually organized graph display.\n+ *\/\n@@ -31,9 +44,190 @@\n-        public int x;\n-        public int y;\n-        public int width;\n-        public int height;\n-        public int layer = -1;\n-        public int xOffset;\n-        public int yOffset;\n-        public int bottomYOffset;\n-        public Vertex vertex; \/\/ Only used for non-dummy nodes, otherwise null\n+    \/\/ Comparator constants for sorting LayoutNodes in various ways\n+    public static final Comparator<LayoutNode> LAYOUT_NODE_DEGREE_COMPARATOR = Comparator.comparingInt(LayoutNode::getDegree);\n+    public static final Comparator<LayoutNode> NODE_POS_COMPARATOR = Comparator.comparingInt(LayoutNode::getPos);\n+    public static final Comparator<LayoutNode> NODE_X_COMPARATOR = Comparator.comparingInt(LayoutNode::getX);\n+    public static final Comparator<LayoutNode> NODE_CROSSING_COMPARATOR = Comparator.comparingInt(LayoutNode::getCrossingNumber);\n+\n+\n+    \/\/ Default dimensions for dummy nodes\n+    public static final int DUMMY_HEIGHT = 1;\n+    public static final int DUMMY_WIDTH = 1;\n+    public static final int REVERSE_EDGE_OFFSET = NODE_OFFSET + LayoutNode.DUMMY_WIDTH;\n+    private Vertex vertex; \/\/ Associated graph vertex; null for dummy nodes\n+    private final List<LayoutEdge> preds = new ArrayList<>(); \/\/ Incoming edges\n+    private final List<LayoutEdge> succs = new ArrayList<>(); \/\/ Outgoing edges\n+    private LayoutEdge selfEdge = null;\n+    private final HashMap<Link, List<Point>> reversedLinkStartPoints = new HashMap<>(); \/\/ Start points of reversed edges\n+    private final HashMap<Link, List<Point>> reversedLinkEndPoints = new HashMap<>();   \/\/ End points of reversed edges\n+    \/\/ Layout properties\n+    private int layer = -1;\n+    private int x;\n+    private int y;\n+    private int width;\n+    private int height;\n+    private int topMargin;\n+    private int bottomMargin;\n+    private int rightMargin;\n+    private int leftMargin;\n+    private int pos = -1; \/\/ Position within its layer\n+    private int crossingNumber = 0;\n+\n+    public boolean hasSelfEdge() {\n+        return selfEdge != null;\n+    }\n+\n+    public void setSelfEdge(LayoutEdge selfEdge) {\n+        this.selfEdge = selfEdge;\n+        if (selfEdge != null) {\n+            topMargin += REVERSE_EDGE_OFFSET;\n+            bottomMargin += REVERSE_EDGE_OFFSET;\n+            rightMargin += REVERSE_EDGE_OFFSET;\n+        }\n+    }\n+\n+    public LayoutEdge getSelfEdge() {\n+        return selfEdge;\n+    }\n+\n+    \/**\n+     * Constructs a LayoutNode associated with the given Vertex.\n+     * Initializes the node's size based on the vertex's dimensions.\n+     *\n+     * @param v The Vertex associated with this LayoutNode. If null, the node is a dummy node.\n+     *\/\n+    public LayoutNode(Vertex v) {\n+        vertex = v;\n+        initSize();\n+    }\n+\n+    \/**\n+     * Constructs a dummy LayoutNode\n+     *\/\n+    public LayoutNode() {\n+        this(null);\n+    }\n+\n+    \/**\n+     * Initializes the size and margins of the node.\n+     * If the node represents a real vertex, it uses the vertex's size.\n+     * Dummy nodes use default dimensions.\n+     *\/\n+    public void initSize() {\n+        if (vertex == null) {\n+            height = DUMMY_HEIGHT;\n+            width = DUMMY_WIDTH;\n+        } else {\n+            Dimension size = vertex.getSize();\n+            height = size.height;\n+            width = size.width;\n+        }\n+        topMargin = 0;\n+        bottomMargin = 0;\n+        leftMargin = 0;\n+        rightMargin = 0;\n+        if (hasSelfEdge()) {\n+            topMargin += REVERSE_EDGE_OFFSET;\n+            bottomMargin += REVERSE_EDGE_OFFSET;\n+            rightMargin += REVERSE_EDGE_OFFSET;\n+        }\n+    }\n+\n+    public int getCrossingNumber() {\n+        return crossingNumber;\n+    }\n+\n+    public void setCrossingNumber(int crossingNumber) {\n+        this.crossingNumber = crossingNumber;\n+    }\n+\n+    public int calculateOptimalXFromPredecessors(boolean useMedian) {\n+        int numPreds = preds.size();\n+\n+        \/\/ If there are no predecessors, retain the current x position\n+        if (numPreds == 0) {\n+            return getX();\n+        }\n+\n+        \/\/ Collect the x positions from all predecessor edges\n+        List<Integer> positions = new ArrayList<>(numPreds);\n+        for (LayoutEdge edge : preds) {\n+            positions.add(edge.getStartX() - edge.getRelativeToX());\n+        }\n+\n+        if (useMedian) {\n+            \/\/ Calculate the median position\n+            Collections.sort(positions);\n+            int midIndex = numPreds \/ 2;\n+\n+            if (numPreds % 2 == 0) {\n+                \/\/ Even number of predecessors: average the two middle values\n+                return (positions.get(midIndex - 1) + positions.get(midIndex)) \/ 2;\n+            } else {\n+                \/\/ Odd number of predecessors: take the middle value\n+                return positions.get(midIndex);\n+            }\n+        } else {\n+            \/\/ Calculate the average position\n+            long sum = 0;\n+            for (int pos : positions) {\n+                sum += pos;\n+            }\n+            \/\/ Integer division is used; adjust as needed for rounding\n+            return (int) (sum \/ numPreds);\n+        }\n+    }\n+\n+\n+    public int calculateOptimalXFromSuccessors(boolean useMedian) {\n+        int numSuccs = succs.size();\n+\n+        \/\/ If there are no successors, retain the current x position\n+        if (numSuccs == 0) {\n+            return getX();\n+        }\n+\n+        \/\/ Collect the x positions from all successor edges\n+        List<Integer> positions = new ArrayList<>(numSuccs);\n+        for (LayoutEdge edge : succs) {\n+            positions.add(edge.getEndX() - edge.getRelativeFromX());\n+        }\n+\n+        if (useMedian) {\n+            \/\/ Calculate the median position\n+            Collections.sort(positions);\n+            int midIndex = numSuccs \/ 2;\n+\n+            if (numSuccs % 2 == 0) {\n+                \/\/ Even number of successors: average the two middle values\n+                return (positions.get(midIndex - 1) + positions.get(midIndex)) \/ 2;\n+            } else {\n+                \/\/ Odd number of successors: take the middle value\n+                return positions.get(midIndex);\n+            }\n+        } else {\n+            \/\/ Calculate the average position\n+            long sum = 0;\n+            for (int pos : positions) {\n+                sum += pos;\n+            }\n+            \/\/ Integer division is used; adjust as needed for rounding\n+            return (int) (sum \/ numSuccs);\n+        }\n+    }\n+\n+    \/**\n+     * Calculates the node's out-degree (number of outgoing edges).\n+     *\n+     * @return The out-degree of the node.\n+     *\/\n+    public int getOutDegree() {\n+        return succs.size();\n+    }\n+\n+    \/**\n+     * Calculates the node's in-degree (number of incoming edges).\n+     *\n+     * @return The in-degree of the node.\n+     *\/\n+    public int getInDegree() {\n+        return preds.size();\n+    }\n@@ -41,5 +235,8 @@\n-        public List<LayoutEdge> preds = new ArrayList<>();\n-        public List<LayoutEdge> succs = new ArrayList<>();\n-        public HashMap<Integer, Integer> outOffsets = new HashMap<>();\n-        public HashMap<Integer, Integer> inOffsets = new HashMap<>();\n-        public int pos = -1; \/\/ Position within layer\n+    \/**\n+     * Calculates the total degree of the node (sum of in-degree and out-degree).\n+     *\n+     * @return The total degree of the node.\n+     *\/\n+    public int getDegree() {\n+        return preds.size() + succs.size();\n+    }\n@@ -47,1 +244,30 @@\n-        public int crossingNumber;\n+    \/**\n+     * Gets the left boundary (excluding left margin) of the node.\n+     *\n+     * @return The x-coordinate of the left boundary.\n+     *\/\n+    public int getLeft() {\n+        return x + leftMargin;\n+    }\n+\n+    \/**\n+     * Gets the total width of the node, including left and right margins.\n+     *\n+     * @return The total outer width.\n+     *\/\n+    public int getOuterWidth() {\n+        return leftMargin + width + rightMargin;\n+    }\n+\n+    \/**\n+     * Gets the total height of the node, including top and bottom margins.\n+     *\n+     * @return The total outer height.\n+     *\/\n+    public int getOuterHeight() {\n+        return topMargin + height + bottomMargin;\n+    }\n+\n+    public int getHeight() {\n+        return height;\n+    }\n@@ -49,3 +275,51 @@\n-        @Override\n-        public String toString() {\n-            return \"Node \" + vertex;\n+    \/**\n+     * Gets the outer right boundary (including right margin) of the node.\n+     *\n+     * @return The x-coordinate of the outer right boundary.\n+     *\/\n+    public int getOuterRight() {\n+        return x + leftMargin + width + rightMargin;\n+    }\n+\n+    \/**\n+     * Gets the horizontal center point of the node.\n+     *\n+     * @return The x-coordinate of the center.\n+     *\/\n+    public int getCenterX() {\n+        return x + leftMargin + (width \/ 2);\n+    }\n+\n+    \/**\n+     * Gets the top boundary (excluding top margin) of the node.\n+     *\n+     * @return The y-coordinate of the top boundary.\n+     *\/\n+    public int getTop() {\n+        return y + topMargin;\n+    }\n+\n+    \/**\n+     * Gets the bottom boundary (excluding bottom margin) of the node.\n+     *\n+     * @return The y-coordinate of the bottom boundary.\n+     *\/\n+    public int getBottom() {\n+        return y + topMargin + height;\n+    }\n+\n+    \/**\n+     * Checks if the node is a dummy node.\n+     *\n+     * @return True if the node is a dummy node; false otherwise.\n+     *\/\n+    public boolean isDummy() {\n+        return vertex == null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (vertex != null) {\n+            return vertex.toString();\n+        } else {\n+            return \"dummy\";\n@@ -54,0 +328,213 @@\n+\n+    public int getX() {\n+        return x;\n+    }\n+\n+    public void setX(int x) {\n+        this.x = x;\n+    }\n+\n+    public int getY() {\n+        return y;\n+    }\n+\n+    public void setY(int y) {\n+        this.y = y;\n+    }\n+\n+    public int getWidth() {\n+        return width;\n+    }\n+\n+    public int getLayer() {\n+        return layer;\n+    }\n+\n+    public void setLayer(int layer) {\n+        this.layer = layer;\n+    }\n+\n+    \/**\n+     * Centers the node by setting equal top and bottom margins.\n+     * The larger of the two margins is applied to both.\n+     *\/\n+    public void centerNode() {\n+        int offset = Math.max(topMargin, bottomMargin);\n+        topMargin = offset;\n+        bottomMargin = offset;\n+    }\n+\n+    public Vertex getVertex() {\n+        return vertex;\n+    }\n+\n+    public void setVertex(Vertex vertex) {\n+        this.vertex = vertex;\n+    }\n+\n+    public boolean hasPredecessors() {\n+        return !preds.isEmpty();\n+    }\n+\n+    public boolean hasSuccessors() {\n+        return !succs.isEmpty();\n+    }\n+\n+    public void clearSuccessors() {\n+        succs.clear();\n+    }\n+\n+    public void clearPredecessors() {\n+        preds.clear();\n+    }\n+\n+    public List<LayoutEdge> getSuccessors() {\n+        return Collections.unmodifiableList(succs);\n+    }\n+\n+    public List<LayoutEdge> getSuccessorsRaw() {\n+        return succs;\n+    }\n+\n+    public List<LayoutEdge> getPredecessors() {\n+        return Collections.unmodifiableList(preds);\n+    }\n+\n+    public List<LayoutEdge> getPredecessorsRaw() {\n+        return preds;\n+    }\n+\n+    public void addSuccessor(LayoutEdge successor) {\n+        succs.add(successor);\n+    }\n+\n+    public void removeSuccessor(LayoutEdge successor) {\n+        succs.remove(successor);\n+    }\n+\n+    public void addPredecessor(LayoutEdge predecessor) {\n+        preds.add(predecessor);\n+    }\n+\n+    public void removePredecessor(LayoutEdge predecessor) {\n+        preds.remove(predecessor);\n+    }\n+\n+    public Map<Link, List<Point>> getReversedLinkStartPoints() {\n+        return Collections.unmodifiableMap(reversedLinkStartPoints);\n+    }\n+\n+    public Map<Link, List<Point>> getReversedLinkEndPoints() {\n+        return Collections.unmodifiableMap(reversedLinkEndPoints);\n+    }\n+\n+    public int getPos() {\n+        return pos;\n+    }\n+\n+    public void setPos(int pos) {\n+        this.pos = pos;\n+    }\n+\n+    private boolean computeReversedStartPoints(boolean left) {\n+        TreeMap<Integer, ArrayList<LayoutEdge>> sortedDownMap = left ? new TreeMap<>() : new TreeMap<>(Collections.reverseOrder());\n+        for (LayoutEdge succEdge : succs) {\n+            if (succEdge.isReversed()) {\n+                succEdge.setRelativeFromX(succEdge.getLink().getTo().getRelativePosition().x);\n+                sortedDownMap.putIfAbsent(succEdge.getRelativeFromX(), new ArrayList<>());\n+                sortedDownMap.get(succEdge.getRelativeFromX()).add(succEdge);\n+            }\n+        }\n+\n+        int offset = REVERSE_EDGE_OFFSET;\n+        int offsetX = left ? -offset : offset;\n+        int currentX = left ? 0 : width;\n+        int startY = 0;\n+        int currentY = 0;\n+        for (Map.Entry<Integer, ArrayList<LayoutEdge>> entry : sortedDownMap.entrySet()) {\n+            int startX = entry.getKey();\n+            ArrayList<LayoutEdge> reversedSuccs = entry.getValue();\n+\n+            currentX += offsetX;\n+            currentY -= offset;\n+            topMargin += offset;\n+\n+            ArrayList<Point> startPoints = new ArrayList<>();\n+            startPoints.add(new Point(currentX, currentY));\n+            startPoints.add(new Point(startX, currentY));\n+            startPoints.add(new Point(startX, startY));\n+            for (LayoutEdge revEdge : reversedSuccs) {\n+                revEdge.setRelativeFromX(currentX);\n+                reversedLinkStartPoints.put(revEdge.getLink(), startPoints);\n+            }\n+        }\n+        if (left) {\n+            leftMargin += sortedDownMap.size() * offset;\n+        } else {\n+            rightMargin += sortedDownMap.size() * offset;\n+        }\n+        return !sortedDownMap.isEmpty();\n+    }\n+\n+    private boolean computeReversedEndPoints(boolean left) {\n+        TreeMap<Integer, ArrayList<LayoutEdge>> sortedUpMap = left ? new TreeMap<>() : new TreeMap<>(Collections.reverseOrder());\n+        for (LayoutEdge predEdge : preds) {\n+            if (predEdge.isReversed()) {\n+                predEdge.setRelativeToX(predEdge.getLink().getFrom().getRelativePosition().x);\n+                sortedUpMap.putIfAbsent(predEdge.getRelativeToX(), new ArrayList<>());\n+                sortedUpMap.get(predEdge.getRelativeToX()).add(predEdge);\n+            }\n+        }\n+\n+        int offset = REVERSE_EDGE_OFFSET;\n+        int offsetX = left ? -offset : offset;\n+        int currentX = left ? 0 : getWidth();\n+        int startY = height;\n+        int currentY = height;\n+        for (Map.Entry<Integer, ArrayList<LayoutEdge>> entry : sortedUpMap.entrySet()) {\n+            int startX = entry.getKey();\n+            ArrayList<LayoutEdge> reversedPreds = entry.getValue();\n+\n+            currentX += offsetX;\n+            currentY += offset;\n+            bottomMargin += offset;\n+\n+            ArrayList<Point> endPoints = new ArrayList<>();\n+            endPoints.add(new Point(currentX, currentY));\n+            endPoints.add(new Point(startX, currentY));\n+            endPoints.add(new Point(startX, startY));\n+            for (LayoutEdge revEdge : reversedPreds) {\n+                revEdge.setRelativeToX(currentX);\n+                reversedLinkEndPoints.put(revEdge.getLink(), endPoints);\n+            }\n+        }\n+        if (left) {\n+            leftMargin += sortedUpMap.size() * offset;\n+        } else {\n+            rightMargin += sortedUpMap.size() * offset;\n+        }\n+\n+        return !sortedUpMap.isEmpty();\n+    }\n+\n+    public void computeReversedLinkPoints(boolean reverseLeft) {\n+        initSize();\n+        reversedLinkStartPoints.clear();\n+        reversedLinkEndPoints.clear();\n+\n+        boolean hasReversedDown = computeReversedStartPoints(reverseLeft);\n+        computeReversedEndPoints(hasReversedDown != reverseLeft);\n+    }\n+\n+    public ArrayList<Point> getSelfEdgePoints() {\n+        ArrayList<Point> points = new ArrayList<>();\n+\n+        Link selfEdgeLink = getSelfEdge().getLink();\n+\n+        points.add(new Point(selfEdgeLink.getFrom().getRelativePosition().x,  selfEdgeLink.getFrom().getRelativePosition().y-REVERSE_EDGE_OFFSET));\n+        points.add(new Point(width + REVERSE_EDGE_OFFSET,  selfEdgeLink.getFrom().getRelativePosition().y-REVERSE_EDGE_OFFSET));\n+        points.add(new Point(width + REVERSE_EDGE_OFFSET, height + REVERSE_EDGE_OFFSET));\n+        points.add(new Point(selfEdgeLink.getTo().getRelativePosition().x,  height + REVERSE_EDGE_OFFSET));\n+        return points;\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutNode.java","additions":506,"deletions":19,"binary":false,"changes":525,"status":"modified"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n-import com.sun.hotspot.igv.layout.LayoutManager;\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Vertex;\n-import java.awt.Point;\n-import java.util.*;\n-\n-public class LinearLayoutManager implements LayoutManager {\n-\n-    \/\/ Ranking determining the vertical node ordering.\n-    private final Map<? extends Vertex, Integer> vertexRank;\n-\n-    public LinearLayoutManager(Map<? extends Vertex, Integer> vertexRank) {\n-        this.vertexRank = vertexRank;\n-    }\n-\n-    @Override\n-    public void setCutEdges(boolean enable) {}\n-\n-    @Override\n-    public void doLayout(LayoutGraph graph) {\n-        doLayout(graph, new HashSet<>());\n-    }\n-\n-    @Override\n-    public void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks) {\n-\n-        assert (graph.getLinks().isEmpty());\n-\n-        \/\/ Sort vertices according to given rank.\n-        List<Vertex> vertices = new ArrayList<>(graph.getVertices());\n-        vertices.sort(Comparator.comparingInt((Vertex v) -> vertexRank.getOrDefault(v, Integer.MAX_VALUE)));\n-\n-        \/\/ Assign vertical coordinates in rank order.\n-        assignVerticalCoordinates(vertices);\n-    }\n-\n-    private void assignVerticalCoordinates(List<Vertex> vertices) {\n-        int curY = 0;\n-        for (Vertex v : vertices) {\n-            v.setPosition(new Point(0, curY));\n-            curY += v.getSize().getHeight();\n-        }\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LinearLayoutManager.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class Timing {\n-\n-    private long lastValue;\n-    private long sum;\n-    private final String name;\n-\n-    public Timing(String name) {\n-        this.name = name;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        long val = sum;\n-        if (lastValue != 0) {\n-            \/\/ Timer running\n-            long newValue = System.nanoTime();\n-            val += (newValue - lastValue);\n-        }\n-        return \"Timing for \" + name + \" is: \" + val \/ 1000000 + \" ms\";\n-    }\n-\n-    public void print() {\n-        System.out.println();\n-    }\n-\n-    public void start() {\n-        lastValue = System.nanoTime();\n-    }\n-\n-    public void stop() {\n-        if (lastValue == 0) {\n-            throw new IllegalStateException(\"You must call start before stop\");\n-        }\n-        long newValue = System.nanoTime();\n-        sum += newValue - lastValue;\n-        lastValue = 0;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Timing.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import java.awt.Dimension;\n+import java.awt.Point;\n@@ -28,0 +28,1 @@\n+import java.util.List;\n@@ -38,1 +39,5 @@\n-    Set<? extends Cluster> getSuccessors();\n+    void setPosition(Point p);\n+\n+    Point getPosition();\n+\n+    Rectangle getBounds();\n@@ -40,1 +45,3 @@\n-    Dimension getNodeOffset();\n+    List<? extends Vertex> getVertices();\n+\n+    Set<? extends Cluster> getSuccessors();\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Cluster.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,205 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.layout;\n-\n-import java.util.*;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class LayoutGraph {\n-\n-    private final Set<? extends Link> links;\n-    private final SortedSet<Vertex> vertices;\n-    private final HashMap<Vertex, Set<Port>> inputPorts;\n-    private final HashMap<Vertex, Set<Port>> outputPorts;\n-    private final HashMap<Port, Set<Link>> portLinks;\n-\n-    public LayoutGraph(Set<? extends Link> links) {\n-        this(links, new HashSet<>());\n-    }\n-\n-    public LayoutGraph(Set<? extends Link> links, Set<? extends Vertex> additionalVertices) {\n-        this.links = links;\n-        assert verify();\n-\n-        vertices = new TreeSet<>();\n-        portLinks = new HashMap<>(links.size());\n-        inputPorts = new HashMap<>(links.size());\n-        outputPorts = new HashMap<>(links.size());\n-\n-        for (Link l : links) {\n-            if (l.getFrom() == null || l.getTo() == null) {\n-                continue;\n-            }\n-            Port p = l.getFrom();\n-            Port p2 = l.getTo();\n-            Vertex v1 = p.getVertex();\n-            Vertex v2 = p2.getVertex();\n-\n-            if (!vertices.contains(v1)) {\n-\n-                outputPorts.put(v1, new HashSet<>(1));\n-                inputPorts.put(v1, new HashSet<>(3));\n-                vertices.add(v1);\n-                assert vertices.contains(v1);\n-            }\n-\n-            if (!vertices.contains(v2)) {\n-                vertices.add(v2);\n-                assert vertices.contains(v2);\n-                outputPorts.put(v2, new HashSet<>(1));\n-                inputPorts.put(v2, new HashSet<>(3));\n-            }\n-\n-            if (!portLinks.containsKey(p)) {\n-                HashSet<Link> hashSet = new HashSet<>(3);\n-                portLinks.put(p, hashSet);\n-            }\n-\n-            if (!portLinks.containsKey(p2)) {\n-                portLinks.put(p2, new HashSet<>(3));\n-            }\n-\n-            outputPorts.get(v1).add(p);\n-            inputPorts.get(v2).add(p2);\n-\n-            portLinks.get(p).add(l);\n-            portLinks.get(p2).add(l);\n-        }\n-\n-        for (Vertex v : additionalVertices) {\n-            if (!vertices.contains(v)) {\n-                outputPorts.put(v, new HashSet<>(1));\n-                inputPorts.put(v, new HashSet<>(3));\n-                vertices.add(v);\n-            }\n-        }\n-    }\n-\n-    public Set<Port> getInputPorts(Vertex v) {\n-        return this.inputPorts.get(v);\n-    }\n-\n-    public Set<Port> getOutputPorts(Vertex v) {\n-        return this.outputPorts.get(v);\n-    }\n-\n-    public Set<Link> getPortLinks(Port p) {\n-        return portLinks.get(p);\n-    }\n-\n-    public Set<? extends Link> getLinks() {\n-        return links;\n-    }\n-\n-    public boolean verify() {\n-        return true;\n-    }\n-\n-    public SortedSet<Vertex> getVertices() {\n-        return vertices;\n-    }\n-\n-    private void markNotRoot(Set<Vertex> notRootSet, Vertex v, Vertex startingVertex) {\n-\n-        if (notRootSet.contains(v)) {\n-            return;\n-        }\n-        if (v != startingVertex) {\n-            notRootSet.add(v);\n-        }\n-        Set<Port> outPorts = getOutputPorts(v);\n-        for (Port p : outPorts) {\n-            Set<Link> portLinks = getPortLinks(p);\n-            for (Link l : portLinks) {\n-                Port other = l.getTo();\n-                Vertex otherVertex = other.getVertex();\n-                if (otherVertex != startingVertex) {\n-                    markNotRoot(notRootSet, otherVertex, startingVertex);\n-                }\n-            }\n-        }\n-    }\n-\n-    \/\/ Returns a set of vertices with the following properties:\n-    \/\/ - All Vertices in the set startingRoots are elements of the set.\n-    \/\/ - When starting a DFS at every vertex in the set, every vertex of the\n-    \/\/   whole graph is visited.\n-    public Set<Vertex> findRootVertices(Set<Vertex> startingRoots) {\n-\n-        Set<Vertex> notRootSet = new HashSet<>();\n-        for (Vertex v : startingRoots) {\n-            if (!notRootSet.contains(v)) {\n-                markNotRoot(notRootSet, v, v);\n-            }\n-        }\n-\n-        Set<Vertex> tmpVertices = getVertices();\n-        for (Vertex v : tmpVertices) {\n-            if (!notRootSet.contains(v)) {\n-                if (this.getInputPorts(v).size() == 0) {\n-                    markNotRoot(notRootSet, v, v);\n-                }\n-            }\n-        }\n-\n-        for (Vertex v : tmpVertices) {\n-            if (!notRootSet.contains(v)) {\n-                markNotRoot(notRootSet, v, v);\n-            }\n-        }\n-\n-        Set<Vertex> result = new HashSet<>();\n-        for (Vertex v : tmpVertices) {\n-            if (!notRootSet.contains(v)) {\n-                result.add(v);\n-            }\n-        }\n-        assert tmpVertices.size() == 0 || result.size() > 0;\n-        return result;\n-    }\n-\n-    public Set<Vertex> findRootVertices() {\n-        return findRootVertices(new HashSet<>());\n-    }\n-\n-    public SortedSet<Cluster> getClusters() {\n-\n-        SortedSet<Cluster> clusters = new TreeSet<>();\n-        for (Vertex v : getVertices()) {\n-            if (v.getCluster() != null) {\n-                clusters.add(v.getCluster());\n-            }\n-        }\n-\n-        return clusters;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"LayoutGraph(\" + vertices + \", \" + links + \", \" + getClusters() + \")\";\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/LayoutGraph.java","additions":0,"deletions":205,"binary":false,"changes":205,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.layout;\n-\n-import java.util.Set;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public interface LayoutManager {\n-\n-    void setCutEdges(boolean enable);\n-\n-    void doLayout(LayoutGraph graph);\n-\n-    void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks);\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/LayoutManager.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,0 @@\n-    boolean isVIP();\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Link.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.hotspot.igv.util;\n-\n-import java.util.Arrays;\n-\n-public class Statistics {\n-\n-    public static int median(int[] values) {\n-        Arrays.sort(values);\n-        if (values.length % 2 == 0) {\n-            return (values[values.length \/ 2 - 1] + values[values.length \/ 2]) \/ 2;\n-        } else {\n-            return values[values.length \/ 2];\n-        }\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/Statistics.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -30,1 +30,2 @@\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n+import com.sun.hotspot.igv.layout.Cluster;\n+import com.sun.hotspot.igv.hierarchicallayout.LayoutGraph;\n@@ -47,0 +48,1 @@\n+import javax.swing.border.Border;\n@@ -52,2 +54,0 @@\n-import org.netbeans.api.visual.animator.AnimatorEvent;\n-import org.netbeans.api.visual.animator.AnimatorListener;\n@@ -87,0 +87,1 @@\n+\n@@ -88,0 +89,2 @@\n+    private HierarchicalLayoutManager seaLayoutManager;\n+\n@@ -97,1 +100,1 @@\n-    public static final int BORDER_SIZE = 100;\n+    public static final int BORDER_SIZE = 50;\n@@ -104,1 +107,0 @@\n-    public static final int SLOT_OFFSET = 8;\n@@ -328,0 +330,2 @@\n+        Border emptyBorder = BorderFactory.createEmptyBorder(BORDER_SIZE, BORDER_SIZE, BORDER_SIZE, BORDER_SIZE);\n+\n@@ -329,0 +333,1 @@\n+        blockLayer.setBorder(emptyBorder);\n@@ -332,0 +337,1 @@\n+        connectionLayer.setBorder(emptyBorder);\n@@ -335,0 +341,1 @@\n+        mainLayer.setBorder(emptyBorder);\n@@ -337,1 +344,0 @@\n-        setBorder(BorderFactory.createLineBorder(Color.white, BORDER_SIZE));\n@@ -360,0 +366,1 @@\n+            clearSelectedNodes();\n@@ -481,3 +488,0 @@\n-        this.model = model;\n-        modelState = new ModelState(model);\n-\n@@ -501,0 +505,4 @@\n+        seaLayoutManager = new HierarchicalLayoutManager();\n+\n+        this.model = model;\n+        modelState = new ModelState(model);\n@@ -557,3 +565,5 @@\n-        Collection<Object> objects = new ArrayList<>(getObjects());\n-        for (Object o : objects) {\n-            removeObject(o);\n+        Set<Object> objectSet = new HashSet<>(getObjects());\n+        for (Object object : objectSet) {\n+            if (isObject(object)) {\n+                removeObject(object);\n+            }\n@@ -572,3 +582,3 @@\n-            Map<InputBlock, Integer> maxWidth = new HashMap<>();\n-            for (InputBlock inputBlock : getModel().getDiagram().getInputBlocks()) {\n-                maxWidth.put(inputBlock, 10);\n+            Map<Block, Integer> maxWidth = new HashMap<>();\n+            for (Block block : getModel().getDiagram().getBlocks()) {\n+                maxWidth.put(block, 10);\n@@ -578,2 +588,2 @@\n-                if (figure.getWidth() > maxWidth.get(figure.getBlock().getInputBlock())) {\n-                    maxWidth.put(figure.getBlock().getInputBlock(), figure.getWidth());\n+                if (figure.getWidth() > maxWidth.get(figure.getBlock())) {\n+                    maxWidth.put(figure.getBlock(), figure.getWidth());\n@@ -584,1 +594,1 @@\n-                figure.setWidth(maxWidth.get(figure.getBlock().getInputBlock()));\n+                figure.setWidth(maxWidth.get(figure.getBlock()));\n@@ -601,1 +611,1 @@\n-                SlotWidget slotWidget = new InputSlotWidget(inputSlot, this, figureWidget, figureWidget);\n+                SlotWidget slotWidget = new InputSlotWidget(inputSlot, this, figureWidget);\n@@ -609,1 +619,1 @@\n-                SlotWidget slotWidget = new OutputSlotWidget(outputSlot, this, figureWidget, figureWidget);\n+                SlotWidget slotWidget = new OutputSlotWidget(outputSlot, this, figureWidget);\n@@ -621,2 +631,2 @@\n-            for (InputBlock inputBlock : getModel().getDiagram().getInputBlocks()) {\n-                BlockWidget blockWidget = new BlockWidget(this, inputBlock);\n+            for (Block block : getModel().getDiagram().getBlocks()) {\n+                BlockWidget blockWidget = new BlockWidget(this, block);\n@@ -625,1 +635,1 @@\n-                addObject(inputBlock, blockWidget);\n+                addObject(block, blockWidget);\n@@ -639,1 +649,16 @@\n-        setFigureSelection(model.getSelectedFigures());\n+        rebuilding = false;\n+    }\n+\n+    private void hiddenNodesChanged() {\n+        relayout();\n+        addUndo();\n+    }\n+\n+    private void relayout() {\n+        rebuilding = true;\n+        Set<FigureWidget> oldVisibleFigureWidgets = getVisibleFigureWidgets();\n+        Set<BlockWidget> oldVisibleBlockWidgets = getVisibleBlockWidgets();\n+\n+        updateVisibleFigureWidgets();\n+        updateNodeHull();\n+        updateVisibleBlockWidgets();\n@@ -641,0 +666,18 @@\n+\n+        Set<Figure> visibleFigures = getVisibleFigures();\n+        Set<Connection> visibleConnections = getVisibleConnections();\n+        if (getModel().getShowStableSea()) {\n+            doStableSeaLayout(visibleFigures, visibleConnections);\n+        } else if (getModel().getShowSea()) {\n+            doSeaLayout(visibleFigures, visibleConnections);\n+        } else if (getModel().getShowBlocks()) {\n+            doClusteredLayout(visibleFigures, visibleConnections);\n+        } else if (getModel().getShowCFG()) {\n+            doCFGLayout(visibleFigures, visibleConnections);\n+        }\n+        rebuildConnectionLayer();\n+\n+        updateFigureWidgetLocations(oldVisibleFigureWidgets);\n+        updateBlockWidgetBounds(oldVisibleBlockWidgets);\n+        validateAll();\n+        setFigureSelection(model.getSelectedFigures());\n@@ -666,1 +709,1 @@\n-                            centerRectangle(new Rectangle(location.x, location.y, bounds.width, bounds.height), false);\n+                            centerRectangle(new Rectangle(location.x, location.y, bounds.width, bounds.height));\n@@ -674,5 +717,0 @@\n-    private void hiddenNodesChanged() {\n-        relayout();\n-        addUndo();\n-    }\n-\n@@ -683,1 +721,7 @@\n-    private boolean isVisible(Connection c) {\n+    public boolean isVisibleBlockConnection(BlockConnection blockConnection) {\n+        Widget w1 = getWidget(blockConnection.getFromCluster());\n+        Widget w2 = getWidget(blockConnection.getToCluster());\n+        return w1.isVisible() && w2.isVisible();\n+    }\n+\n+    private boolean isVisibleFigureConnection(FigureConnection figureConnection) {\n@@ -687,1 +731,1 @@\n-        if (getModel().getShowCFG() && c instanceof FigureConnection) {\n+        if (getModel().getShowCFG()) {\n@@ -690,9 +734,2 @@\n-        Widget w1, w2;\n-        if (c instanceof BlockConnection) {\n-            w1 = getWidget(((Block)c.getFromCluster()).getInputBlock());\n-            w2 = getWidget(((Block)c.getToCluster()).getInputBlock());\n-        } else {\n-            assert (c instanceof FigureConnection);\n-            w1 = getWidget(c.getFrom().getVertex());\n-            w2 = getWidget(c.getTo().getVertex());\n-        }\n+        Widget w1 = getWidget(figureConnection.getFrom().getVertex());\n+        Widget w2 = getWidget(figureConnection.getTo().getVertex());\n@@ -702,1 +739,1 @@\n-    private void doStableSeaLayout(HashSet<Figure> visibleFigures, HashSet<Connection> visibleConnections) {\n+    private void doStableSeaLayout(Set<Figure> visibleFigures, Set<Connection> visibleConnections) {\n@@ -713,64 +750,4 @@\n-    private void doSeaLayout(HashSet<Figure> figures, HashSet<Connection> edges) {\n-        HierarchicalLayoutManager manager = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n-        manager.setCutEdges(model.getCutEdges());\n-        manager.doLayout(new LayoutGraph(edges, figures));\n-        hierarchicalStableLayoutManager.setShouldRedrawLayout(true);\n-    }\n-\n-    private void doClusteredLayout(HashSet<Connection> edges) {\n-        HierarchicalClusterLayoutManager m = new HierarchicalClusterLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n-        HierarchicalLayoutManager manager = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n-        manager.setCutEdges(model.getCutEdges());\n-        manager.setMinLayerDifference(3);\n-        m.setManager(manager);\n-        m.setSubManager(new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS));\n-        m.doLayout(new LayoutGraph(edges));\n-    }\n-\n-    private void doCFGLayout(HashSet<Figure> figures, HashSet<Connection> edges) {\n-        Diagram diagram = getModel().getDiagram();\n-        HierarchicalCFGLayoutManager m = new HierarchicalCFGLayoutManager();\n-        HierarchicalLayoutManager manager = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n-        manager.setCutEdges(model.getCutEdges());\n-        manager.setMinLayerDifference(1);\n-        manager.setLayoutSelfEdges(true);\n-        manager.setXOffset(25);\n-        manager.setLayerOffset(25);\n-        m.setManager(manager);\n-        Map<InputNode, Figure> nodeFig = new HashMap<>();\n-        for (Figure f : figures) {\n-            InputNode n = f.getInputNode();\n-            if (n != null) {\n-                nodeFig.put(n, f);\n-            }\n-        }\n-        \/\/ Compute global ranking among figures given by in-block order. If\n-        \/\/ needed, this could be cached as long as it is computed for all the\n-        \/\/ figures in the model, not just the visible ones.\n-        Map<Figure, Integer> figureRank = new HashMap<>(figures.size());\n-        int r = 0;\n-        for (InputBlock b : diagram.getInputBlocks()) {\n-            for (InputNode n : b.getNodes()) {\n-                Figure f = nodeFig.get(n);\n-                if (f != null) {\n-                    figureRank.put(f, r);\n-                    r++;\n-                }\n-            }\n-        }\n-        \/\/ Add visible connections for CFG edges.\n-        for (BlockConnection c : diagram.getBlockConnections()) {\n-            if (isVisible(c)) {\n-                edges.add(c);\n-            }\n-        }\n-        m.setSubManager(new LinearLayoutManager(figureRank));\n-        Set<Block> visibleBlocks = new HashSet<>();\n-        for (Block b : diagram.getBlocks()) {\n-            BlockWidget w = getWidget(b.getInputBlock());\n-            if (w.isVisible()) {\n-                visibleBlocks.add(b);\n-            }\n-        }\n-        m.setClusters(new HashSet<>(visibleBlocks));\n-        m.doLayout(new LayoutGraph(edges, figures));\n+    private void doSeaLayout(Set<Figure> visibleFigures, Set<Connection> visibleConnections) {\n+        seaLayoutManager = new HierarchicalLayoutManager();\n+        seaLayoutManager.setCutEdges(model.getCutEdges());\n+        seaLayoutManager.doLayout(new LayoutGraph(visibleConnections, visibleFigures));\n@@ -779,0 +756,5 @@\n+    private void doClusteredLayout(Set<Figure> visibleFigures, Set<Connection> visibleConnections) {\n+        HierarchicalClusterLayoutManager clusterLayoutManager = new HierarchicalClusterLayoutManager();\n+        clusterLayoutManager.setCutEdges(model.getCutEdges());\n+        clusterLayoutManager.doLayout(new LayoutGraph(visibleConnections, visibleFigures));\n+    }\n@@ -780,0 +762,5 @@\n+    private void doCFGLayout(Set<Figure> visibleFigures, Set<Connection> visibleConnections) {\n+        HierarchicalCFGLayoutManager cfgLayoutManager = new HierarchicalCFGLayoutManager(getVisibleBlockConnections(), getVisibleBlocks());\n+        cfgLayoutManager.setCutEdges(model.getCutEdges());\n+        cfgLayoutManager.doLayout(new LayoutGraph(visibleConnections, visibleFigures));\n+    }\n@@ -793,7 +780,2 @@\n-    private void processOutputSlot(OutputSlot outputSlot, List<Connection> connections, int controlPointIndex, Point lastPoint, LineWidget predecessor) {\n-        Map<Point, List<Connection>> pointMap = new HashMap<>(connections.size());\n-\n-        for (Connection connection : connections) {\n-            if (!isVisible(connection)) {\n-                continue;\n-            }\n+    private void processOutputSlot(OutputSlot outputSlot, List<FigureConnection> connections, int controlPointIndex, Point lastPoint, LineWidget predecessor) {\n+        Map<Point, List<FigureConnection>> pointMap = new HashMap<>(connections.size());\n@@ -801,14 +783,15 @@\n-            List<Point> controlPoints = connection.getControlPoints();\n-            if (controlPointIndex >= controlPoints.size()) {\n-                continue;\n-            }\n-\n-            Point currentPoint = controlPoints.get(controlPointIndex);\n-            if (currentPoint == null) { \/\/ Long connection, has been cut vertically.\n-                currentPoint = specialNullPoint;\n-            } else if (connection.hasSlots()) {\n-                if (controlPointIndex == 0 && !outputSlot.shouldShowName()) {\n-                    currentPoint = new Point(currentPoint.x, currentPoint.y - SLOT_OFFSET);\n-                } else if (controlPointIndex == controlPoints.size() - 1 &&\n-                           !((Slot)connection.getTo()).shouldShowName()) {\n-                    currentPoint = new Point(currentPoint.x, currentPoint.y + SLOT_OFFSET);\n+        for (FigureConnection connection : connections) {\n+            if (isVisibleFigureConnection(connection)) {\n+                List<Point> controlPoints = connection.getControlPoints();\n+                if (controlPointIndex < controlPoints.size()) {\n+                    Point currentPoint = controlPoints.get(controlPointIndex);\n+                    if (currentPoint == null) { \/\/ Long connection, has been cut vertically.\n+                        currentPoint = specialNullPoint;\n+                    } else {\n+                        currentPoint = new Point(currentPoint.x, currentPoint.y);\n+                    }\n+                    if (pointMap.containsKey(currentPoint)) {\n+                        pointMap.get(currentPoint).add(connection);\n+                    } else {\n+                        pointMap.put(currentPoint, new ArrayList<>(Collections.singletonList(connection)));\n+                    }\n@@ -817,8 +800,0 @@\n-\n-            if (pointMap.containsKey(currentPoint)) {\n-                pointMap.get(currentPoint).add(connection);\n-            } else {\n-                List<Connection> newList = new ArrayList<>(2);\n-                newList.add(connection);\n-                pointMap.put(currentPoint, newList);\n-            }\n@@ -828,1 +803,1 @@\n-            List<Connection> connectionList = pointMap.get(currentPoint);\n+            List<FigureConnection> connectionList = pointMap.get(currentPoint);\n@@ -833,1 +808,1 @@\n-            for (Connection c : connectionList) {\n+            for (FigureConnection c : connectionList) {\n@@ -851,1 +826,9 @@\n-                connectionLayer.addChild(newPredecessor);\n+                if (predecessor == null) {\n+                    if (outputSlotToLineWidget.containsKey(outputSlot)) {\n+                        outputSlotToLineWidget.get(outputSlot).add(newPredecessor);\n+                    } else {\n+                        outputSlotToLineWidget.put(outputSlot, new HashSet<>(Collections.singleton(newPredecessor)));\n+                    }\n+                }\n+\n+                newWidgets.add(newPredecessor);\n@@ -858,0 +841,36 @@\n+\n+        if (pointMap.isEmpty()) {\n+            for (FigureConnection connection : connections) {\n+                if (isVisibleFigureConnection(connection)) {\n+                    InputSlot inputSlot = connection.getInputSlot();\n+                    if (inputSlotToLineWidget.containsKey(inputSlot)) {\n+                        inputSlotToLineWidget.get(inputSlot).add(predecessor);\n+                    } else {\n+                        inputSlotToLineWidget.put(inputSlot, new HashSet<>(Collections.singleton(predecessor)));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void processBlockConnection(BlockConnection blockConnection) {\n+        boolean isDashed = blockConnection.getStyle() == Connection.ConnectionStyle.DASHED;\n+        boolean isBold = blockConnection.getStyle() == Connection.ConnectionStyle.BOLD;\n+        boolean isVisible = blockConnection.getStyle() != Connection.ConnectionStyle.INVISIBLE;\n+        Point lastPoint = null;\n+        LineWidget predecessor = null;\n+        for (Point currentPoint : blockConnection.getControlPoints()) {\n+            if (currentPoint == null) { \/\/ Long connection, has been cut vertically.\n+                currentPoint = specialNullPoint;\n+            } else if (lastPoint != specialNullPoint && lastPoint != null) {\n+                List<BlockConnection> connectionList = Collections.singletonList(blockConnection);\n+                Point src = new Point(lastPoint);\n+                Point dest = new Point(currentPoint);\n+                predecessor = new LineWidget(this, null, connectionList, src, dest, predecessor, isBold, isDashed);\n+                predecessor.setVisible(isVisible);\n+                connectionLayer.addChild(predecessor);\n+                addObject(new ConnectionSet(connectionList), predecessor);\n+                predecessor.getActions().addAction(hoverAction);\n+            }\n+            lastPoint = currentPoint;\n+        }\n@@ -874,1 +893,1 @@\n-        private Set<Connection> connections;\n+        private Collection<? extends Connection> connections;\n@@ -876,6 +895,2 @@\n-        public ConnectionSet(Collection<Connection> connections) {\n-            connections = new HashSet<>(connections);\n-        }\n-\n-        public Set<Connection> getConnectionSet() {\n-            return Collections.unmodifiableSet(connections);\n+        public ConnectionSet(Collection<? extends Connection> connections) {\n+            this.connections = connections;\n@@ -891,1 +906,1 @@\n-        BlockWidget bw = getWidget(block.getInputBlock());\n+        BlockWidget bw = getWidget(block);\n@@ -893,1 +908,1 @@\n-            centerRectangle(bw.getBounds(), true);\n+            centerRectangle(bw.getBounds());\n@@ -940,1 +955,1 @@\n-            centerRectangle(overallRect, true);\n+            centerRectangle(overallRect);\n@@ -944,1 +959,1 @@\n-    private void centerRectangle(Rectangle r, boolean zoomToFit) {\n+    private void centerRectangle(Rectangle r) {\n@@ -947,14 +962,0 @@\n-        if (zoomToFit) {\n-            double factor = Math.min(viewRect.getWidth() \/ rect.getWidth(),  viewRect.getHeight() \/ rect.getHeight());\n-            double zoomFactor = getZoomFactor();\n-            double newZoomFactor = zoomFactor * factor;\n-            if (factor < 1.0 || zoomFactor < 1.0) {\n-                newZoomFactor = Math.min(1.0, newZoomFactor);\n-                centredZoom(newZoomFactor, null);\n-                factor = newZoomFactor \/ zoomFactor;\n-                rect.x *= factor;\n-                rect.y *= factor;\n-                rect.width *= factor;\n-                rect.height *= factor;\n-            }\n-        }\n@@ -962,0 +963,12 @@\n+        double factor = Math.min(viewRect.getWidth() \/ rect.getWidth(),  viewRect.getHeight() \/ rect.getHeight());\n+        double zoomFactor = getZoomFactor();\n+        double newZoomFactor = zoomFactor * factor;\n+        if (factor < 1.0 || zoomFactor < 1.0) {\n+            newZoomFactor = Math.min(1.0, newZoomFactor);\n+            centredZoom(newZoomFactor, null);\n+            factor = newZoomFactor \/ zoomFactor;\n+            rect.x *= factor;\n+            rect.y *= factor;\n+            rect.width *= factor;\n+            rect.height *= factor;\n+        }\n@@ -1006,0 +1019,2 @@\n+    private final ArrayList<LineWidget> newWidgets = new ArrayList<>();\n+\n@@ -1007,0 +1022,2 @@\n+        outputSlotToLineWidget.clear();\n+        inputSlotToLineWidget.clear();\n@@ -1008,0 +1025,1 @@\n+        newWidgets.clear();\n@@ -1010,1 +1028,1 @@\n-                List<Connection> connectionList = new ArrayList<>(outputSlot.getConnections());\n+                List<FigureConnection> connectionList = new ArrayList<>(outputSlot.getConnections());\n@@ -1017,2 +1035,2 @@\n-                if (isVisible(blockConnection)) {\n-                    processOutputSlot(null, Collections.singletonList(blockConnection), 0, null, null);\n+                if (isVisibleBlockConnection(blockConnection)) {\n+                    processBlockConnection(blockConnection);\n@@ -1022,0 +1040,3 @@\n+\n+        connectionLayer.addChildren(newWidgets);\n+        newWidgets.clear();\n@@ -1038,2 +1059,2 @@\n-            for (InputBlock inputBlock : getModel().getDiagram().getInputBlocks()) {\n-                BlockWidget blockWidget = getWidget(inputBlock);\n+            for (Block block : getModel().getDiagram().getBlocks()) {\n+                BlockWidget blockWidget = getWidget(block);\n@@ -1088,1 +1109,1 @@\n-            Set<InputBlock> visibleBlocks = new HashSet<>();\n+            Set<Block> visibleBlocks = new HashSet<>();\n@@ -1092,1 +1113,1 @@\n-                    visibleBlocks.add(figure.getBlock().getInputBlock());\n+                    visibleBlocks.add(figure.getBlock());\n@@ -1097,1 +1118,1 @@\n-                visibleBlocks.addAll(getModel().getDiagram().getInputBlocks());\n+                visibleBlocks.addAll(getModel().getDiagram().getBlocks());\n@@ -1109,1 +1130,1 @@\n-            for (InputBlock inputBlock : getModel().getDiagram().getInputBlocks()) {\n+            for (Block block : getModel().getDiagram().getBlocks()) {\n@@ -1112,4 +1133,3 @@\n-                boolean visibleAfter = visibleBlocks.contains(inputBlock) &&\n-                        !(getModel().getShowCFG() && (inputBlock.isArtificial() || inputBlock.getNodes().isEmpty()));\n-\n-                BlockWidget blockWidget = getWidget(inputBlock);\n+                boolean visibleAfter = visibleBlocks.contains(block) &&\n+                        !(getModel().getShowCFG() && (block.getInputBlock().isArtificial() || block.getInputBlock().getNodes().isEmpty()));\n+                BlockWidget blockWidget = getWidget(block);\n@@ -1121,1 +1141,1 @@\n-    private HashSet<Figure> getVisibleFigures() {\n+    private Set<Figure> getVisibleFigures() {\n@@ -1132,0 +1152,21 @@\n+    private Set<Cluster> getVisibleBlocks() {\n+        Set<Cluster> visibleBlocks = new HashSet<>();\n+        for (Block b : getModel().getDiagram().getBlocks()) {\n+            BlockWidget w = getWidget(b);\n+            if (w.isVisible()) {\n+                visibleBlocks.add(b);\n+            }\n+        }\n+        return visibleBlocks;\n+    }\n+\n+    private Set<Connection> getVisibleBlockConnections() {\n+        Set<Connection> clusterLinks = new HashSet<>();\n+        for (BlockConnection c : getModel().getDiagram().getBlockConnections()) {\n+            if (isVisibleBlockConnection(c)) {\n+                clusterLinks.add(c);\n+            }\n+        }\n+        return clusterLinks;\n+    }\n+\n@@ -1134,2 +1175,2 @@\n-        for (Connection connection : getModel().getDiagram().getConnections()) {\n-            if (isVisible(connection)) {\n+        for (FigureConnection connection : getModel().getDiagram().getConnections()) {\n+            if (isVisibleFigureConnection(connection)) {\n@@ -1161,1 +1202,1 @@\n-                BlockWidget blockWidget = getWidget(block.getInputBlock());\n+                BlockWidget blockWidget = getWidget(block);\n@@ -1174,59 +1215,2 @@\n-    private void centerSingleSelectedFigure() {\n-        if (model.getSelectedFigures().size() == 1) {\n-            if (getSceneAnimator().getPreferredLocationAnimator().isRunning()) {\n-                getSceneAnimator().getPreferredLocationAnimator().addAnimatorListener(new AnimatorListener() {\n-                    @Override\n-                    public void animatorStarted(AnimatorEvent animatorEvent) {}\n-\n-                    @Override\n-                    public void animatorReset(AnimatorEvent animatorEvent) {}\n-\n-                    @Override\n-                    public void animatorFinished(AnimatorEvent animatorEvent) {\n-                        getSceneAnimator().getPreferredLocationAnimator().removeAnimatorListener(this);\n-                    }\n-\n-                    @Override\n-                    public void animatorPreTick(AnimatorEvent animatorEvent) {}\n-\n-                    @Override\n-                    public void animatorPostTick(AnimatorEvent animatorEvent) {\n-                        validateAll();\n-                        centerSelectedFigures();\n-                    }\n-                });\n-            } else {\n-                centerSelectedFigures();\n-            }\n-        }\n-    }\n-\n-    private void relayout() {\n-        rebuilding = true;\n-        Set<FigureWidget> oldVisibleFigureWidgets = getVisibleFigureWidgets();\n-        Set<BlockWidget> oldVisibleBlockWidgets = getVisibleBlockWidgets();\n-\n-        updateVisibleFigureWidgets();\n-        updateNodeHull();\n-        updateVisibleBlockWidgets();\n-\n-        HashSet<Figure> visibleFigures = getVisibleFigures();\n-        HashSet<Connection> visibleConnections = getVisibleConnections();\n-        if (getModel().getShowStableSea()) {\n-            doStableSeaLayout(visibleFigures, visibleConnections);\n-        } else if (getModel().getShowSea()) {\n-            doSeaLayout(visibleFigures, visibleConnections);\n-        } else if (getModel().getShowBlocks()) {\n-            doClusteredLayout(visibleConnections);\n-        } else if (getModel().getShowCFG()) {\n-            doCFGLayout(visibleFigures, visibleConnections);\n-        }\n-        rebuildConnectionLayer();\n-\n-        updateFigureWidgetLocations(oldVisibleFigureWidgets);\n-        updateBlockWidgetBounds(oldVisibleBlockWidgets);\n-        validateAll();\n-\n-        centerSingleSelectedFigure();\n-        rebuilding = false;\n-    }\n+    Map<OutputSlot, Set<LineWidget>> outputSlotToLineWidget = new HashMap<>();\n+    Map<InputSlot, Set<LineWidget>> inputSlotToLineWidget = new HashMap<>();\n@@ -1298,0 +1282,1 @@\n+\n@@ -1306,1 +1291,0 @@\n-        ModelState newModelState = new ModelState(model);\n@@ -1308,0 +1292,1 @@\n+            ModelState newModelState = new ModelState(model);\n@@ -1310,0 +1295,1 @@\n+            modelState = newModelState;\n@@ -1311,1 +1297,0 @@\n-        modelState = newModelState;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":226,"deletions":241,"binary":false,"changes":467,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+        centerPanel.setOpaque(true);\n@@ -199,11 +200,0 @@\n-        diagramViewModel.getGraphChangedEvent().addListener(model -> {\n-            \/\/ HierarchicalStableLayoutManager is not reliable for difference graphs\n-            boolean isDiffGraph = model.getGraph().isDiffGraph();\n-            \/\/ deactivate HierarchicalStableLayoutManager for difference graphs\n-            stableSeaLayoutButton.setEnabled(!isDiffGraph);\n-            if (stableSeaLayoutButton.isSelected() && isDiffGraph) {\n-                \/\/ fallback to HierarchicalLayoutManager for difference graphs\n-                seaLayoutButton.setSelected(true);\n-            }\n-        });\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.graph.Block;\n@@ -47,1 +48,1 @@\n-    private final InputBlock blockNode;\n+    private final Block block;\n@@ -49,1 +50,1 @@\n-    public BlockWidget(Scene scene, InputBlock blockNode) {\n+    public BlockWidget(Scene scene, Block block) {\n@@ -51,1 +52,1 @@\n-        this.blockNode = blockNode;\n+        this.block = block;\n@@ -74,1 +75,1 @@\n-        String s = \"B\" + blockNode.getName();\n+        String s = \"B\" + getBlockNode().getName();\n@@ -86,1 +87,1 @@\n-            graphProvider.addSelectedNodes(blockWidget.blockNode.getNodes(), false);\n+            graphProvider.addSelectedNodes(blockWidget.getBlockNode().getNodes(), false);\n@@ -90,0 +91,8 @@\n+    public void updatePosition() {\n+        setPreferredLocation(block.getPosition());\n+    }\n+\n+    public InputBlock getBlockNode() {\n+        return block.getInputBlock();\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/BlockWidget.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.hotspot.igv.graph.Slot;\n@@ -35,0 +36,2 @@\n+import java.awt.geom.Path2D;\n+import java.awt.geom.RoundRectangle2D;\n@@ -42,0 +45,2 @@\n+import javax.swing.border.Border;\n+import javax.swing.border.LineBorder;\n@@ -65,4 +70,4 @@\n-    private Figure figure;\n-    private Widget middleWidget;\n-    private ArrayList<LabelWidget> labelWidgets;\n-    private DiagramScene diagramScene;\n+    private final Figure figure;\n+    private final Widget middleWidget;\n+    private final ArrayList<LabelWidget> labelWidgets;\n+    private final DiagramScene diagramScene;\n@@ -70,2 +75,0 @@\n-    private final Node node;\n-    private Widget dummyTop;\n@@ -120,4 +123,0 @@\n-        Widget outer = new Widget(scene);\n-        outer.setBackground(f.getColor());\n-        outer.setLayout(LayoutFactory.createOverlayLayout());\n-\n@@ -125,4 +124,2 @@\n-        SerialAlignment textAlign = scene.getModel().getShowCFG() ?\n-            LayoutFactory.SerialAlignment.LEFT_TOP :\n-            LayoutFactory.SerialAlignment.CENTER;\n-        middleWidget.setLayout(LayoutFactory.createVerticalFlowLayout(textAlign, 0));\n+        middleWidget.setPreferredBounds(new Rectangle(0, 0, f.getWidth(), f.getHeight()));\n+        middleWidget.setLayout(LayoutFactory.createHorizontalFlowLayout(SerialAlignment.CENTER, 0));\n@@ -132,12 +129,1 @@\n-\n-        dummyTop = new Widget(scene);\n-        int extraTopHeight =\n-            getFigure().getDiagram().isCFG() && getFigure().hasNamedInputSlot() ?\n-            Figure.TOP_CFG_HEIGHT : 0;\n-        dummyTop.setMinimumSize(new Dimension(Figure.INSET \/ 2, 1 + extraTopHeight));\n-        middleWidget.addChild(dummyTop);\n-\n-        \/\/ This widget includes the node text and possibly a warning sign to the right.\n-        Widget nodeInfoWidget = new Widget(scene);\n-        nodeInfoWidget.setLayout(LayoutFactory.createAbsoluteLayout());\n-        middleWidget.addChild(nodeInfoWidget);\n+        this.addChild(middleWidget);\n@@ -146,0 +132,3 @@\n+        SerialAlignment textAlign = scene.getModel().getShowCFG() ?\n+                LayoutFactory.SerialAlignment.LEFT_TOP :\n+                LayoutFactory.SerialAlignment.CENTER;\n@@ -147,1 +136,1 @@\n-        nodeInfoWidget.addChild(textWidget);\n+        middleWidget.addChild(textWidget);\n@@ -160,1 +149,0 @@\n-            lw.setBorder(BorderFactory.createEmptyBorder());\n@@ -166,0 +154,7 @@\n+        for (int i=1; i < labelWidgets.size(); i++) {\n+            labelWidgets.get(i).setFont(Diagram.FONT.deriveFont(Font.ITALIC));\n+            labelWidgets.get(i).setForeground(Color.DARK_GRAY);\n+        }\n+\n+\n+        int textHeight = f.getHeight() - 2 * Figure.PADDING - f.getSlotsHeight();\n@@ -168,2 +163,0 @@\n-            Point warningLocation = new Point(getFigure().getWidth() - Figure.WARNING_WIDTH - Figure.INSET \/ 2, 0);\n-            warningWidget.setPreferredLocation(warningLocation);\n@@ -171,1 +164,7 @@\n-            nodeInfoWidget.addChild(warningWidget);\n+            middleWidget.addChild(warningWidget);\n+            int textWidth = f.getWidth() - 4 * Figure.BORDER;\n+            textWidth -= Figure.WARNING_WIDTH + Figure.PADDING;\n+            textWidget.setPreferredBounds(new Rectangle(0, 0, textWidth, textHeight));\n+        } else {\n+            int textWidth = f.getWidth() - 4 * Figure.BORDER;\n+            textWidget.setPreferredBounds(new Rectangle(0, 0, textWidth, textHeight));\n@@ -174,10 +173,0 @@\n-        Widget dummyBottom = new Widget(scene);\n-        int extraBottomHeight =\n-            getFigure().getDiagram().isCFG() && getFigure().hasNamedOutputSlot() ?\n-            Figure.BOTTOM_CFG_HEIGHT : 0;\n-        dummyBottom.setMinimumSize(new Dimension(Figure.INSET \/ 2, 1  + extraBottomHeight));\n-        middleWidget.addChild(dummyBottom);\n-\n-        middleWidget.setPreferredBounds(new Rectangle(0, Figure.getVerticalOffset(), f.getWidth(), f.getHeight()));\n-        this.addChild(middleWidget);\n-\n@@ -185,1 +174,1 @@\n-        node = new AbstractNode(Children.LEAF) {\n+        Node node = new AbstractNode(Children.LEAF) {\n@@ -199,0 +188,32 @@\n+    public int getFigureHeight() {\n+        return middleWidget.getPreferredBounds().height;\n+    }\n+\n+    public static class RoundedBorder extends LineBorder {\n+\n+        final float RADIUS = 3f;\n+\n+        public RoundedBorder(Color color, int thickness)  {\n+            super(color, thickness);\n+        }\n+\n+        @Override\n+        public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {\n+            if ((this.thickness > 0) && (g instanceof Graphics2D)) {\n+                Graphics2D g2d = (Graphics2D) g;\n+                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+                Color oldColor = g2d.getColor();\n+                g2d.setColor(this.lineColor);\n+                int offs = this.thickness;\n+                int size = offs + offs;\n+                Shape outer = new RoundRectangle2D.Float(x, y, width, height, RADIUS, RADIUS);\n+                Shape inner = new RoundRectangle2D.Float(x + offs, y + offs, width - size, height - size, RADIUS, RADIUS);\n+                Path2D path = new Path2D.Float(Path2D.WIND_EVEN_ODD);\n+                path.append(outer, false);\n+                path.append(inner, false);\n+                g2d.fill(path);\n+                g2d.setColor(oldColor);\n+            }\n+        }\n+    }\n+\n@@ -211,1 +232,2 @@\n-        int thickness = 1;\n+        Color borderColor = Color.BLACK;\n+        Color innerBorderColor = getFigure().getColor();\n@@ -214,1 +236,1 @@\n-            thickness = 2;\n+            innerBorderColor = Color.BLACK;\n@@ -217,2 +239,0 @@\n-        Color borderColor = Color.BLACK;\n-        Color innerBorderColor = getFigure().getColor();\n@@ -223,1 +243,5 @@\n-        middleWidget.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(borderColor, thickness), BorderFactory.createLineBorder(innerBorderColor, 1)));\n+        Border innerBorder = new RoundedBorder(borderColor, Figure.BORDER);\n+        Border outerBorder = new RoundedBorder(innerBorderColor, Figure.BORDER);\n+        Border roundedBorder = BorderFactory.createCompoundBorder(innerBorder, outerBorder);\n+        middleWidget.setBorder(roundedBorder);\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/FigureWidget.java","additions":71,"deletions":47,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.List;\n@@ -48,2 +47,2 @@\n-    public InputSlotWidget(InputSlot slot, DiagramScene scene, Widget parent, FigureWidget fw) {\n-        super(slot, scene, parent, fw);\n+    public InputSlotWidget(InputSlot slot, DiagramScene scene, FigureWidget fw) {\n+        super(slot, scene, fw);\n@@ -58,7 +57,0 @@\n-    @Override\n-    protected int calculateSlotWidth() {\n-        List<InputSlot> slots = getSlot().getFigure().getInputSlots();\n-        assert slots.contains(getSlot());\n-        return calculateWidth(slots.size());\n-    }\n-\n@@ -68,1 +60,1 @@\n-            calculateClientArea().height - 1 : Figure.SLOT_START;\n+            calculateClientArea().height \/ 2 : 0;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/InputSlotWidget.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,1 @@\n-import java.util.ArrayList;\n-import java.util.HashSet;\n+import java.util.*;\n@@ -39,1 +38,0 @@\n-import java.util.Set;\n@@ -64,1 +62,1 @@\n-    private final List<Connection> connections;\n+    private final List<? extends Connection> connections;\n@@ -67,1 +65,1 @@\n-    private final Rectangle clientArea;\n+    private Rectangle clientArea;\n@@ -74,0 +72,1 @@\n+    private boolean needToInitToolTipText = true;\n@@ -75,1 +74,1 @@\n-    public LineWidget(DiagramScene scene, OutputSlot s, List<Connection> connections, Point from, Point to, LineWidget predecessor, boolean isBold, boolean isDashed) {\n+    public LineWidget(DiagramScene scene, OutputSlot s, List<? extends Connection> connections, Point from, Point to, LineWidget predecessor, boolean isBold, boolean isDashed) {\n@@ -79,1 +78,1 @@\n-        this.connections = connections;\n+        this.connections = Collections.unmodifiableList(connections);\n@@ -91,18 +90,1 @@\n-        int minX = from.x;\n-        int minY = from.y;\n-        int maxX = to.x;\n-        int maxY = to.y;\n-        if (minX > maxX) {\n-            int tmp = minX;\n-            minX = maxX;\n-            maxX = tmp;\n-        }\n-\n-        if (minY > maxY) {\n-            int tmp = minY;\n-            minY = maxY;\n-            maxY = tmp;\n-        }\n-\n-        clientArea = new Rectangle(minX, minY, maxX - minX + 1, maxY - minY + 1);\n-        clientArea.grow(BORDER, BORDER);\n+        computeClientArea();\n@@ -111,1 +93,1 @@\n-        if (connections.size() > 0) {\n+        if (!connections.isEmpty()) {\n@@ -114,1 +96,0 @@\n-        setToolTipText(\"<HTML>\" + generateToolTipText(this.connections) + \"<\/HTML>\");\n@@ -116,1 +97,1 @@\n-        setCheckClipping(true);\n+        setCheckClipping(false);\n@@ -147,1 +128,25 @@\n-    private String generateToolTipText(List<Connection> conn) {\n+    private void computeClientArea() {\n+        int minX = from.x;\n+        int minY = from.y;\n+        int maxX = to.x;\n+        int maxY = to.y;\n+\n+        \/\/ Ensure min and max values are correct\n+        if (minX > maxX) {\n+            int tmp = minX;\n+            minX = maxX;\n+            maxX = tmp;\n+        }\n+\n+        if (minY > maxY) {\n+            int tmp = minY;\n+            minY = maxY;\n+            maxY = tmp;\n+        }\n+\n+        \/\/ Set client area to include the curve and add a BORDER for extra space\n+        clientArea = new Rectangle(minX, minY, maxX - minX + 1, maxY - minY + 1);\n+        clientArea.grow(BORDER, BORDER);\n+    }\n+\n+    private String generateToolTipText(List<? extends Connection> conn) {\n@@ -179,1 +184,1 @@\n-        Graphics2D g = getScene().getGraphics();\n+        Graphics2D g = this.getGraphics();\n@@ -198,1 +203,1 @@\n-            g.setStroke(new BasicStroke(width));\n+            g.setStroke(new BasicStroke(width, BasicStroke.CAP_ROUND, BasicStroke.JOIN_MITER));\n@@ -237,0 +242,1 @@\n+        super.paintWidget();\n@@ -257,0 +263,4 @@\n+            if (enableHighlighting && needToInitToolTipText) {\n+                setToolTipText(\"<HTML>\" + generateToolTipText(this.connections) + \"<\/HTML>\");\n+                needToInitToolTipText = false; \/\/ Ensure it's only set once\n+            }\n@@ -353,0 +363,1 @@\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/LineWidget.java","additions":43,"deletions":32,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.graph.Figure;\n@@ -29,2 +28,0 @@\n-import java.util.List;\n-import org.netbeans.api.visual.widget.Widget;\n@@ -40,2 +37,2 @@\n-    public OutputSlotWidget(OutputSlot slot, DiagramScene scene, Widget parent, FigureWidget fw) {\n-        super(slot, scene, parent, fw);\n+    public OutputSlotWidget(OutputSlot slot, DiagramScene scene, FigureWidget fw) {\n+        super(slot, scene, fw);\n@@ -49,8 +46,0 @@\n-    @Override\n-    protected int calculateSlotWidth() {\n-        List<OutputSlot> slots = getSlot().getFigure().getOutputSlots();\n-        assert slots.contains(getSlot());\n-        return calculateWidth(slots.size());\n-\n-    }\n-\n@@ -60,2 +49,2 @@\n-            calculateClientArea().height : Figure.SLOT_START;\n-        return getSlot().getFigure().getHeight() - overlap;\n+            calculateClientArea().height \/ 2 : 0;\n+        return getFigureWidget().getFigureHeight() - overlap;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/OutputSlotWidget.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import com.sun.hotspot.igv.graph.OutputSlot;\n@@ -53,1 +52,1 @@\n-    public SlotWidget(Slot slot, DiagramScene scene, Widget parent, FigureWidget fw) {\n+    public SlotWidget(Slot slot, DiagramScene scene, FigureWidget fw) {\n@@ -63,6 +62,8 @@\n-        parent.addChild(this);\n-\n-        Point p = slot.getRelativePosition();\n-        p.x -= this.calculateClientArea().width \/ 2;\n-        p.y += yOffset();\n-        this.setPreferredLocation(p);\n+        fw.addChild(this);\n+        if (slot.shouldShowName()) {\n+            Point p = slot.getRelativePosition();\n+            p.x -= slot.getWidth() \/ 2;\n+            p.y -= slot.getHeight() \/ 2;\n+            p.y += yOffset(); \/\/ TODO use fw\n+            this.setPreferredLocation(p);\n+        }\n@@ -143,7 +144,1 @@\n-                if (slot instanceof OutputSlot) {\n-                    g.fillOval(w \/ 2 - r, Figure.SLOT_WIDTH - Figure.SLOT_START - r, 2 * r, 2 * r);\n-                } else {\n-                    g.fillOval(w \/ 2 - r, Figure.SLOT_START - r, 2 * r, 2 * r);\n-                }\n-            } else {\n-                \/\/ Do not paint a slot with connections.\n+                g.fillOval(w \/ 2 - r, h \/ 2 - r, 2 * r, 2 * r);\n@@ -156,1 +151,1 @@\n-        return new Rectangle(0, 0, slot.getWidth(), Figure.SLOT_WIDTH);\n+        return new Rectangle(0, 0, slot.getWidth(), slot.getHeight());\n@@ -159,2 +154,0 @@\n-    protected abstract int calculateSlotWidth();\n-\n@@ -163,4 +156,0 @@\n-    protected int calculateWidth(int count) {\n-        return getFigureWidget().getFigure().getWidth() \/ count;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/SlotWidget.java","additions":12,"deletions":23,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-mvn --batch-mode -f application\/pom.xml nbm:run-platform >.igv.log 2>&1\n+mvn --batch-mode -f application\/pom.xml nbm:run-platform -Dnetbeans.run.params=\"-J-da\" >.igv.log 2>&1\n","filename":"src\/utils\/IdealGraphVisualizer\/igv.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}