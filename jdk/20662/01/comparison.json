{"files":[{"patch":"@@ -577,1 +577,3 @@\n-     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}.\n+     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}. Moreover,\n+     * the value of {@code b} must be such that the computation for {@code offset} does not overflow,\n+     * or the returned method handle throws {@link ArithmeticException}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    private static final MethodHandle MH_ADD;\n+    private static final MethodHandle MH_ADD_EXACT;\n@@ -84,1 +84,1 @@\n-            MH_ADD = lookup.findStatic(Long.class, \"sum\",\n+            MH_ADD_EXACT = lookup.findStatic(Math.class, \"addExact\",\n@@ -247,1 +247,1 @@\n-        MethodHandle mh = MethodHandles.insertArguments(MH_ADD, 0, offset);\n+        MethodHandle mh = MH_ADD_EXACT;\n@@ -250,3 +250,7 @@\n-            \/\/ (J, ...) -> J to (J, J, ...) -> J\n-            \/\/ i.e. new coord is prefixed. Last coord will correspond to innermost layout\n-            mh = MethodHandles.collectArguments(mh, 0, collector);\n+            \/\/ (J, J, ...) -> J to (J, J, J, ...) -> J\n+            \/\/ 1. the leading argument is the base offset (externally provided).\n+            \/\/ 2. index arguments are added. The last index correspond to the innermost layout.\n+            \/\/ 3. overflow can only occur at the outermost layer, due to the final addition with the base offset.\n+            \/\/ This is because the layout API ensures (by construction) that all offsets generated from layout paths\n+            \/\/ are always < Long.MAX_VALUE.\n+            mh = MethodHandles.collectArguments(mh, 1, collector);\n@@ -254,2 +258,1 @@\n-\n-        return mh;\n+        return MethodHandles.insertArguments(mh, 1, offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -335,0 +335,8 @@\n+    @Test(dataProvider = \"testLayouts\", expectedExceptions = ArithmeticException.class)\n+    public void testOffsetHandleOverflow(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                         long expectedByteOffset) throws Throwable {\n+        MethodHandle byteOffsetHandle = layout.byteOffsetHandle(pathElements);\n+        byteOffsetHandle = byteOffsetHandle.asSpreader(long[].class, indexes.length);\n+        byteOffsetHandle.invoke(Long.MAX_VALUE, indexes);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}