{"files":[{"patch":"@@ -44,1 +44,1 @@\n-#include \"utilities\/deferred.hpp\"\n+#include \"utilities\/deferredStatic.hpp\"\n@@ -53,1 +53,1 @@\n-Deferred<MemBaseline> MemTracker::_baseline;\n+DeferredStatic<MemBaseline> MemTracker::_baseline;\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"utilities\/deferredStatic.hpp\"\n@@ -38,1 +39,0 @@\n-#include \"utilities\/deferred.hpp\"\n@@ -322,1 +322,1 @@\n-  static Deferred<MemBaseline>      _baseline;\n+  static DeferredStatic<MemBaseline> _baseline;\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-Deferred<MemoryFileTracker> MemoryFileTracker::Instance::_tracker;\n+DeferredStatic<MemoryFileTracker> MemoryFileTracker::Instance::_tracker;\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/deferredStatic.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"utilities\/deferred.hpp\"\n@@ -95,1 +95,1 @@\n-    static Deferred<MemoryFileTracker> _tracker;\n+    static DeferredStatic<MemoryFileTracker> _tracker;\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n-* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n-* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-*\n-* This code is free software; you can redistribute it and\/or modify it\n-* under the terms of the GNU General Public License version 2 only, as\n-* published by the Free Software Foundation.\n-*\n-* This code is distributed in the hope that it will be useful, but WITHOUT\n-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-* version 2 for more details (a copy is included in the LICENSE file that\n-* accompanied this code).\n-*\n-* You should have received a copy of the GNU General Public License version\n-* 2 along with this work; if not, write to the Free Software Foundation,\n-* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-*\n-* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-* or visit www.oracle.com if you need additional information or have any\n-* questions.\n-*\n-*\/\n-\n-#ifndef SHARE_UTILITIES_STABLEVALUE_HPP\n-#define SHARE_UTILITIES_STABLEVALUE_HPP\n-\n-#include \"globalDefinitions.hpp\"\n-#include <type_traits>\n-\n-\/\/ The purpose of this class is to defer initialization of a T to a later point in time,\n-\/\/ and then to never deallocate it. This is mainly useful for deferring the initialization of\n-\/\/ static fields in classes, in order to avoid \"Static Initialization Order Fiasco\".\n-template<typename T>\n-class Deferred {\n-  union {\n-    T _t;\n-  };\n-\n-  DEBUG_ONLY(bool _initialized);\n-\n-public:\n-  NONCOPYABLE(Deferred);\n-\n-  Deferred()\n-  DEBUG_ONLY(: _initialized(false)) {\n-    \/\/ Do not construct value, on purpose.\n-  }\n-\n-  ~Deferred() {\n-    \/\/ Do not destruct value, on purpose.\n-  }\n-\n-  T* get() {\n-    assert(_initialized, \"must be initialized before access\");\n-    return &_t;\n-  }\n-\n-  const T* get() const {\n-    assert(_initialized, \"must be initialized before access\");\n-    return &_t;\n-  }\n-\n-  T& operator*() {\n-    return *get();\n-  }\n-\n-  const T& operator*() const {\n-    return *get();\n-  }\n-\n-  T* operator->() {\n-    return get();\n-  }\n-\n-  const T* operator->() const {\n-    return get();\n-  }\n-\n-  template<typename... Ts>\n-  void initialize(Ts&... args) {\n-    assert(!_initialized, \"Double initialization forbidden\");\n-    DEBUG_ONLY(_initialized = true);\n-    using NCVP = std::add_pointer_t<std::remove_cv_t<T>>;\n-    ::new (const_cast<NCVP>(get())) T(args...);\n-  }\n-};\n-\n-#endif \/\/ SHARE_UTILITIES_STABLEVALUE_HPP\n","filename":"src\/hotspot\/share\/utilities\/deferred.hpp","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_UTILITIES_DEFERREDSTATIC_HPP\n+#define SHARE_UTILITIES_DEFERREDSTATIC_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <new>\n+#include <type_traits>\n+\n+\/\/ The purpose of this class is to provide control over the initialization\n+\/\/ time for an object of type T with static storage duration. An instance of\n+\/\/ this class provides storage for an object, sized and aligned for T. The\n+\/\/ object must be explicitly initialized before use. This avoids problems\n+\/\/ resulting from the unspecified initialization time and ordering between\n+\/\/ different objects that comes from using undeferred objects (the so-called\n+\/\/ \"Static Initialization Order Fiasco).\n+\/\/\n+\/\/ Once initialized, the object is never destroyed. This avoids similar issues\n+\/\/ with the timing and ordering of destruction on normal program exit.\n+\/\/\n+\/\/ T must not be a reference type. T may be cv-qualified; accessors will\n+\/\/ return a correspondingly cv-qualified reference to the object.\n+template<typename T>\n+class DeferredStatic {\n+  union {\n+    T _t;\n+  };\n+\n+  DEBUG_ONLY(bool _initialized);\n+\n+public:\n+  NONCOPYABLE(DeferredStatic);\n+\n+  DeferredStatic()\n+  DEBUG_ONLY(: _initialized(false)) {\n+    \/\/ Do not construct value, on purpose.\n+  }\n+\n+  ~DeferredStatic() {\n+    \/\/ Do not destruct value, on purpose.\n+  }\n+\n+  T* get() {\n+    assert(_initialized, \"must be initialized before access\");\n+    return &_t;\n+  }\n+\n+  T& operator*() {\n+    return *get();\n+  }\n+\n+  T* operator->() {\n+    return get();\n+  }\n+\n+  template<typename... Ts>\n+  void initialize(Ts&... args) {\n+    assert(!_initialized, \"Double initialization forbidden\");\n+    DEBUG_ONLY(_initialized = true);\n+    using NCVP = std::add_pointer_t<std::remove_cv_t<T>>;\n+    ::new (const_cast<NCVP>(get())) T(args...);\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_DEFERREDSTATIC_HPP\n","filename":"src\/hotspot\/share\/utilities\/deferredStatic.hpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/deferredStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <type_traits>\n+\n+#include \"unittest.hpp\"\n+\n+class DeferredStaticTestClass {\n+public:\n+  static unsigned _initialized_count;\n+  int _value;\n+  bool _allow_destruction;\n+\n+  DeferredStaticTestClass() : DeferredStaticTestClass(0) {}\n+\n+  DeferredStaticTestClass(int value, bool allow_destruction = false)\n+    : _value(value), _allow_destruction(allow_destruction)\n+  {\n+    ++_initialized_count;\n+  }\n+\n+  ~DeferredStaticTestClass() {\n+    if (!_allow_destruction) {\n+      ShouldNotReachHere();\n+    }\n+  }\n+};\n+\n+unsigned DeferredStaticTestClass::_initialized_count = 0;\n+\n+using TC = DeferredStaticTestClass;\n+\n+DeferredStatic<TC> default_constructed;\n+\n+static_assert(std::is_same<TC*, decltype(default_constructed.get())>::value,\n+              \"expected\");\n+\n+TEST(DeferredStaticTest, default_constructed) {\n+  unsigned init_count = TC::_initialized_count;\n+  default_constructed.initialize();\n+  ASSERT_EQ(init_count + 1, TC::_initialized_count);\n+  ASSERT_EQ(0, default_constructed->_value);\n+  ASSERT_EQ(0, default_constructed.get()->_value);\n+  ASSERT_EQ(0, (*default_constructed)._value);\n+\n+  int new_value = 5;\n+  *default_constructed.get() = TC(new_value, true \/* allow_destruction *\/);\n+  ASSERT_EQ(init_count + 2, TC::_initialized_count);\n+  ASSERT_EQ(new_value, default_constructed->_value);\n+  ASSERT_EQ(new_value, default_constructed.get()->_value);\n+  ASSERT_EQ(new_value, (*default_constructed)._value);\n+\n+  int new_value2 = 8;\n+  default_constructed->_value = new_value2;\n+  ASSERT_EQ(init_count + 2, TC::_initialized_count);\n+  ASSERT_EQ(new_value2, default_constructed->_value);\n+  ASSERT_EQ(new_value2, default_constructed.get()->_value);\n+  ASSERT_EQ(new_value2, (*default_constructed)._value);\n+}\n+\n+DeferredStatic<TC> arg_constructed;\n+\n+TEST(DeferredStaticTest, arg_constructed) {\n+  unsigned init_count = TC::_initialized_count;\n+  int arg = 10;\n+  arg_constructed.initialize(arg);\n+  ASSERT_EQ(init_count + 1, TC::_initialized_count);\n+  ASSERT_EQ(arg, arg_constructed->_value);\n+  ASSERT_EQ(arg, arg_constructed.get()->_value);\n+  ASSERT_EQ(arg, (*arg_constructed)._value);\n+}\n+\n+DeferredStatic<const TC> const_test_object;\n+\n+static_assert(std::is_same<const TC*, decltype(const_test_object.get())>::value,\n+              \"expected\");\n+\n+static_assert(std::is_same<const int*, decltype(&const_test_object->_value)>::value,\n+              \"expected\");\n+\n+TEST(DeferredStaticTest, const_test_object) {\n+  unsigned init_count = TC::_initialized_count;\n+  int arg = 20;\n+  const_test_object.initialize(arg);\n+  ASSERT_EQ(init_count + 1, TC::_initialized_count);\n+  ASSERT_EQ(arg, const_test_object->_value);\n+  ASSERT_EQ(arg, const_test_object.get()->_value);\n+  ASSERT_EQ(arg, (*const_test_object)._value);\n+\n+  \/\/ Doesn't compile, as expected.\n+  \/\/ *const_test_object.get() = TC(0, true \/* allow_destruction *\/);\n+\n+  \/\/ Doesn't compile, as expected.\n+  \/\/ const_test_object->_value = 0;\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_deferredStatic.cpp","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"}]}