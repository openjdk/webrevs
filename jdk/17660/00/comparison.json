{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -861,0 +861,1 @@\n+  assert(!THREAD->owns_locks(), \"allocating metaspace while holding mutex\");\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,0 +124,1 @@\n+\n@@ -133,16 +134,15 @@\n-    ResourceMark rm(THREAD);\n-    {\n-      \/\/ Ensure atomic creation of higher dimensions\n-      MutexLocker mu(THREAD, MultiArray_lock);\n-\n-      \/\/ Check if another thread beat us\n-      if (higher_dimension() == nullptr) {\n-\n-        \/\/ Create multi-dim klass object and link them together\n-        ObjArrayKlass* ak =\n-          ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);\n-        ak->set_lower_dimension(this);\n-        \/\/ use 'release' to pair with lock-free load\n-        release_set_higher_dimension(ak);\n-        assert(ak->is_objArray_klass(), \"incorrect initialization of ObjArrayKlass\");\n-      }\n+    auto test = [&] () { return higher_dimension_acquire() == nullptr; };\n+    bool claim = claim_array_alloc(THREAD, test);\n+\n+    \/\/ This thread is the creator.\n+    if (claim) {\n+      \/\/ Create multi-dim klass object and link them together\n+      ObjArrayKlass* ak =\n+          ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, THREAD);\n+      \/\/ use 'release' to pair with lock-free load\n+      release_set_higher_dimension(ak);\n+\n+      release_array_alloc(THREAD);\n+    }\n+    if (HAS_PENDING_EXCEPTION) {\n+      return nullptr;\n@@ -152,1 +152,2 @@\n-  ObjArrayKlass *ak = higher_dimension();\n+  ObjArrayKlass* ak = higher_dimension();\n+  assert(ak != nullptr, \"should be set\");\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1548,12 +1548,15 @@\n-    ResourceMark rm(THREAD);\n-    JavaThread *jt = THREAD;\n-    {\n-      \/\/ Atomic creation of array_klasses\n-      MutexLocker ma(THREAD, MultiArray_lock);\n-\n-      \/\/ Check if update has already taken place\n-      if (array_klasses() == nullptr) {\n-        ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n-        \/\/ use 'release' to pair with lock-free load\n-        release_set_array_klasses(k);\n-      }\n+\n+    auto test = [&] () { return array_klasses_acquire() == nullptr; };\n+    bool claim = claim_array_alloc(THREAD, test);\n+\n+    \/\/ This thread is the creator.\n+    if (claim) {\n+      ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, THREAD);\n+      \/\/ use 'release' to pair with lock-free load\n+      release_set_array_klasses(k);\n+\n+      \/\/ Release allocateion token\n+      release_array_alloc(THREAD);\n+    }\n+    if (HAS_PENDING_EXCEPTION) {\n+      return nullptr;\n@@ -1562,0 +1565,1 @@\n+\n@@ -1563,2 +1567,3 @@\n-  ObjArrayKlass* oak = array_klasses();\n-  return oak->array_klass(n, THREAD);\n+  ObjArrayKlass* ak = array_klasses();\n+  assert(ak != nullptr, \"should be set\");\n+  return ak->array_klass(n, THREAD);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,17 @@\n+\/\/ Since we can't allocate arrays inside a mutex, winning thread claims the right to allocate\n+JavaThread* Klass::_claim_array_allocate_token = nullptr;\n+\/\/ It's a recursive lock\n+uint _claim_array_allocate_token_refcount = 0;\n+\n+void Klass::set_claim_array_allocate_token(JavaThread* thread) {\n+  if (thread == nullptr) {\n+    _claim_array_allocate_token_refcount--;\n+    if (_claim_array_allocate_token_refcount == 0) {\n+      Atomic::release_store(&_claim_array_allocate_token, thread);\n+    }\n+  } else {\n+    _claim_array_allocate_token_refcount++;\n+    Atomic::release_store(&_claim_array_allocate_token, thread);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -556,0 +556,12 @@\n+ private:\n+  static JavaThread* _claim_array_allocate_token;\n+  static void set_claim_array_allocate_token(JavaThread* thread);\n+\n+ protected:\n+  static JavaThread* claim_array_allocate_token()                { return Atomic::load_acquire(&_claim_array_allocate_token); }\n+ public:\n+  template<typename Function>\n+  static bool claim_array_alloc(JavaThread* current, Function function);\n+  static bool try_claim_array_alloc(JavaThread* current);\n+  static void release_array_alloc(JavaThread* current);\n+\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -79,0 +80,37 @@\n+template<typename Function>\n+inline bool Klass::claim_array_alloc(JavaThread* current, Function function) {\n+  \/\/ Ensure atomic creation of array_klasses or higher dimensions\n+  MonitorLocker ma(current, MultiArray_lock);\n+  JavaThread* winner = claim_array_allocate_token();\n+  while (winner != nullptr && winner != current) {\n+    ma.wait();\n+    winner = claim_array_allocate_token();  \/\/ check again\n+  }\n+\n+  \/\/ Check if update has already taken place\n+  if (function()) {\n+    set_claim_array_allocate_token(current);\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+inline bool Klass::try_claim_array_alloc(JavaThread* current) {\n+  MonitorLocker ma(current, MultiArray_lock);\n+  \/\/ Check if update has already taken place under MultiArray_lock\n+  JavaThread* winner = claim_array_allocate_token();\n+  if (winner == nullptr || winner == current) {\n+    set_claim_array_allocate_token(current);\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+inline void Klass::release_array_alloc(JavaThread* current) {\n+  MonitorLocker ma(current, MultiArray_lock);\n+  set_claim_array_allocate_token(nullptr);\n+  ma.notify_all();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,2 +66,0 @@\n-      super_klass = element_super->array_klass_or_null();\n-      bool supers_exist = super_klass != nullptr;\n@@ -69,1 +67,2 @@\n-      \/\/ We need an array type for each.\n+      \/\/ We need an array type for each before creating this array type.\n+      super_klass = element_super->array_klass(CHECK_NULL);\n@@ -71,1 +70,1 @@\n-      for( int i = element_supers->length()-1; i >= 0; i-- ) {\n+      for (int i = element_supers->length()-1; i >= 0; i-- ) {\n@@ -73,20 +72,6 @@\n-        if (elem_super->array_klass_or_null() == nullptr) {\n-          supers_exist = false;\n-          break;\n-        }\n-      }\n-      if (!supers_exist) {\n-        \/\/ Oops.  Not allocated yet.  Back out, allocate it, and retry.\n-        Klass* ek = nullptr;\n-        {\n-          MutexUnlocker mu(MultiArray_lock);\n-          super_klass = element_super->array_klass(CHECK_NULL);\n-          for( int i = element_supers->length()-1; i >= 0; i-- ) {\n-            Klass* elem_super = element_supers->at(i);\n-            elem_super->array_klass(CHECK_NULL);\n-          }\n-          \/\/ Now retry from the beginning\n-          ek = element_klass->array_klass(n, CHECK_NULL);\n-        }  \/\/ re-lock\n-        return ObjArrayKlass::cast(ek);\n-      }\n+        elem_super->array_klass(CHECK_NULL);\n+      }  \/\/ fall through, because we hold the claim token.\n+      \/\/ Because inheritance is acyclic, we hold the global token and allocate all the arrays.\n+      \/\/ per-klass locks would be more scalable and this would still work for that but jvmti would have\n+      \/\/ to query all the klasses for allocation for any held.\n+      assert(claim_array_allocate_token() == THREAD, \"we allocate all the arrays\");\n@@ -153,0 +138,4 @@\n+  if (element_klass->is_array_klass()) {\n+    set_lower_dimension(ArrayKlass::cast(element_klass));\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":14,"deletions":25,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1785,0 +1785,9 @@\n+  \/\/ If any thread is trying to allocate an ObjArray and fails due to OOM, don't post the event unless\n+  \/\/ we hold the claim token, otherwise any array allocation in Java code from the event will hang.\n+  \/\/ The claim token is like a reentrant lock, so this thread will be able to allocate arrays in the Java\n+  \/\/ code if it wants.\n+  bool claim = Klass::try_claim_array_alloc(thread);\n+  if (!claim) {\n+    return;\n+  }\n+\n@@ -1801,0 +1810,1 @@\n+  Klass::release_array_alloc(thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-Mutex*   MultiArray_lock              = nullptr;\n+Monitor* MultiArray_lock              = nullptr;\n@@ -272,1 +272,1 @@\n-  MUTEX_DEFN(MultiArray_lock                 , PaddedMutex  , safepoint);\n+  MUTEX_DEFN(MultiArray_lock                 , PaddedMonitor, safepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-extern Mutex*   MultiArray_lock;                 \/\/ a lock used to guard allocation of multi-dim arrays\n+extern Monitor* MultiArray_lock;                 \/\/ a lock used to guard allocation of multi-dim arrays\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}