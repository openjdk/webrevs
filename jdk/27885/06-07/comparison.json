{"files":[{"patch":"@@ -50,5 +50,3 @@\n-        cfa = ((dwarf.getCFARegister() == AMD64ThreadContext.RBP) &&\n-               !dwarf.isBPOffsetAvailable())\n-                  ? context.getRegisterAsAddress(AMD64ThreadContext.RBP)\n-                  : context.getRegisterAsAddress(dwarf.getCFARegister())\n-                           .addOffsetTo(dwarf.getCFAOffset());\n+\n+        cfa = context.getRegisterAsAddress(dwarf.getCFARegister())\n+                     .addOffsetTo(dwarf.getCFAOffset());\n@@ -98,2 +96,6 @@\n-   private boolean isValidFrame(Address nextCFA, ThreadContext context) {\n-     return nextCFA != null;\n+   private boolean isValidFrame(Address nextCFA, boolean isNative) {\n+     \/\/ CFA should not be null even if it is Java frame.\n+     \/\/ nextCFA should be greater than (current) cfa between native call.\n+     \/\/ It is ok if the frame is Java-related call.\n+     return nextCFA != null &&\n+         (!isNative || (isNative && nextCFA.greaterThan(cfa)));\n@@ -104,0 +106,1 @@\n+     boolean isNative = false;\n@@ -114,1 +117,1 @@\n-         nextCFA = senderFP;\n+         nextCFA = senderFP.addOffsetTo(-nextDwarf.getBasePointerOffsetFromCFA());\n@@ -116,0 +119,1 @@\n+         isNative = true;\n@@ -117,8 +121,10 @@\n-         if (!dwarf.isBPOffsetAvailable() && \/\/ Use RBP as CFA\n-             (nextCFAReg == AMD64ThreadContext.RBP) &&\n-             (nextCFAReg != dwarf.getCFARegister())) {\n-           nextCFA = context.getRegisterAsAddress(AMD64ThreadContext.RBP);\n-           if (nextCFA == null) {\n-             return null;\n-           }\n-           nextCFA = nextCFA.getAddressAt(0);\n+         if (nextCFAReg == AMD64ThreadContext.RBP) {\n+           Address rbp = dwarf.isBPOffsetAvailable() ? cfa.addOffsetTo(dwarf.getBasePointerOffsetFromCFA())\n+                                                     : context.getRegisterAsAddress(AMD64ThreadContext.RBP);\n+           Address nextRBP = rbp.getAddressAt(0);\n+           nextCFA = nextRBP.addOffsetTo(-nextDwarf.getBasePointerOffsetFromCFA());\n+         } else if (nextCFAReg == AMD64ThreadContext.RSP) {\n+           \/\/ next RSP should be previous slot of return address.\n+           Address nextRSP = cfa.addOffsetTo(dwarf.getReturnAddressOffsetFromCFA())\n+                                .addOffsetTo(ADDRESS_SIZE);\n+           nextCFA = nextRSP.addOffsetTo(nextDwarf.getCFAOffset());\n@@ -126,1 +132,1 @@\n-           nextCFA = cfa.getAddressAt(dwarf.getBasePointerOffsetFromCFA());\n+           throw new DebuggerException(\"Unsupported CFA register: \" + nextCFAReg);\n@@ -129,3 +135,0 @@\n-       if (nextCFA != null) {\n-         nextCFA = nextCFA.addOffsetTo(-nextDwarf.getBasePointerOffsetFromCFA());\n-       }\n@@ -134,1 +137,9 @@\n-     return isValidFrame(nextCFA, context) ? nextCFA : null;\n+     \/\/ Sanity check for next CFA address\n+     try {\n+       nextCFA.getAddressAt(0);\n+     } catch (Exception e) {\n+       \/\/ return null if next CFA address is invalid\n+       return null;\n+     }\n+\n+     return isValidFrame(nextCFA, isNative) ? nextCFA : null;\n@@ -177,2 +188,2 @@\n-     return isValidFrame(nextCFA, context) ? new LinuxAMD64CFrame(dbg, nextCFA, nextPC, nextDwarf)\n-                                           : null;\n+     return nextCFA == null ? null\n+                            : new LinuxAMD64CFrame(dbg, nextCFA, nextPC, nextDwarf);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/amd64\/LinuxAMD64CFrame.java","additions":34,"deletions":23,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -89,2 +89,0 @@\n-        SATestUtils.skipIfRunsOnOlderGLIBC(); \/\/ throws SkippedException if this test runs on older GLIBC.\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackMixedWithXComp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n@@ -34,1 +30,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -41,2 +36,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -83,54 +76,0 @@\n-    \/**\n-     * Checks whether the test runs on older glibc or not.\n-     * On Linux, check glibc version before the test and throws SkipException\n-     * if its version is 2.38 or earlier.\n-     * The problem is not to unwind all of call stacks the process is running on\n-     * older glibc. It happens Debian 12, Ubuntu 22.04 (glibc 2.35) and\n-     * Ubuntu 23.04 (glibc 2.37) at least. It works on Ubuntu 24.04 (glibc 2.39).\n-     * The problem happenes both AMD64 and AArch64.\n-     *\n-     * @throws SkippedException if the test runs on older glibc (2.38 or earlier).\n-     *\/\n-    @SuppressWarnings(\"restricted\")\n-    public static void skipIfRunsOnOlderGLIBC() {\n-        var linker = Linker.nativeLinker();\n-        var lookup = linker.defaultLookup();\n-        var sym = lookup.find(\"gnu_get_libc_version\");\n-        if (sym.isEmpty()) {\n-            \/\/ Maybe the platform is not on glibc (Windows, Mac, musl on Alpine).\n-            \/\/ Go ahead.\n-            return;\n-        }\n-\n-        \/\/ Call gnu_get_libc_version()\n-        var desc = FunctionDescriptor.of(ValueLayout.ADDRESS);\n-        var func = linker.downcallHandle(sym.get(), desc);\n-        MemorySegment result;\n-        try {\n-            result = (MemorySegment)func.invoke();\n-        } catch (Throwable t) {\n-            throw new RuntimeException(t);\n-        }\n-\n-        \/\/ Set the length of glibc version because FFM does not know memory size\n-        \/\/ returned by gnu_get_libc_version().\n-        var strlenSym = lookup.find(\"strlen\");\n-        var strlenDesc = FunctionDescriptor.of(linker.canonicalLayouts().get(\"size_t\"), ValueLayout.ADDRESS);\n-        var strlenFunc = linker.downcallHandle(strlenSym.get(), strlenDesc);\n-        long len;\n-        try {\n-            len = (long)strlenFunc.invoke(result);\n-        } catch (Throwable t) {\n-            throw new RuntimeException(t);\n-        }\n-\n-        result = result.reinterpret(len + 1); \/\/ includes NUL\n-        String[] ver = result.getString(0, StandardCharsets.US_ASCII).split(\"\\\\.\");\n-        int major = Integer.parseInt(ver[0]);\n-        int minor = Integer.parseInt(ver[1]);\n-\n-        if (!(major > 2 || (major == 2 && minor >= 39))) {\n-            throw new SkippedException(\"Older glibc version.\");\n-        }\n-    }\n-\n","filename":"test\/lib\/jdk\/test\/lib\/SA\/SATestUtils.java","additions":1,"deletions":62,"binary":false,"changes":63,"status":"modified"}]}