{"files":[{"patch":"@@ -39,0 +39,5 @@\n+  \/** Find sender frame with given FP and PC *\/\n+  public default CFrame sender(ThreadProxy th, Address fp, Address pc) {\n+    return sender(th);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/cdbg\/CFrame.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+   @Override\n@@ -57,2 +58,2 @@\n-      AARCH64ThreadContext context = (AARCH64ThreadContext) thread.getContext();\n-      Address rsp = context.getRegisterAsAddress(AARCH64ThreadContext.SP);\n+      return sender(thread, null, null);\n+   }\n@@ -60,2 +61,13 @@\n-      if ((fp == null) || fp.lessThan(rsp)) {\n-        return null;\n+   @Override\n+   public CFrame sender(ThreadProxy thread, Address nextFP, Address nextPC) {\n+      \/\/ Check fp\n+      \/\/ Skip if both nextFP and nextPC are given - do not need to load from fp.\n+      if (nextFP == null && nextPC == null) {\n+        if (fp == null) {\n+          return null;\n+        }\n+\n+        \/\/ Check alignment of fp\n+        if (dbg.getAddressValue(fp) % (2 * ADDRESS_SIZE) != 0) {\n+          return null;\n+        }\n@@ -64,2 +76,4 @@\n-      \/\/ Check alignment of fp\n-      if (dbg.getAddressValue(fp) % (2 * ADDRESS_SIZE) != 0) {\n+      if (nextFP == null) {\n+        nextFP = fp.getAddressAt(0 * ADDRESS_SIZE);\n+      }\n+      if (nextFP == null) {\n@@ -69,3 +83,2 @@\n-      Address nextFP = fp.getAddressAt(0 * ADDRESS_SIZE);\n-      if (nextFP == null || nextFP.lessThanOrEqual(fp)) {\n-        return null;\n+      if (nextPC == null) {\n+        nextPC  = fp.getAddressAt(1 * ADDRESS_SIZE);\n@@ -73,1 +86,0 @@\n-      Address nextPC  = fp.getAddressAt(1 * ADDRESS_SIZE);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/aarch64\/LinuxAARCH64CFrame.java","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -50,5 +50,3 @@\n-        cfa = ((dwarf.getCFARegister() == AMD64ThreadContext.RBP) &&\n-               !dwarf.isBPOffsetAvailable())\n-                  ? context.getRegisterAsAddress(AMD64ThreadContext.RBP)\n-                  : context.getRegisterAsAddress(dwarf.getCFARegister())\n-                           .addOffsetTo(dwarf.getCFAOffset());\n+\n+        cfa = context.getRegisterAsAddress(dwarf.getCFARegister())\n+                     .addOffsetTo(dwarf.getCFAOffset());\n@@ -104,3 +102,6 @@\n-   private boolean isValidFrame(Address nextCFA, ThreadContext context) {\n-     return (nextCFA != null) &&\n-             !nextCFA.lessThan(context.getRegisterAsAddress(AMD64ThreadContext.RSP));\n+   private boolean isValidFrame(Address nextCFA, boolean isNative) {\n+     \/\/ CFA should never be null.\n+     \/\/ nextCFA must be greater than current CFA, if frame is native.\n+     \/\/ Java interpreter frames can share the CFA (frame pointer).\n+     return nextCFA != null &&\n+         (!isNative || (isNative && nextCFA.greaterThan(cfa)));\n@@ -109,1 +110,1 @@\n-   private Address getNextCFA(DwarfParser nextDwarf, ThreadContext context) {\n+   private Address getNextCFA(DwarfParser nextDwarf, ThreadContext context, Address senderFP) {\n@@ -111,0 +112,5 @@\n+     boolean isNative = false;\n+\n+     if (senderFP == null) {\n+       senderFP = cfa.getAddressAt(0);  \/\/ RBP by default\n+     }\n@@ -113,1 +119,1 @@\n-       nextCFA = (dwarf == null) ? cfa.getAddressAt(0) \/\/ Current frame is Java (Use RBP)\n+       nextCFA = (dwarf == null) ? senderFP \/\/ Current frame is Java\n@@ -116,2 +122,2 @@\n-       if (dwarf == null) { \/\/ Current frame is Java (Use RBP)\n-         nextCFA = cfa.getAddressAt(0);\n+       if (dwarf == null) { \/\/ Current frame is Java\n+         nextCFA = senderFP.addOffsetTo(-nextDwarf.getBasePointerOffsetFromCFA());\n@@ -119,0 +125,1 @@\n+         isNative = true;\n@@ -120,8 +127,10 @@\n-         if (!dwarf.isBPOffsetAvailable() && \/\/ Use RBP as CFA\n-             (nextCFAReg == AMD64ThreadContext.RBP) &&\n-             (nextCFAReg != dwarf.getCFARegister())) {\n-           nextCFA = context.getRegisterAsAddress(AMD64ThreadContext.RBP);\n-           if (nextCFA == null) {\n-             return null;\n-           }\n-           nextCFA = nextCFA.getAddressAt(0);\n+         if (nextCFAReg == AMD64ThreadContext.RBP) {\n+           Address rbp = dwarf.isBPOffsetAvailable() ? cfa.addOffsetTo(dwarf.getBasePointerOffsetFromCFA())\n+                                                     : context.getRegisterAsAddress(AMD64ThreadContext.RBP);\n+           Address nextRBP = rbp.getAddressAt(0);\n+           nextCFA = nextRBP.addOffsetTo(-nextDwarf.getBasePointerOffsetFromCFA());\n+         } else if (nextCFAReg == AMD64ThreadContext.RSP) {\n+           \/\/ next RSP should be previous slot of return address.\n+           Address nextRSP = cfa.addOffsetTo(dwarf.getReturnAddressOffsetFromCFA())\n+                                .addOffsetTo(ADDRESS_SIZE);\n+           nextCFA = nextRSP.addOffsetTo(nextDwarf.getCFAOffset());\n@@ -129,1 +138,1 @@\n-           nextCFA = cfa.getAddressAt(dwarf.getBasePointerOffsetFromCFA());\n+           throw new DebuggerException(\"Unsupported CFA register: \" + nextCFAReg);\n@@ -132,3 +141,0 @@\n-       if (nextCFA != null) {\n-         nextCFA = nextCFA.addOffsetTo(-nextDwarf.getBasePointerOffsetFromCFA());\n-       }\n@@ -137,1 +143,14 @@\n-     return isValidFrame(nextCFA, context) ? nextCFA : null;\n+     \/\/ Sanity check for next CFA address\n+     try {\n+       nextCFA.getAddressAt(0);\n+     } catch (Exception e) {\n+       \/\/ return null if next CFA address is invalid\n+       return null;\n+     }\n+\n+     return isValidFrame(nextCFA, isNative) ? nextCFA : null;\n+   }\n+\n+   @Override\n+   public CFrame sender(ThreadProxy th) {\n+     return sender(th, null, null);\n@@ -141,1 +160,1 @@\n-   public CFrame sender(ThreadProxy thread) {\n+   public CFrame sender(ThreadProxy th, Address fp, Address pc) {\n@@ -146,1 +165,1 @@\n-     ThreadContext context = thread.getContext();\n+     ThreadContext context = th.getContext();\n@@ -148,1 +167,1 @@\n-     Address nextPC = getNextPC(dwarf != null);\n+     Address nextPC = pc != null ? pc : getNextPC(dwarf != null);\n@@ -171,3 +190,3 @@\n-     Address nextCFA = getNextCFA(nextDwarf, context);\n-     return isValidFrame(nextCFA, context) ? new LinuxAMD64CFrame(dbg, nextCFA, nextPC, nextDwarf, false, fallback)\n-                                           : null;\n+     Address nextCFA = getNextCFA(nextDwarf, context, fp);\n+     return nextCFA == null ? null\n+                            : new LinuxAMD64CFrame(dbg, nextCFA, nextPC, nextDwarf, false, fallback);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/amd64\/LinuxAMD64CFrame.java","additions":50,"deletions":31,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+   @Override\n@@ -61,2 +62,2 @@\n-      RISCV64ThreadContext context = (RISCV64ThreadContext) thread.getContext();\n-      Address rsp = context.getRegisterAsAddress(RISCV64ThreadContext.SP);\n+      return sender(thread, null, null);\n+   }\n@@ -64,2 +65,13 @@\n-      if ((fp == null) || fp.lessThan(rsp)) {\n-        return null;\n+   @Override\n+   public CFrame sender(ThreadProxy thread, Address nextFP, Address nextPC) {\n+      \/\/ Check fp\n+      \/\/ Skip if both nextFP and nextPC are given - do not need to load from fp.\n+      if (nextFP == null && nextPC == null) {\n+        if (fp == null) {\n+          return null;\n+        }\n+\n+        \/\/ Check alignment of fp\n+        if (dbg.getAddressValue(fp) % (2 * ADDRESS_SIZE) != 0) {\n+          return null;\n+        }\n@@ -68,2 +80,4 @@\n-      \/\/ Check alignment of fp\n-      if (dbg.getAddressValue(fp) % (2 * ADDRESS_SIZE) != 0) {\n+      if (nextFP == null) {\n+        nextFP = fp.getAddressAt(C_FRAME_LINK_OFFSET * ADDRESS_SIZE);\n+      }\n+      if (nextFP == null) {\n@@ -73,3 +87,2 @@\n-      Address nextFP = fp.getAddressAt(C_FRAME_LINK_OFFSET * ADDRESS_SIZE);\n-      if (nextFP == null || nextFP.lessThanOrEqual(fp)) {\n-        return null;\n+      if (nextPC == null) {\n+        nextPC = fp.getAddressAt(C_FRAME_RETURN_ADDR_OFFSET * ADDRESS_SIZE);\n@@ -77,1 +90,0 @@\n-      Address nextPC  = fp.getAddressAt(C_FRAME_RETURN_ADDR_OFFSET * ADDRESS_SIZE);\n@@ -81,0 +93,1 @@\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/riscv64\/LinuxRISCV64CFrame.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -112,0 +112,2 @@\n+                  Address senderFP = null;\n+                  Address senderPC = null;\n@@ -128,1 +130,1 @@\n-                      String[] names = null;\n+                      JavaNameInfo nameInfo = null;\n@@ -132,1 +134,1 @@\n-                         names = getJavaNames(th, f.localVariableBase());\n+                         nameInfo = getJavaNames(th, f.localVariableBase());\n@@ -134,1 +136,1 @@\n-                         if (names == null || names.length == 0) {\n+                         if (nameInfo == null || nameInfo.names() == null || nameInfo.names().length == 0) {\n@@ -157,1 +159,1 @@\n-                                  names = getJavaNames(th, f.localVariableBase());\n+                                  nameInfo = getJavaNames(th, f.localVariableBase());\n@@ -159,1 +161,1 @@\n-                                  if (names == null || names.length == 0) {\n+                                  if (nameInfo == null || nameInfo.names() == null || nameInfo.names().length == 0) {\n@@ -171,5 +173,8 @@\n-                      if (names != null && names.length != 0) {\n-                         \/\/ print java frame(s)\n-                         for (int i = 0; i < names.length; i++) {\n-                             if (i > 0) {\n-                                 out.print(fillerForAddress);\n+                      if (nameInfo != null) {\n+                         if (nameInfo.names() != null && nameInfo.names().length != 0) {\n+                             \/\/ print java frame(s)\n+                             for (int i = 0; i < nameInfo.names().length; i++) {\n+                                 if (i > 0) {\n+                                     out.print(fillerForAddress);\n+                                 }\n+                                 out.println(nameInfo.names()[i]);\n@@ -177,1 +182,0 @@\n-                             out.println(names[i]);\n@@ -179,0 +183,2 @@\n+                         senderFP = nameInfo.senderFP();\n+                         senderPC = nameInfo.senderPC();\n@@ -181,1 +187,1 @@\n-                  f = f.sender(th);\n+                  f = f.sender(th, senderFP, senderPC);\n@@ -242,1 +248,3 @@\n-   private String[] getJavaNames(ThreadProxy th, Address fp) {\n+   private static record JavaNameInfo(String[] names, Address senderFP, Address senderPC) {};\n+\n+   private JavaNameInfo getJavaNames(ThreadProxy th, Address fp) {\n@@ -248,0 +256,1 @@\n+\n@@ -249,0 +258,1 @@\n+      JavaVFrame bottomJVFrame = null;\n@@ -253,0 +263,1 @@\n+            bottomJVFrame = vf;\n@@ -283,2 +294,10 @@\n-      String[] res = names.toArray(new String[0]);\n-      return res;\n+\n+      Address senderFP = null;\n+      Address senderPC = null;\n+      if (bottomJVFrame != null) {\n+         Frame senderFrame = bottomJVFrame.getFrame().sender((RegisterMap)bottomJVFrame.getRegisterMap().clone());\n+         senderFP = senderFrame.getFP();\n+         senderPC = senderFrame.getPC();\n+      }\n+\n+      return new JavaNameInfo(names.toArray(new String[0]), senderFP, senderPC);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/PStack.java","additions":34,"deletions":15,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, NTT DATA\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.SA.SATestUtils;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @bug 8370176\n+ * @requires vm.hasSA\n+ * @requires os.family == \"linux\"\n+ * @requires os.arch == \"amd64\"\n+ * @library \/test\/lib\n+ * @run driver TestJhsdbJstackMixedWithXComp\n+ *\/\n+public class TestJhsdbJstackMixedWithXComp {\n+\n+    private static void runJstack(LingeredApp app) throws Exception {\n+        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"jhsdb\");\n+        launcher.addVMArgs(Utils.getFilteredTestJavaOpts(\"-showversion\"));\n+        launcher.addToolArg(\"jstack\");\n+        launcher.addToolArg(\"--mixed\");\n+        launcher.addToolArg(\"--pid\");\n+        launcher.addToolArg(Long.toString(app.getPid()));\n+\n+        ProcessBuilder pb = SATestUtils.createProcessBuilder(launcher);\n+        Process jhsdb = pb.start();\n+        OutputAnalyzer out = new OutputAnalyzer(jhsdb);\n+\n+        jhsdb.waitFor();\n+\n+        String stdout = out.getStdout();\n+        System.out.println(stdout);\n+        System.err.println(out.getStderr());\n+\n+        out.stderrShouldBeEmptyIgnoreVMWarnings();\n+\n+        List<String> targetStackTrace = new ArrayList<>();\n+        boolean inStack = false;\n+        for (String line : stdout.split(\"\\n\")) {\n+            if (line.contains(\"<nep_invoker_blob>\")) {\n+                inStack = true;\n+            } else if (inStack && line.contains(\"-----------------\")) {\n+                inStack = false;\n+                break;\n+            }\n+\n+            if (inStack) {\n+                targetStackTrace.add(line);\n+            }\n+        }\n+\n+        boolean found = targetStackTrace.stream()\n+                                        .anyMatch(l -> l.contains(\"thread_native_entry\"));\n+        if (!found) {\n+            throw new RuntimeException(\"Test failed!\");\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        SATestUtils.skipIfCannotAttach(); \/\/ throws SkippedException if attach not expected to work.\n+        LingeredApp app = null;\n+\n+        try {\n+            app = new LingeredAppWithVirtualThread();\n+            LingeredApp.startApp(app, \"-Xcomp\");\n+            System.out.println(\"Started LingeredApp with pid \" + app.getPid());\n+            runJstack(app);\n+            System.out.println(\"Test Completed\");\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            throw e;\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackMixedWithXComp.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"}]}