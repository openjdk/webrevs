{"files":[{"patch":"@@ -450,2 +450,5 @@\n-        try (ZipFile zf = new ZipFile(file)) {\n-            return Validator.validate(this, zf);\n+        try (ZipFile zf = new ZipFile(file);\n+            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(\n+                    new FileInputStream(file)))) {\n+\n+            return Validator.validate(this, zf, zis);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.File;\n@@ -39,0 +38,1 @@\n+import java.util.LinkedHashMap;\n@@ -44,0 +44,2 @@\n+import java.util.function.IntSupplier;\n+import java.util.regex.Pattern;\n@@ -47,0 +49,1 @@\n+import java.util.zip.ZipInputStream;\n@@ -48,1 +51,0 @@\n-import static java.util.jar.JarFile.MANIFEST_NAME;\n@@ -57,0 +59,26 @@\n+    \/**\n+     * Regex expression to verify that the Zip Entry file name:\n+     * - is not an absolute path\n+     * - the file name is not '.' or '..'\n+     * - does not contain a backslash, '\\'\n+     * - does not contain a drive letter\n+     * - path element does not include '.' or '..'\n+     *\/\n+    private static final Pattern INVALID_ZIP_ENTRY_NAME_PATTERN = Pattern.compile(\n+            \/\/ Don't allow a '..' in the path\n+            \"^(\\\\.|\\\\.\\\\.)$\"\n+                    + \"|^\\\\.\\\\.\/\"\n+                    + \"|\/\\\\.\\\\.$\"\n+                    + \"|\/\\\\.\\\\.\/\"\n+                    \/\/ Don't allow a '.' in the path\n+                    + \"|^\\\\.\/\"\n+                    + \"|\/\\\\.$\"\n+                    + \"|\/\\\\.\/\"\n+                    \/\/ Don't allow absolute path\n+                    + \"|^\/\"\n+                    \/\/ Don't allow a backslash in the path\n+                    + \"|^\\\\\\\\\"\n+                    + \"|.*\\\\\\\\.*\"\n+                    \/\/ Don't allow a drive letter\n+                    + \"|.*[a-zA-Z]:.*\"\n+    );\n@@ -65,0 +93,1 @@\n+    private final ZipInputStream zis;\n@@ -66,1 +95,1 @@\n-    private Validator(Main main, ZipFile zf) {\n+    private Validator(Main main, ZipFile zf, ZipInputStream zis) {\n@@ -69,0 +98,1 @@\n+        this.zis = zis;\n@@ -72,2 +102,2 @@\n-    static boolean validate(Main main, ZipFile zf) throws IOException {\n-        return new Validator(main, zf).validate();\n+    static boolean validate(Main main, ZipFile zf, ZipInputStream zis) throws IOException {\n+        return new Validator(main, zf, zis).validate();\n@@ -76,0 +106,160 @@\n+    \/**\n+     * Validate that the CEN\/LOC file name header field adheres  to\n+     * PKWARE APPNOTE-6.3.3.TXT:\n+     *\n+     * 4.4.17.1 The name of the file, with optional relative path.\n+     * The path stored MUST not contain a drive or\n+     * device letter, or a leading slash.  All slashes\n+     * MUST be forward slashes '\/' as opposed to\n+     * backwards slashes '\\' for compatibility with Amiga\n+     * and UNIX file systems etc.\n+     * Also validate that the file name is not \".\" or \"..\", and that any name\n+     * element is not equal to \".\" or \"..\"\n+     *\n+     * @param entryName CEN\/LOC header file name field entry\n+     * @return true if a valid Zip Entry file name; false otherwise\n+     *\/\n+    public static boolean isZipEntryNameValid(String entryName) {\n+        return !INVALID_ZIP_ENTRY_NAME_PATTERN.matcher(entryName).find();\n+    }\n+\n+    \/**\n+     * Validate base on entries in CEN and LOC. To ensure\n+     * - Valid entry name\n+     * - No duplicate entries\n+     * - CEN and LOC should have same entries, in the same order\n+     *\n+     * NOTE: In order to check the encounter order based on the CEN listing,\n+     *       this implementation assumes CEN entries are to be added before\n+     *       add any LOC entries. That is, addCenEntry should be called before\n+     *       calls to addLocEntry to ensure encounter order can be compared\n+     *       properly.\n+     *\/\n+    private class EntryValidator {\n+        \/\/ A place holder when an entry is not yet seen in the directory\n+        static EntryEncounter PLACE_HOLDER = new EntryEncounter(0, 0);\n+        \/\/ Flag to signal the CEN and LOC is not in the same order\n+        boolean outOfOrder = false;\n+        \/**\n+         * A record to keep the encounter order in the directory and count of the appearances\n+         *\/\n+        record EntryEncounter(int order, int count) {\n+            \/**\n+             * Add to the appearance count.\n+             * @param encounterOrder The supplier for the encounter order in the directory\n+             *\/\n+            EntryEncounter increase(IntSupplier encounterOrder) {\n+                return isPlaceHolder() ?\n+                    \/\/ First encounter of the entry in this directory\n+                    new EntryEncounter(encounterOrder.getAsInt(), 1) :\n+                    \/\/ After first encounter, keep the order but add the count\n+                    new EntryEncounter(order, count + 1);\n+            }\n+\n+            \/**\n+             * True if this entry is not in the directory.\n+             *\/\n+            boolean isPlaceHolder() {\n+                return count == 0;\n+            }\n+        }\n+\n+        \/**\n+         * Information used for validation for a entry in CEN and LOC.\n+         *\/\n+        record EntryInfo(EntryEncounter cen, EntryEncounter loc) {}\n+\n+        \/**\n+         * Ordered deduplication set for entries\n+         *\/\n+        LinkedHashMap<String, EntryInfo> entries = new LinkedHashMap<>();\n+        \/\/ Encounter order in CEN, step by 1 on each new entry\n+        int cenEncounterOrder = 0;\n+        \/\/ Encounter order in LOC, step by 1 for new LOC entry exist in CEN\n+        int locEncounterOrder = 0;\n+\n+        \/**\n+         * Record an entry apperance in CEN\n+         *\/\n+        public void addCenEntry(ZipEntry cenEntry) {\n+            var entryName = cenEntry.getName();\n+            var entryInfo = entries.get(entryName);\n+            if (entryInfo == null) {\n+                entries.put(entryName, new EntryInfo(\n+                        new EntryEncounter(cenEncounterOrder++, 1),\n+                        PLACE_HOLDER));\n+            } else {\n+                assert entryInfo.loc().isPlaceHolder();\n+                entries.put(entryName, new EntryInfo(\n+                        entryInfo.cen().increase(() -> cenEncounterOrder++),\n+                        entryInfo.loc()));\n+            }\n+        }\n+\n+        \/**\n+         * Record an entry apperance in LOC\n+         * We compare entry order based on the CEN. Thus do not step LOC\n+         * encounter order if the entry is only in LOC.\n+         * NOTE: This works because all CEN entries are added before adding LOC entries.\n+         *\/\n+        public void addLocEntry(ZipEntry locEntry) {\n+            var entryName = locEntry.getName();\n+            var entryInfo = entries.get(entryName);\n+            if (entryInfo == null) {\n+                entries.put(entryName, new EntryInfo(\n+                        PLACE_HOLDER,\n+                        new EntryEncounter(locEncounterOrder, 1)));\n+            } else {\n+                entries.put(entryName, new EntryInfo(\n+                        entryInfo.cen(),\n+                        entryInfo.loc().increase(() -> entryInfo.cen().isPlaceHolder() ? locEncounterOrder : locEncounterOrder++)));\n+            }\n+        }\n+\n+        \/**\n+         * Issue warning for duplicate entries\n+         *\/\n+        private void checkDuplicates(int count, String msg, String entryName) {\n+            if (count > 1) {\n+                warn(formatMsg(msg, Integer.toString(count), entryName));\n+                isValid = false;\n+            }\n+        }\n+\n+        \/**\n+         * Validation per entry observed.\n+         * Each entry must appeared at least oncee in CEN or LOC.\n+         *\/\n+        private void validateEntry(String entryName, EntryInfo entryInfo) {\n+            \/\/ Check invalid entry name\n+            if (!isZipEntryNameValid(entryName)) {\n+                warn(formatMsg(\"warn.validator.invalid.entry.name\", entryName));\n+                isValid = false;\n+            }\n+            \/\/ Check duplicate entries in CEN\n+            checkDuplicates(entryInfo.cen().count(), \"warn.validator.duplicate.cen.entry\", entryName);\n+            \/\/ Check duplicate entries in LOC\n+            checkDuplicates(entryInfo.loc().count(), \"warn.validator.duplicate.loc.entry\", entryName);\n+            \/\/ Check consistency between CEN and LOC\n+            if (entryInfo.cen().isPlaceHolder()) {\n+                warn(formatMsg(\"warn.validator.loc.only.entry\", entryName));\n+                isValid = false;\n+            } else if (entryInfo.loc().isPlaceHolder()) {\n+                warn(formatMsg(\"warn.validator.cen.only.entry\", entryName));\n+                isValid = false;\n+            } else if (!outOfOrder && entryInfo.loc().order() != entryInfo.cen().order()) {\n+                outOfOrder = true;\n+                isValid = false;\n+                warn(getMsg(\"warn.validator.order.mismatch\"));\n+            }\n+        }\n+\n+        \/**\n+         * Validate the jar entries by check each entry in encounter order\n+         *\/\n+        public void validate() {\n+            entries.sequencedEntrySet().forEach(e -> validateEntry(e.getKey(), e.getValue()));\n+        }\n+    }\n+\n+\n@@ -78,0 +268,1 @@\n+            var entryValidator = new EntryValidator();\n@@ -79,0 +270,1 @@\n+              .peek(entryValidator::addCenEntry)\n@@ -94,1 +286,12 @@\n-        } catch (InvalidJarException e) {\n+\n+            \/*\n+            * Retrieve entries from the ZipInputStream to verify local file headers(LOC)\n+            * have same entries as the cental directory(CEN).\n+            *\/\n+            ZipEntry e;\n+            while ((e = zis.getNextEntry()) != null) {\n+                entryValidator.addLocEntry(e);\n+            }\n+\n+            entryValidator.validate();\n+        } catch (IOException | InvalidJarException e) {\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Validator.java","additions":210,"deletions":7,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,0 +146,12 @@\n+warn.validator.duplicate.cen.entry=\\\n+        Warning: There were {0} central directory entries found for {1}\n+warn.validator.duplicate.loc.entry=\\\n+        Warning: There were {0} local file headers found for {1}\n+warn.validator.invalid.entry.name=\\\n+        Warning: entry name {0} is not valid\n+warn.validator.cen.only.entry=\\\n+        Warning: An equivalent for the central directory entry {0} was not found in the local file headers\n+warn.validator.loc.only.entry=\\\n+        Warning: An equivalent entry for the local file header {0} was not found in the central directory\n+warn.validator.order.mismatch=\\\n+        Warning: Central directory and local file header entries are not in the same order\n@@ -268,2 +280,2 @@\n-\\      --validate             Validate the contents of the jar archive. This option\\n\\\n-\\                             will validate that the API exported by a multi-release\\n\\\n+\\      --validate             Validate the contents of the jar archive. This option:\\n\\\n+\\                             - Validates that the API exported by a multi-release\\n\\\n@@ -271,1 +283,4 @@\n-\\                             versions.\n+\\                             versions.\\n\\\n+\\                             - Issues a warning if there are invalid or duplicate file names\n+\n+\n@@ -349,2 +364,0 @@\n-main.help.opt.extract=\\\n-\\ Operation modifiers valid only in extract mode:\\n\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -109,0 +109,4 @@\n+`--validate`\n+:   Validate the contents of the jar archive.\n+    See `Integrity of a jar Archive` section below for more details.\n+\n@@ -216,0 +220,20 @@\n+## Integrity of a jar Archive\n+As a jar archive is based on ZIP format, it is possible to create a jar archive using tools\n+other than the `jar` command. The --validate option may be used to perform the following\n+integrity checks against a jar archive:\n+\n+- That there are no duplicate Zip Entry file names\n+- Verify that the Zip Entry file name:\n+    - is not an absolute path\n+    - the file name is not '.' or '..'\n+    - does not contain a backslash, '\\\\'\n+    - does not contain a drive letter\n+    - path element does not include '.' or '..\n+- The API exported by a multi-release jar archive is consistent across all different release\n+  versions.\n+\n+The jar tool returns a status code of 0 if there were no integrity issues encountered, otherwise\n+a non-zero status code would be returned.\n+When an integrity issue is reported, it will often require that the jar file is re-created by the\n+original source of the jar file.\n+\n","filename":"src\/jdk.jartool\/share\/man\/jar.md","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,334 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8345431\n+ * @summary test validator to report malformed jar file\n+ * @library \/test\/lib\n+ * @modules jdk.jartool\n+ * @build jdk.test.lib.Platform\n+ *        jdk.test.lib.util.FileUtils\n+ * @run junit\/othervm ValidatorTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestInstance.Lifecycle;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.jar.JarFile;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+@TestInstance(Lifecycle.PER_CLASS)\n+class ValidatorTest {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jar tool not found\")\n+        );\n+\n+    private final String nl = System.lineSeparator();\n+    private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private final PrintStream jarOut = new PrintStream(baos);\n+\n+    static final String jdkVendor = System.getProperty(\"java.vendor\");\n+    static final String jdkVersion = System.getProperty(\"java.version\");\n+    static final String MANIFEST1 = \"Manifest-Version: 1.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    static final String MANIFEST2 = \"Manifest-Version: 2.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    static final String MANIFEST3 = \"Manifest-Version: 3.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    private static final String META_INF = \"META-INF\/\";\n+\n+    private void writeManifestAsFirstSecondAndFourthEntry(Path path, boolean useCen, boolean useLoc) throws IOException {\n+        int locPosA, cenPos;\n+        System.out.printf(\"%n%n*****Creating Jar with duplicate Manifest*****%n%n\");\n+        var out = new ByteArrayOutputStream(1024);\n+        try (var zos = new ZipOutputStream(out)) {\n+            zos.putNextEntry(new ZipEntry(JarFile.MANIFEST_NAME));\n+            zos.write(MANIFEST1.getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosA = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"AANIFEST.MF\"));\n+            zos.write(MANIFEST2.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zos.write(\"entry1\".getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"BANIFEST.MF\"));\n+            zos.write(MANIFEST3.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zos.write(\"hello entry2\".getBytes(StandardCharsets.UTF_8));\n+            zos.flush();\n+            cenPos = out.size();\n+        }\n+        var template = out.toByteArray();\n+        \/\/ ISO_8859_1 to keep the 8-bit value to avoid mess index in the byte array\n+        var s = new String(template, StandardCharsets.ISO_8859_1);\n+        \/\/ change META-INF\/AANIFEST.MF to META-INF\/MANIFEST.MF\n+        if (useCen) {\n+            var cen = s.indexOf(\"AANIFEST.MF\", cenPos);\n+            template[cen] = (byte) 'M';\n+            \/\/ change META-INF\/BANIFEST.MF to META-INF\/MANIFEST.MF\n+            cen = s.indexOf(\"BANIFEST.MF\", cenPos);\n+            template[cen] = (byte) 'M';\n+        }\n+        if (useLoc) {\n+            var loc = s.indexOf(\"AANIFEST.MF\", locPosA);\n+            template[loc] = (byte) 'M';\n+        }\n+        Files.write(path, template);\n+    }\n+\n+    private void createMismatchOrderJar(Path path) throws IOException {\n+        int locPosA, locPosB;\n+        System.out.printf(\"%n%n*****Creating Jar with the swap entry name*****%n%n\");\n+        var out = new ByteArrayOutputStream(1024);\n+        try (var zos = new ZipOutputStream(out)) {\n+            zos.putNextEntry(new ZipEntry(JarFile.MANIFEST_NAME));\n+            zos.write(MANIFEST1.getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosA = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"AANIFEST.MF\"));\n+            zos.write(MANIFEST2.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zos.write(\"entry1\".getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosB = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"BANIFEST.MF\"));\n+            zos.write(MANIFEST3.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zos.write(\"hello entry2\".getBytes(StandardCharsets.UTF_8));\n+            zos.flush();\n+        }\n+        var template = out.toByteArray();\n+        \/\/ ISO_8859_1 to keep the 8-bit value to avoid mess index in the byte array\n+        var s = new String(template, StandardCharsets.ISO_8859_1);\n+        \/\/ change META-INF\/AANIFEST.MF to META-INF\/BANIFEST.MF\n+        var loc = s.indexOf(\"AANIFEST.MF\", locPosA);\n+        template[loc] = (byte) 'B';\n+        \/\/ change META-INF\/BANIFEST.MF to META-INF\/AANIFEST.MF\n+        loc = s.indexOf(\"BANIFEST.MF\", locPosB);\n+        template[loc] = (byte) 'A';\n+\n+        Files.write(path, template);\n+    }\n+\n+    record EntryNameTestCase(String entryName, boolean isValid) {}\n+\n+    private static Stream<EntryNameTestCase> zipEntryPaths() {\n+        return Stream.of(\n+                new EntryNameTestCase(\"..\/..\/c:\/\/\/\/d:\/tmp\/testentry0\", false),\n+                new EntryNameTestCase(\"..\\\\..\\\\c:\\\\d:\\\\tmp\\\\testentry1\", false),\n+                new EntryNameTestCase(\"\/\/\/\/c:\/tmp\/testentry2\", false),\n+                new EntryNameTestCase(\"\/\/\/\/c:\/d:\/tmp\/testentry3\", false),\n+                new EntryNameTestCase(\"c:\/\/\/\/\/d:\/tmp\/testentry4\", false),\n+                new EntryNameTestCase(\"\/\/tmp\/tmp2\/testentry5\", false),\n+                new EntryNameTestCase(\"\/\/\/tmp\/abc\", false),\n+                new EntryNameTestCase(\"C:\\\\Documents\\\\tennis\\\\CardioTennis.pdf\", false),\n+                new EntryNameTestCase(\"\\\\Program Files\\\\Custom Utilities\\\\tennis.exe\", false),\n+                new EntryNameTestCase(\"myhome\\\\Hello.txt\", false),\n+                new EntryNameTestCase(\"Hello.txt\", true),\n+                new EntryNameTestCase(\".\/Hello.txt\", true),\n+                new EntryNameTestCase(\"..\/Hello.txt\", false),\n+                new EntryNameTestCase(\".\\\\Hello.txt\", false),\n+                new EntryNameTestCase(\"..\\\\Hello.txt\", false),\n+                new EntryNameTestCase(\"C:\\\\Hello.txt\", false),\n+                new EntryNameTestCase(\"D:\/Hello.txt\", false),\n+                new EntryNameTestCase(\"foo\\\\bar.txt\", false),\n+                new EntryNameTestCase(\"foo\/bar.txt\", true),\n+                new EntryNameTestCase(\"foo\/..\/bar.txt\", false),\n+                new EntryNameTestCase(\"foo\/.\/bar.txt\", true),\n+                new EntryNameTestCase(\"..\", false),\n+                new EntryNameTestCase(\".\", false),\n+                new EntryNameTestCase(\"\/home\/foo.txt\", false),\n+                new EntryNameTestCase(\".\/home\/foo.txt\", true),\n+                new EntryNameTestCase(\"..\/home\/foo.txt\", false),\n+                new EntryNameTestCase(\"foo\/bar\/..\", false),\n+                new EntryNameTestCase(\"foo\/bar\/.\", true),\n+                new EntryNameTestCase(\"\/foo\/bar\/..\/..\/myhome\/bin\", false),\n+                new EntryNameTestCase(\"\/foo\/bar\/.\/.\/myhome\/bin\", false),\n+                new EntryNameTestCase(\"myHome\/..valid\", true),\n+                new EntryNameTestCase(\"myHome\/.valid\", true),\n+                new EntryNameTestCase(\"..valid\", true),\n+                new EntryNameTestCase(\".valid\", true)\n+        );\n+    }\n+\n+    private List<String> createInvalidEntryJar(Path path) throws IOException {\n+        System.out.printf(\"%n%n*****Creating Jar with the invalid entry names*****%n%n\");\n+        var out = new ByteArrayOutputStream(1024);\n+        List<String> invalidEntryNames;\n+        try (var zos = new ZipOutputStream(out)) {\n+            invalidEntryNames = zipEntryPaths()\n+                .filter(testCase -> {\n+                        try {\n+                            zos.putNextEntry(new ZipEntry(testCase.entryName()));\n+                            var content = \"Content of \" + testCase.entryName();\n+                            zos.write(content.getBytes(StandardCharsets.UTF_8));\n+                            return !testCase.isValid();\n+                        } catch (IOException ioe) {\n+                            throw new UncheckedIOException(ioe);\n+                        }\n+                    })\n+                .map(EntryNameTestCase::entryName).toList();\n+            zos.flush();\n+        } catch (UncheckedIOException uioe) {\n+            throw uioe.getCause();\n+        }\n+        Files.write(path, out.toByteArray());\n+        return invalidEntryNames;\n+    }\n+\n+    @Test\n+    public void testValidateJar() throws IOException {\n+        var zip = Path.of(\"Regular.jar\");\n+        writeManifestAsFirstSecondAndFourthEntry(zip, false, false);\n+        try {\n+            jar(\"--validate --file \" + zip.toString());\n+        } catch (IOException e) {\n+            fail(\"Expecting zero exit code\");\n+        }\n+    }\n+\n+    @Test\n+    public void testValidate() throws IOException {\n+        var zip = Path.of(\"MultipleManifestTest.jar\");\n+        writeManifestAsFirstSecondAndFourthEntry(zip, true, true);\n+        try {\n+            jar(\"--validate --file \" + zip.toString());\n+            fail(\"Expecting non-zero exit code\");\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            assertTrue(err.contains(\"Warning: There were 3 central directory entries found for META-INF\/MANIFEST.MF\"));\n+            assertTrue(err.contains(\"Warning: There were 2 local file headers found for META-INF\/MANIFEST.MF\"));\n+            assertTrue(err.contains(\"Warning: An equivalent entry for the local file header META-INF\/BANIFEST.MF was not found in the central directory\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testOnlyLocModified() throws IOException {\n+        Path f = Path.of(\"LocHacked.jar\");\n+        writeManifestAsFirstSecondAndFourthEntry(f, false, true);\n+        try {\n+            jar(\"--validate --file \" + f.toString());\n+            fail(\"Expecting non-zero exit code\");\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            assertTrue(err.contains(\"Warning: There were 2 local file headers found for META-INF\/MANIFEST.MF\"));\n+            assertTrue(err.contains(\"Warning: An equivalent for the central directory entry META-INF\/AANIFEST.MF was not found in the local file headers\"));\n+            \/\/ Order is base on the central directory, expecting AANIFEST.MF but see next entry\n+            assertTrue(err.contains(\"Warning: Central directory and local file header entries are not in the same order\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testOnlyCenModified() throws IOException {\n+        Path f = Path.of(\"CenHacked.jar\");\n+        writeManifestAsFirstSecondAndFourthEntry(f, true, false);\n+        try {\n+            jar(\"--validate --file \" + f.toString());\n+            fail(\"Expecting non-zero exit code\");\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            assertTrue(err.contains(\"Warning: There were 3 central directory entries found for META-INF\/MANIFEST.MF\"));\n+            assertTrue(err.contains(\"Warning: An equivalent entry for the local file header META-INF\/AANIFEST.MF was not found in the central directory\"));\n+            assertTrue(err.contains(\"Warning: An equivalent entry for the local file header META-INF\/BANIFEST.MF was not found in the central directory\"));\n+            assertFalse(err.contains(\"Warning: Central directory and local file header entries are not in the same order\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testMismatchOrder() throws IOException {\n+        Path f = Path.of(\"SwappedEntry.jar\");\n+        createMismatchOrderJar(f);\n+        try {\n+            jar(\"--validate --file \" + f.toString());\n+            fail(\"Expecting non-zero exit code\");\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            assertTrue(err.contains(\"Warning: Central directory and local file header entries are not in the same order\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testInvalidEntryName() throws IOException {\n+        Path f = Path.of(\"InvalidEntry.jar\");\n+        var invalidEntryNames = createInvalidEntryJar(f);\n+        try {\n+            jar(\"--validate --file \" + f.toString());\n+            fail(\"Expecting non-zero exit code\");\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            for (var entryName : invalidEntryNames) {\n+                assertTrue(err.contains(\"Warning: entry name \" + entryName + \" is not valid\"));\n+            }\n+        }\n+    }\n+\n+    \/\/ return stderr output\n+    private String jar(String cmdline) throws IOException {\n+        System.out.println(\"jar \" + cmdline);\n+        baos.reset();\n+\n+        \/\/ the run method catches IOExceptions, we need to expose them\n+        ByteArrayOutputStream baes = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baes);\n+        PrintStream saveErr = System.err;\n+        System.setErr(err);\n+        try {\n+            int rc = JAR_TOOL.run(jarOut, err, cmdline.split(\" +\"));\n+            if (rc != 0) {\n+                throw new IOException(baes.toString());\n+            } else {\n+                return baes.toString();\n+            }\n+        } finally {\n+            System.setErr(saveErr);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jar\/ValidatorTest.java","additions":334,"deletions":0,"binary":false,"changes":334,"status":"added"}]}