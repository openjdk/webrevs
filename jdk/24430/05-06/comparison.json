{"files":[{"patch":"@@ -39,1 +39,0 @@\n-import java.util.LinkedList;\n@@ -45,0 +44,1 @@\n+import java.util.function.IntSupplier;\n@@ -61,5 +61,5 @@\n-     *  - is not an absolute path\n-     *  - the file name is not '.' or '..'\n-     *  - does not contain a backslash, '\\'\n-     *  - does not contain a drive letter\n-     *  - path element does not include '..'\n+     * - is not an absolute path\n+     * - the file name is not '.' or '..'\n+     * - does not contain a backslash, '\\'\n+     * - does not contain a drive letter\n+     * - path element does not include '..'\n@@ -68,0 +68,1 @@\n+            \/\/ Don't allow a '..' in the path\n@@ -72,0 +73,5 @@\n+                    \/\/ Don't allow a '.' in the path\n+                    + \"|^\\\\.\/\"\n+                    + \"|\/\\\\.$\"\n+                    + \"|\/\\\\.\/\"\n+                    \/\/ Don't allow absolute path\n@@ -73,0 +79,1 @@\n+                    \/\/ Don't allow a backslash in the path\n@@ -75,0 +82,1 @@\n+                    \/\/ Don't allow a drive letter\n@@ -119,2 +127,6 @@\n-     * Helper class to deduplicate entry names.\n-     * Keep a coutner for duplicate entry names and check if the entry name is valid on first add.\n+     * Validate base on entries in CEN and LOC. To ensure\n+     * - Valid entry name\n+     * - No duplicate entries\n+     * - CEN and LOC should have same entries, in the same order\n+     * NOTE: This implementation assumes CEN entries are to be added before\n+     *       add any LOC entries.\n@@ -122,15 +134,19 @@\n-    private class DedupEntryNames {\n-        LinkedHashMap<String, Integer> entries = new LinkedHashMap<>();\n-        boolean isCEN;\n-\n-        public DedupEntryNames(boolean isCEN) {\n-            this.isCEN = isCEN;\n-        }\n-\n-        public void add(String entryName) {\n-            int latestCount = entries.merge(entryName, 1, (count, _) -> count + 1);\n-            if (latestCount > 1) {\n-                isValid = false;\n-            } else if (!isZipEntryNameValid(entryName)) {\n-                warn(formatMsg(\"error.validator.bad.entry.name\", entryName));\n-                isValid = false;\n+    private class EntryValidator {\n+        \/\/ A place holder when an entry is not yet seen in the directory\n+        static EntryEncounter PLACE_HOLDER = new EntryEncounter(0, 0);\n+        \/\/ Flag to signal the CEN and LOC is not in the same order\n+        boolean outOfOrder = false;\n+        \/**\n+         * A record to keep the encounter order in the directory and count of the appearances\n+         *\/\n+        record EntryEncounter(int order, int count) {\n+            \/**\n+             * Add to the appearance count.\n+             * @param encounterOrder The supplier for the encounter order in the directory\n+             *\/\n+            EntryEncounter increase(IntSupplier encounterOrder) {\n+                return isPlaceHolder() ?\n+                    \/\/ First encounter of the entry in this directory\n+                    new EntryEncounter(encounterOrder.getAsInt(), 1) :\n+                    \/\/ After first encounter, keep the order but add the count\n+                    new EntryEncounter(order, count + 1);\n@@ -138,1 +154,0 @@\n-        }\n@@ -140,6 +155,2 @@\n-        private boolean checkDuplicates(Map.Entry<String, Integer> counter) {\n-            var count = counter.getValue();\n-            if (count == 1) {\n-            } else {\n-                var msg = isCEN ? \"warn.validator.duplicate.cen.entry\" : \"warn.validator.duplicate.loc.entry\";\n-                warn(formatMsg(msg, count.toString(), counter.getKey()));\n+            boolean isPlaceHolder() {\n+                return count == 0;\n@@ -147,1 +158,0 @@\n-            return true;\n@@ -150,7 +160,4 @@\n-        public LinkedList<String> dedup() {\n-            return entries.sequencedEntrySet().stream()\n-                    .filter(this::checkDuplicates)\n-                    .map(Map.Entry::getKey)\n-                    .collect(Collectors.toCollection(LinkedList::new));\n-        }\n-    }\n+        \/**\n+         * Information used for validation for a entry in CEN and LOC.\n+         *\/\n+        record EntryInfo(EntryEncounter cen, EntryEncounter loc) {}\n@@ -158,9 +165,8 @@\n-    \/\/ Check any CEN entry is matching the specified name\n-    private boolean checkAnyCenEntry(String locEntryName, LinkedList<String> cenEntryNames) {\n-        var hasEntry = cenEntryNames.remove(locEntryName);\n-        if (!hasEntry) {\n-            warn(formatMsg(\"warn.validator.loc.only.entry\", locEntryName));\n-            isValid = false;\n-        }\n-        return hasEntry;\n-    }\n+        \/**\n+         * Ordered deduplication set for entries\n+         *\/\n+        LinkedHashMap<String, EntryInfo> entries = new LinkedHashMap<>();\n+        \/\/ Encounter order in CEN, step by 1 on each new entry\n+        int cenEncounterOrder = 0;\n+        \/\/ Encounter order in LOC, step by 1 for new LOC entry exist in CEN\n+        int locEncounterOrder = 0;\n@@ -168,5 +174,16 @@\n-    \/\/ Check next CEN entry is matching the specified name\n-    private boolean checkNextCenEntry(String locEntryName, LinkedList<String> cenEntryNames) {\n-        var nextCenEntryName = cenEntryNames.removeFirst();\n-        if (nextCenEntryName.equals(locEntryName)) {\n-            return true;\n+        \/**\n+         * Record an entry apperance in CEN\n+         *\/\n+        public void addCenEntry(ZipEntry cenEntry) {\n+            var entryName = cenEntry.getName();\n+            var entryInfo = entries.get(entryName);\n+            if (entryInfo == null) {\n+                entries.put(entryName, new EntryInfo(\n+                        new EntryEncounter(cenEncounterOrder++, 1),\n+                        PLACE_HOLDER));\n+            } else {\n+                assert entryInfo.loc().isPlaceHolder();\n+                entries.put(entryName, new EntryInfo(\n+                        entryInfo.cen().increase(() -> cenEncounterOrder++),\n+                        entryInfo.loc()));\n+            }\n@@ -175,4 +192,19 @@\n-        cenEntryNames.addFirst(nextCenEntryName);\n-        if (checkAnyCenEntry(locEntryName, cenEntryNames)) {\n-            warn(getMsg(\"warn.validator.order.mismatch\"));\n-            \/\/ order mismatch is just a warning, still consider valid\n+        \/**\n+         * Record an entry apperance in LOC\n+         * We compare entry order based on the CEN. Thus do not step LOC\n+         * encounter order if the entry is only in LOC.\n+         * NOTE: This works because all CEN entries are added before adding LOC entries.\n+         *\/\n+        public void addLocEntry(ZipEntry locEntry) {\n+            var entryName = locEntry.getName();\n+            var entryInfo = entries.get(entryName);\n+            if (entryInfo == null) {\n+                entries.put(entryName, new EntryInfo(\n+                        PLACE_HOLDER,\n+                        new EntryEncounter(locEncounterOrder, 1)));\n+            } else {\n+                assert !entryInfo.cen().isPlaceHolder();\n+                entries.put(entryName, new EntryInfo(\n+                        entryInfo.cen(),\n+                        entryInfo.loc().increase(() -> entryInfo.cen().isPlaceHolder() ? locEncounterOrder : locEncounterOrder++)));\n+            }\n@@ -180,2 +212,0 @@\n-        return false;\n-    }\n@@ -183,12 +213,7 @@\n-    \/*\n-     * Retrieve entries from the XipInputStream to verify local file headers(LOC)\n-     * have same entries as the cental directory(CEN).\n-     *\/\n-    private void checkZipInputStream(LinkedList<String> cenEntryNames) {\n-        try {\n-            ZipEntry e;\n-            var dedupLocNames = new DedupEntryNames(false);\n-            boolean outOfOrder = false;\n-\n-            while ((e = zis.getNextEntry()) != null) {\n-                dedupLocNames.add(e.getName());\n+        \/**\n+         * Issue warning for duplicate entries\n+         *\/\n+        private void checkDuplicates(int count, String msg, String entryName) {\n+            if (count > 1) {\n+                warn(formatMsg(msg, Integer.toString(count), entryName));\n+                isValid = false;\n@@ -196,0 +221,1 @@\n+        }\n@@ -197,6 +223,9 @@\n-            for (var locEntryName : dedupLocNames.dedup()) {\n-                if (outOfOrder) {\n-                    checkAnyCenEntry(locEntryName, cenEntryNames);\n-                } else {\n-                    outOfOrder = !checkNextCenEntry(locEntryName, cenEntryNames);\n-                }\n+        \/**\n+         * Validation per entry observed.\n+         * Each entry must appeared at least oncee in CEN or LOC.\n+         *\/\n+        private void validateEntry(String entryName, EntryInfo entryInfo) {\n+            \/\/ Check invalid entry name\n+            if (!isZipEntryNameValid(entryName)) {\n+                warn(formatMsg(\"warn.validator.invalid.entry.name\", entryName));\n+                isValid = false;\n@@ -204,3 +233,14 @@\n-            \/\/ remaining entries in CEN not matching any in LOC\n-            for (var cenEntryName: cenEntryNames) {\n-                warn(formatMsg(\"warn.validator.cen.only.entry\", cenEntryName));\n+            \/\/ Check duplicate entries in CEN\n+            checkDuplicates(entryInfo.cen().count(), \"warn.validator.duplicate.cen.entry\", entryName);\n+            \/\/ Check duplicate entries in LOC\n+            checkDuplicates(entryInfo.loc().count(), \"warn.validator.duplicate.loc.entry\", entryName);\n+            \/\/ Check consistency between CEN and LOC\n+            if (entryInfo.cen().isPlaceHolder()) {\n+                warn(formatMsg(\"warn.validator.loc.only.entry\", entryName));\n+                isValid = false;\n+            } else if (entryInfo.loc().isPlaceHolder()) {\n+                warn(formatMsg(\"warn.validator.cen.only.entry\", entryName));\n+                isValid = false;\n+            } else if (!outOfOrder && entryInfo.loc().order() != entryInfo.cen().order()) {\n+                outOfOrder = true;\n+                warn(getMsg(\"warn.validator.order.mismatch\"));\n@@ -208,2 +248,7 @@\n-        } catch (IOException ioe) {\n-           throw new InvalidJarException(ioe.getMessage());\n+        }\n+\n+        \/**\n+         * Validate the jar entries by check each entry in encounter order\n+         *\/\n+        public void validate() {\n+            entries.sequencedEntrySet().forEach(e -> validateEntry(e.getKey(), e.getValue()));\n@@ -213,0 +258,1 @@\n+\n@@ -215,1 +261,1 @@\n-            var dedupCEN = new DedupEntryNames(true);\n+            var entryValidator = new EntryValidator();\n@@ -217,1 +263,1 @@\n-              .peek(e -> dedupCEN.add(e.getName()))\n+              .peek(entryValidator::addCenEntry)\n@@ -234,2 +280,11 @@\n-            checkZipInputStream(dedupCEN.dedup());\n-        } catch (InvalidJarException e) {\n+            \/*\n+            * Retrieve entries from the ZipInputStream to verify local file headers(LOC)\n+            * have same entries as the cental directory(CEN).\n+            *\/\n+            ZipEntry e;\n+            while ((e = zis.getNextEntry()) != null) {\n+                entryValidator.addLocEntry(e);\n+            }\n+\n+            entryValidator.validate();\n+        } catch (IOException | InvalidJarException e) {\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Validator.java","additions":140,"deletions":85,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-        Warning: {0} copies of {1} is detected in central directory\n+        Warning: There were {0} central directory entries found for {1}\n@@ -149,1 +149,3 @@\n-        Warning: {0} copies of {1} is detected in local file header\n+        Warning: There were {0} local file headers found for {1}\n+warn.validator.invalid.entry.name=\\\n+        Warning: entry name {0} is not valid\n@@ -281,1 +283,5 @@\n-\\                             versions.\n+\\                             versions.\\n\\\n+\\                             This option also check for multiple copies of same file\\n\\\n+\\                             or invalid file names that could lead to unintended effects.\\n\\\n+\\                             Check with the developer to ensure the jar archive integrity\\n\\\n+\\                             when warnings observed after using this option.\n@@ -359,2 +365,0 @@\n-main.help.opt.extract=\\\n-\\ Operation modifiers valid only in extract mode:\\n\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -109,0 +109,6 @@\n+`--validate`\n+:   Validate the contents of the jar archive.\n+    Check with the developer to ensure the jar archive integrity\n+    when warnings observed after using this option.\n+    See `Integrity of a jar Archive` section below for more details.\n+\n@@ -216,0 +222,16 @@\n+## Integrity of a jar Archive\n+As a jar archive is based on ZIP format, it is possible to manufacture a jar archive using tools\n+other than the `jar` command. The `--validate` options checks a jar archive for some integrity\n+straights:\n+\n+-   Entries in the centrail directory should be consistent with the local file headers.\n+-   Same names entry should only have one copy. Duplicated entries in a jar file could lead to\n+    override desired content.\n+-   Entries names should be valid. An entry name should not:\n+    - contain a drive or device letter,\n+    - contain a leading slash\n+    - contain backwards slashes '\\'\n+    - have any name element is \".\" or \"..\"\n+-   The API exported by a multi-release jar archive is consistent across all different release\n+    versions.\n+\n","filename":"src\/jdk.jartool\/share\/man\/jar.md","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import org.junit.jupiter.api.Assertions;\n@@ -41,0 +40,3 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -83,2 +85,2 @@\n-        int locPosA, locPosB, cenPos;\n-        System.out.printf(\"%n%n*****Creating Jar with the Manifest as the 1st, 2nd and 4th entry*****%n%n\");\n+        int locPosA, cenPos;\n+        System.out.printf(\"%n%n*****Creating Jar with duplicate Manifest*****%n%n\");\n@@ -96,1 +98,0 @@\n-            locPosB = out.size();\n@@ -105,1 +106,1 @@\n-        \/\/ ISO_8859_1 to keep the 8-bit value\n+        \/\/ ISO_8859_1 to keep the 8-bit value to avoid mess index in the byte array\n@@ -144,1 +145,1 @@\n-        \/\/ ISO_8859_1 to keep the 8-bit value\n+        \/\/ ISO_8859_1 to keep the 8-bit value to avoid mess index in the byte array\n@@ -232,3 +233,3 @@\n-            Assertions.assertTrue(err.contains(\"Warning: 2 copies of META-INF\/MANIFEST.MF is detected in local file header\"));\n-            Assertions.assertTrue(err.contains(\"Warning: 3 copies of META-INF\/MANIFEST.MF is detected in central directory\"));\n-            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/BANIFEST.MF in local file header is not in central directory\"));\n+            assertTrue(err.contains(\"Warning: There were 2 local file headers found for META-INF\/MANIFEST.MF\"));\n+            assertTrue(err.contains(\"Warning: There were 3 central directory entries found for META-INF\/MANIFEST.MF\"));\n+            assertTrue(err.contains(\"Warning: Entry META-INF\/BANIFEST.MF in local file header is not in central directory\"));\n@@ -247,2 +248,2 @@\n-            Assertions.assertTrue(err.contains(\"Warning: 2 copies of META-INF\/MANIFEST.MF is detected in local file header\"));\n-            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/AANIFEST.MF in central directory is not in local file header\"));\n+            assertTrue(err.contains(\"Warning: There were 2 local file headers found for META-INF\/MANIFEST.MF\"));\n+            assertTrue(err.contains(\"Warning: Entry META-INF\/AANIFEST.MF in central directory is not in local file header\"));\n@@ -261,3 +262,4 @@\n-            Assertions.assertTrue(err.contains(\"Warning: 3 copies of META-INF\/MANIFEST.MF is detected in central directory\"));\n-            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/AANIFEST.MF in local file header is not in central directory\"));\n-            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/BANIFEST.MF in local file header is not in central directory\"));\n+            assertTrue(err.contains(\"Warning: There were 3 central directory entries found for META-INF\/MANIFEST.MF\"));\n+            assertTrue(err.contains(\"Warning: Entry META-INF\/AANIFEST.MF in local file header is not in central directory\"));\n+            assertTrue(err.contains(\"Warning: Entry META-INF\/BANIFEST.MF in local file header is not in central directory\"));\n+            assertFalse(err.contains(\"Warning: Central directory and local file header entries are not in the same order\"));\n@@ -274,1 +276,1 @@\n-            Assertions.assertTrue(err.contains(\"Warning: Central directory and local file header entries are not in the same order\"));\n+            assertTrue(err.contains(\"Warning: Central directory and local file header entries are not in the same order\"));\n@@ -276,1 +278,1 @@\n-            Assertions.fail(\"Ordering is not guaranteed by specification\");\n+            fail(\"Ordering is not guaranteed by specification\");\n@@ -290,1 +292,1 @@\n-                Assertions.assertTrue(err.contains(\"entry name malformed, \" + entryName));\n+                assertTrue(err.contains(\"Warning: entry name \" + entryName + \" is not valid\"));\n","filename":"test\/jdk\/tools\/jar\/ValidatorTest.java","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"}]}