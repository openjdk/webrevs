{"files":[{"patch":"@@ -38,1 +38,2 @@\n-import java.util.LinkedHashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n@@ -44,0 +45,1 @@\n+import java.util.regex.Pattern;\n@@ -56,1 +58,19 @@\n-final class Validator {\n+public final class Validator {\n+    \/**\n+     * Regex expression to verify that the Zip Entry file name:\n+     *  - is not an absolute path\n+     *  - the file name is not '.' or '..'\n+     *  - does not contain a backslash, '\\'\n+     *  - does not contain a drive letter\n+     *  - path element does not include '..'\n+     *\/\n+    private static final Pattern INVALID_ZIP_ENTRY_NAME_PATTERN = Pattern.compile(\n+            \"^(\\\\.|\\\\.\\\\.)$\"\n+                    + \"|^\\\\.\\\\.\/\"\n+                    + \"|\/\\\\.\\\\.$\"\n+                    + \"|\/\\\\.\\\\.\/\"\n+                    + \"|^\/\"\n+                    + \"|^\\\\\\\\\"\n+                    + \"|.*\\\\\\\\.*\"\n+                    + \"|.*[a-zA-Z]:.*\"\n+    );\n@@ -66,1 +86,0 @@\n-    private final LinkedHashSet<String> cenEntryNames = new LinkedHashSet<>();\n@@ -79,6 +98,57 @@\n-    \/\/ Detect duplicates when iterate through CEN entries\n-    private void checkDuplicates(ZipEntry e) {\n-        var cenEntryName = e.getName();\n-        if (!cenEntryNames.add(cenEntryName)) {\n-            warn(formatMsg(\"warn.validator.duplicate.cen.entry\", cenEntryName));\n-            isValid = false;\n+    \/**\n+     * Validate that the CEN\/LOC file name header field adheres  to\n+     * PKWARE APPNOTE-6.3.3.TXT:\n+     *\n+     * 4.4.17.1 The name of the file, with optional relative path.\n+     * The path stored MUST not contain a drive or\n+     * device letter, or a leading slash.  All slashes\n+     * MUST be forward slashes '\/' as opposed to\n+     * backwards slashes '\\' for compatibility with Amiga\n+     * and UNIX file systems etc.\n+     * Also validate that the file name is not \".\" and that any name element is\n+     * not equal to \"..\"\n+     *\n+     * @param entryName CEN\/LOC header file name field entry\n+     * @return true if a valid Zip Entry file name; false otherwise\n+     *\/\n+    public static boolean isZipEntryNameValid(String entryName) {\n+        return !INVALID_ZIP_ENTRY_NAME_PATTERN.matcher(entryName).find();\n+    }\n+\n+    \/**\n+     * Helper class to deduplicate entry names.\n+     * Keep a coutner for duplicate entry names and check if the entry name is valid on first add.\n+     *\/\n+    private class DedupEntryNames {\n+        LinkedHashMap<String, Integer> entries = new LinkedHashMap<>();\n+        boolean isCEN;\n+\n+        public DedupEntryNames(boolean isCEN) {\n+            this.isCEN = isCEN;\n+        }\n+\n+        public void add(String entryName) {\n+            int latestCount = entries.merge(entryName, 1, (count, _) -> count + 1);\n+            if (latestCount > 1) {\n+                isValid = false;\n+            } else if (!isZipEntryNameValid(entryName)) {\n+                warn(formatMsg(\"error.validator.bad.entry.name\", entryName));\n+                isValid = false;\n+            }\n+        }\n+\n+        private boolean checkDuplicates(Map.Entry<String, Integer> counter) {\n+            var count = counter.getValue();\n+            if (count == 1) {\n+            } else {\n+                var msg = isCEN ? \"warn.validator.duplicate.cen.entry\" : \"warn.validator.duplicate.loc.entry\";\n+                warn(formatMsg(msg, count.toString(), counter.getKey()));\n+            }\n+            return true;\n+        }\n+\n+        public LinkedList<String> dedup() {\n+            return entries.sequencedEntrySet().stream()\n+                    .filter(this::checkDuplicates)\n+                    .map(Map.Entry::getKey)\n+                    .collect(Collectors.toCollection(LinkedList::new));\n@@ -89,1 +159,1 @@\n-    private boolean checkAnyCenEntry(String locEntryName) {\n+    private boolean checkAnyCenEntry(String locEntryName, LinkedList<String> cenEntryNames) {\n@@ -99,1 +169,1 @@\n-    private boolean checkNextCenEntry(String locEntryName) {\n+    private boolean checkNextCenEntry(String locEntryName, LinkedList<String> cenEntryNames) {\n@@ -105,1 +175,2 @@\n-        if (checkAnyCenEntry(locEntryName)) {\n+        cenEntryNames.addFirst(nextCenEntryName);\n+        if (checkAnyCenEntry(locEntryName, cenEntryNames)) {\n@@ -107,1 +178,0 @@\n-            cenEntryNames.addFirst(nextCenEntryName);\n@@ -117,4 +187,1 @@\n-    private void checkZipInputStream() {\n-        var locEntryNames = new LinkedHashSet<String>();\n-        var outOfOrder = false;\n-\n+    private void checkZipInputStream(LinkedList<String> cenEntryNames) {\n@@ -123,0 +190,3 @@\n+            var dedupLocNames = new DedupEntryNames(false);\n+            boolean outOfOrder = false;\n+\n@@ -124,6 +194,2 @@\n-                var locEntryName = e.getName();\n-                if (!locEntryNames.add(locEntryName)) {\n-                    isValid = false;\n-                    warn(formatMsg(\"warn.validator.duplicate.loc.entry\", locEntryName));\n-                    continue;\n-                }\n+                dedupLocNames.add(e.getName());\n+            }\n@@ -131,0 +197,1 @@\n+            for (var locEntryName : dedupLocNames.dedup()) {\n@@ -132,1 +199,1 @@\n-                    checkAnyCenEntry(locEntryName);\n+                    checkAnyCenEntry(locEntryName, cenEntryNames);\n@@ -134,1 +201,1 @@\n-                    outOfOrder = !checkNextCenEntry(locEntryName);\n+                    outOfOrder = !checkNextCenEntry(locEntryName, cenEntryNames);\n@@ -148,0 +215,1 @@\n+            var dedupCEN = new DedupEntryNames(true);\n@@ -149,1 +217,1 @@\n-              .peek(this::checkDuplicates)\n+              .peek(e -> dedupCEN.add(e.getName()))\n@@ -165,1 +233,2 @@\n-            checkZipInputStream();\n+\n+            checkZipInputStream(dedupCEN.dedup());\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Validator.java","additions":96,"deletions":27,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-        Warning: More than one copy of {0} is detected in central directory\n+        Warning: {0} copies of {1} is detected in central directory\n@@ -149,1 +149,1 @@\n-        Warning: More than one copy of {0} is detected in local file header\n+        Warning: {0} copies of {1} is detected in local file header\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,0 @@\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.AfterEach;\n@@ -40,1 +38,0 @@\n-import org.junit.jupiter.api.BeforeAll;\n@@ -52,1 +49,1 @@\n-import java.util.jar.Attributes;\n+import java.util.List;\n@@ -54,1 +51,0 @@\n-import java.util.jar.Manifest;\n@@ -73,1 +69,0 @@\n-    static final Path zip = Path.of(\"MultipleManifestTest.jar\");\n@@ -87,20 +82,0 @@\n-    \/**\n-     * Delete the ZIP file produced by this test\n-     *\n-     * @throws IOException if an unexpected IOException occurs\n-     *\/\n-    @AfterAll\n-    public void cleanup() throws IOException {\n-        Files.deleteIfExists(zip);\n-    }\n-\n-    \/**\n-     * Create a JAR with the Manifest as the 1st, 2nd and 4th entry\n-     *\n-     * @throws IOException if an error occurs\n-     *\/\n-    @BeforeAll\n-    public void beforeAll() throws IOException {\n-        writeManifestAsFirstSecondAndFourthEntry(zip, true, true);\n-    }\n-\n@@ -143,2 +118,0 @@\n-            loc = s.indexOf(\"BANIFEST.MF\", locPosB);\n-            template[loc] = (byte) 'M';\n@@ -183,3 +156,64 @@\n-    @AfterEach\n-    public void removeExtractedFiles() {\n-        rm(\"META-INF entry1.txt entry2.txt\");\n+    record EntryNameTestCase(String entryName, boolean isValid) {}\n+\n+    private static Stream<EntryNameTestCase> zipEntryPaths() {\n+        return Stream.of(\n+                new EntryNameTestCase(\"..\/..\/c:\/\/\/\/d:\/tmp\/testentry0\", false),\n+                new EntryNameTestCase(\"..\\\\..\\\\c:\\\\d:\\\\tmp\\\\testentry1\", false),\n+                new EntryNameTestCase(\"\/\/\/\/c:\/tmp\/testentry2\", false),\n+                new EntryNameTestCase(\"\/\/\/\/c:\/d:\/tmp\/testentry3\", false),\n+                new EntryNameTestCase(\"c:\/\/\/\/\/d:\/tmp\/testentry4\", false),\n+                new EntryNameTestCase(\"\/\/tmp\/tmp2\/testentry5\", false),\n+                new EntryNameTestCase(\"\/\/\/tmp\/abc\", false),\n+                new EntryNameTestCase(\"C:\\\\Documents\\\\tennis\\\\CardioTennis.pdf\", false),\n+                new EntryNameTestCase(\"\\\\Program Files\\\\Custom Utilities\\\\tennis.exe\", false),\n+                new EntryNameTestCase(\"myhome\\\\Hello.txt\", false),\n+                new EntryNameTestCase(\"Hello.txt\", true),\n+                new EntryNameTestCase(\".\/Hello.txt\", true),\n+                new EntryNameTestCase(\"..\/Hello.txt\", false),\n+                new EntryNameTestCase(\".\\\\Hello.txt\", false),\n+                new EntryNameTestCase(\"..\\\\Hello.txt\", false),\n+                new EntryNameTestCase(\"C:\\\\Hello.txt\", false),\n+                new EntryNameTestCase(\"D:\/Hello.txt\", false),\n+                new EntryNameTestCase(\"foo\\\\bar.txt\", false),\n+                new EntryNameTestCase(\"foo\/bar.txt\", true),\n+                new EntryNameTestCase(\"foo\/..\/bar.txt\", false),\n+                new EntryNameTestCase(\"foo\/.\/bar.txt\", true),\n+                new EntryNameTestCase(\"..\", false),\n+                new EntryNameTestCase(\".\", false),\n+                new EntryNameTestCase(\"\/home\/foo.txt\", false),\n+                new EntryNameTestCase(\".\/home\/foo.txt\", true),\n+                new EntryNameTestCase(\"..\/home\/foo.txt\", false),\n+                new EntryNameTestCase(\"foo\/bar\/..\", false),\n+                new EntryNameTestCase(\"foo\/bar\/.\", true),\n+                new EntryNameTestCase(\"\/foo\/bar\/..\/..\/myhome\/bin\", false),\n+                new EntryNameTestCase(\"\/foo\/bar\/.\/.\/myhome\/bin\", false),\n+                new EntryNameTestCase(\"myHome\/..valid\", true),\n+                new EntryNameTestCase(\"myHome\/.valid\", true),\n+                new EntryNameTestCase(\"..valid\", true),\n+                new EntryNameTestCase(\".valid\", true)\n+        );\n+    }\n+\n+    private List<String> createInvalidEntryJar(Path path) throws IOException {\n+        System.out.printf(\"%n%n*****Creating Jar with the invalid entry names*****%n%n\");\n+        var out = new ByteArrayOutputStream(1024);\n+        List<String> invalidEntryNames;\n+        try (var zos = new ZipOutputStream(out)) {\n+            invalidEntryNames = zipEntryPaths()\n+                .filter(testCase -> {\n+                        try {\n+                            zos.putNextEntry(new ZipEntry(testCase.entryName()));\n+                            var content = \"Content of \" + testCase.entryName();\n+                            zos.write(content.getBytes(StandardCharsets.UTF_8));\n+                            return !testCase.isValid();\n+                        } catch (IOException ioe) {\n+                            throw new UncheckedIOException(ioe);\n+                        }\n+                    })\n+                .map(EntryNameTestCase::entryName).toList();\n+            zos.flush();\n+        } catch (UncheckedIOException uioe) {\n+            throw uioe.getCause();\n+        }\n+        Files.write(path, out.toByteArray());\n+        return invalidEntryNames;\n@@ -188,0 +222,1 @@\n+\n@@ -189,1 +224,3 @@\n-    public void testValidate() {\n+    public void testValidate() throws IOException {\n+        var zip = Path.of(\"MultipleManifestTest.jar\");\n+        writeManifestAsFirstSecondAndFourthEntry(zip, true, true);\n@@ -195,2 +232,3 @@\n-            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected in local file header\"));\n-            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected in central directory\"));\n+            Assertions.assertTrue(err.contains(\"Warning: 2 copies of META-INF\/MANIFEST.MF is detected in local file header\"));\n+            Assertions.assertTrue(err.contains(\"Warning: 3 copies of META-INF\/MANIFEST.MF is detected in central directory\"));\n+            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/BANIFEST.MF in local file header is not in central directory\"));\n@@ -209,1 +247,1 @@\n-            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected in local file header\"));\n+            Assertions.assertTrue(err.contains(\"Warning: 2 copies of META-INF\/MANIFEST.MF is detected in local file header\"));\n@@ -211,1 +249,0 @@\n-            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/BANIFEST.MF in central directory is not in local file header\"));\n@@ -224,1 +261,1 @@\n-            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected in central directory\"));\n+            Assertions.assertTrue(err.contains(\"Warning: 3 copies of META-INF\/MANIFEST.MF is detected in central directory\"));\n@@ -243,4 +280,12 @@\n-    private String getManifestVersion() throws IOException {\n-        try (var is = Files.newInputStream(Path.of(JarFile.MANIFEST_NAME))) {\n-            var manifest = new Manifest(is);\n-            return manifest.getMainAttributes().getValue(Attributes.Name.MANIFEST_VERSION);\n+    @Test\n+    public void testInvalidEntryName() throws IOException {\n+        Path f = Path.of(\"InvalidEntry.jar\");\n+        var invalidEntryNames = createInvalidEntryJar(f);\n+        try {\n+            jar(\"--validate --file \" + f.toString());\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            for (var entryName : invalidEntryNames) {\n+                Assertions.assertTrue(err.contains(\"entry name malformed, \" + entryName));\n+            }\n@@ -272,8 +317,0 @@\n-    private void assertOutputContains(String expected) {\n-        Assertions.assertTrue(baos.toString().contains(expected));\n-    }\n-\n-    private void println() throws IOException {\n-        System.out.println(new String(baos.toByteArray()));\n-    }\n-\n","filename":"test\/jdk\/tools\/jar\/ValidatorTest.java","additions":86,"deletions":49,"binary":false,"changes":135,"status":"modified"}]}