{"files":[{"patch":"@@ -450,2 +450,5 @@\n-        try (ZipFile zf = new ZipFile(file)) {\n-            return Validator.validate(this, zf);\n+        try (ZipFile zf = new ZipFile(file);\n+            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(\n+                    new FileInputStream(file)))) {\n+\n+            return Validator.validate(this, zf, zis);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.File;\n@@ -39,0 +38,2 @@\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n@@ -44,0 +45,1 @@\n+import java.util.regex.Pattern;\n@@ -47,0 +49,1 @@\n+import java.util.zip.ZipInputStream;\n@@ -48,1 +51,0 @@\n-import static java.util.jar.JarFile.MANIFEST_NAME;\n@@ -57,0 +59,18 @@\n+    \/**\n+     * Regex expression to verify that the Zip Entry file name:\n+     *  - is not an absolute path\n+     *  - the file name is not '.' or '..'\n+     *  - does not contain a backslash, '\\'\n+     *  - does not contain a drive letter\n+     *  - path element does not include '..'\n+     *\/\n+    private static final Pattern INVALID_ZIP_ENTRY_NAME_PATTERN = Pattern.compile(\n+            \"^(\\\\.|\\\\.\\\\.)$\"\n+                    + \"|^\\\\.\\\\.\/\"\n+                    + \"|\/\\\\.\\\\.$\"\n+                    + \"|\/\\\\.\\\\.\/\"\n+                    + \"|^\/\"\n+                    + \"|^\\\\\\\\\"\n+                    + \"|.*\\\\\\\\.*\"\n+                    + \"|.*[a-zA-Z]:.*\"\n+    );\n@@ -65,0 +85,1 @@\n+    private final ZipInputStream zis;\n@@ -66,1 +87,1 @@\n-    private Validator(Main main, ZipFile zf) {\n+    private Validator(Main main, ZipFile zf, ZipInputStream zis) {\n@@ -69,0 +90,1 @@\n+        this.zis = zis;\n@@ -72,2 +94,117 @@\n-    static boolean validate(Main main, ZipFile zf) throws IOException {\n-        return new Validator(main, zf).validate();\n+    static boolean validate(Main main, ZipFile zf, ZipInputStream zis) throws IOException {\n+        return new Validator(main, zf, zis).validate();\n+    }\n+\n+    \/**\n+     * Validate that the CEN\/LOC file name header field adheres  to\n+     * PKWARE APPNOTE-6.3.3.TXT:\n+     *\n+     * 4.4.17.1 The name of the file, with optional relative path.\n+     * The path stored MUST not contain a drive or\n+     * device letter, or a leading slash.  All slashes\n+     * MUST be forward slashes '\/' as opposed to\n+     * backwards slashes '\\' for compatibility with Amiga\n+     * and UNIX file systems etc.\n+     * Also validate that the file name is not \".\" and that any name element is\n+     * not equal to \"..\"\n+     *\n+     * @param entryName CEN\/LOC header file name field entry\n+     * @return true if a valid Zip Entry file name; false otherwise\n+     *\/\n+    public static boolean isZipEntryNameValid(String entryName) {\n+        return !INVALID_ZIP_ENTRY_NAME_PATTERN.matcher(entryName).find();\n+    }\n+\n+    \/**\n+     * Helper class to deduplicate entry names.\n+     * Keep a coutner for duplicate entry names and check if the entry name is valid on first add.\n+     *\/\n+    private class DedupEntryNames {\n+        LinkedHashMap<String, Integer> entries = new LinkedHashMap<>();\n+        boolean isCEN;\n+\n+        public DedupEntryNames(boolean isCEN) {\n+            this.isCEN = isCEN;\n+        }\n+\n+        public void add(String entryName) {\n+            int latestCount = entries.merge(entryName, 1, (count, _) -> count + 1);\n+            if (latestCount > 1) {\n+                isValid = false;\n+            } else if (!isZipEntryNameValid(entryName)) {\n+                warn(formatMsg(\"error.validator.bad.entry.name\", entryName));\n+                isValid = false;\n+            }\n+        }\n+\n+        private boolean checkDuplicates(Map.Entry<String, Integer> counter) {\n+            var count = counter.getValue();\n+            if (count == 1) {\n+            } else {\n+                var msg = isCEN ? \"warn.validator.duplicate.cen.entry\" : \"warn.validator.duplicate.loc.entry\";\n+                warn(formatMsg(msg, count.toString(), counter.getKey()));\n+            }\n+            return true;\n+        }\n+\n+        public LinkedList<String> dedup() {\n+            return entries.sequencedEntrySet().stream()\n+                    .filter(this::checkDuplicates)\n+                    .map(Map.Entry::getKey)\n+                    .collect(Collectors.toCollection(LinkedList::new));\n+        }\n+    }\n+\n+    \/\/ Check any CEN entry is matching the specified name\n+    private boolean checkAnyCenEntry(String locEntryName, LinkedList<String> cenEntryNames) {\n+        var hasEntry = cenEntryNames.remove(locEntryName);\n+        if (!hasEntry) {\n+            warn(formatMsg(\"warn.validator.loc.only.entry\", locEntryName));\n+            isValid = false;\n+        }\n+        return hasEntry;\n+    }\n+\n+    \/\/ Check next CEN entry is matching the specified name\n+    private boolean checkNextCenEntry(String locEntryName, LinkedList<String> cenEntryNames) {\n+        var nextCenEntryName = cenEntryNames.removeFirst();\n+        if (nextCenEntryName.equals(locEntryName)) {\n+            return true;\n+        }\n+\n+        cenEntryNames.addFirst(nextCenEntryName);\n+        if (checkAnyCenEntry(locEntryName, cenEntryNames)) {\n+            warn(getMsg(\"warn.validator.order.mismatch\"));\n+            \/\/ order mismatch is just a warning, still consider valid\n+        }\n+        return false;\n+    }\n+\n+    \/*\n+     * Retrieve entries from the XipInputStream to verify local file headers(LOC)\n+     * have same entries as the cental directory(CEN).\n+     *\/\n+    private void checkZipInputStream(LinkedList<String> cenEntryNames) {\n+        try {\n+            ZipEntry e;\n+            var dedupLocNames = new DedupEntryNames(false);\n+            boolean outOfOrder = false;\n+\n+            while ((e = zis.getNextEntry()) != null) {\n+                dedupLocNames.add(e.getName());\n+            }\n+\n+            for (var locEntryName : dedupLocNames.dedup()) {\n+                if (outOfOrder) {\n+                    checkAnyCenEntry(locEntryName, cenEntryNames);\n+                } else {\n+                    outOfOrder = !checkNextCenEntry(locEntryName, cenEntryNames);\n+                }\n+            }\n+            \/\/ remaining entries in CEN not matching any in LOC\n+            for (var cenEntryName: cenEntryNames) {\n+                warn(formatMsg(\"warn.validator.cen.only.entry\", cenEntryName));\n+            }\n+        } catch (IOException ioe) {\n+           throw new InvalidJarException(ioe.getMessage());\n+        }\n@@ -78,0 +215,1 @@\n+            var dedupCEN = new DedupEntryNames(true);\n@@ -79,0 +217,1 @@\n+              .peek(e -> dedupCEN.add(e.getName()))\n@@ -94,0 +233,2 @@\n+\n+            checkZipInputStream(dedupCEN.dedup());\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Validator.java","additions":147,"deletions":6,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,0 +146,10 @@\n+warn.validator.duplicate.cen.entry=\\\n+        Warning: {0} copies of {1} is detected in central directory\n+warn.validator.duplicate.loc.entry=\\\n+        Warning: {0} copies of {1} is detected in local file header\n+warn.validator.cen.only.entry=\\\n+        Warning: Entry {0} in central directory is not in local file header\n+warn.validator.loc.only.entry=\\\n+        Warning: Entry {0} in local file header is not in central directory\n+warn.validator.order.mismatch=\\\n+        Warning: Central directory and local file header entries are not in the same order\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,335 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8345431\n+ * @summary test validator to report malformed jar file\n+ * @library \/test\/lib\n+ * @modules jdk.jartool\n+ * @build jdk.test.lib.Platform\n+ *        jdk.test.lib.util.FileUtils\n+ * @run junit\/othervm ValidatorTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestInstance.Lifecycle;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.jar.JarFile;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+@TestInstance(Lifecycle.PER_CLASS)\n+class ValidatorTest {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jar tool not found\")\n+        );\n+\n+    private final String nl = System.lineSeparator();\n+    private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private final PrintStream jarOut = new PrintStream(baos);\n+\n+    static final String jdkVendor = System.getProperty(\"java.vendor\");\n+    static final String jdkVersion = System.getProperty(\"java.version\");\n+    static final String MANIFEST1 = \"Manifest-Version: 1.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    static final String MANIFEST2 = \"Manifest-Version: 2.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    static final String MANIFEST3 = \"Manifest-Version: 3.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    private static final String META_INF = \"META-INF\/\";\n+\n+    private void writeManifestAsFirstSecondAndFourthEntry(Path path, boolean useCen, boolean useLoc) throws IOException {\n+        int locPosA, locPosB, cenPos;\n+        System.out.printf(\"%n%n*****Creating Jar with the Manifest as the 1st, 2nd and 4th entry*****%n%n\");\n+        var out = new ByteArrayOutputStream(1024);\n+        try (var zos = new ZipOutputStream(out)) {\n+            zos.putNextEntry(new ZipEntry(JarFile.MANIFEST_NAME));\n+            zos.write(MANIFEST1.getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosA = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"AANIFEST.MF\"));\n+            zos.write(MANIFEST2.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zos.write(\"entry1\".getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosB = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"BANIFEST.MF\"));\n+            zos.write(MANIFEST3.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zos.write(\"hello entry2\".getBytes(StandardCharsets.UTF_8));\n+            zos.flush();\n+            cenPos = out.size();\n+        }\n+        var template = out.toByteArray();\n+        \/\/ ISO_8859_1 to keep the 8-bit value\n+        var s = new String(template, StandardCharsets.ISO_8859_1);\n+        \/\/ change META-INF\/AANIFEST.MF to META-INF\/MANIFEST.MF\n+        if (useCen) {\n+            var cen = s.indexOf(\"AANIFEST.MF\", cenPos);\n+            template[cen] = (byte) 'M';\n+            \/\/ change META-INF\/BANIFEST.MF to META-INF\/MANIFEST.MF\n+            cen = s.indexOf(\"BANIFEST.MF\", cenPos);\n+            template[cen] = (byte) 'M';\n+        }\n+        if (useLoc) {\n+            var loc = s.indexOf(\"AANIFEST.MF\", locPosA);\n+            template[loc] = (byte) 'M';\n+        }\n+        Files.write(path, template);\n+    }\n+\n+    private void createMismatchOrderJar(Path path) throws IOException {\n+        int locPosA, locPosB;\n+        System.out.printf(\"%n%n*****Creating Jar with the swap entry name*****%n%n\");\n+        var out = new ByteArrayOutputStream(1024);\n+        try (var zos = new ZipOutputStream(out)) {\n+            zos.putNextEntry(new ZipEntry(JarFile.MANIFEST_NAME));\n+            zos.write(MANIFEST1.getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosA = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"AANIFEST.MF\"));\n+            zos.write(MANIFEST2.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zos.write(\"entry1\".getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosB = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"BANIFEST.MF\"));\n+            zos.write(MANIFEST3.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zos.write(\"hello entry2\".getBytes(StandardCharsets.UTF_8));\n+            zos.flush();\n+        }\n+        var template = out.toByteArray();\n+        \/\/ ISO_8859_1 to keep the 8-bit value\n+        var s = new String(template, StandardCharsets.ISO_8859_1);\n+        \/\/ change META-INF\/AANIFEST.MF to META-INF\/BANIFEST.MF\n+        var loc = s.indexOf(\"AANIFEST.MF\", locPosA);\n+        template[loc] = (byte) 'B';\n+        \/\/ change META-INF\/BANIFEST.MF to META-INF\/AANIFEST.MF\n+        loc = s.indexOf(\"BANIFEST.MF\", locPosB);\n+        template[loc] = (byte) 'A';\n+\n+        Files.write(path, template);\n+    }\n+\n+    record EntryNameTestCase(String entryName, boolean isValid) {}\n+\n+    private static Stream<EntryNameTestCase> zipEntryPaths() {\n+        return Stream.of(\n+                new EntryNameTestCase(\"..\/..\/c:\/\/\/\/d:\/tmp\/testentry0\", false),\n+                new EntryNameTestCase(\"..\\\\..\\\\c:\\\\d:\\\\tmp\\\\testentry1\", false),\n+                new EntryNameTestCase(\"\/\/\/\/c:\/tmp\/testentry2\", false),\n+                new EntryNameTestCase(\"\/\/\/\/c:\/d:\/tmp\/testentry3\", false),\n+                new EntryNameTestCase(\"c:\/\/\/\/\/d:\/tmp\/testentry4\", false),\n+                new EntryNameTestCase(\"\/\/tmp\/tmp2\/testentry5\", false),\n+                new EntryNameTestCase(\"\/\/\/tmp\/abc\", false),\n+                new EntryNameTestCase(\"C:\\\\Documents\\\\tennis\\\\CardioTennis.pdf\", false),\n+                new EntryNameTestCase(\"\\\\Program Files\\\\Custom Utilities\\\\tennis.exe\", false),\n+                new EntryNameTestCase(\"myhome\\\\Hello.txt\", false),\n+                new EntryNameTestCase(\"Hello.txt\", true),\n+                new EntryNameTestCase(\".\/Hello.txt\", true),\n+                new EntryNameTestCase(\"..\/Hello.txt\", false),\n+                new EntryNameTestCase(\".\\\\Hello.txt\", false),\n+                new EntryNameTestCase(\"..\\\\Hello.txt\", false),\n+                new EntryNameTestCase(\"C:\\\\Hello.txt\", false),\n+                new EntryNameTestCase(\"D:\/Hello.txt\", false),\n+                new EntryNameTestCase(\"foo\\\\bar.txt\", false),\n+                new EntryNameTestCase(\"foo\/bar.txt\", true),\n+                new EntryNameTestCase(\"foo\/..\/bar.txt\", false),\n+                new EntryNameTestCase(\"foo\/.\/bar.txt\", true),\n+                new EntryNameTestCase(\"..\", false),\n+                new EntryNameTestCase(\".\", false),\n+                new EntryNameTestCase(\"\/home\/foo.txt\", false),\n+                new EntryNameTestCase(\".\/home\/foo.txt\", true),\n+                new EntryNameTestCase(\"..\/home\/foo.txt\", false),\n+                new EntryNameTestCase(\"foo\/bar\/..\", false),\n+                new EntryNameTestCase(\"foo\/bar\/.\", true),\n+                new EntryNameTestCase(\"\/foo\/bar\/..\/..\/myhome\/bin\", false),\n+                new EntryNameTestCase(\"\/foo\/bar\/.\/.\/myhome\/bin\", false),\n+                new EntryNameTestCase(\"myHome\/..valid\", true),\n+                new EntryNameTestCase(\"myHome\/.valid\", true),\n+                new EntryNameTestCase(\"..valid\", true),\n+                new EntryNameTestCase(\".valid\", true)\n+        );\n+    }\n+\n+    private List<String> createInvalidEntryJar(Path path) throws IOException {\n+        System.out.printf(\"%n%n*****Creating Jar with the invalid entry names*****%n%n\");\n+        var out = new ByteArrayOutputStream(1024);\n+        List<String> invalidEntryNames;\n+        try (var zos = new ZipOutputStream(out)) {\n+            invalidEntryNames = zipEntryPaths()\n+                .filter(testCase -> {\n+                        try {\n+                            zos.putNextEntry(new ZipEntry(testCase.entryName()));\n+                            var content = \"Content of \" + testCase.entryName();\n+                            zos.write(content.getBytes(StandardCharsets.UTF_8));\n+                            return !testCase.isValid();\n+                        } catch (IOException ioe) {\n+                            throw new UncheckedIOException(ioe);\n+                        }\n+                    })\n+                .map(EntryNameTestCase::entryName).toList();\n+            zos.flush();\n+        } catch (UncheckedIOException uioe) {\n+            throw uioe.getCause();\n+        }\n+        Files.write(path, out.toByteArray());\n+        return invalidEntryNames;\n+    }\n+\n+\n+    @Test\n+    public void testValidate() throws IOException {\n+        var zip = Path.of(\"MultipleManifestTest.jar\");\n+        writeManifestAsFirstSecondAndFourthEntry(zip, true, true);\n+        try {\n+            jar(\"--validate --file \" + zip.toString());\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            Assertions.assertTrue(err.contains(\"Warning: 2 copies of META-INF\/MANIFEST.MF is detected in local file header\"));\n+            Assertions.assertTrue(err.contains(\"Warning: 3 copies of META-INF\/MANIFEST.MF is detected in central directory\"));\n+            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/BANIFEST.MF in local file header is not in central directory\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testOnlyLocModified() throws IOException {\n+        Path f = Path.of(\"LocHacked.jar\");\n+        writeManifestAsFirstSecondAndFourthEntry(f, false, true);\n+        try {\n+            jar(\"--validate --file \" + f.toString());\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            Assertions.assertTrue(err.contains(\"Warning: 2 copies of META-INF\/MANIFEST.MF is detected in local file header\"));\n+            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/AANIFEST.MF in central directory is not in local file header\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testOnlyCenModified() throws IOException {\n+        Path f = Path.of(\"CenHacked.jar\");\n+        writeManifestAsFirstSecondAndFourthEntry(f, true, false);\n+        try {\n+            jar(\"--validate --file \" + f.toString());\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            Assertions.assertTrue(err.contains(\"Warning: 3 copies of META-INF\/MANIFEST.MF is detected in central directory\"));\n+            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/AANIFEST.MF in local file header is not in central directory\"));\n+            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/BANIFEST.MF in local file header is not in central directory\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testMismatchOrder() throws IOException {\n+        Path f = Path.of(\"SwappedEntry.jar\");\n+        createMismatchOrderJar(f);\n+        try {\n+            String err = jar(\"--validate --file \" + f.toString());\n+            System.out.println(err);\n+            Assertions.assertTrue(err.contains(\"Warning: Central directory and local file header entries are not in the same order\"));\n+        } catch (IOException e) {\n+            Assertions.fail(\"Ordering is not guaranteed by specification\");\n+        }\n+    }\n+\n+    @Test\n+    public void testInvalidEntryName() throws IOException {\n+        Path f = Path.of(\"InvalidEntry.jar\");\n+        var invalidEntryNames = createInvalidEntryJar(f);\n+        try {\n+            jar(\"--validate --file \" + f.toString());\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            for (var entryName : invalidEntryNames) {\n+                Assertions.assertTrue(err.contains(\"entry name malformed, \" + entryName));\n+            }\n+        }\n+    }\n+\n+    \/\/ return stderr output\n+    private String jar(String cmdline) throws IOException {\n+        System.out.println(\"jar \" + cmdline);\n+        baos.reset();\n+\n+        \/\/ the run method catches IOExceptions, we need to expose them\n+        ByteArrayOutputStream baes = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baes);\n+        PrintStream saveErr = System.err;\n+        System.setErr(err);\n+        try {\n+            int rc = JAR_TOOL.run(jarOut, err, cmdline.split(\" +\"));\n+            if (rc != 0) {\n+                throw new IOException(baes.toString());\n+            } else {\n+                return baes.toString();\n+            }\n+        } finally {\n+            System.setErr(saveErr);\n+        }\n+    }\n+\n+    private Stream<Path> mkpath(String... args) {\n+        return Arrays.stream(args).map(d -> Path.of(\".\", d.split(\"\/\")));\n+    }\n+\n+    private void rm(String cmdline) {\n+        System.out.println(\"rm -rf \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                if (Files.isDirectory(p)) {\n+                    FileUtils.deleteFileTreeWithRetry(p);\n+                } else {\n+                    FileUtils.deleteFileIfExistsWithRetry(p);\n+                }\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jar\/ValidatorTest.java","additions":335,"deletions":0,"binary":false,"changes":335,"status":"added"}]}