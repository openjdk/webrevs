{"files":[{"patch":"@@ -450,2 +450,5 @@\n-        try (ZipFile zf = new ZipFile(file)) {\n-            return Validator.validate(this, zf);\n+        try (ZipFile zf = new ZipFile(file);\n+            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(\n+                    new FileInputStream(file)))) {\n+\n+            return Validator.validate(this, zf, zis);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.File;\n@@ -39,0 +38,1 @@\n+import java.util.LinkedHashSet;\n@@ -47,0 +47,1 @@\n+import java.util.zip.ZipInputStream;\n@@ -48,1 +49,0 @@\n-import static java.util.jar.JarFile.MANIFEST_NAME;\n@@ -65,0 +65,2 @@\n+    private final ZipInputStream zis;\n+    private final LinkedHashSet<String> cenEntryNames = new LinkedHashSet<>();\n@@ -66,1 +68,1 @@\n-    private Validator(Main main, ZipFile zf) {\n+    private Validator(Main main, ZipFile zf, ZipInputStream zis) {\n@@ -69,0 +71,1 @@\n+        this.zis = zis;\n@@ -72,2 +75,69 @@\n-    static boolean validate(Main main, ZipFile zf) throws IOException {\n-        return new Validator(main, zf).validate();\n+    static boolean validate(Main main, ZipFile zf, ZipInputStream zis) throws IOException {\n+        return new Validator(main, zf, zis).validate();\n+    }\n+\n+    \/\/ Detect duplicates when iterate through CEN entries\n+    private void checkDuplicates(ZipEntry e) {\n+        var cenEntryName = e.getName();\n+        if (!cenEntryNames.add(cenEntryName)) {\n+            warn(formatMsg(\"warn.validator.duplicate.cen.entry\", cenEntryName));\n+            isValid = false;\n+        }\n+    }\n+\n+    \/\/ Check any CEN entry is matching the specified name\n+    private boolean checkAnyCenEntry(String locEntryName) {\n+        var hasEntry = cenEntryNames.remove(locEntryName);\n+        if (!hasEntry) {\n+            warn(formatMsg(\"warn.validator.loc.only.entry\", locEntryName));\n+            isValid = false;\n+        }\n+        return hasEntry;\n+    }\n+\n+    \/\/ Check next CEN entry is matching the specified name\n+    private boolean checkNextCenEntry(String locEntryName) {\n+        var nextCenEntryName = cenEntryNames.removeFirst();\n+        if (nextCenEntryName.equals(locEntryName)) {\n+            return true;\n+        }\n+\n+        if (checkAnyCenEntry(locEntryName)) {\n+            warn(getMsg(\"warn.validator.order.mismatch\"));\n+            cenEntryNames.addFirst(nextCenEntryName);\n+            \/\/ order mismatch is just a warning, still consider valid\n+        }\n+        return false;\n+    }\n+\n+    \/*\n+     * Retrieve entries from the XipInputStream to verify local file headers(LOC)\n+     * have same entries as the cental directory(CEN).\n+     *\/\n+    private void checkZipInputStream() {\n+        var locEntryNames = new LinkedHashSet<String>();\n+        var outOfOrder = false;\n+\n+        try {\n+            ZipEntry e;\n+            while ((e = zis.getNextEntry()) != null) {\n+                var locEntryName = e.getName();\n+                if (!locEntryNames.add(locEntryName)) {\n+                    isValid = false;\n+                    warn(formatMsg(\"warn.validator.duplicate.loc.entry\", locEntryName));\n+                    continue;\n+                }\n+\n+                if (outOfOrder) {\n+                    checkAnyCenEntry(locEntryName);\n+                } else {\n+                    outOfOrder = !checkNextCenEntry(locEntryName);\n+                }\n+            }\n+            \/\/ remaining entries in CEN not matching any in LOC\n+            for (var cenEntryName: cenEntryNames) {\n+                warn(formatMsg(\"warn.validator.cen.only.entry\", cenEntryName));\n+            }\n+        } catch (IOException ioe) {\n+           throw new InvalidJarException(ioe.getMessage());\n+        }\n@@ -79,0 +149,1 @@\n+              .peek(this::checkDuplicates)\n@@ -94,0 +165,1 @@\n+            checkZipInputStream();\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Validator.java","additions":78,"deletions":6,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,0 +146,10 @@\n+warn.validator.duplicate.cen.entry=\\\n+        Warning: More than one copy of {0} is detected in central directory\n+warn.validator.duplicate.loc.entry=\\\n+        Warning: More than one copy of {0} is detected in local file header\n+warn.validator.cen.only.entry=\\\n+        Warning: Entry {0} in central directory is not in local file header\n+warn.validator.loc.only.entry=\\\n+        Warning: Entry {0} in local file header is not in central directory\n+warn.validator.order.mismatch=\\\n+        Warning: Central directory and local file header entries are not in the same order\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,298 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8345431\n+ * @summary test validator to report malformed jar file\n+ * @library \/test\/lib\n+ * @modules jdk.jartool\n+ * @build jdk.test.lib.Platform\n+ *        jdk.test.lib.util.FileUtils\n+ * @run junit\/othervm ValidatorTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestInstance.Lifecycle;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.jar.Attributes;\n+import java.util.jar.JarFile;\n+import java.util.jar.Manifest;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+@TestInstance(Lifecycle.PER_CLASS)\n+class ValidatorTest {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jar tool not found\")\n+        );\n+\n+    private final String nl = System.lineSeparator();\n+    private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private final PrintStream jarOut = new PrintStream(baos);\n+\n+    static final Path zip = Path.of(\"MultipleManifestTest.jar\");\n+    static final String jdkVendor = System.getProperty(\"java.vendor\");\n+    static final String jdkVersion = System.getProperty(\"java.version\");\n+    static final String MANIFEST1 = \"Manifest-Version: 1.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    static final String MANIFEST2 = \"Manifest-Version: 2.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    static final String MANIFEST3 = \"Manifest-Version: 3.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    private static final String META_INF = \"META-INF\/\";\n+\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterAll\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Create a JAR with the Manifest as the 1st, 2nd and 4th entry\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @BeforeAll\n+    public void beforeAll() throws IOException {\n+        writeManifestAsFirstSecondAndFourthEntry(zip, true, true);\n+    }\n+\n+    private void writeManifestAsFirstSecondAndFourthEntry(Path path, boolean useCen, boolean useLoc) throws IOException {\n+        int locPosA, locPosB, cenPos;\n+        System.out.printf(\"%n%n*****Creating Jar with the Manifest as the 1st, 2nd and 4th entry*****%n%n\");\n+        var out = new ByteArrayOutputStream(1024);\n+        try (var zos = new ZipOutputStream(out)) {\n+            zos.putNextEntry(new ZipEntry(JarFile.MANIFEST_NAME));\n+            zos.write(MANIFEST1.getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosA = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"AANIFEST.MF\"));\n+            zos.write(MANIFEST2.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zos.write(\"entry1\".getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosB = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"BANIFEST.MF\"));\n+            zos.write(MANIFEST3.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zos.write(\"hello entry2\".getBytes(StandardCharsets.UTF_8));\n+            zos.flush();\n+            cenPos = out.size();\n+        }\n+        var template = out.toByteArray();\n+        \/\/ ISO_8859_1 to keep the 8-bit value\n+        var s = new String(template, StandardCharsets.ISO_8859_1);\n+        \/\/ change META-INF\/AANIFEST.MF to META-INF\/MANIFEST.MF\n+        if (useCen) {\n+            var cen = s.indexOf(\"AANIFEST.MF\", cenPos);\n+            template[cen] = (byte) 'M';\n+            \/\/ change META-INF\/BANIFEST.MF to META-INF\/MANIFEST.MF\n+            cen = s.indexOf(\"BANIFEST.MF\", cenPos);\n+            template[cen] = (byte) 'M';\n+        }\n+        if (useLoc) {\n+            var loc = s.indexOf(\"AANIFEST.MF\", locPosA);\n+            template[loc] = (byte) 'M';\n+            loc = s.indexOf(\"BANIFEST.MF\", locPosB);\n+            template[loc] = (byte) 'M';\n+        }\n+        Files.write(path, template);\n+    }\n+\n+    private void createMismatchOrderJar(Path path) throws IOException {\n+        int locPosA, locPosB;\n+        System.out.printf(\"%n%n*****Creating Jar with the swap entry name*****%n%n\");\n+        var out = new ByteArrayOutputStream(1024);\n+        try (var zos = new ZipOutputStream(out)) {\n+            zos.putNextEntry(new ZipEntry(JarFile.MANIFEST_NAME));\n+            zos.write(MANIFEST1.getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosA = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"AANIFEST.MF\"));\n+            zos.write(MANIFEST2.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zos.write(\"entry1\".getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosB = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"BANIFEST.MF\"));\n+            zos.write(MANIFEST3.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zos.write(\"hello entry2\".getBytes(StandardCharsets.UTF_8));\n+            zos.flush();\n+        }\n+        var template = out.toByteArray();\n+        \/\/ ISO_8859_1 to keep the 8-bit value\n+        var s = new String(template, StandardCharsets.ISO_8859_1);\n+        \/\/ change META-INF\/AANIFEST.MF to META-INF\/BANIFEST.MF\n+        var loc = s.indexOf(\"AANIFEST.MF\", locPosA);\n+        template[loc] = (byte) 'B';\n+        \/\/ change META-INF\/BANIFEST.MF to META-INF\/AANIFEST.MF\n+        loc = s.indexOf(\"BANIFEST.MF\", locPosB);\n+        template[loc] = (byte) 'A';\n+\n+        Files.write(path, template);\n+    }\n+\n+    @AfterEach\n+    public void removeExtractedFiles() {\n+        rm(\"META-INF entry1.txt entry2.txt\");\n+    }\n+\n+    @Test\n+    public void testValidate() {\n+        try {\n+            jar(\"--validate --file \" + zip.toString());\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected in local file header\"));\n+            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected in central directory\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testOnlyLocModified() throws IOException {\n+        Path f = Path.of(\"LocHacked.jar\");\n+        writeManifestAsFirstSecondAndFourthEntry(f, false, true);\n+        try {\n+            jar(\"--validate --file \" + f.toString());\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected in local file header\"));\n+            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/AANIFEST.MF in central directory is not in local file header\"));\n+            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/BANIFEST.MF in central directory is not in local file header\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testOnlyCenModified() throws IOException {\n+        Path f = Path.of(\"CenHacked.jar\");\n+        writeManifestAsFirstSecondAndFourthEntry(f, true, false);\n+        try {\n+            jar(\"--validate --file \" + f.toString());\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected in central directory\"));\n+            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/AANIFEST.MF in local file header is not in central directory\"));\n+            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/BANIFEST.MF in local file header is not in central directory\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testMismatchOrder() throws IOException {\n+        Path f = Path.of(\"SwappedEntry.jar\");\n+        createMismatchOrderJar(f);\n+        try {\n+            String err = jar(\"--validate --file \" + f.toString());\n+            System.out.println(err);\n+            Assertions.assertTrue(err.contains(\"Warning: Central directory and local file header entries are not in the same order\"));\n+        } catch (IOException e) {\n+            Assertions.fail(\"Ordering is not guaranteed by specification\");\n+        }\n+    }\n+\n+    private String getManifestVersion() throws IOException {\n+        try (var is = Files.newInputStream(Path.of(JarFile.MANIFEST_NAME))) {\n+            var manifest = new Manifest(is);\n+            return manifest.getMainAttributes().getValue(Attributes.Name.MANIFEST_VERSION);\n+        }\n+    }\n+\n+    \/\/ return stderr output\n+    private String jar(String cmdline) throws IOException {\n+        System.out.println(\"jar \" + cmdline);\n+        baos.reset();\n+\n+        \/\/ the run method catches IOExceptions, we need to expose them\n+        ByteArrayOutputStream baes = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baes);\n+        PrintStream saveErr = System.err;\n+        System.setErr(err);\n+        try {\n+            int rc = JAR_TOOL.run(jarOut, err, cmdline.split(\" +\"));\n+            if (rc != 0) {\n+                throw new IOException(baes.toString());\n+            } else {\n+                return baes.toString();\n+            }\n+        } finally {\n+            System.setErr(saveErr);\n+        }\n+    }\n+\n+    private void assertOutputContains(String expected) {\n+        Assertions.assertTrue(baos.toString().contains(expected));\n+    }\n+\n+    private void println() throws IOException {\n+        System.out.println(new String(baos.toByteArray()));\n+    }\n+\n+    private Stream<Path> mkpath(String... args) {\n+        return Arrays.stream(args).map(d -> Path.of(\".\", d.split(\"\/\")));\n+    }\n+\n+    private void rm(String cmdline) {\n+        System.out.println(\"rm -rf \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                if (Files.isDirectory(p)) {\n+                    FileUtils.deleteFileTreeWithRetry(p);\n+                } else {\n+                    FileUtils.deleteFileIfExistsWithRetry(p);\n+                }\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jar\/ValidatorTest.java","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"}]}