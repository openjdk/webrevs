{"files":[{"patch":"@@ -35,1 +35,0 @@\n-import java.util.ArrayList;\n@@ -39,0 +38,1 @@\n+import java.util.LinkedHashSet;\n@@ -66,2 +66,1 @@\n-    private final Set<String> entryNames = new HashSet<>();\n-    private final List<String> duplicateEntries = new ArrayList<>();\n+    private final LinkedHashSet<String> cenEntryNames = new LinkedHashSet<>();\n@@ -80,0 +79,1 @@\n+    \/\/ Detect duplicates when iterate through CEN entries\n@@ -81,2 +81,4 @@\n-        if (!entryNames.add(e.getName())) {\n-            duplicateEntries.add(e.getName());\n+        var cenEntryName = e.getName();\n+        if (!cenEntryNames.add(cenEntryName)) {\n+            warn(formatMsg(\"warn.validator.duplicate.cen.entry\", cenEntryName));\n+            isValid = false;\n@@ -86,0 +88,30 @@\n+    \/\/ Check if CEN contains the LOC entry by name\n+    private boolean checkHasCenEntry(String locEntryName) {\n+        var hasEntry = cenEntryNames.remove(locEntryName);\n+        if (!hasEntry) {\n+            warn(formatMsg(\"warn.validator.loc.only.entry\", locEntryName));\n+            isValid = false;\n+        }\n+        return hasEntry;\n+    }\n+\n+    \/\/ Check next CEN entry is matching the specified name\n+    private boolean checkNextCenEntry(String locEntryName) {\n+        var nextCenEntryName = cenEntryNames.removeFirst();\n+        if (nextCenEntryName.equals(locEntryName)) {\n+            return true;\n+        }\n+\n+        if (checkHasCenEntry(locEntryName)) {\n+            warn(getMsg(\"warn.validator.order.mismatch\"));\n+            cenEntryNames.addFirst(nextCenEntryName);\n+            \/\/ order mismatch is just a warning, still consider valid\n+        }\n+        return false;\n+    }\n+\n+\n+    \/*\n+     * Retrieve entries from the XipInputStream to verify local file headers(LOC)\n+     * have same entries as the cental directory(CEN).\n+     *\/\n@@ -87,2 +119,3 @@\n-        var locEntryNames = new HashSet<String>();\n-        var missingEntryNames = new ArrayList<String>();\n+        var locEntryNames = new LinkedHashSet<String>();\n+        var outOfOrder = false;\n+\n@@ -92,2 +125,2 @@\n-                var entryName = e.getName();\n-                if (!locEntryNames.add(entryName)) {\n+                var locEntryName = e.getName();\n+                if (!locEntryNames.add(locEntryName)) {\n@@ -95,1 +128,2 @@\n-                    warn(formatMsg(\"warn.validator.duplicate.entry\", entryName));\n+                    warn(formatMsg(\"warn.validator.duplicate.loc.entry\", locEntryName));\n+                    continue;\n@@ -97,2 +131,5 @@\n-                if (!entryNames.contains(entryName)) {\n-                    missingEntryNames.add(entryName);\n+\n+                if (outOfOrder) {\n+                    checkHasCenEntry(locEntryName);\n+                } else {\n+                    outOfOrder = !checkNextCenEntry(locEntryName);\n@@ -101,3 +138,3 @@\n-            if (!missingEntryNames.isEmpty() || locEntryNames.size() != entryNames.size()) {\n-                isValid = false;\n-                warn(getMsg(\"warn.validator.inconsistent.content\"));\n+            \/\/ remaining entries in CEN not matching any in LOC\n+            for (var cenEntryName: cenEntryNames) {\n+                warn(formatMsg(\"warn.validator.cen.only.entry\", cenEntryName));\n@@ -129,4 +166,0 @@\n-            if (!duplicateEntries.isEmpty()) {\n-                duplicateEntries.forEach(name -> warn(formatMsg(\"warn.validator.duplicate.entry\", name)));\n-                isValid = false;\n-            }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Validator.java","additions":52,"deletions":19,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -146,4 +146,10 @@\n-warn.validator.duplicate.entry=\\\n-        Warning: More than one copy of {0} is detected\n-warn.validator.inconsistent.content=\\\n-        Warning: The list of entries does not match the content\n+warn.validator.duplicate.cen.entry=\\\n+        Warning: More than one copy of {0} is detected in central directory\n+warn.validator.duplicate.loc.entry=\\\n+        Warning: More than one copy of {0} is detected in local file header\n+warn.validator.cen.only.entry=\\\n+        Warning: Entry {0} in central directory is not in local file header\n+warn.validator.loc.only.entry=\\\n+        Warning: Entry {0} in local file header is not in central directory\n+warn.validator.order.mismatch=\\\n+        Warning: Central directory and local file header entries are not in the same order\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8335912 8345431\n+ * @bug 8335912\n@@ -103,5 +103,1 @@\n-    public void beforeAll() throws IOException {\n-        writeManifestAsFirstSecondAndFourthEntry(zip, true, true);\n-    }\n-\n-    private void writeManifestAsFirstSecondAndFourthEntry(Path path, boolean useCen, boolean useLoc) throws IOException {\n+    public void writeManifestAsFirstSecondAndFourthEntry() throws IOException {\n@@ -133,14 +129,8 @@\n-        if (useCen) {\n-            var cen = s.indexOf(\"AANIFEST.MF\", cenPos);\n-            template[cen] = (byte) 'M';\n-            \/\/ change META-INF\/BANIFEST.MF to META-INF\/MANIFEST.MF\n-            cen = s.indexOf(\"BANIFEST.MF\", cenPos);\n-            template[cen] = (byte) 'M';\n-        }\n-        if (useLoc) {\n-            var loc = s.indexOf(\"AANIFEST.MF\", locPosA);\n-            template[loc] = (byte) 'M';\n-            loc = s.indexOf(\"BANIFEST.MF\", locPosB);\n-            template[loc] = (byte) 'M';\n-        }\n-        Files.write(path, template);\n+        var loc = s.indexOf(\"AANIFEST.MF\", locPosA);\n+        var cen = s.indexOf(\"AANIFEST.MF\", cenPos);\n+        template[loc] = template[cen] = (byte) 'M';\n+        \/\/ change META-INF\/BANIFEST.MF to META-INF\/MANIFEST.MF\n+        loc = s.indexOf(\"BANIFEST.MF\", locPosB);\n+        cen = s.indexOf(\"BANIFEST.MF\", cenPos);\n+        template[loc] = template[cen] = (byte) 'M';\n+        Files.write(zip, template);\n@@ -186,39 +176,0 @@\n-    @Test\n-    public void testValidate() {\n-        try {\n-            jar(\"--validate --file \" + zip.toString());\n-        } catch (IOException e) {\n-            var err = e.getMessage();\n-            System.out.println(err);\n-            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected\"));\n-        }\n-    }\n-\n-    @Test\n-    public void testOnlyLocModified() throws IOException {\n-        Path f = Path.of(\"LocHacked.jar\");\n-        writeManifestAsFirstSecondAndFourthEntry(f, false, true);\n-        try {\n-            jar(\"--validate --file \" + f.toString());\n-        } catch (IOException e) {\n-            var err = e.getMessage();\n-            System.out.println(err);\n-            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected\"));\n-            Assertions.assertTrue(err.contains(\"Warning: The list of entries does not match the content\"));\n-        }\n-    }\n-\n-    @Test\n-    public void testOnlyCenModified() throws IOException {\n-        Path f = Path.of(\"CenHacked.jar\");\n-        writeManifestAsFirstSecondAndFourthEntry(f, true, false);\n-        try {\n-            jar(\"--validate --file \" + f.toString());\n-        } catch (IOException e) {\n-            var err = e.getMessage();\n-            System.out.println(err);\n-            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected\"));\n-            Assertions.assertTrue(err.contains(\"Warning: The list of entries does not match the content\"));\n-        }\n-    }\n-\n","filename":"test\/jdk\/tools\/jar\/MultipleManifestTest.java","additions":11,"deletions":60,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -0,0 +1,298 @@\n+\/*\n+ * Copyright (c) 2025, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8345431\n+ * @summary test validator to report malformed jar file\n+ * @library \/test\/lib\n+ * @modules jdk.jartool\n+ * @build jdk.test.lib.Platform\n+ *        jdk.test.lib.util.FileUtils\n+ * @run junit\/othervm ValidatorTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestInstance.Lifecycle;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.jar.Attributes;\n+import java.util.jar.JarFile;\n+import java.util.jar.Manifest;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+@TestInstance(Lifecycle.PER_CLASS)\n+class ValidatorTest {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jar tool not found\")\n+        );\n+\n+    private final String nl = System.lineSeparator();\n+    private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private final PrintStream jarOut = new PrintStream(baos);\n+\n+    static final Path zip = Path.of(\"MultipleManifestTest.jar\");\n+    static final String jdkVendor = System.getProperty(\"java.vendor\");\n+    static final String jdkVersion = System.getProperty(\"java.version\");\n+    static final String MANIFEST1 = \"Manifest-Version: 1.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    static final String MANIFEST2 = \"Manifest-Version: 2.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    static final String MANIFEST3 = \"Manifest-Version: 3.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    private static final String META_INF = \"META-INF\/\";\n+\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterAll\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Create a JAR with the Manifest as the 1st, 2nd and 4th entry\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @BeforeAll\n+    public void beforeAll() throws IOException {\n+        writeManifestAsFirstSecondAndFourthEntry(zip, true, true);\n+    }\n+\n+    private void writeManifestAsFirstSecondAndFourthEntry(Path path, boolean useCen, boolean useLoc) throws IOException {\n+        int locPosA, locPosB, cenPos;\n+        System.out.printf(\"%n%n*****Creating Jar with the Manifest as the 1st, 2nd and 4th entry*****%n%n\");\n+        var out = new ByteArrayOutputStream(1024);\n+        try (var zos = new ZipOutputStream(out)) {\n+            zos.putNextEntry(new ZipEntry(JarFile.MANIFEST_NAME));\n+            zos.write(MANIFEST1.getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosA = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"AANIFEST.MF\"));\n+            zos.write(MANIFEST2.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zos.write(\"entry1\".getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosB = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"BANIFEST.MF\"));\n+            zos.write(MANIFEST3.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zos.write(\"hello entry2\".getBytes(StandardCharsets.UTF_8));\n+            zos.flush();\n+            cenPos = out.size();\n+        }\n+        var template = out.toByteArray();\n+        \/\/ ISO_8859_1 to keep the 8-bit value\n+        var s = new String(template, StandardCharsets.ISO_8859_1);\n+        \/\/ change META-INF\/AANIFEST.MF to META-INF\/MANIFEST.MF\n+        if (useCen) {\n+            var cen = s.indexOf(\"AANIFEST.MF\", cenPos);\n+            template[cen] = (byte) 'M';\n+            \/\/ change META-INF\/BANIFEST.MF to META-INF\/MANIFEST.MF\n+            cen = s.indexOf(\"BANIFEST.MF\", cenPos);\n+            template[cen] = (byte) 'M';\n+        }\n+        if (useLoc) {\n+            var loc = s.indexOf(\"AANIFEST.MF\", locPosA);\n+            template[loc] = (byte) 'M';\n+            loc = s.indexOf(\"BANIFEST.MF\", locPosB);\n+            template[loc] = (byte) 'M';\n+        }\n+        Files.write(path, template);\n+    }\n+\n+    private void createMismatchOrderJar(Path path) throws IOException {\n+        int locPosA, locPosB;\n+        System.out.printf(\"%n%n*****Creating Jar with the swap entry name*****%n%n\");\n+        var out = new ByteArrayOutputStream(1024);\n+        try (var zos = new ZipOutputStream(out)) {\n+            zos.putNextEntry(new ZipEntry(JarFile.MANIFEST_NAME));\n+            zos.write(MANIFEST1.getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosA = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"AANIFEST.MF\"));\n+            zos.write(MANIFEST2.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zos.write(\"entry1\".getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosB = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"BANIFEST.MF\"));\n+            zos.write(MANIFEST3.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zos.write(\"hello entry2\".getBytes(StandardCharsets.UTF_8));\n+            zos.flush();\n+        }\n+        var template = out.toByteArray();\n+        \/\/ ISO_8859_1 to keep the 8-bit value\n+        var s = new String(template, StandardCharsets.ISO_8859_1);\n+        \/\/ change META-INF\/AANIFEST.MF to META-INF\/BANIFEST.MF\n+        var loc = s.indexOf(\"AANIFEST.MF\", locPosA);\n+        template[loc] = (byte) 'B';\n+        \/\/ change META-INF\/BANIFEST.MF to META-INF\/AANIFEST.MF\n+        loc = s.indexOf(\"BANIFEST.MF\", locPosB);\n+        template[loc] = (byte) 'A';\n+\n+        Files.write(path, template);\n+    }\n+\n+    @AfterEach\n+    public void removeExtractedFiles() {\n+        rm(\"META-INF entry1.txt entry2.txt\");\n+    }\n+\n+    @Test\n+    public void testValidate() {\n+        try {\n+            jar(\"--validate --file \" + zip.toString());\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected in local file header\"));\n+            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected in central directory\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testOnlyLocModified() throws IOException {\n+        Path f = Path.of(\"LocHacked.jar\");\n+        writeManifestAsFirstSecondAndFourthEntry(f, false, true);\n+        try {\n+            jar(\"--validate --file \" + f.toString());\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected in local file header\"));\n+            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/AANIFEST.MF in central directory is not in local file header\"));\n+            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/BANIFEST.MF in central directory is not in local file header\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testOnlyCenModified() throws IOException {\n+        Path f = Path.of(\"CenHacked.jar\");\n+        writeManifestAsFirstSecondAndFourthEntry(f, true, false);\n+        try {\n+            jar(\"--validate --file \" + f.toString());\n+        } catch (IOException e) {\n+            var err = e.getMessage();\n+            System.out.println(err);\n+            Assertions.assertTrue(err.contains(\"Warning: More than one copy of META-INF\/MANIFEST.MF is detected in central directory\"));\n+            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/AANIFEST.MF in local file header is not in central directory\"));\n+            Assertions.assertTrue(err.contains(\"Warning: Entry META-INF\/BANIFEST.MF in local file header is not in central directory\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testMismatchOrder() throws IOException {\n+        Path f = Path.of(\"SwappedEntry.jar\");\n+        createMismatchOrderJar(f);\n+        try {\n+            String err = jar(\"--validate --file \" + f.toString());\n+            System.out.println(err);\n+            Assertions.assertTrue(err.contains(\"Warning: Central directory and local file header entries are not in the same order\"));\n+        } catch (IOException e) {\n+            Assertions.fail(\"Ordering is not guaranteed by specification\");\n+        }\n+    }\n+\n+    private String getManifestVersion() throws IOException {\n+        try (var is = Files.newInputStream(Path.of(JarFile.MANIFEST_NAME))) {\n+            var manifest = new Manifest(is);\n+            return manifest.getMainAttributes().getValue(Attributes.Name.MANIFEST_VERSION);\n+        }\n+    }\n+\n+    \/\/ return stderr output\n+    private String jar(String cmdline) throws IOException {\n+        System.out.println(\"jar \" + cmdline);\n+        baos.reset();\n+\n+        \/\/ the run method catches IOExceptions, we need to expose them\n+        ByteArrayOutputStream baes = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baes);\n+        PrintStream saveErr = System.err;\n+        System.setErr(err);\n+        try {\n+            int rc = JAR_TOOL.run(jarOut, err, cmdline.split(\" +\"));\n+            if (rc != 0) {\n+                throw new IOException(baes.toString());\n+            } else {\n+                return baes.toString();\n+            }\n+        } finally {\n+            System.setErr(saveErr);\n+        }\n+    }\n+\n+    private void assertOutputContains(String expected) {\n+        Assertions.assertTrue(baos.toString().contains(expected));\n+    }\n+\n+    private void println() throws IOException {\n+        System.out.println(new String(baos.toByteArray()));\n+    }\n+\n+    private Stream<Path> mkpath(String... args) {\n+        return Arrays.stream(args).map(d -> Path.of(\".\", d.split(\"\/\")));\n+    }\n+\n+    private void rm(String cmdline) {\n+        System.out.println(\"rm -rf \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                if (Files.isDirectory(p)) {\n+                    FileUtils.deleteFileTreeWithRetry(p);\n+                } else {\n+                    FileUtils.deleteFileIfExistsWithRetry(p);\n+                }\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jar\/ValidatorTest.java","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"}]}