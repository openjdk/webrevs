{"files":[{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ *\n+ * Extends the {@code javax.naming} package to provide functionality\n+ * for accessing directory services.\n+ *\n+ * <p>\n+ * This package defines the directory operations of the Java Naming and\n+ * Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ * <p>\n+ * This package allows applications to retrieve and update attributes\n+ * associated with objects stored in a directory, and to search for\n+ * objects using specified attributes.\n+ *\n+ * <h2>The Directory Context<\/h2>\n+ *\n+ * The {@code DirContext}\n+ * interface represents a <em>directory context<\/em>.\n+ * It defines methods for examining and updating attributes associated with a\n+ * <em>directory object<\/em>, or <em>directory entry<\/em> as it is sometimes\n+ * called.\n+ * <p>\n+ * You use {@code getAttributes()} to retrieve the attributes\n+ * associated with a directory object (for which you supply the name).\n+ * Attributes are modified using {@code modifyAttributes()}.\n+ * You can add, replace, or remove attributes and\/or attribute values\n+ * using this operation.\n+ * <p>\n+ * {@code DirContext} also behaves as a naming context\n+ * by extending the {@code Context} interface in the {@code javax.naming} package.\n+ * This means that any directory object can also provide\n+ * a naming context.\n+ * For example, the directory object for a person might contain\n+ * the attributes of that person, and at the same time provide\n+ * a context for naming objects relative to that person\n+ * such as his printers and home directory.\n+ *\n+ * <h3>Searches<\/h3>\n+ * {@code DirContext} contains methods for\n+ * performing content-based searching of the directory.\n+ * In the simplest and most common form of usage, the application\n+ * specifies a set of attributes--possibly with specific\n+ * values--to match, and submits this attribute set, to the\n+ * {@code search()} method.\n+ * There are other overloaded forms of {@code search()}\n+ * that support more sophisticated <em>search filters<\/em>.\n+ *\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI API Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming.directory;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/directory\/package-info.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -1,90 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Extends the <code>javax.naming<\/code> package to provide functionality\n-for accessing directory services.\n-\n-<p>\n-This package defines the directory operations of the Java Naming and\n-Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-<p>\n-This package allows applications to retrieve and update attributes\n-associated with objects stored in a directory, and to search for\n-objects using specified attributes.\n-\n-<h2>The Directory Context<\/h2>\n-\n-The <code>DirContext<\/code>\n-interface represents a <em>directory context<\/em>.\n-It defines methods for examining and updating attributes associated with a\n-<em>directory object<\/em>, or <em>directory entry<\/em> as it is sometimes\n-called.\n-<p>\n-You use\t<code>getAttributes()<\/code> to retrieve the attributes\n-associated with a directory object (for which you supply the name).\n-Attributes are modified using <code>modifyAttributes()<\/code>.\n-You can add, replace, or remove attributes and\/or attribute values\n-using this operation.\n-<p>\n-<code>DirContext<\/code> also behaves as a naming context\n-by extending the <code>Context<\/code> interface in the <code>javax.naming<\/code> package.\n-This means that any directory object can also provide\n-a naming context. \n-For example, the directory object for a person might contain\n-the attributes of that person, and at the same time provide\n-a context for naming objects relative to that person\n-such as his printers and home directory.\n-\n-<h3>Searches<\/h3>\n-<code>DirContext<\/code> contains methods for\n-performing content-based searching of the directory.\n-In the simplest and most common form of usage, the application\n-specifies a set of attributes--possibly with specific\n-values--to match, and submits this attribute set, to the\n-<code>search()<\/code> method.\n-There are other overloaded forms of <code>search()<\/code>\n-that support more sophisticated <em>search filters<\/em>.\n-\n-\n-<h2>Package Specification<\/h2>\n-\n-The JNDI API Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/directory\/package.html","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ *\n+ * Provides support for event notification when accessing naming and\n+ * directory services.\n+ *\n+ * <p>\n+ * This package defines the event notification operations of the Java Naming\n+ * and Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ * <h2>Naming Events<\/h2>\n+ * <p>\n+ * This package defines a {@code NamingEvent} class to represent an event\n+ * that is generated by a naming\/directory service.\n+ * It also defines subinterfaces of {@code Context} and {@code DirContext},\n+ * called {@code EventContext} and {@code EventDirContext},\n+ * through which applications can register their interest in events\n+ * fired by the context.\n+ * <p>\n+ * {@code NamingEvent} represents an event that occurs in a\n+ * naming or directory service. There are two categories of naming events:\n+ * <ul>\n+ * <li>Those that affect the namespace (add\/remove\/rename an object)\n+ * <li>Those that affect the objects' contents.\n+ * <\/ul>\n+ * Each category of events is handled by a corresponding listener:\n+ * {@code NamespaceChangeListener}, {@code ObjectChangeListener}.\n+ * <p>\n+ * An application, for example, can register its interest in changes to\n+ * objects in a context as follows:\n+ * <blockquote>\n+ * {@snippet :\n+ * EventContext src =\n+ *     (EventContext)(new InitialContext()).lookup(\"o=wiz,c=us\");\n+ * src.addNamingListener(\"ou=users\", EventContext.ONELEVEL_SCOPE,\n+ *     new ChangeHandler());\n+ * ...\n+ * class ChangeHandler implements ObjectChangeListener {\n+ *     public void objectChanged(NamingEvent evt) {\n+ *         System.out.println(evt.getNewBinding());\n+ *     }\n+ *     public void namingExceptionThrown(NamingExceptionEvent evt) {\n+ *         System.out.println(evt.getException());\n+ *     }\n+ * }\n+ * }\n+ * <\/blockquote>\n+ *\n+ * <a id=THREADING><\/a>\n+ * <h3>Threading Issues<\/h3>\n+ *\n+ * When an event is dispatched to a listener, the listener method (such\n+ * as {@code objectChanged()}) may be executed in a thread other than the\n+ * one in which the call to {@code addNamingListener()} was executed.\n+ * The choice of which thread to use is made by the service provider.\n+ * When an event is dispatched to multiple listeners, the service provider\n+ * may choose (and is generally encouraged) to execute the listener methods\n+ * concurrently in separate threads.\n+ * <p>\n+ * When a listener instance invokes {@code NamingEvent.getEventContext()},\n+ * it must take into account the possibility that other threads will be\n+ * working with that context concurrently. Likewise, when a listener is\n+ * registered via {@code addNamingListener()}, the registering thread\n+ * must take into account the likely possibility that the service provider\n+ * will later invoke the listeners in newly-created threads. As {@code Context}\n+ * instances are not guaranteed to be thread-safe in general, all context\n+ * operations must be synchronized as needed.\n+ *\n+ * <h3>Exception Handling<\/h3>\n+ *\n+ * When a listener registers for events with a context, the context might\n+ * need to do some internal processing in order to collect information\n+ * required to generate the events. The context, for example, might need\n+ * to make a request to the server to register interest in changes\n+ * on the server that will eventually be translated into events.\n+ * If an exception occurs that prevents information about the events from\n+ * being collected, the listener will never be notified of the events.\n+ * When such an exception occurs, a {@code NamingExceptionEvent} is\n+ * fired to notify the listener. The listener's\n+ * {@code namingExceptionThrown()} method is invoked, as shown in the\n+ * sample code above,\n+ * and the listener is automatically deregistered.\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI API Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming.event;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/event\/package-info.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -1,125 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Provides support for event notification when accessing naming and\n-directory services.\n-\n-<p>\n-This package defines the event notification operations of the Java Naming\n-and Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-<h2>Naming Events<\/h2>\n-<p>\n-This package defines a <code>NamingEvent<\/code> class to represent an event\n-that is generated by a naming\/directory service.\n-It also defines subinterfaces of <code>Context<\/code> and <code>DirContext<\/code>,\n-called <code>EventContext<\/code> and <code>EventDirContext<\/code>,\n-through which applications can register their interest in events\n-fired by the context.\n-<p>\n-<code>NamingEvent<\/code> represents an event that occurs in a \n-naming or directory service. There are two categories of naming events:\n-<ul>\n-<li>Those that affect the namespace (add\/remove\/rename an object)\n-<li>Those that affect the objects' contents.\n-<\/ul>\n-Each category of events is handled by a corresponding listener:\n-<code>NamespaceChangeListener<\/code>, <code>ObjectChangeListener<\/code>.\n-<p>\n-An application, for example, can register its interest in changes to\n-objects in a context as follows:\n-<blockquote>\n-<pre>\n-EventContext src = \n-    (EventContext)(new InitialContext()).lookup(\"o=wiz,c=us\");\n-src.addNamingListener(\"ou=users\", EventContext.ONELEVEL_SCOPE,\n-    new ChangeHandler());\n-...\n-class ChangeHandler implements ObjectChangeListener {\n-    public void objectChanged(NamingEvent evt) {\n-        System.out.println(evt.getNewBinding());\n-    }\n-    public void namingExceptionThrown(NamingExceptionEvent evt) {\n-        System.out.println(evt.getException());\n-    }\n-}\n-<\/pre>\n-<\/blockquote>\n-\n-<a id=THREADING><\/a>\n-<h3>Threading Issues<\/h3>\n-\n-When an event is dispatched to a listener, the listener method (such\n-as <code>objectChanged()<\/code>) may be executed in a thread other than the\n-one in which the call to <code>addNamingListener()<\/code> was executed.\n-The choice of which thread to use is made by the service provider.\n-When an event is dispatched to multiple listeners, the service provider\n-may choose (and is generally encouraged) to execute the listener methods\n-concurrently in separate threads.\n-<p>\n-When a listener instance invokes <code>NamingEvent.getEventContext()<\/code>,\n-it must take into account the possibility that other threads will be\n-working with that context concurrently.  Likewise, when a listener is\n-registered via <code>addNamingListener()<\/code>, the registering thread\n-must take into account the likely possibility that the service provider\n-will later invoke the listeners in newly-created threads.  As <code>Context<\/code>\n-instances are not guaranteed to be thread-safe in general, all context\n-operations must be synchronized as needed.\n-\n-<h3>Exception Handling<\/h3>\n-\n-When a listener registers for events with a context, the context might\n-need to do some internal processing in order to collect information\n-required to generate the events.  The context, for example, might need\n-to make a request to the server to register interest in changes\n-on the server that will eventually be translated into events.\n-If an exception occurs that prevents information about the events from\n-being collected, the listener will never be notified of the events.\n-When such an exception occurs, a <code>NamingExceptionEvent<\/code> is\n-fired to notify the listener. The listener's\n-<code>namingExceptionThrown()<\/code> method is invoked, as shown in the\n-sample code above,\n-and the listener is automatically deregistered.\n-\n-<h2>Package Specification<\/h2>\n-\n-\n-The JNDI API Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/event\/package.html","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ *\n+ * Provides support for LDAPv3 extended operations and controls.\n+ *\n+ * <p>\n+ * This package extends the directory operations of the Java Naming and\n+ * Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ * <p>\n+ * This package is for applications and service providers that deal with\n+ * LDAPv3 extended operations and controls, as defined by\n+ * <a href=http:\/\/www.ietf.org\/rfc\/rfc2251.txt>RFC 2251<\/a>.\n+ * The core interface in this package is {@code LdapContext}, which defines\n+ * methods on a context for performing extended operations and handling\n+ * controls.\n+ *\n+ * <h2>Extended Operations<\/h2>\n+ * <p>\n+ * This package defines the interface {@code ExtendedRequest}\n+ * to represent the argument to an extended operation,\n+ * and the interface {@code ExtendedResponse} to represent the result\n+ * of the extended operation.\n+ * An extended response is always paired with an extended request\n+ * but not necessarily vice versa. That is, you can have an extended request\n+ * that has no corresponding extended response.\n+ * <p>\n+ * An application typically does not deal directly with these interfaces.\n+ * Instead, it deals with classes that <em>implement<\/em> these\n+ * interfaces.\n+ * The application gets these classes either as part of a\n+ * repertoire of extended operations standardized through the IETF, or\n+ * from directory vendors for vendor-specific extended operations.\n+ * The request classes should have constructors that accept\n+ * arguments in a type-safe and user-friendly manner, while the\n+ * response classes should have access methods for getting the data\n+ * of the response in a type-safe and user-friendly manner.\n+ * Internally, the request\/response classes deal with encoding and decoding\n+ * BER values.\n+ * <p>\n+ * For example, suppose an LDAP server supports a \"get time\" extended operation.\n+ * It would supply classes such as\n+ * {@code GetTimeRequest} and {@code GetTimeResponse},\n+ * so that applications can use this feature.\n+ * An application would use these classes as follows:\n+ * {@snippet :\n+ * GetTimeResponse resp =\n+ *     (GetTimeResponse) ectx.extendedOperation(new GetTimeRequest());\n+ * long time = resp.getTime();\n+ * }\n+ * <p>\n+ * The {@code GetTimeRequest} and {@code GetTimeResponse} classes might\n+ * be defined as follows:\n+ * {@snippet :\n+ * public class GetTimeRequest implements ExtendedRequest {\n+ *     \/\/ User-friendly constructor\n+ *     public GetTimeRequest() {\n+ *     };\n+ *\n+ *     \/\/ Methods used by service providers\n+ *     public String getID() {\n+ *         return GETTIME_REQ_OID;\n+ *     }\n+ *     public byte[] getEncodedValue() {\n+ *         return null;  \/\/ no value needed for get time request\n+ *     }\n+ *     public ExtendedResponse createExtendedResponse(\n+ *         String id, byte[] berValue, int offset, int length) throws NamingException {\n+ *         return new GetTimeResponse(id, berValue, offset, length);\n+ *     }\n+ * }\n+ * public class GetTimeResponse implements ExtendedResponse {\n+ *     long time;\n+ *     \/\/ called by GetTimeRequest.createExtendedResponse()\n+ *     public GetTimeResponse(String id, byte[] berValue, int offset, int length)\n+ *         throws NamingException {\n+ *         \/\/ check validity of id\n+ *         long time =  ... \/\/ decode berValue to get time\n+ *     }\n+ *\n+ *     \/\/ Type-safe and User-friendly methods\n+ *     public java.util.Date getDate() { return new java.util.Date(time); }\n+ *     public long getTime() { return time; }\n+ *\n+ *     \/\/ Low level methods\n+ *     public byte[] getEncodedValue() {\n+ *         return \/\/ berValue saved;\n+ *     }\n+ *     public String getID() {\n+ *         return GETTIME_RESP_OID;\n+ *     }\n+ * }\n+ * }\n+ *\n+ * <h2>Controls<\/h2>\n+ *\n+ * This package defines the interface {@code Control} to represent an LDAPv3\n+ * control. It can be a control that is sent to an LDAP server\n+ * (<em>request control<\/em>) or a control returned by an LDAP server\n+ * (<em>response control<\/em>). Unlike extended requests and responses,\n+ * there is not necessarily any pairing between request controls and\n+ * response controls. You can send request controls and expect no\n+ * response controls back, or receive response controls without sending\n+ * any request controls.\n+ * <p>\n+ * An application typically does not deal directly with this interface.\n+ * Instead, it deals with classes that <em>implement<\/em> this interface.\n+ * The application gets control classes either as part of a repertoire of\n+ * controls standardized through the IETF, or from directory vendors for\n+ * vendor-specific controls. The request control classes should have\n+ * constructors that accept arguments in a type-safe and user-friendly\n+ * manner, while the response control classes should have access methods\n+ * for getting the data of the response in a type-safe and user-friendly\n+ * manner. Internally, the request\/response control classes deal with\n+ * encoding and decoding BER values.\n+ * <p>\n+ * For example, suppose an LDAP server supports a \"signed results\"\n+ * request control, which when sent with a request, asks the\n+ * server to digitally sign the results of an operation.\n+ * It would supply a class {@code SignedResultsControl} so that applications\n+ * can use this feature.\n+ * An application would use this class as follows:\n+ * {@snippet :\n+ * Control[] reqCtls = new Control[] {new SignedResultsControl(Control.CRITICAL)};\n+ * ectx.setRequestControls(reqCtls);\n+ * NamingEnumeration enum = ectx.search(...);\n+ * }\n+ * The {@code SignedResultsControl} class might be defined as follows:\n+ * {@snippet :\n+ * public class SignedResultsControl implements Control {\n+ *     \/\/ User-friendly constructor\n+ *     public SignedResultsControl(boolean criticality) {\n+ *  \/\/ assemble the components of the request control\n+ *     };\n+ *\n+ *     \/\/ Methods used by service providers\n+ *     public String getID() {\n+ *         return \/\/ control's object identifier\n+ *     }\n+ *     public byte[] getEncodedValue() {\n+ *         return \/\/ ASN.1 BER encoded control value\n+ *     }\n+ *     ...\n+ * }\n+ * }\n+ * <p>\n+ * When a service provider receives response controls, it uses\n+ * the {@code ControlFactory} class to produce specific classes\n+ * that implement the {@code Control} interface.\n+ * <p>\n+ * An LDAP server can send back response controls with an LDAP operation\n+ * and also with enumeration results, such as those returned\n+ * by a list or search operation.\n+ * The {@code LdapContext} provides a method ({@code getResponseControls()})\n+ * for getting the response controls sent with an LDAP operation,\n+ * while the {@code HasControls} interface is used to retrieve\n+ * response controls associated with enumeration results.\n+ * <p>\n+ * For example, suppose an LDAP server sends back a \"change ID\" control in response\n+ * to a successful modification. It would supply a class {@code ChangeIDControl}\n+ * so that the application can use this feature.\n+ * An application would perform an update, and then try to get the change ID.\n+ * {@snippet :\n+ * \/\/ Perform update\n+ * Context ctx = ectx.createSubsubcontext(\"cn=newobj\");\n+ *\n+ * \/\/ Get response controls\n+ * Control[] respCtls = ectx.getResponseControls();\n+ * if (respCtls != null) {\n+ *     \/\/ Find the one we want\n+ *     for (int i = 0; i < respCtls.length; i++) {\n+ *         if(respCtls[i] instanceof ChangeIDControl) {\n+ *      ChangeIDControl cctl = (ChangeIDControl)respCtls[i];\n+ *      System.out.println(cctl.getChangeID());\n+ *         }\n+ *     }\n+ * }\n+ * }\n+ * The vendor might supply the following {@code ChangeIDControl} and\n+ * {@code VendorXControlFactory} classes. The {@code VendorXControlFactory}\n+ * will be used by the service provider when the provider receives response\n+ * controls from the LDAP server.\n+ * {@snippet :\n+ * public class ChangeIDControl implements Control {\n+ *     long id;\n+ *\n+ *     \/\/ Constructor used by ControlFactory\n+ *     public ChangeIDControl(String OID, byte[] berVal) throws NamingException {\n+ *         \/\/ check validity of OID\n+ *         id = \/\/ extract change ID from berVal\n+ *     };\n+ *\n+ *     \/\/ Type-safe and User-friendly method\n+ *     public long getChangeID() {\n+ *         return id;\n+ *     }\n+ *\n+ *     \/\/ Low-level methods\n+ *     public String getID() {\n+ *         return CHANGEID_OID;\n+ *     }\n+ *     public byte[] getEncodedValue() {\n+ *         return \/\/ original berVal\n+ *     }\n+ *     ...\n+ * }\n+ * public class VendorXControlFactory extends ControlFactory {\n+ *     public VendorXControlFactory () {\n+ *     }\n+ *\n+ *     public Control getControlInstance(Control orig) throws NamingException {\n+ *         if (isOneOfMyControls(orig.getID())) {\n+ *      ...\n+ *\n+ *      \/\/ determine which of ours it is and call its constructor\n+ *      return (new ChangeIDControl(orig.getID(), orig.getEncodedValue()));\n+ *  }\n+ *         return null;  \/\/ not one of ours\n+ *     }\n+ * }\n+ * }\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI API Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming.ldap;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/ldap\/package-info.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -1,266 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n- \n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Provides support for LDAPv3 extended operations and controls.\n-\n-<p>\n-This package extends the directory operations of the Java Naming and\n-Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-<p>\n-This package is for applications and service providers that deal with\n-LDAPv3 extended operations and controls, as defined by\n-<a href=http:\/\/www.ietf.org\/rfc\/rfc2251.txt>RFC 2251<\/a>.\n-The core interface in this package is <code>LdapContext<\/code>, which defines\n-methods on a context for performing extended operations and handling\n-controls.\n-\n-<h2>Extended Operations<\/h2>\n-<p>\n-This package defines the interface <code>ExtendedRequest<\/code>\n-to represent the argument to an extended operation,\n-and the interface <code>ExtendedResponse<\/code> to represent the result\n-of the extended operation.\n-An extended response is always paired with an extended request\n-but not necessarily vice versa. That is, you can have an extended request\n-that has no corresponding extended response.\n-<p>\n-An application typically does not deal directly with these interfaces.\n-Instead, it deals with classes that <em>implement<\/em> these\n-interfaces.  \n-The application gets these classes either as part of a\n-repertoire of extended operations standardized through the IETF, or\n-from directory vendors for vendor-specific extended operations.\n-The request classes should have constructors that accept\n-arguments in a type-safe and user-friendly manner, while the\n-response classes should have access methods for getting the data\n-of the response in a type-safe and user-friendly manner.\n-Internally, the request\/response classes deal with encoding and decoding\n-BER values.\n-<p>\n-For example, suppose an LDAP server supports a \"get time\" extended operation.\n-It would supply classes such as\n-<code>GetTimeRequest<\/code> and <code>GetTimeResponse<\/code>,\n-so that applications can use this feature.\n-An application would use these classes as follows:\n-<blockquote><pre>\n-GetTimeResponse resp =\n-    (GetTimeResponse) ectx.extendedOperation(new GetTimeRequest());\n-long time = resp.getTime();\n-<\/pre><\/blockquote>\n-<p>\n-The <code>GetTimeRequest<\/code> and <code>GetTimeResponse<\/code> classes might\n-be defined as follows:\n-<blockquote><pre>\n-public class GetTimeRequest implements ExtendedRequest {\n-    \/\/ User-friendly constructor \n-    public GetTimeRequest() {\n-    };\n-\n-    \/\/ Methods used by service providers\n-    public String getID() {\n-        return GETTIME_REQ_OID;\n-    }\n-    public byte[] getEncodedValue() {\n-        return null;  \/\/ no value needed for get time request\n-    }\n-    public ExtendedResponse createExtendedResponse(\n-        String id, byte[] berValue, int offset, int length) throws NamingException {\n-        return new GetTimeResponse(id, berValue, offset, length);\n-    }\n-}\n-public class GetTimeResponse() implements ExtendedResponse {\n-    long time;\n-    \/\/ called by GetTimeRequest.createExtendedResponse()\n-    public GetTimeResponse(String id, byte[] berValue, int offset, int length)\n-        throws NamingException {\n-        \/\/ check validity of id\n-        long time =  ... \/\/ decode berValue to get time\n-    }\n-\n-    \/\/ Type-safe and User-friendly methods\n-    public java.util.Date getDate() { return new java.util.Date(time); }\n-    public long getTime() { return time; }\n-\n-    \/\/ Low level methods\n-    public byte[] getEncodedValue() {\n-        return \/\/ berValue saved;\n-    }\n-    public String getID() {\n-        return GETTIME_RESP_OID;\n-    }\n-}\n-<\/pre><\/blockquote>\n-\n-<h2>Controls<\/h2>\n-\n-This package defines the interface <code>Control<\/code> to represent an LDAPv3\n-control. It can be a control that is sent to an LDAP server\n-(<em>request control<\/em>) or a control returned by an LDAP server\n-(<em>response control<\/em>).  Unlike extended requests and responses,\n-there is not necessarily any pairing between request controls and\n-response controls.  You can send request controls and expect no\n-response controls back, or receive response controls without sending\n-any request controls.\n-<p>\n-An application typically does not deal directly with this interface.\n-Instead, it deals with classes that <em>implement<\/em> this interface.\n-The application gets control classes either as part of a repertoire of\n-controls standardized through the IETF, or from directory vendors for\n-vendor-specific controls.  The request control classes should have\n-constructors that accept arguments in a type-safe and user-friendly\n-manner, while the response control classes should have access methods\n-for getting the data of the response in a type-safe and user-friendly\n-manner.  Internally, the request\/response control classes deal with\n-encoding and decoding BER values.\n-<p>\n-For example, suppose an LDAP server supports a \"signed results\"\n-request control, which when sent with a request, asks the\n-server to digitally sign the results of an operation.\n-It would supply a class <code>SignedResultsControl<\/code>  so that applications\n-can use this feature.\n-An application  would use this class as follows:\n-<blockquote>\n-<pre>\n-Control[] reqCtls = new Control[] {new SignedResultsControl(Control.CRITICAL)};\n-ectx.setRequestControls(reqCtls);\n-NamingEnumeration enum = ectx.search(...);\n-<\/pre>\n-<\/blockquote>\n-The <code>SignedResultsControl<\/code> class might be defined as follows:\n-<blockquote><pre>\n-public class SignedResultsControl implements Control {\n-    \/\/ User-friendly constructor \n-    public SignedResultsControl(boolean criticality) {\n-\t\/\/ assemble the components of the request control\n-    };\n-\n-    \/\/ Methods used by service providers\n-    public String getID() {\n-        return \/\/ control's object identifier\n-    }\n-    public byte[] getEncodedValue() {\n-        return \/\/ ASN.1 BER encoded control value\n-    }\n-    ...\n-}\n-<\/pre><\/blockquote>\n-<p>\n-When a service provider receives response controls, it uses\n-the <code>ControlFactory<\/code> class to produce specific classes\n-that implement the <code>Control<\/code> interface.\n-<p>\n-An LDAP server can send back response controls with an LDAP operation\n-and also with enumeration results, such as those returned\n-by a list or search operation.\n-The <code>LdapContext<\/code> provides a method (<code>getResponseControls()<\/code>)\n-for getting the response controls sent with an LDAP operation,\n-while the <code>HasControls<\/code> interface is used to retrieve\n-response controls associated with enumeration results.\n-<p>\n-For example, suppose an LDAP server sends back a \"change ID\" control in response\n-to a successful modification. It would supply a class <code>ChangeIDControl<\/code>\n-so that the application can use this feature.\n-An application would perform an update, and then try to get the change ID.\n-<blockquote><pre>\n-\/\/ Perform update\n-Context ctx = ectx.createSubsubcontext(\"cn=newobj\");\n-\n-\/\/ Get response controls\n-Control[] respCtls = ectx.getResponseControls();\n-if (respCtls != null) {\n-    \/\/ Find the one we want\n-    for (int i = 0; i &lt; respCtls; i++) {\n-        if(respCtls[i] instanceof ChangeIDControl) {\n-\t    ChangeIDControl cctl = (ChangeIDControl)respCtls[i];\n-\t    System.out.println(cctl.getChangeID());\n-        }\n-    }\n-}\n-<\/pre><\/blockquote>\n-The vendor might supply the following <code>ChangeIDControl<\/code> and\n-<code>VendorXControlFactory<\/code> classes. The <code>VendorXControlFactory<\/code>\n-will be used by the service provider when the provider receives response\n-controls from the LDAP server.\n-<blockquote><pre>\n-public class ChangeIDControl implements Control {\n-    long id;\n-\n-    \/\/ Constructor used by ControlFactory\n-    public ChangeIDControl(String OID, byte[] berVal) throws NamingException {\n-        \/\/ check validity of OID\n-        id = \/\/ extract change ID from berVal\n-    };\n-\n-    \/\/ Type-safe and User-friendly method\n-    public long getChangeID() {\n-        return id;\n-    }\n-\n-    \/\/ Low-level methods\n-    public String getID() {\n-        return CHANGEID_OID;\n-    }\n-    public byte[] getEncodedValue() {\n-        return \/\/ original berVal\n-    }\n-    ...\n-}\n-public class VendorXControlFactory extends ControlFactory {\n-    public VendorXControlFactory () {\n-    }\n-\n-    public Control getControlInstance(Control orig) throws NamingException {\n-        if (isOneOfMyControls(orig.getID())) {\n-\t    ...\n-\n-\t    \/\/ determine which of ours it is and call its constructor\n-\t    return (new ChangeIDControl(orig.getID(), orig.getEncodedValue()));\n-\t}\n-        return null;  \/\/ not one of ours\n-    }\n-}\n-<\/pre><\/blockquote>\n-\n-<h2>Package Specification<\/h2>\n-\n-The JNDI API Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/ldap\/package.html","additions":0,"deletions":266,"binary":false,"changes":266,"status":"deleted"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ *\n+ * Provides the Service Provider Interface for DNS lookups when\n+ * performing LDAP operations.\n+ *\n+ * @since 12\n+ *\/\n+package javax.naming.ldap.spi;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/ldap\/spi\/package-info.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides the classes and interfaces for accessing naming services.\n+ *\n+ * <p>\n+ * This package defines the naming operations of the Java Naming and\n+ * Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ *\n+ * <h2>Context<\/h2>\n+ * <p>\n+ * This package defines the notion of a <em>context<\/em>, represented\n+ * by the {@code Context} interface.\n+ * A context consists of a set of name-to-object <em>bindings<\/em>.\n+ * {@code Context} is the core interface for looking up, binding, unbinding,\n+ * and renaming objects, and for creating and destroying subcontexts.\n+ * <p>\n+ * {@code lookup()} is the most commonly used operation.\n+ * You supply {@code lookup()}\n+ * the name of the object you want\n+ * to look up, and it returns the object bound to that name.\n+ * For example, the following code fragment looks up\n+ * a printer and sends a document to the printer object\n+ * to be printed:\n+ *\n+ * {@snippet :\n+ * Printer printer = (Printer)ctx.lookup(\"treekiller\");\n+ * printer.print(report);\n+ * }\n+ *\n+ * <h2>Names<\/h2>\n+ * <p>\n+ * Every naming method in the {@code Context}\n+ * interface has two\n+ * overloads: one that accepts a\n+ * {@code Name} argument and one that accepts a string name.\n+ * {@code Name} is an interface that represents a generic\n+ * name--an ordered sequence of zero of more components.\n+ * For these methods, {@code Name} can be used to represent a\n+ * <em>composite name<\/em> ({@code CompositeName})\n+ * so that you can name an object using a name which spans multiple namespaces.\n+ * <p>\n+ * The overloads that accept {@code Name}\n+ * are useful for applications that need to manipulate names: composing\n+ * them, comparing components, and so on.\n+ * The overloads that accept string names are likely to be more useful\n+ * for simple applications, such as those that simply read in a name\n+ * and look up the corresponding object.\n+ *\n+ * <h2>Bindings<\/h2>\n+ *\n+ * The {@code Binding} class represents a name-to-object binding.\n+ * It is a tuple containing the name of the bound object,\n+ * the name of the object's class, and the object itself.\n+ * <p>\n+ * The {@code Binding} class is actually a subclass of\n+ * {@code NameClassPair}, which consists\n+ * simply of the object's name and the object's class name.\n+ * The {@code NameClassPair} is useful when you only want\n+ * information about the object's class and do not want to\n+ * pay the extra cost of getting the object.\n+ *\n+ * <h2>References<\/h2>\n+ * Objects are stored in naming and directory services in different ways.\n+ * If an object store supports storing Java objects,\n+ * it might support storing an object in its serialized form.\n+ * However, some naming and directory services do not support the\n+ * storing of Java objects. Furthermore, for some\n+ * objects in the directory, Java programs are but one group of applications\n+ * that access them. In this case, a serialized Java object might\n+ * not be the most appropriate representation.\n+ * JNDI defines a <em>reference<\/em>, represented by the {@code Reference}\n+ * class, which contains information on how to construct a copy of the object.\n+ * JNDI will attempt to turn references looked up from the directory\n+ * into the Java objects they represent, so that\n+ * JNDI clients have the illusion that what\n+ * is stored in the directory are Java objects.\n+ *\n+ *\n+ * <h2>The Initial Context<\/h2>\n+ *\n+ * In JNDI, all naming and directory operations are performed relative\n+ * to a context. There are no absolute roots.\n+ * Therefore JNDI defines an <em>initial context<\/em>,\n+ * {@code InitialContext},\n+ * which provides a starting point for naming and directory operations.\n+ * Once you have an initial context, you can use it to\n+ * look up other contexts and objects.\n+ *\n+ * <h2>Exceptions<\/h2>\n+ *\n+ * JNDI defines a class hierarchy for exceptions that can be thrown in\n+ * the course of performing naming and directory operations. The root of\n+ * this class hierarchy is {@code NamingException}.\n+ * Programs interested in dealing with a particular exception\n+ * can catch the corresponding subclass of the exception.\n+ * Otherwise, programs should catch {@code NamingException}.\n+ *\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI API Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/package-info.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -1,143 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Provides the classes and interfaces for accessing naming services.\n-\n-<p>\n-This package defines the naming operations of the Java Naming and\n-Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-\n-<h2>Context<\/h2>\n-<p>\n-This package defines the notion of a <em>context<\/em>, represented\n-by the <code>Context<\/code> interface.\n-A context consists of a set of name-to-object <em>bindings<\/em>.\n-<code>Context<\/code> is the core interface for looking up, binding, unbinding,\n-and renaming objects, and for creating and destroying subcontexts.\n-<p>\n-<code>lookup()<\/code> is the most commonly used operation.\n-You supply <code>lookup()<\/code>\n-the name of the object you want\n-to look up, and it returns the object bound to that name.\n-For example, the following code fragment looks up \n-a printer and sends a document to the printer object\n-to be printed:\n-\n-<blockquote>\n-<pre>\n-Printer printer = (Printer)ctx.lookup(\"treekiller\");\n-printer.print(report);\n-<\/pre>\n-<\/blockquote>\n-\n-<h2>Names<\/h2>\n-<p>\n-Every naming method in the <code>Context<\/code>\n-interface has two\n-overloads: one that accepts a \n-<code>Name<\/code> argument and one that accepts a string name.\n-<code>Name<\/code> is an interface that represents a generic \n-name--an ordered sequence of zero of more components.\n-For these methods, <code>Name<\/code> can be used to represent a\n-<em>composite name<\/em> (<code>CompositeName<\/code>)\n-so that you can name an object using a name which spans multiple namespaces.\n-<p>\n-The overloads that accept <code>Name<\/code>\n-are useful for applications that need to manipulate names: composing\n-them, comparing components, and so on.\n-The overloads that accept string names are likely to be more useful\n-for simple applications, such as those that simply read in a name\n-and look up the corresponding object.\n-\n-<h2>Bindings<\/h2>\n-\n-The <code>Binding<\/code> class represents a name-to-object binding.\n-It is a tuple containing the name of the bound object,\n-the name of the object's class, and the object itself.\n-<p>\n-The <code>Binding<\/code> class is actually a subclass of\n-<code>NameClassPair<\/code>, which consists\n-simply of the object's name and the object's class name.\n-The <code>NameClassPair<\/code> is useful when you only want\n-information about the object's class and do not want to\n-pay the extra cost of getting the object.\n-\n-<h2>References<\/h2>\n-Objects are stored in naming and directory services in different ways.\n-If an object store supports storing Java objects, \n-it might support storing an object in its serialized form.\n-However, some naming and directory services do not support the\n-storing of Java objects. Furthermore, for some\n-objects in the directory, Java programs are but one group of applications \n-that access them. In this case, a serialized Java object might\n-not be the most appropriate representation.\n-JNDI defines a <em>reference<\/em>, represented by the <code>Reference<\/code>\n-class, which contains information on how to construct a copy of the object.\n-JNDI will attempt to turn references looked up from the directory\n-into the Java objects they represent, so that\n-JNDI clients have the illusion that what\n-is stored in the directory are Java objects. \n-\n-\n-<h2>The Initial Context<\/h2>\n-\n-In JNDI, all naming and directory operations are performed relative\n-to a context. There are no absolute roots.\n-Therefore JNDI defines an <em>initial context<\/em>, \n-<code>InitialContext<\/code>,\n-which provides a starting point for naming and directory operations.\n-Once you have an initial context, you can use it to\n-look up other contexts and objects.\n-\n-<h2>Exceptions<\/h2>\n-\n-JNDI defines a class hierarchy for exceptions that can be thrown in\n-the course of performing naming and directory operations.  The root of\n-this class hierarchy is <code>NamingException<\/code>.\n-Programs interested in dealing with a particular exception\n-can catch the corresponding subclass of the exception.\n-Otherwise, programs should catch <code>NamingException<\/code>.\n-\n-\n-<h2>Package Specification<\/h2>\n-\n-The JNDI API Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/package.html","additions":0,"deletions":143,"binary":false,"changes":143,"status":"deleted"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides the means for dynamically plugging in support for accessing\n+ * naming and directory services through the {@code javax.naming}\n+ * and related packages.\n+ *\n+ * <p>\n+ * This package defines the service provider interface (SPI) of the Java Naming\n+ * and Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ * <p>\n+ * The JNDI SPI provides the means for creating JNDI service providers,\n+ * through which JNDI applications access different naming and\n+ * directory services.\n+ *\n+ *\n+ * <h2>Plug-in Architecture<\/h2>\n+ *\n+ * The service provider package allows different implementations to be plugged in\n+ * dynamically.\n+ * These different implementations include those for the\n+ * <em>initial context<\/em>,\n+ * and implementations for contexts that can be reached\n+ * from the initial context.\n+ *\n+ * <h2>Java Object Support<\/h2>\n+ *\n+ * The service provider package provides support\n+ * for implementors of the\n+ * {@code javax.naming.Context.lookup()}\n+ * method and related methods to return Java objects that are natural\n+ * and intuitive for the Java programmer.\n+ * For example, when looking up a printer name from the directory,\n+ * it is natural for you to expect to get\n+ * back a printer object on which to operate.\n+ *\n+ *\n+ * <h2>Multiple Naming Systems (Federation)<\/h2>\n+ *\n+ * JNDI operations allow applications to supply names that span multiple\n+ * naming systems. So in the process of completing\n+ * an operation, one service provider might need to interact\n+ * with another service provider, for example, to pass on\n+ * the operation to be continued in the next naming system.\n+ * The service provider package provides support for\n+ * different providers to cooperate to complete JNDI operations.\n+ *\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI SPI Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming.spi;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/spi\/package-info.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -1,90 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Provides the means for dynamically plugging in support for accessing\n-naming and directory services through the <code>javax.naming<\/code>\n-and related packages.\n-\n-<p>\n-This package defines the service provider interface (SPI) of the Java Naming\n-and Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-<p>\n-The JNDI SPI provides the means for creating JNDI service providers,\n-through which JNDI applications access different naming and\n-directory services.\n-\n-\n-<h2>Plug-in Architecture<\/h2>\n-\n-The service provider package allows different implementations to be plugged in\n-dynamically.\n-These different implementations include those for the\n-<em>initial context<\/em>,\n-and implementations for contexts that can be reached \n-from the initial context.\n-\n-<h2>Java Object Support<\/h2>\n-\n-The service provider package provides support\n-for implementors of the\n-<code>javax.naming.Context.lookup()<\/code>\n-method and related methods to return Java objects that are natural\n-and intuitive for the Java programmer.\n-For example, when looking up a printer name from the directory,\n-it is natural for you to expect to get\n-back a printer object on which to operate.\n-\n-\n-<h2>Multiple Naming Systems (Federation)<\/h2>\n-\n-JNDI operations allow applications to supply names that span multiple\n-naming systems.  So in the process of completing\n-an operation, one service provider might need to interact\n-with another service provider, for example, to pass on\n-the operation to be continued in the next naming system.\n-The service provider package provides support for\n-different providers to cooperate to complete JNDI operations.\n-\n-\n-<h2>Package Specification<\/h2>\n-\n-The JNDI SPI Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/spi\/package.html","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"}]}