{"files":[{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.invoke;\n+\n+import jdk.internal.misc.VM;\n+import sun.security.action.GetBooleanAction;\n+import sun.security.action.GetPropertyAction;\n+import sun.util.logging.PlatformLogger;\n+\n+import java.io.FilePermission;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Objects;\n+import java.util.PropertyPermission;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/**\n+ * Helper class to log normal and hidden classes defined via Lookup API\n+ *\n+ * @implNote\n+ * <p> Because this class is called by MethodHandleStatics, LambdaForms generation\n+ * and LambdaMetafactory, make use of lambda lead to recursive calls cause stack overflow.\n+ *\/\n+final class ClassFileDumper {\n+    private static final char[] HEX = {\n+        '0', '1', '2', '3', '4', '5', '6', '7',\n+        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n+    };\n+    private static final char[] BAD_CHARS = {\n+        '\\\\', ':', '*', '?', '\"', '<', '>', '|'\n+    };\n+    private static final String[] REPLACEMENT = {\n+        \"%5C\", \"%3A\", \"%2A\", \"%3F\", \"%22\", \"%3C\", \"%3E\", \"%7C\"\n+    };\n+\n+    private static final ConcurrentHashMap<String, ClassFileDumper> DUMPER_MAP\n+            = new ConcurrentHashMap<>();\n+\n+    \/**\n+     * Returns a ClassFileDumper instance for the given key.  To enable\n+     * dumping of the generated classes, set the system property via\n+     * -D<key>=<path>.\n+     *\n+     * The system property is read only once when it is the first time\n+     * the dumper instance for the given key is created.\n+     *\n+     * If not enabled, this method returns ClassFileDumper with null\n+     * dump path.\n+     *\/\n+    public static ClassFileDumper getInstance(String key) {\n+        Objects.requireNonNull(key);\n+\n+        var dumper = DUMPER_MAP.get(key);\n+        if (dumper == null) {\n+            String path = GetPropertyAction.privilegedGetProperty(key);\n+            Path dir;\n+            if (path == null || path.trim().isEmpty()) {\n+                dir = null;\n+            } else {\n+                dir = validateDumpDir(Path.of(path.trim()));\n+            }\n+            var newDumper = new ClassFileDumper(key, dir);\n+            var v = DUMPER_MAP.putIfAbsent(key, newDumper);\n+            dumper = v != null ? v : newDumper;\n+        }\n+        return dumper;\n+    }\n+\n+    \/**\n+     * Returns a ClassFileDumper instance for the given key with a given\n+     * dump path. To enable dumping of the generated classes, -D<key>=true.\n+     *\n+     * The system property is read only once when it is the first time\n+     * the dumper instance for the given key is created.\n+     *\n+     * If not enabled, this method returns ClassFileDumper with null\n+     * dump path.\n+     *\/\n+    public static ClassFileDumper getInstance(String key, Path path) {\n+        Objects.requireNonNull(key);\n+        Objects.requireNonNull(path);\n+\n+        var dumper = DUMPER_MAP.get(key);\n+        if (dumper == null) {\n+            boolean enabled = GetBooleanAction.privilegedGetProperty(key);\n+            Path dir = enabled ? validateDumpDir(path) : null;\n+            var newDumper = new ClassFileDumper(key, dir);\n+            var v = DUMPER_MAP.putIfAbsent(key, newDumper);\n+            dumper = v != null ? v : newDumper;\n+        }\n+\n+        if (dumper.isEnabled() && !path.equals(dumper.dumpPath())) {\n+            throw new IllegalArgumentException(\"mismatched dump path for \" + key);\n+        }\n+        return dumper;\n+    }\n+\n+    private final String key;\n+    private final Path dumpDir;\n+    private final AtomicInteger counter = new AtomicInteger();\n+\n+    private ClassFileDumper(String key, Path path) {\n+        this.key = key;\n+        this.dumpDir = path;\n+    }\n+\n+    public String key() {\n+        return key;\n+    }\n+    public boolean isEnabled() {\n+        return dumpDir != null;\n+    }\n+\n+    public Path dumpPath() {\n+        return dumpDir;\n+    }\n+\n+    public int incrementAndGetCounter() {\n+        return counter.incrementAndGet();\n+    }\n+\n+    public Path pathname(String internalName) {\n+        return dumpDir.resolve(encodeForFilename(internalName) + \".class\");\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    public void dumpClass(String internalName, final byte[] classBytes) {\n+        if (!isEnabled()) return;\n+\n+        AccessController.doPrivileged(new PrivilegedAction<>() {\n+                @Override public Void run() {\n+                    Path file = pathname(internalName);\n+                    try {\n+                        Path dir = file.getParent();\n+                        Files.createDirectories(dir);\n+                        Files.write(file, classBytes);\n+                    } catch (Exception ignore) {\n+                        if (VM.isModuleSystemInited()) {\n+                            \/\/ log only when lambda is ready to use\n+                            System.getLogger(ClassFileDumper.class.getName())\n+                                  .log(System.Logger.Level.WARNING, \"Exception writing to path at \" + file.toString());\n+                        }\n+                        \/\/ simply don't care if this operation failed\n+                    }\n+                    return null;\n+                }},\n+                null,\n+                new FilePermission(\"<<ALL FILES>>\", \"read, write\"),\n+                \/\/ createDirectories may need it\n+                new PropertyPermission(\"user.dir\", \"read\"));\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static Path validateDumpDir(Path path) {\n+            return AccessController.doPrivileged(new PrivilegedAction<>() {\n+                @Override\n+                public Path run() {\n+                    if (!Files.exists(path)) {\n+                        try {\n+                            Files.createDirectory(path);\n+                        } catch (IOException ex) {\n+                            throw new UncheckedIOException(\"Fail to create \" + path + \" - dumping disabled\", ex);\n+                        }\n+                    }\n+                    if (!Files.isDirectory(path)) {\n+                        throw new IllegalArgumentException(\"Path \" + path + \" is not a directory\" + \" - dumping disabled\");\n+                    } else if (!Files.isWritable(path)) {\n+                        throw new IllegalArgumentException(\"Directory \" + path + \" is not writable\" + \" - dumping disabled\");\n+                    }\n+                    return path;\n+                }\n+            });\n+    }\n+\n+\n+    private static String encodeForFilename(String className) {\n+        final int len = className.length();\n+        StringBuilder sb = new StringBuilder(len);\n+\n+        for (int i = 0; i < len; i++) {\n+            char c = className.charAt(i);\n+            \/\/ control characters\n+            if (c <= 31) {\n+                sb.append('%');\n+                sb.append(HEX[c >> 4 & 0x0F]);\n+                sb.append(HEX[c & 0x0F]);\n+            } else {\n+                int j = 0;\n+                for (; j < BAD_CHARS.length; j++) {\n+                    if (c == BAD_CHARS[j]) {\n+                        sb.append(REPLACEMENT[j]);\n+                        break;\n+                    }\n+                }\n+                if (j >= BAD_CHARS.length) {\n+                    sb.append(c);\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassFileDumper.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.access.SharedSecrets;\n@@ -39,3 +38,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.security.ProtectionDomain;\n@@ -573,16 +569,3 @@\n-\n-            \/\/ load class\n-            InvokerBytecodeGenerator.maybeDump(classBCName(className), classFile);\n-            ClassLoader cl = topClass.getClassLoader();\n-            ProtectionDomain pd = null;\n-            if (cl != null) {\n-                pd = AccessController.doPrivileged(\n-                        new PrivilegedAction<>() {\n-                            @Override\n-                            public ProtectionDomain run() {\n-                                return topClass().getProtectionDomain();\n-                            }\n-                        });\n-            }\n-            Class<?> speciesCode = SharedSecrets.getJavaLangAccess()\n-                    .defineClass(cl, className, classFile, pd, \"_ClassSpecializer_generateConcreteSpeciesCode\");\n+            var lookup = new MethodHandles.Lookup(topClass);\n+            Class<?> speciesCode = lookup.makeClassDefiner(classBCName(className), classFile, DUMP_CLASS_FILES)\n+                                         .defineClass(false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -38,1 +37,0 @@\n-import java.lang.invoke.MethodHandles.Lookup;\n@@ -92,1 +90,1 @@\n-    private static final ProxyClassesDumper dumper;\n+    private static final ClassFileDumper dumper;\n@@ -101,3 +99,1 @@\n-        String dumpPath = GetPropertyAction.privilegedGetProperty(dumpProxyClassesKey);\n-        dumper = (null == dumpPath) ? null : ProxyClassesDumper.getInstance(dumpPath);\n-\n+        dumper = ClassFileDumper.getInstance(dumpProxyClassesKey);\n@@ -366,26 +362,4 @@\n-            Lookup lookup = null;\n-            try {\n-                if (useImplMethodHandle) {\n-                    lookup = caller.defineHiddenClassWithClassData(classBytes, implementation, !disableEagerInitialization,\n-                                                                   NESTMATE, STRONG);\n-                } else {\n-                    lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);\n-                }\n-                return lookup.lookupClass();\n-            } finally {\n-                \/\/ If requested, dump out to a file for debugging purposes\n-                if (dumper != null) {\n-                    String name;\n-                    if (lookup != null) {\n-                        String definedName = lookup.lookupClass().getName();\n-                        int suffixIdx = definedName.lastIndexOf('\/');\n-                        assert suffixIdx != -1;\n-                        name = lambdaClassName + '.' + definedName.substring(suffixIdx + 1);\n-                    } else {\n-                        name = lambdaClassName + \".failed-\" + counter.incrementAndGet();\n-                    }\n-                    doDump(name, classBytes);\n-                }\n-            }\n-        } catch (IllegalAccessException e) {\n-            throw new LambdaConversionException(\"Exception defining lambda proxy class\", e);\n+            var classdata = useImplMethodHandle? implementation : null;\n+            return caller.makeHiddenClassDefiner(lambdaClassName, classBytes, Set.of(NESTMATE, STRONG), dumper)\n+                         .defineClass(!disableEagerInitialization, classdata);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":6,"deletions":32,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-        if (DUMP_CLASS_FILES) {\n+        if (dumpClassEnabled()) {\n@@ -177,2 +177,0 @@\n-    \/** debugging flag for saving generated class files *\/\n-    private static final File DUMP_CLASS_FILES_DIR;\n@@ -181,1 +179,1 @@\n-        if (DUMP_CLASS_FILES) {\n+        if (dumpClassEnabled()) {\n@@ -183,10 +181,1 @@\n-            try {\n-                File dumpDir = new File(\"DUMP_CLASS_FILES\");\n-                if (!dumpDir.exists()) {\n-                    dumpDir.mkdirs();\n-                }\n-                DUMP_CLASS_FILES_DIR = dumpDir;\n-                System.out.println(\"Dumping class files to \"+DUMP_CLASS_FILES_DIR+\"\/...\");\n-            } catch (Exception e) {\n-                throw newInternalError(e);\n-            }\n+            System.out.println(\"Dumping class files to \" + DUMP_CLASS_FILES.dumpPath() + \"\/...\");\n@@ -195,31 +184,0 @@\n-            DUMP_CLASS_FILES_DIR = null;\n-        }\n-    }\n-\n-    private void maybeDump(final byte[] classFile) {\n-        if (DUMP_CLASS_FILES) {\n-            maybeDump(className, classFile);\n-        }\n-    }\n-\n-    \/\/ Also used from BoundMethodHandle\n-    @SuppressWarnings(\"removal\")\n-    static void maybeDump(final String className, final byte[] classFile) {\n-        if (DUMP_CLASS_FILES) {\n-            java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<>() {\n-                public Void run() {\n-                    try {\n-                        String dumpName = className.replace('.','\/');\n-                        File dumpFile = new File(DUMP_CLASS_FILES_DIR, dumpName+\".class\");\n-                        System.out.println(\"dump: \" + dumpFile);\n-                        dumpFile.getParentFile().mkdirs();\n-                        FileOutputStream file = new FileOutputStream(dumpFile);\n-                        file.write(classFile);\n-                        file.close();\n-                        return null;\n-                    } catch (IOException ex) {\n-                        throw newInternalError(ex);\n-                    }\n-                }\n-            });\n@@ -229,0 +187,4 @@\n+    private static boolean dumpClassEnabled() {\n+        return DUMP_CLASS_FILES.isEnabled();\n+    }\n+\n@@ -274,1 +236,1 @@\n-        if (DUMP_CLASS_FILES) {\n+        if (dumpClassEnabled()) {\n@@ -302,1 +264,1 @@\n-        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(className, classFile, Set.of())\n+        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(className, classFile, Set.of(), DUMP_CLASS_FILES)\n@@ -812,3 +774,1 @@\n-        final byte[] classFile = toByteArray();\n-        maybeDump(classFile);\n-        return classFile;\n+        return toByteArray();\n@@ -1901,3 +1861,1 @@\n-        final byte[] classFile = cw.toByteArray();\n-        maybeDump(classFile);\n-        return classFile;\n+        return cw.toByteArray();\n@@ -1970,3 +1928,1 @@\n-        final byte[] classFile = cw.toByteArray();\n-        maybeDump(classFile);\n-        return classFile;\n+        return cw.toByteArray();\n@@ -1980,1 +1936,1 @@\n-        if (DUMP_CLASS_FILES) {\n+        if (dumpClassEnabled()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":14,"deletions":58,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1104,0 +1104,1 @@\n+                name = name.replace('.', '\/');\n@@ -1105,1 +1106,1 @@\n-                        .makeHiddenClassDefiner(name, INJECTED_INVOKER_TEMPLATE, Set.of(NESTMATE))\n+                        .makeHiddenClassDefiner(name, INJECTED_INVOKER_TEMPLATE, Set.of(NESTMATE), DUMP_CLASS_FILES)\n@@ -1658,6 +1659,0 @@\n-            @Override\n-            public Lookup defineHiddenClassWithClassData(Lookup caller, String name, byte[] bytes, Object classData, boolean initialize) {\n-                \/\/ skip name and access flags validation\n-                return caller.makeHiddenClassDefiner(name, bytes, Set.of()).defineClassAsLookup(initialize, classData);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.nio.file.Path;\n@@ -52,1 +53,0 @@\n-    static final boolean DUMP_CLASS_FILES;\n@@ -65,0 +65,1 @@\n+    static final ClassFileDumper DUMP_CLASS_FILES;\n@@ -70,2 +71,2 @@\n-        DUMP_CLASS_FILES = Boolean.parseBoolean(\n-                props.getProperty(\"java.lang.invoke.MethodHandle.DUMP_CLASS_FILES\"));\n+        DUMP_CLASS_FILES = ClassFileDumper.getInstance(\"java.lang.invoke.MethodHandle.DUMP_CLASS_FILES\",\n+                                                       Path.of(\"DUMP_CLASS_FILES\"));\n@@ -110,1 +111,1 @@\n-                DUMP_CLASS_FILES |\n+                DUMP_CLASS_FILES.isEnabled() |\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleStatics.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2241,1 +2241,1 @@\n-            final String name;\n+            final String name;  \/\/ internal name\n@@ -2263,0 +2263,12 @@\n+                var cf = readClassFile(bytes);\n+\n+                \/\/ check if it's in the named package\n+                int index = cf.name.lastIndexOf('\/');\n+                String pn = (index == -1) ? \"\" : cf.name.substring(0, index).replace('\/', '.');\n+                if (!pn.equals(pkgName)) {\n+                    throw newIllegalArgumentException(cf.name + \" not in same package as lookup class\");\n+                }\n+                return cf;\n+            }\n+\n+            private static ClassFile readClassFile(byte[] bytes) {\n@@ -2277,1 +2289,1 @@\n-                    \/\/ ClassReader::getClassName does not check if `this_class` is CONSTANT_Class_info\n+                    \/\/ ClassReader does not check if `this_class` is CONSTANT_Class_info\n@@ -2287,1 +2299,1 @@\n-                    name = type.getClassName();\n+                    name = type.getInternalName();\n@@ -2295,1 +2307,0 @@\n-\n@@ -2300,8 +2311,0 @@\n-\n-                \/\/ check if it's in the named package\n-                int index = name.lastIndexOf('.');\n-                String pn = (index == -1) ? \"\" : name.substring(0, index);\n-                if (!pn.equals(pkgName)) {\n-                    throw newIllegalArgumentException(name + \" not in same package as lookup class\");\n-                }\n-\n@@ -2341,1 +2344,16 @@\n-            return new ClassDefiner(this, cf, STRONG_LOADER_LINK);\n+            return new ClassDefiner(this, cf, STRONG_LOADER_LINK, DEFAULT_DUMPER);\n+        }\n+\n+        \/**\n+         * Returns a ClassDefiner that creates a {@code Class} object of a normal class\n+         * from the given bytes.  No package name check on the given bytes.\n+         *\n+         * @param name    internal name\n+         * @param bytes   class bytes\n+         * @param dumper  dumper to write the given bytes to the dumper's output directory\n+         * @return ClassDefiner that defines a normal class of the given bytes.\n+         *\/\n+        ClassDefiner makeClassDefiner(String name, byte[] bytes, ClassFileDumper dumper) {\n+            \/\/ skip package name validation\n+            ClassFile cf = ClassFile.newInstanceNoCheck(name, bytes);\n+            return new ClassDefiner(this, cf, STRONG_LOADER_LINK, dumper);\n@@ -2359,1 +2377,1 @@\n-            return makeHiddenClassDefiner(cf, Set.of(), false);\n+            return makeHiddenClassDefiner(cf, Set.of(), false, DEFAULT_DUMPER);\n@@ -2382,1 +2400,1 @@\n-            return makeHiddenClassDefiner(cf, options, accessVmAnnotations);\n+            return makeHiddenClassDefiner(cf, options, accessVmAnnotations, DEFAULT_DUMPER);\n@@ -2387,1 +2405,1 @@\n-         * from the given bytes and the given options.  No package name check on the given name.\n+         * from the given bytes and the given options.  No package name check on the given bytes.\n@@ -2389,1 +2407,1 @@\n-         * @param name    fully-qualified name that specifies the prefix of the hidden class\n+         * @param name    internal name which specifies the prefix of the hidden class\n@@ -2396,1 +2414,17 @@\n-            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), options, false);\n+            return makeHiddenClassDefiner(name, bytes, options, DEFAULT_DUMPER);\n+        }\n+\n+        \/**\n+         * Returns a ClassDefiner that creates a {@code Class} object of a hidden class\n+         * from the given bytes and the given options.  No package name check on the given bytes.\n+         *\n+         * @param name    internal name that specifies the prefix of the hidden class\n+         * @param bytes   class bytes\n+         * @param options class options\n+         * @param dumper  dumper to write the given bytes to the dumper's output directory\n+         * @return ClassDefiner that defines a hidden class of the given bytes and options.\n+         *\/\n+        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, Set<ClassOption> options, ClassFileDumper dumper) {\n+            Objects.requireNonNull(dumper);\n+            \/\/ skip name and access flags validation\n+            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), options, false, dumper);\n@@ -2406,0 +2440,1 @@\n+         * @param dumper dumper to write the given bytes to the dumper's output directory\n@@ -2409,1 +2444,2 @@\n-                                                    boolean accessVmAnnotations) {\n+                                                    boolean accessVmAnnotations,\n+                                                    ClassFileDumper dumper) {\n@@ -2417,1 +2453,1 @@\n-            return new ClassDefiner(this, cf, flags);\n+            return new ClassDefiner(this, cf, flags, dumper);\n@@ -2422,1 +2458,1 @@\n-            private final String name;\n+            private final String name;  \/\/ internal name\n@@ -2425,0 +2461,1 @@\n+            private final ClassFileDumper dumper;\n@@ -2426,1 +2463,1 @@\n-            private ClassDefiner(Lookup lookup, ClassFile cf, int flags) {\n+            private ClassDefiner(Lookup lookup, ClassFile cf, int flags, ClassFileDumper dumper) {\n@@ -2432,0 +2469,1 @@\n+                this.dumper = dumper;\n@@ -2434,1 +2472,1 @@\n-            String className() {\n+            String internalName() {\n@@ -2461,4 +2499,26 @@\n-                Class<?> c = SharedSecrets.getJavaLangAccess()\n-                        .defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);\n-                assert !isNestmate() || c.getNestHost() == lookupClass.getNestHost();\n-                return c;\n+                Class<?> c = null;\n+                try {\n+                    c = SharedSecrets.getJavaLangAccess()\n+                            .defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);\n+                    assert !isNestmate() || c.getNestHost() == lookupClass.getNestHost();\n+                    return c;\n+                } finally {\n+                    \/\/ dump the classfile for debugging\n+                    if (dumper.isEnabled()) {\n+                        String name = internalName();\n+                        if (c != null) {\n+                            String cn = c.getName();\n+                            int suffixIdx = cn.lastIndexOf('\/');\n+                            if (suffixIdx > 0) {\n+                                assert ((classFlags & HIDDEN_CLASS) != 0);\n+                                name += '.' + cn.substring(suffixIdx + 1);\n+                            } else {\n+                                assert ((classFlags & HIDDEN_CLASS) == 0);\n+                            }\n+                        } else {\n+                            name += \".failed-\" + dumper.incrementAndGetCounter();\n+                        }\n+                        System.out.println(\"dump: \" + dumper.pathname(name));\n+                        dumper.dumpClass(name, bytes);\n+                    }\n+                }\n@@ -2467,0 +2527,10 @@\n+            \/**\n+             * Defines the class of the given bytes and the given classData.\n+             * If {@code initialize} parameter is true, then the class will be initialized.\n+             *\n+             * @param initialize true if the class to be initialized\n+             * @param classData classData or null\n+             * @return a Lookup for the defined class\n+             *\n+             * @throws LinkageError linkage error\n+             *\/\n@@ -2477,0 +2547,5 @@\n+        \/\/ A default dumper for writing generated classes to disk, for debugging purposes\n+        \/\/ To enable, set -Djava.lang.invoke.Lookup.dumpClasses=<path>\n+        private static final ClassFileDumper DEFAULT_DUMPER =\n+                ClassFileDumper.getInstance(\"java.lang.invoke.Lookup.dumpClasses\");\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":102,"deletions":27,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -1,147 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.invoke;\n-\n-import sun.util.logging.PlatformLogger;\n-\n-import java.io.FilePermission;\n-import java.nio.file.Files;\n-import java.nio.file.InvalidPathException;\n-import java.nio.file.Path;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.Objects;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-\/**\n- * Helper class used by InnerClassLambdaMetafactory to log generated classes\n- *\n- * @implNote\n- * <p> Because this class is called by LambdaMetafactory, make use\n- * of lambda lead to recursive calls cause stack overflow.\n- *\/\n-final class ProxyClassesDumper {\n-    private static final char[] HEX = {\n-        '0', '1', '2', '3', '4', '5', '6', '7',\n-        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n-    };\n-    private static final char[] BAD_CHARS = {\n-        '\\\\', ':', '*', '?', '\"', '<', '>', '|'\n-    };\n-    private static final String[] REPLACEMENT = {\n-        \"%5C\", \"%3A\", \"%2A\", \"%3F\", \"%22\", \"%3C\", \"%3E\", \"%7C\"\n-    };\n-\n-    private final Path dumpDir;\n-\n-    @SuppressWarnings(\"removal\")\n-    public static ProxyClassesDumper getInstance(String path) {\n-        if (null == path) {\n-            return null;\n-        }\n-        try {\n-            path = path.trim();\n-            final Path dir = Path.of(path.isEmpty() ? \".\" : path);\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                    @Override\n-                    public Void run() {\n-                        validateDumpDir(dir);\n-                        return null;\n-                    }\n-                }, null, new FilePermission(\"<<ALL FILES>>\", \"read, write\"));\n-            return new ProxyClassesDumper(dir);\n-        } catch (InvalidPathException ex) {\n-            PlatformLogger.getLogger(ProxyClassesDumper.class.getName())\n-                          .warning(\"Path \" + path + \" is not valid - dumping disabled\", ex);\n-        } catch (IllegalArgumentException iae) {\n-            PlatformLogger.getLogger(ProxyClassesDumper.class.getName())\n-                          .warning(iae.getMessage() + \" - dumping disabled\");\n-        }\n-        return null;\n-    }\n-\n-    private ProxyClassesDumper(Path path) {\n-        dumpDir = Objects.requireNonNull(path);\n-    }\n-\n-    private static void validateDumpDir(Path path) {\n-        if (!Files.exists(path)) {\n-            throw new IllegalArgumentException(\"Directory \" + path + \" does not exist\");\n-        } else if (!Files.isDirectory(path)) {\n-            throw new IllegalArgumentException(\"Path \" + path + \" is not a directory\");\n-        } else if (!Files.isWritable(path)) {\n-            throw new IllegalArgumentException(\"Directory \" + path + \" is not writable\");\n-        }\n-    }\n-\n-    public static String encodeForFilename(String className) {\n-        final int len = className.length();\n-        StringBuilder sb = new StringBuilder(len);\n-\n-        for (int i = 0; i < len; i++) {\n-            char c = className.charAt(i);\n-            \/\/ control characters\n-            if (c <= 31) {\n-                sb.append('%');\n-                sb.append(HEX[c >> 4 & 0x0F]);\n-                sb.append(HEX[c & 0x0F]);\n-            } else {\n-                int j = 0;\n-                for (; j < BAD_CHARS.length; j++) {\n-                    if (c == BAD_CHARS[j]) {\n-                        sb.append(REPLACEMENT[j]);\n-                        break;\n-                    }\n-                }\n-                if (j >= BAD_CHARS.length) {\n-                    sb.append(c);\n-                }\n-            }\n-        }\n-\n-        return sb.toString();\n-    }\n-\n-    public void dumpClass(String className, final byte[] classBytes) {\n-        Path file;\n-        try {\n-            file = dumpDir.resolve(encodeForFilename(className) + \".class\");\n-        } catch (InvalidPathException ex) {\n-            PlatformLogger.getLogger(ProxyClassesDumper.class.getName())\n-                          .warning(\"Invalid path for class \" + className);\n-            return;\n-        }\n-\n-        try {\n-            Path dir = file.getParent();\n-            Files.createDirectories(dir);\n-            Files.write(file, classBytes);\n-        } catch (Exception ignore) {\n-            PlatformLogger.getLogger(ProxyClassesDumper.class.getName())\n-                          .warning(\"Exception writing to path at \" + file.toString());\n-            \/\/ simply don't care if this operation failed\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ProxyClassesDumper.java","additions":0,"deletions":147,"binary":false,"changes":147,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,6 +170,0 @@\n-    \/**\n-     * Defines a hidden class of the given name and bytes with class data.\n-     * The given bytes is trusted.\n-     *\/\n-    Lookup defineHiddenClassWithClassData(Lookup caller, String name, byte[] bytes, Object classData, boolean initialize);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8023524\n+ * @bug 8023524 8304846\n@@ -137,1 +137,1 @@\n-                2, \"Two lambda captured\");\n+                      2, \"Two lambda captured\");\n@@ -149,5 +149,7 @@\n-        assertEquals(tr.testOutput.stream()\n-                                  .filter(s -> s.startsWith(\"WARNING\"))\n-                                  .filter(s -> s.contains(\"does not exist\"))\n-                                  .count(),\n-                     1, \"only show error once\");\n+        \/\/ The dump directory will be created if not exist\n+        assertEquals(Files.find(\n+                        Paths.get(\"notExist\"),\n+                        99,\n+                        (p, a) -> p.startsWith(Paths.get(\"notExist\/com\/example\"))\n+                                && a.isRegularFile()).count(),\n+                    2, \"Two lambda captured\");\n@@ -166,2 +168,1 @@\n-                                  .filter(s -> s.startsWith(\"WARNING\"))\n-                                  .filter(s -> s.contains(\"not a directory\"))\n+                                  .filter(s -> s.contains(\"Path file is not a directory - dumping disabled\"))\n@@ -170,1 +171,1 @@\n-        tr.assertZero(\"Should still return 0\");\n+        assertTrue(tr.exitValue !=0);\n@@ -225,2 +226,1 @@\n-                                      .filter(s -> s.startsWith(\"WARNING\"))\n-                                      .filter(s -> s.contains(\"not writable\"))\n+                                      .filter(s -> s.contains(\"Directory readOnly is not writable - dumping disabled\"))\n@@ -229,1 +229,1 @@\n-            tr.assertZero(\"Should still return 0\");\n+            assertTrue(tr.exitValue != 0);\n@@ -257,1 +257,1 @@\n-                        System.out.println(\"filetered out: \" + p.toString());\n+                        System.out.println(\"filtered out: \" + p.toString());\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LogGeneratedClassesTest.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"}]}