{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.access.SharedSecrets;\n@@ -39,3 +38,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.security.ProtectionDomain;\n@@ -573,16 +569,3 @@\n-\n-            \/\/ load class\n-            InvokerBytecodeGenerator.maybeDump(classBCName(className), classFile);\n-            ClassLoader cl = topClass.getClassLoader();\n-            ProtectionDomain pd = null;\n-            if (cl != null) {\n-                pd = AccessController.doPrivileged(\n-                        new PrivilegedAction<>() {\n-                            @Override\n-                            public ProtectionDomain run() {\n-                                return topClass().getProtectionDomain();\n-                            }\n-                        });\n-            }\n-            Class<?> speciesCode = SharedSecrets.getJavaLangAccess()\n-                    .defineClass(cl, className, classFile, pd, \"_ClassSpecializer_generateConcreteSpeciesCode\");\n+            var lookup = new MethodHandles.Lookup(topClass);\n+            Class<?> speciesCode = lookup.makeClassDefiner(classBCName(className), classFile, dumper())\n+                                         .defineClass(false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.util.ClassFileDumper;\n@@ -32,1 +33,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -35,1 +35,0 @@\n-import java.io.FilePermission;\n@@ -38,1 +37,0 @@\n-import java.lang.invoke.MethodHandles.Lookup;\n@@ -40,2 +38,1 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n+import java.nio.file.Path;\n@@ -44,1 +41,0 @@\n-import java.util.PropertyPermission;\n@@ -92,1 +88,1 @@\n-    private static final ProxyClassesDumper dumper;\n+    private static final ClassFileDumper lambdaProxyClassFileDumper;\n@@ -100,3 +96,4 @@\n-        final String dumpProxyClassesKey = \"jdk.internal.lambda.dumpProxyClasses\";\n-        String dumpPath = GetPropertyAction.privilegedGetProperty(dumpProxyClassesKey);\n-        dumper = (null == dumpPath) ? null : ProxyClassesDumper.getInstance(dumpPath);\n+        \/\/ To dump the lambda proxy classes, set this system property:\n+        \/\/    -Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles=true\n+        final String dumpProxyClassesKey = \"jdk.invoke.LambdaMetafactory.dumpProxyClassFiles\";\n+        lambdaProxyClassFileDumper = ClassFileDumper.getInstance(dumpProxyClassesKey, Path.of(\"DUMP_LAMBDA_PROXY_CLASS_FILES\"));\n@@ -366,26 +363,4 @@\n-            Lookup lookup = null;\n-            try {\n-                if (useImplMethodHandle) {\n-                    lookup = caller.defineHiddenClassWithClassData(classBytes, implementation, !disableEagerInitialization,\n-                                                                   NESTMATE, STRONG);\n-                } else {\n-                    lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);\n-                }\n-                return lookup.lookupClass();\n-            } finally {\n-                \/\/ If requested, dump out to a file for debugging purposes\n-                if (dumper != null) {\n-                    String name;\n-                    if (lookup != null) {\n-                        String definedName = lookup.lookupClass().getName();\n-                        int suffixIdx = definedName.lastIndexOf('\/');\n-                        assert suffixIdx != -1;\n-                        name = lambdaClassName + '.' + definedName.substring(suffixIdx + 1);\n-                    } else {\n-                        name = lambdaClassName + \".failed-\" + counter.incrementAndGet();\n-                    }\n-                    doDump(name, classBytes);\n-                }\n-            }\n-        } catch (IllegalAccessException e) {\n-            throw new LambdaConversionException(\"Exception defining lambda proxy class\", e);\n+            var classdata = useImplMethodHandle? implementation : null;\n+            return caller.makeHiddenClassDefiner(lambdaClassName, classBytes, Set.of(NESTMATE, STRONG), lambdaProxyClassFileDumper)\n+                         .defineClass(!disableEagerInitialization, classdata);\n+\n@@ -397,14 +372,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private void doDump(final String className, final byte[] classBytes) {\n-        AccessController.doPrivileged(new PrivilegedAction<>() {\n-            @Override\n-            public Void run() {\n-                dumper.dumpClass(className, classBytes);\n-                return null;\n-            }\n-        }, null,\n-        new FilePermission(\"<<ALL FILES>>\", \"read, write\"),\n-        \/\/ createDirectories may need it\n-        new PropertyPermission(\"user.dir\", \"read\"));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":11,"deletions":50,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -39,3 +38,0 @@\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n@@ -128,1 +124,1 @@\n-        if (DUMP_CLASS_FILES) {\n+        if (dumper().isEnabled()) {\n@@ -176,52 +172,2 @@\n-    private static final HashMap<String,Integer> DUMP_CLASS_FILES_COUNTERS;\n-    \/** debugging flag for saving generated class files *\/\n-    private static final File DUMP_CLASS_FILES_DIR;\n-\n-    static {\n-        if (DUMP_CLASS_FILES) {\n-            DUMP_CLASS_FILES_COUNTERS = new HashMap<>();\n-            try {\n-                File dumpDir = new File(\"DUMP_CLASS_FILES\");\n-                if (!dumpDir.exists()) {\n-                    dumpDir.mkdirs();\n-                }\n-                DUMP_CLASS_FILES_DIR = dumpDir;\n-                System.out.println(\"Dumping class files to \"+DUMP_CLASS_FILES_DIR+\"\/...\");\n-            } catch (Exception e) {\n-                throw newInternalError(e);\n-            }\n-        } else {\n-            DUMP_CLASS_FILES_COUNTERS = null;\n-            DUMP_CLASS_FILES_DIR = null;\n-        }\n-    }\n-\n-    private void maybeDump(final byte[] classFile) {\n-        if (DUMP_CLASS_FILES) {\n-            maybeDump(className, classFile);\n-        }\n-    }\n-\n-    \/\/ Also used from BoundMethodHandle\n-    @SuppressWarnings(\"removal\")\n-    static void maybeDump(final String className, final byte[] classFile) {\n-        if (DUMP_CLASS_FILES) {\n-            java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<>() {\n-                public Void run() {\n-                    try {\n-                        String dumpName = className.replace('.','\/');\n-                        File dumpFile = new File(DUMP_CLASS_FILES_DIR, dumpName+\".class\");\n-                        System.out.println(\"dump: \" + dumpFile);\n-                        dumpFile.getParentFile().mkdirs();\n-                        FileOutputStream file = new FileOutputStream(dumpFile);\n-                        file.write(classFile);\n-                        file.close();\n-                        return null;\n-                    } catch (IOException ex) {\n-                        throw newInternalError(ex);\n-                    }\n-                }\n-            });\n-        }\n-    }\n+    private static final HashMap<String,Integer> DUMP_CLASS_FILES_COUNTERS =\n+            dumper().isEnabled() ?  new HashMap<>(): null;\n@@ -274,1 +220,1 @@\n-        if (DUMP_CLASS_FILES) {\n+        if (dumper().isEnabled()) {\n@@ -302,1 +248,1 @@\n-        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(className, classFile, Set.of())\n+        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(className, classFile, Set.of(), dumper())\n@@ -812,3 +758,1 @@\n-        final byte[] classFile = toByteArray();\n-        maybeDump(classFile);\n-        return classFile;\n+        return toByteArray();\n@@ -1901,3 +1845,1 @@\n-        final byte[] classFile = cw.toByteArray();\n-        maybeDump(classFile);\n-        return classFile;\n+        return cw.toByteArray();\n@@ -1970,3 +1912,1 @@\n-        final byte[] classFile = cw.toByteArray();\n-        maybeDump(classFile);\n-        return classFile;\n+        return cw.toByteArray();\n@@ -1980,1 +1920,1 @@\n-        if (DUMP_CLASS_FILES) {\n+        if (dumper().isEnabled()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":10,"deletions":70,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1104,0 +1104,1 @@\n+                name = name.replace('.', '\/');\n@@ -1105,1 +1106,1 @@\n-                        .makeHiddenClassDefiner(name, INJECTED_INVOKER_TEMPLATE, Set.of(NESTMATE))\n+                        .makeHiddenClassDefiner(name, INJECTED_INVOKER_TEMPLATE, Set.of(NESTMATE), dumper())\n@@ -1658,6 +1659,0 @@\n-            @Override\n-            public Lookup defineHiddenClassWithClassData(Lookup caller, String name, byte[] bytes, Object classData, boolean initialize) {\n-                \/\/ skip name and access flags validation\n-                return caller.makeHiddenClassDefiner(name, bytes, Set.of()).defineClassAsLookup(initialize, classData);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.util.ClassFileDumper;\n@@ -33,0 +34,1 @@\n+import java.nio.file.Path;\n@@ -52,1 +54,0 @@\n-    static final boolean DUMP_CLASS_FILES;\n@@ -65,0 +66,1 @@\n+    static final ClassFileDumper DUMP_CLASS_FILES;\n@@ -70,2 +72,1 @@\n-        DUMP_CLASS_FILES = Boolean.parseBoolean(\n-                props.getProperty(\"java.lang.invoke.MethodHandle.DUMP_CLASS_FILES\"));\n+\n@@ -99,0 +100,3 @@\n+        DUMP_CLASS_FILES = ClassFileDumper.getInstance(\"jdk.invoke.MethodHandle.dumpMethodHandleInternals\",\n+                Path.of(\"DUMP_METHOD_HANDLE_INTERNALS\"));\n+\n@@ -110,1 +114,1 @@\n-                DUMP_CLASS_FILES |\n+                DUMP_CLASS_FILES.isEnabled() |\n@@ -116,0 +120,4 @@\n+    static ClassFileDumper dumper() {\n+        return DUMP_CLASS_FILES;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleStatics.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.util.ClassFileDumper;\n@@ -58,0 +59,1 @@\n+import java.nio.file.Path;\n@@ -2240,0 +2242,14 @@\n+        \/\/ A default dumper for writing class files passed to Lookup::defineClass\n+        \/\/ and Lookup::defineHiddenClass to disk for debugging purposes.  To enable,\n+        \/\/ set -Djdk.invoke.MethodHandle.dumpHiddenClassFiles=true\n+        \/\/\n+        \/\/ This default dumper does not dump hidden classes defined by LambdaMetafactory\n+        \/\/ and LambdaForms and method handle internals.  They are dumped via\n+        \/\/ different ClassFileDumpers.\n+        private static ClassFileDumper defaultDumper() {\n+            return DEFAULT_DUMPER;\n+        }\n+\n+        private static final ClassFileDumper DEFAULT_DUMPER = ClassFileDumper.getInstance(\n+                \"jdk.invoke.MethodHandle.dumpClassFiles\", Path.of(\"DUMP_CLASS_FILES\"));\n+\n@@ -2241,1 +2257,1 @@\n-            final String name;\n+            final String name;  \/\/ internal name\n@@ -2263,0 +2279,12 @@\n+                var cf = readClassFile(bytes);\n+\n+                \/\/ check if it's in the named package\n+                int index = cf.name.lastIndexOf('\/');\n+                String pn = (index == -1) ? \"\" : cf.name.substring(0, index).replace('\/', '.');\n+                if (!pn.equals(pkgName)) {\n+                    throw newIllegalArgumentException(cf.name + \" not in same package as lookup class\");\n+                }\n+                return cf;\n+            }\n+\n+            private static ClassFile readClassFile(byte[] bytes) {\n@@ -2277,1 +2305,1 @@\n-                    \/\/ ClassReader::getClassName does not check if `this_class` is CONSTANT_Class_info\n+                    \/\/ ClassReader does not check if `this_class` is CONSTANT_Class_info\n@@ -2287,1 +2315,1 @@\n-                    name = type.getClassName();\n+                    name = type.getInternalName();\n@@ -2295,1 +2323,0 @@\n-\n@@ -2300,8 +2327,0 @@\n-\n-                \/\/ check if it's in the named package\n-                int index = name.lastIndexOf('.');\n-                String pn = (index == -1) ? \"\" : name.substring(0, index);\n-                if (!pn.equals(pkgName)) {\n-                    throw newIllegalArgumentException(name + \" not in same package as lookup class\");\n-                }\n-\n@@ -2341,1 +2360,16 @@\n-            return new ClassDefiner(this, cf, STRONG_LOADER_LINK);\n+            return new ClassDefiner(this, cf, STRONG_LOADER_LINK, defaultDumper());\n+        }\n+\n+        \/**\n+         * Returns a ClassDefiner that creates a {@code Class} object of a normal class\n+         * from the given bytes.  No package name check on the given bytes.\n+         *\n+         * @param name    internal name\n+         * @param bytes   class bytes\n+         * @param dumper  dumper to write the given bytes to the dumper's output directory\n+         * @return ClassDefiner that defines a normal class of the given bytes.\n+         *\/\n+        ClassDefiner makeClassDefiner(String name, byte[] bytes, ClassFileDumper dumper) {\n+            \/\/ skip package name validation\n+            ClassFile cf = ClassFile.newInstanceNoCheck(name, bytes);\n+            return new ClassDefiner(this, cf, STRONG_LOADER_LINK, dumper);\n@@ -2359,1 +2393,1 @@\n-            return makeHiddenClassDefiner(cf, Set.of(), false);\n+            return makeHiddenClassDefiner(cf, Set.of(), false, defaultDumper());\n@@ -2382,1 +2416,1 @@\n-            return makeHiddenClassDefiner(cf, options, accessVmAnnotations);\n+            return makeHiddenClassDefiner(cf, options, accessVmAnnotations, defaultDumper());\n@@ -2387,1 +2421,1 @@\n-         * from the given bytes and the given options.  No package name check on the given name.\n+         * from the given bytes and the given options.  No package name check on the given bytes.\n@@ -2389,1 +2423,1 @@\n-         * @param name    fully-qualified name that specifies the prefix of the hidden class\n+         * @param name    internal name which specifies the prefix of the hidden class\n@@ -2396,1 +2430,17 @@\n-            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), options, false);\n+            return makeHiddenClassDefiner(name, bytes, options, defaultDumper());\n+        }\n+\n+        \/**\n+         * Returns a ClassDefiner that creates a {@code Class} object of a hidden class\n+         * from the given bytes and the given options.  No package name check on the given bytes.\n+         *\n+         * @param name    internal name that specifies the prefix of the hidden class\n+         * @param bytes   class bytes\n+         * @param options class options\n+         * @param dumper  dumper to write the given bytes to the dumper's output directory\n+         * @return ClassDefiner that defines a hidden class of the given bytes and options.\n+         *\/\n+        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, Set<ClassOption> options, ClassFileDumper dumper) {\n+            Objects.requireNonNull(dumper);\n+            \/\/ skip name and access flags validation\n+            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), options, false, dumper);\n@@ -2406,0 +2456,1 @@\n+         * @param dumper dumper to write the given bytes to the dumper's output directory\n@@ -2409,1 +2460,2 @@\n-                                                    boolean accessVmAnnotations) {\n+                                                    boolean accessVmAnnotations,\n+                                                    ClassFileDumper dumper) {\n@@ -2417,1 +2469,1 @@\n-            return new ClassDefiner(this, cf, flags);\n+            return new ClassDefiner(this, cf, flags, dumper);\n@@ -2422,1 +2474,1 @@\n-            private final String name;\n+            private final String name;  \/\/ internal name\n@@ -2425,0 +2477,1 @@\n+            private final ClassFileDumper dumper;\n@@ -2426,1 +2479,1 @@\n-            private ClassDefiner(Lookup lookup, ClassFile cf, int flags) {\n+            private ClassDefiner(Lookup lookup, ClassFile cf, int flags, ClassFileDumper dumper) {\n@@ -2432,0 +2485,1 @@\n+                this.dumper = dumper;\n@@ -2434,1 +2488,1 @@\n-            String className() {\n+            String internalName() {\n@@ -2461,4 +2515,25 @@\n-                Class<?> c = SharedSecrets.getJavaLangAccess()\n-                        .defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);\n-                assert !isNestmate() || c.getNestHost() == lookupClass.getNestHost();\n-                return c;\n+                Class<?> c = null;\n+                try {\n+                    c = SharedSecrets.getJavaLangAccess()\n+                            .defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);\n+                    assert !isNestmate() || c.getNestHost() == lookupClass.getNestHost();\n+                    return c;\n+                } finally {\n+                    \/\/ dump the classfile for debugging\n+                    if (dumper.isEnabled()) {\n+                        String name = internalName();\n+                        if (c != null) {\n+                            String cn = c.getName();\n+                            int suffixIdx = cn.lastIndexOf('\/');\n+                            if (suffixIdx > 0) {\n+                                assert ((classFlags & HIDDEN_CLASS) != 0);\n+                                name += '.' + cn.substring(suffixIdx + 1);\n+                            } else {\n+                                assert ((classFlags & HIDDEN_CLASS) == 0);\n+                            }\n+                        } else {\n+                            name += \".failed-\" + dumper.incrementAndGetCounter();\n+                        }\n+                        dumper.dumpClass(name, bytes);\n+                    }\n+                }\n@@ -2467,0 +2542,10 @@\n+            \/**\n+             * Defines the class of the given bytes and the given classData.\n+             * If {@code initialize} parameter is true, then the class will be initialized.\n+             *\n+             * @param initialize true if the class to be initialized\n+             * @param classData classData or null\n+             * @return a Lookup for the defined class\n+             *\n+             * @throws LinkageError linkage error\n+             *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":112,"deletions":27,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -1,147 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.invoke;\n-\n-import sun.util.logging.PlatformLogger;\n-\n-import java.io.FilePermission;\n-import java.nio.file.Files;\n-import java.nio.file.InvalidPathException;\n-import java.nio.file.Path;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.Objects;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-\/**\n- * Helper class used by InnerClassLambdaMetafactory to log generated classes\n- *\n- * @implNote\n- * <p> Because this class is called by LambdaMetafactory, make use\n- * of lambda lead to recursive calls cause stack overflow.\n- *\/\n-final class ProxyClassesDumper {\n-    private static final char[] HEX = {\n-        '0', '1', '2', '3', '4', '5', '6', '7',\n-        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n-    };\n-    private static final char[] BAD_CHARS = {\n-        '\\\\', ':', '*', '?', '\"', '<', '>', '|'\n-    };\n-    private static final String[] REPLACEMENT = {\n-        \"%5C\", \"%3A\", \"%2A\", \"%3F\", \"%22\", \"%3C\", \"%3E\", \"%7C\"\n-    };\n-\n-    private final Path dumpDir;\n-\n-    @SuppressWarnings(\"removal\")\n-    public static ProxyClassesDumper getInstance(String path) {\n-        if (null == path) {\n-            return null;\n-        }\n-        try {\n-            path = path.trim();\n-            final Path dir = Path.of(path.isEmpty() ? \".\" : path);\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                    @Override\n-                    public Void run() {\n-                        validateDumpDir(dir);\n-                        return null;\n-                    }\n-                }, null, new FilePermission(\"<<ALL FILES>>\", \"read, write\"));\n-            return new ProxyClassesDumper(dir);\n-        } catch (InvalidPathException ex) {\n-            PlatformLogger.getLogger(ProxyClassesDumper.class.getName())\n-                          .warning(\"Path \" + path + \" is not valid - dumping disabled\", ex);\n-        } catch (IllegalArgumentException iae) {\n-            PlatformLogger.getLogger(ProxyClassesDumper.class.getName())\n-                          .warning(iae.getMessage() + \" - dumping disabled\");\n-        }\n-        return null;\n-    }\n-\n-    private ProxyClassesDumper(Path path) {\n-        dumpDir = Objects.requireNonNull(path);\n-    }\n-\n-    private static void validateDumpDir(Path path) {\n-        if (!Files.exists(path)) {\n-            throw new IllegalArgumentException(\"Directory \" + path + \" does not exist\");\n-        } else if (!Files.isDirectory(path)) {\n-            throw new IllegalArgumentException(\"Path \" + path + \" is not a directory\");\n-        } else if (!Files.isWritable(path)) {\n-            throw new IllegalArgumentException(\"Directory \" + path + \" is not writable\");\n-        }\n-    }\n-\n-    public static String encodeForFilename(String className) {\n-        final int len = className.length();\n-        StringBuilder sb = new StringBuilder(len);\n-\n-        for (int i = 0; i < len; i++) {\n-            char c = className.charAt(i);\n-            \/\/ control characters\n-            if (c <= 31) {\n-                sb.append('%');\n-                sb.append(HEX[c >> 4 & 0x0F]);\n-                sb.append(HEX[c & 0x0F]);\n-            } else {\n-                int j = 0;\n-                for (; j < BAD_CHARS.length; j++) {\n-                    if (c == BAD_CHARS[j]) {\n-                        sb.append(REPLACEMENT[j]);\n-                        break;\n-                    }\n-                }\n-                if (j >= BAD_CHARS.length) {\n-                    sb.append(c);\n-                }\n-            }\n-        }\n-\n-        return sb.toString();\n-    }\n-\n-    public void dumpClass(String className, final byte[] classBytes) {\n-        Path file;\n-        try {\n-            file = dumpDir.resolve(encodeForFilename(className) + \".class\");\n-        } catch (InvalidPathException ex) {\n-            PlatformLogger.getLogger(ProxyClassesDumper.class.getName())\n-                          .warning(\"Invalid path for class \" + className);\n-            return;\n-        }\n-\n-        try {\n-            Path dir = file.getParent();\n-            Files.createDirectories(dir);\n-            Files.write(file, classBytes);\n-        } catch (Exception ignore) {\n-            PlatformLogger.getLogger(ProxyClassesDumper.class.getName())\n-                          .warning(\"Exception writing to path at \" + file.toString());\n-            \/\/ simply don't care if this operation failed\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ProxyClassesDumper.java","additions":0,"deletions":147,"binary":false,"changes":147,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,6 +170,0 @@\n-    \/**\n-     * Defines a hidden class of the given name and bytes with class data.\n-     * The given bytes is trusted.\n-     *\/\n-    Lookup defineHiddenClassWithClassData(Lookup caller, String name, byte[] bytes, Object classData, boolean initialize);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.util;\n+\n+import jdk.internal.misc.VM;\n+import sun.security.action.GetBooleanAction;\n+import sun.security.action.GetPropertyAction;\n+import sun.util.logging.PlatformLogger;\n+\n+import java.io.FilePermission;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Objects;\n+import java.util.PropertyPermission;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/**\n+ * Helper class to log normal and hidden classes defined via Lookup::defineClass\n+ * and Lookup::defineHiddenClass API\n+ *\n+ * @implNote\n+ * <p> Because this class is called by MethodHandleStatics, LambdaForms generation\n+ * and LambdaMetafactory, make use of lambda lead to recursive calls cause stack overflow.\n+ *\/\n+public final class ClassFileDumper {\n+    private static final char[] HEX = {\n+        '0', '1', '2', '3', '4', '5', '6', '7',\n+        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n+    };\n+    private static final char[] BAD_CHARS = {\n+        '\\\\', ':', '*', '?', '\"', '<', '>', '|'\n+    };\n+    private static final String[] REPLACEMENT = {\n+        \"%5C\", \"%3A\", \"%2A\", \"%3F\", \"%22\", \"%3C\", \"%3E\", \"%7C\"\n+    };\n+\n+    private static final ConcurrentHashMap<String, ClassFileDumper> DUMPER_MAP\n+            = new ConcurrentHashMap<>();\n+\n+    \/**\n+     * Returns a ClassFileDumper instance for the given key.  To enable\n+     * dumping of the generated classes, set the system property via\n+     * -D<key>=<path>.\n+     *\n+     * The system property is read only once when it is the first time\n+     * the dumper instance for the given key is created.\n+     *\n+     * If not enabled, this method returns ClassFileDumper with null\n+     * dump path.\n+     *\/\n+    public static ClassFileDumper getInstance(String key) {\n+        Objects.requireNonNull(key);\n+\n+        var dumper = DUMPER_MAP.get(key);\n+        if (dumper == null) {\n+            String path = GetPropertyAction.privilegedGetProperty(key);\n+            Path dir;\n+            if (path == null || path.trim().isEmpty()) {\n+                dir = null;\n+            } else {\n+                dir = validateDumpDir(Path.of(path.trim()));\n+            }\n+            var newDumper = new ClassFileDumper(key, dir);\n+            var v = DUMPER_MAP.putIfAbsent(key, newDumper);\n+            dumper = v != null ? v : newDumper;\n+        }\n+        return dumper;\n+    }\n+\n+    \/**\n+     * Returns a ClassFileDumper instance for the given key with a given\n+     * dump path. To enable dumping of the generated classes, -D<key>=true.\n+     *\n+     * The system property is read only once when it is the first time\n+     * the dumper instance for the given key is created.\n+     *\n+     * If not enabled, this method returns ClassFileDumper with null\n+     * dump path.\n+     *\/\n+    public static ClassFileDumper getInstance(String key, Path path) {\n+        Objects.requireNonNull(key);\n+        Objects.requireNonNull(path);\n+\n+        var dumper = DUMPER_MAP.get(key);\n+        if (dumper == null) {\n+            boolean enabled = GetBooleanAction.privilegedGetProperty(key);\n+            Path dir = enabled ? validateDumpDir(path) : null;\n+            var newDumper = new ClassFileDumper(key, dir);\n+            var v = DUMPER_MAP.putIfAbsent(key, newDumper);\n+            dumper = v != null ? v : newDumper;\n+        }\n+\n+        if (dumper.isEnabled() && !path.equals(dumper.dumpPath())) {\n+            throw new IllegalArgumentException(\"mismatched dump path for \" + key);\n+        }\n+        return dumper;\n+    }\n+\n+    private final String key;\n+    private final Path dumpDir;\n+    private final AtomicInteger counter = new AtomicInteger();\n+\n+    private ClassFileDumper(String key, Path path) {\n+        this.key = key;\n+        this.dumpDir = path;\n+    }\n+\n+    public String key() {\n+        return key;\n+    }\n+    public boolean isEnabled() {\n+        return dumpDir != null;\n+    }\n+\n+    public Path dumpPath() {\n+        return dumpDir;\n+    }\n+\n+    public int incrementAndGetCounter() {\n+        return counter.incrementAndGet();\n+    }\n+\n+    public Path pathname(String internalName) {\n+        return dumpDir.resolve(encodeForFilename(internalName) + \".class\");\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    public void dumpClass(String internalName, final byte[] classBytes) {\n+        if (!isEnabled()) return;\n+\n+        AccessController.doPrivileged(new PrivilegedAction<>() {\n+                @Override public Void run() {\n+                    Path file = pathname(internalName);\n+                    try {\n+                        Path dir = file.getParent();\n+                        Files.createDirectories(dir);\n+                        Files.write(file, classBytes);\n+                    } catch (Exception ex) {\n+                        if (VM.isModuleSystemInited()) {\n+                            \/\/ log only when lambda is ready to use\n+                            System.getLogger(ClassFileDumper.class.getName())\n+                                  .log(System.Logger.Level.WARNING, \"Exception writing to \" +\n+                                          file.toString() + \" \" + ex.getMessage());\n+                        }\n+                        \/\/ simply don't care if this operation failed\n+                    }\n+                    return null;\n+                }},\n+                null,\n+                new FilePermission(\"<<ALL FILES>>\", \"read, write\"),\n+                \/\/ createDirectories may need it\n+                new PropertyPermission(\"user.dir\", \"read\"));\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static Path validateDumpDir(Path path) {\n+            return AccessController.doPrivileged(new PrivilegedAction<>() {\n+                @Override\n+                public Path run() {\n+                    if (!Files.exists(path)) {\n+                        try {\n+                            Files.createDirectory(path);\n+                        } catch (IOException ex) {\n+                            throw new UncheckedIOException(\"Fail to create \" + path, ex);\n+                        }\n+                    }\n+                    if (!Files.isDirectory(path)) {\n+                        throw new IllegalArgumentException(\"Path \" + path + \" is not a directory\");\n+                    } else if (!Files.isWritable(path)) {\n+                        throw new IllegalArgumentException(\"Directory \" + path + \" is not writable\");\n+                    }\n+                    return path;\n+                }\n+            });\n+    }\n+\n+\n+    private static String encodeForFilename(String className) {\n+        final int len = className.length();\n+        StringBuilder sb = new StringBuilder(len);\n+\n+        for (int i = 0; i < len; i++) {\n+            char c = className.charAt(i);\n+            \/\/ control characters\n+            if (c <= 31) {\n+                sb.append('%');\n+                sb.append(HEX[c >> 4 & 0x0F]);\n+                sb.append(HEX[c & 0x0F]);\n+            } else {\n+                int j = 0;\n+                for (; j < BAD_CHARS.length; j++) {\n+                    if (c == BAD_CHARS[j]) {\n+                        sb.append(REPLACEMENT[j]);\n+                        break;\n+                    }\n+                }\n+                if (j >= BAD_CHARS.length) {\n+                    sb.append(c);\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ClassFileDumper.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -54,0 +54,1 @@\n+    static final Path DUMP_LAMBDA_PROXY_CLASS_FILES = Path.of(\"DUMP_LAMBDA_PROXY_CLASS_FILES\");\n@@ -61,1 +62,1 @@\n-                \"-Djdk.internal.lambda.dumpProxyClasses=.\",\n+                \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles=true\",\n@@ -137,1 +138,1 @@\n-        try (DirectoryStream<Path> ds = newDirectoryStream(new File(\".\").toPath(),\n+        try (DirectoryStream<Path> ds = newDirectoryStream(DUMP_LAMBDA_PROXY_CLASS_FILES,\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaAsm.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8023524\n+ * @bug 8023524 8304846\n@@ -54,0 +54,1 @@\n+    static final Path DUMP_LAMBDA_PROXY_CLASS_FILES = Path.of(\"DUMP_LAMBDA_PROXY_CLASS_FILES\");\n@@ -96,6 +97,0 @@\n-\n-        \/\/ create target\n-        Files.createDirectory(Paths.get(\"dump\"));\n-        Files.createDirectories(Paths.get(\"dumpLong\/com\/example\/nonsense\"));\n-        Files.createFile(Paths.get(\"dumpLong\/com\/example\/nonsense\/nonsense\"));\n-        Files.createFile(Paths.get(\"file\"));\n@@ -108,2 +103,2 @@\n-        Files.delete(Paths.get(\"file\"));\n-        TestUtil.removeAll(Paths.get(\"com\"));\n+        TestUtil.removeAll(DUMP_LAMBDA_PROXY_CLASS_FILES);\n+        TestUtil.removeAll(Paths.get(\"notDir\"));\n@@ -125,1 +120,3 @@\n-        assertTrue(Files.exists(Paths.get(\"dump\")));\n+        Path testDir = Path.of(\"dump\");\n+        Path dumpDir = testDir.resolve(DUMP_LAMBDA_PROXY_CLASS_FILES);\n+        Files.createDirectory(testDir);\n@@ -127,1 +124,2 @@\n-                               \"-cp\", \".\",\n+                               \"-cp\", \"..\",\n+                               \"-Duser.dir=\" + testDir.toAbsolutePath(),\n@@ -129,1 +127,1 @@\n-                               \"-Djdk.internal.lambda.dumpProxyClasses=dump\",\n+                               \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles=true\",\n@@ -133,1 +131,1 @@\n-                        Paths.get(\"dump\"),\n+                        dumpDir,\n@@ -135,1 +133,1 @@\n-                        (p, a) -> p.startsWith(Paths.get(\"dump\/com\/example\"))\n+                        (p, a) -> p.startsWith(dumpDir.resolve(\"com\/example\"))\n@@ -137,1 +135,1 @@\n-                2, \"Two lambda captured\");\n+                      2, \"Two lambda captured\");\n@@ -143,1 +141,6 @@\n-        assertFalse(Files.exists(Paths.get(\"notExist\")));\n+        Path testDir = Path.of(\"NotExist\");\n+        Path dumpDir = testDir.resolve(DUMP_LAMBDA_PROXY_CLASS_FILES);\n+        Files.createDirectory(testDir);\n+        TestUtil.removeAll(dumpDir);\n+\n+        assertFalse(Files.exists(dumpDir));\n@@ -145,1 +148,2 @@\n-                               \"-cp\", \".\",\n+                               \"-cp\", \"..\",\n+                               \"-Duser.dir=\" + testDir.toAbsolutePath(),\n@@ -147,1 +151,1 @@\n-                               \"-Djdk.internal.lambda.dumpProxyClasses=notExist\",\n+                               \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles=true\",\n@@ -149,5 +153,8 @@\n-        assertEquals(tr.testOutput.stream()\n-                                  .filter(s -> s.startsWith(\"WARNING\"))\n-                                  .filter(s -> s.contains(\"does not exist\"))\n-                                  .count(),\n-                     1, \"only show error once\");\n+\n+        \/\/ The dump directory will be created if not exist\n+        assertEquals(Files.find(\n+                        dumpDir,\n+                        99,\n+                        (p, a) -> p.startsWith(dumpDir.resolve(\"com\/example\"))\n+                                && a.isRegularFile()).count(),\n+                    2, \"Two lambda captured\");\n@@ -159,1 +166,5 @@\n-        assertTrue(Files.isRegularFile(Paths.get(\"file\")));\n+        Path testDir = Path.of(\"notDir\");\n+        Path dumpFile = testDir.resolve(DUMP_LAMBDA_PROXY_CLASS_FILES);\n+        Files.createDirectory(testDir);\n+        Files.createFile(dumpFile);\n+        assertTrue(Files.isRegularFile(dumpFile));\n@@ -161,1 +172,2 @@\n-                               \"-cp\", \".\",\n+                               \"-cp\", \"..\",\n+                               \"-Duser.dir=\" + testDir.toAbsolutePath(),\n@@ -163,1 +175,1 @@\n-                               \"-Djdk.internal.lambda.dumpProxyClasses=file\",\n+                               \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles=true\",\n@@ -166,2 +178,1 @@\n-                                  .filter(s -> s.startsWith(\"WARNING\"))\n-                                  .filter(s -> s.contains(\"not a directory\"))\n+                                  .filter(s -> s.contains(\"is not a directory\"))\n@@ -170,1 +181,1 @@\n-        tr.assertZero(\"Should still return 0\");\n+        assertTrue(tr.exitValue !=0);\n@@ -209,1 +220,4 @@\n-        Files.createDirectory(Paths.get(\"readOnly\"),\n+        Path testDir = Path.of(\"readOnly\");\n+        Path dumpDir = testDir.resolve(DUMP_LAMBDA_PROXY_CLASS_FILES);\n+        Files.createDirectory(testDir);\n+        Files.createDirectory(dumpDir,\n@@ -212,1 +226,1 @@\n-            if (isWriteableDirectory(Paths.get(\"readOnly\"))) {\n+            if (isWriteableDirectory(dumpDir)) {\n@@ -215,1 +229,1 @@\n-                System.out.println(\"WARNING: readOnly directory is writeable. Skipping testDumpDirNotWritable test.\");\n+                System.out.println(\"WARNING: The dump directory is writeable. Skipping testDumpDirNotWritable test.\");\n@@ -220,1 +234,2 @@\n-                                   \"-cp\", \".\",\n+                                   \"-cp\", \"..\",\n+                                   \"-Duser.dir=\" + testDir.toAbsolutePath(),\n@@ -222,1 +237,1 @@\n-                                   \"-Djdk.internal.lambda.dumpProxyClasses=readOnly\",\n+                                   \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles=true\",\n@@ -225,2 +240,1 @@\n-                                      .filter(s -> s.startsWith(\"WARNING\"))\n-                                      .filter(s -> s.contains(\"not writable\"))\n+                                      .filter(s -> s.contains(\"is not writable\"))\n@@ -229,1 +243,1 @@\n-            tr.assertZero(\"Should still return 0\");\n+            assertTrue(tr.exitValue != 0);\n@@ -231,1 +245,1 @@\n-            TestUtil.removeAll(Paths.get(\"readOnly\"));\n+            TestUtil.removeAll(testDir);\n@@ -237,1 +251,4 @@\n-        assertTrue(Files.exists(Paths.get(\"dumpLong\")));\n+        Path testDir = Path.of(\"dumpLong\");\n+        Path dumpDir = testDir.resolve(DUMP_LAMBDA_PROXY_CLASS_FILES);\n+        Files.createDirectories(dumpDir.resolve(\"com\/example\/nonsense\"));\n+        Files.createFile(dumpDir.resolve(\"com\/example\/nonsense\/nonsense\"));\n@@ -239,3 +256,4 @@\n-                               \"-cp\", \".\",\n-                                \"-Djava.security.manager=allow\",\n-                               \"-Djdk.internal.lambda.dumpProxyClasses=dumpLong\",\n+                               \"-cp\", \"..\",\n+                               \"-Duser.dir=\" + testDir.toAbsolutePath(),\n+                               \"-Djava.security.manager=allow\",\n+                               \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles=true\",\n@@ -247,2 +265,2 @@\n-        \/\/ dumpLong\/com\/example\/nonsense\/nonsense\n-        Path dumpPath = Paths.get(\"dumpLong\/com\/example\/nonsense\");\n+        \/\/ dumpLong\/DUMP_LAMBDA_PROXY_CLASS_FILES\/com\/example\/nonsense\/nonsense\n+        Path dumpPath = dumpDir.resolve(\"com\/example\/nonsense\");\n@@ -252,1 +270,1 @@\n-           Files.walk(Paths.get(\"dumpLong\"))\n+           Files.walk(dumpDir)\n@@ -257,1 +275,1 @@\n-                        System.out.println(\"filetered out: \" + p.toString());\n+                        System.out.println(\"filtered out: \" + p.toString());\n@@ -261,1 +279,1 @@\n-        assertEquals(Files.walk(Paths.get(\"dumpLong\"))\n+        assertEquals(Files.walk(dumpDir)\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LogGeneratedClassesTest.java","additions":66,"deletions":48,"binary":false,"changes":114,"status":"modified"}]}