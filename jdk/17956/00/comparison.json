{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.security.PublicKey;\n@@ -43,0 +44,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -80,0 +82,17 @@\n+    private boolean ksP12;\n+    \/*\n+     * The credentials from the PKCS12KeyStore as\n+     * Map: String(builderIndex.entryAlias) -> X509Credentials(credentials)\n+     *\/\n+    private final Map<String, X509Credentials> credentialsMap;\n+\n+    private static class X509Credentials {\n+        final PrivateKey privateKey;\n+        final X509Certificate[] certificates;\n+\n+        X509Credentials(PrivateKey privateKey, X509Certificate[] certificates) {\n+            this.privateKey = privateKey;\n+            this.certificates = certificates;\n+        }\n+    }\n+\n@@ -87,2 +106,33 @@\n-        entryCacheMap = Collections.synchronizedMap\n-                        (new SizedMap<>());\n+        KeyStore keyStore = null;\n+        boolean foundPKCS12 = false;\n+\n+        for (int i = 0, n = builders.size(); i < n; i++) {\n+            try {\n+                Builder builder = builders.get(i);\n+                keyStore = builder.getKeyStore();\n+                if (keyStore == null) {\n+                    continue;\n+                }\n+                String ksType = keyStore.getType();\n+                if (ksType.equalsIgnoreCase(\"pkcs12\")) {\n+                    foundPKCS12 = true;\n+                    break;\n+                }\n+            } catch (Exception e) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                    SSLLogger.fine(\"KeyMgr: error occurred during \" +\n+                            \"getKeyStore() operation for Keystore builder\");\n+                }\n+            }\n+        }\n+\n+        if (foundPKCS12) {\n+            ksP12 = true;\n+            credentialsMap = new ConcurrentHashMap<>();\n+            entryCacheMap = null;\n+            initializeCredentials();\n+        } else {\n+            ksP12 = false;\n+            credentialsMap = null;\n+            entryCacheMap = Collections.synchronizedMap(new SizedMap<>());\n+        }\n@@ -102,0 +152,35 @@\n+    private void initializeCredentials() {\n+        for (int i = 0, n = builders.size(); i < n; i++) {\n+            try {\n+                Builder builder = builders.get(i);\n+                KeyStore keyStore = builder.getKeyStore();\n+                if (keyStore == null) {\n+                    continue;\n+                }\n+\n+                Enumeration<String> aliases = keyStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    String alias = aliases.nextElement();\n+                    if (!keyStore.isKeyEntry(alias)) {\n+                        continue;\n+                    }\n+\n+                    boolean mapEntryUpdated = processCredentials(builder,\n+                            i, alias);\n+                    if (!mapEntryUpdated){\n+                        if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                            SSLLogger.fine(\"KeyMgr: error occurred during \" +\n+                                    \"initializing cached map for PKCS12 \" +\n+                                    \"keystore\");\n+                        }\n+                    }\n+                }\n+            } catch (Exception e) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                    SSLLogger.fine(\"KeyMgr: error occurred during \" +\n+                            \"getKeyStore() operation for Keystore builder\");\n+                }\n+            }\n+        }\n+    }\n+\n@@ -108,0 +193,18 @@\n+        if (ksP12) {\n+            String builderAlias = removeAliasIndex(alias);\n+            if (builderAlias == null) {\n+                return null;\n+            }\n+\n+            X509Credentials cred = credentialsMap.get(builderAlias);\n+            if (cred == null || !areCertChainsEqual(builderAlias,\n+                    cred.certificates)) {\n+                if (updateCredentialsMap(builderAlias)) {\n+                    cred = credentialsMap.get(builderAlias);\n+                    return cred.certificates.clone();\n+                }\n+                return null;\n+            }\n+            return cred.certificates.clone();\n+        }\n+\n@@ -115,0 +218,18 @@\n+        if (ksP12) {\n+            String builderAlias = removeAliasIndex(alias);\n+            if (builderAlias == null) {\n+                return null;\n+            }\n+\n+            X509Credentials cred = credentialsMap.get(builderAlias);\n+            if (cred == null || !areCertChainsEqual(builderAlias,\n+                    cred.certificates)) {\n+                if (updateCredentialsMap(builderAlias)) {\n+                    cred = credentialsMap.get(builderAlias);\n+                    return cred.privateKey;\n+                }\n+                return null;\n+            }\n+            return cred.privateKey;\n+        }\n+\n@@ -183,0 +304,110 @@\n+    private String removeAliasIndex (String alias){\n+        if (alias == null) {\n+            return null;\n+        }\n+\n+        int firstDot = alias.indexOf('.');\n+        int secondDot = alias.indexOf('.', firstDot + 1);\n+        if ((firstDot == -1) || (secondDot == firstDot)) {\n+            \/\/ invalid alias\n+            return null;\n+        }\n+        return alias.substring(firstDot + 1);\n+    }\n+\n+    private boolean areCertChainsEqual(String builderAlias,\n+            X509Certificate[] cachedCerts) {\n+        int aDot = builderAlias.indexOf('.');\n+        int builderIndex = Integer.parseInt(builderAlias.substring(0, aDot));\n+        String entryAlias = builderAlias.substring(aDot + 1);\n+        try {\n+            Builder builder = builders.get(builderIndex);\n+            KeyStore keyStore = builder.getKeyStore();\n+            if (keyStore == null) {\n+                return false;\n+            }\n+            Certificate[] keyStoreCerts = keyStore.getCertificateChain(entryAlias);\n+            if (keyStoreCerts == null || keyStoreCerts.length == 0) {\n+                return false;\n+            }\n+\n+            \/\/ Convert KeyStore certificates to X509Certificates\n+            X509Certificate[] newCerts = Arrays.copyOf(keyStoreCerts,\n+                    keyStoreCerts.length, X509Certificate[].class);\n+            return Arrays.equals(cachedCerts, newCerts);\n+        } catch (Exception e) {\n+            return false;\n+        }\n+    }\n+\n+    private boolean processCredentials(Builder builder, int builderIndex,\n+            String alias) throws Exception {\n+        KeyStore keyStore = builder.getKeyStore();\n+        if (keyStore == null) {\n+            return false;\n+        }\n+\n+        Entry newEntry = keyStore.getEntry(alias,\n+                builder.getProtectionParameter(alias));\n+        if (!(newEntry instanceof PrivateKeyEntry)) {\n+            return false;\n+        }\n+\n+        PrivateKeyEntry privateKeyEntry = (PrivateKeyEntry) newEntry;\n+        PrivateKey privateKey = privateKeyEntry.getPrivateKey();\n+        Certificate[] certs = privateKeyEntry.getCertificateChain();\n+\n+        if ((certs == null) || (certs.length == 0) ||\n+                !(certs[0] instanceof X509Certificate)) {\n+            return false;\n+        }\n+\n+        if (!(certs instanceof X509Certificate[])) {\n+            Certificate[] tmp = new X509Certificate[certs.length];\n+            System.arraycopy(certs, 0, tmp, 0, certs.length);\n+            certs = tmp;\n+        }\n+\n+        X509Certificate cert = (X509Certificate) certs[0];\n+        PublicKey publicKey = cert.getPublicKey();\n+        if (!privateKey.getAlgorithm().equals(publicKey.getAlgorithm())) {\n+            return false;\n+        }\n+\n+        \/\/ Add to credentials map\n+        String builderAlias = builderIndex + \".\" + alias;\n+        X509Credentials cred = new X509Credentials(privateKey,\n+                (X509Certificate[]) certs);\n+        credentialsMap.put(builderAlias, cred);\n+\n+        if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+            SSLLogger.fine(\"found key for : \" +\n+                    \"keystore builder index = \" + builderIndex +\n+                    \" alias = \" + alias, (Object[]) certs);\n+        }\n+\n+        return true;\n+    }\n+\n+    \/\/ Update the credentialsMap with the up-to-date key and certificates\n+    private boolean updateCredentialsMap(String builderAlias) {\n+        int aDot = builderAlias.indexOf('.');\n+        int builderIndex = Integer.parseInt(builderAlias.substring(0, aDot));\n+        String entryAlias = builderAlias.substring(aDot + 1);\n+        Builder builder = builders.get(builderIndex);\n+\n+        try {\n+            boolean mapEntryUpdated = processCredentials(builder,\n+                    builderIndex, entryAlias);\n+            if (!mapEntryUpdated) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                    SSLLogger.fine(\"KeyMgr: error occurred during updating \" +\n+                            \"cached map for PKCS12 keystore\");\n+                }\n+            }\n+            return mapEntryUpdated;\n+        } catch (Exception e) {\n+            return false;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerImpl.java","additions":234,"deletions":3,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,3 @@\n+    @Param({\"SunX509\", \"PKIX\"})\n+    String keyMgr;\n+\n@@ -83,2 +86,1 @@\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\n-                KeyManagerFactory.getDefaultAlgorithm());\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(keyMgr);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SSLHandshake.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}