{"files":[{"patch":"@@ -1413,0 +1413,8 @@\n+  int base_offset1 = arrayOopDesc::base_offset_in_bytes(T_BYTE);\n+  int base_offset2 = arrayOopDesc::base_offset_in_bytes(T_CHAR);\n+\n+  assert((base_offset1 % (UseCompactObjectHeaders ? 4 :\n+                          (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n+  assert((base_offset2 % (UseCompactObjectHeaders ? 4 :\n+                          (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n+\n@@ -1430,0 +1438,18 @@\n+  \/\/ Load 4 bytes once to compare for alignment before main loop. Note that this\n+  \/\/ is only possible for LL\/UU case. We need to resort to load_long_misaligned\n+  \/\/ for both LU and UL cases.\n+  if (str1_isL == str2_isL) { \/\/ LL or UU\n+    beq(str1, str2, DONE);\n+    int base_offset = isLL ? base_offset1 : base_offset2;\n+    if (AvoidUnalignedAccesses && (base_offset % 8) != 0) {\n+      mv(t0, minCharsInWord \/ 2);\n+      ble(cnt2, t0, SHORT_STRING);\n+      lwu(tmp1, Address(str1));\n+      lwu(tmp2, Address(str2));\n+      bne(tmp1, tmp2, DIFFERENCE);\n+      addi(str1, str1, 4);\n+      addi(str2, str2, 4);\n+      subi(cnt2, cnt2, minCharsInWord \/ 2);\n+    }\n+  }\n+\n@@ -1438,2 +1464,8 @@\n-      \/\/ check if str1 and str2 is same pointer\n-      beq(str1, str2, DONE);\n+#ifdef ASSERT\n+      Label align_ok;\n+      orr(t0, str1, str2);\n+      andi(t0, t0, 0x7);\n+      beqz(t0, align_ok);\n+      stop(\"bad alignment\");\n+      bind(align_ok);\n+#endif\n@@ -1456,1 +1488,1 @@\n-      ld(tmp2, Address(str2));\n+      load_long_misaligned(tmp2, Address(str2), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n@@ -1469,1 +1501,1 @@\n-      ld(tmp1, Address(str1));\n+      load_long_misaligned(tmp1, Address(str1), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n@@ -1473,1 +1505,1 @@\n-      addi(cnt2, cnt2, -4);\n+      subi(cnt2, cnt2, 4);\n@@ -1499,1 +1531,1 @@\n-      ld(tmp2, Address(t0));\n+      load_long_misaligned(tmp2, Address(t0), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n@@ -1508,1 +1540,1 @@\n-      ld(tmp1, Address(t0));\n+      load_long_misaligned(tmp1, Address(t0), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n@@ -1641,0 +1673,3 @@\n+  assert((base_offset % (UseCompactObjectHeaders ? 4 :\n+                         (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n+\n@@ -1664,0 +1699,12 @@\n+\n+  \/\/ Load 4 bytes once to compare for alignment before main loop.\n+  if (AvoidUnalignedAccesses && (base_offset % 8) != 0) {\n+    subi(cnt1, cnt1, elem_per_word \/ 2);\n+    bltz(cnt1, TAIL03);\n+    lwu(tmp1, Address(a1));\n+    lwu(tmp2, Address(a2));\n+    addi(a1, a1, 4);\n+    addi(a2, a2, 4);\n+    bne(tmp1, tmp2, DONE);\n+  }\n+\n@@ -1668,0 +1715,9 @@\n+#ifdef ASSERT\n+  Label align_ok;\n+  orr(t0, a1, a2);\n+  andi(t0, t0, 0x7);\n+  beqz(t0, align_ok);\n+  stop(\"bad alignment\");\n+  bind(align_ok);\n+#endif\n+\n@@ -1733,1 +1789,1 @@\n-  Label SAME, DONE, SHORT, NEXT_WORD;\n+  Label SAME, DONE, SHORT, NEXT_WORD, TAIL03, TAIL01;\n@@ -1739,0 +1795,5 @@\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(T_BYTE);\n+\n+  assert((base_offset % (UseCompactObjectHeaders ? 4 :\n+                         (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n+\n@@ -1743,0 +1804,11 @@\n+  \/\/ Load 4 bytes once to compare for alignment before main loop.\n+  if (AvoidUnalignedAccesses && (base_offset % 8) != 0) {\n+    subi(cnt1, cnt1, 4);\n+    bltz(cnt1, TAIL03);\n+    lwu(tmp1, Address(a1));\n+    lwu(tmp2, Address(a2));\n+    addi(a1, a1, 4);\n+    addi(a2, a2, 4);\n+    bne(tmp1, tmp2, DONE);\n+  }\n+\n@@ -1747,0 +1819,9 @@\n+#ifdef ASSERT\n+  Label align_ok;\n+  orr(t0, a1, a2);\n+  andi(t0, t0, 0x7);\n+  beqz(t0, align_ok);\n+  stop(\"bad alignment\");\n+  bind(align_ok);\n+#endif\n+\n@@ -1761,2 +1842,0 @@\n-  Label TAIL03, TAIL01;\n-\n@@ -2516,0 +2595,3 @@\n+  assert((base_offset % (UseCompactObjectHeaders ? 4 :\n+                         (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":92,"deletions":10,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -4264,1 +4264,1 @@\n-      addi(tmp2, tmp1, -1);\n+      subi(tmp2, tmp1, 1);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2464,1 +2464,2 @@\n-  void compare_string_8_x_LU(Register tmpL, Register tmpU, Register strL, Register strU, Label& DIFF) {\n+  void compare_string_8_x_LU(Register tmpL, Register tmpU,\n+                             Register strL, Register strU, Label& DIFF) {\n@@ -2466,0 +2467,7 @@\n+\n+    int base_offset = arrayOopDesc::base_offset_in_bytes(T_CHAR);\n+\n+    assert((base_offset % (UseCompactObjectHeaders ? 4 :\n+                           (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n+\n+    \/\/ strL is 8-byte aligned\n@@ -2468,1 +2476,1 @@\n-    __ ld(tmpU, Address(strU));\n+    __ load_long_misaligned(tmpU, Address(strU), tmp, (base_offset % 8) != 0 ? 4 : 8);\n@@ -2491,1 +2499,3 @@\n-    StubCodeMark mark(this, \"StubRoutines\", isLU ? \"compare_long_string_different_encoding LU\" : \"compare_long_string_different_encoding UL\");\n+    StubCodeMark mark(this, \"StubRoutines\", isLU\n+        ? \"compare_long_string_different_encoding LU\"\n+        : \"compare_long_string_different_encoding UL\");\n@@ -2497,0 +2507,8 @@\n+    int base_offset1 = arrayOopDesc::base_offset_in_bytes(T_BYTE);\n+    int base_offset2 = arrayOopDesc::base_offset_in_bytes(T_CHAR);\n+\n+    assert((base_offset1 % (UseCompactObjectHeaders ? 4 :\n+                            (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n+    assert((base_offset2 % (UseCompactObjectHeaders ? 4 :\n+                            (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n+\n@@ -2513,11 +2531,13 @@\n-    \/\/ make sure main loop is 8 byte-aligned, we should load another 4 bytes from strL\n-    \/\/ cnt2 is >= 68 here, no need to check it for >= 0\n-    __ lwu(tmpL, Address(strL));\n-    __ addi(strL, strL, wordSize \/ 2);\n-    __ ld(tmpU, Address(strU));\n-    __ addi(strU, strU, wordSize);\n-    __ inflate_lo32(tmp3, tmpL);\n-    __ mv(tmpL, tmp3);\n-    __ xorr(tmp3, tmpU, tmpL);\n-    __ bnez(tmp3, CALCULATE_DIFFERENCE);\n-    __ addi(cnt2, cnt2, -wordSize \/ 2);\n+    if ((base_offset1 % 8) == 0) {\n+      \/\/ Load another 4 bytes from strL to make sure main loop is 8-byte aligned\n+      \/\/ cnt2 is >= 68 here, no need to check it for >= 0\n+      __ lwu(tmpL, Address(strL));\n+      __ addi(strL, strL, wordSize \/ 2);\n+      __ load_long_misaligned(tmpU, Address(strU), tmp4, (base_offset2 % 8) != 0 ? 4 : 8);\n+      __ addi(strU, strU, wordSize);\n+      __ inflate_lo32(tmp3, tmpL);\n+      __ mv(tmpL, tmp3);\n+      __ xorr(tmp3, tmpU, tmpL);\n+      __ bnez(tmp3, CALCULATE_DIFFERENCE);\n+      __ subi(cnt2, cnt2, wordSize \/ 2);\n+    }\n@@ -4447,1 +4467,1 @@\n-        __ addi(consts, consts, -total_adds);\n+        __ subi(consts, consts, total_adds);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":35,"deletions":15,"binary":false,"changes":50,"status":"modified"}]}