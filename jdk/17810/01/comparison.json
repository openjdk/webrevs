{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1300,1 +1300,2 @@\n-            var seltype = types.erasure(componentType);\n+            Type seltype = types.erasure(componentType);\n+            Type pattype = types.erasure(bp.type);\n@@ -1302,16 +1303,3 @@\n-            if (seltype.isPrimitive()) {\n-                if (types.isSameType(bp.type, types.boxedClass(seltype).type)) {\n-                    return true;\n-                }\n-\n-                \/\/ if the target is unconditionally exact to the pattern, target is covered\n-                if (types.isUnconditionallyExact(seltype, bp.type)) {\n-                    return true;\n-                }\n-            } else if (seltype.isReference() && bp.type.isPrimitive() && types.isCastable(seltype, bp.type)) {\n-                return true;\n-            } else {\n-                if (types.isSubtype(seltype, types.erasure(bp.type))) {\n-                    return true;\n-                }\n-            }\n+            return seltype.isPrimitive() ?\n+                    types.isUnconditionallyExact(seltype, pattype) :\n+                    (bp.type.isPrimitive() && types.isUnconditionallyExact(types.unboxedType(seltype), bp.type)) || types.isSubtype(seltype, pattype);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":6,"deletions":18,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 8304487\n+ * @bug 8304487 8325653\n@@ -220,0 +220,24 @@\n+\n+    public static int nonExhaustive4() {\n+        Number n = Byte.valueOf((byte) 42);\n+        return switch (n) { \/\/ Error - not exhaustive\n+            case byte  b when b == 42 -> 1;\n+            case byte  b -> -1 ;\n+        };\n+    }\n+\n+    public static int nonExhaustive5() {\n+        Object n = 42;\n+        return switch (n) { \/\/ Error - not exhaustive\n+            case int  b when b == 42 -> 1;\n+            case int  b -> -1 ;\n+        };\n+    }\n+\n+    public static int nonExhaustive6() {\n+        Object n = 42;\n+        return switch (n) { \/\/ Error - not exhaustive\n+            case byte b -> -1 ;\n+            case int b -> -2 ;\n+        };\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+PrimitivePatternsSwitchErrors.java:223:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:231:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:239:16: compiler.err.not.exhaustive\n@@ -37,1 +40,1 @@\n-34 errors\n\\ No newline at end of file\n+37 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.out","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}