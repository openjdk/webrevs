{"files":[{"patch":"@@ -24,0 +24,2 @@\n+import jdk.test.lib.Utils;\n+\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/RmiBootstrapTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.test.lib.Utils;\n@@ -147,39 +148,0 @@\n-    \/**\n-     * Grant file access.\n-     *\n-     * @param file   file to grant access\n-     * @param access user access or full access\n-     * @throws IOException if error occurs\n-     *\/\n-    static void grantAccess(Path file, AccessControl access) throws IOException {\n-        Set<String> attr = file.getFileSystem().supportedFileAttributeViews();\n-        if (attr.contains(\"posix\")) {\n-            String perms = access == AccessControl.OWNER ? \"rw-------\" : \"rwxrwxrwx\";\n-            Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(perms));\n-        } else if (attr.contains(\"acl\")) {\n-            AclFileAttributeView view = Files.getFileAttributeView(file, AclFileAttributeView.class);\n-            List<AclEntry> acl = new ArrayList<>();\n-            for (AclEntry thisEntry : view.getAcl()) {\n-                if (access == AccessControl.OWNER) {\n-                    if (thisEntry.principal().getName().equals(view.getOwner().getName())) {\n-                        acl.add(Utils.allowAccess(thisEntry));\n-                    } else if (thisEntry.type() == AclEntryType.ALLOW) {\n-                        acl.add(Utils.revokeAccess(thisEntry));\n-                    } else {\n-                        acl.add(thisEntry);\n-                    }\n-                } else {\n-                    if (!thisEntry.principal().getName().contains(\"NULL SID\")\n-                            && thisEntry.type() != AclEntryType.ALLOW) {\n-                        acl.add(Utils.allowAccess(thisEntry));\n-                    } else {\n-                        acl.add(thisEntry);\n-                    }\n-                }\n-            }\n-            view.setAcl(acl);\n-        } else {\n-            throw new RuntimeException(\"Unsupported file attributes: \" + attr);\n-        }\n-    }\n-\n@@ -193,1 +155,2 @@\n-    static void grantFilesAccess(List<Path> files, AccessControl access) throws IOException {\n+    static void grantFilesAccess(List<Path> files, AccessControl access)\n+            throws IOException {\n@@ -195,1 +158,1 @@\n-            grantAccess(thisFile, access);\n+            Utils.grantFileAccess(thisFile, access == AccessControl.OWNER);\n@@ -212,1 +175,1 @@\n-            grantAccess(sslTarget.resolve(file.getFileName()), AccessControl.EVERYONE);\n+            Utils.fullAccess(sslTarget.resolve(file.getFileName()));\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/RmiTestBase.java","additions":5,"deletions":42,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1,195 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.nio.file.CopyOption;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.attribute.*;\n-import java.util.*;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * Utility class.\n- *\/\n-public class Utils {\n-    static private String fileSeparator = System.getProperty(\"file.separator\");\n-\n-    \/**\n-     * Converts slashes in a pathname to backslashes\n-     * if slashes is not the file separator.\n-     *\/\n-    static String convertPath(String path) {\n-        \/\/ No need to do the conversion if file separator is '\/'\n-        if (fileSeparator.length() == 1 && fileSeparator.charAt(0) == '\/') {\n-            return path;\n-        }\n-\n-        char[] cs = path.toCharArray();\n-        for (int i = 0; i < cs.length; i++) {\n-            if (cs[i] == '\/') {\n-                cs[i] = '\\\\';\n-            }\n-        }\n-        String newPath = new String(cs);\n-        return newPath;\n-    }\n-\n-    \/**\n-     * Return file directories that satisfy the specified filter.\n-     *\n-     * @param searchDirectory the base directory to search\n-     * @param filter          a filename filter\n-     * @return                file directories\n-     *\/\n-    public static List<Path> findFiles(Path searchDirectory,\n-            FilenameFilter filter) {\n-        return Arrays.stream(searchDirectory.toFile().listFiles(filter))\n-                .map(f -> f.toPath())\n-                .collect(Collectors.toList());\n-    }\n-\n-    \/**\n-     * Copy files to the target path.\n-     *\n-     * @param source         the paths to the files to copy\n-     * @param target         the path to the target files\n-     * @param filenameMapper mapper function applied to filenames\n-     * @param options        options specifying how the copy should be done\n-     * @return               the paths to the target files\n-     * @throws IOException   if error occurs\n-     *\/\n-    public static List<Path> copyFiles(List<Path> source, Path target,\n-            Function<String, String> filenameMapper,\n-            CopyOption... options) throws IOException {\n-        List<Path> result = new ArrayList<>();\n-\n-        if (!target.toFile().exists()) {\n-            Files.createDirectory(target);\n-        }\n-\n-        for (Path file : source) {\n-            if (!file.toFile().exists()) {\n-                continue;\n-            }\n-\n-            String baseName = file.getFileName().toString();\n-\n-            Path targetFile = target.resolve(filenameMapper.apply(baseName));\n-            Files.copy(file, targetFile, options);\n-            result.add(targetFile);\n-        }\n-        return result;\n-    }\n-\n-    \/**\n-     * Copy files to the target path.\n-     *\n-     * @param source         the paths to the files to copy\n-     * @param target         the path to the target files\n-     * @param options        options specifying how the copy should be done\n-     * @return               the paths to the target files\n-     * @throws IOException   if error occurs\n-     *\/\n-    public static List<Path> copyFiles(List<Path> source, Path target,\n-            CopyOption... options) throws IOException {\n-        return copyFiles(source, target, (s) -> s, options);\n-    }\n-\n-    \/**\n-     * Return an ACL entry that revokes owner access.\n-     *\n-     * @param acl   original ACL entry to build from\n-     * @return      an ACL entry that revokes all access\n-     *\/\n-    public static AclEntry revokeAccess(AclEntry acl) {\n-        return buildAclEntry(acl, AclEntryType.DENY);\n-    }\n-\n-    \/**\n-     * Return an ACL entry that allow owner access.\n-     * @param acl   original ACL entry to build from\n-     * @return      an ACL entry that allows all access\n-     *\/\n-    public static AclEntry allowAccess(AclEntry acl) {\n-        return buildAclEntry(acl, AclEntryType.ALLOW);\n-    }\n-\n-    \/**\n-     * Build an ACL entry with a given ACL entry type.\n-     *\n-     * @param acl   original ACL entry to build from\n-     * @return      an ACL entry with a given ACL entry type\n-     *\/\n-    public static AclEntry buildAclEntry(AclEntry acl, AclEntryType type) {\n-        return AclEntry.newBuilder()\n-                .setType(type)\n-                .setPrincipal(acl.principal())\n-                .setPermissions(acl.permissions())\n-                .build();\n-    }\n-\n-    \/**\n-     * Replace file string by applying the given mapper function.\n-     *\n-     * @param source        the file to read\n-     * @param contentMapper the mapper function applied to file's content\n-     * @throws IOException  if an I\/O error occurs\n-     *\/\n-    public static void replaceFileString(Path source,\n-            Function<String, String> contentMapper) throws IOException {\n-        StringBuilder sb = new StringBuilder();\n-        String lineSep = System.getProperty(\"line.separator\");\n-\n-        try (BufferedReader reader =\n-                new BufferedReader(new FileReader(source.toFile()))) {\n-\n-            String line;\n-\n-            \/\/ read all and replace all at once??\n-            while ((line = reader.readLine()) != null) {\n-                sb.append(contentMapper.apply(line))\n-                        .append(lineSep);\n-            }\n-        }\n-\n-        try (FileWriter writer = new FileWriter(source.toFile())) {\n-            writer.write(sb.toString());\n-        }\n-    }\n-\n-    \/**\n-     * Replace files' string by applying the given mapper function.\n-     *\n-     * @param source        the file to read\n-     * @param contentMapper the mapper function applied to files' content\n-     * @throws IOException  if an I\/O error occurs\n-     *\/\n-    public static void replaceFilesString(List<Path> source,\n-            Function<String, String> contentMapper) throws IOException {\n-        for (Path file : source) {\n-            replaceFileString(file, contentMapper);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/Utils.java","additions":0,"deletions":195,"binary":false,"changes":195,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+import java.io.BufferedReader;\n@@ -27,0 +28,3 @@\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.FilenameFilter;\n@@ -38,0 +42,1 @@\n+import java.nio.file.CopyOption;\n@@ -41,0 +46,3 @@\n+import java.nio.file.attribute.AclEntry;\n+import java.nio.file.attribute.AclEntryType;\n+import java.nio.file.attribute.AclFileAttributeView;\n@@ -43,0 +51,1 @@\n+import java.nio.file.attribute.PosixFilePermissions;\n@@ -56,0 +65,1 @@\n+import java.util.Set;\n@@ -62,0 +72,1 @@\n+import java.util.stream.Collectors;\n@@ -132,0 +143,5 @@\n+    \/**\n+     * Returns the value of 'file.separator' system property\n+     *\/\n+    public static final String FILE_SEPARATOR = System.getProperty(\"file.separator\");\n+\n@@ -821,0 +837,196 @@\n+\n+    \/**\n+     * Converts slashes in a pathname to backslashes\n+     * if slashes is not the file separator.\n+     *\/\n+    public static String convertPath(String path) {\n+        \/\/ No need to do the conversion if file separator is '\/'\n+        if (FILE_SEPARATOR.length() == 1 && FILE_SEPARATOR.charAt(0) == '\/') {\n+            return path;\n+        }\n+\n+        char[] cs = path.toCharArray();\n+        for (int i = 0; i < cs.length; i++) {\n+            if (cs[i] == '\/') {\n+                cs[i] = '\\\\';\n+            }\n+        }\n+        String newPath = new String(cs);\n+        return newPath;\n+    }\n+\n+    \/**\n+     * Return file directories that satisfy the specified filter.\n+     *\n+     * @param searchDirectory the base directory to search\n+     * @param filter          a filename filter\n+     * @return                file directories\n+     *\/\n+    public static List<Path> findFiles(Path searchDirectory,\n+            FilenameFilter filter) {\n+        return Arrays.stream(searchDirectory.toFile().listFiles(filter))\n+                .map(f -> f.toPath())\n+                .collect(Collectors.toList());\n+    }\n+\n+    \/**\n+     * Copy files to the target path.\n+     *\n+     * @param source         the paths to the files to copy\n+     * @param target         the path to the target files\n+     * @param filenameMapper mapper function applied to filenames\n+     * @param options        options specifying how the copy should be done\n+     * @return               the paths to the target files\n+     * @throws IOException   if error occurs\n+     *\/\n+    public static List<Path> copyFiles(List<Path> source, Path target,\n+            Function<String, String> filenameMapper,\n+            CopyOption... options) throws IOException {\n+        List<Path> result = new ArrayList<>();\n+\n+        if (!target.toFile().exists()) {\n+            Files.createDirectory(target);\n+        }\n+\n+        for (Path file : source) {\n+            if (!file.toFile().exists()) {\n+                continue;\n+            }\n+\n+            String baseName = file.getFileName().toString();\n+\n+            Path targetFile = target.resolve(filenameMapper.apply(baseName));\n+            Files.copy(file, targetFile, options);\n+            result.add(targetFile);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Copy files to the target path.\n+     *\n+     * @param source         the paths to the files to copy\n+     * @param target         the path to the target files\n+     * @param options        options specifying how the copy should be done\n+     * @return               the paths to the target files\n+     * @throws IOException   if error occurs\n+     *\/\n+    public static List<Path> copyFiles(List<Path> source, Path target,\n+            CopyOption... options) throws IOException {\n+        return copyFiles(source, target, (s) -> s, options);\n+    }\n+\n+    \/**\n+     * Replace file string by applying the given mapper function.\n+     *\n+     * @param source        the file to read\n+     * @param contentMapper the mapper function applied to file's content\n+     * @throws IOException  if an I\/O error occurs\n+     *\/\n+    public static void replaceFileString(Path source,\n+            Function<String, String> contentMapper) throws IOException {\n+        StringBuilder sb = new StringBuilder();\n+        String lineSep = System.getProperty(\"line.separator\");\n+\n+        try (BufferedReader reader =\n+                new BufferedReader(new FileReader(source.toFile()))) {\n+\n+            String line;\n+\n+            \/\/ read all and replace all at once??\n+            while ((line = reader.readLine()) != null) {\n+                sb.append(contentMapper.apply(line))\n+                        .append(lineSep);\n+            }\n+        }\n+\n+        try (FileWriter writer = new FileWriter(source.toFile())) {\n+            writer.write(sb.toString());\n+        }\n+    }\n+\n+    \/**\n+     * Replace files' string by applying the given mapper function.\n+     *\n+     * @param source        the file to read\n+     * @param contentMapper the mapper function applied to files' content\n+     * @throws IOException  if an I\/O error occurs\n+     *\/\n+    public static void replaceFilesString(List<Path> source,\n+            Function<String, String> contentMapper) throws IOException {\n+        for (Path file : source) {\n+            replaceFileString(file, contentMapper);\n+        }\n+    }\n+\n+    \/**\n+     * Grant file user access or full access to everyone.\n+     *\n+     * @param file   file to grant access\n+     * @param userOnly true for user access, otherwise full access to everyone\n+     * @throws IOException if error occurs\n+     *\/\n+    public static void grantFileAccess(Path file, boolean userOnly)\n+            throws IOException {\n+        Set<String> attr = file.getFileSystem().supportedFileAttributeViews();\n+        if (attr.contains(\"posix\")) {\n+            if (userOnly) {\n+                Files.setPosixFilePermissions(file,\n+                        PosixFilePermissions.fromString(\"rwx------\"));\n+            } else { \/* Allow access to everyone *\/\n+                Files.setPosixFilePermissions(file,\n+                        PosixFilePermissions.fromString(\"rwxrwxrwx\"));\n+            }\n+        } else if (attr.contains(\"acl\")) {\n+            AclFileAttributeView view =\n+                    Files.getFileAttributeView(file, AclFileAttributeView.class);\n+            List<AclEntry> acl = new ArrayList<>();\n+            for (AclEntry thisEntry : view.getAcl()) {\n+                if (userOnly) {\n+                    if (thisEntry.principal().getName()\n+                            .equals(view.getOwner().getName())) {\n+                        acl.add(AclEntry.newBuilder(thisEntry)\n+                                .setType(AclEntryType.ALLOW)\n+                                .build());\n+                    } else if (thisEntry.type() == AclEntryType.ALLOW) {\n+                        acl.add(AclEntry.newBuilder(thisEntry)\n+                                .setType(AclEntryType.DENY)\n+                                .build());\n+                    } else {\n+                        acl.add(thisEntry);\n+                    }\n+                } else {\n+                    if (thisEntry.type() != AclEntryType.ALLOW) {\n+                        acl.add(AclEntry.newBuilder(thisEntry)\n+                                .setType(AclEntryType.ALLOW)\n+                                .build());\n+                    } else {\n+                        acl.add(thisEntry);\n+                    }\n+                }\n+            }\n+            view.setAcl(acl);\n+        } else {\n+            throw new RuntimeException(\"Unsupported file attributes: \" + attr);\n+        }\n+    }\n+\n+    \/**\n+     * Grant file user access.\n+     *\n+     * @param file   file to grant access\n+     * @throws IOException if error occurs\n+     *\/\n+    public static void userAccess(Path file) throws IOException {\n+        grantFileAccess(file, true);\n+    }\n+\n+    \/**\n+     * Grant file full access to everyone.\n+     *\n+     * @param file   file to grant access\n+     * @throws IOException if error occurs\n+     *\/\n+    public static void fullAccess(Path file) throws IOException {\n+        grantFileAccess(file, false);\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/Utils.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"modified"}]}