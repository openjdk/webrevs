{"files":[{"patch":"@@ -33,0 +33,1 @@\n+#include \"logging\/log.hpp\"\n@@ -38,0 +39,27 @@\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/stack.inline.hpp\"\n+\n+#ifdef ASSERT\n+void DFSClosure::log_reference_stack() {\n+  LogTarget(Trace, jfr, system, dfs) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print_cr(\"--- ref stack ---\");\n+    for (size_t i = 0; i <= _current_depth; i++) {\n+      const void* refaddr = (void*)_reference_stack[i].addr<uintptr_t>();\n+      if (refaddr != 0) {\n+        const oop pointee = _reference_stack[i].dereference();\n+        ls.print(PTR_FORMAT \" \" PTR_FORMAT \" : \", p2i(refaddr), p2i(pointee));\n+        if (pointee != nullptr) {\n+          pointee->klass()->name()->print_value_on(&ls);\n+        }\n+      } else {\n+        ls.print(PTR_FORMAT \" ??? : \", p2i(refaddr));\n+      }\n+      ls.cr();\n+    }\n+    ls.print_cr(\"--- \/ref stack ---\");\n+  }\n+}\n+#endif \/\/ ASSERT\n@@ -50,1 +78,6 @@\n-  start_edge->pointee()->oop_iterate(&dfs);\n+  log_debug(jfr, system, dfs)(\"DFS: scanning from edge\");\n+  const UnifiedOopRef ref = start_edge->reference();\n+  const oop obj = ref.dereference();\n+  dfs.probe_stack_push(ref, obj, 0);\n+  dfs.drain_probe_stack();\n+  log_debug(jfr, system, dfs)(\"DFS: done\");\n@@ -58,1 +91,3 @@\n-  \/\/ Mark root set, to avoid going sideways\n+  \/\/ Mark root set, to avoid going sideways. The intent here is to prevent\n+  \/\/ long reference chains that would be caused by tracing through multiple root\n+  \/\/ objects.\n@@ -62,0 +97,1 @@\n+  log_debug(jfr, system, dfs)(\"DFS: scanning roots...\");\n@@ -63,0 +99,1 @@\n+  dfs.drain_probe_stack();\n@@ -67,0 +104,1 @@\n+  log_debug(jfr, system, dfs)(\"DFS: scanning in depth ...\");\n@@ -68,0 +106,2 @@\n+  dfs.drain_probe_stack();\n+  log_debug(jfr, system, dfs)(\"DFS: done\");\n@@ -70,0 +110,23 @@\n+\/\/ Memory usage of DFS search is dominated by probe stack usage, which is\n+\/\/ (avg. number of outgoing references per oop) * depth.\n+\/\/\n+\/\/ We disregard objArrayOop: deep graphs of broad object arrays are rare.\n+\/\/ But we also use array chunking, to be on the safe side.\n+\/\/\n+\/\/ Statistically, instanceKlass oopmaps are very small. Moreover, deep\n+\/\/ graphs will typically consist of heavy hitters like LinkedListNode,\n+\/\/ which has just two references that need to be pushed onto the probe stack\n+\/\/ (its backward reference is typically already marked).\n+\/\/\n+\/\/ Hence, at max_dfs_depth of 4000, on average we have a probe stack depth of\n+\/\/ ~10000, which costs us <~160KB. In practice, these numbers seem to be even\n+\/\/ smaller. Not a problem at all.\n+\/\/\n+\/\/ But we could run into weird pathological object graphs. Therfore we also\n+\/\/ cap the max size of the probe stack. When we hit it, we deal with it the same\n+\/\/ way we deal with reaching max_dfs_depth - by aborting the trace of that\n+\/\/ particular graph edge.\n+static constexpr size_t max_probe_stack_elems = 256 * K; \/\/ 4 MB\n+\n+static constexpr int array_chunk_size = 64;\n+\n@@ -72,1 +135,45 @@\n-  _max_depth(max_dfs_depth), _depth(0), _ignore_root_set(false) {\n+  _max_depth(max_dfs_depth), _ignore_root_set(false),\n+  _probe_stack(1024, 4, max_probe_stack_elems),\n+  _current_ref(UnifiedOopRef::encode_null()),\n+  _current_pointee(nullptr),\n+  _current_depth(0),\n+  _current_chunkindex(0),\n+  _num_objects_processed(0),\n+  _num_sampled_objects_found(0),\n+  _times_max_depth_reached(0),\n+  _times_probe_stack_full(0)\n+{\n+}\n+\n+DFSClosure::~DFSClosure() {\n+  if (!GranularTimer::is_finished()) {\n+    assert(_probe_stack.is_empty(), \"We should have drained the probe stack?\");\n+  }\n+  log_info(jfr, system, dfs)(\"DFS: objects processed: \" UINT64_FORMAT \",\"\n+       \" sampled objects found: \" UINT64_FORMAT \",\"\n+       \" reached max graph depth: \" UINT64_FORMAT \",\"\n+       \" reached max probe stack depth: \" UINT64_FORMAT,\n+      _num_objects_processed, _num_sampled_objects_found,\n+      _times_max_depth_reached, _times_probe_stack_full);\n+}\n+\n+void DFSClosure::probe_stack_push(UnifiedOopRef ref, oop pointee, size_t depth) {\n+\n+  assert(!ref.is_null(), \"invariant\");\n+\n+  if (_probe_stack.is_full()) {\n+    _times_probe_stack_full ++;\n+    return;\n+  }\n+\n+  if (pointee == nullptr) {\n+    return;\n+  }\n+\n+  if (depth > 0 && pointee_was_visited(pointee)) {\n+    \/\/ Optimization: don't push if marked (special handling for root oops)\n+    return;\n+  }\n+\n+  ProbeStackItem item { ref, checked_cast<unsigned>(depth), 0 };\n+  _probe_stack.push(item);\n@@ -75,1 +182,3 @@\n-void DFSClosure::closure_impl(UnifiedOopRef reference, const oop pointee) {\n+void DFSClosure::probe_stack_push_followup_chunk(UnifiedOopRef ref, oop pointee, size_t depth, int chunkindex) {\n+\n+  assert(!ref.is_null(), \"invariant\");\n@@ -77,1 +186,1 @@\n-  assert(!reference.is_null(), \"invariant\");\n+  assert(chunkindex > 0, \"invariant\");\n@@ -79,1 +188,2 @@\n-  if (GranularTimer::is_finished()) {\n+  if (_probe_stack.is_full()) {\n+    _times_probe_stack_full ++;\n@@ -83,5 +193,35 @@\n-  if (_depth == 0 && _ignore_root_set) {\n-    \/\/ Root set is already marked, but we want\n-    \/\/ to continue, so skip is_marked check.\n-    assert(_mark_bits->is_marked(pointee), \"invariant\");\n-    _reference_stack[_depth] = reference;\n+  ProbeStackItem item { ref, checked_cast<unsigned>(depth), chunkindex };\n+  _probe_stack.push(item);\n+}\n+\n+bool DFSClosure::probe_stack_pop() {\n+\n+  if (_probe_stack.is_empty()) {\n+    _current_ref = UnifiedOopRef::encode_null();\n+    _current_pointee = nullptr;\n+    _current_depth = 0;\n+    _current_chunkindex = 0;\n+    return false;\n+  }\n+\n+  ProbeStackItem item = _probe_stack.pop();\n+  _current_ref = item.r;\n+  assert(!_current_ref.is_null(), \"invariant\");\n+  _current_depth = item.depth;\n+  assert(_current_depth < _max_depth, \"invariant\");\n+  _current_chunkindex = item.chunkindex;\n+  assert(_current_chunkindex >= 0, \"invariant\");\n+\n+  _current_pointee = _current_ref.dereference();\n+\n+  _num_objects_processed++;\n+\n+  return true;\n+}\n+\n+void DFSClosure::handle_oop() {\n+\n+  if (_current_depth == 0 && _ignore_root_set) {\n+    assert(pointee_was_visited(_current_pointee), \"We should have already visited roots\");\n+    _reference_stack[_current_depth] = _current_ref;\n+    \/\/ continue since we want to process children, too\n@@ -89,2 +229,2 @@\n-    if (_mark_bits->is_marked(pointee)) {\n-      return;\n+    if (pointee_was_visited(_current_pointee)) {\n+      return; \/\/ already processed\n@@ -92,4 +232,3 @@\n-    _mark_bits->mark_obj(pointee);\n-    _reference_stack[_depth] = reference;\n-    \/\/ is the pointee a sample object?\n-    if (pointee->mark().is_marked()) {\n+    mark_pointee_as_visited(_current_pointee);\n+    _reference_stack[_current_depth] = _current_ref;\n+    if (pointee_was_sampled(_current_pointee)) {\n@@ -99,6 +238,77 @@\n-  assert(_max_depth >= 1, \"invariant\");\n-  if (_depth < _max_depth - 1) {\n-    _depth++;\n-    pointee->oop_iterate(this);\n-    assert(_depth > 0, \"invariant\");\n-    _depth--;\n+\n+  \/\/ trace children if needed\n+  if (_current_depth == _max_depth - 1) {\n+    _times_max_depth_reached ++;\n+    return; \/\/ stop following this chain\n+  }\n+\n+  _current_depth ++;\n+  _current_pointee->oop_iterate(this);\n+  _current_depth --;\n+}\n+\n+void DFSClosure::handle_objarrayoop() {\n+\n+  if (_current_depth == 0 && _ignore_root_set) {\n+    assert(pointee_was_visited(_current_pointee), \"We should have already visited roots\");\n+    _reference_stack[_current_depth] = _current_ref;\n+    \/\/ continue since we want to process children, too\n+  } else {\n+\n+    if (_current_chunkindex == 0) {\n+      \/\/ For the first chunk only, check, process and mark the array oop itself.\n+      if (pointee_was_visited(_current_pointee)) {\n+        return; \/\/ already processed\n+      }\n+      mark_pointee_as_visited(_current_pointee);\n+      _reference_stack[_current_depth] = _current_ref;\n+\n+      if (pointee_was_sampled(_current_pointee)) {\n+        add_chain();\n+      }\n+    }\n+  }\n+\n+  \/\/ trace children if needed\n+\n+  if (_current_depth == _max_depth - 1) {\n+    _times_max_depth_reached ++;\n+    return; \/\/ stop following this chain\n+  }\n+\n+  const objArrayOop pointee_oa = (objArrayOop) _current_pointee;\n+  const int array_len = pointee_oa->length();\n+  if (array_len == 0) {\n+    return;\n+  }\n+  const int begidx = _current_chunkindex * array_chunk_size;\n+  const int endidx = MIN2(array_len, (_current_chunkindex + 1) * array_chunk_size);\n+  assert(begidx < endidx, \"invariant\");\n+\n+  \/\/ Push follow-up chunk\n+  if (endidx < array_len) {\n+    probe_stack_push_followup_chunk(_current_ref, _current_pointee, _current_depth, _current_chunkindex + 1);\n+  }\n+\n+  \/\/ push child references\n+  _current_depth ++;\n+  pointee_oa->oop_iterate_elements_range(this, begidx, endidx);\n+  _current_depth --;\n+}\n+\n+void DFSClosure::drain_probe_stack() {\n+\n+  DEBUG_ONLY(size_t last_depth = 0;)\n+\n+  while (probe_stack_pop() && !GranularTimer::is_finished()) {\n+\n+    \/\/ We should not dive downward more than 1 indirection.\n+    assert(_current_depth <= (last_depth + 1), \"invariant\");\n+\n+    if (_current_pointee->is_objArray()) {\n+      handle_objarrayoop();\n+    } else {\n+      handle_oop();\n+    }\n+\n+    DEBUG_ONLY(last_depth = _current_depth;)\n@@ -109,1 +319,1 @@\n-  const size_t array_length = _depth + 2;\n+  const size_t array_length = _current_depth + 2;\n@@ -115,0 +325,7 @@\n+  _num_sampled_objects_found++;\n+\n+#ifdef ASSERT\n+  log_trace(jfr, system, dfs)(\"Sample object found (\" UINT64_FORMAT \" so far)\", _num_sampled_objects_found);\n+  log_reference_stack();\n+#endif\n+\n@@ -116,1 +333,1 @@\n-  for (size_t i = 0; i <= _depth; i++) {\n+  for (size_t i = 0; i <= _current_depth; i++) {\n@@ -118,2 +335,2 @@\n-    const size_t depth = _depth - i;\n-    chain[idx++] = Edge(&chain[next], _reference_stack[depth]);\n+    const size_t d = _current_depth - i;\n+    chain[idx++] = Edge(&chain[next], _reference_stack[d]);\n@@ -121,1 +338,1 @@\n-  assert(_depth + 1 == idx, \"invariant\");\n+  assert(_current_depth + 1 == idx, \"invariant\");\n@@ -137,3 +354,1 @@\n-  if (pointee != nullptr) {\n-    closure_impl(UnifiedOopRef::encode_in_heap(ref), pointee);\n-  }\n+  probe_stack_push(UnifiedOopRef::encode_in_heap(ref), pointee, _current_depth);\n@@ -146,3 +361,1 @@\n-  if (pointee != nullptr) {\n-    closure_impl(UnifiedOopRef::encode_in_heap(ref), pointee);\n-  }\n+  probe_stack_push(UnifiedOopRef::encode_in_heap(ref), pointee, _current_depth);\n@@ -155,1 +368,1 @@\n-  closure_impl(ref, pointee);\n+  probe_stack_push(ref, pointee, 0);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.cpp","additions":248,"deletions":35,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+#include \"nmt\/memTag.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/stack.inline.hpp\"\n@@ -39,2 +42,1 @@\n-  \/\/ max dfs depth should not exceed size of stack\n-  static const size_t max_dfs_depth = 3200;\n+  static const size_t max_dfs_depth = 4000;\n@@ -47,1 +49,0 @@\n-  size_t _depth;\n@@ -51,0 +52,1 @@\n+  ~DFSClosure();\n@@ -53,1 +55,30 @@\n-  void closure_impl(UnifiedOopRef reference, const oop pointee);\n+\n+  struct ProbeStackItem { \/\/ 16 bytes\n+    UnifiedOopRef r;\n+    unsigned depth;\n+    int chunkindex; \/\/ only used if objArrayOop\n+  };\n+  Stack<ProbeStackItem, mtTracing> _probe_stack;\n+\n+  \/\/ Walkstate\n+  UnifiedOopRef _current_ref;\n+  oop _current_pointee;\n+  size_t _current_depth;\n+  int _current_chunkindex;\n+  uint64_t _num_objects_processed;\n+  uint64_t _num_sampled_objects_found;\n+  uint64_t _times_max_depth_reached;\n+  uint64_t _times_probe_stack_full;\n+\n+  bool pointee_was_visited(const oop pointee) const { return _mark_bits->is_marked(pointee); }\n+  void mark_pointee_as_visited(const oop pointee)   { _mark_bits->mark_obj(pointee); }\n+  bool pointee_was_sampled(const oop pointee) const { return pointee->mark().is_marked(); }\n+\n+  void probe_stack_push_followup_chunk(UnifiedOopRef ref, oop pointee, size_t depth, int chunkindex);\n+  void probe_stack_push(UnifiedOopRef ref, oop pointee, size_t depth);\n+  bool probe_stack_pop();\n+  void drain_probe_stack();\n+  void handle_oop();\n+  void handle_objarrayoop();\n+\n+  void log_reference_stack() DEBUG_ONLY(;) NOT_DEBUG({})\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.hpp","additions":35,"deletions":4,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -49,1 +49,2 @@\n-  _sampler(sampler),_edge_store(edge_store), _cutoff_ticks(cutoff), _emit_all(emit_all), _skip_bfs(skip_bfs) {}\n+  _sampler(sampler),_edge_store(edge_store), _cutoff_ticks(cutoff), _emit_all(emit_all),\n+  _skip_bfs(skip_bfs) {}\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/pathToGcRootsOperation.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+  LOG_TAG(dfs) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -715,1 +715,0 @@\n-jdk\/jfr\/jvm\/TestWaste.java                                      8371630 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jcmd;\n+\n+import java.util.LinkedList;\n+import java.util.Random;\n+\n+\/**\n+ * @test\n+ * @summary Test dumping with path-to-gc-roots and DFS only, excercise the array chunking path\n+ * @requires vm.hasJFR & vm.flagless\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @library \/test\/lib \/test\/jdk\n+ *\n+ * @run main\/othervm -Xmx1g jdk.jfr.jcmd.TestJcmdDumpPathToGCRootsDFSArrayChunking\n+ *\/\n+public class TestJcmdDumpPathToGCRootsDFSArrayChunking extends TestJcmdDumpPathToGCRootsDFSBase {\n+\n+    \/\/ Tests that array chunking works correctly. We create an object array; link a second object array\n+    \/\/ into it at its middle; link a third object array into the second at its end; fill the third array with\n+    \/\/ many objects. GC root search should walk successfully through the middle of the first and the end of\n+    \/\/ the second to the third array and sample a good portion of its objects.\n+\n+    private static final int TOTAL_OBJECTS = 10_000_000;\n+    private static final int arrayChunkSize = 64; \/\/ keep in sync with dfsClosure.cpp\n+    private Object[] leak;\n+\n+    @Override\n+    protected final void buildLeak() {\n+        final int arraySize = (arrayChunkSize * 10) + arrayChunkSize \/ 2;\n+        Object[] first = new Object[arraySize];\n+        Object[] second = new Object[arraySize];\n+        Object[] third = new Object[TOTAL_OBJECTS];\n+        for (int i = 0; i < third.length; i++) {\n+            third[i] = new Object();\n+        }\n+        second[second.length - 1] = third;\n+        first[first.length \/ 2] = second;\n+        leak = first;\n+    }\n+\n+    protected final void clearLeak() {\n+        leak = null;\n+        System.gc();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new TestJcmdDumpPathToGCRootsDFSArrayChunking().testDump(\"TestJcmdDumpPathToGCRootsDFSArrayChunking\", 30);\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdDumpPathToGCRootsDFSArrayChunking.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jcmd;\n+\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedObject;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.jfr.internal.test.WhiteBox;\n+import jdk.test.lib.jfr.EventNames;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.*;\n+\n+public abstract class TestJcmdDumpPathToGCRootsDFSBase {\n+\n+    protected abstract void buildLeak();\n+    protected abstract void clearLeak();\n+\n+    protected void testDump(String jfrFileName, int minChainsExpected) throws Exception {\n+        WhiteBox.setWriteAllObjectSamples(true);\n+        WhiteBox.setSkipBFS(true);\n+        final String settingName = EventNames.OldObjectSample + \"#\" + \"cutoff\";\n+        Map<String, String> settings = Collections.singletonMap(settingName, \"infinity\");\n+        final String pathToGcRoots = \"path-to-gc-roots=true\";\n+        int numTries = 10;\n+        while (--numTries >= 0) {\n+            try (Recording r = new Recording()) {\n+                Map<String, String> p = new HashMap<>(settings);\n+                p.put(EventNames.OldObjectSample + \"#\" + Enabled.NAME, \"true\");\n+                r.setName(\"dodo\");\n+                r.setSettings(p);\n+                r.setToDisk(true);\n+                r.start();\n+                clearLeak();\n+                System.out.println(\"Recording id: \" + r.getId());\n+                System.out.println(\"Settings: \" + settings.toString());\n+                System.out.println(\"Command: JFR.dump \" + pathToGcRoots);\n+                buildLeak();\n+                System.gc();\n+                System.gc();\n+                File recording = new File(jfrFileName + r.getId() + \".jfr\");\n+                recording.delete();\n+                JcmdHelper.jcmd(\"JFR.dump\", \"name=dodo\", pathToGcRoots, \"filename=\" + recording.getAbsolutePath());\n+                r.setSettings(Collections.emptyMap());\n+                List<RecordedEvent> events = RecordingFile.readAllEvents(recording.toPath());\n+                if (events.isEmpty()) {\n+                    System.out.println(\"No events found in recording. Retrying.\");\n+                    continue;\n+                }\n+                int chains = countChains(events);\n+                if (chains < minChainsExpected) {\n+                    System.out.println(events);\n+                    System.out.println(\"Not enough chains found (\" + chains + \"), retrying.\");\n+                    continue;\n+                }\n+                return; \/\/ Success\n+            }\n+        }\n+        throw new RuntimeException(\"Failed\");\n+    }\n+\n+    private static int countChains(List<RecordedEvent> events) throws IOException {\n+        int found = 0;\n+        for (RecordedEvent e : events) {\n+            RecordedObject ro = e.getValue(\"object\");\n+            if (ro.getValue(\"referrer\") != null) {\n+                found++;\n+            }\n+        }\n+        System.out.println(\"Found chains: \" + found);\n+        return found;\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdDumpPathToGCRootsDFSBase.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jcmd;\n+import java.util.*;\n+\n+\/**\n+ * @test\n+ * @summary Test dumping with path-to-gc-roots and DFS only with a very small stacksize for the VM thread\n+ * @requires vm.hasJFR & vm.flagless\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @library \/test\/lib \/test\/jdk\n+ *\n+ * @run main\/othervm -Xmx1g -XX:VMThreadStackSize=128 jdk.jfr.jcmd.TestJcmdDumpPathToGCRootsDFSWithSmallStack\n+ *\/\n+public class TestJcmdDumpPathToGCRootsDFSWithSmallStack extends TestJcmdDumpPathToGCRootsDFSBase {\n+\n+    \/\/ Tests the new non-recursive implementation of the JFR leak profiler path-to-gc-roots-search.\n+\n+    \/\/ An non-zero exit code, together with a missing hs-err file or possibly a missing jfr file,\n+    \/\/ indicates a native stack overflow happened and is a fail condition for this test.\n+\n+    \/\/ We build up an array of linked lists, each containing enough entries for DFS search to\n+    \/\/ max out max_dfs_depth (but not greatly surpass it).\n+    \/\/ The old recursive implementation, started with such a small stack, will fail to reach\n+    \/\/ max_dfs_depth, instead crashing with stack overflow.\n+    \/\/ The new non-recursive implementation should work; the majority of the linked list items\n+    \/\/ should be scanned (all those at the start of the lists, below max_dfs_depth) and contribute\n+    \/\/ old object samples to the result.\n+\n+    \/\/ Note: VMThreadStackSize defines thread stack size for *all* VM-internal threads, not just the\n+    \/\/ VM thread. Make sure that whatever small size we use in this test is still fine for the rest of\n+    \/\/ the VM.\n+\n+    private static final int TOTAL_OBJECTS = 10_000_000;\n+    private static final int OBJECTS_PER_LIST = 5_000;\n+    private LinkedList[] leak;\n+\n+    @Override\n+    protected final void buildLeak() {\n+        leak = new LinkedList[TOTAL_OBJECTS\/OBJECTS_PER_LIST];\n+        for (int i = 0; i < leak.length; i++) {\n+            leak[i] = new LinkedList();\n+            for (int j = 0; j < OBJECTS_PER_LIST; j++) {\n+                leak[i].add(new Object());\n+            }\n+        }\n+    }\n+\n+    protected final void clearLeak() {\n+        leak = null;\n+        System.gc();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new TestJcmdDumpPathToGCRootsDFSWithSmallStack().testDump(\"TestJcmdDumpPathToGCRootsDFSWithSmallStack\", 30);\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdDumpPathToGCRootsDFSWithSmallStack.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}