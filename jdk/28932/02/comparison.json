{"files":[{"patch":"@@ -64,0 +64,4 @@\n+  \/\/ This is the only instance of request. It is important that request.generation\n+  \/\/ does not change between a concurrent cycle failure and the start of a degenerated\n+  \/\/ cycle. We initialize it with the young generation to handle the pathological case\n+  \/\/ where the very first cycle is degenerated (some tests exercise this path).\n@@ -65,0 +69,1 @@\n+  request.generation = _heap->young_generation();\n@@ -80,6 +85,4 @@\n-    if (!_heap->cancelled_gc()) {\n-      MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n-      if (_requested_gc_cause == GCCause::_no_gc) {\n-        set_gc_mode(ml, none);\n-        ml.wait();\n-      }\n+    MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+    if (_requested_gc_cause == GCCause::_no_gc) {\n+      set_gc_mode(ml, none);\n+      ml.wait();\n@@ -99,2 +102,1 @@\n-  _requested_gc_cause = GCCause::_shenandoah_stop_vm;\n-  notify_cancellation(ml, GCCause::_shenandoah_stop_vm);\n+  notify_control_thread(ml, GCCause::_shenandoah_stop_vm);\n@@ -108,7 +110,7 @@\n-  if (_heap->cancelled_gc()) {\n-    \/\/ The previous request was cancelled. Either it was cancelled for an allocation\n-    \/\/ failure (degenerated cycle), or old marking was cancelled to run a young collection.\n-    \/\/ In either case, the correct generation for the next cycle can be determined by\n-    \/\/ the cancellation cause.\n-    request.cause = _heap->clear_cancellation(GCCause::_shenandoah_concurrent_gc);\n-    if (request.cause == GCCause::_shenandoah_concurrent_gc) {\n+\n+  log_debug(gc, thread)(\"cancelled cause: %s, requested cause: %s\",\n+    GCCause::to_string(_heap->cancelled_cause()), GCCause::to_string(_requested_gc_cause));\n+\n+  request.cause = _requested_gc_cause;\n+  if (ShenandoahCollectorPolicy::is_allocation_failure(request.cause)) {\n+    if (_degen_point == ShenandoahGC::_degenerated_unset) {\n@@ -116,0 +118,3 @@\n+      _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n+    } else {\n+      assert(request.generation != nullptr, \"Must know which generation to use for degenerated cycle\");\n@@ -118,1 +123,6 @@\n-    request.cause = _requested_gc_cause;\n+    if (request.cause == GCCause::_shenandoah_concurrent_gc) {\n+      \/\/ This is a regulator request. It is also possible that the regulator \"canceled\" an old mark,\n+      \/\/ so we can clear that here. This clear operation will only clear the cancellation if it is\n+      \/\/ a regulator request.\n+      _heap->clear_cancellation(GCCause::_shenandoah_concurrent_gc);\n+    }\n@@ -120,5 +130,0 @@\n-\n-    \/\/ Only clear these if we made a request from them. In the case of a cancelled gc,\n-    \/\/ we do not want to inadvertently lose this pending request.\n-    _requested_gc_cause = GCCause::_no_gc;\n-    _requested_generation = nullptr;\n@@ -127,0 +132,6 @@\n+  log_debug(gc, thread)(\"request.cause: %s, request.generation: %s\",\n+    GCCause::to_string(request.cause), request.generation == nullptr ? \"None\" : request.generation->name());\n+\n+  _requested_gc_cause = GCCause::_no_gc;\n+  _requested_generation = nullptr;\n+\n@@ -131,0 +142,1 @@\n+  assert(request.generation != nullptr, \"request.generation cannot be null, cause is: %s\", GCCause::to_string(request.cause));\n@@ -143,5 +155,3 @@\n-\n-  if (_degen_point == ShenandoahGC::_degenerated_unset) {\n-    _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n-    request.generation = _heap->young_generation();\n-  } else if (request.generation->is_old()) {\n+  \/\/ Important: not all paths update the request.generation. This is intentional.\n+  \/\/ A degenerated cycle must use the same generation carried over from the previous request.\n+  if (request.generation->is_old()) {\n@@ -591,0 +601,2 @@\n+    MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+    _requested_gc_cause = _heap->cancelled_cause();\n@@ -636,3 +648,1 @@\n-    \/\/ GC should already be cancelled. Here we are just notifying the control thread to\n-    \/\/ wake up and handle the cancellation request, so we don't need to set _requested_gc_cause.\n-    notify_cancellation(cause);\n+    notify_control_thread(cause);\n@@ -656,1 +666,2 @@\n-      log_debug(gc, thread)(\"Cannot start young, old collection is not preemptible\");\n+      \/\/ Global should be able to cause old collection to be abandoned\n+      log_debug(gc, thread)(\"Cannot start %s, old collection is not preemptible\", generation->name());\n@@ -664,1 +675,1 @@\n-      notify_cancellation(ml, GCCause::_shenandoah_concurrent_gc);\n+      notify_control_thread(ml, GCCause::_shenandoah_concurrent_gc, generation);\n@@ -698,4 +709,10 @@\n-  log_debug(gc, thread)(\"Notify control (%s): %s, %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause), generation->name());\n-  _requested_gc_cause = cause;\n-  _requested_generation = generation;\n-  ml.notify();\n+  if (ShenandoahCollectorPolicy::is_allocation_failure(_requested_gc_cause)) {\n+    \/\/ We have already observed a request to handle an allocation failure. We cannot allow\n+    \/\/ another request (System.gc or regulator) to subvert the degenerated cycle.\n+    log_debug(gc, thread)(\"Not overwriting gc cause %s with %s\", GCCause::to_string(_requested_gc_cause), GCCause::to_string(cause));\n+  } else {\n+    log_debug(gc, thread)(\"Notify control (%s): %s, %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause), generation->name());\n+    _requested_gc_cause = cause;\n+    _requested_generation = generation;\n+    ml.notify();\n+  }\n@@ -704,1 +721,1 @@\n-void ShenandoahGenerationalControlThread::notify_cancellation(GCCause::Cause cause) {\n+void ShenandoahGenerationalControlThread::notify_control_thread(GCCause::Cause cause) {\n@@ -706,1 +723,1 @@\n-  notify_cancellation(ml, cause);\n+  notify_control_thread(ml, cause);\n@@ -709,4 +726,11 @@\n-void ShenandoahGenerationalControlThread::notify_cancellation(MonitorLocker& ml, GCCause::Cause cause) {\n-  assert(_heap->cancelled_gc(), \"GC should already be cancelled\");\n-  log_debug(gc,thread)(\"Notify control (%s): %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause));\n-  ml.notify();\n+void ShenandoahGenerationalControlThread::notify_control_thread(MonitorLocker& ml, GCCause::Cause cause) {\n+  assert(_control_lock.is_locked(), \"Request lock must be held here\");\n+  if (ShenandoahCollectorPolicy::is_allocation_failure(_requested_gc_cause)) {\n+    \/\/ We have already observed a request to handle an allocation failure. We cannot allow\n+    \/\/ another request (System.gc or regulator) to subvert the degenerated cycle.\n+    log_debug(gc, thread)(\"Not overwriting gc cause %s with %s\", GCCause::to_string(_requested_gc_cause), GCCause::to_string(cause));\n+  } else {\n+    log_debug(gc, thread)(\"Notify control (%s): %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause));\n+    _requested_gc_cause = cause;\n+    ml.notify();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":65,"deletions":41,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -138,2 +138,4 @@\n-  \/\/ Takes the request lock and updates the requested cause and generation, then notifies the control thread.\n-  \/\/ The overloaded variant should be used when the _control_lock is already held.\n+  \/\/ These notify the control thread after updating _requested_gc_cause and (optionally) _requested_generation.\n+  \/\/ Updating the requested generation is not necessary for allocation failures nor when stopping the thread.\n+  void notify_control_thread(GCCause::Cause cause);\n+  void notify_control_thread(MonitorLocker& ml, GCCause::Cause cause);\n@@ -143,5 +145,0 @@\n-  \/\/ Notifies the control thread, but does not update the requested cause or generation.\n-  \/\/ The overloaded variant should be used when the _control_lock is already held.\n-  void notify_cancellation(GCCause::Cause cause);\n-  void notify_cancellation(MonitorLocker& ml, GCCause::Cause cause);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    assert(ShenandoahCardBarrier, \"Should have card barrier to use genenrational heap\");\n+    assert(ShenandoahCardBarrier, \"Should have card barrier to use generational heap\");\n@@ -53,1 +53,1 @@\n-    assert(ShenandoahCardBarrier, \"Should have card barrier to use genenrational heap\");\n+    assert(ShenandoahCardBarrier, \"Should have card barrier to use generational heap\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -152,0 +152,7 @@\n+\n+  \/\/ This call may find the control thread waiting on workers which have suspended\n+  \/\/ to allow a safepoint to run. If this regulator thread does not yield, the safepoint\n+  \/\/ will not run. The worker threads won't progress, the control thread won't progress,\n+  \/\/ and the regulator thread may never yield. Therefore, we leave the suspendible\n+  \/\/ thread set before making this call.\n+  SuspendibleThreadSetLeaver leaver;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}