{"files":[{"patch":"@@ -887,1 +887,0 @@\n-        int nk;\n@@ -896,1 +895,0 @@\n-            nk = AESConstants.AES_KEYSIZES[0]\/WB;\n@@ -899,1 +897,0 @@\n-            nk = AESConstants.AES_KEYSIZES[1]\/WB;\n@@ -902,1 +899,0 @@\n-            nk = AESConstants.AES_KEYSIZES[2]\/WB;\n@@ -914,2 +910,2 @@\n-            sessionK[0] = genRKeys(key, nk);\n-            sessionK[1] = invGenRKeys();\n+            sessionK[0] = genRoundKeys(key, rounds);\n+            sessionK[1] = invGenRoundKeys();\n@@ -925,1 +921,1 @@\n-     * Generate the cipher round keys.\n+     * Generate the cipher's round keys as outlined in section 5.2 of the spec.\n@@ -928,1 +924,0 @@\n-     * @param nk [in] the number of words in the key.\n@@ -932,3 +927,4 @@\n-    private int[] genRKeys(byte[] key, int nk) {\n-        int len = WB, tmp, rW, subWord, g;\n-        int[] w = new int[len * (rounds + 1)];\n+    private static int[] genRoundKeys(byte[] key, int rounds) {\n+        int wLen = WB * (rounds + 1);\n+        int[] w = new int[wLen];\n+        int nk = key.length \/ WB;\n@@ -936,5 +932,3 @@\n-        for (int i = 0; i < nk; i++) {\n-            w[i] = ((key[i * len] & 0xFF) << 24)\n-                    | ((key[(i * len) + 1] & 0xFF) << 16)\n-                    | ((key[(i * len) + 2] & 0xFF) << 8)\n-                    | (key[(i * len) + 3] & 0xFF);\n+        for (int i = 0, j = 0; i < nk; i++, j += WB) {\n+            w[i] = ((key[j] & 0xFF) << 24) | ((key[j + 1] & 0xFF) << 16)\n+                    | ((key[j + 2] & 0xFF) << 8) | (key[j + 3] & 0xFF);\n@@ -942,2 +936,2 @@\n-        for (int i = nk; i < len * (rounds + 1); i++) {\n-            tmp = w[i - 1];\n+        for (int i = nk; i < wLen; i++) {\n+            int tmp = w[i - 1];\n@@ -945,7 +939,4 @@\n-                rW = (tmp << 8) & 0xFFFFFF00 | (tmp >>> 24);\n-                subWord = subByte(rW, SBOX);\n-                g = subWord ^ RCON[(i \/ nk) - 1];\n-                tmp = g;\n-            } else if ((nk > 6) && ((i % nk) == len)) {\n-                subWord = subByte(tmp, SBOX);\n-                tmp = subWord;\n+                int rW = (tmp << 8) & 0xFFFFFF00 | (tmp >>> 24);\n+                tmp = subByte(rW, SBOX) ^ RCON[(i \/ nk) - 1];\n+            } else if ((nk > 6) && ((i % nk) == WB)) {\n+                tmp = subByte(tmp, SBOX);\n@@ -1003,1 +994,1 @@\n-    private int[] invGenRKeys() {\n+    private int[] invGenRoundKeys() {\n@@ -1032,1 +1023,1 @@\n-    private int subByte(int state, byte[][] sub) {\n+    private static int subByte(int state, byte[][] sub) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AES_Crypt.java","additions":18,"deletions":27,"binary":false,"changes":45,"status":"modified"}]}