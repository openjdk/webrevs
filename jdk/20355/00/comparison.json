{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -35,0 +36,1 @@\n+import java.util.Arrays;\n@@ -345,0 +347,199 @@\n+    \/**\n+     * Perform a simple concatenation string and int. Added for startup performance\n+     *\n+     * @param prefix       an object     to encode before value\n+     * @param value        Integer value to encode\n+     * @param suffix       an object     to encode after value\n+     * @return String      resulting string\n+     *\/\n+    static String simpleConcat(Object prefix, Integer value, Object suffix) {\n+        if (value == null) {\n+            return simpleConcat(prefix, \"null\", suffix);\n+        }\n+        return simpleConcat(prefix, value.intValue(), suffix);\n+    }\n+\n+    \/**\n+     * Perform a simple concatenation string and int. Added for startup performance\n+     *\n+     * @param prefix       an object to encode before value\n+     * @param value        int value to encode\n+     * @param suffix       an object to encode after value\n+     * @return String      resulting string\n+     *\/\n+    static String simpleConcat(Object prefix, int value, Object suffix) {\n+        String s1 = stringOf(prefix);\n+        String s2 = stringOf(suffix);\n+        byte coder = (byte) (s1.coder() | s2.coder());\n+        int index = s1.length() + DecimalDigits.stringSize(value) + s2.length();\n+        byte[] buf = newArray(index << coder);\n+        index -= s2.length();\n+        s2.getBytes(buf, index, coder);\n+        if (coder == String.LATIN1) {\n+            StringLatin1.getChars(value, index, buf);\n+        } else {\n+            StringUTF16.getChars(value, index, buf);\n+        }\n+        s1.getBytes(buf, 0, coder);\n+        return new String(buf, coder);\n+    }\n+\n+    \/**\n+     * Perform a simple concatenation string and int. Added for startup performance\n+     *\n+     * @param prefix       an object  to encode before value\n+     * @param value        long value to encode\n+     * @param suffix       an object  to encode after value\n+     * @return String      resulting string\n+     *\/\n+    static String simpleConcat(Object prefix, Long value, Object suffix) {\n+        if (value == null) {\n+            return simpleConcat(prefix, \"null\", suffix);\n+        }\n+        return simpleConcat(prefix, value.longValue(), suffix);\n+    }\n+\n+    \/**\n+     * Perform a simple concatenation string and int. Added for startup performance\n+     *\n+     * @param prefix       an object  to encode before value\n+     * @param value        long value to encode\n+     * @param suffix       an object  to encode after value\n+     * @return String      resulting string\n+     *\/\n+    static String simpleConcat(Object prefix, long value, Object suffix) {\n+        String s1 = stringOf(prefix);\n+        String s2 = stringOf(suffix);\n+        byte coder = (byte) (s1.coder() | s2.coder());\n+        int index = s1.length() + DecimalDigits.stringSize(value) + s2.length();\n+        byte[] buf = newArray(index << coder);\n+        index -= s2.length();\n+        s2.getBytes(buf, index, coder);\n+        if (coder == String.LATIN1) {\n+            StringLatin1.getChars(value, index, buf);\n+        } else {\n+            StringUTF16.getChars(value, index, buf);\n+        }\n+        s1.getBytes(buf, 0, coder);\n+        return new String(buf, coder);\n+    }\n+\n+    \/**\n+     * Perform a simple concatenation string and int. Added for startup performance\n+     *\n+     * @param prefix       an object     to encode before value\n+     * @param value        boolean value to encode\n+     * @param suffix       an object     to encode after value\n+     * @return String      resulting string\n+     *\/\n+    static String simpleConcat(Object prefix, boolean value, Object suffix) {\n+        String s1 = stringOf(prefix);\n+        String s2 = stringOf(suffix);\n+        byte coder = (byte) (s1.coder() | s2.coder());\n+        int length = s1.length() + s2.length() + (value ? 4 : 5);\n+        byte[] buf = newArray(length << coder);\n+        s1.getBytes(buf, 0, coder);\n+        int index = s1.length();\n+        if (coder == String.LATIN1) {\n+            if (value) {\n+                buf[index] = 't';\n+                buf[index + 1] = 'r';\n+                buf[index + 2] = 'u';\n+                buf[index + 3] = 'e';\n+            } else {\n+                buf[index] = 'f';\n+                buf[index + 1] = 'a';\n+                buf[index + 2] = 'l';\n+                buf[index + 3] = 's';\n+                buf[index + 4] = 'e';\n+            }\n+        } else {\n+            if (value) {\n+                StringUTF16.putChar(buf, index, 't');\n+                StringUTF16.putChar(buf, index + 1, 'r');\n+                StringUTF16.putChar(buf, index + 2, 'u');\n+                StringUTF16.putChar(buf, index + 3, 'e');\n+            } else {\n+                StringUTF16.putChar(buf, index, 'f');\n+                StringUTF16.putChar(buf, index + 1, 'a');\n+                StringUTF16.putChar(buf, index + 2, 'l');\n+                StringUTF16.putChar(buf, index + 3, 's');\n+                StringUTF16.putChar(buf, index + 4, 'e');\n+            }\n+        }\n+        index += value ? 4 : 5;\n+        s2.getBytes(buf, index, coder);\n+        return new String(buf, coder);\n+    }\n+\n+    \/**\n+     * Perform a simple concatenation string and int. Added for startup performance\n+     *\n+     * @param prefix       an object  to encode before value\n+     * @param value        char value to encode\n+     * @param suffix       an object  to encode after value\n+     * @return String      resulting string\n+     *\/\n+    static String simpleConcat(Object prefix, char value, Object suffix) {\n+        String s1 = stringOf(prefix);\n+        String s2 = stringOf(suffix);\n+        byte coder = (byte) (s1.coder() | (StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16) | s2.coder());\n+        int length = s1.length() + s2.length() + 1;\n+        byte[] buf = newArray(length << coder);\n+        s1.getBytes(buf, 0, coder);\n+        int index = s1.length();\n+        if (coder == String.LATIN1) {\n+            buf[index] = (byte) (value & 0xFF);\n+        } else {\n+            StringUTF16.putChar(buf, index, value);\n+        }\n+        s2.getBytes(buf, index + 1, coder);\n+        return new String(buf, coder);\n+    }\n+\n+    \/**\n+     * Perform a simple concatenation string and int. Added for startup performance\n+     *\n+     * @param prefix       an object  to encode before value\n+     * @param value        float value to encode\n+     * @param suffix       an object  to encode after value\n+     * @return String      resulting string\n+     *\/\n+    static String simpleConcat(Object prefix, float value, Object suffix) {\n+        return simpleConcat(stringOf(prefix), Float.toString(value), stringOf(suffix));\n+    }\n+\n+    \/**\n+     * Perform a simple concatenation string and int. Added for startup performance\n+     *\n+     * @param prefix       an object  to encode before value\n+     * @param value        double value to encode\n+     * @param suffix       an object  to encode after value\n+     * @return String      resulting string\n+     *\/\n+    static String simpleConcat(Object prefix, double value, Object suffix) {\n+        return simpleConcat(stringOf(prefix), Double.toString(value), stringOf(suffix));\n+    }\n+\n+    \/**\n+     * Perform a simple concatenation string and int. Added for startup performance\n+     *\n+     * @param prefix       an object       to encode before value\n+     * @param value        an Object value to encode\n+     * @param suffix       an object       to encode after value\n+     * @return String      resulting string\n+     *\/\n+    static String simpleConcat(Object prefix, Object value, Object suffix) {\n+        return simpleConcat(stringOf(prefix), String.valueOf(value), stringOf(suffix));\n+    }\n+\n+    private static String simpleConcat(String s1, String s2, String s3) {\n+        byte coder = (byte) (s1.coder() | s2.coder() | s3.coder());\n+        int length = s1.length() + s2.length() + s3.length();\n+        byte[] buf = newArray(length << coder);\n+        s1.getBytes(buf, 0, coder);\n+        s2.getBytes(buf, s1.length(), coder);\n+        s3.getBytes(buf, s1.length() + s2.length(), coder);\n+        return new String(buf, coder);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -374,4 +375,9 @@\n-            if (concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n-                return new ConstantCallSite(\n-                        generateMHInlineCopy(concatType, constantStrings)\n-                                .viewAsType(concatType, true));\n+            \/\/ Fast-path trivial concatenations\n+            MethodHandle mh = simpleConcat(concatType, constantStrings);\n+\n+            if (mh == null && concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n+                mh = generateMHInlineCopy(concatType, constantStrings);\n+            }\n+\n+            if (mh != null) {\n+                mh = mh.viewAsType(concatType, true);\n@@ -379,2 +385,1 @@\n-                return new ConstantCallSite(\n-                        SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings));\n+                mh = SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings);\n@@ -382,0 +387,2 @@\n+\n+            return new ConstantCallSite(mh);\n@@ -469,8 +476,1 @@\n-    \/**\n-     * <p>This strategy replicates what StringBuilders are doing: it builds the\n-     * byte[] array on its own and passes that byte[] array to String\n-     * constructor. This strategy requires access to some private APIs in JDK,\n-     * most notably, the private String constructor that accepts byte[] arrays\n-     * without copying.\n-     *\/\n-    private static MethodHandle generateMHInlineCopy(MethodType mt, String[] constants) {\n+    private static MethodHandle simpleConcat(MethodType mt, String[] constants) {\n@@ -479,0 +479,3 @@\n+        if (suffix == null) {\n+            suffix = \"\";\n+        }\n@@ -480,1 +483,0 @@\n-        \/\/ Fast-path trivial concatenations\n@@ -482,1 +484,6 @@\n-            return MethodHandles.insertArguments(newStringifier(), 0, suffix == null ? \"\" : suffix);\n+            return MethodHandles.insertArguments(newStringifier(), 0, suffix);\n+        }\n+\n+        String prefix = constants[0];\n+        if (prefix == null) {\n+            prefix = \"\";\n@@ -484,0 +491,3 @@\n+\n+        MethodHandle mh;\n+        var paramType0 = mt.parameterType(0);\n@@ -485,1 +495,0 @@\n-            String prefix = constants[0];\n@@ -487,4 +496,6 @@\n-            if (prefix == null) {\n-                if (suffix == null) {\n-                    return unaryConcat(mt.parameterType(0));\n-                } else if (!mt.hasPrimitives()) {\n+            if (prefix.isEmpty()) {\n+                if (suffix.isEmpty()) {\n+                    return unaryConcat(paramType0);\n+                }\n+\n+                if (!mt.hasPrimitives()) {\n@@ -492,8 +503,13 @@\n-                } \/\/ else fall-through\n-            } else if (suffix == null && !mt.hasPrimitives()) {\n-                \/\/ Non-primitive argument\n-                return MethodHandles.insertArguments(simpleConcat(), 0, prefix);\n-            } \/\/ fall-through if there's both a prefix and suffix\n-        }\n-        if (paramCount == 2 && !mt.hasPrimitives() && suffix == null\n-                && constants[0] == null && constants[1] == null) {\n+                }\n+            } else if (suffix.isEmpty()) {\n+                if (!mt.hasPrimitives()) {\n+                    \/\/ Non-primitive argument\n+                    return MethodHandles.insertArguments(simpleConcat(), 0, prefix);\n+                }\n+            }\n+\n+            mh = simpleConcat3(paramType0);\n+            mh = MethodHandles.insertArguments(mh, 2, suffix);\n+            return MethodHandles.insertArguments(mh, 0, prefix);\n+        } else if (paramCount == 2 && constants[1] == null) {\n+            var paramType1 = mt.parameterType(1);\n@@ -501,1 +517,15 @@\n-            return simpleConcat();\n+            if (!mt.hasPrimitives() && suffix.isEmpty() && prefix.isEmpty()) {\n+                return simpleConcat();\n+            }\n+\n+            if (suffix.isEmpty() && !paramType1.isPrimitive()) {\n+                \/\/ \"prefix\" + i + s\n+                mh = simpleConcat3(paramType0);\n+                return MethodHandles.insertArguments(mh, 0, prefix);\n+            }\n+\n+            if (prefix.isEmpty() && !paramType0.isPrimitive()) {\n+                \/\/ s + i + \"suffix\"\n+                mh = simpleConcat3(paramType1);\n+                return MethodHandles.insertArguments(mh, 2, suffix);\n+            }\n@@ -503,1 +533,0 @@\n-        \/\/ else... fall-through to slow-path\n@@ -505,0 +534,37 @@\n+        return null;\n+    }\n+\n+    static MethodHandle simpleConcat3(Class<?> paramType) {\n+        MethodHandle mh;\n+        if (paramType == byte.class || paramType == short.class || paramType == int.class) {\n+            mh = simpleConcat3int();\n+        } else if (paramType == long.class) {\n+            mh = simpleConcat3long();\n+        } else if (paramType == char.class) {\n+            mh = simpleConcat3char();\n+        } else if (paramType == boolean.class) {\n+            mh = simpleConcat3boolean();\n+        } else if (paramType == float.class) {\n+            mh = simpleConcat3float();\n+        } else if (paramType == double.class) {\n+            mh = simpleConcat3double();\n+        } else if (paramType == Integer.class) {\n+            mh = simpleConcat3Integer();\n+        } else if (paramType == Long.class) {\n+            mh = simpleConcat3Long();\n+        } else {\n+            mh = simpleConcat3();\n+        }\n+        return mh;\n+    }\n+\n+    \/**\n+     * <p>This strategy replicates what StringBuilders are doing: it builds the\n+     * byte[] array on its own and passes that byte[] array to String\n+     * constructor. This strategy requires access to some private APIs in JDK,\n+     * most notably, the private String constructor that accepts byte[] arrays\n+     * without copying.\n+     *\/\n+    private static MethodHandle generateMHInlineCopy(MethodType mt, String[] constants) {\n+        int paramCount = mt.parameterCount();\n+        String suffix = constants[paramCount];\n@@ -881,0 +947,99 @@\n+    private @Stable static MethodHandle SIMPLE_CONCAT3_INT;\n+    private static MethodHandle simpleConcat3int() {\n+        MethodHandle mh = SIMPLE_CONCAT3_INT;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"simpleConcat\",\n+                    methodType(String.class, Object.class, int.class, Object.class));\n+            SIMPLE_CONCAT3_INT = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n+    private @Stable static MethodHandle SIMPLE_CONCAT3_INTEGER;\n+    private static MethodHandle simpleConcat3Integer() {\n+        MethodHandle mh = SIMPLE_CONCAT3_INTEGER;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"simpleConcat\",\n+                    methodType(String.class, Object.class, Integer.class, Object.class));\n+            SIMPLE_CONCAT3_INTEGER = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n+    private @Stable static MethodHandle SIMPLE_CONCAT3_LONG;\n+    private static MethodHandle simpleConcat3long() {\n+        MethodHandle mh = SIMPLE_CONCAT3_LONG;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"simpleConcat\",\n+                    methodType(String.class, Object.class, long.class, Object.class));\n+            SIMPLE_CONCAT3_LONG = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n+    private @Stable static MethodHandle SIMPLE_CONCAT3_LONGO;\n+    private static MethodHandle simpleConcat3Long() {\n+        MethodHandle mh = SIMPLE_CONCAT3_LONGO;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"simpleConcat\",\n+                    methodType(String.class, Object.class, Long.class, Object.class));\n+            SIMPLE_CONCAT3_LONGO = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n+    private @Stable static MethodHandle SIMPLE_CONCAT3_BOOLEAN;\n+    private static MethodHandle simpleConcat3boolean() {\n+        MethodHandle mh = SIMPLE_CONCAT3_BOOLEAN;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"simpleConcat\",\n+                    methodType(String.class, Object.class, boolean.class, Object.class));\n+            SIMPLE_CONCAT3_BOOLEAN = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n+    private @Stable static MethodHandle SIMPLE_CONCAT3_CHAR;\n+    private static MethodHandle simpleConcat3char() {\n+        MethodHandle mh = SIMPLE_CONCAT3_CHAR;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"simpleConcat\",\n+                    methodType(String.class, Object.class, char.class, Object.class));\n+            SIMPLE_CONCAT3_CHAR = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n+    private @Stable static MethodHandle SIMPLE_CONCAT3_FLOAT;\n+    private static MethodHandle simpleConcat3float() {\n+        MethodHandle mh = SIMPLE_CONCAT3_FLOAT;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"simpleConcat\",\n+                    methodType(String.class, Object.class, float.class, Object.class));\n+            SIMPLE_CONCAT3_FLOAT = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n+    private @Stable static MethodHandle SIMPLE_CONCAT3_DOUBLE;\n+    private static MethodHandle simpleConcat3double() {\n+        MethodHandle mh = SIMPLE_CONCAT3_DOUBLE;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"simpleConcat\",\n+                    methodType(String.class, Object.class, double.class, Object.class));\n+            SIMPLE_CONCAT3_DOUBLE = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n+    private @Stable static MethodHandle SIMPLE_CONCAT3;\n+    private static MethodHandle simpleConcat3() {\n+        MethodHandle mh = SIMPLE_CONCAT3;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"simpleConcat\",\n+                    methodType(String.class, Object.class, Object.class, Object.class));\n+            SIMPLE_CONCAT3 = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":196,"deletions":31,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -51,1 +52,2 @@\n-\n+    public Integer integerValue = intValue + 1;\n+    public float floatValue = 156456.36435637F + intValue;\n@@ -53,1 +55,0 @@\n-\n@@ -55,1 +56,0 @@\n-\n@@ -57,1 +57,0 @@\n-\n@@ -59,1 +58,0 @@\n-\n@@ -67,0 +65,10 @@\n+    @Benchmark\n+    public String concatConstInteger() {\n+        return \"string\" + integerValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstFloat() {\n+        return \"string\" + floatValue;\n+    }\n+\n@@ -97,0 +105,20 @@\n+    @Benchmark\n+    public String concatConstIntString() {\n+        return \"string\" + intValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntegerString() {\n+        return \"string\" + integerValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstFloatString() {\n+        return \"string\" + floatValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstBooleanString() {\n+        return \"string\" + boolValue + stringValue;\n+    }\n+\n@@ -117,0 +145,15 @@\n+    @Benchmark\n+    public String concat3String() {\n+        return stringValue + stringValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringIntString() {\n+        return stringValue + intValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringIntegerString() {\n+        return stringValue + integerValue + stringValue;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConcat.java","additions":48,"deletions":5,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -47,1 +49,7 @@\n-        String[] selection = new String[] { \"StringLarge\", \"MixedSmall\", \"StringSingle\", \"MixedLarge\" };\n+        String[] selection = {\n+                \"StringLarge\",\n+                \"MixedSmall\",\n+                \"StringSingle\",\n+                \"StringThree\",\n+                \"MixedLarge\"\n+        };\n@@ -53,1 +61,13 @@\n-                case \"StringSingle\" -> new StringSingle().run();\n+                case \"StringSingle\" -> {\n+                    new StringSingle().constInt();\n+                    new StringSingle().constFloat();\n+                    new StringSingle().constString();\n+                    new StringSingle().const2String();\n+                    new StringSingle().constIntString();\n+                    new StringSingle().constFloatString();\n+                    new StringSingle().constBooleanString();\n+                }\n+                case \"StringThree\" -> {\n+                    new StringThree().stringIntString();\n+                    new StringThree().stringIntegerString();\n+                }\n@@ -67,1 +87,6 @@\n-        public String s = \"foo\";\n+        @Param(\"4711\")\n+        public int intValue;\n+        public Integer integerValue = intValue;\n+        public float floatValue = 156456.36435637F + intValue;\n+        public String stringValue = String.valueOf(intValue);\n+        public boolean boolValue = true;\n@@ -70,2 +95,41 @@\n-        public String run() {\n-            return \"\" + s;\n+        public String constInt() {\n+            return \"string\" + intValue;\n+        }\n+\n+        @Benchmark\n+        public String constInteger() {\n+            return \"string\" + integerValue;\n+        }\n+\n+        @Benchmark\n+        public String constFloat() {\n+            return \"string\" + floatValue;\n+        }\n+\n+        @Benchmark\n+        public String constString() {\n+            return \"string\" + stringValue;\n+        }\n+\n+        public String const2String() {\n+            return \"string\" + stringValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constIntString() {\n+            return \"string\" + intValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constIntegerString() {\n+            return \"string\" + integerValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constFloatString() {\n+            return \"string\" + floatValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constBooleanString() {\n+            return \"string\" + boolValue + stringValue;\n@@ -75,0 +139,21 @@\n+    @BenchmarkMode(Mode.SingleShotTime)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    @State(Scope.Thread)\n+    @Fork(value = 40, warmups = 2)\n+    public static class StringThree {\n+\n+        @Param(\"4711\")\n+        public int intValue;\n+        public Integer integerValue = intValue;\n+        public String stringValue = String.valueOf(intValue);\n+\n+        @Benchmark\n+        public String stringIntString() {\n+            return stringValue + intValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String stringIntegerString() {\n+            return stringValue + integerValue + stringValue;\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConcatStartup.java","additions":90,"deletions":5,"binary":false,"changes":95,"status":"modified"}]}