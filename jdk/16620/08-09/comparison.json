{"files":[{"patch":"@@ -1099,2 +1099,2 @@\n-      VLoop vl(phase);\n-      if (vl.check_preconditions(this, true)) {\n+      VLoop vl(this, true);\n+      if (vl.check_preconditions()) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4667,2 +4667,1 @@\n-    VLoopAnalyzer vloop_analyzer(this);\n-    SuperWord sw(vloop_analyzer);\n+    ResourceArea autovectorization_arena;\n@@ -4673,1 +4672,6 @@\n-        if (!vloop_analyzer.analyze(lpt) ||\n+        ResourceMark rm(&autovectorization_arena);\n+        \/\/ TODO only start analyzer once VLoop passes preconditions?\n+        VLoopAnalyzer vloop_analyzer(&autovectorization_arena, lpt);\n+        \/\/ TODO can we have it only after analyzer succeeds?\n+        SuperWord sw(&autovectorization_arena, vloop_analyzer);\n+        if (!vloop_analyzer.analyze() ||\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-SuperWord::SuperWord(const VLoopAnalyzer &vla) :\n+SuperWord::SuperWord(Arena* arena, const VLoopAnalyzer &vla) :\n@@ -48,3 +48,4 @@\n-  _arena(phase()->C->comp_arena()),\n-  _packset(arena(), 8,  0, nullptr),                        \/\/ packs for the current block\n-  _node_info(arena(), 8,  0, SWNodeInfo::initial),          \/\/ info needed per node\n+  _arena(arena),\n+  \/\/ TODO reserve?\n+  _packset(arena, 8,  0, nullptr),                          \/\/ packs for the current block\n+  _node_info(arena, 8,  0, SWNodeInfo::initial),            \/\/ info needed per node\n@@ -53,1 +54,1 @@\n-  _n_idx_list(arena(), 8),                                  \/\/ scratch list of (node,index) pairs\n+  _n_idx_list(arena, 8),                                    \/\/ scratch list of (node,index) pairs\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-  SuperWord(const VLoopAnalyzer &vla);\n+  SuperWord(Arena* arena, const VLoopAnalyzer &vla);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1354,3 +1354,1 @@\n-bool VLoop::check_preconditions(IdealLoopTree* lpt, bool allow_cfg) {\n-  reset(lpt, allow_cfg);\n-\n+bool VLoop::check_preconditions() {\n@@ -1360,2 +1358,2 @@\n-    lpt->dump_head();\n-    lpt->head()->dump();\n+    lpt()->dump_head();\n+    lpt()->head()->dump();\n@@ -1439,3 +1437,2 @@\n-bool VLoopAnalyzer::analyze(IdealLoopTree* lpt) {\n-  reset(lpt);\n-  bool success = _vloop.check_preconditions(lpt, false);\n+bool VLoopAnalyzer::analyze() {\n+  bool success = _vloop.check_preconditions();\n@@ -1447,1 +1444,1 @@\n-    lpt->dump_head();\n+    vloop().lpt()->dump_head();\n@@ -2068,1 +2065,1 @@\n-  DependenceNode* m = new (_vloop.arena()) DependenceNode(node);\n+  DependenceNode* m = new (arena()) DependenceNode(node);\n@@ -2078,4 +2075,4 @@\n-  DependenceEdge* e = new (_vloop.arena()) DependenceEdge(dpred,\n-                                                           dsucc,\n-                                                           dsucc->in_head(),\n-                                                           dpred->out_head());\n+  DependenceEdge* e = new (arena()) DependenceEdge(dpred,\n+                                                   dsucc,\n+                                                   dsucc->in_head(),\n+                                                   dpred->out_head());\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -40,3 +40,3 @@\n-  PhaseIdealLoop* _phase = nullptr;\n-  Arena* _arena = nullptr;\n-  IdealLoopTree* _lpt = nullptr;\n+  PhaseIdealLoop* const _phase = nullptr;\n+  IdealLoopTree* const _lpt = nullptr;\n+  const bool _allow_cfg = false;\n@@ -46,1 +46,0 @@\n-  bool _allow_cfg = false;\n@@ -61,4 +60,8 @@\n-  VLoop(PhaseIdealLoop* phase) :\n-    _phase(phase),\n-    _arena(phase->C->comp_arena()),\n-    _trace_tags(phase->C->directive()->traceautovectorization_tags()) {}\n+  VLoop(IdealLoopTree* lpt, bool allow_cfg) :\n+    _phase(lpt->_phase),\n+    _lpt(lpt),\n+    _allow_cfg(allow_cfg),\n+    _cl(nullptr),\n+    _cl_exit(nullptr),\n+    _iv(nullptr),\n+    _trace_tags(phase()->C->directive()->traceautovectorization_tags()) {}\n@@ -67,9 +70,0 @@\n-  void reset(IdealLoopTree* lpt, bool allow_cfg) {\n-    assert(_phase == lpt->_phase, \"must be the same phase\");\n-    _lpt       = lpt;\n-    _cl        = nullptr;\n-    _cl_exit   = nullptr;\n-    _iv        = nullptr;\n-    _allow_cfg = allow_cfg;\n-  }\n-\n@@ -77,6 +71,5 @@\n-  Arena* arena()          const { return _arena; }\n-  IdealLoopTree* lpt()    const { assert(_lpt     != nullptr, \"\"); return _lpt; };\n-  PhaseIdealLoop* phase() const { assert(_phase   != nullptr, \"\"); return _phase; }\n-  CountedLoopNode* cl()   const { assert(_cl      != nullptr, \"\"); return _cl; };\n-  Node* cl_exit()         const { assert(_cl_exit != nullptr, \"\"); return _cl_exit; };\n-  PhiNode* iv()           const { assert(_iv      != nullptr, \"\"); return _iv; };\n+  IdealLoopTree* lpt()    const { return _lpt; };\n+  PhaseIdealLoop* phase() const { return _phase; }\n+  CountedLoopNode* cl()   const { return _cl; };\n+  Node* cl_exit()         const { return _cl_exit; };\n+  PhiNode* iv()           const { return _iv; };\n@@ -85,0 +78,1 @@\n+\n@@ -90,0 +84,1 @@\n+\n@@ -139,1 +134,1 @@\n-  bool check_preconditions(IdealLoopTree* lpt, bool allow_cfg);\n+  bool check_preconditions();\n@@ -155,1 +150,1 @@\n-  VLoopReductions(const VLoop& vloop) :\n+  VLoopReductions(Arena* arena, const VLoop& vloop) :\n@@ -157,1 +152,2 @@\n-    _loop_reductions(_vloop.arena()){};\n+    _loop_reductions(arena){}; \/\/ TODO reserve?\n+\n@@ -159,3 +155,0 @@\n-  void reset() {\n-    _loop_reductions.clear();\n-  }\n@@ -232,1 +225,1 @@\n-  VLoopMemorySlices(const VLoop& vloop) :\n+  VLoopMemorySlices(Arena* arena, const VLoop& vloop) :\n@@ -234,2 +227,2 @@\n-    _heads(_vloop.arena(), 8,  0, nullptr),\n-    _tails(_vloop.arena(), 8,  0, nullptr) {};\n+    _heads(arena, 8,  0, nullptr),\n+    _tails(arena, 8,  0, nullptr) {};\n@@ -239,5 +232,0 @@\n-  void reset() {\n-    _heads.clear();\n-    _tails.clear();\n-  }\n-\n@@ -273,1 +261,1 @@\n-  VLoopBody(const VLoop& vloop) :\n+  VLoopBody(Arena* arena, const VLoop& vloop) :\n@@ -275,2 +263,2 @@\n-    _body(_vloop.arena(), 8, 0, nullptr),\n-    _body_idx(_vloop.arena(), (int)(1.10 * _vloop.phase()->C->unique()), 0, 0) {}\n+    _body(arena, 8, 0, nullptr),\n+    _body_idx(arena, (int)(1.10 * _vloop.phase()->C->unique()), 0, 0) {}\n@@ -280,5 +268,0 @@\n-  void reset() {\n-    _body.clear();\n-    _body_idx.clear();\n-  }\n-\n@@ -334,0 +317,2 @@\n+  Arena* _arena;\n+\n@@ -341,1 +326,2 @@\n-  VLoopDependenceGraph(const VLoop& vloop,\n+  VLoopDependenceGraph(Arena* arena,\n+                       const VLoop& vloop,\n@@ -347,4 +333,5 @@\n-    _map(vloop.arena(), 8,  0, nullptr),\n-    _root(nullptr),\n-    _sink(nullptr),\n-    _depth(vloop.arena(), 8,  0, 0) {}\n+    _arena(arena),\n+    _map(arena, 8,  0, nullptr),\n+    _root(new (arena) DependenceNode(nullptr)),\n+    _sink(new (arena) DependenceNode(nullptr)),\n+    _depth(arena, 8,  0, 0) {}\n@@ -354,7 +341,0 @@\n-  void reset() {\n-    _map.clear();\n-    _root = new (_vloop.arena()) DependenceNode(nullptr);\n-    _sink = new (_vloop.arena()) DependenceNode(nullptr);\n-    _depth.clear();\n-  }\n-\n@@ -368,0 +348,2 @@\n+  Arena* arena() { return _arena; }\n+\n@@ -505,1 +487,2 @@\n-  VLoopTypes(const VLoop& vloop,\n+  VLoopTypes(Arena* arena,\n+             const VLoop& vloop,\n@@ -509,1 +492,1 @@\n-    _velt_type(vloop.arena(), 8,  0, nullptr) {}\n+    _velt_type(arena, 8,  0, nullptr) {}\n@@ -513,4 +496,0 @@\n-  void reset() {\n-    _velt_type.clear();\n-  }\n-\n@@ -590,7 +569,7 @@\n-  VLoopAnalyzer(PhaseIdealLoop* phase) :\n-    _vloop(phase),\n-    _reductions(vloop()),\n-    _memory_slices(vloop()),\n-    _body(vloop()),\n-    _types(vloop(), body()), \/\/ types requires: body\n-    _dependence_graph(vloop(), memory_slices(), body()) \/\/ dependence_graph requires: memory_slices and body\n+  VLoopAnalyzer(Arena* arena, IdealLoopTree* lpt) :\n+    _vloop           (lpt, false),\n+    _reductions      (arena, vloop()),\n+    _memory_slices   (arena, vloop()),\n+    _body            (arena, vloop()),\n+    _types           (arena, vloop(), body()),\n+    _dependence_graph(arena, vloop(), memory_slices(), body())\n@@ -599,0 +578,1 @@\n+\n@@ -603,1 +583,1 @@\n-  bool analyze(IdealLoopTree* lpt);\n+  bool analyze();\n@@ -614,7 +594,0 @@\n-  void reset(IdealLoopTree* lpt) {\n-    _reductions.reset();\n-    _memory_slices.reset();\n-    _body.reset();\n-    _types.reset();\n-    _dependence_graph.reset();\n-  }\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":51,"deletions":78,"binary":false,"changes":129,"status":"modified"}]}