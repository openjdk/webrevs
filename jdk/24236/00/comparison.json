{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -664,1 +664,1 @@\n-        return groups.toArray(new ThreadGroup[0]);\n+        return groups.toArray(new ThreadGroup[groups.size()]);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadGroup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8352088\n+ * @summary If ThreadGroupReference.groups() is called very early on from an\n+ *          event handler, it can cause a deadlock because the call can result\n+ *          in ClassPrepareEvents, which the debug agent will block on until\n+ *          the debugger handles them, which it won't because the event handler\n+ *          thread is waiting for a reply to ThreadGroupReference.groups().\n+ *\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter\n+ * @run compile -g EarlyThreadGroupChildrenTest.java\n+ * @run main\/othervm\/timeout=20 EarlyThreadGroupChildrenTest\n+ *\/\n+\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import com.sun.jdi.request.*;\n+\n+import java.util.*;\n+\n+class EarlyThreadGroupChildrenTestTarg {\n+    public static void main(String[] args) throws InterruptedException {\n+        System.out.println(\"Start\");\n+        System.out.println(\"Finish\");\n+    }\n+}\n+\n+    \/********** test program **********\/\n+\n+public class EarlyThreadGroupChildrenTest extends TestScaffold {\n+    ClassType targetClass;\n+    ThreadReference mainThread;\n+\n+    EarlyThreadGroupChildrenTest(String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args)      throws Exception {\n+        new EarlyThreadGroupChildrenTest(args).startTests();\n+    }\n+\n+    \/********** event handlers **********\/\n+\n+    ClassPrepareRequest cpRequest;\n+    ThreadStartRequest tsRequest;\n+\n+    @Override\n+    public void threadStarted(ThreadStartEvent event) {\n+        System.out.println(\"Got ThreadStartEvent: \" + event);\n+        cpRequest = eventRequestManager().createClassPrepareRequest();\n+        cpRequest.setSuspendPolicy(EventRequest.SUSPEND_ALL);\n+        cpRequest.enable();\n+    }\n+\n+    static volatile int classPreparedCount = 0;\n+\n+    @Override\n+    public void classPrepared(ClassPrepareEvent event) {\n+        try {\n+            ++classPreparedCount;\n+            System.out.println(\"ClassPreparedEvent \" + classPreparedCount +\n+                               \" on thread \" + event.thread() +\n+                               \": \" + event.referenceType());\n+            List<ThreadGroupReference> groups = vm().topLevelThreadGroups();\n+            ThreadGroupReference systemThreadGroup = groups.get(0);\n+            groups = systemThreadGroup.threadGroups();\n+            System.out.println(\"system child ThreadGroups: \" + groups);\n+        } catch (VMDisconnectedException e) {\n+            \/\/ This usually eventually happens during shutdown.\n+            System.out.println(\"ClassPreparedEvent \" + classPreparedCount +\n+                               \": Got VMDisconnectedException\");\n+        }\n+    }\n+\n+    public void vmDisconnected(VMDisconnectEvent event) {\n+        System.out.println(\"Got VMDisconnectEvent\");\n+    }\n+\n+    \/********** test core **********\/\n+\n+    protected void runTests() throws Exception {\n+        connect(new String[]{\"EarlyThreadGroupChildrenTestTarg\"});\n+        System.out.println(\"Connected: \");\n+        addListener(this);\n+\n+        \/\/ Create a ThreadStartRequest for the first ThreadStartEvent. When this event is\n+        \/\/ received, we will enable ClassPrepareEvents.\n+        tsRequest = eventRequestManager().createThreadStartRequest();\n+        tsRequest.setSuspendPolicy(EventRequest.SUSPEND_ALL);\n+        tsRequest.addCountFilter(1);\n+        tsRequest.enable();\n+\n+        waitForVMStart();\n+        System.out.println(\"VM Started: \");\n+\n+        resumeToVMDisconnect();\n+\n+        \/\/ Failure mode for this test is deadlocking, so there is no error to check for.\n+        System.out.println(\"EarlyThreadGroupChildrenTest: passed\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/EarlyThreadGroupChildrenTest.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"}]}