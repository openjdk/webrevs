{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/g1\/g1CollectionSetChooser.hpp\"\n@@ -1179,1 +1180,4 @@\n-class G1UpdateRemSetTrackingBeforeRebuildTask : public WorkerTask {\n+\/\/ Update per-region liveness info based on CM stats. Then, reclaim empty\n+\/\/ regions right away and select certain regions (e.g. sparse ones) for remset\n+\/\/ rebuild.\n+class G1UpdateRegionLivenessAndSelectForRebuildTask : public WorkerTask {\n@@ -1183,0 +1187,1 @@\n+\n@@ -1185,1 +1190,2 @@\n-  G1PrintRegionLivenessInfoClosure _cl;\n+  \/\/ Reclaimed empty regions\n+  FreeRegionList _cleanup_list;\n@@ -1187,1 +1193,1 @@\n-  class G1UpdateRemSetTrackingBeforeRebuild : public HeapRegionClosure {\n+  struct G1OnRegionClosure : public HeapRegionClosure {\n@@ -1190,0 +1196,2 @@\n+    \/\/ The number of regions actually selected for rebuild.\n+    uint _num_selected_for_rebuild;\n@@ -1191,1 +1199,4 @@\n-    G1PrintRegionLivenessInfoClosure* _cl;\n+    size_t _freed_bytes;\n+    uint _num_old_regions_removed;\n+    uint _num_humongous_regions_removed;\n+    FreeRegionList* _local_cleanup_list;\n@@ -1193,1 +1204,10 @@\n-    uint _num_regions_selected_for_rebuild;  \/\/ The number of regions actually selected for rebuild.\n+    G1OnRegionClosure(G1CollectedHeap* g1h,\n+                      G1ConcurrentMark* cm,\n+                      FreeRegionList* local_cleanup_list) :\n+      _g1h(g1h),\n+      _cm(cm),\n+      _num_selected_for_rebuild(0),\n+      _freed_bytes(0),\n+      _num_old_regions_removed(0),\n+      _num_humongous_regions_removed(0),\n+      _local_cleanup_list(local_cleanup_list) {}\n@@ -1195,2 +1215,3 @@\n-    void update_remset_before_rebuild(HeapRegion* hr) {\n-      G1RemSetTrackingPolicy* tracking_policy = _g1h->policy()->remset_tracker();\n+    void reclaim_empty_humongous_region(HeapRegion* hr) {\n+      assert(!hr->has_pinned_objects(), \"precondition\");\n+      assert(hr->is_starts_humongous(), \"precondition\");\n@@ -1198,12 +1219,11 @@\n-      bool selected_for_rebuild;\n-      if (hr->is_humongous()) {\n-        bool const is_live = _cm->contains_live_object(hr->humongous_start_region()->hrm_index());\n-        selected_for_rebuild = tracking_policy->update_humongous_before_rebuild(hr, is_live);\n-      } else {\n-        size_t const live_bytes = _cm->live_bytes(hr->hrm_index());\n-        selected_for_rebuild = tracking_policy->update_before_rebuild(hr, live_bytes);\n-      }\n-      if (selected_for_rebuild) {\n-        _num_regions_selected_for_rebuild++;\n-      }\n-      _cm->update_top_at_rebuild_start(hr);\n+      auto on_humongous_region = [&] (HeapRegion* hr) {\n+        assert(hr->used() > 0, \"precondition\");\n+        _num_humongous_regions_removed++;\n+        _freed_bytes += hr->used();\n+        hr->set_containing_set(nullptr);\n+        _g1h->free_humongous_region(hr, _local_cleanup_list);\n+        hr->clear_cardtable();\n+        _g1h->concurrent_mark()->clear_statistics(hr);\n+      };\n+\n+      _g1h->humongous_obj_regions_iterate(hr, on_humongous_region);\n@@ -1212,17 +1232,11 @@\n-    \/\/ Distribute the given marked bytes across the humongous object starting\n-    \/\/ with hr and note end of marking for these regions.\n-    void distribute_marked_bytes(HeapRegion* hr, size_t marked_bytes) {\n-      \/\/ Dead humongous objects (marked_bytes == 0) may have already been unloaded.\n-      assert(marked_bytes == 0 || cast_to_oop(hr->bottom())->size() * HeapWordSize == marked_bytes,\n-             \"Marked bytes should either be 0 or the same as humongous object (%zu) but is %zu\",\n-             cast_to_oop(hr->bottom())->size() * HeapWordSize, marked_bytes);\n-\n-      auto distribute_bytes = [&] (HeapRegion* r) {\n-        size_t const bytes_to_add = MIN2(HeapRegion::GrainBytes, marked_bytes);\n-\n-        log_trace(gc, marking)(\"Adding %zu bytes to humongous region %u (%s)\",\n-                               bytes_to_add, r->hrm_index(), r->get_type_str());\n-        add_marked_bytes_and_note_end(r, bytes_to_add);\n-        marked_bytes -= bytes_to_add;\n-      };\n-      _g1h->humongous_obj_regions_iterate(hr, distribute_bytes);\n+    void reclaim_empty_old_region(HeapRegion* hr) {\n+      assert(hr->used() > 0, \"precondition\");\n+      assert(!hr->has_pinned_objects(), \"precondition\");\n+      assert(hr->is_old(), \"precondition\");\n+\n+      _num_old_regions_removed++;\n+      _freed_bytes += hr->used();\n+      hr->set_containing_set(nullptr);\n+      hr->clear_cardtable();\n+      _g1h->concurrent_mark()->clear_statistics(hr);\n+      _g1h->free_region(hr, _local_cleanup_list);\n@@ -1231,12 +1245,30 @@\n-    void update_marked_bytes(HeapRegion* hr) {\n-      uint const region_idx = hr->hrm_index();\n-      size_t const marked_bytes = _cm->live_bytes(region_idx);\n-      \/\/ The marking attributes the object's size completely to the humongous starts\n-      \/\/ region. We need to distribute this value across the entire set of regions a\n-      \/\/ humongous object spans.\n-      if (hr->is_humongous()) {\n-        assert(hr->is_starts_humongous() || marked_bytes == 0,\n-               \"Should not have live bytes %zu in continues humongous region %u (%s)\",\n-               marked_bytes, region_idx, hr->get_type_str());\n-        if (hr->is_starts_humongous()) {\n-          distribute_marked_bytes(hr, marked_bytes);\n+    bool do_heap_region(HeapRegion* hr) override {\n+      G1RemSetTrackingPolicy* tracker = _g1h->policy()->remset_tracker();\n+      if (hr->is_starts_humongous()) {\n+        \/\/ The liveness of this humongous obj decided by either its allocation\n+        \/\/ time (allocated after conc-mark-start, i.e. live) or conc-marking.\n+        const bool is_live = hr->top_at_mark_start() == hr->bottom()\n+                             || _cm->contains_live_object(hr->hrm_index());\n+        if (is_live) {\n+          const bool selected_for_rebuild = tracker->update_humongous_before_rebuild(hr);\n+          auto on_humongous_region = [&] (HeapRegion* hr) {\n+            if (selected_for_rebuild) {\n+              _num_selected_for_rebuild++;\n+            }\n+            _cm->update_top_at_rebuild_start(hr);\n+          };\n+\n+          _g1h->humongous_obj_regions_iterate(hr, on_humongous_region);\n+        } else {\n+          reclaim_empty_humongous_region(hr);\n+        }\n+      } else if (hr->is_old()) {\n+        hr->note_end_of_marking(_cm->live_bytes(hr->hrm_index()));\n+\n+        if (hr->live_bytes() != 0) {\n+          if (tracker->update_old_before_rebuild(hr)) {\n+            _num_selected_for_rebuild++;\n+          }\n+          _cm->update_top_at_rebuild_start(hr);\n+        } else {\n+          reclaim_empty_old_region(hr);\n@@ -1244,3 +1276,0 @@\n-      } else {\n-        log_trace(gc, marking)(\"Adding %zu bytes to region %u (%s)\", marked_bytes, region_idx, hr->get_type_str());\n-        add_marked_bytes_and_note_end(hr, marked_bytes);\n@@ -1248,0 +1277,2 @@\n+\n+      return false;\n@@ -1249,0 +1280,1 @@\n+  };\n@@ -1250,3 +1282,18 @@\n-    void add_marked_bytes_and_note_end(HeapRegion* hr, size_t marked_bytes) {\n-      hr->note_end_of_marking(marked_bytes);\n-      _cl->do_heap_region(hr);\n+public:\n+  G1UpdateRegionLivenessAndSelectForRebuildTask(G1CollectedHeap* g1h,\n+                                                G1ConcurrentMark* cm,\n+                                                uint num_workers) :\n+    WorkerTask(\"G1 Update Region Liveness and Select For Rebuild\"),\n+    _g1h(g1h),\n+    _cm(cm),\n+    _hrclaimer(num_workers),\n+    _total_selected_for_rebuild(0),\n+    _cleanup_list(\"Empty Regions After Mark List\") {}\n+\n+  ~G1UpdateRegionLivenessAndSelectForRebuildTask() {\n+    if (!_cleanup_list.is_empty()) {\n+      log_debug(gc)(\"Reclaimed %u empty regions\", _cleanup_list.length());\n+      \/\/ Now print the empty regions list.\n+      _g1h->hr_printer()->cleanup(&_cleanup_list);\n+      \/\/ And actually make them available.\n+      _g1h->prepend_to_freelist(&_cleanup_list);\n@@ -1254,0 +1301,1 @@\n+  }\n@@ -1255,3 +1303,4 @@\n-  public:\n-    G1UpdateRemSetTrackingBeforeRebuild(G1CollectedHeap* g1h, G1ConcurrentMark* cm, G1PrintRegionLivenessInfoClosure* cl) :\n-      _g1h(g1h), _cm(cm), _cl(cl), _num_regions_selected_for_rebuild(0) { }\n+  void work(uint worker_id) override {\n+    FreeRegionList local_cleanup_list(\"Local Cleanup List\");\n+    G1OnRegionClosure on_region_cl(_g1h, _cm, &local_cleanup_list);\n+    _g1h->heap_region_par_iterate_from_worker_offset(&on_region_cl, &_hrclaimer, worker_id);\n@@ -1259,3 +1308,1 @@\n-    virtual bool do_heap_region(HeapRegion* r) {\n-      update_remset_before_rebuild(r);\n-      update_marked_bytes(r);\n+    Atomic::add(&_total_selected_for_rebuild, on_region_cl._num_selected_for_rebuild);\n@@ -1263,2 +1310,3 @@\n-      return false;\n-    }\n+    \/\/ Update the old\/humongous region sets\n+    _g1h->remove_from_old_gen_sets(on_region_cl._num_old_regions_removed,\n+                                   on_region_cl._num_humongous_regions_removed);\n@@ -1266,2 +1314,3 @@\n-    uint num_selected_for_rebuild() const { return _num_regions_selected_for_rebuild; }\n-  };\n+    {\n+      MutexLocker x(G1RareEvent_lock, Mutex::_no_safepoint_check_flag);\n+      _g1h->decrement_summary_bytes(on_region_cl._freed_bytes);\n@@ -1269,9 +1318,3 @@\n-public:\n-  G1UpdateRemSetTrackingBeforeRebuildTask(G1CollectedHeap* g1h, G1ConcurrentMark* cm, uint num_workers) :\n-    WorkerTask(\"G1 Update RemSet Tracking Before Rebuild\"),\n-    _g1h(g1h), _cm(cm), _hrclaimer(num_workers), _total_selected_for_rebuild(0), _cl(\"Post-Marking\") { }\n-\n-  virtual void work(uint worker_id) {\n-    G1UpdateRemSetTrackingBeforeRebuild update_cl(_g1h, _cm, &_cl);\n-    _g1h->heap_region_par_iterate_from_worker_offset(&update_cl, &_hrclaimer, worker_id);\n-    Atomic::add(&_total_selected_for_rebuild, update_cl.num_selected_for_rebuild());\n+      _cleanup_list.add_ordered(&local_cleanup_list);\n+      assert(local_cleanup_list.is_empty(), \"post-condition\");\n+    }\n@@ -1282,2 +1325,4 @@\n-  \/\/ Number of regions for which roughly one thread should be spawned for this work.\n-  static const uint RegionsPerThread = 384;\n+  static uint desired_num_workers(uint num_regions) {\n+    const uint num_regions_per_worker = 384;\n+    return (num_regions + num_regions_per_worker - 1) \/ num_regions_per_worker;\n+  }\n@@ -1362,1 +1407,1 @@\n-      GCTraceTime(Debug, gc, phases) debug(\"Update Remembered Set Tracking Before Rebuild\", _gc_timer_cm);\n+      GCTraceTime(Debug, gc, phases) debug(\"Select For Rebuild & Reclaim Empty Regions\", _gc_timer_cm);\n@@ -1364,5 +1409,3 @@\n-      uint const workers_by_capacity = (_g1h->num_regions() + G1UpdateRemSetTrackingBeforeRebuildTask::RegionsPerThread - 1) \/\n-                                       G1UpdateRemSetTrackingBeforeRebuildTask::RegionsPerThread;\n-      uint const num_workers = MIN2(_g1h->workers()->active_workers(), workers_by_capacity);\n-\n-      G1UpdateRemSetTrackingBeforeRebuildTask cl(_g1h, this, num_workers);\n+      G1UpdateRegionLivenessAndSelectForRebuildTask cl(_g1h, this, _g1h->workers()->active_workers());\n+      uint const num_workers = MIN2(G1UpdateRegionLivenessAndSelectForRebuildTask::desired_num_workers(_g1h->num_regions()),\n+                                    _g1h->workers()->active_workers());\n@@ -1373,2 +1416,1 @@\n-                                      _g1h->num_regions(), cl.total_selected_for_rebuild());\n-\n+                                        _g1h->num_regions(), cl.total_selected_for_rebuild());\n@@ -1377,3 +1419,4 @@\n-    {\n-      GCTraceTime(Debug, gc, phases) debug(\"Reclaim Empty Regions\", _gc_timer_cm);\n-      reclaim_empty_regions();\n+\n+    if (log_is_enabled(Trace, gc, liveness)) {\n+      G1PrintRegionLivenessInfoClosure cl(\"Post-Marking\");\n+      _g1h->heap_region_iterate(&cl);\n@@ -1427,92 +1470,0 @@\n-class G1ReclaimEmptyRegionsTask : public WorkerTask {\n-  class G1ReclaimEmptyRegionsClosure : public HeapRegionClosure {\n-    G1CollectedHeap* _g1h;\n-    size_t _freed_bytes;\n-    FreeRegionList* _local_cleanup_list;\n-    uint _old_regions_removed;\n-    uint _humongous_regions_removed;\n-\n-  public:\n-    G1ReclaimEmptyRegionsClosure(G1CollectedHeap* g1h,\n-                                 FreeRegionList* local_cleanup_list) :\n-      _g1h(g1h),\n-      _freed_bytes(0),\n-      _local_cleanup_list(local_cleanup_list),\n-      _old_regions_removed(0),\n-      _humongous_regions_removed(0) { }\n-\n-    size_t freed_bytes() { return _freed_bytes; }\n-    uint old_regions_removed() { return _old_regions_removed; }\n-    uint humongous_regions_removed() { return _humongous_regions_removed; }\n-\n-    bool do_heap_region(HeapRegion *hr) {\n-      bool can_reclaim = hr->used() > 0 && hr->live_bytes() == 0 &&\n-                         !hr->is_young() && !hr->has_pinned_objects();\n-\n-      if (can_reclaim) {\n-        log_trace(gc, marking)(\"Reclaimed empty old gen region %u (%s) bot \" PTR_FORMAT,\n-                               hr->hrm_index(), hr->get_short_type_str(), p2i(hr->bottom()));\n-        _freed_bytes += hr->used();\n-        hr->set_containing_set(nullptr);\n-        if (hr->is_humongous()) {\n-          _humongous_regions_removed++;\n-          _g1h->free_humongous_region(hr, _local_cleanup_list);\n-        } else {\n-          _old_regions_removed++;\n-          _g1h->free_region(hr, _local_cleanup_list);\n-        }\n-        hr->clear_cardtable();\n-        _g1h->concurrent_mark()->clear_statistics(hr);\n-      }\n-\n-      return false;\n-    }\n-  };\n-\n-  G1CollectedHeap* _g1h;\n-  FreeRegionList* _cleanup_list;\n-  HeapRegionClaimer _hrclaimer;\n-\n-public:\n-  G1ReclaimEmptyRegionsTask(G1CollectedHeap* g1h, FreeRegionList* cleanup_list, uint n_workers) :\n-    WorkerTask(\"G1 Cleanup\"),\n-    _g1h(g1h),\n-    _cleanup_list(cleanup_list),\n-    _hrclaimer(n_workers) {\n-  }\n-\n-  void work(uint worker_id) {\n-    FreeRegionList local_cleanup_list(\"Local Cleanup List\");\n-    G1ReclaimEmptyRegionsClosure cl(_g1h, &local_cleanup_list);\n-    _g1h->heap_region_par_iterate_from_worker_offset(&cl, &_hrclaimer, worker_id);\n-    assert(cl.is_complete(), \"Shouldn't have aborted!\");\n-\n-    \/\/ Now update the old\/humongous region sets\n-    _g1h->remove_from_old_gen_sets(cl.old_regions_removed(),\n-                                   cl.humongous_regions_removed());\n-    {\n-      MutexLocker x(G1RareEvent_lock, Mutex::_no_safepoint_check_flag);\n-      _g1h->decrement_summary_bytes(cl.freed_bytes());\n-\n-      _cleanup_list->add_ordered(&local_cleanup_list);\n-      assert(local_cleanup_list.is_empty(), \"post-condition\");\n-    }\n-  }\n-};\n-\n-void G1ConcurrentMark::reclaim_empty_regions() {\n-  WorkerThreads* workers = _g1h->workers();\n-  FreeRegionList empty_regions_list(\"Empty Regions After Mark List\");\n-\n-  G1ReclaimEmptyRegionsTask cl(_g1h, &empty_regions_list, workers->active_workers());\n-  workers->run_task(&cl);\n-\n-  if (!empty_regions_list.is_empty()) {\n-    log_debug(gc)(\"Reclaimed %u empty regions\", empty_regions_list.length());\n-    \/\/ Now print the empty regions list.\n-    _g1h->hr_printer()->cleanup(&empty_regions_list);\n-    \/\/ And actually make them available.\n-    _g1h->prepend_to_freelist(&empty_regions_list);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":129,"deletions":178,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -466,2 +466,0 @@\n-  void reclaim_empty_regions();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,16 +57,1 @@\n-static void print_before_rebuild(HeapRegion* r, bool selected_for_rebuild, size_t total_live_bytes, size_t live_bytes) {\n-  log_trace(gc, remset, tracking)(\"Before rebuild region %u \"\n-                                  \"(tams: \" PTR_FORMAT \") \"\n-                                  \"total_live_bytes %zu \"\n-                                  \"selected %s \"\n-                                  \"(live_bytes %zu \"\n-                                  \"type %s)\",\n-                                  r->hrm_index(),\n-                                  p2i(r->top_at_mark_start()),\n-                                  total_live_bytes,\n-                                  BOOL_TO_STR(selected_for_rebuild),\n-                                  live_bytes,\n-                                  r->get_type_str());\n-}\n-\n-bool G1RemSetTrackingPolicy::update_humongous_before_rebuild(HeapRegion* r, bool is_live) {\n+bool G1RemSetTrackingPolicy::update_humongous_before_rebuild(HeapRegion* r) {\n@@ -74,1 +59,1 @@\n-  assert(r->is_humongous(), \"Region %u should be humongous\", r->hrm_index());\n+  assert(r->is_starts_humongous(), \"Region %u should be Humongous\", r->hrm_index());\n@@ -79,5 +64,8 @@\n-  \/\/ For humongous regions, to be of interest for rebuilding the remembered set the following must apply:\n-  \/\/ - We always try to update the remembered sets of humongous regions containing\n-  \/\/ type arrays as they might have been reset after full gc.\n-  if (is_live && cast_to_oop(r->humongous_start_region()->bottom())->is_typeArray() && !r->rem_set()->is_tracked()) {\n-    r->rem_set()->set_state_updating();\n+  \/\/ Humongous regions containing type-array objs are remset-tracked to\n+  \/\/ support eager-reclaim. However, their remset state can be reset after\n+  \/\/ Full-GC. Try to re-enable remset-tracking for them if possible.\n+  if (cast_to_oop(r->bottom())->is_typeArray() && !r->rem_set()->is_tracked()) {\n+    auto on_humongous_region = [] (HeapRegion* r) {\n+      r->rem_set()->set_state_updating();\n+    };\n+    G1CollectedHeap::heap()->humongous_obj_regions_iterate(r, on_humongous_region);\n@@ -87,3 +75,0 @@\n-  size_t const live_bytes = is_live ? HeapRegion::GrainBytes : 0;\n-  print_before_rebuild(r, selected_for_rebuild, live_bytes, live_bytes);\n-\n@@ -93,1 +78,1 @@\n-bool G1RemSetTrackingPolicy::update_before_rebuild(HeapRegion* r, size_t live_bytes_below_tams) {\n+bool G1RemSetTrackingPolicy::update_old_before_rebuild(HeapRegion* r) {\n@@ -95,6 +80,1 @@\n-  assert(!r->is_humongous(), \"Region %u is humongous\", r->hrm_index());\n-\n-  \/\/ Only consider updating the remembered set for old gen regions.\n-  if (!r->is_old()) {\n-    return false;\n-  }\n+  assert(r->is_old(), \"Region %u should be Old\", r->hrm_index());\n@@ -104,3 +84,0 @@\n-  size_t live_bytes_above_tams = pointer_delta(r->top(), r->top_at_mark_start()) * HeapWordSize;\n-  size_t total_live_bytes = live_bytes_below_tams + live_bytes_above_tams;\n-\n@@ -108,8 +85,0 @@\n-  \/\/ For old regions, to be of interest for rebuilding the remembered set the following must apply:\n-  \/\/ - They must contain some live data in them.\n-  \/\/ - Only need to rebuild non-complete remembered sets.\n-  \/\/ - Otherwise only add those old gen regions which occupancy is low enough that there\n-  \/\/ is a chance that we will ever evacuate them in the mixed gcs.\n-  if ((total_live_bytes > 0) &&\n-      G1CollectionSetChooser::region_occupancy_low_enough_for_evac(total_live_bytes) &&\n-      !r->rem_set()->is_tracked()) {\n@@ -117,0 +86,2 @@\n+  if (G1CollectionSetChooser::region_occupancy_low_enough_for_evac(r->live_bytes()) &&\n+      !r->rem_set()->is_tracked()) {\n@@ -121,2 +92,0 @@\n-  print_before_rebuild(r, selected_for_rebuild, total_live_bytes, live_bytes_below_tams);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":14,"deletions":45,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -46,4 +46,4 @@\n-  bool update_humongous_before_rebuild(HeapRegion* r, bool is_live);\n-  \/\/ Update remembered set tracking state before we are going to rebuild remembered\n-  \/\/ sets. Called at safepoint in the remark pause.\n-  bool update_before_rebuild(HeapRegion* r, size_t live_bytes_below_tams);\n+  bool update_humongous_before_rebuild(HeapRegion* r);\n+  \/\/ Update remembered set tracking state for old regions before we are going\n+  \/\/ to rebuild remembered sets. Called at safepoint in the remark pause.\n+  bool update_old_before_rebuild(HeapRegion* r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}