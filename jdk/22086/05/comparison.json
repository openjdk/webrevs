{"files":[{"patch":"@@ -62,0 +62,4 @@\n+    \/\/ chunkSize is a multiple of block size and used to divide up\n+    \/\/ input data to trigger the intrinsic.\n+    private final int chunkSize;\n+\n@@ -66,0 +70,1 @@\n+        chunkSize = blockSize * 6400;\n@@ -151,2 +156,12 @@\n-        return implEncrypt(plain, plainOffset, plainLen,\n-                           cipher, cipherOffset);\n+        int processed = 0;\n+        for (;  plainLen > chunkSize; cipherOffset += chunkSize,\n+            plainOffset += chunkSize, plainLen -= chunkSize) {\n+            processed +=\n+               implEncrypt(plain, plainOffset, chunkSize, cipher, cipherOffset);\n+        }\n+        \/\/ note: above loop always leaves some data to process (more then zero,\n+        \/\/ less then or equal to chunkSize) so this last call can be\n+        \/\/ unconditional\n+        processed +=\n+            implEncrypt(plain, plainOffset, plainLen, cipher, cipherOffset);\n+        return processed;\n@@ -202,1 +217,12 @@\n-        return implDecrypt(cipher, cipherOffset, cipherLen, plain, plainOffset);\n+        int processed = 0;\n+        for (;  cipherLen > chunkSize; cipherOffset += chunkSize,\n+            plainOffset += chunkSize, cipherLen -= chunkSize) {\n+            processed +=\n+               implDecrypt(cipher, cipherOffset, chunkSize, plain, plainOffset);\n+        }\n+        \/\/ note: above loop always leaves some data to process (more then zero,\n+        \/\/ less then or equal to chunkSize) so this last call can be\n+        \/\/ unconditional\n+        processed +=\n+            implDecrypt(cipher, cipherOffset, cipherLen, plain, plainOffset);\n+        return processed;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherBlockChaining.java","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import org.openjdk.jmh.infra.Blackhole;\n+import java.security.GeneralSecurityException;\n+import org.openjdk.jmh.annotations.Fork;\n@@ -39,0 +42,1 @@\n+@Fork(jvmArgsAppend = {\"-Xms20g\", \"-Xmx20g\", \"-XX:+UseZGC\"})\n@@ -41,1 +45,1 @@\n-    public static final int SET_SIZE = 128;\n+    public static final int SET_SIZE = 8;\n@@ -56,0 +60,1 @@\n+    private byte[] outBuffer;\n@@ -69,0 +74,1 @@\n+        outBuffer = new byte[dataSize + 128]; \/\/ extra space for tag, etc\n@@ -78,0 +84,7 @@\n+    @Benchmark\n+    public void encrypt2(Blackhole bh) throws GeneralSecurityException {\n+        byte[] d = data[index];\n+        index = (index +1) % SET_SIZE;\n+        bh.consume(encryptCipher.doFinal(d, 0, d.length, outBuffer));\n+    }\n+\n@@ -85,0 +98,7 @@\n+    @Benchmark\n+    public void decrypt2(Blackhole bh) throws GeneralSecurityException {\n+        byte[] e = encryptedData[index];\n+        index = (index +1) % SET_SIZE;\n+        bh.consume(decryptCipher.doFinal(e, 0, e.length, outBuffer));\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESBench.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"}]}