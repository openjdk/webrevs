{"files":[{"patch":"@@ -62,4 +62,3 @@\n-    \/\/ chunkSize is multiple of block size, but otherwise fairly arbitrary\n-    \/\/ Should be large enough to provide intrinsic with optimization\n-    \/\/ opportunities\n-    private final int chunkSize = 1024*100;\n+    \/\/ chunkSize is a multiple of block size and used to divide up\n+    \/\/ input data to trigger the intrinsic.\n+    private final int chunkSize;\n@@ -71,0 +70,1 @@\n+        chunkSize = blockSize * 6400;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherBlockChaining.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import org.openjdk.jmh.infra.Blackhole;\n+import java.security.GeneralSecurityException;\n+import org.openjdk.jmh.annotations.Fork;\n@@ -39,0 +42,1 @@\n+@Fork(jvmArgsAppend = {\"-Xms20g\", \"-Xmx20g\", \"-XX:+UseZGC\"})\n@@ -41,1 +45,1 @@\n-    public static final int SET_SIZE = 128;\n+    public static final int SET_SIZE = 8;\n@@ -49,1 +53,1 @@\n-    @Param({\"\" + 16 * 1024})\n+    @Param({\"\" + 16 * 16, \"\" + 16 * 128, \"\" + 16 * 1024, \"\" + 16 * 1024})\n@@ -56,0 +60,1 @@\n+    private byte[] outBuffer;\n@@ -69,0 +74,1 @@\n+        outBuffer = new byte[dataSize + 128]; \/\/ extra space for tag, etc\n@@ -78,0 +84,7 @@\n+    @Benchmark\n+    public void encrypt2(Blackhole bh) throws GeneralSecurityException {\n+        byte[] d = data[index];\n+        index = (index +1) % SET_SIZE;\n+        bh.consume(encryptCipher.doFinal(d, 0, d.length, outBuffer));\n+    }\n+\n@@ -85,0 +98,7 @@\n+    @Benchmark\n+    public void decrypt2(Blackhole bh) throws GeneralSecurityException {\n+        byte[] e = encryptedData[index];\n+        index = (index +1) % SET_SIZE;\n+        bh.consume(decryptCipher.doFinal(e, 0, e.length, outBuffer));\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESBench.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"}]}