{"files":[{"patch":"@@ -818,0 +818,1 @@\n+            boolean genericPatternsExpanded = false;\n@@ -827,1 +828,0 @@\n-                    patterns = updatedPatterns;\n@@ -831,0 +831,13 @@\n+                    if (!repeat && !genericPatternsExpanded) {\n+                        \/\/there may be situation like:\n+                        \/\/class B extends S1, S2\n+                        \/\/patterns: R(S1, B), R(S2, S2)\n+                        \/\/this should be joined to R(B, S2),\n+                        \/\/but hashing in reduceNestedPatterns will not allow that\n+                        \/\/attempt to once expand all types to their transitive permitted types,\n+                        \/\/on all depth of nesting:\n+                        updatedPatterns = expandGenericPatterns(updatedPatterns);\n+                        genericPatternsExpanded = true;\n+                        repeat = !updatedPatterns.equals(patterns);\n+                    }\n+                    patterns = updatedPatterns;\n@@ -1133,0 +1146,34 @@\n+        private Set<PatternDescription> expandGenericPatterns(Set<PatternDescription> patterns) {\n+            var newPatterns = new HashSet<PatternDescription>(patterns);\n+            boolean modified;\n+            do {\n+                modified = false;\n+                for (PatternDescription pd : patterns) {\n+                    if (pd instanceof RecordPattern rpOne) {\n+                        for (int i = 0; i < rpOne.nested.length; i++) {\n+                            Set<PatternDescription> toExpand = Set.of(rpOne.nested[i]);\n+                            Set<PatternDescription> expanded = expandGenericPatterns(toExpand);\n+                            if (expanded != toExpand) {\n+                                expanded.removeAll(toExpand);\n+                                for (PatternDescription exp : expanded) {\n+                                    PatternDescription[] newNested = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n+                                    newNested[i] = exp;\n+                                    modified |= newPatterns.add(new RecordPattern(rpOne.recordType(), rpOne.fullComponentTypes(), newNested));\n+                                }\n+                            }\n+                        }\n+                    } else if (pd instanceof BindingPattern bp) {\n+                        Set<Symbol> permittedSymbols = allPermittedSubTypes((ClassSymbol) bp.type.tsym, cs -> true);\n+\n+                        if (!permittedSymbols.isEmpty()) {\n+                            for (Symbol permitted : permittedSymbols) {\n+                                \/\/TODO infer.instantiatePatternType(selectorType, csym); (?)\n+                                modified |= newPatterns.add(new BindingPattern(permitted.type));\n+                            }\n+                        }\n+                    }\n+                }\n+            } while (modified);\n+            return newPatterns;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815\n+ * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215\n@@ -1995,0 +1995,80 @@\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8325215:\n+    public void testTooGenericPatternInRecord(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface A permits T, U {}\n+                   sealed interface B permits V, W {}\n+\n+                   static final class T implements A { public T() {} }\n+                   static final class U implements A { public U() {} }\n+\n+                   static final class V implements B { public V() {} }\n+                   static final class W implements B { public W() {} }\n+\n+                   final static record R(A a, B b) { }\n+\n+                   static int r(R r) {\n+                      return switch (r) {\n+                          case R(A a, V b) -> 1; \/\/ Any A with specific B\n+                          case R(T a, B b) -> 2; \/\/ Specific A with any B\n+                          case R(U a, W b) -> 3; \/\/ Specific A with specific B\n+                      };\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface A permits T, U {}\n+                   sealed interface B permits V, W {}\n+\n+                   static final class T implements A { public T() {} }\n+                   static final class U implements A { public U() {} }\n+\n+                   static final class V implements B { public V() {} }\n+                   static final class W implements B { public W() {} }\n+\n+                   final static record R(B b, A a) { }\n+\n+                   static int r(R r) {\n+                      return switch (r) {\n+                          case R(V b, A a) -> 1; \/\/ Any A with specific B\n+                          case R(B b, T a) -> 2; \/\/ Specific A with any B\n+                          case R(W b, U a) -> 3; \/\/ Specific A with specific B\n+                      };\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface A permits T, U {}\n+                   sealed interface B permits V, W {}\n+\n+                   static final class T implements A { public T() {} }\n+                   static final class U implements A { public U() {} }\n+\n+                   static final class V implements B { public V() {} }\n+                   static final class W implements B { public W() {} }\n+\n+                   final static record X(B b) { }\n+                   final static record R(A a, X x) { }\n+\n+                   static int r(R r) {\n+                      return switch (r) {\n+                          case R(A a, X(V b)) -> 1; \/\/ Any A with specific B\n+                          case R(T a, X(B b)) -> 2; \/\/ Specific A with any B\n+                          case R(U a, X(W b)) -> 3; \/\/ Specific A with specific B\n+                      };\n+                   }\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":81,"deletions":1,"binary":false,"changes":82,"status":"modified"}]}