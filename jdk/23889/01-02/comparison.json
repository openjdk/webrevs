{"files":[{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2024, Intel Corporation. All rights reserved.\n+* Copyright (c) 2024, 2025, Intel Corporation. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_tanh.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n@@ -25,0 +23,17 @@\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -26,3 +41,0 @@\n-package java.lang;\n-\n-import java.math.BigDecimal;\n@@ -30,3 +42,1 @@\n-import jdk.internal.math.FloatConsts;\n-import jdk.internal.math.DoubleConsts;\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n+import java.util.concurrent.TimeUnit;\n@@ -34,1 +44,7 @@\n-import static java.lang.Double.*;\n+@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(2)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@State(Scope.Thread)\n+public class MathBench {\n@@ -36,92 +52,2 @@\n-\/**\n- * The class {@code Math} contains methods for performing basic\n- * numeric operations such as the elementary exponential, logarithm,\n- * square root, and trigonometric functions.\n- *\n- * <p>Unlike some of the numeric methods of class\n- * {@link java.lang.StrictMath StrictMath}, all implementations of the equivalent\n- * functions of class {@code Math} are not defined to return the\n- * bit-for-bit same results.  This relaxation permits\n- * better-performing implementations where strict reproducibility is\n- * not required.\n- *\n- * <p>By default many of the {@code Math} methods simply call\n- * the equivalent method in {@code StrictMath} for their\n- * implementation.  Code generators are encouraged to use\n- * platform-specific native libraries or microprocessor instructions,\n- * where available, to provide higher-performance implementations of\n- * {@code Math} methods.  Such higher-performance\n- * implementations still must conform to the specification for\n- * {@code Math}.\n- *\n- * <p>The quality of implementation specifications concern two\n- * properties, accuracy of the returned result and monotonicity of the\n- * method.  Accuracy of the floating-point {@code Math} methods is\n- * measured in terms of <dfn>{@index ulp}s<\/dfn>, {@index \"units in\n- * the last place\"}.  For a given floating-point format, an\n- * {@linkplain #ulp(double) ulp} of a specific real number value is\n- * the distance between the two floating-point values bracketing that\n- * numerical value.  When discussing the accuracy of a method as a\n- * whole rather than at a specific argument, the number of ulps cited\n- * is for the worst-case error at any argument.  If a method always\n- * has an error less than 0.5 ulps, the method always returns the\n- * floating-point number nearest the exact result; such a method is\n- * <dfn>correctly rounded<\/dfn>.  A {@index \"correctly rounded\"}\n- * method is generally the best a floating-point approximation can be;\n- * however, it is impractical for many floating-point methods to be\n- * correctly rounded.  Instead, for the {@code Math} class, a larger\n- * error bound of 1 or 2 ulps is allowed for certain methods.\n- * Informally, with a 1 ulp error bound, when the exact result is a\n- * representable number, the exact result should be returned as the\n- * computed result; otherwise, either of the two floating-point values\n- * which bracket the exact result may be returned.  For exact results\n- * large in magnitude, one of the endpoints of the bracket may be\n- * infinite.  Besides accuracy at individual arguments, maintaining\n- * proper relations between the method at different arguments is also\n- * important.  Therefore, most methods with more than 0.5 ulp errors\n- * are required to be <dfn>{@index \"semi-monotonic\"}<\/dfn>: whenever\n- * the mathematical function is non-decreasing, so is the\n- * floating-point approximation, likewise, whenever the mathematical\n- * function is non-increasing, so is the floating-point approximation.\n- * Not all approximations that have 1 ulp accuracy will automatically\n- * meet the monotonicity requirements.\n- *\n- * <p>\n- * The platform uses signed two's complement integer arithmetic with\n- * {@code int} and {@code long} primitive types.  The developer should\n- * choose the primitive type to ensure that arithmetic operations\n- * consistently produce correct results, which in some cases means the\n- * operations will not overflow the range of values of the\n- * computation.  The best practice is to choose the primitive type and\n- * algorithm to avoid overflow. In cases where the size is {@code int}\n- * or {@code long} and overflow errors need to be detected, the\n- * methods whose names end with {@code Exact} throw an {@code\n- * ArithmeticException} when the results overflow.\n- *\n- * <h2><a id=Ieee754RecommendedOps>IEEE 754 Recommended\n- * Operations<\/a><\/h2>\n- *\n- * The 2019 revision of the IEEE 754 floating-point standard includes\n- * a section of recommended operations and the semantics of those\n- * operations if they are included in a programming environment. The\n- * recommended operations present in this class include {@link sin\n- * sin}, {@link cos cos}, {@link tan tan}, {@link asin asin}, {@link\n- * acos acos}, {@link atan atan}, {@link exp exp}, {@link expm1\n- * expm1}, {@link log log}, {@link log10 log10}, {@link log1p log1p},\n- * {@link sinh sinh}, {@link cosh cosh}, {@link tanh tanh}, {@link\n- * hypot hypot}, and {@link pow pow}.  (The {@link sqrt sqrt}\n- * operation is a required part of IEEE 754 from a different section\n- * of the standard.) The special case behavior of the recommended\n- * operations generally follows the guidance of the IEEE 754\n- * standard. However, the {@code pow} method defines different\n- * behavior for some arguments, as noted in its {@linkplain pow\n- * specification}. The IEEE 754 standard defines its operations to be\n- * correctly rounded, which is a more stringent quality of\n- * implementation condition than required for most of the methods in\n- * question that are also included in this class.\n- *\n- * @spec https:\/\/standards.ieee.org\/ieee\/754\/6210\/\n- *       IEEE Standard for Floating-Point Arithmetic\n- *\n- * @since   1.0\n- *\/\n+    @Param(\"0\")\n+    public long seed;\n@@ -129,675 +55,37 @@\n-public final class Math {\n-\n-    \/**\n-     * Don't let anyone instantiate this class.\n-     *\/\n-    private Math() {}\n-\n-    \/**\n-     * The {@code double} value that is closer than any other to\n-     * <i>e<\/i>, the base of the natural logarithms.\n-     *\/\n-    public static final double E = 2.718281828459045;\n-\n-    \/**\n-     * The {@code double} value that is closer than any other to\n-     * <i>pi<\/i> (&pi;), the ratio of the circumference of a circle to\n-     * its diameter.\n-     *\/\n-    public static final double PI = 3.141592653589793;\n-\n-    \/**\n-     * The {@code double} value that is closer than any other to\n-     * <i>tau<\/i> (&tau;), the ratio of the circumference of a circle\n-     * to its radius.\n-     *\n-     * @apiNote\n-     * The value of <i>pi<\/i> is one half that of <i>tau<\/i>; in other\n-     * words, <i>tau<\/i> is double <i>pi<\/i> .\n-     *\n-     * @since 19\n-     *\/\n-    public static final double TAU = 2.0 * PI;\n-\n-    \/**\n-     * Constant by which to multiply an angular value in degrees to obtain an\n-     * angular value in radians.\n-     *\/\n-    private static final double DEGREES_TO_RADIANS = 0.017453292519943295;\n-\n-    \/**\n-     * Constant by which to multiply an angular value in radians to obtain an\n-     * angular value in degrees.\n-     *\/\n-    private static final double RADIANS_TO_DEGREES = 57.29577951308232;\n-\n-    \/**\n-     * Returns the trigonometric sine of an angle.  Special cases:\n-     * <ul><li>If the argument is NaN or an infinity, then the\n-     * result is NaN.\n-     * <li>If the argument is zero, then the result is a zero with the\n-     * same sign as the argument.<\/ul>\n-     *\n-     * <p>The computed result must be within 1 ulp of the exact result.\n-     * Results must be semi-monotonic.\n-     *\n-     * @param   a   an angle, in radians.\n-     * @return  the sine of the argument.\n-     *\/\n-    @IntrinsicCandidate\n-    public static double sin(double a) {\n-        return StrictMath.sin(a); \/\/ default impl. delegates to StrictMath\n-    }\n-\n-    \/**\n-     * Returns the trigonometric cosine of an angle. Special cases:\n-     * <ul><li>If the argument is NaN or an infinity, then the\n-     * result is NaN.\n-     * <li>If the argument is zero, then the result is {@code 1.0}.\n-     *<\/ul>\n-     *\n-     * <p>The computed result must be within 1 ulp of the exact result.\n-     * Results must be semi-monotonic.\n-     *\n-     * @param   a   an angle, in radians.\n-     * @return  the cosine of the argument.\n-     *\/\n-    @IntrinsicCandidate\n-    public static double cos(double a) {\n-        return StrictMath.cos(a); \/\/ default impl. delegates to StrictMath\n-    }\n-\n-    \/**\n-     * Returns the trigonometric tangent of an angle.  Special cases:\n-     * <ul><li>If the argument is NaN or an infinity, then the result\n-     * is NaN.\n-     * <li>If the argument is zero, then the result is a zero with the\n-     * same sign as the argument.<\/ul>\n-     *\n-     * <p>The computed result must be within 1.25 ulps of the exact result.\n-     * Results must be semi-monotonic.\n-     *\n-     * @param   a   an angle, in radians.\n-     * @return  the tangent of the argument.\n-     *\/\n-    @IntrinsicCandidate\n-    public static double tan(double a) {\n-        return StrictMath.tan(a); \/\/ default impl. delegates to StrictMath\n-    }\n-\n-    \/**\n-     * Returns the arc sine of a value; the returned angle is in the\n-     * range &minus;<i>pi<\/i>\/2 through <i>pi<\/i>\/2.  Special cases:\n-     * <ul><li>If the argument is NaN or its absolute value is greater\n-     * than 1, then the result is NaN.\n-     * <li>If the argument is zero, then the result is a zero with the\n-     * same sign as the argument.<\/ul>\n-     *\n-     * <p>The computed result must be within 1 ulp of the exact result.\n-     * Results must be semi-monotonic.\n-     *\n-     * @param   a   the value whose arc sine is to be returned.\n-     * @return  the arc sine of the argument.\n-     *\/\n-    public static double asin(double a) {\n-        return StrictMath.asin(a); \/\/ default impl. delegates to StrictMath\n-    }\n-\n-    \/**\n-     * Returns the arc cosine of a value; the returned angle is in the\n-     * range 0.0 through <i>pi<\/i>.  Special case:\n-     * <ul><li>If the argument is NaN or its absolute value is greater\n-     * than 1, then the result is NaN.\n-     * <li>If the argument is {@code 1.0}, the result is positive zero.\n-     * <\/ul>\n-     *\n-     * <p>The computed result must be within 1 ulp of the exact result.\n-     * Results must be semi-monotonic.\n-     *\n-     * @param   a   the value whose arc cosine is to be returned.\n-     * @return  the arc cosine of the argument.\n-     *\/\n-    public static double acos(double a) {\n-        return StrictMath.acos(a); \/\/ default impl. delegates to StrictMath\n-    }\n-\n-    \/**\n-     * Returns the arc tangent of a value; the returned angle is in the\n-     * range &minus;<i>pi<\/i>\/2 through <i>pi<\/i>\/2.  Special cases:\n-     * <ul><li>If the argument is NaN, then the result is NaN.\n-     * <li>If the argument is zero, then the result is a zero with the\n-     * same sign as the argument.\n-     * <li>If the argument is {@linkplain Double#isInfinite infinite},\n-     * then the result is the closest value to <i>pi<\/i>\/2 with the\n-     * same sign as the input.\n-     * <\/ul>\n-     *\n-     * <p>The computed result must be within 1 ulp of the exact result.\n-     * Results must be semi-monotonic.\n-     *\n-     * @param   a   the value whose arc tangent is to be returned.\n-     * @return  the arc tangent of the argument.\n-     *\/\n-    public static double atan(double a) {\n-        return StrictMath.atan(a); \/\/ default impl. delegates to StrictMath\n-    }\n-\n-    \/**\n-     * Converts an angle measured in degrees to an approximately\n-     * equivalent angle measured in radians.  The conversion from\n-     * degrees to radians is generally inexact.\n-     *\n-     * @param   angdeg   an angle, in degrees\n-     * @return  the measurement of the angle {@code angdeg}\n-     *          in radians.\n-     * @since   1.2\n-     *\/\n-    public static double toRadians(double angdeg) {\n-        return angdeg * DEGREES_TO_RADIANS;\n-    }\n-\n-    \/**\n-     * Converts an angle measured in radians to an approximately\n-     * equivalent angle measured in degrees.  The conversion from\n-     * radians to degrees is generally inexact; users should\n-     * <i>not<\/i> expect {@code cos(toRadians(90.0))} to exactly\n-     * equal {@code 0.0}.\n-     *\n-     * @param   angrad   an angle, in radians\n-     * @return  the measurement of the angle {@code angrad}\n-     *          in degrees.\n-     * @since   1.2\n-     *\/\n-    public static double toDegrees(double angrad) {\n-        return angrad * RADIANS_TO_DEGREES;\n-    }\n-\n-    \/**\n-     * Returns Euler's number <i>e<\/i> raised to the power of a\n-     * {@code double} value.  Special cases:\n-     * <ul><li>If the argument is NaN, the result is NaN.\n-     * <li>If the argument is positive infinity, then the result is\n-     * positive infinity.\n-     * <li>If the argument is negative infinity, then the result is\n-     * positive zero.\n-     * <li>If the argument is zero, then the result is {@code 1.0}.\n-     * <\/ul>\n-     *\n-     * <p>The computed result must be within 1 ulp of the exact result.\n-     * Results must be semi-monotonic.\n-     *\n-     * @param   a   the exponent to raise <i>e<\/i> to.\n-     * @return  the value <i>e<\/i><sup>{@code a}<\/sup>,\n-     *          where <i>e<\/i> is the base of the natural logarithms.\n-     *\/\n-    @IntrinsicCandidate\n-    public static double exp(double a) {\n-        return StrictMath.exp(a); \/\/ default impl. delegates to StrictMath\n-    }\n-\n-    \/**\n-     * Returns the natural logarithm (base <i>e<\/i>) of a {@code double}\n-     * value.  Special cases:\n-     * <ul><li>If the argument is NaN or less than zero, then the result\n-     * is NaN.\n-     * <li>If the argument is positive infinity, then the result is\n-     * positive infinity.\n-     * <li>If the argument is positive zero or negative zero, then the\n-     * result is negative infinity.\n-     * <li>If the argument is {@code 1.0}, then the result is positive\n-     * zero.\n-     * <\/ul>\n-     *\n-     * <p>The computed result must be within 1 ulp of the exact result.\n-     * Results must be semi-monotonic.\n-     *\n-     * @param   a   a value\n-     * @return  the value ln&nbsp;{@code a}, the natural logarithm of\n-     *          {@code a}.\n-     *\/\n-    @IntrinsicCandidate\n-    public static double log(double a) {\n-        return StrictMath.log(a); \/\/ default impl. delegates to StrictMath\n-    }\n-\n-    \/**\n-     * Returns the base 10 logarithm of a {@code double} value.\n-     * Special cases:\n-     *\n-     * <ul><li>If the argument is NaN or less than zero, then the result\n-     * is NaN.\n-     * <li>If the argument is positive infinity, then the result is\n-     * positive infinity.\n-     * <li>If the argument is positive zero or negative zero, then the\n-     * result is negative infinity.\n-     * <li>If the argument is equal to 10<sup><i>n<\/i><\/sup> for\n-     * integer <i>n<\/i>, then the result is <i>n<\/i>. In particular,\n-     * if the argument is {@code 1.0} (10<sup>0<\/sup>), then the\n-     * result is positive zero.\n-     * <\/ul>\n-     *\n-     * <p>The computed result must be within 1 ulp of the exact result.\n-     * Results must be semi-monotonic.\n-     *\n-     * @param   a   a value\n-     * @return  the base 10 logarithm of  {@code a}.\n-     * @since 1.5\n-     *\/\n-    @IntrinsicCandidate\n-    public static double log10(double a) {\n-        return StrictMath.log10(a); \/\/ default impl. delegates to StrictMath\n-    }\n-\n-    \/**\n-     * Returns the correctly rounded positive square root of a\n-     * {@code double} value.\n-     * Special cases:\n-     * <ul><li>If the argument is NaN or less than zero, then the result\n-     * is NaN.\n-     * <li>If the argument is positive infinity, then the result is positive\n-     * infinity.\n-     * <li>If the argument is positive zero or negative zero, then the\n-     * result is the same as the argument.<\/ul>\n-     * Otherwise, the result is the {@code double} value closest to\n-     * the true mathematical square root of the argument value.\n-     *\n-     * @apiNote\n-     * This method corresponds to the squareRoot operation defined in\n-     * IEEE 754.\n-     *\n-     * @param   a   a value.\n-     * @return  the positive square root of {@code a}.\n-     *          If the argument is NaN or less than zero, the result is NaN.\n-     *\/\n-    @IntrinsicCandidate\n-    public static double sqrt(double a) {\n-        return StrictMath.sqrt(a); \/\/ default impl. delegates to StrictMath\n-                                   \/\/ Note that hardware sqrt instructions\n-                                   \/\/ frequently can be directly used by JITs\n-                                   \/\/ and should be much faster than doing\n-                                   \/\/ Math.sqrt in software.\n-    }\n-\n-\n-    \/**\n-     * Returns the cube root of a {@code double} value.  For\n-     * positive finite {@code x}, {@code cbrt(-x) ==\n-     * -cbrt(x)}; that is, the cube root of a negative value is\n-     * the negative of the cube root of that value's magnitude.\n-     *\n-     * Special cases:\n-     *\n-     * <ul>\n-     *\n-     * <li>If the argument is NaN, then the result is NaN.\n-     *\n-     * <li>If the argument is infinite, then the result is an infinity\n-     * with the same sign as the argument.\n-     *\n-     * <li>If the argument is zero, then the result is a zero with the\n-     * same sign as the argument.\n-     *\n-     * <\/ul>\n-     *\n-     * <p>The computed result must be within 1 ulp of the exact result.\n-     *\n-     * @param   a   a value.\n-     * @return  the cube root of {@code a}.\n-     * @since 1.5\n-     *\/\n-    public static double cbrt(double a) {\n-        return StrictMath.cbrt(a);\n-    }\n-\n-    \/**\n-     * Computes the remainder operation on two arguments as prescribed\n-     * by the IEEE 754 standard.\n-     * The remainder value is mathematically equal to\n-     * <code>f1&nbsp;-&nbsp;f2<\/code>&nbsp;&times;&nbsp;<i>n<\/i>,\n-     * where <i>n<\/i> is the mathematical integer closest to the exact\n-     * mathematical value of the quotient {@code f1\/f2}, and if two\n-     * mathematical integers are equally close to {@code f1\/f2},\n-     * then <i>n<\/i> is the integer that is even. If the remainder is\n-     * zero, its sign is the same as the sign of the first argument.\n-     * Special cases:\n-     * <ul><li>If either argument is NaN, or the first argument is infinite,\n-     * or the second argument is positive zero or negative zero, then the\n-     * result is NaN.\n-     * <li>If the first argument is finite and the second argument is\n-     * infinite, then the result is the same as the first argument.<\/ul>\n-     *\n-     * @param   f1   the dividend.\n-     * @param   f2   the divisor.\n-     * @return  the remainder when {@code f1} is divided by\n-     *          {@code f2}.\n-     *\/\n-    public static double IEEEremainder(double f1, double f2) {\n-        return StrictMath.IEEEremainder(f1, f2); \/\/ delegate to StrictMath\n-    }\n-\n-    \/**\n-     * Returns the smallest (closest to negative infinity)\n-     * {@code double} value that is greater than or equal to the\n-     * argument and is equal to a mathematical integer. Special cases:\n-     * <ul><li>If the argument value is already equal to a\n-     * mathematical integer, then the result is the same as the\n-     * argument.  <li>If the argument is NaN or an infinity or\n-     * positive zero or negative zero, then the result is the same as\n-     * the argument.  <li>If the argument value is less than zero but\n-     * greater than -1.0, then the result is negative zero.<\/ul> Note\n-     * that the value of {@code Math.ceil(x)} is exactly the\n-     * value of {@code -Math.floor(-x)}.\n-     *\n-     * @apiNote\n-     * This method corresponds to the roundToIntegralTowardPositive\n-     * operation defined in IEEE 754.\n-     *\n-     * @param   a   a value.\n-     * @return  the smallest (closest to negative infinity)\n-     *          floating-point value that is greater than or equal to\n-     *          the argument and is equal to a mathematical integer.\n-     *\/\n-    @IntrinsicCandidate\n-    public static double ceil(double a) {\n-        return StrictMath.ceil(a); \/\/ default impl. delegates to StrictMath\n-    }\n-\n-    \/**\n-     * Returns the largest (closest to positive infinity)\n-     * {@code double} value that is less than or equal to the\n-     * argument and is equal to a mathematical integer. Special cases:\n-     * <ul><li>If the argument value is already equal to a\n-     * mathematical integer, then the result is the same as the\n-     * argument.  <li>If the argument is NaN or an infinity or\n-     * positive zero or negative zero, then the result is the same as\n-     * the argument.<\/ul>\n-     *\n-     * @apiNote\n-     * This method corresponds to the roundToIntegralTowardNegative\n-     * operation defined in IEEE 754.\n-     *\n-     * @param   a   a value.\n-     * @return  the largest (closest to positive infinity)\n-     *          floating-point value that less than or equal to the argument\n-     *          and is equal to a mathematical integer.\n-     *\/\n-    @IntrinsicCandidate\n-    public static double floor(double a) {\n-        return StrictMath.floor(a); \/\/ default impl. delegates to StrictMath\n-    }\n-\n-    \/**\n-     * Returns the {@code double} value that is closest in value\n-     * to the argument and is equal to a mathematical integer. If two\n-     * {@code double} values that are mathematical integers are\n-     * equally close, the result is the integer value that is\n-     * even. Special cases:\n-     * <ul><li>If the argument value is already equal to a mathematical\n-     * integer, then the result is the same as the argument.\n-     * <li>If the argument is NaN or an infinity or positive zero or negative\n-     * zero, then the result is the same as the argument.<\/ul>\n-     *\n-     * @apiNote\n-     * This method corresponds to the roundToIntegralTiesToEven\n-     * operation defined in IEEE 754.\n-     *\n-     * @param   a   a {@code double} value.\n-     * @return  the closest floating-point value to {@code a} that is\n-     *          equal to a mathematical integer.\n-     *\/\n-    @IntrinsicCandidate\n-    public static double rint(double a) {\n-        return StrictMath.rint(a); \/\/ default impl. delegates to StrictMath\n-    }\n-\n-    \/**\n-     * Returns the angle <i>theta<\/i> from the conversion of rectangular\n-     * coordinates ({@code x},&nbsp;{@code y}) to polar\n-     * coordinates (r,&nbsp;<i>theta<\/i>).\n-     * This method computes the phase <i>theta<\/i> by computing an arc tangent\n-     * of {@code y\/x} in the range of &minus;<i>pi<\/i> to <i>pi<\/i>. Special\n-     * cases:\n-     * <ul><li>If either argument is NaN, then the result is NaN.\n-     * <li>If the first argument is positive zero and the second argument\n-     * is positive, or the first argument is positive and finite and the\n-     * second argument is positive infinity, then the result is positive\n-     * zero.\n-     * <li>If the first argument is negative zero and the second argument\n-     * is positive, or the first argument is negative and finite and the\n-     * second argument is positive infinity, then the result is negative zero.\n-     * <li>If the first argument is positive zero and the second argument\n-     * is negative, or the first argument is positive and finite and the\n-     * second argument is negative infinity, then the result is the\n-     * {@code double} value closest to <i>pi<\/i>.\n-     * <li>If the first argument is negative zero and the second argument\n-     * is negative, or the first argument is negative and finite and the\n-     * second argument is negative infinity, then the result is the\n-     * {@code double} value closest to -<i>pi<\/i>.\n-     * <li>If the first argument is positive and the second argument is\n-     * positive zero or negative zero, or the first argument is positive\n-     * infinity and the second argument is finite, then the result is the\n-     * {@code double} value closest to <i>pi<\/i>\/2.\n-     * <li>If the first argument is negative and the second argument is\n-     * positive zero or negative zero, or the first argument is negative\n-     * infinity and the second argument is finite, then the result is the\n-     * {@code double} value closest to -<i>pi<\/i>\/2.\n-     * <li>If both arguments are positive infinity, then the result is the\n-     * {@code double} value closest to <i>pi<\/i>\/4.\n-     * <li>If the first argument is positive infinity and the second argument\n-     * is negative infinity, then the result is the {@code double}\n-     * value closest to 3*<i>pi<\/i>\/4.\n-     * <li>If the first argument is negative infinity and the second argument\n-     * is positive infinity, then the result is the {@code double} value\n-     * closest to -<i>pi<\/i>\/4.\n-     * <li>If both arguments are negative infinity, then the result is the\n-     * {@code double} value closest to -3*<i>pi<\/i>\/4.<\/ul>\n-     *\n-     * <p>The computed result must be within 2 ulps of the exact result.\n-     * Results must be semi-monotonic.\n-     *\n-     * @apiNote\n-     * For <i>y<\/i> with a positive sign and finite nonzero\n-     * <i>x<\/i>, the exact mathematical value of {@code atan2} is\n-     * equal to:\n-     * <ul>\n-     * <li>If <i>x<\/i> {@literal >} 0, atan(abs(<i>y<\/i>\/<i>x<\/i>))\n-     * <li>If <i>x<\/i> {@literal <} 0, &pi; - atan(abs(<i>y<\/i>\/<i>x<\/i>))\n-     * <\/ul>\n-     *\n-     * @param   y   the ordinate coordinate\n-     * @param   x   the abscissa coordinate\n-     * @return  the <i>theta<\/i> component of the point\n-     *          (<i>r<\/i>,&nbsp;<i>theta<\/i>)\n-     *          in polar coordinates that corresponds to the point\n-     *          (<i>x<\/i>,&nbsp;<i>y<\/i>) in Cartesian coordinates.\n-     *\/\n-    @IntrinsicCandidate\n-    public static double atan2(double y, double x) {\n-        return StrictMath.atan2(y, x); \/\/ default impl. delegates to StrictMath\n-    }\n-\n-    \/**\n-     * Returns the value of the first argument raised to the power of the\n-     * second argument. Special cases:\n-     *\n-     * <ul><li>If the second argument is positive or negative zero, then the\n-     * result is 1.0.\n-     * <li>If the second argument is 1.0, then the result is the same as the\n-     * first argument.\n-     * <li>If the second argument is NaN, then the result is NaN.\n-     * <li>If the first argument is NaN and the second argument is nonzero,\n-     * then the result is NaN.\n-     *\n-     * <li>If\n-     * <ul>\n-     * <li>the absolute value of the first argument is greater than 1\n-     * and the second argument is positive infinity, or\n-     * <li>the absolute value of the first argument is less than 1 and\n-     * the second argument is negative infinity,\n-     * <\/ul>\n-     * then the result is positive infinity.\n-     *\n-     * <li>If\n-     * <ul>\n-     * <li>the absolute value of the first argument is greater than 1 and\n-     * the second argument is negative infinity, or\n-     * <li>the absolute value of the\n-     * first argument is less than 1 and the second argument is positive\n-     * infinity,\n-     * <\/ul>\n-     * then the result is positive zero.\n-     *\n-     * <li>If the absolute value of the first argument equals 1 and the\n-     * second argument is infinite, then the result is NaN.\n-     *\n-     * <li>If\n-     * <ul>\n-     * <li>the first argument is positive zero and the second argument\n-     * is greater than zero, or\n-     * <li>the first argument is positive infinity and the second\n-     * argument is less than zero,\n-     * <\/ul>\n-     * then the result is positive zero.\n-     *\n-     * <li>If\n-     * <ul>\n-     * <li>the first argument is positive zero and the second argument\n-     * is less than zero, or\n-     * <li>the first argument is positive infinity and the second\n-     * argument is greater than zero,\n-     * <\/ul>\n-     * then the result is positive infinity.\n-     *\n-     * <li>If\n-     * <ul>\n-     * <li>the first argument is negative zero and the second argument\n-     * is greater than zero but not a finite odd integer, or\n-     * <li>the first argument is negative infinity and the second\n-     * argument is less than zero but not a finite odd integer,\n-     * <\/ul>\n-     * then the result is positive zero.\n-     *\n-     * <li>If\n-     * <ul>\n-     * <li>the first argument is negative zero and the second argument\n-     * is a positive finite odd integer, or\n-     * <li>the first argument is negative infinity and the second\n-     * argument is a negative finite odd integer,\n-     * <\/ul>\n-     * then the result is negative zero.\n-     *\n-     * <li>If\n-     * <ul>\n-     * <li>the first argument is negative zero and the second argument\n-     * is less than zero but not a finite odd integer, or\n-     * <li>the first argument is negative infinity and the second\n-     * argument is greater than zero but not a finite odd integer,\n-     * <\/ul>\n-     * then the result is positive infinity.\n-     *\n-     * <li>If\n-     * <ul>\n-     * <li>the first argument is negative zero and the second argument\n-     * is a negative finite odd integer, or\n-     * <li>the first argument is negative infinity and the second\n-     * argument is a positive finite odd integer,\n-     * <\/ul>\n-     * then the result is negative infinity.\n-     *\n-     * <li>If the first argument is finite and less than zero\n-     * <ul>\n-     * <li> if the second argument is a finite even integer, the\n-     * result is equal to the result of raising the absolute value of\n-     * the first argument to the power of the second argument\n-     *\n-     * <li>if the second argument is a finite odd integer, the result\n-     * is equal to the negative of the result of raising the absolute\n-     * value of the first argument to the power of the second\n-     * argument\n-     *\n-     * <li>if the second argument is finite and not an integer, then\n-     * the result is NaN.\n-     * <\/ul>\n-     *\n-     * <li>If both arguments are integers, then the result is exactly equal\n-     * to the mathematical result of raising the first argument to the power\n-     * of the second argument if that result can in fact be represented\n-     * exactly as a {@code double} value.<\/ul>\n-     *\n-     * <p>(In the foregoing descriptions, a floating-point value is\n-     * considered to be an integer if and only if it is finite and a\n-     * fixed point of the method {@link #ceil ceil} or,\n-     * equivalently, a fixed point of the method {@link #floor\n-     * floor}. A value is a fixed point of a one-argument\n-     * method if and only if the result of applying the method to the\n-     * value is equal to the value.)\n-     *\n-     * <p>The computed result must be within 1 ulp of the exact result.\n-     * Results must be semi-monotonic.\n-     *\n-     * @apiNote\n-     * The special cases definitions of this method differ from the\n-     * special case definitions of the IEEE 754 recommended {@code\n-     * pow} operation for &plusmn;{@code 1.0} raised to an infinite\n-     * power. This method treats such cases as indeterminate and\n-     * specifies a NaN is returned. The IEEE 754 specification treats\n-     * the infinite power as a large integer (large-magnitude\n-     * floating-point numbers are numerically integers, specifically\n-     * even integers) and therefore specifies {@code 1.0} be returned.\n-     *\n-     * @param   a   the base.\n-     * @param   b   the exponent.\n-     * @return  the value {@code a}<sup>{@code b}<\/sup>.\n-     *\/\n-    @IntrinsicCandidate\n-    public static double pow(double a, double b) {\n-        return StrictMath.pow(a, b); \/\/ default impl. delegates to StrictMath\n-    }\n-\n-    \/**\n-     * Returns the closest {@code int} to the argument, with ties\n-     * rounding to positive infinity.\n-     *\n-     * <p>\n-     * Special cases:\n-     * <ul><li>If the argument is NaN, the result is 0.\n-     * <li>If the argument is negative infinity or any value less than or\n-     * equal to the value of {@code Integer.MIN_VALUE}, the result is\n-     * equal to the value of {@code Integer.MIN_VALUE}.\n-     * <li>If the argument is positive infinity or any value greater than or\n-     * equal to the value of {@code Integer.MAX_VALUE}, the result is\n-     * equal to the value of {@code Integer.MAX_VALUE}.<\/ul>\n-     *\n-     * @param   a   a floating-point value to be rounded to an integer.\n-     * @return  the value of the argument rounded to the nearest\n-     *          {@code int} value.\n-     * @see     java.lang.Integer#MAX_VALUE\n-     * @see     java.lang.Integer#MIN_VALUE\n-     *\/\n-    @IntrinsicCandidate\n-    public static int round(float a) {\n-        int intBits = Float.floatToRawIntBits(a);\n-        int biasedExp = (intBits & FloatConsts.EXP_BIT_MASK)\n-                >> (FloatConsts.SIGNIFICAND_WIDTH - 1);\n-        int shift = (FloatConsts.SIGNIFICAND_WIDTH - 2\n-                + FloatConsts.EXP_BIAS) - biasedExp;\n-        if ((shift & -32) == 0) { \/\/ shift >= 0 && shift < 32\n-            \/\/ a is a finite number such that pow(2,-32) <= ulp(a) < 1\n-            int r = ((intBits & FloatConsts.SIGNIF_BIT_MASK)\n-                    | (FloatConsts.SIGNIF_BIT_MASK + 1));\n-            if (intBits < 0) {\n-                r = -r;\n-            }\n-            \/\/ In the comments below each Java expression evaluates to the value\n-            \/\/ the corresponding mathematical expression:\n-            \/\/ (r) evaluates to a \/ ulp(a)\n-            \/\/ (r >> shift) evaluates to floor(a * 2)\n-            \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n-            \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n-            return ((r >> shift) + 1) >> 1;\n-        } else {\n-            \/\/ a is either\n-            \/\/ - a finite number with abs(a) < exp(2,FloatConsts.SIGNIFICAND_WIDTH-32) < 1\/2\n-            \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n-            \/\/ - an infinity or NaN\n-            return (int) a;\n+    public int dividend;\n+    public int divisor;\n+\n+    public long longDividend;\n+    public long longDivisor;\n+\n+    public int int1 = 1, int2 = 2, int42 = 42, int5 = 5;\n+    public long long1 = 1L, long2 = 2L, long747 = 747L, long13 = 13L;\n+    public float float1 = 1.0f, float2 = 2.0f, floatNegative99 = -99.0f, float7 = 7.0f, eFloat = 2.718f;\n+    public double double1 = 1.0d, double2 = 2.0d, double81 = 81.0d, doubleNegative12 = -12.0d, double4Dot1 = 4.1d, double0Dot5 = 0.5d;\n+\n+    @Param(\"2048\")\n+    public int tanhValueCount;\n+\n+    @Param(\"0\")\n+    public double tanhBound1;\n+\n+    @Param(\"2.7755575615628914E-17\")\n+    public double tanhBound2;\n+\n+    public double [] tanhPosVector;\n+    public double [] tanhNegVector;\n+\n+    @Setup\n+    public void setupValues() {\n+        Random random = new Random(seed);\n+        dividend = Math.abs(random.nextInt() + 4711);\n+        divisor  = Math.abs(random.nextInt(dividend) + 17);\n+        longDividend = Math.abs(random.nextLong() + 4711L);\n+        longDivisor  = Math.abs(random.nextLong() + longDividend);\n+\n+        \/\/ Fill the positive and negative tanh vectors with random values\n+        tanhPosVector = new double[tanhValueCount];\n+        tanhNegVector = new double[tanhValueCount];\n+        for (int i = 0; i < tanhValueCount; i++) {\n+            tanhPosVector[i] = random.nextDouble(tanhBound1, tanhBound2);\n+            tanhNegVector[i] = random.nextDouble(-tanhBound2, -tanhBound1);\n@@ -807,48 +95,3 @@\n-    \/**\n-     * Returns the closest {@code long} to the argument, with ties\n-     * rounding to positive infinity.\n-     *\n-     * <p>Special cases:\n-     * <ul><li>If the argument is NaN, the result is 0.\n-     * <li>If the argument is negative infinity or any value less than or\n-     * equal to the value of {@code Long.MIN_VALUE}, the result is\n-     * equal to the value of {@code Long.MIN_VALUE}.\n-     * <li>If the argument is positive infinity or any value greater than or\n-     * equal to the value of {@code Long.MAX_VALUE}, the result is\n-     * equal to the value of {@code Long.MAX_VALUE}.<\/ul>\n-     *\n-     * @param   a   a floating-point value to be rounded to a\n-     *          {@code long}.\n-     * @return  the value of the argument rounded to the nearest\n-     *          {@code long} value.\n-     * @see     java.lang.Long#MAX_VALUE\n-     * @see     java.lang.Long#MIN_VALUE\n-     *\/\n-    @IntrinsicCandidate\n-    public static long round(double a) {\n-        long longBits = Double.doubleToRawLongBits(a);\n-        long biasedExp = (longBits & DoubleConsts.EXP_BIT_MASK)\n-                >> (DoubleConsts.SIGNIFICAND_WIDTH - 1);\n-        long shift = (DoubleConsts.SIGNIFICAND_WIDTH - 2\n-                + DoubleConsts.EXP_BIAS) - biasedExp;\n-        if ((shift & -64) == 0) { \/\/ shift >= 0 && shift < 64\n-            \/\/ a is a finite number such that pow(2,-64) <= ulp(a) < 1\n-            long r = ((longBits & DoubleConsts.SIGNIF_BIT_MASK)\n-                    | (DoubleConsts.SIGNIF_BIT_MASK + 1));\n-            if (longBits < 0) {\n-                r = -r;\n-            }\n-            \/\/ In the comments below each Java expression evaluates to the value\n-            \/\/ the corresponding mathematical expression:\n-            \/\/ (r) evaluates to a \/ ulp(a)\n-            \/\/ (r >> shift) evaluates to floor(a * 2)\n-            \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n-            \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n-            return ((r >> shift) + 1) >> 1;\n-        } else {\n-            \/\/ a is either\n-            \/\/ - a finite number with abs(a) < exp(2,DoubleConsts.SIGNIFICAND_WIDTH-64) < 1\/2\n-            \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n-            \/\/ - an infinity or NaN\n-            return (long) a;\n-        }\n+    @Benchmark\n+    public double  absDouble() {\n+        return  Math.abs(doubleNegative12);\n@@ -857,407 +100,4 @@\n-    private static final class RandomNumberGeneratorHolder {\n-        static final Random randomNumberGenerator = new Random();\n-    }\n-\n-    \/**\n-     * Returns a {@code double} value with a positive sign, greater\n-     * than or equal to {@code 0.0} and less than {@code 1.0}.\n-     * Returned values are chosen pseudorandomly with (approximately)\n-     * uniform distribution from that range.\n-     *\n-     * <p>When this method is first called, it creates a single new\n-     * pseudorandom-number generator, exactly as if by the expression\n-     *\n-     * <blockquote>{@code new java.util.Random()}<\/blockquote>\n-     *\n-     * This new pseudorandom-number generator is used thereafter for\n-     * all calls to this method and is used nowhere else.\n-     *\n-     * <p>This method is properly synchronized to allow correct use by\n-     * more than one thread. However, if many threads need to generate\n-     * pseudorandom numbers at a great rate, it may reduce contention\n-     * for each thread to have its own pseudorandom-number generator.\n-     *\n-     * @apiNote\n-     * As the largest {@code double} value less than {@code 1.0}\n-     * is {@code Math.nextDown(1.0)}, a value {@code x} in the closed range\n-     * {@code [x1,x2]} where {@code x1<=x2} may be defined by the statements\n-     *\n-     * <blockquote><pre>{@code\n-     * double f = Math.random()\/Math.nextDown(1.0);\n-     * double x = x1*(1.0 - f) + x2*f;\n-     * }<\/pre><\/blockquote>\n-     *\n-     * @return  a pseudorandom {@code double} greater than or equal\n-     * to {@code 0.0} and less than {@code 1.0}.\n-     * @see #nextDown(double)\n-     * @see Random#nextDouble()\n-     *\/\n-    public static double random() {\n-        return RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble();\n-    }\n-\n-    \/**\n-     * Returns the sum of its arguments,\n-     * throwing an exception if the result overflows an {@code int}.\n-     *\n-     * @param x the first value\n-     * @param y the second value\n-     * @return the result\n-     * @throws ArithmeticException if the result overflows an int\n-     * @since 1.8\n-     *\/\n-    @IntrinsicCandidate\n-    public static int addExact(int x, int y) {\n-        int r = x + y;\n-        \/\/ HD 2-12 Overflow iff both arguments have the opposite sign of the result\n-        if (((x ^ r) & (y ^ r)) < 0) {\n-            throw new ArithmeticException(\"integer overflow\");\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * Returns the sum of its arguments,\n-     * throwing an exception if the result overflows a {@code long}.\n-     *\n-     * @param x the first value\n-     * @param y the second value\n-     * @return the result\n-     * @throws ArithmeticException if the result overflows a long\n-     * @since 1.8\n-     *\/\n-    @IntrinsicCandidate\n-    public static long addExact(long x, long y) {\n-        long r = x + y;\n-        \/\/ HD 2-12 Overflow iff both arguments have the opposite sign of the result\n-        if (((x ^ r) & (y ^ r)) < 0) {\n-            throw new ArithmeticException(\"long overflow\");\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * Returns the difference of the arguments,\n-     * throwing an exception if the result overflows an {@code int}.\n-     *\n-     * @param x the first value\n-     * @param y the second value to subtract from the first\n-     * @return the result\n-     * @throws ArithmeticException if the result overflows an int\n-     * @since 1.8\n-     *\/\n-    @IntrinsicCandidate\n-    public static int subtractExact(int x, int y) {\n-        int r = x - y;\n-        \/\/ HD 2-12 Overflow iff the arguments have different signs and\n-        \/\/ the sign of the result is different from the sign of x\n-        if (((x ^ y) & (x ^ r)) < 0) {\n-            throw new ArithmeticException(\"integer overflow\");\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * Returns the difference of the arguments,\n-     * throwing an exception if the result overflows a {@code long}.\n-     *\n-     * @param x the first value\n-     * @param y the second value to subtract from the first\n-     * @return the result\n-     * @throws ArithmeticException if the result overflows a long\n-     * @since 1.8\n-     *\/\n-    @IntrinsicCandidate\n-    public static long subtractExact(long x, long y) {\n-        long r = x - y;\n-        \/\/ HD 2-12 Overflow iff the arguments have different signs and\n-        \/\/ the sign of the result is different from the sign of x\n-        if (((x ^ y) & (x ^ r)) < 0) {\n-            throw new ArithmeticException(\"long overflow\");\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * Returns the product of the arguments,\n-     * throwing an exception if the result overflows an {@code int}.\n-     *\n-     * @param x the first value\n-     * @param y the second value\n-     * @return the result\n-     * @throws ArithmeticException if the result overflows an int\n-     * @since 1.8\n-     *\/\n-    @IntrinsicCandidate\n-    public static int multiplyExact(int x, int y) {\n-        long r = (long)x * (long)y;\n-        if ((int)r != r) {\n-            throw new ArithmeticException(\"integer overflow\");\n-        }\n-        return (int)r;\n-    }\n-\n-    \/**\n-     * Returns the product of the arguments, throwing an exception if the result\n-     * overflows a {@code long}.\n-     *\n-     * @param x the first value\n-     * @param y the second value\n-     * @return the result\n-     * @throws ArithmeticException if the result overflows a long\n-     * @since 9\n-     *\/\n-    public static long multiplyExact(long x, int y) {\n-        return multiplyExact(x, (long)y);\n-    }\n-\n-    \/**\n-     * Returns the product of the arguments,\n-     * throwing an exception if the result overflows a {@code long}.\n-     *\n-     * @param x the first value\n-     * @param y the second value\n-     * @return the result\n-     * @throws ArithmeticException if the result overflows a long\n-     * @since 1.8\n-     *\/\n-    @IntrinsicCandidate\n-    public static long multiplyExact(long x, long y) {\n-        long r = x * y;\n-        long ax = Math.abs(x);\n-        long ay = Math.abs(y);\n-        if (((ax | ay) >>> 31 != 0)) {\n-            \/\/ Some bits greater than 2^31 that might cause overflow\n-            \/\/ Check the result using the divide operator\n-            \/\/ and check for the special case of Long.MIN_VALUE * -1\n-           if (((y != 0) && (r \/ y != x)) ||\n-               (x == Long.MIN_VALUE && y == -1)) {\n-                throw new ArithmeticException(\"long overflow\");\n-            }\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * Returns the quotient of the arguments, throwing an exception if the\n-     * result overflows an {@code int}.  Such overflow occurs in this method if\n-     * {@code x} is {@link Integer#MIN_VALUE} and {@code y} is {@code -1}.\n-     * In contrast, if {@code Integer.MIN_VALUE \/ -1} were evaluated directly,\n-     * the result would be {@code Integer.MIN_VALUE} and no exception would be\n-     * thrown.\n-     * <p>\n-     * If {@code y} is zero, an {@code ArithmeticException} is thrown\n-     * (JLS {@jls 15.17.2}).\n-     * <p>\n-     * The built-in remainder operator \"{@code %}\" is a suitable counterpart\n-     * both for this method and for the built-in division operator \"{@code \/}\".\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the quotient {@code x \/ y}\n-     * @throws ArithmeticException if {@code y} is zero or the quotient\n-     * overflows an int\n-     * @jls 15.17.2 Division Operator \/\n-     * @since 18\n-     *\/\n-    public static int divideExact(int x, int y) {\n-        int q = x \/ y;\n-        if ((x & y & q) >= 0) {\n-            return q;\n-        }\n-        throw new ArithmeticException(\"integer overflow\");\n-    }\n-\n-    \/**\n-     * Returns the quotient of the arguments, throwing an exception if the\n-     * result overflows a {@code long}.  Such overflow occurs in this method if\n-     * {@code x} is {@link Long#MIN_VALUE} and {@code y} is {@code -1}.\n-     * In contrast, if {@code Long.MIN_VALUE \/ -1} were evaluated directly,\n-     * the result would be {@code Long.MIN_VALUE} and no exception would be\n-     * thrown.\n-     * <p>\n-     * If {@code y} is zero, an {@code ArithmeticException} is thrown\n-     * (JLS {@jls 15.17.2}).\n-     * <p>\n-     * The built-in remainder operator \"{@code %}\" is a suitable counterpart\n-     * both for this method and for the built-in division operator \"{@code \/}\".\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the quotient {@code x \/ y}\n-     * @throws ArithmeticException if {@code y} is zero or the quotient\n-     * overflows a long\n-     * @jls 15.17.2 Division Operator \/\n-     * @since 18\n-     *\/\n-    public static long divideExact(long x, long y) {\n-        long q = x \/ y;\n-        if ((x & y & q) >= 0) {\n-            return q;\n-        }\n-        throw new ArithmeticException(\"long overflow\");\n-    }\n-\n-    \/**\n-     * Returns the largest (closest to positive infinity)\n-     * {@code int} value that is less than or equal to the algebraic quotient.\n-     * This method is identical to {@link #floorDiv(int,int)} except that it\n-     * throws an {@code ArithmeticException} when the dividend is\n-     * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is\n-     * {@code -1} instead of ignoring the integer overflow and returning\n-     * {@code Integer.MIN_VALUE}.\n-     * <p>\n-     * The floor modulus method {@link #floorMod(int,int)} is a suitable\n-     * counterpart both for this method and for the {@link #floorDiv(int,int)}\n-     * method.\n-     * <p>\n-     * For examples, see {@link #floorDiv(int, int)}.\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the largest (closest to positive infinity)\n-     * {@code int} value that is less than or equal to the algebraic quotient.\n-     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n-     * dividend {@code x} is {@code Integer.MIN_VALUE} and the divisor {@code y}\n-     * is {@code -1}.\n-     * @see #floorDiv(int, int)\n-     * @since 18\n-     *\/\n-    public static int floorDivExact(int x, int y) {\n-        final int q = x \/ y;\n-        if ((x & y & q) >= 0) {\n-            \/\/ if the signs are different and modulo not zero, round down\n-            if ((x ^ y) < 0 && (q * y != x)) {\n-                return q - 1;\n-            }\n-            return q;\n-        }\n-        throw new ArithmeticException(\"integer overflow\");\n-    }\n-\n-    \/**\n-     * Returns the largest (closest to positive infinity)\n-     * {@code long} value that is less than or equal to the algebraic quotient.\n-     * This method is identical to {@link #floorDiv(long,long)} except that it\n-     * throws an {@code ArithmeticException} when the dividend is\n-     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is\n-     * {@code -1} instead of ignoring the integer overflow and returning\n-     * {@code Long.MIN_VALUE}.\n-     * <p>\n-     * The floor modulus method {@link #floorMod(long,long)} is a suitable\n-     * counterpart both for this method and for the {@link #floorDiv(long,long)}\n-     * method.\n-     * <p>\n-     * For examples, see {@link #floorDiv(int, int)}.\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the largest (closest to positive infinity)\n-     * {@code long} value that is less than or equal to the algebraic quotient.\n-     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n-     * dividend {@code x} is {@code Long.MIN_VALUE} and the divisor {@code y}\n-     * is {@code -1}.\n-     * @see #floorDiv(long,long)\n-     * @since 18\n-     *\/\n-    public static long floorDivExact(long x, long y) {\n-        final long q = x \/ y;\n-        if ((x & y & q) >= 0) {\n-            \/\/ if the signs are different and modulo not zero, round down\n-            if ((x ^ y) < 0 && (q * y != x)) {\n-                return q - 1;\n-            }\n-            return q;\n-        }\n-        throw new ArithmeticException(\"long overflow\");\n-    }\n-\n-    \/**\n-     * Returns the smallest (closest to negative infinity)\n-     * {@code int} value that is greater than or equal to the algebraic quotient.\n-     * This method is identical to {@link #ceilDiv(int,int)} except that it\n-     * throws an {@code ArithmeticException} when the dividend is\n-     * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is\n-     * {@code -1} instead of ignoring the integer overflow and returning\n-     * {@code Integer.MIN_VALUE}.\n-     * <p>\n-     * The ceil modulus method {@link #ceilMod(int,int)} is a suitable\n-     * counterpart both for this method and for the {@link #ceilDiv(int,int)}\n-     * method.\n-     * <p>\n-     * For examples, see {@link #ceilDiv(int, int)}.\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the smallest (closest to negative infinity)\n-     * {@code int} value that is greater than or equal to the algebraic quotient.\n-     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n-     * dividend {@code x} is {@code Integer.MIN_VALUE} and the divisor {@code y}\n-     * is {@code -1}.\n-     * @see #ceilDiv(int, int)\n-     * @since 18\n-     *\/\n-    public static int ceilDivExact(int x, int y) {\n-        final int q = x \/ y;\n-        if ((x & y & q) >= 0) {\n-            \/\/ if the signs are the same and modulo not zero, round up\n-            if ((x ^ y) >= 0 && (q * y != x)) {\n-                return q + 1;\n-            }\n-            return q;\n-        }\n-        throw new ArithmeticException(\"integer overflow\");\n-    }\n-\n-    \/**\n-     * Returns the smallest (closest to negative infinity)\n-     * {@code long} value that is greater than or equal to the algebraic quotient.\n-     * This method is identical to {@link #ceilDiv(long,long)} except that it\n-     * throws an {@code ArithmeticException} when the dividend is\n-     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is\n-     * {@code -1} instead of ignoring the integer overflow and returning\n-     * {@code Long.MIN_VALUE}.\n-     * <p>\n-     * The ceil modulus method {@link #ceilMod(long,long)} is a suitable\n-     * counterpart both for this method and for the {@link #ceilDiv(long,long)}\n-     * method.\n-     * <p>\n-     * For examples, see {@link #ceilDiv(int, int)}.\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the smallest (closest to negative infinity)\n-     * {@code long} value that is greater than or equal to the algebraic quotient.\n-     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n-     * dividend {@code x} is {@code Long.MIN_VALUE} and the divisor {@code y}\n-     * is {@code -1}.\n-     * @see #ceilDiv(long,long)\n-     * @since 18\n-     *\/\n-    public static long ceilDivExact(long x, long y) {\n-        final long q = x \/ y;\n-        if ((x & y & q) >= 0) {\n-            \/\/ if the signs are the same and modulo not zero, round up\n-            if ((x ^ y) >= 0 && (q * y != x)) {\n-                return q + 1;\n-            }\n-            return q;\n-        }\n-        throw new ArithmeticException(\"long overflow\");\n-    }\n-\n-    \/**\n-     * Returns the argument incremented by one, throwing an exception if the\n-     * result overflows an {@code int}.\n-     * The overflow only occurs for {@linkplain Integer#MAX_VALUE the maximum value}.\n-     *\n-     * @param a the value to increment\n-     * @return the result\n-     * @throws ArithmeticException if the result overflows an int\n-     * @since 1.8\n-     *\/\n-    @IntrinsicCandidate\n-    public static int incrementExact(int a) {\n-        if (a == Integer.MAX_VALUE) {\n-            throw new ArithmeticException(\"integer overflow\");\n-        }\n+    @Benchmark\n+    public float  absFloat() {\n+        return  Math.abs(floatNegative99);\n+    }\n@@ -1265,18 +105,4 @@\n-        return a + 1;\n-    }\n-\n-    \/**\n-     * Returns the argument incremented by one, throwing an exception if the\n-     * result overflows a {@code long}.\n-     * The overflow only occurs for {@linkplain Long#MAX_VALUE the maximum value}.\n-     *\n-     * @param a the value to increment\n-     * @return the result\n-     * @throws ArithmeticException if the result overflows a long\n-     * @since 1.8\n-     *\/\n-    @IntrinsicCandidate\n-    public static long incrementExact(long a) {\n-        if (a == Long.MAX_VALUE) {\n-            throw new ArithmeticException(\"long overflow\");\n-        }\n+    @Benchmark\n+    public int  absExactInt() {\n+        return  Math.absExact(int2);\n+    }\n@@ -1284,18 +110,4 @@\n-        return a + 1L;\n-    }\n-\n-    \/**\n-     * Returns the argument decremented by one, throwing an exception if the\n-     * result overflows an {@code int}.\n-     * The overflow only occurs for {@linkplain Integer#MIN_VALUE the minimum value}.\n-     *\n-     * @param a the value to decrement\n-     * @return the result\n-     * @throws ArithmeticException if the result overflows an int\n-     * @since 1.8\n-     *\/\n-    @IntrinsicCandidate\n-    public static int decrementExact(int a) {\n-        if (a == Integer.MIN_VALUE) {\n-            throw new ArithmeticException(\"integer overflow\");\n-        }\n+    @Benchmark\n+    public long  absExactLong() {\n+        return  Math.absExact(long2);\n+    }\n@@ -1303,18 +115,4 @@\n-        return a - 1;\n-    }\n-\n-    \/**\n-     * Returns the argument decremented by one, throwing an exception if the\n-     * result overflows a {@code long}.\n-     * The overflow only occurs for {@linkplain Long#MIN_VALUE the minimum value}.\n-     *\n-     * @param a the value to decrement\n-     * @return the result\n-     * @throws ArithmeticException if the result overflows a long\n-     * @since 1.8\n-     *\/\n-    @IntrinsicCandidate\n-    public static long decrementExact(long a) {\n-        if (a == Long.MIN_VALUE) {\n-            throw new ArithmeticException(\"long overflow\");\n-        }\n+    @Benchmark\n+    public int  absInt() {\n+        return  Math.abs(int42);\n+    }\n@@ -1322,18 +120,4 @@\n-        return a - 1L;\n-    }\n-\n-    \/**\n-     * Returns the negation of the argument, throwing an exception if the\n-     * result overflows an {@code int}.\n-     * The overflow only occurs for {@linkplain Integer#MIN_VALUE the minimum value}.\n-     *\n-     * @param a the value to negate\n-     * @return the result\n-     * @throws ArithmeticException if the result overflows an int\n-     * @since 1.8\n-     *\/\n-    @IntrinsicCandidate\n-    public static int negateExact(int a) {\n-        if (a == Integer.MIN_VALUE) {\n-            throw new ArithmeticException(\"integer overflow\");\n-        }\n+    @Benchmark\n+    public long  absLong() {\n+        return  Math.abs(long13);\n+    }\n@@ -1341,18 +125,4 @@\n-        return -a;\n-    }\n-\n-    \/**\n-     * Returns the negation of the argument, throwing an exception if the\n-     * result overflows a {@code long}.\n-     * The overflow only occurs for {@linkplain Long#MIN_VALUE the minimum value}.\n-     *\n-     * @param a the value to negate\n-     * @return the result\n-     * @throws ArithmeticException if the result overflows a long\n-     * @since 1.8\n-     *\/\n-    @IntrinsicCandidate\n-    public static long negateExact(long a) {\n-        if (a == Long.MIN_VALUE) {\n-            throw new ArithmeticException(\"long overflow\");\n-        }\n+    @Benchmark\n+    public double  acosDouble() {\n+        return  Math.acos(double1);\n+    }\n@@ -1360,1078 +130,3 @@\n-        return -a;\n-    }\n-\n-    \/**\n-     * Returns the value of the {@code long} argument,\n-     * throwing an exception if the value overflows an {@code int}.\n-     *\n-     * @param value the long value\n-     * @return the argument as an int\n-     * @throws ArithmeticException if the {@code argument} overflows an int\n-     * @since 1.8\n-     *\/\n-    public static int toIntExact(long value) {\n-        if ((int)value != value) {\n-            throw new ArithmeticException(\"integer overflow\");\n-        }\n-        return (int)value;\n-    }\n-\n-    \/**\n-     * Returns the exact mathematical product of the arguments.\n-     *\n-     * @param x the first value\n-     * @param y the second value\n-     * @return the result\n-     * @since 9\n-     *\/\n-    public static long multiplyFull(int x, int y) {\n-        return (long)x * (long)y;\n-    }\n-\n-    \/**\n-     * Returns as a {@code long} the most significant 64 bits of the 128-bit\n-     * product of two 64-bit factors.\n-     *\n-     * @param x the first value\n-     * @param y the second value\n-     * @return the result\n-     * @see #unsignedMultiplyHigh\n-     * @since 9\n-     *\/\n-    @IntrinsicCandidate\n-    public static long multiplyHigh(long x, long y) {\n-        \/\/ Use technique from section 8-2 of Henry S. Warren, Jr.,\n-        \/\/ Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174.\n-        long x1 = x >> 32;\n-        long x2 = x & 0xFFFFFFFFL;\n-        long y1 = y >> 32;\n-        long y2 = y & 0xFFFFFFFFL;\n-\n-        long z2 = x2 * y2;\n-        long t = x1 * y2 + (z2 >>> 32);\n-        long z1 = t & 0xFFFFFFFFL;\n-        long z0 = t >> 32;\n-        z1 += x2 * y1;\n-\n-        return x1 * y1 + z0 + (z1 >> 32);\n-    }\n-\n-    \/**\n-     * Returns as a {@code long} the most significant 64 bits of the unsigned\n-     * 128-bit product of two unsigned 64-bit factors.\n-     *\n-     * @param x the first value\n-     * @param y the second value\n-     * @return the result\n-     * @see #multiplyHigh\n-     * @since 18\n-     *\/\n-    @IntrinsicCandidate\n-    public static long unsignedMultiplyHigh(long x, long y) {\n-        \/\/ Compute via multiplyHigh() to leverage the intrinsic\n-        long result = Math.multiplyHigh(x, y);\n-        result += (y & (x >> 63)); \/\/ equivalent to `if (x < 0) result += y;`\n-        result += (x & (y >> 63)); \/\/ equivalent to `if (y < 0) result += x;`\n-        return result;\n-    }\n-\n-    \/**\n-     * Returns the largest (closest to positive infinity)\n-     * {@code int} value that is less than or equal to the algebraic quotient.\n-     * There is one special case: if the dividend is\n-     * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is {@code -1},\n-     * then integer overflow occurs and\n-     * the result is equal to {@code Integer.MIN_VALUE}.\n-     * <p>\n-     * Normal integer division operates under the round to zero rounding mode\n-     * (truncation).  This operation instead acts under the round toward\n-     * negative infinity (floor) rounding mode.\n-     * The floor rounding mode gives different results from truncation\n-     * when the exact quotient is not an integer and is negative.\n-     * <ul>\n-     *   <li>If the signs of the arguments are the same, the results of\n-     *       {@code floorDiv} and the {@code \/} operator are the same.  <br>\n-     *       For example, {@code floorDiv(4, 3) == 1} and {@code (4 \/ 3) == 1}.<\/li>\n-     *   <li>If the signs of the arguments are different, {@code floorDiv}\n-     *       returns the largest integer less than or equal to the quotient\n-     *       while the {@code \/} operator returns the smallest integer greater\n-     *       than or equal to the quotient.\n-     *       They differ if and only if the quotient is not an integer.<br>\n-     *       For example, {@code floorDiv(-4, 3) == -2},\n-     *       whereas {@code (-4 \/ 3) == -1}.\n-     *   <\/li>\n-     * <\/ul>\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the largest (closest to positive infinity)\n-     * {@code int} value that is less than or equal to the algebraic quotient.\n-     * @throws ArithmeticException if the divisor {@code y} is zero\n-     * @see #floorMod(int, int)\n-     * @see #floor(double)\n-     * @since 1.8\n-     *\/\n-    public static int floorDiv(int x, int y) {\n-        final int q = x \/ y;\n-        \/\/ if the signs are different and modulo not zero, round down\n-        if ((x ^ y) < 0 && (q * y != x)) {\n-            return q - 1;\n-        }\n-        return q;\n-    }\n-\n-    \/**\n-     * Returns the largest (closest to positive infinity)\n-     * {@code long} value that is less than or equal to the algebraic quotient.\n-     * There is one special case: if the dividend is\n-     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},\n-     * then integer overflow occurs and\n-     * the result is equal to {@code Long.MIN_VALUE}.\n-     * <p>\n-     * Normal integer division operates under the round to zero rounding mode\n-     * (truncation).  This operation instead acts under the round toward\n-     * negative infinity (floor) rounding mode.\n-     * The floor rounding mode gives different results from truncation\n-     * when the exact result is not an integer and is negative.\n-     * <p>\n-     * For examples, see {@link #floorDiv(int, int)}.\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the largest (closest to positive infinity)\n-     * {@code long} value that is less than or equal to the algebraic quotient.\n-     * @throws ArithmeticException if the divisor {@code y} is zero\n-     * @see #floorMod(long, int)\n-     * @see #floor(double)\n-     * @since 9\n-     *\/\n-    public static long floorDiv(long x, int y) {\n-        return floorDiv(x, (long)y);\n-    }\n-\n-    \/**\n-     * Returns the largest (closest to positive infinity)\n-     * {@code long} value that is less than or equal to the algebraic quotient.\n-     * There is one special case: if the dividend is\n-     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},\n-     * then integer overflow occurs and\n-     * the result is equal to {@code Long.MIN_VALUE}.\n-     * <p>\n-     * Normal integer division operates under the round to zero rounding mode\n-     * (truncation).  This operation instead acts under the round toward\n-     * negative infinity (floor) rounding mode.\n-     * The floor rounding mode gives different results from truncation\n-     * when the exact result is not an integer and is negative.\n-     * <p>\n-     * For examples, see {@link #floorDiv(int, int)}.\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the largest (closest to positive infinity)\n-     * {@code long} value that is less than or equal to the algebraic quotient.\n-     * @throws ArithmeticException if the divisor {@code y} is zero\n-     * @see #floorMod(long, long)\n-     * @see #floor(double)\n-     * @since 1.8\n-     *\/\n-    public static long floorDiv(long x, long y) {\n-        final long q = x \/ y;\n-        \/\/ if the signs are different and modulo not zero, round down\n-        if ((x ^ y) < 0 && (q * y != x)) {\n-            return q - 1;\n-        }\n-        return q;\n-    }\n-\n-    \/**\n-     * Returns the floor modulus of the {@code int} arguments.\n-     * <p>\n-     * The floor modulus is {@code r = x - (floorDiv(x, y) * y)},\n-     * has the same sign as the divisor {@code y} or is zero, and\n-     * is in the range of {@code -abs(y) < r < +abs(y)}.\n-     *\n-     * <p>\n-     * The relationship between {@code floorDiv} and {@code floorMod} is such that:\n-     * <ul>\n-     *   <li>{@code floorDiv(x, y) * y + floorMod(x, y) == x}<\/li>\n-     * <\/ul>\n-     * <p>\n-     * The difference in values between {@code floorMod} and the {@code %} operator\n-     * is due to the difference between {@code floorDiv} and the {@code \/}\n-     * operator, as detailed in {@linkplain #floorDiv(int, int)}.\n-     * <p>\n-     * Examples:\n-     * <ul>\n-     *   <li>Regardless of the signs of the arguments, {@code floorMod}(x, y)\n-     *       is zero exactly when {@code x % y} is zero as well.<\/li>\n-     *   <li>If neither {@code floorMod}(x, y) nor {@code x % y} is zero,\n-     *       they differ exactly when the signs of the arguments differ.<br>\n-     *       <ul>\n-     *       <li>{@code floorMod(+4, +3) == +1}; &nbsp; and {@code (+4 % +3) == +1}<\/li>\n-     *       <li>{@code floorMod(-4, -3) == -1}; &nbsp; and {@code (-4 % -3) == -1}<\/li>\n-     *       <li>{@code floorMod(+4, -3) == -2}; &nbsp; and {@code (+4 % -3) == +1}<\/li>\n-     *       <li>{@code floorMod(-4, +3) == +2}; &nbsp; and {@code (-4 % +3) == -1}<\/li>\n-     *       <\/ul>\n-     *   <\/li>\n-     * <\/ul>\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the floor modulus {@code x - (floorDiv(x, y) * y)}\n-     * @throws ArithmeticException if the divisor {@code y} is zero\n-     * @see #floorDiv(int, int)\n-     * @since 1.8\n-     *\/\n-    public static int floorMod(int x, int y) {\n-        final int r = x % y;\n-        \/\/ if the signs are different and modulo not zero, adjust result\n-        if ((x ^ y) < 0 && r != 0) {\n-            return r + y;\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * Returns the floor modulus of the {@code long} and {@code int} arguments.\n-     * <p>\n-     * The floor modulus is {@code r = x - (floorDiv(x, y) * y)},\n-     * has the same sign as the divisor {@code y} or is zero, and\n-     * is in the range of {@code -abs(y) < r < +abs(y)}.\n-     *\n-     * <p>\n-     * The relationship between {@code floorDiv} and {@code floorMod} is such that:\n-     * <ul>\n-     *   <li>{@code floorDiv(x, y) * y + floorMod(x, y) == x}<\/li>\n-     * <\/ul>\n-     * <p>\n-     * For examples, see {@link #floorMod(int, int)}.\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the floor modulus {@code x - (floorDiv(x, y) * y)}\n-     * @throws ArithmeticException if the divisor {@code y} is zero\n-     * @see #floorDiv(long, int)\n-     * @since 9\n-     *\/\n-    public static int floorMod(long x, int y) {\n-        \/\/ Result cannot overflow the range of int.\n-        return (int)floorMod(x, (long)y);\n-    }\n-\n-    \/**\n-     * Returns the floor modulus of the {@code long} arguments.\n-     * <p>\n-     * The floor modulus is {@code r = x - (floorDiv(x, y) * y)},\n-     * has the same sign as the divisor {@code y} or is zero, and\n-     * is in the range of {@code -abs(y) < r < +abs(y)}.\n-     *\n-     * <p>\n-     * The relationship between {@code floorDiv} and {@code floorMod} is such that:\n-     * <ul>\n-     *   <li>{@code floorDiv(x, y) * y + floorMod(x, y) == x}<\/li>\n-     * <\/ul>\n-     * <p>\n-     * For examples, see {@link #floorMod(int, int)}.\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the floor modulus {@code x - (floorDiv(x, y) * y)}\n-     * @throws ArithmeticException if the divisor {@code y} is zero\n-     * @see #floorDiv(long, long)\n-     * @since 1.8\n-     *\/\n-    public static long floorMod(long x, long y) {\n-        final long r = x % y;\n-        \/\/ if the signs are different and modulo not zero, adjust result\n-        if ((x ^ y) < 0 && r != 0) {\n-            return r + y;\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * Returns the smallest (closest to negative infinity)\n-     * {@code int} value that is greater than or equal to the algebraic quotient.\n-     * There is one special case: if the dividend is\n-     * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is {@code -1},\n-     * then integer overflow occurs and\n-     * the result is equal to {@code Integer.MIN_VALUE}.\n-     * <p>\n-     * Normal integer division operates under the round to zero rounding mode\n-     * (truncation).  This operation instead acts under the round toward\n-     * positive infinity (ceiling) rounding mode.\n-     * The ceiling rounding mode gives different results from truncation\n-     * when the exact quotient is not an integer and is positive.\n-     * <ul>\n-     *   <li>If the signs of the arguments are different, the results of\n-     *       {@code ceilDiv} and the {@code \/} operator are the same.  <br>\n-     *       For example, {@code ceilDiv(-4, 3) == -1} and {@code (-4 \/ 3) == -1}.<\/li>\n-     *   <li>If the signs of the arguments are the same, {@code ceilDiv}\n-     *       returns the smallest integer greater than or equal to the quotient\n-     *       while the {@code \/} operator returns the largest integer less\n-     *       than or equal to the quotient.\n-     *       They differ if and only if the quotient is not an integer.<br>\n-     *       For example, {@code ceilDiv(4, 3) == 2},\n-     *       whereas {@code (4 \/ 3) == 1}.\n-     *   <\/li>\n-     * <\/ul>\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the smallest (closest to negative infinity)\n-     * {@code int} value that is greater than or equal to the algebraic quotient.\n-     * @throws ArithmeticException if the divisor {@code y} is zero\n-     * @see #ceilMod(int, int)\n-     * @see #ceil(double)\n-     * @since 18\n-     *\/\n-    public static int ceilDiv(int x, int y) {\n-        final int q = x \/ y;\n-        \/\/ if the signs are the same and modulo not zero, round up\n-        if ((x ^ y) >= 0 && (q * y != x)) {\n-            return q + 1;\n-        }\n-        return q;\n-    }\n-\n-    \/**\n-     * Returns the smallest (closest to negative infinity)\n-     * {@code long} value that is greater than or equal to the algebraic quotient.\n-     * There is one special case: if the dividend is\n-     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},\n-     * then integer overflow occurs and\n-     * the result is equal to {@code Long.MIN_VALUE}.\n-     * <p>\n-     * Normal integer division operates under the round to zero rounding mode\n-     * (truncation).  This operation instead acts under the round toward\n-     * positive infinity (ceiling) rounding mode.\n-     * The ceiling rounding mode gives different results from truncation\n-     * when the exact result is not an integer and is positive.\n-     * <p>\n-     * For examples, see {@link #ceilDiv(int, int)}.\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the smallest (closest to negative infinity)\n-     * {@code long} value that is greater than or equal to the algebraic quotient.\n-     * @throws ArithmeticException if the divisor {@code y} is zero\n-     * @see #ceilMod(int, int)\n-     * @see #ceil(double)\n-     * @since 18\n-     *\/\n-    public static long ceilDiv(long x, int y) {\n-        return ceilDiv(x, (long)y);\n-    }\n-\n-    \/**\n-     * Returns the smallest (closest to negative infinity)\n-     * {@code long} value that is greater than or equal to the algebraic quotient.\n-     * There is one special case: if the dividend is\n-     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},\n-     * then integer overflow occurs and\n-     * the result is equal to {@code Long.MIN_VALUE}.\n-     * <p>\n-     * Normal integer division operates under the round to zero rounding mode\n-     * (truncation).  This operation instead acts under the round toward\n-     * positive infinity (ceiling) rounding mode.\n-     * The ceiling rounding mode gives different results from truncation\n-     * when the exact result is not an integer and is positive.\n-     * <p>\n-     * For examples, see {@link #ceilDiv(int, int)}.\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the smallest (closest to negative infinity)\n-     * {@code long} value that is greater than or equal to the algebraic quotient.\n-     * @throws ArithmeticException if the divisor {@code y} is zero\n-     * @see #ceilMod(int, int)\n-     * @see #ceil(double)\n-     * @since 18\n-     *\/\n-    public static long ceilDiv(long x, long y) {\n-        final long q = x \/ y;\n-        \/\/ if the signs are the same and modulo not zero, round up\n-        if ((x ^ y) >= 0 && (q * y != x)) {\n-            return q + 1;\n-        }\n-        return q;\n-    }\n-\n-    \/**\n-     * Returns the ceiling modulus of the {@code int} arguments.\n-     * <p>\n-     * The ceiling modulus is {@code r = x - (ceilDiv(x, y) * y)},\n-     * has the opposite sign as the divisor {@code y} or is zero, and\n-     * is in the range of {@code -abs(y) < r < +abs(y)}.\n-     *\n-     * <p>\n-     * The relationship between {@code ceilDiv} and {@code ceilMod} is such that:\n-     * <ul>\n-     *   <li>{@code ceilDiv(x, y) * y + ceilMod(x, y) == x}<\/li>\n-     * <\/ul>\n-     * <p>\n-     * The difference in values between {@code ceilMod} and the {@code %} operator\n-     * is due to the difference between {@code ceilDiv} and the {@code \/}\n-     * operator, as detailed in {@linkplain #ceilDiv(int, int)}.\n-     * <p>\n-     * Examples:\n-     * <ul>\n-     *   <li>Regardless of the signs of the arguments, {@code ceilMod}(x, y)\n-     *       is zero exactly when {@code x % y} is zero as well.<\/li>\n-     *   <li>If neither {@code ceilMod}(x, y) nor {@code x % y} is zero,\n-     *       they differ exactly when the signs of the arguments are the same.<br>\n-     *       <ul>\n-     *       <li>{@code ceilMod(+4, +3) == -2}; &nbsp; and {@code (+4 % +3) == +1}<\/li>\n-     *       <li>{@code ceilMod(-4, -3) == +2}; &nbsp; and {@code (-4 % -3) == -1}<\/li>\n-     *       <li>{@code ceilMod(+4, -3) == +1}; &nbsp; and {@code (+4 % -3) == +1}<\/li>\n-     *       <li>{@code ceilMod(-4, +3) == -1}; &nbsp; and {@code (-4 % +3) == -1}<\/li>\n-     *       <\/ul>\n-     *   <\/li>\n-     * <\/ul>\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the ceiling modulus {@code x - (ceilDiv(x, y) * y)}\n-     * @throws ArithmeticException if the divisor {@code y} is zero\n-     * @see #ceilDiv(int, int)\n-     * @since 18\n-     *\/\n-    public static int ceilMod(int x, int y) {\n-        final int r = x % y;\n-        \/\/ if the signs are the same and modulo not zero, adjust result\n-        if ((x ^ y) >= 0 && r != 0) {\n-            return r - y;\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * Returns the ceiling modulus of the {@code long} and {@code int} arguments.\n-     * <p>\n-     * The ceiling modulus is {@code r = x - (ceilDiv(x, y) * y)},\n-     * has the opposite sign as the divisor {@code y} or is zero, and\n-     * is in the range of {@code -abs(y) < r < +abs(y)}.\n-     *\n-     * <p>\n-     * The relationship between {@code ceilDiv} and {@code ceilMod} is such that:\n-     * <ul>\n-     *   <li>{@code ceilDiv(x, y) * y + ceilMod(x, y) == x}<\/li>\n-     * <\/ul>\n-     * <p>\n-     * For examples, see {@link #ceilMod(int, int)}.\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the ceiling modulus {@code x - (ceilDiv(x, y) * y)}\n-     * @throws ArithmeticException if the divisor {@code y} is zero\n-     * @see #ceilDiv(long, int)\n-     * @since 18\n-     *\/\n-    public static int ceilMod(long x, int y) {\n-        \/\/ Result cannot overflow the range of int.\n-        return (int)ceilMod(x, (long)y);\n-    }\n-\n-    \/**\n-     * Returns the ceiling modulus of the {@code long} arguments.\n-     * <p>\n-     * The ceiling modulus is {@code r = x - (ceilDiv(x, y) * y)},\n-     * has the opposite sign as the divisor {@code y} or is zero, and\n-     * is in the range of {@code -abs(y) < r < +abs(y)}.\n-     *\n-     * <p>\n-     * The relationship between {@code ceilDiv} and {@code ceilMod} is such that:\n-     * <ul>\n-     *   <li>{@code ceilDiv(x, y) * y + ceilMod(x, y) == x}<\/li>\n-     * <\/ul>\n-     * <p>\n-     * For examples, see {@link #ceilMod(int, int)}.\n-     *\n-     * @param x the dividend\n-     * @param y the divisor\n-     * @return the ceiling modulus {@code x - (ceilDiv(x, y) * y)}\n-     * @throws ArithmeticException if the divisor {@code y} is zero\n-     * @see #ceilDiv(long, long)\n-     * @since 18\n-     *\/\n-    public static long ceilMod(long x, long y) {\n-        final long r = x % y;\n-        \/\/ if the signs are the same and modulo not zero, adjust result\n-        if ((x ^ y) >= 0 && r != 0) {\n-            return r - y;\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * Returns the absolute value of an {@code int} value.\n-     * If the argument is not negative, the argument is returned.\n-     * If the argument is negative, the negation of the argument is returned.\n-     *\n-     * <p>Note that if the argument is equal to the value of {@link\n-     * Integer#MIN_VALUE}, the most negative representable {@code int}\n-     * value, the result is that same value, which is negative. In\n-     * contrast, the {@link Math#absExact(int)} method throws an\n-     * {@code ArithmeticException} for this value.\n-     *\n-     * @param   a   the argument whose absolute value is to be determined\n-     * @return  the absolute value of the argument.\n-     * @see Math#absExact(int)\n-     *\/\n-    @IntrinsicCandidate\n-    public static int abs(int a) {\n-        return (a < 0) ? -a : a;\n-    }\n-\n-    \/**\n-     * Returns the mathematical absolute value of an {@code int} value\n-     * if it is exactly representable as an {@code int}, throwing\n-     * {@code ArithmeticException} if the result overflows the\n-     * positive {@code int} range.\n-     *\n-     * <p>Since the range of two's complement integers is asymmetric\n-     * with one additional negative value (JLS {@jls 4.2.1}), the\n-     * mathematical absolute value of {@link Integer#MIN_VALUE}\n-     * overflows the positive {@code int} range, so an exception is\n-     * thrown for that argument.\n-     *\n-     * @param  a  the argument whose absolute value is to be determined\n-     * @return the absolute value of the argument, unless overflow occurs\n-     * @throws ArithmeticException if the argument is {@link Integer#MIN_VALUE}\n-     * @see Math#abs(int)\n-     * @since 15\n-     *\/\n-    public static int absExact(int a) {\n-        if (a == Integer.MIN_VALUE)\n-            throw new ArithmeticException(\n-                \"Overflow to represent absolute value of Integer.MIN_VALUE\");\n-        else\n-            return abs(a);\n-    }\n-\n-    \/**\n-     * Returns the absolute value of a {@code long} value.\n-     * If the argument is not negative, the argument is returned.\n-     * If the argument is negative, the negation of the argument is returned.\n-     *\n-     * <p>Note that if the argument is equal to the value of {@link\n-     * Long#MIN_VALUE}, the most negative representable {@code long}\n-     * value, the result is that same value, which is negative. In\n-     * contrast, the {@link Math#absExact(long)} method throws an\n-     * {@code ArithmeticException} for this value.\n-     *\n-     * @param   a   the argument whose absolute value is to be determined\n-     * @return  the absolute value of the argument.\n-     * @see Math#absExact(long)\n-     *\/\n-    @IntrinsicCandidate\n-    public static long abs(long a) {\n-        return (a < 0) ? -a : a;\n-    }\n-\n-    \/**\n-     * Returns the mathematical absolute value of an {@code long} value\n-     * if it is exactly representable as an {@code long}, throwing\n-     * {@code ArithmeticException} if the result overflows the\n-     * positive {@code long} range.\n-     *\n-     * <p>Since the range of two's complement integers is asymmetric\n-     * with one additional negative value (JLS {@jls 4.2.1}), the\n-     * mathematical absolute value of {@link Long#MIN_VALUE} overflows\n-     * the positive {@code long} range, so an exception is thrown for\n-     * that argument.\n-     *\n-     * @param  a  the argument whose absolute value is to be determined\n-     * @return the absolute value of the argument, unless overflow occurs\n-     * @throws ArithmeticException if the argument is {@link Long#MIN_VALUE}\n-     * @see Math#abs(long)\n-     * @since 15\n-     *\/\n-    public static long absExact(long a) {\n-        if (a == Long.MIN_VALUE)\n-            throw new ArithmeticException(\n-                \"Overflow to represent absolute value of Long.MIN_VALUE\");\n-        else\n-            return abs(a);\n-    }\n-\n-    \/**\n-     * Returns the absolute value of a {@code float} value.\n-     * If the argument is not negative, the argument is returned.\n-     * If the argument is negative, the negation of the argument is returned.\n-     * Special cases:\n-     * <ul><li>If the argument is positive zero or negative zero, the\n-     * result is positive zero.\n-     * <li>If the argument is infinite, the result is positive infinity.\n-     * <li>If the argument is NaN, the result is NaN.<\/ul>\n-     *\n-     * @apiNote As implied by the above, one valid implementation of\n-     * this method is given by the expression below which computes a\n-     * {@code float} with the same exponent and significand as the\n-     * argument but with a guaranteed zero sign bit indicating a\n-     * positive value:<br>\n-     * {@code Float.intBitsToFloat(0x7fffffff & Float.floatToRawIntBits(a))}\n-     *\n-     * @param   a   the argument whose absolute value is to be determined\n-     * @return  the absolute value of the argument.\n-     *\/\n-    @IntrinsicCandidate\n-    public static float abs(float a) {\n-        \/\/ Convert to bit field form, zero the sign bit, and convert back\n-        return Float.intBitsToFloat(Float.floatToRawIntBits(a) & FloatConsts.MAG_BIT_MASK);\n-    }\n-\n-    \/**\n-     * Returns the absolute value of a {@code double} value.\n-     * If the argument is not negative, the argument is returned.\n-     * If the argument is negative, the negation of the argument is returned.\n-     * Special cases:\n-     * <ul><li>If the argument is positive zero or negative zero, the result\n-     * is positive zero.\n-     * <li>If the argument is infinite, the result is positive infinity.\n-     * <li>If the argument is NaN, the result is NaN.<\/ul>\n-     *\n-     * @apiNote As implied by the above, one valid implementation of\n-     * this method is given by the expression below which computes a\n-     * {@code double} with the same exponent and significand as the\n-     * argument but with a guaranteed zero sign bit indicating a\n-     * positive value:<br>\n-     * {@code Double.longBitsToDouble((Double.doubleToRawLongBits(a)<<1)>>>1)}\n-     *\n-     * @param   a   the argument whose absolute value is to be determined\n-     * @return  the absolute value of the argument.\n-     *\/\n-    @IntrinsicCandidate\n-    public static double abs(double a) {\n-        \/\/ Convert to bit field form, zero the sign bit, and convert back\n-        return Double.longBitsToDouble(Double.doubleToRawLongBits(a) & DoubleConsts.MAG_BIT_MASK);\n-\n-    }\n-\n-    \/**\n-     * Returns the greater of two {@code int} values. That is, the\n-     * result is the argument closer to the value of\n-     * {@link Integer#MAX_VALUE}. If the arguments have the same value,\n-     * the result is that same value.\n-     *\n-     * @param   a   an argument.\n-     * @param   b   another argument.\n-     * @return  the larger of {@code a} and {@code b}.\n-     *\/\n-    @IntrinsicCandidate\n-    public static int max(int a, int b) {\n-        return (a >= b) ? a : b;\n-    }\n-\n-    \/**\n-     * Returns the greater of two {@code long} values. That is, the\n-     * result is the argument closer to the value of\n-     * {@link Long#MAX_VALUE}. If the arguments have the same value,\n-     * the result is that same value.\n-     *\n-     * @param   a   an argument.\n-     * @param   b   another argument.\n-     * @return  the larger of {@code a} and {@code b}.\n-     *\/\n-    public static long max(long a, long b) {\n-        return (a >= b) ? a : b;\n-    }\n-\n-    \/\/ Use raw bit-wise conversions on guaranteed non-NaN arguments.\n-    private static final long negativeZeroFloatBits  = Float.floatToRawIntBits(-0.0f);\n-    private static final long negativeZeroDoubleBits = Double.doubleToRawLongBits(-0.0d);\n-\n-    \/**\n-     * Returns the greater of two {@code float} values.  That is,\n-     * the result is the argument closer to positive infinity. If the\n-     * arguments have the same value, the result is that same\n-     * value. If either value is NaN, then the result is NaN.  Unlike\n-     * the numerical comparison operators, this method considers\n-     * negative zero to be strictly smaller than positive zero. If one\n-     * argument is positive zero and the other negative zero, the\n-     * result is positive zero.\n-     *\n-     * @apiNote\n-     * This method corresponds to the maximum operation defined in\n-     * IEEE 754.\n-     *\n-     * @param   a   an argument.\n-     * @param   b   another argument.\n-     * @return  the larger of {@code a} and {@code b}.\n-     *\/\n-    @IntrinsicCandidate\n-    public static float max(float a, float b) {\n-        if (a != a)\n-            return a;   \/\/ a is NaN\n-        if ((a == 0.0f) &&\n-            (b == 0.0f) &&\n-            (Float.floatToRawIntBits(a) == negativeZeroFloatBits)) {\n-            \/\/ Raw conversion ok since NaN can't map to -0.0.\n-            return b;\n-        }\n-        return (a >= b) ? a : b;\n-    }\n-\n-    \/**\n-     * Returns the greater of two {@code double} values.  That\n-     * is, the result is the argument closer to positive infinity. If\n-     * the arguments have the same value, the result is that same\n-     * value. If either value is NaN, then the result is NaN.  Unlike\n-     * the numerical comparison operators, this method considers\n-     * negative zero to be strictly smaller than positive zero. If one\n-     * argument is positive zero and the other negative zero, the\n-     * result is positive zero.\n-     *\n-     * @apiNote\n-     * This method corresponds to the maximum operation defined in\n-     * IEEE 754.\n-     *\n-     * @param   a   an argument.\n-     * @param   b   another argument.\n-     * @return  the larger of {@code a} and {@code b}.\n-     *\/\n-    @IntrinsicCandidate\n-    public static double max(double a, double b) {\n-        if (a != a)\n-            return a;   \/\/ a is NaN\n-        if ((a == 0.0d) &&\n-            (b == 0.0d) &&\n-            (Double.doubleToRawLongBits(a) == negativeZeroDoubleBits)) {\n-            \/\/ Raw conversion ok since NaN can't map to -0.0.\n-            return b;\n-        }\n-        return (a >= b) ? a : b;\n-    }\n-\n-    \/**\n-     * Returns the smaller of two {@code int} values. That is,\n-     * the result the argument closer to the value of\n-     * {@link Integer#MIN_VALUE}.  If the arguments have the same\n-     * value, the result is that same value.\n-     *\n-     * @param   a   an argument.\n-     * @param   b   another argument.\n-     * @return  the smaller of {@code a} and {@code b}.\n-     *\/\n-    @IntrinsicCandidate\n-    public static int min(int a, int b) {\n-        return (a <= b) ? a : b;\n-    }\n-\n-    \/**\n-     * Returns the smaller of two {@code long} values. That is,\n-     * the result is the argument closer to the value of\n-     * {@link Long#MIN_VALUE}. If the arguments have the same\n-     * value, the result is that same value.\n-     *\n-     * @param   a   an argument.\n-     * @param   b   another argument.\n-     * @return  the smaller of {@code a} and {@code b}.\n-     *\/\n-    public static long min(long a, long b) {\n-        return (a <= b) ? a : b;\n-    }\n-\n-    \/**\n-     * Returns the smaller of two {@code float} values.  That is,\n-     * the result is the value closer to negative infinity. If the\n-     * arguments have the same value, the result is that same\n-     * value. If either value is NaN, then the result is NaN.  Unlike\n-     * the numerical comparison operators, this method considers\n-     * negative zero to be strictly smaller than positive zero.  If\n-     * one argument is positive zero and the other is negative zero,\n-     * the result is negative zero.\n-     *\n-     * @apiNote\n-     * This method corresponds to the minimum operation defined in\n-     * IEEE 754.\n-     *\n-     * @param   a   an argument.\n-     * @param   b   another argument.\n-     * @return  the smaller of {@code a} and {@code b}.\n-     *\/\n-    @IntrinsicCandidate\n-    public static float min(float a, float b) {\n-        if (a != a)\n-            return a;   \/\/ a is NaN\n-        if ((a == 0.0f) &&\n-            (b == 0.0f) &&\n-            (Float.floatToRawIntBits(b) == negativeZeroFloatBits)) {\n-            \/\/ Raw conversion ok since NaN can't map to -0.0.\n-            return b;\n-        }\n-        return (a <= b) ? a : b;\n-    }\n-\n-    \/**\n-     * Returns the smaller of two {@code double} values.  That\n-     * is, the result is the value closer to negative infinity. If the\n-     * arguments have the same value, the result is that same\n-     * value. If either value is NaN, then the result is NaN.  Unlike\n-     * the numerical comparison operators, this method considers\n-     * negative zero to be strictly smaller than positive zero. If one\n-     * argument is positive zero and the other is negative zero, the\n-     * result is negative zero.\n-     *\n-     * @apiNote\n-     * This method corresponds to the minimum operation defined in\n-     * IEEE 754.\n-     *\n-     * @param   a   an argument.\n-     * @param   b   another argument.\n-     * @return  the smaller of {@code a} and {@code b}.\n-     *\/\n-    @IntrinsicCandidate\n-    public static double min(double a, double b) {\n-        if (a != a)\n-            return a;   \/\/ a is NaN\n-        if ((a == 0.0d) &&\n-            (b == 0.0d) &&\n-            (Double.doubleToRawLongBits(b) == negativeZeroDoubleBits)) {\n-            \/\/ Raw conversion ok since NaN can't map to -0.0.\n-            return b;\n-        }\n-        return (a <= b) ? a : b;\n-    }\n-\n-    \/**\n-     * Clamps the value to fit between min and max. If the value is less\n-     * than {@code min}, then {@code min} is returned. If the value is greater\n-     * than {@code max}, then {@code max} is returned. Otherwise, the original\n-     * value is returned.\n-     * <p>\n-     * While the original value of type long may not fit into the int type,\n-     * the bounds have the int type, so the result always fits the int type.\n-     * This allows to use method to safely cast long value to int with\n-     * saturation.\n-     *\n-     * @param value value to clamp\n-     * @param min minimal allowed value\n-     * @param max maximal allowed value\n-     * @return a clamped value that fits into {@code min..max} interval\n-     * @throws IllegalArgumentException if {@code min > max}\n-     *\n-     * @since 21\n-     *\/\n-    public static int clamp(long value, int min, int max) {\n-        if (min > max) {\n-            throw new IllegalArgumentException(min + \" > \" + max);\n-        }\n-        return (int) Math.min(max, Math.max(value, min));\n-    }\n-\n-    \/**\n-     * Clamps the value to fit between min and max. If the value is less\n-     * than {@code min}, then {@code min} is returned. If the value is greater\n-     * than {@code max}, then {@code max} is returned. Otherwise, the original\n-     * value is returned.\n-     *\n-     * @param value value to clamp\n-     * @param min minimal allowed value\n-     * @param max maximal allowed value\n-     * @return a clamped value that fits into {@code min..max} interval\n-     * @throws IllegalArgumentException if {@code min > max}\n-     *\n-     * @since 21\n-     *\/\n-    public static long clamp(long value, long min, long max) {\n-        if (min > max) {\n-            throw new IllegalArgumentException(min + \" > \" + max);\n-        }\n-        return Math.min(max, Math.max(value, min));\n-    }\n-\n-    \/**\n-     * Clamps the value to fit between min and max. If the value is less\n-     * than {@code min}, then {@code min} is returned. If the value is greater\n-     * than {@code max}, then {@code max} is returned. Otherwise, the original\n-     * value is returned. If value is NaN, the result is also NaN.\n-     * <p>\n-     * Unlike the numerical comparison operators, this method considers\n-     * negative zero to be strictly smaller than positive zero.\n-     * E.g., {@code clamp(-0.0, 0.0, 1.0)} returns 0.0.\n-     *\n-     * @param value value to clamp\n-     * @param min minimal allowed value\n-     * @param max maximal allowed value\n-     * @return a clamped value that fits into {@code min..max} interval\n-     * @throws IllegalArgumentException if either of {@code min} and {@code max}\n-     * arguments is NaN, or {@code min > max}, or {@code min} is +0.0, and\n-     * {@code max} is -0.0.\n-     *\n-     * @since 21\n-     *\/\n-    public static double clamp(double value, double min, double max) {\n-        \/\/ This unusual condition allows keeping only one branch\n-        \/\/ on common path when min < max and neither of them is NaN.\n-        \/\/ If min == max, we should additionally check for +0.0\/-0.0 case,\n-        \/\/ so we're still visiting the if statement.\n-        if (!(min < max)) { \/\/ min greater than, equal to, or unordered with respect to max; NaN values are unordered\n-            if (Double.isNaN(min)) {\n-                throw new IllegalArgumentException(\"min is NaN\");\n-            }\n-            if (Double.isNaN(max)) {\n-                throw new IllegalArgumentException(\"max is NaN\");\n-            }\n-            if (Double.compare(min, max) > 0) {\n-                throw new IllegalArgumentException(min + \" > \" + max);\n-            }\n-            \/\/ Fall-through if min and max are exactly equal (or min = -0.0 and max = +0.0)\n-            \/\/ and none of them is NaN\n-        }\n-        return Math.min(max, Math.max(value, min));\n-    }\n-\n-    \/**\n-     * Clamps the value to fit between min and max. If the value is less\n-     * than {@code min}, then {@code min} is returned. If the value is greater\n-     * than {@code max}, then {@code max} is returned. Otherwise, the original\n-     * value is returned. If value is NaN, the result is also NaN.\n-     * <p>\n-     * Unlike the numerical comparison operators, this method considers\n-     * negative zero to be strictly smaller than positive zero.\n-     * E.g., {@code clamp(-0.0f, 0.0f, 1.0f)} returns 0.0f.\n-     *\n-     * @param value value to clamp\n-     * @param min minimal allowed value\n-     * @param max maximal allowed value\n-     * @return a clamped value that fits into {@code min..max} interval\n-     * @throws IllegalArgumentException if either of {@code min} and {@code max}\n-     * arguments is NaN, or {@code min > max}, or {@code min} is +0.0f, and\n-     * {@code max} is -0.0f.\n-     *\n-     * @since 21\n-     *\/\n-    public static float clamp(float value, float min, float max) {\n-        \/\/ This unusual condition allows keeping only one branch\n-        \/\/ on common path when min < max and neither of them is NaN.\n-        \/\/ If min == max, we should additionally check for +0.0\/-0.0 case,\n-        \/\/ so we're still visiting the if statement.\n-        if (!(min < max)) { \/\/ min greater than, equal to, or unordered with respect to max; NaN values are unordered\n-            if (Float.isNaN(min)) {\n-                throw new IllegalArgumentException(\"min is NaN\");\n-            }\n-            if (Float.isNaN(max)) {\n-                throw new IllegalArgumentException(\"max is NaN\");\n-            }\n-            if (Float.compare(min, max) > 0) {\n-                throw new IllegalArgumentException(min + \" > \" + max);\n-            }\n-            \/\/ Fall-through if min and max are exactly equal (or min = -0.0 and max = +0.0)\n-            \/\/ and none of them is NaN\n-        }\n-        return Math.min(max, Math.max(value, min));\n-    }\n-\n-    \/**\n-     * Returns the fused multiply add of the three arguments; that is,\n-     * returns the exact product of the first two arguments summed\n-     * with the third argument and then rounded once to the nearest\n-     * {@code double}.\n-     *\n-     * The rounding is done using the {@linkplain\n-     * java.math.RoundingMode#HALF_EVEN round to nearest even\n-     * rounding mode}.\n-     *\n-     * In contrast, if {@code a * b + c} is evaluated as a regular\n-     * floating-point expression, two rounding errors are involved,\n-     * the first for the multiply operation, the second for the\n-     * addition operation.\n-     *\n-     * <p>Special cases:\n-     * <ul>\n-     * <li> If any argument is NaN, the result is NaN.\n-     *\n-     * <li> If one of the first two arguments is infinite and the\n-     * other is zero, the result is NaN.\n-     *\n-     * <li> If the exact product of the first two arguments is infinite\n-     * (in other words, at least one of the arguments is infinite and\n-     * the other is neither zero nor NaN) and the third argument is an\n-     * infinity of the opposite sign, the result is NaN.\n-     *\n-     * <\/ul>\n-     *\n-     * <p>Note that {@code fma(a, 1.0, c)} returns the same\n-     * result as ({@code a + c}).  However,\n-     * {@code fma(a, b, +0.0)} does <em>not<\/em> always return the\n-     * same result as ({@code a * b}) since\n-     * {@code fma(-0.0, +0.0, +0.0)} is {@code +0.0} while\n-     * ({@code -0.0 * +0.0}) is {@code -0.0}; {@code fma(a, b, -0.0)} is\n-     * equivalent to ({@code a * b}) however.\n-     *\n-     * @apiNote This method corresponds to the fusedMultiplyAdd\n-     * operation defined in IEEE 754.\n-     *\n-     * @param a a value\n-     * @param b a value\n-     * @param c a value\n-     *\n-     * @return (<i>a<\/i>&nbsp;&times;&nbsp;<i>b<\/i>&nbsp;+&nbsp;<i>c<\/i>)\n-     * computed, as if with unlimited range and precision, and rounded\n-     * once to the nearest {@code double} value\n-     *\n-     * @since 9\n-     *\/\n-    @IntrinsicCandidate\n-    public static double fma(double a, double b, double c) {\n-        \/*\n-         * Infinity and NaN arithmetic is not quite the same with two\n-         * roundings as opposed to just one so the simple expression\n-         * \"a * b + c\" cannot always be used to compute the correct\n-         * result.  With two roundings, the product can overflow and\n-         * if the addend is infinite, a spurious NaN can be produced\n-         * if the infinity from the overflow and the infinite addend\n-         * have opposite signs.\n-         *\/\n-\n-        \/\/ First, screen for and handle non-finite input values whose\n-        \/\/ arithmetic is not supported by BigDecimal.\n-        if (Double.isNaN(a) || Double.isNaN(b) || Double.isNaN(c)) {\n-            return Double.NaN;\n-        } else { \/\/ All inputs non-NaN\n-            boolean infiniteA = Double.isInfinite(a);\n-            boolean infiniteB = Double.isInfinite(b);\n-            boolean infiniteC = Double.isInfinite(c);\n-            double result;\n-\n-            if (infiniteA || infiniteB || infiniteC) {\n-                if (infiniteA && b == 0.0 ||\n-                    infiniteB && a == 0.0 ) {\n-                    return Double.NaN;\n-                }\n-                double product = a * b;\n-                if (Double.isInfinite(product) && !infiniteA && !infiniteB) {\n-                    \/\/ Intermediate overflow; might cause a\n-                    \/\/ spurious NaN if added to infinite c.\n-                    assert Double.isInfinite(c);\n-                    return c;\n-                } else {\n-                    result = product + c;\n-                    assert !Double.isFinite(result);\n-                    return result;\n-                }\n-            } else { \/\/ All inputs finite\n-                BigDecimal product = (new BigDecimal(a)).multiply(new BigDecimal(b));\n-                if (c == 0.0) { \/\/ Positive or negative zero\n-                    \/\/ If the product is an exact zero, use a\n-                    \/\/ floating-point expression to compute the sign\n-                    \/\/ of the zero final result. The product is an\n-                    \/\/ exact zero if and only if at least one of a and\n-                    \/\/ b is zero.\n-                    if (a == 0.0 || b == 0.0) {\n-                        return a * b + c;\n-                    } else {\n-                        \/\/ The sign of a zero addend doesn't matter if\n-                        \/\/ the product is nonzero. The sign of a zero\n-                        \/\/ addend is not factored in the result if the\n-                        \/\/ exact product is nonzero but underflows to\n-                        \/\/ zero; see IEEE-754 2008 section 6.3 \"The\n-                        \/\/ sign bit\".\n-                        return product.doubleValue();\n-                    }\n-                } else {\n-                    return product.add(new BigDecimal(c)).doubleValue();\n-                }\n-            }\n-        }\n+    @Benchmark\n+    public int  addExactInt() {\n+        return  Math.addExact(int42, int5);\n@@ -2440,67 +135,3 @@\n-    \/**\n-     * Returns the fused multiply add of the three arguments; that is,\n-     * returns the exact product of the first two arguments summed\n-     * with the third argument and then rounded once to the nearest\n-     * {@code float}.\n-     *\n-     * The rounding is done using the {@linkplain\n-     * java.math.RoundingMode#HALF_EVEN round to nearest even\n-     * rounding mode}.\n-     *\n-     * In contrast, if {@code a * b + c} is evaluated as a regular\n-     * floating-point expression, two rounding errors are involved,\n-     * the first for the multiply operation, the second for the\n-     * addition operation.\n-     *\n-     * <p>Special cases:\n-     * <ul>\n-     * <li> If any argument is NaN, the result is NaN.\n-     *\n-     * <li> If one of the first two arguments is infinite and the\n-     * other is zero, the result is NaN.\n-     *\n-     * <li> If the exact product of the first two arguments is infinite\n-     * (in other words, at least one of the arguments is infinite and\n-     * the other is neither zero nor NaN) and the third argument is an\n-     * infinity of the opposite sign, the result is NaN.\n-     *\n-     * <\/ul>\n-     *\n-     * <p>Note that {@code fma(a, 1.0f, c)} returns the same\n-     * result as ({@code a + c}).  However,\n-     * {@code fma(a, b, +0.0f)} does <em>not<\/em> always return the\n-     * same result as ({@code a * b}) since\n-     * {@code fma(-0.0f, +0.0f, +0.0f)} is {@code +0.0f} while\n-     * ({@code -0.0f * +0.0f}) is {@code -0.0f}; {@code fma(a, b, -0.0f)} is\n-     * equivalent to ({@code a * b}) however.\n-     *\n-     * @apiNote This method corresponds to the fusedMultiplyAdd\n-     * operation defined in IEEE 754.\n-     *\n-     * @param a a value\n-     * @param b a value\n-     * @param c a value\n-     *\n-     * @return (<i>a<\/i>&nbsp;&times;&nbsp;<i>b<\/i>&nbsp;+&nbsp;<i>c<\/i>)\n-     * computed, as if with unlimited range and precision, and rounded\n-     * once to the nearest {@code float} value\n-     *\n-     * @since 9\n-     *\/\n-    @IntrinsicCandidate\n-    public static float fma(float a, float b, float c) {\n-        if (Float.isFinite(a) && Float.isFinite(b) && Float.isFinite(c)) {\n-            if (a == 0.0 || b == 0.0) {\n-                return a * b + c; \/\/ Handled signed zero cases\n-            } else {\n-                return (new BigDecimal((double)a * (double)b) \/\/ Exact multiply\n-                        .add(new BigDecimal((double)c)))      \/\/ Exact sum\n-                    .floatValue();                            \/\/ One rounding\n-                                                              \/\/ to a float value\n-            }\n-        } else {\n-            \/\/ At least one of a,b, and c is non-finite. The result\n-            \/\/ will be non-finite as well and will be the same\n-            \/\/ non-finite value under double as float arithmetic.\n-            return (float)fma((double)a, (double)b, (double)c);\n-        }\n+    @Benchmark\n+    public long  addExactLong() {\n+        return  Math.addExact(long2, long13);\n@@ -2509,525 +140,303 @@\n-    \/**\n-     * Returns the size of an ulp of the argument.  An ulp, unit in\n-     * the last place, of a {@code double} value is the positive\n-     * distance between this floating-point value and the {@code\n-     * double} value next larger in magnitude.  Note that for non-NaN\n-     * <i>x<\/i>, <code>ulp(-<i>x<\/i>) == ulp(<i>x<\/i>)<\/code>.\n-     *\n-     * <p>Special Cases:\n-     * <ul>\n-     * <li> If the argument is NaN, then the result is NaN.\n-     * <li> If the argument is positive or negative infinity, then the\n-     * result is positive infinity.\n-     * <li> If the argument is positive or negative zero, then the result is\n-     * {@code Double.MIN_VALUE}.\n-     * <li> If the argument is &plusmn;{@code Double.MAX_VALUE}, then\n-     * the result is equal to 2<sup>971<\/sup>.\n-     * <\/ul>\n-     *\n-     * @param d the floating-point value whose ulp is to be returned\n-     * @return the size of an ulp of the argument\n-     * @author Joseph D. Darcy\n-     * @since 1.5\n-     *\/\n-    public static double ulp(double d) {\n-        int exp = getExponent(d);\n-\n-        return switch(exp) {\n-            case Double.MAX_EXPONENT + 1 -> Math.abs(d);      \/\/ NaN or infinity\n-            case Double.MIN_EXPONENT - 1 -> Double.MIN_VALUE; \/\/ zero or subnormal\n-            default -> {\n-                assert exp <= Double.MAX_EXPONENT && exp >= Double.MIN_EXPONENT;\n-\n-                \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n-                exp = exp - (DoubleConsts.SIGNIFICAND_WIDTH - 1);\n-                if (exp >= Double.MIN_EXPONENT) {\n-                    yield powerOfTwoD(exp);\n-                } else {\n-                    \/\/ return a subnormal result; left shift integer\n-                    \/\/ representation of Double.MIN_VALUE appropriate\n-                    \/\/ number of positions\n-                    yield Double.longBitsToDouble(1L <<\n-                            (exp - (Double.MIN_EXPONENT - (DoubleConsts.SIGNIFICAND_WIDTH - 1))));\n-                }\n-            }\n-        };\n-    }\n-\n-    \/**\n-     * Returns the size of an ulp of the argument.  An ulp, unit in\n-     * the last place, of a {@code float} value is the positive\n-     * distance between this floating-point value and the {@code\n-     * float} value next larger in magnitude.  Note that for non-NaN\n-     * <i>x<\/i>, <code>ulp(-<i>x<\/i>) == ulp(<i>x<\/i>)<\/code>.\n-     *\n-     * <p>Special Cases:\n-     * <ul>\n-     * <li> If the argument is NaN, then the result is NaN.\n-     * <li> If the argument is positive or negative infinity, then the\n-     * result is positive infinity.\n-     * <li> If the argument is positive or negative zero, then the result is\n-     * {@code Float.MIN_VALUE}.\n-     * <li> If the argument is &plusmn;{@code Float.MAX_VALUE}, then\n-     * the result is equal to 2<sup>104<\/sup>.\n-     * <\/ul>\n-     *\n-     * @param f the floating-point value whose ulp is to be returned\n-     * @return the size of an ulp of the argument\n-     * @author Joseph D. Darcy\n-     * @since 1.5\n-     *\/\n-    public static float ulp(float f) {\n-        int exp = getExponent(f);\n-\n-        return switch(exp) {\n-            case Float.MAX_EXPONENT + 1 -> Math.abs(f);     \/\/ NaN or infinity\n-            case Float.MIN_EXPONENT - 1 -> Float.MIN_VALUE; \/\/ zero or subnormal\n-            default -> {\n-                assert exp <= Float.MAX_EXPONENT && exp >= Float.MIN_EXPONENT;\n-\n-                \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n-                exp = exp - (FloatConsts.SIGNIFICAND_WIDTH - 1);\n-                if (exp >= Float.MIN_EXPONENT) {\n-                    yield powerOfTwoF(exp);\n-                } else {\n-                    \/\/ return a subnormal result; left shift integer\n-                    \/\/ representation of FloatConsts.MIN_VALUE appropriate\n-                    \/\/ number of positions\n-                    yield Float.intBitsToFloat(1 <<\n-                            (exp - (Float.MIN_EXPONENT - (FloatConsts.SIGNIFICAND_WIDTH - 1))));\n-                }\n-            }\n-        };\n-    }\n-\n-    \/**\n-     * Returns the signum function of the argument; zero if the argument\n-     * is zero, 1.0 if the argument is greater than zero, -1.0 if the\n-     * argument is less than zero.\n-     *\n-     * <p>Special Cases:\n-     * <ul>\n-     * <li> If the argument is NaN, then the result is NaN.\n-     * <li> If the argument is positive zero or negative zero, then the\n-     *      result is the same as the argument.\n-     * <\/ul>\n-     *\n-     * @param d the floating-point value whose signum is to be returned\n-     * @return the signum function of the argument\n-     * @author Joseph D. Darcy\n-     * @since 1.5\n-     *\/\n-    @IntrinsicCandidate\n-    public static double signum(double d) {\n-        return (d == 0.0 || Double.isNaN(d))?d:copySign(1.0, d);\n-    }\n-\n-    \/**\n-     * Returns the signum function of the argument; zero if the argument\n-     * is zero, 1.0f if the argument is greater than zero, -1.0f if the\n-     * argument is less than zero.\n-     *\n-     * <p>Special Cases:\n-     * <ul>\n-     * <li> If the argument is NaN, then the result is NaN.\n-     * <li> If the argument is positive zero or negative zero, then the\n-     *      result is the same as the argument.\n-     * <\/ul>\n-     *\n-     * @param f the floating-point value whose signum is to be returned\n-     * @return the signum function of the argument\n-     * @author Joseph D. Darcy\n-     * @since 1.5\n-     *\/\n-    @IntrinsicCandidate\n-    public static float signum(float f) {\n-        return (f == 0.0f || Float.isNaN(f))?f:copySign(1.0f, f);\n-    }\n-\n-    \/**\n-     * Returns the hyperbolic sine of a {@code double} value.\n-     * The hyperbolic sine of <i>x<\/i> is defined to be\n-     * (<i>e<sup>x<\/sup>&nbsp;&minus;&nbsp;e<sup>&minus;x<\/sup><\/i>)\/2\n-     * where <i>e<\/i> is {@linkplain Math#E Euler's number}.\n-     *\n-     * <p>Special cases:\n-     * <ul>\n-     *\n-     * <li>If the argument is NaN, then the result is NaN.\n-     *\n-     * <li>If the argument is infinite, then the result is an infinity\n-     * with the same sign as the argument.\n-     *\n-     * <li>If the argument is zero, then the result is a zero with the\n-     * same sign as the argument.\n-     *\n-     * <\/ul>\n-     *\n-     * <p>The computed result must be within 2.5 ulps of the exact result.\n-     *\n-     * @param   x The number whose hyperbolic sine is to be returned.\n-     * @return  The hyperbolic sine of {@code x}.\n-     * @since 1.5\n-     *\/\n-    public static double sinh(double x) {\n-        return StrictMath.sinh(x);\n-    }\n-\n-    \/**\n-     * Returns the hyperbolic cosine of a {@code double} value.\n-     * The hyperbolic cosine of <i>x<\/i> is defined to be\n-     * (<i>e<sup>x<\/sup>&nbsp;+&nbsp;e<sup>&minus;x<\/sup><\/i>)\/2\n-     * where <i>e<\/i> is {@linkplain Math#E Euler's number}.\n-     *\n-     * <p>Special cases:\n-     * <ul>\n-     *\n-     * <li>If the argument is NaN, then the result is NaN.\n-     *\n-     * <li>If the argument is infinite, then the result is positive\n-     * infinity.\n-     *\n-     * <li>If the argument is zero, then the result is {@code 1.0}.\n-     *\n-     * <\/ul>\n-     *\n-     * <p>The computed result must be within 2.5 ulps of the exact result.\n-     *\n-     * @param   x The number whose hyperbolic cosine is to be returned.\n-     * @return  The hyperbolic cosine of {@code x}.\n-     * @since 1.5\n-     *\/\n-    public static double cosh(double x) {\n-        return StrictMath.cosh(x);\n-    }\n-\n-    \/**\n-     * Returns the hyperbolic tangent of a {@code double} value.\n-     * The hyperbolic tangent of <i>x<\/i> is defined to be\n-     * (<i>e<sup>x<\/sup>&nbsp;&minus;&nbsp;e<sup>&minus;x<\/sup><\/i>)\/(<i>e<sup>x<\/sup>&nbsp;+&nbsp;e<sup>&minus;x<\/sup><\/i>),\n-     * in other words, {@linkplain Math#sinh\n-     * sinh(<i>x<\/i>)}\/{@linkplain Math#cosh cosh(<i>x<\/i>)}.  Note\n-     * that the absolute value of the exact tanh is always less than\n-     * 1.\n-     *\n-     * <p>Special cases:\n-     * <ul>\n-     *\n-     * <li>If the argument is NaN, then the result is NaN.\n-     *\n-     * <li>If the argument is zero, then the result is a zero with the\n-     * same sign as the argument.\n-     *\n-     * <li>If the argument is positive infinity, then the result is\n-     * {@code +1.0}.\n-     *\n-     * <li>If the argument is negative infinity, then the result is\n-     * {@code -1.0}.\n-     *\n-     * <\/ul>\n-     *\n-     * <p>The computed result must be within 2.5 ulps of the exact result.\n-     * The result of {@code tanh} for any finite input must have\n-     * an absolute value less than or equal to 1.  Note that once the\n-     * exact result of tanh is within 1\/2 of an ulp of the limit value\n-     * of &plusmn;1, correctly signed &plusmn;{@code 1.0} should\n-     * be returned.\n-     *\n-     * @param   x The number whose hyperbolic tangent is to be returned.\n-     * @return  The hyperbolic tangent of {@code x}.\n-     * @since 1.5\n-     *\/\n-    @IntrinsicCandidate\n-    public static double tanh(double x) {\n-        return StrictMath.tanh(x);\n-    }\n-\n-    \/**\n-     * Returns sqrt(<i>x<\/i><sup>2<\/sup>&nbsp;+<i>y<\/i><sup>2<\/sup>)\n-     * without intermediate overflow or underflow.\n-     *\n-     * <p>Special cases:\n-     * <ul>\n-     *\n-     * <li> If either argument is infinite, then the result\n-     * is positive infinity.\n-     *\n-     * <li> If either argument is NaN and neither argument is infinite,\n-     * then the result is NaN.\n-     *\n-     * <li> If both arguments are zero, the result is positive zero.\n-     * <\/ul>\n-     *\n-     * <p>The computed result must be within 1.5 ulps of the exact\n-     * result.  If one parameter is held constant, the results must be\n-     * semi-monotonic in the other parameter.\n-     *\n-     * @param x a value\n-     * @param y a value\n-     * @return sqrt(<i>x<\/i><sup>2<\/sup>&nbsp;+<i>y<\/i><sup>2<\/sup>)\n-     * without intermediate overflow or underflow\n-     * @since 1.5\n-     *\/\n-    public static double hypot(double x, double y) {\n-        return StrictMath.hypot(x, y);\n-    }\n-\n-    \/**\n-     * Returns <i>e<\/i><sup>x<\/sup>&nbsp;&minus;1.  Note that for values of\n-     * <i>x<\/i> near 0, the exact sum of\n-     * {@code expm1(x)}&nbsp;+&nbsp;1 is much closer to the true\n-     * result of <i>e<\/i><sup>x<\/sup> than {@code exp(x)}.\n-     *\n-     * <p>Special cases:\n-     * <ul>\n-     * <li>If the argument is NaN, the result is NaN.\n-     *\n-     * <li>If the argument is positive infinity, then the result is\n-     * positive infinity.\n-     *\n-     * <li>If the argument is negative infinity, then the result is\n-     * -1.0.\n-     *\n-     * <li>If the argument is zero, then the result is a zero with the\n-     * same sign as the argument.\n-     *\n-     * <\/ul>\n-     *\n-     * <p>The computed result must be within 1 ulp of the exact result.\n-     * Results must be semi-monotonic.  The result of\n-     * {@code expm1} for any finite input must be greater than or\n-     * equal to {@code -1.0}.  Note that once the exact result of\n-     * <i>e<\/i><sup>{@code x}<\/sup>&nbsp;-&nbsp;1 is within 1\/2\n-     * ulp of the limit value -1, {@code -1.0} should be\n-     * returned.\n-     *\n-     * @param   x   the exponent to raise <i>e<\/i> to in the computation of\n-     *              <i>e<\/i><sup>{@code x}<\/sup>&nbsp;&minus;1.\n-     * @return  the value <i>e<\/i><sup>{@code x}<\/sup>&nbsp;-&nbsp;1.\n-     * @since 1.5\n-     *\/\n-    public static double expm1(double x) {\n-        return StrictMath.expm1(x);\n-    }\n-\n-    \/**\n-     * Returns the natural logarithm of the sum of the argument and 1.\n-     * Note that for small values {@code x}, the result of\n-     * {@code log1p(x)} is much closer to the true result of ln(1\n-     * + {@code x}) than the floating-point evaluation of\n-     * {@code log(1.0+x)}.\n-     *\n-     * <p>Special cases:\n-     *\n-     * <ul>\n-     *\n-     * <li>If the argument is NaN or less than -1, then the result is\n-     * NaN.\n-     *\n-     * <li>If the argument is positive infinity, then the result is\n-     * positive infinity.\n-     *\n-     * <li>If the argument is negative one, then the result is\n-     * negative infinity.\n-     *\n-     * <li>If the argument is zero, then the result is a zero with the\n-     * same sign as the argument.\n-     *\n-     * <\/ul>\n-     *\n-     * <p>The computed result must be within 1 ulp of the exact result.\n-     * Results must be semi-monotonic.\n-     *\n-     * @param   x   a value\n-     * @return the value ln({@code x}&nbsp;+&nbsp;1), the natural\n-     * log of {@code x}&nbsp;+&nbsp;1\n-     * @since 1.5\n-     *\/\n-    public static double log1p(double x) {\n-        return StrictMath.log1p(x);\n-    }\n-\n-    \/**\n-     * Returns the first floating-point argument with the sign of the\n-     * second floating-point argument.  Note that unlike the {@link\n-     * StrictMath#copySign(double, double) StrictMath.copySign}\n-     * method, this method does not require NaN {@code sign}\n-     * arguments to be treated as positive values; implementations are\n-     * permitted to treat some NaN arguments as positive and other NaN\n-     * arguments as negative to allow greater performance.\n-     *\n-     * @apiNote\n-     * This method corresponds to the copySign operation defined in\n-     * IEEE 754.\n-     *\n-     * @param magnitude  the parameter providing the magnitude of the result\n-     * @param sign   the parameter providing the sign of the result\n-     * @return a value with the magnitude of {@code magnitude}\n-     * and the sign of {@code sign}.\n-     * @since 1.6\n-     *\/\n-    @IntrinsicCandidate\n-    public static double copySign(double magnitude, double sign) {\n-        return Double.longBitsToDouble((Double.doubleToRawLongBits(sign) &\n-                                        (DoubleConsts.SIGN_BIT_MASK)) |\n-                                       (Double.doubleToRawLongBits(magnitude) &\n-                                        (DoubleConsts.EXP_BIT_MASK |\n-                                         DoubleConsts.SIGNIF_BIT_MASK)));\n-    }\n-\n-    \/**\n-     * Returns the first floating-point argument with the sign of the\n-     * second floating-point argument.  Note that unlike the {@link\n-     * StrictMath#copySign(float, float) StrictMath.copySign}\n-     * method, this method does not require NaN {@code sign}\n-     * arguments to be treated as positive values; implementations are\n-     * permitted to treat some NaN arguments as positive and other NaN\n-     * arguments as negative to allow greater performance.\n-     *\n-     * @apiNote\n-     * This method corresponds to the copySign operation defined in\n-     * IEEE 754.\n-     *\n-     * @param magnitude  the parameter providing the magnitude of the result\n-     * @param sign   the parameter providing the sign of the result\n-     * @return a value with the magnitude of {@code magnitude}\n-     * and the sign of {@code sign}.\n-     * @since 1.6\n-     *\/\n-    @IntrinsicCandidate\n-    public static float copySign(float magnitude, float sign) {\n-        return Float.intBitsToFloat((Float.floatToRawIntBits(sign) &\n-                                     (FloatConsts.SIGN_BIT_MASK)) |\n-                                    (Float.floatToRawIntBits(magnitude) &\n-                                     (FloatConsts.EXP_BIT_MASK |\n-                                      FloatConsts.SIGNIF_BIT_MASK)));\n-    }\n-\n-    \/**\n-     * Returns the unbiased exponent used in the representation of a\n-     * {@code float}.  Special cases:\n-     *\n-     * <ul>\n-     * <li>If the argument is NaN or infinite, then the result is\n-     * {@link Float#MAX_EXPONENT} + 1.\n-     * <li>If the argument is zero or subnormal, then the result is\n-     * {@link Float#MIN_EXPONENT} - 1.\n-     * <\/ul>\n-     * @apiNote\n-     * This method is analogous to the logB operation defined in IEEE\n-     * 754, but returns a different value on subnormal arguments.\n-     *\n-     * @param f a {@code float} value\n-     * @return the unbiased exponent of the argument\n-     * @since 1.6\n-     *\/\n-    public static int getExponent(float f) {\n-        \/*\n-         * Bitwise convert f to integer, mask out exponent bits, shift\n-         * to the right and then subtract out float's bias adjust to\n-         * get true exponent value\n-         *\/\n-        return ((Float.floatToRawIntBits(f) & FloatConsts.EXP_BIT_MASK) >>\n-                (FloatConsts.SIGNIFICAND_WIDTH - 1)) - FloatConsts.EXP_BIAS;\n-    }\n-\n-    \/**\n-     * Returns the unbiased exponent used in the representation of a\n-     * {@code double}.  Special cases:\n-     *\n-     * <ul>\n-     * <li>If the argument is NaN or infinite, then the result is\n-     * {@link Double#MAX_EXPONENT} + 1.\n-     * <li>If the argument is zero or subnormal, then the result is\n-     * {@link Double#MIN_EXPONENT} - 1.\n-     * <\/ul>\n-     * @apiNote\n-     * This method is analogous to the logB operation defined in IEEE\n-     * 754, but returns a different value on subnormal arguments.\n-     *\n-     * @param d a {@code double} value\n-     * @return the unbiased exponent of the argument\n-     * @since 1.6\n-     *\/\n-    public static int getExponent(double d) {\n-        \/*\n-         * Bitwise convert d to long, mask out exponent bits, shift\n-         * to the right and then subtract out double's bias adjust to\n-         * get true exponent value.\n-         *\/\n-        return (int)(((Double.doubleToRawLongBits(d) & DoubleConsts.EXP_BIT_MASK) >>\n-                      (DoubleConsts.SIGNIFICAND_WIDTH - 1)) - DoubleConsts.EXP_BIAS);\n-    }\n-\n-    \/**\n-     * Returns the floating-point number adjacent to the first\n-     * argument in the direction of the second argument.  If both\n-     * arguments compare as equal the second argument is returned.\n-     *\n-     * <p>\n-     * Special cases:\n-     * <ul>\n-     * <li> If either argument is a NaN, then NaN is returned.\n-     *\n-     * <li> If both arguments are signed zeros, {@code direction}\n-     * is returned unchanged (as implied by the requirement of\n-     * returning the second argument if the arguments compare as\n-     * equal).\n-     *\n-     * <li> If {@code start} is\n-     * &plusmn;{@link Double#MIN_VALUE} and {@code direction}\n-     * has a value such that the result should have a smaller\n-     * magnitude, then a zero with the same sign as {@code start}\n-     * is returned.\n-     *\n-     * <li> If {@code start} is infinite and\n-     * {@code direction} has a value such that the result should\n-     * have a smaller magnitude, {@link Double#MAX_VALUE} with the\n-     * same sign as {@code start} is returned.\n-     *\n-     * <li> If {@code start} is equal to &plusmn;\n-     * {@link Double#MAX_VALUE} and {@code direction} has a\n-     * value such that the result should have a larger magnitude, an\n-     * infinity with same sign as {@code start} is returned.\n-     * <\/ul>\n-     *\n-     * @param start  starting floating-point value\n-     * @param direction value indicating which of\n-     * {@code start}'s neighbors or {@code start} should\n-     * be returned\n-     * @return The floating-point number adjacent to {@code start} in the\n-     * direction of {@code direction}.\n-     * @since 1.6\n-     *\/\n-    public static double nextAfter(double start, double direction) {\n-        \/*\n-         * The cases:\n-         *\n-         * nextAfter(+infinity, 0)  == MAX_VALUE\n-         * nextAfter(+infinity, +infinity)  == +infinity\n-         * nextAfter(-infinity, 0)  == -MAX_VALUE\n-         * nextAfter(-infinity, -infinity)  == -infinity\n-         *\n-         * are naturally handled without any additional testing\n-         *\/\n-\n-        \/*\n-         * IEEE 754 floating-point numbers are lexicographically\n-         * ordered if treated as signed-magnitude integers.\n-         * Since Java's integers are two's complement,\n-         * incrementing the two's complement representation of a\n-         * logically negative floating-point value *decrements*\n-         * the signed-magnitude representation. Therefore, when\n-         * the integer representation of a floating-point value\n-         * is negative, the adjustment to the representation is in\n-         * the opposite direction from what would initially be expected.\n-         *\/\n-\n-        \/\/ Branch to descending case first as it is more costly than ascending\n-        \/\/ case due to start != 0.0d conditional.\n-        if (start > direction) { \/\/ descending\n-            if (start != 0.0d) {\n-                final long transducer = Double.doubleToRawLongBits(start);\n-                return Double.longBitsToDouble(transducer + ((transducer > 0L) ? -1L : 1L));\n-            } else { \/\/ start == 0.0d && direction < 0.0d\n-                return -Double.MIN_VALUE;\n+    @Benchmark\n+    public double  asinDouble() {\n+        return  Math.asin(double1);\n+    }\n+\n+    @Benchmark\n+    public double  atanDouble() {\n+        return  Math.atan(double1);\n+    }\n+\n+    @Benchmark\n+    public double  atan2Double() {\n+        return  Math.atan2(double1, double2);\n+    }\n+\n+    @Benchmark\n+    public double  cbrt() {\n+        return  Math.cbrt(double81);\n+    }\n+\n+    @Benchmark\n+    public double  ceilDouble() {\n+        return  Math.ceil(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  addCeilFloorDouble() {\n+        return  Math.ceil(double4Dot1) + Math.floor(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  copySignDouble() {\n+        return  Math.copySign(double81, doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public float  copySignFloat() {\n+        return  Math.copySign(floatNegative99, float1);\n+    }\n+\n+    @Benchmark\n+    public double  cosDouble() {\n+        return  Math.cos(double1);\n+    }\n+\n+    @Benchmark\n+    public double  coshDouble() {\n+        return  Math.cosh(double2);\n+    }\n+\n+    @Benchmark\n+    public int  decrementExactInt() {\n+        return  Math.decrementExact(int42);\n+    }\n+\n+    @Benchmark\n+    public long  decrementExactLong() {\n+        return  Math.decrementExact(long747);\n+    }\n+\n+    @Benchmark\n+    public double  expDouble() {\n+        return  Math.exp(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  expm1() {\n+        return  Math.expm1(doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public double  floorDouble() {\n+        return  Math.floor(doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public int  floorDivIntInt() {\n+        return  Math.floorDiv(int42, int5);\n+    }\n+\n+    @Benchmark\n+    public long  floorDivLongInt() {\n+        return  Math.floorDiv(long747, int42);\n+    }\n+\n+    @Benchmark\n+    public long  floorDivLongLong() {\n+        return  Math.floorDiv(long747, long13);\n+    }\n+\n+    @Benchmark\n+    public int  floorModIntInt() {\n+        return  Math.floorMod(int42, int5);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int floorModIntIntMultiple() {\n+        return Math.floorMod( dividend,  divisor) +\n+               Math.floorMod( dividend, -divisor) +\n+               Math.floorMod(-dividend,  divisor) +\n+               Math.floorMod(-dividend, -divisor);\n+    }\n+\n+    @Benchmark\n+    public int  floorModLongInt() {\n+        return  Math.floorMod(long747, int5);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int floorModLongIntMultiple() {\n+        return Math.floorMod( longDividend,  divisor) +\n+               Math.floorMod( longDividend, -divisor) +\n+               Math.floorMod(-longDividend,  divisor) +\n+               Math.floorMod(-longDividend, -divisor);\n+    }\n+\n+    @Benchmark\n+    public long  floorModLongLong() {\n+        return  Math.floorMod(long747, long13);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long floorModLongLongMultiple() {\n+        return Math.floorMod( longDividend,  longDivisor) +\n+               Math.floorMod( longDividend, -longDivisor) +\n+               Math.floorMod(-longDividend,  longDivisor) +\n+               Math.floorMod(-longDividend, -longDivisor);\n+    }\n+\n+    @Benchmark\n+    public double  fmaDouble() {\n+        return  Math.fma(double2, double81, double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public float  fmaFloat() {\n+        return  Math.fma(float2, floatNegative99, float7);\n+    }\n+\n+    @Benchmark\n+    public int  getExponentDouble() {\n+        return  Math.getExponent(double81);\n+    }\n+\n+    @Benchmark\n+    public int  getExponentFloat() {\n+        return  Math.getExponent(float7);\n+    }\n+\n+    @Benchmark\n+    public double  hypotDouble() {\n+        return  Math.hypot(double2, double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  IEEERemainderDouble() {\n+        return  Math.IEEEremainder(double81, double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public int  incrementExactInt() {\n+        return  Math.incrementExact(int42);\n+    }\n+\n+    @Benchmark\n+    public long  incrementExactLong() {\n+        return  Math.incrementExact(long747);\n+    }\n+\n+    @Benchmark\n+    public double  logDouble() {\n+        return  Math.log(double81);\n+    }\n+\n+    @Benchmark\n+    public double  log10Double() {\n+        return  Math.log10(double81);\n+    }\n+\n+    @Benchmark\n+    public double  log1pDouble() {\n+        return  Math.log1p(double81);\n+    }\n+\n+    @Benchmark\n+    public int  maxInt() {\n+        return  Math.max(int1, int2);\n+    }\n+\n+    @Benchmark\n+    public long  maxLong() {\n+        return  Math.max(long1, long2);\n+    }\n+\n+    @Benchmark\n+    public float  maxFloat() {\n+        return  Math.max(float1, float2);\n+    }\n+\n+    @Benchmark\n+    public double  maxDouble() {\n+        return  Math.max(double1, doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public int  minInt() {\n+        return  Math.min(int1, int2);\n+    }\n+\n+    @Benchmark\n+    public long  minLong() {\n+        return  Math.min(long1, long2);\n+    }\n+\n+    @Benchmark\n+    public float  minFloat() {\n+        return  Math.min(float1, floatNegative99);\n+    }\n+\n+    @Benchmark\n+    public double  minDouble() {\n+        return  Math.min(double4Dot1, double2);\n+    }\n+\n+    @Benchmark\n+    public int  multiplyExactInt() {\n+        return  Math.multiplyExact(int42, int5);\n+    }\n+\n+    @Benchmark\n+    public long  multiplyExactLongInt() {\n+        return  Math.multiplyExact(long747, int42);\n+    }\n+\n+    @Benchmark\n+    public long  multiplyExactLongLong() {\n+        return  Math.multiplyExact(long747, long13);\n+    }\n+\n+    @Benchmark\n+    public long  multiplyFullIntInt() {\n+        return  Math.multiplyFull(int42, int5);\n+    }\n+\n+    @Benchmark\n+    public long  multiplyHighLongLog() {\n+        return  Math.multiplyHigh(long747, long13);\n+    }\n+\n+    @Benchmark\n+    public int  negateExactInt() {\n+        return  Math.negateExact(int42);\n+    }\n+\n+    @Benchmark\n+    public long  negateExactLong() {\n+        return  Math.negateExact(long747);\n+    }\n+\n+    @Benchmark\n+    public double  nextAfterDoubleDouble() {\n+        return  Math.nextAfter(double81, double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public float  nextAfterFloatDouble() {\n+        return  Math.nextAfter(float7, doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public double  nextDownDouble() {\n+        return  Math.nextDown(float7);\n+    }\n+\n+    @Benchmark\n+    public float  nextDownFloat() {\n+        return  Math.nextDown(floatNegative99);\n+    }\n+\n+    @Benchmark\n+    public double  nextUpDouble() {\n+        return  Math.nextUp(double81);\n+    }\n+\n+    @Benchmark\n+    public float  nextUpFloat() {\n+        return  Math.nextUp(float7);\n+    }\n+\n+    @Benchmark\n+    public double  powDouble() {\n+        return  Math.pow(double4Dot1, double2);\n+    }\n+\n+    @Benchmark\n+    public double  powDoubleLoop() {\n+        double sum = 0.0;\n+        for (int i = 0; i < 1000; i++) {\n+            for (int j = 0; j < 1000; j++) {\n+                sum += i + Math.pow(j * 1.0, i * 1.0);\n@@ -3035,9 +444,0 @@\n-        } else if (start < direction) { \/\/ ascending\n-            \/\/ Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 => +0.0)\n-            \/\/ then bitwise convert start to integer.\n-            final long transducer = Double.doubleToRawLongBits(start + 0.0d);\n-            return Double.longBitsToDouble(transducer + ((transducer >= 0L) ? 1L : -1L));\n-        } else if (start == direction) {\n-            return direction;\n-        } else { \/\/ isNaN(start) || isNaN(direction)\n-            return start + direction;\n@@ -3045,0 +445,11 @@\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public double  powDouble0Dot5() {\n+        return  Math.pow(double4Dot1, double0Dot5);\n+    }\n+\n+    @Benchmark\n+    public double  powDouble0Dot5Const() {\n+        return  Math.pow(double4Dot1, 0.5);\n@@ -3047,71 +458,6 @@\n-    \/**\n-     * Returns the floating-point number adjacent to the first\n-     * argument in the direction of the second argument.  If both\n-     * arguments compare as equal a value equivalent to the second argument\n-     * is returned.\n-     *\n-     * <p>\n-     * Special cases:\n-     * <ul>\n-     * <li> If either argument is a NaN, then NaN is returned.\n-     *\n-     * <li> If both arguments are signed zeros, a value equivalent\n-     * to {@code direction} is returned.\n-     *\n-     * <li> If {@code start} is\n-     * &plusmn;{@link Float#MIN_VALUE} and {@code direction}\n-     * has a value such that the result should have a smaller\n-     * magnitude, then a zero with the same sign as {@code start}\n-     * is returned.\n-     *\n-     * <li> If {@code start} is infinite and\n-     * {@code direction} has a value such that the result should\n-     * have a smaller magnitude, {@link Float#MAX_VALUE} with the\n-     * same sign as {@code start} is returned.\n-     *\n-     * <li> If {@code start} is equal to &plusmn;\n-     * {@link Float#MAX_VALUE} and {@code direction} has a\n-     * value such that the result should have a larger magnitude, an\n-     * infinity with same sign as {@code start} is returned.\n-     * <\/ul>\n-     *\n-     * @param start  starting floating-point value\n-     * @param direction value indicating which of\n-     * {@code start}'s neighbors or {@code start} should\n-     * be returned\n-     * @return The floating-point number adjacent to {@code start} in the\n-     * direction of {@code direction}.\n-     * @since 1.6\n-     *\/\n-    public static float nextAfter(float start, double direction) {\n-        \/*\n-         * The cases:\n-         *\n-         * nextAfter(+infinity, 0)  == MAX_VALUE\n-         * nextAfter(+infinity, +infinity)  == +infinity\n-         * nextAfter(-infinity, 0)  == -MAX_VALUE\n-         * nextAfter(-infinity, -infinity)  == -infinity\n-         *\n-         * are naturally handled without any additional testing\n-         *\/\n-\n-        \/*\n-         * IEEE 754 floating-point numbers are lexicographically\n-         * ordered if treated as signed-magnitude integers.\n-         * Since Java's integers are two's complement,\n-         * incrementing the two's complement representation of a\n-         * logically negative floating-point value *decrements*\n-         * the signed-magnitude representation. Therefore, when\n-         * the integer representation of a floating-point value\n-         * is negative, the adjustment to the representation is in\n-         * the opposite direction from what would initially be expected.\n-         *\/\n-\n-        \/\/ Branch to descending case first as it is more costly than ascending\n-        \/\/ case due to start != 0.0f conditional.\n-        if (start > direction) { \/\/ descending\n-            if (start != 0.0f) {\n-                final int transducer = Float.floatToRawIntBits(start);\n-                return Float.intBitsToFloat(transducer + ((transducer > 0) ? -1 : 1));\n-            } else { \/\/ start == 0.0f && direction < 0.0f\n-                return -Float.MIN_VALUE;\n+    @Benchmark\n+    public double  powDouble0Dot5Loop() {\n+        double sum = 0.0;\n+        for (int i = 0; i < 1000; i++) {\n+            for (int j = 0; j < 1000; j++) {\n+                sum += i + Math.pow(j * 1.0, 0.5);\n@@ -3119,9 +465,0 @@\n-        } else if (start < direction) { \/\/ ascending\n-            \/\/ Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 => +0.0)\n-            \/\/ then bitwise convert start to integer.\n-            final int transducer = Float.floatToRawIntBits(start + 0.0f);\n-            return Float.intBitsToFloat(transducer + ((transducer >= 0) ? 1 : -1));\n-        } else if (start == direction) {\n-            return (float)direction;\n-        } else { \/\/ isNaN(start) || isNaN(direction)\n-            return start + (float)direction;\n@@ -3129,0 +466,1 @@\n+        return sum;\n@@ -3131,37 +469,3 @@\n-    \/**\n-     * Returns the floating-point value adjacent to {@code d} in\n-     * the direction of positive infinity.  This method is\n-     * semantically equivalent to {@code nextAfter(d,\n-     * Double.POSITIVE_INFINITY)}; however, a {@code nextUp}\n-     * implementation may run faster than its equivalent\n-     * {@code nextAfter} call.\n-     *\n-     * <p>Special Cases:\n-     * <ul>\n-     * <li> If the argument is NaN, the result is NaN.\n-     *\n-     * <li> If the argument is positive infinity, the result is\n-     * positive infinity.\n-     *\n-     * <li> If the argument is zero, the result is\n-     * {@link Double#MIN_VALUE}\n-     *\n-     * <\/ul>\n-     *\n-     * @apiNote This method corresponds to the nextUp\n-     * operation defined in IEEE 754.\n-     *\n-     * @param d starting floating-point value\n-     * @return The adjacent floating-point value closer to positive\n-     * infinity.\n-     * @since 1.6\n-     *\/\n-    public static double nextUp(double d) {\n-        \/\/ Use a single conditional and handle the likely cases first.\n-        if (d < Double.POSITIVE_INFINITY) {\n-            \/\/ Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 => +0.0).\n-            final long transducer = Double.doubleToRawLongBits(d + 0.0D);\n-            return Double.longBitsToDouble(transducer + ((transducer >= 0L) ? 1L : -1L));\n-        } else { \/\/ d is NaN or +Infinity\n-            return d;\n-        }\n+    @Benchmark\n+    public double  random() {\n+        return  Math.random();\n@@ -3170,37 +474,3 @@\n-    \/**\n-     * Returns the floating-point value adjacent to {@code f} in\n-     * the direction of positive infinity.  This method is\n-     * semantically equivalent to {@code nextAfter(f,\n-     * Float.POSITIVE_INFINITY)}; however, a {@code nextUp}\n-     * implementation may run faster than its equivalent\n-     * {@code nextAfter} call.\n-     *\n-     * <p>Special Cases:\n-     * <ul>\n-     * <li> If the argument is NaN, the result is NaN.\n-     *\n-     * <li> If the argument is positive infinity, the result is\n-     * positive infinity.\n-     *\n-     * <li> If the argument is zero, the result is\n-     * {@link Float#MIN_VALUE}\n-     *\n-     * <\/ul>\n-     *\n-     * @apiNote This method corresponds to the nextUp\n-     * operation defined in IEEE 754.\n-     *\n-     * @param f starting floating-point value\n-     * @return The adjacent floating-point value closer to positive\n-     * infinity.\n-     * @since 1.6\n-     *\/\n-    public static float nextUp(float f) {\n-        \/\/ Use a single conditional and handle the likely cases first.\n-        if (f < Float.POSITIVE_INFINITY) {\n-            \/\/ Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 => +0.0).\n-            final int transducer = Float.floatToRawIntBits(f + 0.0F);\n-            return Float.intBitsToFloat(transducer + ((transducer >= 0) ? 1 : -1));\n-        } else { \/\/ f is NaN or +Infinity\n-            return f;\n-        }\n+    @Benchmark\n+    public double  rintDouble() {\n+        return  Math.rint(double4Dot1);\n@@ -3209,38 +479,3 @@\n-    \/**\n-     * Returns the floating-point value adjacent to {@code d} in\n-     * the direction of negative infinity.  This method is\n-     * semantically equivalent to {@code nextAfter(d,\n-     * Double.NEGATIVE_INFINITY)}; however, a\n-     * {@code nextDown} implementation may run faster than its\n-     * equivalent {@code nextAfter} call.\n-     *\n-     * <p>Special Cases:\n-     * <ul>\n-     * <li> If the argument is NaN, the result is NaN.\n-     *\n-     * <li> If the argument is negative infinity, the result is\n-     * negative infinity.\n-     *\n-     * <li> If the argument is zero, the result is\n-     * {@code -Double.MIN_VALUE}\n-     *\n-     * <\/ul>\n-     *\n-     * @apiNote This method corresponds to the nextDown\n-     * operation defined in IEEE 754.\n-     *\n-     * @param d  starting floating-point value\n-     * @return The adjacent floating-point value closer to negative\n-     * infinity.\n-     * @since 1.8\n-     *\/\n-    public static double nextDown(double d) {\n-        if (Double.isNaN(d) || d == Double.NEGATIVE_INFINITY)\n-            return d;\n-        else {\n-            if (d == 0.0)\n-                return -Double.MIN_VALUE;\n-            else\n-                return Double.longBitsToDouble(Double.doubleToRawLongBits(d) +\n-                                               ((d > 0.0d)?-1L:+1L));\n-        }\n+    @Benchmark\n+    public long  roundDouble() {\n+        return  Math.round( Math.PI);\n@@ -3249,38 +484,3 @@\n-    \/**\n-     * Returns the floating-point value adjacent to {@code f} in\n-     * the direction of negative infinity.  This method is\n-     * semantically equivalent to {@code nextAfter(f,\n-     * Float.NEGATIVE_INFINITY)}; however, a\n-     * {@code nextDown} implementation may run faster than its\n-     * equivalent {@code nextAfter} call.\n-     *\n-     * <p>Special Cases:\n-     * <ul>\n-     * <li> If the argument is NaN, the result is NaN.\n-     *\n-     * <li> If the argument is negative infinity, the result is\n-     * negative infinity.\n-     *\n-     * <li> If the argument is zero, the result is\n-     * {@code -Float.MIN_VALUE}\n-     *\n-     * <\/ul>\n-     *\n-     * @apiNote This method corresponds to the nextDown\n-     * operation defined in IEEE 754.\n-     *\n-     * @param f  starting floating-point value\n-     * @return The adjacent floating-point value closer to negative\n-     * infinity.\n-     * @since 1.8\n-     *\/\n-    public static float nextDown(float f) {\n-        if (Float.isNaN(f) || f == Float.NEGATIVE_INFINITY)\n-            return f;\n-        else {\n-            if (f == 0.0f)\n-                return -Float.MIN_VALUE;\n-            else\n-                return Float.intBitsToFloat(Float.floatToRawIntBits(f) +\n-                                            ((f > 0.0f)?-1:+1));\n-        }\n+    @Benchmark\n+    public int  roundFloat() {\n+        return  Math.round(eFloat);\n@@ -3289,51 +489,60 @@\n-    private static final double F_UP = 0x1p1023;  \/\/ normal, exact, 2^DoubleConsts.EXP_BIAS\n-    private static final double F_DOWN = 0x1p-1023;  \/\/ subnormal, exact, 2^-DoubleConsts.EXP_BIAS\n-\n-    \/**\n-     * Returns {@code d} &times; 2<sup>{@code scaleFactor}<\/sup>\n-     * rounded as if performed by a single correctly rounded\n-     * floating-point multiply.  If the exponent of the result is\n-     * between {@link Double#MIN_EXPONENT} and {@link\n-     * Double#MAX_EXPONENT}, the answer is calculated exactly.  If the\n-     * exponent of the result would be larger than {@code\n-     * Double.MAX_EXPONENT}, an infinity is returned.  Note that if\n-     * the result is subnormal, precision may be lost; that is, when\n-     * {@code scalb(x, n)} is subnormal, {@code scalb(scalb(x, n),\n-     * -n)} may not equal <i>x<\/i>.  When the result is non-NaN, the\n-     * result has the same sign as {@code d}.\n-     *\n-     * <p>Special cases:\n-     * <ul>\n-     * <li> If the first argument is NaN, NaN is returned.\n-     * <li> If the first argument is infinite, then an infinity of the\n-     * same sign is returned.\n-     * <li> If the first argument is zero, then a zero of the same\n-     * sign is returned.\n-     * <\/ul>\n-     *\n-     * @apiNote This method corresponds to the scaleB operation\n-     * defined in IEEE 754.\n-     *\n-     * @param d number to be scaled by a power of two.\n-     * @param scaleFactor power of 2 used to scale {@code d}\n-     * @return {@code d} &times; 2<sup>{@code scaleFactor}<\/sup>\n-     * @since 1.6\n-     *\/\n-    public static double scalb(double d, int scaleFactor) {\n-        if (scaleFactor > -DoubleConsts.EXP_BIAS) {\n-            if (scaleFactor <= DoubleConsts.EXP_BIAS) {\n-                return d * primPowerOfTwoD(scaleFactor);\n-            }\n-            if (scaleFactor <= 2 * DoubleConsts.EXP_BIAS) {\n-                return d * primPowerOfTwoD(scaleFactor - DoubleConsts.EXP_BIAS) * F_UP;\n-            }\n-            if (scaleFactor < 2 * DoubleConsts.EXP_BIAS + PRECISION - 1) {\n-                return d * primPowerOfTwoD(scaleFactor - 2 * DoubleConsts.EXP_BIAS) * F_UP * F_UP;\n-            }\n-            return d * F_UP * F_UP * F_UP;\n-        }\n-        if (scaleFactor > -2 * DoubleConsts.EXP_BIAS) {\n-            return d * primPowerOfTwoD(scaleFactor + DoubleConsts.EXP_BIAS) * F_DOWN;\n-        }\n-        if (scaleFactor > -2 * DoubleConsts.EXP_BIAS - PRECISION) {\n-            return d * primPowerOfTwoD(scaleFactor + 2 * DoubleConsts.EXP_BIAS) * F_DOWN * F_DOWN;\n+    @Benchmark\n+    public double  scalbDoubleInt() {\n+        return  Math.scalb(double81, int2);\n+    }\n+\n+    @Benchmark\n+    public float  scalbFloatInt() {\n+        return  Math.scalb(float7, int2);\n+    }\n+\n+    @Benchmark\n+    public double  signumDouble() {\n+        return  Math.signum(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  signumFloat() {\n+        return  Math.signum(floatNegative99);\n+    }\n+\n+    @Benchmark\n+    public double  sinDouble() {\n+        return  Math.sin(double1);\n+    }\n+\n+    @Benchmark\n+    public double  sinhDouble() {\n+        return  Math.sinh(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  sqrtDouble() {\n+        return  Math.sqrt(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  subtractExactIntInt() {\n+        return  Math.subtractExact(int42,int5);\n+    }\n+\n+    @Benchmark\n+    public double  subtractExactLongLong() {\n+        return  Math.subtractExact(long747,long13);\n+    }\n+\n+    @Benchmark\n+    public double  tanDouble() {\n+        return  Math.tan(double1);\n+    }\n+\n+    @Benchmark\n+    public double  tanhDouble() {\n+        return  Math.tanh(double1);\n+    }\n+\n+    @Benchmark\n+    public double  tanhRangeDouble() {\n+        double sum = 0.0;\n+        for (int i = 0; i < tanhValueCount; i++) {\n+            sum += Math.tanh(tanhPosVector[i]) + Math.tanh(tanhNegVector[i]);\n@@ -3341,78 +550,16 @@\n-        return d * MIN_VALUE * MIN_VALUE;\n-    }\n-\n-    \/**\n-     * Returns {@code f} &times; 2<sup>{@code scaleFactor}<\/sup>\n-     * rounded as if performed by a single correctly rounded\n-     * floating-point multiply.  If the exponent of the result is\n-     * between {@link Float#MIN_EXPONENT} and {@link\n-     * Float#MAX_EXPONENT}, the answer is calculated exactly.  If the\n-     * exponent of the result would be larger than {@code\n-     * Float.MAX_EXPONENT}, an infinity is returned.  Note that if the\n-     * result is subnormal, precision may be lost; that is, when\n-     * {@code scalb(x, n)} is subnormal, {@code scalb(scalb(x, n),\n-     * -n)} may not equal <i>x<\/i>.  When the result is non-NaN, the\n-     * result has the same sign as {@code f}.\n-     *\n-     * <p>Special cases:\n-     * <ul>\n-     * <li> If the first argument is NaN, NaN is returned.\n-     * <li> If the first argument is infinite, then an infinity of the\n-     * same sign is returned.\n-     * <li> If the first argument is zero, then a zero of the same\n-     * sign is returned.\n-     * <\/ul>\n-     *\n-     * @apiNote This method corresponds to the scaleB operation\n-     * defined in IEEE 754.\n-     *\n-     * @param f number to be scaled by a power of two.\n-     * @param scaleFactor power of 2 used to scale {@code f}\n-     * @return {@code f} &times; 2<sup>{@code scaleFactor}<\/sup>\n-     * @since 1.6\n-     *\/\n-    public static float scalb(float f, int scaleFactor) {\n-        \/\/ magnitude of a power of two so large that scaling a finite\n-        \/\/ nonzero value by it would be guaranteed to over or\n-        \/\/ underflow; due to rounding, scaling down takes an\n-        \/\/ additional power of two which is reflected here\n-        final int MAX_SCALE = Float.MAX_EXPONENT + -Float.MIN_EXPONENT +\n-                              FloatConsts.SIGNIFICAND_WIDTH + 1;\n-\n-        \/\/ Make sure scaling factor is in a reasonable range\n-        scaleFactor = Math.max(Math.min(scaleFactor, MAX_SCALE), -MAX_SCALE);\n-\n-        \/*\n-         * Since + MAX_SCALE for float fits well within the double\n-         * exponent range and + float -> double conversion is exact\n-         * the multiplication below will be exact. Therefore, the\n-         * rounding that occurs when the double product is cast to\n-         * float will be the correctly rounded float result.\n-         *\/\n-        return (float)((double)f*powerOfTwoD(scaleFactor));\n-    }\n-\n-    \/**\n-     * Returns a floating-point power of two in the normal range.\n-     *\/\n-    static double powerOfTwoD(int n) {\n-        assert(n >= Double.MIN_EXPONENT && n <= Double.MAX_EXPONENT);\n-        return primPowerOfTwoD(n);\n-    }\n-\n-    \/**\n-     * Returns a floating-point power of two in the normal range.\n-     * No checks are performed on the argument.\n-     *\/\n-    private static double primPowerOfTwoD(int n) {\n-        return longBitsToDouble((long) (n + DoubleConsts.EXP_BIAS) << PRECISION - 1);\n-    }\n-\n-    \/**\n-     * Returns a floating-point power of two in the normal range.\n-     *\/\n-    static float powerOfTwoF(int n) {\n-        assert(n >= Float.MIN_EXPONENT && n <= Float.MAX_EXPONENT);\n-        return Float.intBitsToFloat(((n + FloatConsts.EXP_BIAS) <<\n-                                     (FloatConsts.SIGNIFICAND_WIDTH-1))\n-                                    & FloatConsts.EXP_BIT_MASK);\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public double  toDegreesDouble() {\n+        return  Math.toDegrees(double81);\n+    }\n+\n+    @Benchmark\n+    public double  toIntExactLong() {\n+        return  Math.toIntExact(long747);\n+    }\n+\n+    @Benchmark\n+    public double  toRadiansDouble() {\n+        return  Math.toRadians(double81);\n@@ -3420,0 +567,16 @@\n+\n+    @Benchmark\n+    public double  ulpDouble() {\n+        return  Math.ulp(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  ulpFloat() {\n+        return  Math.ulp(float7);\n+    }\n+\n+    @Benchmark\n+    public long  unsignedMultiplyHighLongLong() {\n+        return  Math.unsignedMultiplyHigh(long747, long13);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":524,"deletions":3361,"binary":false,"changes":3885,"status":"modified"}]}