{"files":[{"patch":"@@ -1338,1 +1338,1 @@\n-    tty_message(\"=====================\");\n+    tty_message(\"=== START DUMP ===\");\n@@ -1341,0 +1341,1 @@\n+    tty_message(\"=== END DUMP ===\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import com.sun.jdi.Bootstrap;\n+import com.sun.jdi.ClassType;\n+import com.sun.jdi.VirtualMachine;\n+import com.sun.jdi.VMDisconnectedException;\n+import com.sun.jdi.connect.AttachingConnector;\n+import com.sun.jdi.connect.Connector;\n+import com.sun.jdi.connect.IllegalConnectorArgumentsException;\n+import com.sun.jdi.event.ClassPrepareEvent;\n+import com.sun.jdi.event.Event;\n+import com.sun.jdi.event.EventSet;\n+import com.sun.jdi.request.EventRequest;\n+import com.sun.jdi.request.ClassPrepareRequest;\n+\/**\n+ * @test\n+ * @bug  8332488\n+ * @summary Unit test for testing debug agent support for JVMTI.data_dump jcmd.\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.jdi\n+ * @build DataDumpTest\n+ * @run main\/othervm\/timeout=15 DataDumpTest\n+ *\/\n+\n+class DataDumpTestTarg {\n+    public static void main(String args[]) throws Exception {\n+        \/\/ Write something that can be read by the driver\n+        System.out.println(\"Debuggee started\");\n+    }\n+}\n+\n+public class DataDumpTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"Test 1: Debuggee start with datadump=y\");\n+        runTest(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,datadump=y\");\n+    }\n+\n+    private static void sleep(long ms) {\n+        try {\n+            Thread.sleep(ms);\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private static void runTest(String jdwpArg) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                jdwpArg,\n+                \/\/ Probably not required by this test, but best to include when using datadump\n+                \"-XX:+StartAttachListener\",\n+                \"DataDumpTestTarg\");\n+        Process p = null;\n+        OutputAnalyzer out = null;\n+        try {\n+            p = pb.start();\n+            InputStream is = p.getInputStream();\n+            out = new OutputAnalyzer(p);\n+\n+            \/\/ Attach a debugger and do the data dump. The data dump output will appear\n+            \/\/ in the debuggee output.\n+            attachAndDump(p.pid());\n+\n+            out.waitFor(); \/\/ Wait for the debuggee to exit\n+\n+            System.out.println(\"Deuggee output:\");\n+            System.out.println(out.getOutput());\n+\n+            \/\/ All these strings are part of the debug agent data dump output.\n+            out.shouldHaveExitValue(0);\n+            out.shouldContain(\"Debuggee started\");\n+            out.shouldContain(\"Debug Agent Data Dump\");\n+            out.shouldContain(\"suspendAllCount: 0\");\n+            out.shouldContain(\"ClassMatch: classPattern(DataDumpTestTarg)\");\n+            out.shouldContain(\"Handlers for EI_VM_DEATH\");\n+        } finally {\n+            if (p != null) {\n+                p.destroyForcibly();\n+            }\n+        }\n+    }\n+\n+    private static void attachAndDump(long pid) throws IOException,\n+            IllegalConnectorArgumentsException {\n+        \/\/ Get the ProcessAttachingConnector, which can attach using the pid of the debuggee.\n+        AttachingConnector ac = Bootstrap.virtualMachineManager().attachingConnectors()\n+                .stream()\n+                .filter(c -> c.name().equals(\"com.sun.jdi.ProcessAttach\"))\n+                .findFirst()\n+                .orElseThrow(() -> new RuntimeException(\"Unable to locate ProcessAttachingConnector\"));\n+\n+        \/\/ Set the connector's \"pid\" argument to the pid of the debuggee.\n+        Map<String, Connector.Argument> args = ac.defaultArguments();\n+        Connector.StringArgument arg = (Connector.StringArgument)args.get(\"pid\");\n+        arg.setValue(\"\" + pid);\n+\n+        \/\/ Attach to the debuggee.\n+        System.out.println(\"Debugger is attaching to: \" + pid + \" ...\");\n+        VirtualMachine vm = ac.attach(args);\n+\n+        \/\/ List all threads as a sanity check.\n+        System.out.println(\"Attached! Now listing threads ...\");\n+        vm.allThreads().stream().forEach(System.out::println);\n+\n+        \/\/ Request VM to trigger ClassPrepareRequest when DataDumpTestTarg class is prepared.\n+        ClassPrepareRequest classPrepareRequest = vm.eventRequestManager().createClassPrepareRequest();\n+        classPrepareRequest.addClassFilter(\"DataDumpTestTarg\");\n+        \/\/ Don't use SUSPEND_ALL here. That might prevent the data dump because the\n+        \/\/ Signal Dispatcher and Attach Listener threads will be suspended, and they\n+        \/\/ may be needed by the jcmd support.\n+        classPrepareRequest.setSuspendPolicy(EventRequest.SUSPEND_EVENT_THREAD);\n+        classPrepareRequest.enable();\n+\n+        try {\n+            while (true) { \/\/ Exit when we get VMDisconnectedException\n+                EventSet eventSet = vm.eventQueue().remove();\n+                if (eventSet == null) {\n+                    continue;\n+                }\n+                for (Event event : eventSet) {\n+                    System.out.println(\"Received event: \" + event);\n+                    if (event instanceof ClassPrepareEvent) {\n+                        ClassPrepareEvent evt = (ClassPrepareEvent) event;\n+                        ClassType classType = (ClassType) evt.referenceType();\n+\n+                        \/\/ Run JVMTI.data_dump jcmd.\n+                        OutputAnalyzer out = new PidJcmdExecutor(\"\" + pid).execute(\"JVMTI.data_dump\");\n+                        out.waitFor();\n+\n+                        \/\/ Verify the output of the jcmd. Note the actual dump is in the debuggee\n+                        \/\/ output, not in the jcmd output, so we don't check it here.\n+                        System.out.println(\"JVMTI.data_dump output:\");\n+                        System.out.println(out.getOutput());\n+                        out.shouldContain(\"Command executed successfully\");\n+                        out.shouldHaveExitValue(0);\n+                    }\n+                }\n+                eventSet.resume();\n+            }\n+        } catch (VMDisconnectedException e) {\n+            System.out.println(\"VM is now disconnected.\");\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/DataDumpTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"}]}