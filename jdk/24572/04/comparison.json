{"files":[{"patch":"@@ -58,0 +58,2 @@\n+  bool is_uncommit_operation = state == StateType::Reserved && use_tag_inplace;\n+  bool tree_is_changed = false;\n@@ -61,7 +63,10 @@\n-    assert(!use_tag_inplace, \"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n-    if (use_tag_inplace) {\n-      log_debug(nmt)(\"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n-    }\n-    \/\/ No match. We add the A node directly, unless it would have no effect.\n-    if (!stA.is_noop()) {\n-      _tree.upsert(A, stA);\n+    if (!is_uncommit_operation) {\n+      assert(!use_tag_inplace, \"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n+      if (use_tag_inplace) {\n+        log_debug(nmt)(\"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n+      }\n+      \/\/ No match. We add the A node directly, unless it would have no effect.\n+      if (!stA.is_noop()) {\n+        _tree.upsert(A, stA);\n+        tree_is_changed = true;\n+      }\n@@ -74,0 +79,2 @@\n+    bool is_uncommit_over_released = is_uncommit_operation && leqA_state == StateType::Released;\n+    tty->print_cr(\" == A ..., uncom-over-rel: %d\", is_uncommit_over_released);\n@@ -76,1 +83,1 @@\n-    if (use_tag_inplace) {\n+    if (use_tag_inplace && !is_uncommit_over_released) {\n@@ -91,0 +98,1 @@\n+      tty->print_cr(\"A == ...\");\n@@ -98,10 +106,14 @@\n-      if (stA.is_noop()) {\n-        \/\/ invalidates leqA_n\n-        _tree.remove(leqA_n->key());\n-      } else {\n-        \/\/ If the state is not matching then we have different operations, such as:\n-        \/\/ reserve [x1, A); ... commit [A, x2); or\n-        \/\/ reserve [x1, A), mem_tag1; ... reserve [A, x2), mem_tag2; or\n-        \/\/ reserve [A, x1), mem_tag1; ... reserve [A, x2), mem_tag2;\n-        \/\/ then we re-use the existing out node, overwriting its old metadata.\n-        leqA_n->val() = stA;\n+      if (!is_uncommit_over_released) {\n+        tree_is_changed = true;\n+        tty->print_cr(\"!uncom-over-rel ...\");\n+        if (stA.is_noop()) {\n+          \/\/ invalidates leqA_n\n+          _tree.remove(leqA_n->key());\n+        } else {\n+          \/\/ If the state is not matching then we have different operations, such as:\n+          \/\/ reserve [x1, A); ... commit [A, x2); or\n+          \/\/ reserve [x1, A), mem_tag1; ... reserve [A, x2), mem_tag2; or\n+          \/\/ reserve [A, x1), mem_tag1; ... reserve [A, x2), mem_tag2;\n+          \/\/ then we re-use the existing out node, overwriting its old metadata.\n+          leqA_n->val() = stA;\n+        }\n@@ -109,0 +121,1 @@\n+\n@@ -112,0 +125,1 @@\n+      tty->print_cr(\"A > leqA ...\");\n@@ -117,5 +131,10 @@\n-      if (stA.is_noop()) {\n-        \/\/ Nothing to do.\n-      } else {\n-        \/\/ Add new node.\n-        _tree.upsert(A, stA);\n+      if (!is_uncommit_over_released) {\n+        tty->print_cr(\"Not unc-over-rel...\");\n+        if (stA.is_noop()) {\n+          \/\/ Nothing to do.\n+        } else {\n+          \/\/ Add new node.\n+          _tree.upsert(A, stA);\n+          tree_is_changed = true;\n+          tty->print_cr(\"A upsert ...\");\n+        }\n@@ -132,1 +151,9 @@\n-\n+  auto can_be_deleted = [&](TreapNode* node) -> bool {\n+    if (is_uncommit_operation && node->val().out.type() == StateType::Released) {\n+      return false;\n+    }\n+    if (is_uncommit_operation && node->val().out.type() == StateType::Committed) {\n+      return false;\n+    }\n+    return true;\n+  };\n@@ -137,0 +164,1 @@\n+    tty->print_cr(\"visit..., node: %d\", (int) head->key());\n@@ -138,10 +166,16 @@\n-    if (cmp_B < 0) {\n-      \/\/ Record all nodes preceding B.\n-      to_be_deleted_inbetween_a_b.push({head->key(), head->val()});\n-    } else if (cmp_B == 0) {\n-      \/\/ Re-purpose B node, unless it would result in a noop node, in\n-      \/\/ which case record old node at B for deletion and summary accounting.\n-      if (stB.is_noop()) {\n-        to_be_deleted_inbetween_a_b.push(AddressState{B, head->val()});\n-      } else {\n-        head->val() = stB;\n+    if (can_be_deleted(head))  {\n+      if (cmp_B < 0) {\n+        tty->print_cr(\"to-be-deleted\");\n+        \/\/ Record all nodes preceding B.\n+        to_be_deleted_inbetween_a_b.push({head->key(), head->val()});\n+      } else if (cmp_B == 0) {\n+        \/\/ Re-purpose B node, unless it would result in a noop node, in\n+        \/\/ which case record old node at B for deletion and summary accounting.\n+        if (stB.is_noop()) {\n+          tty->print_cr(\"to be deleted\");\n+          to_be_deleted_inbetween_a_b.push(AddressState{B, head->val()});\n+        } else {\n+          head->val() = stB;\n+          tree_is_changed = true;\n+        }\n+        B_needs_insert = false;\n@@ -149,1 +183,0 @@\n-      B_needs_insert = false;\n@@ -152,1 +185,0 @@\n-\n@@ -157,1 +189,5 @@\n-    _tree.upsert(B, stB);\n+      if (!is_uncommit_operation) {\n+        _tree.upsert(B, stB);\n+        tree_is_changed = true;\n+        tty->print_cr(\"upser B after visit ......\");\n+      }\n@@ -168,0 +204,1 @@\n+    tty->print_cr(\"len == 0 && not found LEQ...\");\n@@ -182,0 +219,2 @@\n+    tree_is_changed = true;\n+    tty->print_cr(\"in loop for deleting ...\");\n@@ -194,0 +233,4 @@\n+  if (!tree_is_changed) {\n+    return SummaryDiff();\n+  }\n+\n@@ -198,0 +241,2 @@\n+    tty->print_cr(\"in If !=A and Released...\");\n+\n@@ -207,0 +252,1 @@\n+  tty->print_cr(\"End of routine...\");\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":83,"deletions":37,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -742,0 +742,89 @@\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, UncommmitReleasedRegion) {\n+  {\n+    Tree tree;\n+    VMATree::RegionData rd(si[0], mtNone);\n+    VMATree::SummaryDiff diff = tree.uncommit_mapping(40, 20, rd);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtNone)].reserve);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtNone)].commit);\n+  }\n+  {\n+    Tree tree;\n+    VMATree::RegionData rd(si[0], mtTest);\n+    VMATree::RegionData rd2(si[0], mtNone);\n+    tree.reserve_mapping(0, 100, rd);\n+    tree.release_mapping(50, 20);\n+    \/\/0-----50....70-----100\n+    \/\/   40----60\n+    VMATree::SummaryDiff diff = tree.uncommit_mapping(40, 20, rd2);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtNone)].reserve);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtNone)].commit);\n+  }\n+  {\n+    Tree tree;\n+    VMATree::RegionData rd(si[0], mtTest);\n+    VMATree::RegionData rd2(si[0], mtNone);\n+    tree.commit_mapping(0, 10, rd);\n+    tree.commit_mapping(20, 10, rd);\n+    \/\/0-----10....20-----30\n+    \/\/0----------------------------100\n+    tree.print_on(tty);\n+    VMATree::SummaryDiff diff = tree.uncommit_mapping(0, 100, rd2);\n+    tree.print_on(tty);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+    EXPECT_EQ(-20, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtNone)].reserve);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtNone)].commit);\n+  }\n+  {\n+    Tree tree;\n+    VMATree::RegionData rd(si[0], mtTest);\n+    VMATree::RegionData rd2(si[0], mtNone);\n+    tree.reserve_mapping(40, 60, rd);\n+    tree.release_mapping(50, 20);\n+    \/\/....40---50....70-----100\n+    \/\/ 20---------60\n+    VMATree::SummaryDiff diff = tree.uncommit_mapping(20, 40, rd2);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtNone)].reserve);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtNone)].commit);\n+  }\n+  {\n+    Tree tree;\n+    VMATree::RegionData rd(si[0], mtTest);\n+    VMATree::RegionData rd2(si[0], mtNone);\n+    tree.reserve_mapping(0, 100, rd);\n+    tree.release_mapping(50, 20);\n+    \/\/0-----50....70-----100\n+    \/\/         60----80\n+    VMATree::SummaryDiff diff = tree.uncommit_mapping(60, 20, rd2);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtNone)].reserve);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtNone)].commit);\n+  }\n+  {\n+    Tree tree;\n+    VMATree::RegionData rd(si[0], mtTest);\n+    VMATree::RegionData rd2(si[0], mtNone);\n+    tree.reserve_mapping(0, 100, rd);\n+    tree.release_mapping(50, 20);\n+    tree.set_tag(70, 30, mtClass);\n+    \/\/ mtTest    mtNone     mtClass\n+    \/\/0-------50.........70---------100\n+    \/\/    40-------------70\n+    VMATree::SummaryDiff diff = tree.uncommit_mapping(40, 30, rd2);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtNone)].reserve);\n+    EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtNone)].commit);\n+    \/\/ Node 70 should not be changed\n+    VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(70);\n+    ASSERT_TRUE(r.start != nullptr);\n+    EXPECT_TRUE(r.start->val().out.type() == VMATree::StateType::Reserved);\n+    EXPECT_EQ(r.start->val().out.mem_tag(), mtClass);\n+  }\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"}]}