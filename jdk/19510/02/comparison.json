{"files":[{"patch":"@@ -39,0 +39,1 @@\n+#include \"jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp\"\n@@ -275,0 +276,22 @@\n+static inline void reset_write_state(const JfrBlobHandle& handle) {\n+  handle->reset_write_state();\n+}\n+\n+\/\/ Resets the blob write states from the previous epoch.\n+static void reset_blob_write_state(const ObjectSampler* sampler, JavaThread* jt) {\n+  assert(sampler != nullptr, \"invariant\");\n+  const ObjectSample* sample = sampler->last_resolved();\n+  while (sample != nullptr) {\n+    if (sample->has_stacktrace()) {\n+      reset_write_state(sample->stacktrace());\n+    }\n+    if (sample->has_thread()) {\n+      reset_write_state(sample->thread());\n+    }\n+    if (sample->has_type_set()) {\n+      reset_write_state(sample->type_set());\n+    }\n+    sample = sample->next();\n+  }\n+}\n+\n@@ -280,0 +303,1 @@\n+  reset_blob_write_state(sampler, thread);\n@@ -329,5 +353,1 @@\n-static void write_blob(const JfrBlobHandle& blob, JfrCheckpointWriter& writer, bool reset) {\n-  if (reset) {\n-    blob->reset_write_state();\n-    return;\n-  }\n+static void write_blob(const JfrBlobHandle& blob, JfrCheckpointWriter& writer) {\n@@ -337,1 +357,1 @@\n-static void write_type_set_blob(const ObjectSample* sample, JfrCheckpointWriter& writer, bool reset) {\n+static void write_type_set_blob(const ObjectSample* sample, JfrCheckpointWriter& writer) {\n@@ -339,1 +359,1 @@\n-    write_blob(sample->type_set(), writer, reset);\n+    write_blob(sample->type_set(), writer);\n@@ -343,1 +363,1 @@\n-static void write_thread_blob(const ObjectSample* sample, JfrCheckpointWriter& writer, bool reset) {\n+static void write_thread_blob(const ObjectSample* sample, JfrCheckpointWriter& writer) {\n@@ -346,1 +366,1 @@\n-    write_blob(sample->thread(), writer, reset);\n+    write_blob(sample->thread(), writer);\n@@ -350,1 +370,1 @@\n-static void write_stacktrace_blob(const ObjectSample* sample, JfrCheckpointWriter& writer, bool reset) {\n+static void write_stacktrace_blob(const ObjectSample* sample, JfrCheckpointWriter& writer) {\n@@ -352,1 +372,1 @@\n-    write_blob(sample->stacktrace(), writer, reset);\n+    write_blob(sample->stacktrace(), writer);\n@@ -356,1 +376,1 @@\n-static void write_blobs(const ObjectSample* sample, JfrCheckpointWriter& writer, bool reset) {\n+static void write_blobs(const ObjectSample* sample, JfrCheckpointWriter& writer) {\n@@ -358,3 +378,3 @@\n-  write_stacktrace_blob(sample, writer, reset);\n-  write_thread_blob(sample, writer, reset);\n-  write_type_set_blob(sample, writer, reset);\n+  write_stacktrace_blob(sample, writer);\n+  write_thread_blob(sample, writer);\n+  write_type_set_blob(sample, writer);\n@@ -368,1 +388,0 @@\n-  bool _reset;\n@@ -371,1 +390,1 @@\n-    _sampler(sampler), _writer(writer), _last_sweep(last_sweep), _reset(false)  {}\n+    _sampler(sampler), _writer(writer), _last_sweep(last_sweep) {}\n@@ -374,1 +393,1 @@\n-      write_blobs(sample, _writer, _reset);\n+      write_blobs(sample, _writer);\n@@ -377,3 +396,0 @@\n-  void set_reset() {\n-    _reset = true;\n-  }\n@@ -388,3 +404,0 @@\n-  \/\/ reset blob write states\n-  cbw.set_reset();\n-  iterate_samples(cbw, true);\n@@ -406,38 +419,0 @@\n-\/\/ A linked list of saved type set blobs for the epoch.\n-\/\/ The link consist of a reference counted handle.\n-static JfrBlobHandle saved_type_set_blobs;\n-\n-static void release_state_for_previous_epoch() {\n-  \/\/ decrements the reference count and the list is reinitialized\n-  saved_type_set_blobs = JfrBlobHandle();\n-}\n-\n-class BlobInstaller {\n- public:\n-  ~BlobInstaller() {\n-    release_state_for_previous_epoch();\n-  }\n-  void sample_do(ObjectSample* sample) {\n-    if (!sample->is_dead()) {\n-      sample->set_type_set(saved_type_set_blobs);\n-    }\n-  }\n-};\n-\n-static void install_type_set_blobs() {\n-  if (saved_type_set_blobs.valid()) {\n-    BlobInstaller installer;\n-    iterate_samples(installer);\n-  }\n-}\n-\n-static void save_type_set_blob(JfrCheckpointWriter& writer) {\n-  assert(writer.has_data(), \"invariant\");\n-  const JfrBlobHandle blob = writer.copy();\n-  if (saved_type_set_blobs.valid()) {\n-    saved_type_set_blobs->set_next(blob);\n-  } else {\n-    saved_type_set_blobs = blob;\n-  }\n-}\n-\n@@ -445,1 +420,1 @@\n-void ObjectSampleCheckpoint::on_type_set(JfrCheckpointWriter& writer) {\n+void ObjectSampleCheckpoint::on_type_set(JavaThread* jt) {\n@@ -452,1 +427,1 @@\n-  const ObjectSample* const last = ObjectSampler::sampler()->last();\n+  ObjectSample* const last = ObjectSampler::sampler()->last();\n@@ -455,4 +430,1 @@\n-  if (writer.has_data()) {\n-    save_type_set_blob(writer);\n-  }\n-  install_type_set_blobs();\n+  JfrReferenceCountedStorage::install(last, ObjectSampler::sampler()->last_resolved());\n@@ -461,9 +433,0 @@\n-\n-\/\/ This routine does NOT have exclusive access to the sampler instance on entry.\n-void ObjectSampleCheckpoint::on_type_set_unload(JfrCheckpointWriter& writer) {\n-  assert(LeakProfiler::is_running(), \"invariant\");\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  if (writer.has_data() && ObjectSampler::has_unresolved_entry()) {\n-    save_type_set_blob(writer);\n-  }\n-}\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":40,"deletions":77,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,1 @@\n-  static void on_type_set(JfrCheckpointWriter& writer);\n-  static void on_type_set_unload(JfrCheckpointWriter& writer);\n+  static void on_type_set(JavaThread* jt);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,1 +236,1 @@\n-  void set_type_set(const JfrBlobHandle& ref) {\n+  void install_type_set(const JfrBlobHandle& ref) {\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSample.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp\"\n@@ -592,2 +593,3 @@\n-  JfrDeprecationManager::on_type_set(leakp_writer, nullptr, thread);\n-  \/\/ We placed a blob in the Deprecated subsystem by moving the information\n+  JfrAddRefCountedBlob add_blob(leakp_writer);\n+  JfrDeprecationManager::on_type_set(nullptr, thread);\n+  \/\/ We placed a blob in the TypeSetBlobManager subsystem by moving the information\n@@ -616,0 +618,1 @@\n+    JfrAddRefCountedBlob add_blob(leakp_writer);\n@@ -617,1 +620,1 @@\n-      ObjectSampleCheckpoint::on_type_set(leakp_writer);\n+      ObjectSampleCheckpoint::on_type_set(thread);\n@@ -619,2 +622,1 @@\n-    \/\/ Place this call after ObjectSampleCheckpoint::on_type_set.\n-    JfrDeprecationManager::on_type_set(leakp_writer, _chunkwriter, thread);\n+    JfrDeprecationManager::on_type_set(_chunkwriter, thread);\n@@ -629,4 +631,1 @@\n-  if (LeakProfiler::is_running()) {\n-    ObjectSampleCheckpoint::on_type_set_unload(writer);\n-  }\n-  JfrDeprecationManager::on_type_set_unload(writer);\n+  JfrAddRefCountedBlob add_blob(writer, false \/* move *\/, false \/* reset *\/);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  friend class JfrAddRefCountedBlob;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/leakprofiler\/sampling\/objectSampler.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp\"\n+#include \"jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp\"\n+#include \"jfr\/support\/jfrDeprecationManager.hpp\"\n+\n+\/\/ Currently only two subsystems use type set blobs. Save a blob only if either has an unresolved entry.\n+static inline bool save_blob_predicate() {\n+  return JfrDeprecationManager::has_unresolved_entry() || ObjectSampler::has_unresolved_entry();\n+}\n+\n+JfrAddRefCountedBlob::JfrAddRefCountedBlob(JfrCheckpointWriter& writer, bool move \/* true *\/, bool reset \/* true *\/) : _reset(reset) {\n+  if (writer.has_data()) {\n+    if (save_blob_predicate()) {\n+      JfrReferenceCountedStorage::save_blob(writer, move);\n+    } else if (move) {\n+      writer.cancel();\n+    }\n+  }\n+  DEBUG_ONLY(if (reset) JfrReferenceCountedStorage::set_scope();)\n+}\n+\n+JfrAddRefCountedBlob::~JfrAddRefCountedBlob() {\n+  if (_reset) {\n+    JfrReferenceCountedStorage::reset();\n+  }\n+}\n+\n+JfrBlobHandle JfrReferenceCountedStorage::_type_sets = JfrBlobHandle();\n+DEBUG_ONLY(bool JfrReferenceCountedStorage::_scope = false;)\n+\n+void JfrReferenceCountedStorage::save_blob(JfrCheckpointWriter& writer, bool move \/* false *\/) {\n+  assert(writer.has_data(), \"invariant\");\n+  const JfrBlobHandle blob = move ? writer.move() : writer.copy();\n+  if (_type_sets.valid()) {\n+    _type_sets->set_next(blob);\n+    return;\n+  }\n+  _type_sets = blob;\n+}\n+\n+void JfrReferenceCountedStorage::reset() {\n+  assert(_scope, \"invariant\");\n+  if (_type_sets.valid()) {\n+    _type_sets = JfrBlobHandle();\n+  }\n+  DEBUG_ONLY(_scope = false;)\n+}\n+\n+#ifdef ASSERT\n+void JfrReferenceCountedStorage::set_scope() {\n+  assert(!_scope, \"invariant\");\n+  _scope = true;\n+}\n+#endif\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrReferenceCountedStorage.cpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_STORAGE_JFRREFERENCECOUNTEDSTORAGE_HPP\n+#define SHARE_JFR_RECORDER_STORAGE_JFRREFERENCECOUNTEDSTORAGE_HPP\n+\n+#include \"jfr\/utilities\/jfrBlob.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class JfrCheckpointWriter;\n+\n+\/\/ RAII helper class for adding blobs to the storage.\n+class JfrAddRefCountedBlob : public StackObj {\n+ private:\n+  bool _reset;\n+ public:\n+  JfrAddRefCountedBlob(JfrCheckpointWriter& writer, bool move = true, bool reset = true);\n+  ~JfrAddRefCountedBlob();\n+};\n+\n+\/\/ The debug aid 'scope' implies the proper RAII save construct is placed on stack.\n+\/\/ This is a necessary condition for installing reference counted storage to nodes.\n+class JfrReferenceCountedStorage : AllStatic {\n+  friend class JfrAddRefCountedBlob;\n+ private:\n+  static JfrBlobHandle _type_sets; \/\/ linked-list of blob handles saved during epoch.\n+  DEBUG_ONLY(static bool _scope;)\n+\n+  static void save_blob(JfrCheckpointWriter& writer, bool move = false);\n+  static void reset();\n+  DEBUG_ONLY(static void set_scope();)\n+\n+ public:\n+  template <typename T>\n+  static void install(T* node, const T* end) {\n+    assert(_scope, \"invariant\");\n+    if (_type_sets.valid()) {\n+      while (node != end) {\n+        node->install_type_set(_type_sets);\n+        node = node->next();\n+      }\n+    }\n+  }\n+};\n+\n+#endif \/\/ SHARE_JFR_RECORDER_STORAGE_JFRREFERENCECOUNTEDSTORAGE_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,2 +119,2 @@\n-JfrDeprecatedEventWriter::JfrDeprecatedEventWriter(JfrChunkWriter& cw, bool stacktrace) :\n-  _now(JfrTicks::now()),_cw(cw), _for_removal(only_for_removal()), _stacktrace(stacktrace), _did_write(false) {}\n+JfrDeprecatedEventWriter::JfrDeprecatedEventWriter(JfrChunkWriter& cw, JfrCheckpointWriter& tsw, bool stacktrace) :\n+  _now(JfrTicks::now()),_cw(cw), _tsw(tsw), _for_removal(only_for_removal()), _stacktrace(stacktrace) {}\n@@ -144,0 +144,7 @@\n+static void write_type_set(const JfrDeprecatedEdge* edge, JfrCheckpointWriter& tsw) {\n+  if (!edge->has_type_set()) {\n+    return;\n+  }\n+  edge->type_set()->exclusive_write(tsw);\n+}\n+\n@@ -149,3 +156,11 @@\n-  write_event(edge, _cw,_now, _stacktrace);\n-  if (!_did_write) {\n-    _did_write = true;\n+  write_event(edge, _cw, _now, _stacktrace);\n+  write_type_set(edge, _tsw);\n+  return true;\n+}\n+\n+JfrDeprecatedEventClear::JfrDeprecatedEventClear() {}\n+\n+bool JfrDeprecatedEventClear::process(const JfrDeprecatedEdge* edge) {\n+  assert(edge != nullptr, \"invariant\");\n+  if (!edge->has_type_set()) {\n+    return true;\n@@ -153,0 +168,1 @@\n+  edge->type_set()->reset_write_state();\n@@ -155,0 +171,1 @@\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationEventWriter.cpp","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+  JfrCheckpointWriter& _tsw;\n@@ -61,1 +62,0 @@\n-  bool _did_write;\n@@ -63,2 +63,7 @@\n-  JfrDeprecatedEventWriter(JfrChunkWriter& cw, bool stacktrace);\n-  bool did_write() const { return _did_write; }\n+  JfrDeprecatedEventWriter(JfrChunkWriter& cw, JfrCheckpointWriter& tsw, bool stacktrace);\n+  bool process(const JfrDeprecatedEdge* edge);\n+};\n+\n+class JfrDeprecatedEventClear : public StackObj {\n+ public:\n+  JfrDeprecatedEventClear();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationEventWriter.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp\"\n@@ -69,0 +70,1 @@\n+  _type_set(),\n@@ -97,0 +99,14 @@\n+bool JfrDeprecatedEdge::has_type_set() const {\n+  return _type_set.valid();\n+}\n+\n+const JfrBlobHandle& JfrDeprecatedEdge::type_set() const {\n+  assert(has_type_set(), \"invariant\");\n+  return _type_set;\n+}\n+\n+void JfrDeprecatedEdge::install_type_set(const JfrBlobHandle& type_set) {\n+  assert(!has_type_set(), \"invariant\");\n+  _type_set = type_set;\n+}\n+\n@@ -101,1 +117,1 @@\n-static DeprecatedEdgeList _resolved_list; \/\/ Fully resolved edges (event and stacktrace blobs).\n+static DeprecatedEdgeList _resolved_list; \/\/ Fully resolved edges (event, stacktrace and typeset blobs).\n@@ -228,4 +244,0 @@\n-void JfrDeprecationManager::on_level_setting_update(int64_t new_level) {\n-  JfrDeprecatedEventWriterState::on_level_setting_update(new_level);\n-}\n-\n@@ -273,0 +285,17 @@\n+inline DeprecatedEdgeList::NodePtr pending_head() {\n+  return Atomic::load(&_pending_head);\n+}\n+\n+\/\/ The test for a pending head can be read concurrently from a thread doing class unloading.\n+inline static bool has_pending_head() {\n+  return pending_head() != nullptr;\n+}\n+\n+inline static bool no_pending_head() {\n+  return !has_pending_head();\n+}\n+\n+inline static void set_pending_head(DeprecatedEdgeList::NodePtr head) {\n+  Atomic::store(&_pending_head, head);\n+}\n+\n@@ -284,2 +313,2 @@\n-    if (_pending_head == nullptr) {\n-      _pending_head = edge;\n+    if (no_pending_head()) {\n+      set_pending_head(edge);\n@@ -292,2 +321,4 @@\n-void JfrDeprecationManager::prepare_type_set(JavaThread* jt) {\n-  _pending_head = nullptr;\n+\/\/ Resets the pending head and tail.\n+\/\/ Resets blob write states for nodes on the resolved list, dirtied in the previous epoch.\n+static void reset_type_set_blobs() {\n+  set_pending_head(nullptr);\n@@ -295,0 +326,8 @@\n+  if (_resolved_list.is_nonempty()) {\n+    JfrDeprecatedEventClear clear;\n+    _resolved_list.iterate(clear);\n+  }\n+}\n+\n+void JfrDeprecationManager::prepare_type_set(JavaThread* jt) {\n+  reset_type_set_blobs();\n@@ -300,1 +339,1 @@\n-    assert(_pending_head != nullptr, \"invariant\");\n+    assert(has_pending_head(), \"invariant\");\n@@ -306,1 +345,1 @@\n-    _resolved_list.add_list(_pending_head);\n+    _resolved_list.add_list(pending_head());\n@@ -312,21 +351,2 @@\n-\/\/ A linked-list of blob handles.\n-static JfrBlobHandle type_set_blobs;\n-\n-static inline void write_type_set_blobs(JfrCheckpointWriter& writer) {\n-  type_set_blobs->write(writer);\n-}\n-\n-static void save_type_set_blob(JfrCheckpointWriter& writer, bool copy = false) {\n-  assert(writer.has_data(), \"invariant\");\n-  const JfrBlobHandle blob = copy ? writer.copy() : writer.move();\n-  if (type_set_blobs.valid()) {\n-    type_set_blobs->set_next(blob);\n-  } else {\n-    type_set_blobs = blob;\n-  }\n-}\n-\n-void JfrDeprecationManager::on_type_set_unload(JfrCheckpointWriter& writer) {\n-  if (writer.has_data()) {\n-    save_type_set_blob(writer, true);\n-  }\n+bool JfrDeprecationManager::has_unresolved_entry() {\n+  return _list.is_nonempty() || has_pending_head() || _pending_list.is_nonempty();\n@@ -339,1 +359,1 @@\n-static inline bool write_events(JfrChunkWriter& cw) {\n+static inline void write_events(JfrChunkWriter& cw, Thread* thread, bool on_error) {\n@@ -341,1 +361,2 @@\n-  JfrDeprecatedEventWriter ebw(cw, has_stacktrace());\n+  JfrCheckpointWriter type_set_writer(!on_error, thread, false);\n+  JfrDeprecatedEventWriter ebw(cw, type_set_writer, has_stacktrace());\n@@ -343,1 +364,0 @@\n-  return ebw.did_write();\n@@ -352,9 +372,3 @@\n-static inline void write_type_sets(Thread* thread, bool on_error) {\n-  JfrCheckpointWriter writer(!on_error, thread, false);\n-  write_type_set_blobs(writer);\n-}\n-\n-\/\/ First, we consolidate all stacktrace blobs into a single TYPE_STACKTRACE checkpoint and serialize it to the chunk.\n-\/\/ Secondly, we serialize all events to the chunk.\n-\/\/ Thirdly, the type set blobs are written into the JfrCheckpoint system, to be serialized to the chunk\n-\/\/ just after we return from here.\n+\/\/ First, we consolidate all stack trace blobs into a single TYPE_STACKTRACE checkpoint\n+\/\/ and serialize it to the chunk. Then, all events are serialized, and unique type set blobs\n+\/\/ written into the JfrCheckpoint system to be serialized to the chunk upon return.\n@@ -366,3 +380,1 @@\n-    if (write_events(cw)) {\n-      write_type_sets(thread, on_error);\n-    }\n+    write_events(cw, thread, on_error);\n@@ -372,1 +384,1 @@\n-void JfrDeprecationManager::on_type_set(JfrCheckpointWriter& writer, JfrChunkWriter* cw, Thread* thread) {\n+void JfrDeprecationManager::on_type_set(JfrChunkWriter* cw, Thread* thread) {\n@@ -374,4 +386,4 @@\n-  if (_pending_head != nullptr) {\n-    save_type_set_blob(writer);\n-  } else {\n-    writer.cancel();\n+  if (has_pending_head()) {\n+    assert(_pending_tail != nullptr, \"invariant\");\n+    \/\/ Install type set blobs for the pending, i.e. unresolved nodes.\n+    JfrReferenceCountedStorage::install(pending_head(), _pending_tail->next());\n@@ -383,0 +395,4 @@\n+\n+void JfrDeprecationManager::on_level_setting_update(int64_t new_level) {\n+  JfrDeprecatedEventWriterState::on_level_setting_update(new_level);\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.cpp","additions":69,"deletions":53,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+  JfrBlobHandle _type_set;\n@@ -61,1 +62,1 @@\n-  const JfrDeprecatedEdge* next() const { return _next; }\n+  JfrDeprecatedEdge* next() const { return _next; }\n@@ -71,0 +72,4 @@\n+  bool has_type_set() const;\n+  const JfrBlobHandle& type_set() const;\n+  void install_type_set(const JfrBlobHandle& type_set);\n+\n@@ -92,2 +97,1 @@\n-  static void on_type_set(JfrCheckpointWriter& writer, JfrChunkWriter* cw, Thread* thread);\n-  static void on_type_set_unload(JfrCheckpointWriter& writer);\n+  static void on_type_set(JfrChunkWriter* cw, Thread* thread);\n@@ -97,0 +101,1 @@\n+  static bool has_unresolved_entry();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"}]}