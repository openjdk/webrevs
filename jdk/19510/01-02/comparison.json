{"files":[{"patch":"@@ -36,1 +36,0 @@\n-#include \"jfr\/recorder\/checkpoint\/types\/jfrTypeSetBlobManager.hpp\"\n@@ -40,0 +39,1 @@\n+#include \"jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp\"\n@@ -430,1 +430,1 @@\n-  JfrTypeSetBlobManager::install(last, ObjectSampler::sampler()->last_resolved());\n+  JfrReferenceCountedStorage::install(last, ObjectSampler::sampler()->last_resolved());\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"jfr\/recorder\/checkpoint\/types\/jfrTypeSetBlobManager.hpp\"\n@@ -41,0 +40,1 @@\n+#include \"jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp\"\n@@ -593,1 +593,1 @@\n-  JfrSaveTypeSetBlob save_blob(leakp_writer);\n+  JfrAddRefCountedBlob add_blob(leakp_writer);\n@@ -618,1 +618,1 @@\n-    JfrSaveTypeSetBlob save_blob(leakp_writer);\n+    JfrAddRefCountedBlob add_blob(leakp_writer);\n@@ -631,1 +631,1 @@\n-  JfrSaveTypeSetBlob save_blob(writer, false \/* move *\/, false \/* reset *\/);\n+  JfrAddRefCountedBlob add_blob(writer, false \/* move *\/, false \/* reset *\/);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  friend class JfrAddRefCountedBlob;\n@@ -59,1 +60,0 @@\n-  friend class JfrSaveTypeSetBlob;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"jfr\/leakprofiler\/sampling\/objectSampler.hpp\"\n-#include \"jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp\"\n-#include \"jfr\/recorder\/checkpoint\/types\/jfrTypeSetBlobManager.hpp\"\n-#include \"jfr\/support\/jfrDeprecationManager.hpp\"\n-\n-\/\/ Currently only two subsystems use type set blobs. Save a blob only if either has an unresolved entry.\n-static inline bool save_blob_predicate() {\n-  return JfrDeprecationManager::has_unresolved_entry() || ObjectSampler::has_unresolved_entry();\n-}\n-\n-JfrSaveTypeSetBlob::JfrSaveTypeSetBlob(JfrCheckpointWriter& writer, bool move \/* true *\/, bool reset \/* true *\/) : _reset(reset) {\n-  if (writer.has_data()) {\n-    if (save_blob_predicate()) {\n-      JfrTypeSetBlobManager::save_blob(writer, move);\n-    } else if (move) {\n-      writer.cancel();\n-    }\n-  }\n-  DEBUG_ONLY(if (reset) JfrTypeSetBlobManager::set_scope();)\n-}\n-\n-JfrSaveTypeSetBlob::~JfrSaveTypeSetBlob() {\n-  if (_reset) {\n-    JfrTypeSetBlobManager::reset();\n-  }\n-}\n-\n-JfrBlobHandle JfrTypeSetBlobManager::_type_sets = JfrBlobHandle();\n-DEBUG_ONLY(bool JfrTypeSetBlobManager::_scope = false;)\n-\n-void JfrTypeSetBlobManager::save_blob(JfrCheckpointWriter& writer, bool move \/* false *\/) {\n-  assert(writer.has_data(), \"invariant\");\n-  const JfrBlobHandle blob = move ? writer.move() : writer.copy();\n-  if (_type_sets.valid()) {\n-    _type_sets->set_next(blob);\n-    return;\n-  }\n-  _type_sets = blob;\n-}\n-\n-void JfrTypeSetBlobManager::reset() {\n-  assert(_scope, \"invariant\");\n-  if (_type_sets.valid()) {\n-    _type_sets = JfrBlobHandle();\n-  }\n-  DEBUG_ONLY(_scope = false;)\n-}\n-\n-#ifdef ASSERT\n-void JfrTypeSetBlobManager::set_scope() {\n-  assert(!_scope, \"invariant\");\n-  _scope = true;\n-}\n-#endif\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetBlobManager.cpp","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_JFR_RECORDER_CHECKPOINT_TYPES_JFRTYPESETBLOBMANAGER_HPP\n-#define SHARE_JFR_RECORDER_CHECKPOINT_TYPES_JFRTYPESETBLOBMANAGER_HPP\n-\n-#include \"jfr\/utilities\/jfrBlob.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-class JfrCheckpointWriter;\n-\n-\/\/ RAII helper class for saving type set blobs.\n-class JfrSaveTypeSetBlob : public StackObj {\n- private:\n-  bool _reset;\n- public:\n-  JfrSaveTypeSetBlob(JfrCheckpointWriter& writer, bool move = true, bool reset = true);\n-  ~JfrSaveTypeSetBlob();\n-};\n-\n-\/\/ The debug aid 'scope' implies the proper RAII save construct on stack.\n-\/\/ This is a necessary condition for installing type sets to nodes.\n-class JfrTypeSetBlobManager : AllStatic {\n-  friend class JfrSaveTypeSetBlob;\n- private:\n-  static JfrBlobHandle _type_sets; \/\/ linked-list of type set blob handles saved during epoch.\n-  DEBUG_ONLY(static bool _scope;)\n-\n-  static void save_blob(JfrCheckpointWriter& writer, bool move = false);\n-  static void reset();\n-  DEBUG_ONLY(static void set_scope();)\n-\n- public:\n-  template <typename T>\n-  static void install(T* node, const T* end) {\n-    assert(_scope, \"invariant\");\n-    if (_type_sets.valid()) {\n-      while (node != end) {\n-        node->install_type_set(_type_sets);\n-        node = node->next();\n-      }\n-    }\n-  }\n-};\n-\n-#endif \/\/ SHARE_JFR_RECORDER_CHECKPOINT_TYPES_JFRTYPESETBLOBMANAGER_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetBlobManager.hpp","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/leakprofiler\/sampling\/objectSampler.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp\"\n+#include \"jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp\"\n+#include \"jfr\/support\/jfrDeprecationManager.hpp\"\n+\n+\/\/ Currently only two subsystems use type set blobs. Save a blob only if either has an unresolved entry.\n+static inline bool save_blob_predicate() {\n+  return JfrDeprecationManager::has_unresolved_entry() || ObjectSampler::has_unresolved_entry();\n+}\n+\n+JfrAddRefCountedBlob::JfrAddRefCountedBlob(JfrCheckpointWriter& writer, bool move \/* true *\/, bool reset \/* true *\/) : _reset(reset) {\n+  if (writer.has_data()) {\n+    if (save_blob_predicate()) {\n+      JfrReferenceCountedStorage::save_blob(writer, move);\n+    } else if (move) {\n+      writer.cancel();\n+    }\n+  }\n+  DEBUG_ONLY(if (reset) JfrReferenceCountedStorage::set_scope();)\n+}\n+\n+JfrAddRefCountedBlob::~JfrAddRefCountedBlob() {\n+  if (_reset) {\n+    JfrReferenceCountedStorage::reset();\n+  }\n+}\n+\n+JfrBlobHandle JfrReferenceCountedStorage::_type_sets = JfrBlobHandle();\n+DEBUG_ONLY(bool JfrReferenceCountedStorage::_scope = false;)\n+\n+void JfrReferenceCountedStorage::save_blob(JfrCheckpointWriter& writer, bool move \/* false *\/) {\n+  assert(writer.has_data(), \"invariant\");\n+  const JfrBlobHandle blob = move ? writer.move() : writer.copy();\n+  if (_type_sets.valid()) {\n+    _type_sets->set_next(blob);\n+    return;\n+  }\n+  _type_sets = blob;\n+}\n+\n+void JfrReferenceCountedStorage::reset() {\n+  assert(_scope, \"invariant\");\n+  if (_type_sets.valid()) {\n+    _type_sets = JfrBlobHandle();\n+  }\n+  DEBUG_ONLY(_scope = false;)\n+}\n+\n+#ifdef ASSERT\n+void JfrReferenceCountedStorage::set_scope() {\n+  assert(!_scope, \"invariant\");\n+  _scope = true;\n+}\n+#endif\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrReferenceCountedStorage.cpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_STORAGE_JFRREFERENCECOUNTEDSTORAGE_HPP\n+#define SHARE_JFR_RECORDER_STORAGE_JFRREFERENCECOUNTEDSTORAGE_HPP\n+\n+#include \"jfr\/utilities\/jfrBlob.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class JfrCheckpointWriter;\n+\n+\/\/ RAII helper class for adding blobs to the storage.\n+class JfrAddRefCountedBlob : public StackObj {\n+ private:\n+  bool _reset;\n+ public:\n+  JfrAddRefCountedBlob(JfrCheckpointWriter& writer, bool move = true, bool reset = true);\n+  ~JfrAddRefCountedBlob();\n+};\n+\n+\/\/ The debug aid 'scope' implies the proper RAII save construct is placed on stack.\n+\/\/ This is a necessary condition for installing reference counted storage to nodes.\n+class JfrReferenceCountedStorage : AllStatic {\n+  friend class JfrAddRefCountedBlob;\n+ private:\n+  static JfrBlobHandle _type_sets; \/\/ linked-list of blob handles saved during epoch.\n+  DEBUG_ONLY(static bool _scope;)\n+\n+  static void save_blob(JfrCheckpointWriter& writer, bool move = false);\n+  static void reset();\n+  DEBUG_ONLY(static void set_scope();)\n+\n+ public:\n+  template <typename T>\n+  static void install(T* node, const T* end) {\n+    assert(_scope, \"invariant\");\n+    if (_type_sets.valid()) {\n+      while (node != end) {\n+        node->install_type_set(_type_sets);\n+        node = node->next();\n+      }\n+    }\n+  }\n+};\n+\n+#endif \/\/ SHARE_JFR_RECORDER_STORAGE_JFRREFERENCECOUNTEDSTORAGE_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"jfr\/recorder\/checkpoint\/types\/jfrTypeSetBlobManager.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp\"\n@@ -389,1 +389,1 @@\n-    JfrTypeSetBlobManager::install(pending_head(), _pending_tail->next());\n+    JfrReferenceCountedStorage::install(pending_head(), _pending_tail->next());\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}