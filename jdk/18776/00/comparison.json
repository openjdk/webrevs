{"files":[{"patch":"@@ -267,6 +267,6 @@\n-  if (last != sampler->last_resolved()) {\n-    ResourceMark rm;\n-    JfrKlassUnloading::sort();\n-    StackTraceBlobInstaller installer;\n-    iterate_samples(installer);\n-  }\n+  assert(last != nullptr, \"invariant\");\n+  assert(last != sampler->last_resolved(), \"invariant\");\n+  ResourceMark rm;\n+  JfrKlassUnloading::sort();\n+  StackTraceBlobInstaller installer;\n+  iterate_samples(installer);\n@@ -280,0 +280,3 @@\n+  if (!ObjectSampler::has_unresolved_entry()) {\n+    return;\n+  }\n@@ -425,2 +428,4 @@\n-  BlobInstaller installer;\n-  iterate_samples(installer);\n+  if (saved_type_set_blobs.valid()) {\n+    BlobInstaller installer;\n+    iterate_samples(installer);\n+  }\n@@ -439,0 +444,1 @@\n+\/\/ This routine has exclusive access to the sampler instance on entry.\n@@ -442,2 +448,8 @@\n-  const ObjectSample* last = ObjectSampler::sampler()->last();\n-  if (writer.has_data() && last != nullptr) {\n+  assert(ClassLoaderDataGraph_lock->owned_by_self(), \"invariant\");\n+  if (!ObjectSampler::has_unresolved_entry()) {\n+    return;\n+  }\n+  const ObjectSample* const last = ObjectSampler::sampler()->last();\n+  assert(last != nullptr, \"invariant\");\n+  assert(last != ObjectSampler::sampler()->last_resolved(), \"invariant\");\n+  if (writer.has_data()) {\n@@ -445,2 +457,0 @@\n-    install_type_set_blobs();\n-    ObjectSampler::sampler()->set_last_resolved(last);\n@@ -448,0 +458,2 @@\n+  install_type_set_blobs();\n+  ObjectSampler::sampler()->set_last_resolved(last);\n@@ -450,0 +462,1 @@\n+\/\/ This routine does NOT have exclusive access to the sampler instance on entry.\n@@ -452,1 +465,2 @@\n-  if (writer.has_data() && ObjectSampler::sampler()->last() != nullptr) {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  if (writer.has_data() && ObjectSampler::has_unresolved_entry()) {\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"jfr\/utilities\/jfrSignal.hpp\"\n@@ -62,0 +63,19 @@\n+\/\/ A notification mechanism to let class unloading determine if to save unloaded typesets.\n+static JfrSignal _unresolved_entry;\n+\n+static inline void signal_unresolved_entry() {\n+  _unresolved_entry.signal_if_not_set();\n+}\n+\n+static inline void clear_unresolved_entry() {\n+  _unresolved_entry.reset();\n+}\n+\n+static inline void signal_resolved() {\n+  clear_unresolved_entry();\n+}\n+\n+bool ObjectSampler::has_unresolved_entry() {\n+  return _unresolved_entry.is_signaled();\n+}\n+\n@@ -111,0 +131,2 @@\n+  clear_unresolved_entry();\n+  assert(!has_unresolved_entry(), \"invariant\");\n@@ -245,0 +267,1 @@\n+  signal_unresolved_entry();\n@@ -307,0 +330,1 @@\n+  signal_resolved();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+  static bool has_unresolved_entry();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,4 @@\n+  void reset() const {\n+    Atomic::release_store(&_signaled, false);\n+  }\n+\n@@ -44,0 +48,6 @@\n+  void signal_if_not_set() const {\n+    if (!is_signaled()) {\n+      signal();\n+    }\n+  }\n+\n@@ -46,1 +56,1 @@\n-      Atomic::release_store(&_signaled, false);\n+      reset();\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSignal.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"}]}