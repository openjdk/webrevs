{"files":[{"patch":"@@ -2691,0 +2691,1 @@\n+    \/\/ used by java.util.Vector\n@@ -2709,0 +2710,2 @@\n+        transient SynchronizedList<E> reversedView = null;\n+        transient final boolean isReversed;\n@@ -2710,0 +2713,1 @@\n+        \/\/ constructs a forward view, using 'this' as the mutex\n@@ -2713,0 +2717,1 @@\n+            this.isReversed = false;\n@@ -2714,0 +2719,2 @@\n+\n+        \/\/ constructs a forward view, using 'mutex' as the mutex\n@@ -2717,0 +2724,9 @@\n+            this.isReversed = false;\n+        }\n+\n+        \/\/ constructs the reversed view; first arg should be reversed view of backing list\n+        SynchronizedList(List<E> revList, Object mutex, SynchronizedList<E> forward) {\n+            super(revList, mutex);\n+            this.list = revList;\n+            this.reversedView = forward;\n+            this.isReversed = true;\n@@ -2727,1 +2743,0 @@\n-\n@@ -2740,1 +2755,0 @@\n-\n@@ -2747,1 +2761,0 @@\n-\n@@ -2751,1 +2764,0 @@\n-\n@@ -2755,1 +2767,0 @@\n-\n@@ -2759,1 +2770,0 @@\n-\n@@ -2766,2 +2776,0 @@\n-\n-        @Override\n@@ -2771,1 +2779,0 @@\n-        @Override\n@@ -2775,0 +2782,64 @@\n+        public void addFirst(E element) {\n+            synchronized (mutex) {list.addFirst(element);}\n+        }\n+        public void addLast(E element) {\n+            synchronized (mutex) {list.addLast(element);}\n+        }\n+        public E getFirst() {\n+            synchronized (mutex) {return list.getFirst();}\n+        }\n+        public E getLast() {\n+            synchronized (mutex) {return list.getLast();}\n+        }\n+        public E removeFirst() {\n+            synchronized (mutex) {return list.removeFirst();}\n+        }\n+        public E removeLast() {\n+            synchronized (mutex) {return list.removeLast();}\n+        }\n+\n+        \/**\n+         * Reversed view handling. The reversedView field is transient\n+         * and is initialized to null upon construction of the wrapper\n+         * and upon deserialization. Reversed views are not serializable.\n+         * The reversed view is created on first call to the reversed()\n+         * method.\n+         *\n+         * There are four objects at play here:\n+         *\n+         * L = original list\n+         * Lr = reversed view of original list\n+         * S = synchronized forward wrapper: its backing list is L\n+         * Sr = synchronized reversed wrapper: its backing list is Lr\n+         *\n+         * The reversedView field of S points to Sr and vice versa.\n+         * This enables the reversed() method always to return the same\n+         * object, and for S.reversed().reversed() to return S. This isn't\n+         * strictly necessary, because all internal locking is done on S\n+         * (which is passed around as mutex). But in the case where the\n+         * client does external locking, it's good to minimize the number\n+         * of different instances. Note however that external locking on\n+         * the reversed wrapper Sr can't be made to work properly with\n+         * internal or external locking on the forward wrapper S. (Sublists\n+         * of a synchronized wrapper, reversed or not, have the same issue.)\n+         *\n+         * An alternative would be to have a ReversedSynchronizedList view class. However,\n+         * that would require two extra classes (one RandomAccess and one not) and it would\n+         * complicate the serialization story.\n+         *\/\n+        public List<E> reversed() {\n+            synchronized (mutex) {\n+                if (reversedView == null) {\n+                    reversedView = new SynchronizedList<>(list.reversed(), mutex, this);\n+                }\n+                return reversedView;\n+            }\n+        }\n+\n+        @java.io.Serial\n+        private void writeObject(ObjectOutputStream out) throws IOException {\n+            if (isReversed) {\n+                throw new java.io.NotSerializableException();\n+            }\n+            out.defaultWriteObject();\n+        }\n@@ -2811,0 +2882,13 @@\n+        SynchronizedRandomAccessList(List<E> list, Object mutex, SynchronizedList<E> forward) {\n+            super(list, mutex, forward);\n+        }\n+\n+        public List<E> reversed() {\n+            synchronized (mutex) {\n+                if (reversedView == null) {\n+                    reversedView = new SynchronizedRandomAccessList<>(list.reversed(), mutex, this);\n+                }\n+                return reversedView;\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":93,"deletions":9,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8351230\n+ * @library \/test\/lib\n+ * @build   jdk.test.lib.Utils\n+ * @run     main SyncListBash f\n+ * @run     main SyncListBash r\n+ * @summary Test that List's new SequencedCollection methods are properly\n+ *          synchronized on a synchronized list.\n+ *\/\n+\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.stream.*;\n+\n+import jdk.test.lib.Utils;\n+\n+public class SyncListBash {\n+    static final int LOOP_COUNT = 1000;\n+    static final int NUM_WORKERS = 4;\n+    static List<Integer> list;\n+\n+    \/**\n+     * Test for race conditions with synchronized lists. Several worker threads\n+     * add and remove elements from the front of the list, while the main thread\n+     * gets the last element. The last element should never change. However, if\n+     * the list isn't properly synchronized, getLast() might return the wrong\n+     * element or throw IndexOutOfBoundsException.\n+     *\n+     * On an unsynchronized list, this fails 200-500 out of 1000 times, so this\n+     * seems like a fairly reliable way to test for a race condition.\n+     *\n+     * @param args there must be one arg, \"f\" or \"r\", which determines whether the\n+     *             forward (original) list or reversed view of the list is tested\n+     * @throws InterruptedException if the main thread is interrupted\n+     *\/\n+    public static void main(String[] args) throws InterruptedException {\n+        int wrongElement = 0;\n+        int numExceptions = 0;\n+\n+        boolean reversed = switch (args[0]) {\n+            case \"f\" -> false;\n+            case \"r\" -> true;\n+            default -> throw new IllegalArgumentException();\n+        };\n+\n+        list = IntStream.range(0, 10)\n+                        .boxed()\n+                        .collect(Collectors.toCollection(ArrayList::new));\n+        list = Collections.synchronizedList(list);\n+        if (reversed)\n+            list = list.reversed();\n+        Integer expectedLast = list.getLast();\n+\n+        ExecutorService pool = Executors.newFixedThreadPool(NUM_WORKERS);\n+        for (int i = 0; i < NUM_WORKERS; i++)\n+            pool.submit(() -> {\n+                while (! Thread.currentThread().isInterrupted()) {\n+                    list.add(0, -1);\n+                    list.remove(0);\n+                }\n+            });\n+\n+        for (int i = 0; i < LOOP_COUNT; i++) {\n+            Thread.sleep(1L);\n+            try {\n+                Integer actualLast = list.getLast();\n+                if (! expectedLast.equals(actualLast)) {\n+                    ++wrongElement;\n+                }\n+            } catch (IndexOutOfBoundsException ioobe) {\n+                ++numExceptions;\n+            }\n+        }\n+\n+        pool.shutdownNow();\n+        pool.awaitTermination(Utils.adjustTimeout(60L), TimeUnit.SECONDS);\n+\n+        System.out.printf(\"LOOP_COUNT=%d wrongElement=%d numExceptions=%d%n\",\n+            LOOP_COUNT, wrongElement, numExceptions);\n+        if (wrongElement == 0 && numExceptions == 0) {\n+            System.out.println(\"Test passed.\");\n+        } else {\n+            throw new AssertionError(\"TEST FAILED!\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Collections\/SyncListBash.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,5 @@\n-    static SequencedCollection<String> ulist(List<String> list) {\n+    static List<String> sylist(List<String> list) {\n+        return Collections.synchronizedList(list);\n+    }\n+\n+    static List<String> ulist(List<String> list) {\n@@ -119,0 +123,1 @@\n+            new Object[] { \"SynchList\", sylist(new ArrayList<>(ORIGINAL)), ORIGINAL },\n@@ -142,0 +147,1 @@\n+            new Object[] { \"SynchList\", sylist(new ArrayList<>()), List.of() },\n@@ -158,1 +164,2 @@\n-            new Object[] { \"SimpleList\", new SimpleList<>(ORIGINAL), ORIGINAL }\n+            new Object[] { \"SimpleList\", new SimpleList<>(ORIGINAL), ORIGINAL },\n+            new Object[] { \"SynchList\", sylist(new ArrayList<>(ORIGINAL)), ORIGINAL }\n@@ -181,0 +188,1 @@\n+            new Object[] { \"SynchList\", sylist(new ArrayList<>(ORIGINAL)), ORIGINAL },\n@@ -197,0 +205,1 @@\n+            new Object[] { \"SynchList\", sylist(new ArrayList<>()), List.of() },\n@@ -212,0 +221,1 @@\n+            new Object[] { \"SynchList\", sylist(new ArrayList<>(ORIGINAL)), ORIGINAL },\n@@ -229,0 +239,1 @@\n+            new Object[] { \"SynchList\", sylist(new ArrayList<>(ORIGINAL)).reversed() },\n@@ -246,1 +257,2 @@\n-            new Object[] { \"SimpleSortedSet\", new SimpleSortedSet<>(ORIGINAL) }\n+            new Object[] { \"SimpleSortedSet\", new SimpleSortedSet<>(ORIGINAL) },\n+            new Object[] { \"SynchList\", sylist(new ArrayList<>(ORIGINAL)) }\n@@ -285,0 +297,14 @@\n+    \/\/ These Lists don't all implement RandomAccess; they're Lists that should be\n+    \/\/ tested for proper propagation of the RandomAccess markers.\n+    @DataProvider(name=\"randomAccessLists\")\n+    public Iterator<Object[]> randomAccessLists() {\n+        return Arrays.asList(\n+            new Object[] { \"ArrayList\", new ArrayList<>(ORIGINAL) },\n+            new Object[] { \"AsList\", Arrays.asList(ORIGINAL.toArray()) },\n+            new Object[] { \"COWAL\", new CopyOnWriteArrayList<>(ORIGINAL) },\n+            new Object[] { \"LinkedList\", new LinkedList<>(ORIGINAL) },\n+            new Object[] { \"ListOf\", ORIGINAL },\n+            new Object[] { \"SimpleList\", new SimpleList<>(ORIGINAL) }\n+        ).iterator();\n+    }\n+\n@@ -857,0 +883,18 @@\n+\n+    @Test\n+    public void testSynchListReversedAlwaysReturnsSameObject() {\n+        var list = sylist(ORIGINAL);\n+        var rev1 = list.reversed();\n+        var rev2 = list.reversed();\n+        assertSame(rev1, rev2);\n+    }\n+\n+    @Test(dataProvider=\"randomAccessLists\")\n+    public void testRandomAccess(String label, List<String> list) {\n+        assertEquals(list.reversed() instanceof RandomAccess, list instanceof RandomAccess);\n+\n+        \/\/ Collections.synchronizedList() preservation of RandomAccess is somewhat\n+        \/\/ tested by java\/util\/Collection\/MOAT.java but it might not have all these cases.\n+        assertEquals(sylist(list) instanceof RandomAccess, list instanceof RandomAccess);\n+        assertEquals(sylist(list).reversed() instanceof RandomAccess, sylist(list) instanceof RandomAccess);\n+    }\n","filename":"test\/jdk\/java\/util\/SequencedCollection\/Basic.java","additions":48,"deletions":4,"binary":false,"changes":52,"status":"modified"}]}