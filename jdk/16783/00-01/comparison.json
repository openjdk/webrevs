{"files":[{"patch":"@@ -864,1 +864,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libIterateMonitorWithDeadObjectTest.c libTestPsig.c exeGetCreatedJavaVMs.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libMonitorWithDeadObjectHelper.c libTestPsig.c exeGetCreatedJavaVMs.c\n@@ -1506,1 +1506,1 @@\n-  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libIterateMonitorWithDeadObjectTest += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libMonitorWithDeadObjectHelper += -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test IterateMonitorWithDeadObjectTest\n- * @summary This locks a monitor, GCs the object, and iterate and perform\n- *          various iteration and operations over this monitor.\n- * @requires os.family == \"linux\"\n- * @library \/testlibrary \/test\/lib\n- * @build IterateMonitorWithDeadObjectTest\n- * @run main\/native IterateMonitorWithDeadObjectTest\n- *\/\n-\n-import java.lang.management.ManagementFactory;\n-import java.lang.management.ThreadMXBean;\n-\n-public class IterateMonitorWithDeadObjectTest {\n-    public static native void runTestAndDetachThread();\n-    public static native void joinTestThread();\n-\n-    public static void dumpThreadsWithLockedMonitors() {\n-        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n-        threadBean.dumpAllThreads(true, false);\n-    }\n-\n-    static {\n-        System.loadLibrary(\"IterateMonitorWithDeadObjectTest\");\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        \/\/ Run the part of the test that causes the problematic monitor:\n-        \/\/ - Create an object\n-        \/\/ - Call MonitorEnter on the object to create a monitor\n-        \/\/ - Drop the last reference to the object\n-        \/\/ - GC to clear the weak reference to the object in the monitor\n-        \/\/ - Detach the thread - provoke previous bug\n-        \/\/ - Leave the thread un-joined\n-        runTestAndDetachThread();\n-\n-        System.out.println(\"Dumping threads with locked monitors\");\n-\n-        \/\/ After testIt has been called, there's an \"owned\" monitor with a\n-        \/\/ dead object. The thread dumping code didn't tolerate such a monitor,\n-        \/\/ so run a thread dump and make sure that it doesn't crash\/assert.\n-        dumpThreadsWithLockedMonitors();\n-\n-        System.out.println(\"Dumping threads with locked monitors done\");\n-\n-        joinTestThread();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/IterateMonitorWithDeadObjectTest.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test MonitorWithDeadObjectDetachThreadTest\n+ * @summary This test checks that ObjectMonitors with dead objects don't\n+            cause asserts, crashes, or failures when the owning thread\n+            is detached.\n+ * @requires os.family != \"windows\"\n+ * @library \/testlibrary \/test\/lib\n+ * @modules jdk.management\n+ * @run main\/native MonitorWithDeadObjectDetachThreadTest\n+ *\/\n+\n+public class MonitorWithDeadObjectDetachThreadTest {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Create an ObjectMonitor with a dead object from an\n+        \/\/ attached thread.\n+        MonitorWithDeadObjectHelper.createMonitorWithDeadObject();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorWithDeadObjectDetachThreadTest.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test MonitorWithDeadObjectDumpThreadsAfterDetachTest\n+ * @summary This test checks that ObjectMonitors with dead objects don't\n+            cause asserts, crashes, or failures when dumping threads\n+            after the owning thread has been detached.\n+ * @requires os.family != \"windows\"\n+ * @library \/testlibrary \/test\/lib\n+ * @modules jdk.management\n+ * @run main\/native MonitorWithDeadObjectDumpThreadsAfterDetachTest\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadMXBean;\n+\n+public class MonitorWithDeadObjectDumpThreadsAfterDetachTest {\n+    public static void dumpThreadsWithLockedMonitors() {\n+        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n+        threadBean.dumpAllThreads(true, false);\n+    }\n+\n+    public static void testBeforeJoin() {\n+        MonitorWithDeadObjectHelper.createMonitorWithDeadObjectNoJoin();\n+\n+        \/\/ After createMonitorWithDeadObjectNoJoin has been called, there's an\n+        \/\/ \"owned\" monitor with a\n+        \/\/ dead object. The thread dumping code didn't tolerate such a monitor,\n+        \/\/ so run a thread dump and make sure that it doesn't crash\/assert.\n+        dumpThreadsWithLockedMonitors();\n+\n+        MonitorWithDeadObjectHelper.joinTestThread();\n+    }\n+\n+    public static void testAfterJoin() {\n+        MonitorWithDeadObjectHelper.createMonitorWithDeadObjectNoJoin();\n+        MonitorWithDeadObjectHelper.joinTestThread();\n+\n+        \/\/ After createMonitorWithDeadObjectNoJoin has been called, there's an\n+        \/\/ \"owned\" monitor with a\n+        \/\/ dead object. The thread dumping code didn't tolerate such a monitor,\n+        \/\/ so run a thread dump and make sure that it doesn't crash\/assert.\n+        dumpThreadsWithLockedMonitors();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        testBeforeJoin();\n+        testAfterJoin();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorWithDeadObjectDumpThreadsAfterDetachTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test MonitorWithDeadObjectDumpThreadsBeforeDetachTest\n+ * @summary This test checks that ObjectMonitors with dead objects don't\n+            cause asserts, crashes, or failures when threads are dumped\n+            before the thread has been detached.\n+ * @requires os.family != \"windows\"\n+ * @library \/testlibrary \/test\/lib\n+ * @modules jdk.management\n+ * @run main\/native MonitorWithDeadObjectDumpThreadsBeforeDetachTest\n+ *\/\n+\n+public class MonitorWithDeadObjectDumpThreadsBeforeDetachTest {\n+    public static void main(String[] args) throws Exception {\n+        MonitorWithDeadObjectHelper.createMonitorWithDeadObjectDumpThreadsBeforeDetach();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorWithDeadObjectDumpThreadsBeforeDetachTest.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public class MonitorWithDeadObjectHelper {\n+    public static native void createMonitorWithDeadObject();\n+    public static native void createMonitorWithDeadObjectNoJoin();\n+    public static native void createMonitorWithDeadObjectDumpThreadsBeforeDetach();\n+\n+    public static native void joinTestThread();\n+\n+    static {\n+        System.loadLibrary(\"MonitorWithDeadObjectHelper\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorWithDeadObjectHelper.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -1,142 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include <stdlib.h>\n-#include <pthread.h>\n-#include <stdio.h>\n-#include <unistd.h>\n-\n-#define die(x) do { printf(\"%s:%s\\n\",x , __func__); perror(x); exit(EXIT_FAILURE); } while (0)\n-\n-#ifndef _Included_IterateMonitorWithDeadObjectTest\n-#define _Included_IterateMonitorWithDeadObjectTest\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-static JavaVM* jvm;\n-static pthread_t attacher;\n-\n-static jobject create_object(JNIEnv* env) {\n-  jclass clazz = (*env)->FindClass(env, \"java\/lang\/Object\");\n-  if (clazz == 0) die(\"No class\");\n-\n-  jmethodID constructor = (*env)->GetMethodID(env, clazz, \"<init>\", \"()V\");\n-  if (constructor == 0) die(\"No constructor\");\n-\n-  return (*env)->NewObject(env, clazz, constructor);\n-}\n-\n-static void system_gc(JNIEnv* env) {\n-  jclass clazz = (*env)->FindClass(env, \"java\/lang\/System\");\n-  if (clazz == 0) die(\"No class\");\n-\n-  jmethodID method = (*env)->GetStaticMethodID(env, clazz, \"gc\", \"()V\");\n-  if (method == 0) die(\"No method\");\n-\n-  (*env)->CallStaticVoidMethod(env, clazz, method);\n-}\n-\n-static void thread_dump_with_locked_monitors(JNIEnv* env) {\n-  jclass ManagementFactoryClass = (*env)->FindClass(env, \"java\/lang\/management\/ManagementFactory\");\n-  if (ManagementFactoryClass == 0) die(\"No ManagementFactory class\");\n-\n-  jmethodID getThreadMXBeanMethod = (*env)->GetStaticMethodID(env, ManagementFactoryClass, \"getThreadMXBean\", \"()Ljava\/lang\/management\/ThreadMXBean;\");\n-  if (getThreadMXBeanMethod == 0) die(\"No getThreadMXBean method\");\n-\n-  jobject threadBean = (*env)->CallStaticObjectMethod(env, ManagementFactoryClass, getThreadMXBeanMethod);\n-\n-  jclass ThreadMXBeanClass = (*env)->FindClass(env, \"java\/lang\/management\/ThreadMXBean\");\n-  if (ThreadMXBeanClass == 0) die(\"No ThreadMXBean class\");\n-\n-  jmethodID dumpAllThreadsMethod = (*env)->GetMethodID(env, ThreadMXBeanClass, \"dumpAllThreads\", \"(ZZ)[Ljava\/lang\/management\/ThreadInfo;\");\n-  if (dumpAllThreadsMethod == 0) die(\"No dumpAllThreads method\");\n-\n-  \/\/ The 'lockedMonitors == true' is what triggers the collection of the monitor with the dead object.\n-  (*env)->CallObjectMethod(env, ThreadMXBeanClass, dumpAllThreadsMethod, threadBean, JNI_TRUE \/* lockedMonitors *\/, JNI_FALSE \/* lockedSynchronizers*\/);\n-}\n-\n-static void* do_test() {\n-  JNIEnv* env;\n-  int res = (*jvm)->AttachCurrentThread(jvm, (void**)&env, NULL);\n-  if (res != JNI_OK) die(\"AttachCurrentThread\");\n-\n-  jobject obj = create_object(env);\n-\n-  if ((*env)->MonitorEnter(env, obj) != 0) die(\"MonitorEnter\");\n-\n-  \/\/ Drop the last strong reference to the object associated with the monitor.\n-  \/\/ The monitor only keeps a weak reference to the object.\n-  (*env)->DeleteLocalRef(env, obj);\n-\n-  \/\/ Let the GC clear the weak reference to the object.\n-  system_gc(env);\n-\n-  \/\/ Perform a thread dump that checks for all thread's monitors.\n-  \/\/ That code didn't expect the monitor iterators to return monitors\n-  \/\/ with dead objects and therefore asserted\/crashed.\n-  thread_dump_with_locked_monitors(env);\n-\n-  \/\/ DetachCurrenThread will try to unlock held monitors. This has been a\n-  \/\/ source of at least two bugs:\n-  \/\/ - When the object reference in the monitor was made weak, the code\n-  \/\/   didn't unlock the monitor, leaving it lingering in the system.\n-  \/\/ - When the monitor iterator API was rewritten the code was changed to\n-  \/\/   assert that we didn't have \"owned\" monitors with dead objects. This\n-  \/\/   test provokes that situation and those asserts.\n-  if ((*jvm)->DetachCurrentThread(jvm) != JNI_OK) die(\"DetachCurrentThread\");\n-  pthread_exit(NULL);\n-\n-  return NULL;\n-}\n-\n-\/*\n- * Class:     IterateMonitorWithDeadObjectTest\n- * Method:    runTestAndDetachThread\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL Java_IterateMonitorWithDeadObjectTest_runTestAndDetachThread(JNIEnv* env, jclass jc) {\n-    pthread_attr_t attr;\n-    void* ret;\n-\n-    (*env)->GetJavaVM(env, &jvm);\n-\n-    if (pthread_attr_init(&attr) != 0) die(\"pthread_attr_init\");\n-    if (pthread_create(&attacher, &attr, do_test, NULL) != 0) die(\"pthread_create\");\n-}\n-\n-\/*\n- * Class:     IterateMonitorWithDeadObjectTest\n- * Method:    joinTestThread\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL Java_IterateMonitorWithDeadObjectTest_joinTestThread(JNIEnv* env, jclass jc) {\n-    void* ret;\n-    if (pthread_join(attacher, &ret) != 0) die(\"pthread_join\");\n-}\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-#endif\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/libIterateMonitorWithDeadObjectTest.c","additions":0,"deletions":142,"binary":false,"changes":142,"status":"deleted"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+\n+#define die(x) do { printf(\"%s:%s\\n\",x , __func__); perror(x); exit(EXIT_FAILURE); } while (0)\n+\n+#ifndef _Included_MonitorWithDeadObjectHelper\n+#define _Included_MonitorWithDeadObjectHelper\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+static JavaVM* jvm;\n+static pthread_t attacher;\n+\n+static void check_exception(JNIEnv* env, const char* msg) {\n+  if ((*env)->ExceptionCheck(env)) {\n+    fprintf(stderr, \"Error: %s\", msg);\n+    exit(-1);\n+  }\n+}\n+\n+#define check(env, what, msg)                      \\\n+  check_exception((env), (msg));                   \\\n+  do {                                             \\\n+    if ((what) == 0) {                             \\\n+      fprintf(stderr, #what \"is null: %s\", (msg)); \\\n+      exit(-2);                                    \\\n+    }                                              \\\n+  } while (0)\n+\n+static jobject create_object(JNIEnv* env) {\n+  jclass clazz = (*env)->FindClass(env, \"java\/lang\/Object\");\n+  check(env, clazz, \"No class\");\n+\n+  jmethodID constructor = (*env)->GetMethodID(env, clazz, \"<init>\", \"()V\");\n+  check(env, constructor, \"No constructor\");\n+\n+  jobject obj = (*env)->NewObject(env, clazz, constructor);\n+  check(env, constructor, \"No object\");\n+\n+  return obj;\n+}\n+\n+static void system_gc(JNIEnv* env) {\n+  jclass clazz = (*env)->FindClass(env, \"java\/lang\/System\");\n+  check(env, clazz, \"No class\");\n+\n+  jmethodID method = (*env)->GetStaticMethodID(env, clazz, \"gc\", \"()V\");\n+  check(env, method, \"No method\");\n+\n+  (*env)->CallStaticVoidMethod(env, clazz, method);\n+  check_exception(env, \"Calling System.gc()\");\n+}\n+\n+static void thread_dump_with_locked_monitors(JNIEnv* env) {\n+  jclass ManagementFactoryClass = (*env)->FindClass(env, \"java\/lang\/management\/ManagementFactory\");\n+  check(env, ManagementFactoryClass, \"No ManagementFactory class\");\n+\n+  jmethodID getThreadMXBeanMethod = (*env)->GetStaticMethodID(env, ManagementFactoryClass, \"getThreadMXBean\", \"()Ljava\/lang\/management\/ThreadMXBean;\");\n+  check(env, getThreadMXBeanMethod, \"No getThreadMXBean method\");\n+\n+  jobject threadBean = (*env)->CallStaticObjectMethod(env, ManagementFactoryClass, getThreadMXBeanMethod);\n+  check(env, threadBean, \"Calling getThreadMXBean()\");\n+\n+  jclass ThreadMXBeanClass = (*env)->FindClass(env, \"java\/lang\/management\/ThreadMXBean\");\n+  check(env, ThreadMXBeanClass, \"No ThreadMXBean class\");\n+\n+  jmethodID dumpAllThreadsMethod = (*env)->GetMethodID(env, ThreadMXBeanClass, \"dumpAllThreads\", \"(ZZ)[Ljava\/lang\/management\/ThreadInfo;\");\n+  check(env, dumpAllThreadsMethod, \"No dumpAllThreads method\");\n+\n+  \/\/ The 'lockedMonitors == true' is what causes the monitor with a dead object to be examined.\n+  jobject array = (*env)->CallObjectMethod(env, threadBean, dumpAllThreadsMethod, JNI_TRUE \/* lockedMonitors *\/, JNI_FALSE \/* lockedSynchronizers*\/);\n+  check(env, array, \"Calling dumpAllThreads(true, false)\");\n+}\n+\n+static void create_monitor_with_dead_object(JNIEnv* env) {\n+  jobject obj = create_object(env);\n+\n+  if ((*env)->MonitorEnter(env, obj) != 0) die(\"MonitorEnter\");\n+\n+  \/\/ Drop the last strong reference to the object associated with the monitor.\n+  \/\/ The monitor only keeps a weak reference to the object.\n+  (*env)->DeleteLocalRef(env, obj);\n+\n+  \/\/ Let the GC clear the weak reference to the object.\n+  system_gc(env);\n+}\n+\n+static void* create_monitor_with_dead_object_in_thread() {\n+  JNIEnv* env;\n+  int res = (*jvm)->AttachCurrentThread(jvm, (void**)&env, NULL);\n+  if (res != JNI_OK) die(\"AttachCurrentThread\");\n+\n+  \/\/ Make the correct incantation to create a monitor with a dead object.\n+  create_monitor_with_dead_object(env);\n+\n+  \/\/ DetachCurrenThread will try to unlock held monitors. This has been a\n+  \/\/ source of at least two bugs:\n+  \/\/ - When the object reference in the monitor was cleared, the monitor\n+  \/\/   iterator code would skip it, preventing it from being unlocked when\n+  \/\/   the owner thread detached, leaving it lingering in the system.\n+  \/\/ - When the monitor iterator API was rewritten the code was changed to\n+  \/\/   assert that we didn't have \"owned\" monitors with dead objects. This\n+  \/\/   test provokes that situation and that asserts.\n+  if ((*jvm)->DetachCurrentThread(jvm) != JNI_OK) die(\"DetachCurrentThread\");\n+  pthread_exit(NULL);\n+\n+  return NULL;\n+}\n+\n+static void* create_monitor_with_dead_object_and_dump_threads_in_thread() {\n+  JNIEnv* env;\n+  int res = (*jvm)->AttachCurrentThread(jvm, (void**)&env, NULL);\n+  if (res != JNI_OK) die(\"AttachCurrentThread\");\n+\n+  \/\/ Make the correct incantation to create a monitor with a dead object.\n+  create_monitor_with_dead_object(env);\n+\n+  \/\/ Perform a thread dump that checks for all thread's monitors.\n+  \/\/ That code didn't expect the monitor iterators to return monitors\n+  \/\/ with dead objects and therefore asserted\/crashed.\n+  thread_dump_with_locked_monitors(env);\n+\n+  if ((*jvm)->DetachCurrentThread(jvm) != JNI_OK) die(\"DetachCurrentThread\");\n+  pthread_exit(NULL);\n+\n+  return NULL;\n+}\n+\n+JNIEXPORT void JNICALL Java_MonitorWithDeadObjectHelper_createMonitorWithDeadObject(JNIEnv* env, jclass jc) {\n+    pthread_attr_t attr;\n+    void* ret;\n+\n+    (*env)->GetJavaVM(env, &jvm);\n+\n+    if (pthread_attr_init(&attr) != 0) die(\"pthread_attr_init\");\n+    if (pthread_create(&attacher, &attr, create_monitor_with_dead_object_in_thread, NULL) != 0) die(\"pthread_create\");\n+    if (pthread_join(attacher, &ret) != 0) die(\"pthread_join\");\n+}\n+\n+JNIEXPORT void JNICALL Java_MonitorWithDeadObjectHelper_createMonitorWithDeadObjectNoJoin(JNIEnv* env, jclass jc) {\n+    pthread_attr_t attr;\n+    void* ret;\n+\n+    (*env)->GetJavaVM(env, &jvm);\n+\n+    if (pthread_attr_init(&attr) != 0) die(\"pthread_attr_init\");\n+    if (pthread_create(&attacher, &attr, create_monitor_with_dead_object_in_thread, NULL) != 0) die(\"pthread_create\");\n+}\n+\n+JNIEXPORT void JNICALL Java_MonitorWithDeadObjectHelper_createMonitorWithDeadObjectDumpThreadsBeforeDetach(JNIEnv* env, jclass jc) {\n+    pthread_attr_t attr;\n+    void* ret;\n+\n+    (*env)->GetJavaVM(env, &jvm);\n+\n+    if (pthread_attr_init(&attr) != 0) die(\"pthread_attr_init\");\n+    if (pthread_create(&attacher, &attr, create_monitor_with_dead_object_and_dump_threads_in_thread, NULL) != 0) die(\"pthread_create\");\n+    if (pthread_join(attacher, &ret) != 0) die(\"pthread_join\");\n+}\n+\n+JNIEXPORT void JNICALL Java_MonitorWithDeadObjectHelper_joinTestThread(JNIEnv* env, jclass jc) {\n+    void* ret;\n+    if (pthread_join(attacher, &ret) != 0) die(\"pthread_join\");\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/libMonitorWithDeadObjectHelper.c","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -54,1 +54,1 @@\n-        \/\/ The monitor iterator used GetOwnedMonitorInfo used to\n+        \/\/ The monitor iterator used by GetOwnedMonitorInfo used to\n@@ -60,0 +60,3 @@\n+        if (!Thread.holdsLock(obj)) {\n+            throw new RuntimeException(\"The object is not locked\");\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorInfo\/GetOwnedMonitorInfoTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}