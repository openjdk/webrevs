{"files":[{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/parallel\/psScavenge.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/parallel\/psScavenge.inline.hpp\"\n+#include \"gc\/parallel\/psScavenge.hpp\"\n@@ -42,2 +42,3 @@\n-    if (PSScavenge::should_scavenge(p)) {\n-      oop o = RawAccess<IS_NOT_NULL>::oop_load(p);\n+    oop o = RawAccess<>::oop_load(p);\n+    if (PSScavenge::is_obj_in_young(o)) {\n+      assert(!PSScavenge::is_obj_in_to_space(o), \"Revisiting roots?\");\n@@ -92,4 +93,1 @@\n-    ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();\n-    assert(!psh->is_in_reserved(p), \"GC barrier needed\");\n-    if (PSScavenge::should_scavenge(p)) {\n-      assert(PSScavenge::should_scavenge(p, true), \"revisiting object?\");\n+    assert(!ParallelScavengeHeap::heap()->is_in_reserved(p), \"GC barrier needed\");\n@@ -97,1 +95,3 @@\n-      oop o = RawAccess<IS_NOT_NULL>::oop_load(p);\n+    oop o = RawAccess<>::oop_load(p);\n+    if (PSScavenge::is_obj_in_young(o)) {\n+      assert(!PSScavenge::is_obj_in_to_space(o), \"Revisiting roots?\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psClosure.inline.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/parallel\/psScavenge.inline.hpp\"\n+#include \"gc\/parallel\/psScavenge.hpp\"\n@@ -89,9 +89,0 @@\n-\/\/ Helper functions to get around the circular dependency between\n-\/\/ psScavenge.inline.hpp and psPromotionManager.inline.hpp.\n-bool PSPromotionManager::should_scavenge(oop* p, bool check_to_space) {\n-  return PSScavenge::should_scavenge(p, check_to_space);\n-}\n-bool PSPromotionManager::should_scavenge(narrowOop* p, bool check_to_space) {\n-  return PSScavenge::should_scavenge(p, check_to_space);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -170,3 +170,0 @@\n-  static bool should_scavenge(oop* p, bool check_to_space = false);\n-  static bool should_scavenge(narrowOop* p, bool check_to_space = false);\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/parallel\/psScavenge.inline.hpp\"\n+#include \"gc\/parallel\/psScavenge.hpp\"\n@@ -142,1 +142,2 @@\n-  assert(should_scavenge(&o), \"Sanity\");\n+  assert(PSScavenge::is_obj_in_young(o), \"precondition\");\n+  assert(!PSScavenge::is_obj_in_to_space(o), \"precondition\");\n@@ -238,2 +239,0 @@\n-  assert(should_scavenge(&o), \"Sanity\");\n-\n@@ -337,1 +336,0 @@\n-  assert(should_scavenge(p, true), \"revisiting object?\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"gc\/parallel\/psScavenge.inline.hpp\"\n+#include \"gc\/parallel\/psScavenge.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,9 +103,0 @@\n-  template <class T> static inline bool should_scavenge(T* p);\n-\n-  \/\/ These call should_scavenge() above and, if it returns true, also check that\n-  \/\/ the object was not newly copied into to_space.  The version with the bool\n-  \/\/ argument is a convenience wrapper that fetches the to_space pointer from\n-  \/\/ the heap and calls the other version (if the arg is true).\n-  template <class T> static inline bool should_scavenge(T* p, MutableSpace* to_space);\n-  template <class T> static inline bool should_scavenge(T* p, bool check_to_space);\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_PARALLEL_PSSCAVENGE_INLINE_HPP\n-#define SHARE_GC_PARALLEL_PSSCAVENGE_INLINE_HPP\n-\n-#include \"gc\/parallel\/psScavenge.hpp\"\n-\n-#include \"gc\/parallel\/parallelScavengeHeap.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/iterator.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/access.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-template <class T> inline bool PSScavenge::should_scavenge(T* p) {\n-  T heap_oop = RawAccess<>::oop_load(p);\n-  return PSScavenge::is_obj_in_young(heap_oop);\n-}\n-\n-template <class T>\n-inline bool PSScavenge::should_scavenge(T* p, MutableSpace* to_space) {\n-  if (should_scavenge(p)) {\n-    oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n-    \/\/ Skip objects copied to to_space since the scavenge started.\n-    HeapWord* const addr = cast_from_oop<HeapWord*>(obj);\n-    return addr < to_space->bottom() || addr >= to_space->end();\n-  }\n-  return false;\n-}\n-\n-template <class T>\n-inline bool PSScavenge::should_scavenge(T* p, bool check_to_space) {\n-  if (check_to_space) {\n-    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-    return should_scavenge(p, heap->young_gen()->to_space());\n-  }\n-  return should_scavenge(p);\n-}\n-\n-#endif \/\/ SHARE_GC_PARALLEL_PSSCAVENGE_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.inline.hpp","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"}]}