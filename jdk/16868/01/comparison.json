{"files":[{"patch":"@@ -30,0 +30,2 @@\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"include\/jvm_io.h\"\n@@ -31,0 +33,3 @@\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"utilities\/defaultStream.hpp\"\n@@ -41,0 +46,312 @@\n+char* CDSConfig::_default_archive_path = nullptr;\n+char* CDSConfig::_static_archive_path = nullptr;\n+char* CDSConfig::_dynamic_archive_path = nullptr;\n+\n+void CDSConfig::initialize() {\n+  if (is_dumping_static_archive()) {\n+    if (RequireSharedSpaces) {\n+      warning(\"Cannot dump shared archive while using shared archive\");\n+    }\n+    UseSharedSpaces = false;\n+  }\n+\n+  \/\/ Initialize shared archive paths which could include both base and dynamic archive paths\n+  \/\/ This must be after set_ergonomics_flags() called so flag UseCompressedOops is set properly.\n+  \/\/\n+  \/\/ UseSharedSpaces may be disabled if -XX:SharedArchiveFile is invalid.\n+  if (is_dumping_static_archive() || UseSharedSpaces) {\n+    init_shared_archive_paths();\n+  }\n+}\n+\n+char* CDSConfig::default_archive_path() {\n+  if (_default_archive_path == nullptr) {\n+    char jvm_path[JVM_MAXPATHLEN];\n+    os::jvm_path(jvm_path, sizeof(jvm_path));\n+    char *end = strrchr(jvm_path, *os::file_separator());\n+    if (end != nullptr) *end = '\\0';\n+    size_t jvm_path_len = strlen(jvm_path);\n+    size_t file_sep_len = strlen(os::file_separator());\n+    const size_t len = jvm_path_len + file_sep_len + 20;\n+    _default_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);\n+    jio_snprintf(_default_archive_path, len,\n+                LP64_ONLY(!UseCompressedOops ? \"%s%sclasses_nocoops.jsa\":) \"%s%sclasses.jsa\",\n+                jvm_path, os::file_separator());\n+  }\n+  return _default_archive_path;\n+}\n+\n+int CDSConfig::num_archives(const char* archive_path) {\n+  if (archive_path == nullptr) {\n+    return 0;\n+  }\n+  int npaths = 1;\n+  char* p = (char*)archive_path;\n+  while (*p != '\\0') {\n+    if (*p == os::path_separator()[0]) {\n+      npaths++;\n+    }\n+    p++;\n+  }\n+  return npaths;\n+}\n+\n+void CDSConfig::extract_shared_archive_paths(const char* archive_path,\n+                                             char** base_archive_path,\n+                                             char** top_archive_path) {\n+  char* begin_ptr = (char*)archive_path;\n+  char* end_ptr = strchr((char*)archive_path, os::path_separator()[0]);\n+  if (end_ptr == nullptr || end_ptr == begin_ptr) {\n+    vm_exit_during_initialization(\"Base archive was not specified\", archive_path);\n+  }\n+  size_t len = end_ptr - begin_ptr;\n+  char* cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);\n+  strncpy(cur_path, begin_ptr, len);\n+  cur_path[len] = '\\0';\n+  *base_archive_path = cur_path;\n+\n+  begin_ptr = ++end_ptr;\n+  if (*begin_ptr == '\\0') {\n+    vm_exit_during_initialization(\"Top archive was not specified\", archive_path);\n+  }\n+  end_ptr = strchr(begin_ptr, '\\0');\n+  assert(end_ptr != nullptr, \"sanity\");\n+  len = end_ptr - begin_ptr;\n+  cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);\n+  strncpy(cur_path, begin_ptr, len + 1);\n+  *top_archive_path = cur_path;\n+}\n+\n+void CDSConfig::init_shared_archive_paths() {\n+  if (ArchiveClassesAtExit != nullptr) {\n+    assert(!RecordDynamicDumpInfo, \"already checked\");\n+    if (is_dumping_static_archive()) {\n+      vm_exit_during_initialization(\"-XX:ArchiveClassesAtExit cannot be used with -Xshare:dump\");\n+    }\n+    check_unsupported_dumping_properties();\n+\n+    if (os::same_files(default_archive_path(), ArchiveClassesAtExit)) {\n+      vm_exit_during_initialization(\n+        \"Cannot specify the default CDS archive for -XX:ArchiveClassesAtExit\", default_archive_path());\n+    }\n+  }\n+\n+  if (SharedArchiveFile == nullptr) {\n+    _static_archive_path = default_archive_path();\n+  } else {\n+    int archives = num_archives(SharedArchiveFile);\n+    assert(archives > 0, \"must be\");\n+\n+    if (is_dumping_archive() && archives > 1) {\n+      vm_exit_during_initialization(\n+        \"Cannot have more than 1 archive file specified in -XX:SharedArchiveFile during CDS dumping\");\n+    }\n+\n+    if (is_dumping_static_archive()) {\n+      assert(archives == 1, \"must be\");\n+      \/\/ Static dump is simple: only one archive is allowed in SharedArchiveFile. This file\n+      \/\/ will be overwritten no matter regardless of its contents\n+      _static_archive_path = os::strdup_check_oom(SharedArchiveFile, mtArguments);\n+    } else {\n+      \/\/ SharedArchiveFile may specify one or two files. In case (c), the path for base.jsa\n+      \/\/ is read from top.jsa\n+      \/\/    (a) 1 file:  -XX:SharedArchiveFile=base.jsa\n+      \/\/    (b) 2 files: -XX:SharedArchiveFile=base.jsa:top.jsa\n+      \/\/    (c) 2 files: -XX:SharedArchiveFile=top.jsa\n+      \/\/\n+      \/\/ However, if either RecordDynamicDumpInfo or ArchiveClassesAtExit is used, we do not\n+      \/\/ allow cases (b) and (c). Case (b) is already checked above.\n+\n+      if (archives > 2) {\n+        vm_exit_during_initialization(\n+          \"Cannot have more than 2 archive files specified in the -XX:SharedArchiveFile option\");\n+      }\n+      if (archives == 1) {\n+        char* base_archive_path = nullptr;\n+        bool success =\n+          FileMapInfo::get_base_archive_name_from_header(SharedArchiveFile, &base_archive_path);\n+        if (!success) {\n+          \/\/ If +AutoCreateSharedArchive and the specified shared archive does not exist,\n+          \/\/ regenerate the dynamic archive base on default archive.\n+          if (AutoCreateSharedArchive && !os::file_exists(SharedArchiveFile)) {\n+            enable_dumping_dynamic_archive();\n+            ArchiveClassesAtExit = const_cast<char *>(SharedArchiveFile);\n+            _static_archive_path = default_archive_path();\n+            SharedArchiveFile = nullptr;\n+          } else {\n+            if (AutoCreateSharedArchive) {\n+              warning(\"-XX:+AutoCreateSharedArchive is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\");\n+              AutoCreateSharedArchive = false;\n+            }\n+            Arguments::no_shared_spaces(\"invalid archive\");\n+          }\n+        } else if (base_archive_path == nullptr) {\n+          \/\/ User has specified a single archive, which is a static archive.\n+          _static_archive_path = const_cast<char *>(SharedArchiveFile);\n+        } else {\n+          \/\/ User has specified a single archive, which is a dynamic archive.\n+          _dynamic_archive_path = const_cast<char *>(SharedArchiveFile);\n+          _static_archive_path = base_archive_path; \/\/ has been c-heap allocated.\n+        }\n+      } else {\n+        extract_shared_archive_paths((const char*)SharedArchiveFile,\n+                                      &_static_archive_path, &_dynamic_archive_path);\n+        if (_static_archive_path == nullptr) {\n+          assert(_dynamic_archive_path == nullptr, \"must be\");\n+          Arguments::no_shared_spaces(\"invalid archive\");\n+        }\n+      }\n+\n+      if (_dynamic_archive_path != nullptr) {\n+        \/\/ Check for case (c)\n+        if (RecordDynamicDumpInfo) {\n+          vm_exit_during_initialization(\"-XX:+RecordDynamicDumpInfo is unsupported when a dynamic CDS archive is specified in -XX:SharedArchiveFile\",\n+                                        SharedArchiveFile);\n+        }\n+        if (ArchiveClassesAtExit != nullptr) {\n+          vm_exit_during_initialization(\"-XX:ArchiveClassesAtExit is unsupported when a dynamic CDS archive is specified in -XX:SharedArchiveFile\",\n+                                        SharedArchiveFile);\n+        }\n+      }\n+\n+      if (ArchiveClassesAtExit != nullptr && os::same_files(SharedArchiveFile, ArchiveClassesAtExit)) {\n+          vm_exit_during_initialization(\n+            \"Cannot have the same archive file specified for -XX:SharedArchiveFile and -XX:ArchiveClassesAtExit\",\n+            SharedArchiveFile);\n+      }\n+    }\n+  }\n+}\n+\n+void CDSConfig::check_system_property(const char* key, const char* value) {\n+  if (Arguments::is_internal_module_property(key)) {\n+    MetaspaceShared::disable_optimized_module_handling();\n+    log_info(cds)(\"optimized module handling: disabled due to incompatible property: %s=%s\", key, value);\n+  }\n+  if (strcmp(key, \"jdk.module.showModuleResolution\") == 0 ||\n+      strcmp(key, \"jdk.module.validation\") == 0 ||\n+      strcmp(key, \"java.system.class.loader\") == 0) {\n+    disable_loading_full_module_graph();\n+    disable_dumping_full_module_graph();\n+    log_info(cds)(\"full module graph: disabled due to incompatible property: %s=%s\", key, value);\n+  }\n+}\n+\n+static const char* unsupported_properties[] = {\n+  \"jdk.module.limitmods\",\n+  \"jdk.module.upgrade.path\",\n+  \"jdk.module.patch.0\"\n+};\n+static const char* unsupported_options[] = {\n+  \"--limit-modules\",\n+  \"--upgrade-module-path\",\n+  \"--patch-module\"\n+};\n+\n+void CDSConfig::check_unsupported_dumping_properties() {\n+  assert(is_dumping_archive(), \"this function is only used with CDS dump time\");\n+  assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), \"must be\");\n+  \/\/ If a vm option is found in the unsupported_options array, vm will exit with an error message.\n+  SystemProperty* sp = Arguments::system_properties();\n+  while (sp != nullptr) {\n+    for (uint i = 0; i < ARRAY_SIZE(unsupported_properties); i++) {\n+      if (strcmp(sp->key(), unsupported_properties[i]) == 0) {\n+        vm_exit_during_initialization(\n+          \"Cannot use the following option when dumping the shared archive\", unsupported_options[i]);\n+      }\n+    }\n+    sp = sp->next();\n+  }\n+\n+  \/\/ Check for an exploded module build in use with -Xshare:dump.\n+  if (!Arguments::has_jimage()) {\n+    vm_exit_during_initialization(\"Dumping the shared archive is not supported with an exploded module build\");\n+  }\n+}\n+\n+bool CDSConfig::check_unsupported_cds_runtime_properties() {\n+  assert(UseSharedSpaces, \"this function is only used with -Xshare:{on,auto}\");\n+  assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), \"must be\");\n+  if (ArchiveClassesAtExit != nullptr) {\n+    \/\/ dynamic dumping, just return false for now.\n+    \/\/ check_unsupported_dumping_properties() will be called later to check the same set of\n+    \/\/ properties, and will exit the VM with the correct error message if the unsupported properties\n+    \/\/ are used.\n+    return false;\n+  }\n+  for (uint i = 0; i < ARRAY_SIZE(unsupported_properties); i++) {\n+    if (Arguments::get_property(unsupported_properties[i]) != nullptr) {\n+      if (RequireSharedSpaces) {\n+        warning(\"CDS is disabled when the %s option is specified.\", unsupported_options[i]);\n+      } else {\n+        log_info(cds)(\"CDS is disabled when the %s option is specified.\", unsupported_options[i]);\n+      }\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool CDSConfig::check_vm_args_consistency(bool patch_mod_javabase,  bool mode_flag_cmd_line) {\n+  if (is_dumping_static_archive()) {\n+    if (!mode_flag_cmd_line) {\n+      \/\/ By default, -Xshare:dump runs in interpreter-only mode, which is required for deterministic archive.\n+      \/\/\n+      \/\/ If your classlist is large and you don't care about deterministic dumping, you can use\n+      \/\/ -Xshare:dump -Xmixed to improve dumping speed.\n+      Arguments::set_mode_flags(Arguments::_int);\n+    } else if (Arguments::mode() == Arguments::_comp) {\n+      \/\/ -Xcomp may use excessive CPU for the test tiers. Also, -Xshare:dump runs a small and fixed set of\n+      \/\/ Java code, so there's not much benefit in running -Xcomp.\n+      log_info(cds)(\"reduced -Xcomp to -Xmixed for static dumping\");\n+      Arguments::set_mode_flags(Arguments::_mixed);\n+    }\n+\n+    \/\/ String deduplication may cause CDS to iterate the strings in different order from one\n+    \/\/ run to another which resulting in non-determinstic CDS archives.\n+    \/\/ Disable UseStringDeduplication while dumping CDS archive.\n+    UseStringDeduplication = false;\n+  }\n+\n+  \/\/ RecordDynamicDumpInfo is not compatible with ArchiveClassesAtExit\n+  if (ArchiveClassesAtExit != nullptr && RecordDynamicDumpInfo) {\n+    jio_fprintf(defaultStream::output_stream(),\n+                \"-XX:+RecordDynamicDumpInfo cannot be used with -XX:ArchiveClassesAtExit.\\n\");\n+    return false;\n+  }\n+\n+  if (ArchiveClassesAtExit == nullptr && !RecordDynamicDumpInfo) {\n+    disable_dumping_dynamic_archive();\n+  } else {\n+    enable_dumping_dynamic_archive();\n+  }\n+\n+  if (AutoCreateSharedArchive) {\n+    if (SharedArchiveFile == nullptr) {\n+      log_warning(cds)(\"-XX:+AutoCreateSharedArchive requires -XX:SharedArchiveFile\");\n+      return false;\n+    }\n+    if (ArchiveClassesAtExit != nullptr) {\n+      log_warning(cds)(\"-XX:+AutoCreateSharedArchive does not work with ArchiveClassesAtExit\");\n+      return false;\n+    }\n+  }\n+\n+  if (UseSharedSpaces && patch_mod_javabase) {\n+    Arguments::no_shared_spaces(\"CDS is disabled when \" JAVA_BASE_NAME \" module is patched.\");\n+  }\n+  if (UseSharedSpaces && check_unsupported_cds_runtime_properties()) {\n+    UseSharedSpaces = false;\n+  }\n+\n+  if (is_dumping_archive()) {\n+    \/\/ Always verify non-system classes during CDS dump\n+    if (!BytecodeVerificationRemote) {\n+      BytecodeVerificationRemote = true;\n+      log_info(cds)(\"All non-system classes will be verified (-Xverify:remote) during CDS dump time.\");\n+    }\n+  }\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":317,"deletions":0,"binary":false,"changes":317,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -37,0 +38,4 @@\n+\n+  static char*  _default_archive_path;\n+  static char*  _static_archive_path;\n+  static char*  _dynamic_archive_path;\n@@ -39,0 +44,6 @@\n+  static void extract_shared_archive_paths(const char* archive_path,\n+                                           char** base_archive_path,\n+                                           char** top_archive_path);\n+  static void init_shared_archive_paths();\n+  static bool check_unsupported_cds_runtime_properties();\n+\n@@ -40,0 +51,6 @@\n+  \/\/ Initialization and command-line checking\n+  static void initialize() NOT_CDS_RETURN;\n+  static void check_system_property(const char* key, const char* value) NOT_CDS_RETURN;\n+  static void check_unsupported_dumping_properties() NOT_CDS_RETURN;\n+  static bool check_vm_args_consistency(bool patch_mod_javabase,  bool mode_flag_cmd_line) NOT_CDS_RETURN_(false);\n+\n@@ -48,0 +65,11 @@\n+  \/\/ Archive paths\n+  \/\/ Points to the classes.jsa in $JAVA_HOME\n+  static char* default_archive_path()                         NOT_CDS_RETURN_(nullptr);\n+  \/\/ The actual static archive  (if any) selected at runtime\n+  static const char* static_archive_path()                   { return CDS_ONLY(_static_archive_path) NOT_CDS(nullptr); }\n+  \/\/ The actual dynamic archive  (if any) selected at runtime\n+  static const char* dynamic_archive_path()                  { return CDS_ONLY(_dynamic_archive_path) NOT_CDS(nullptr); }\n+\n+  static int num_archives(const char* archive_path)          NOT_CDS_RETURN_(0);\n+\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -165,2 +165,2 @@\n-    const char* default_base_archive_name = Arguments::get_default_shared_archive_path();\n-    const char* current_base_archive_name = Arguments::GetSharedArchivePath();\n+    const char* default_base_archive_name = CDSConfig::default_archive_path();\n+    const char* current_base_archive_name = CDSConfig::static_archive_path();\n@@ -202,1 +202,1 @@\n-    copy_base_archive_name(Arguments::GetSharedArchivePath());\n+    copy_base_archive_name(CDSConfig::static_archive_path());\n@@ -919,1 +919,1 @@\n-  int num_paths = Arguments::num_archives(rp);\n+  int num_paths = CDSConfig::num_archives(rp);\n@@ -1251,1 +1251,1 @@\n-    *base_archive_name = Arguments::get_default_shared_archive_path();\n+    *base_archive_name = CDSConfig::default_archive_path();\n@@ -2276,1 +2276,1 @@\n-        ArchiveClassesAtExit = Arguments::GetSharedDynamicArchivePath();\n+        ArchiveClassesAtExit = CDSConfig::dynamic_archive_path();\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -542,1 +542,1 @@\n-  const char* static_archive = Arguments::GetSharedArchivePath();\n+  const char* static_archive = CDSConfig::static_archive_path();\n@@ -654,2 +654,1 @@\n-  Arguments::check_unsupported_dumping_properties();\n-\n+  CDSConfig::check_unsupported_dumping_properties();\n@@ -987,2 +986,2 @@\n-  const char* static_archive = Arguments::GetSharedArchivePath();\n-  assert(static_archive != nullptr, \"SharedArchivePath is nullptr\");\n+  const char* static_archive = CDSConfig::static_archive_path();\n+  assert(static_archive != nullptr, \"sanity\");\n@@ -1001,1 +1000,1 @@\n-  const char* dynamic_archive = Arguments::GetSharedDynamicArchivePath();\n+  const char* dynamic_archive = CDSConfig::dynamic_archive_path();\n@@ -1494,1 +1493,1 @@\n-      tty->print_cr(\"\\n\\nBase archive name: %s\", Arguments::GetSharedArchivePath());\n+      tty->print_cr(\"\\n\\nBase archive name: %s\", CDSConfig::static_archive_path());\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2046,1 +2046,1 @@\n-  const char* p = Arguments::get_default_shared_archive_path();\n+  const char* p = CDSConfig::default_archive_path();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,4 +104,0 @@\n-char*  Arguments::_default_shared_archive_path  = nullptr;\n-char*  Arguments::SharedArchivePath             = nullptr;\n-char*  Arguments::SharedDynamicArchivePath      = nullptr;\n-\n@@ -1266,13 +1262,1 @@\n-#if INCLUDE_CDS\n-  if (is_internal_module_property(key)) {\n-    MetaspaceShared::disable_optimized_module_handling();\n-    log_info(cds)(\"optimized module handling: disabled due to incompatible property: %s=%s\", key, value);\n-  }\n-  if (strcmp(key, \"jdk.module.showModuleResolution\") == 0 ||\n-      strcmp(key, \"jdk.module.validation\") == 0 ||\n-      strcmp(key, \"java.system.class.loader\") == 0) {\n-    CDSConfig::disable_loading_full_module_graph();\n-    CDSConfig::disable_dumping_full_module_graph();\n-    log_info(cds)(\"full module graph: disabled due to incompatible property: %s=%s\", key, value);\n-  }\n-#endif\n+  CDSConfig::check_system_property(key, value);\n@@ -1332,54 +1316,0 @@\n-#if INCLUDE_CDS\n-const char* unsupported_properties[] = { \"jdk.module.limitmods\",\n-                                         \"jdk.module.upgrade.path\",\n-                                         \"jdk.module.patch.0\" };\n-const char* unsupported_options[] = { \"--limit-modules\",\n-                                      \"--upgrade-module-path\",\n-                                      \"--patch-module\"\n-                                    };\n-void Arguments::check_unsupported_dumping_properties() {\n-  assert(CDSConfig::is_dumping_archive(),\n-         \"this function is only used with CDS dump time\");\n-  assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), \"must be\");\n-  \/\/ If a vm option is found in the unsupported_options array, vm will exit with an error message.\n-  SystemProperty* sp = system_properties();\n-  while (sp != nullptr) {\n-    for (uint i = 0; i < ARRAY_SIZE(unsupported_properties); i++) {\n-      if (strcmp(sp->key(), unsupported_properties[i]) == 0) {\n-        vm_exit_during_initialization(\n-          \"Cannot use the following option when dumping the shared archive\", unsupported_options[i]);\n-      }\n-    }\n-    sp = sp->next();\n-  }\n-\n-  \/\/ Check for an exploded module build in use with -Xshare:dump.\n-  if (!has_jimage()) {\n-    vm_exit_during_initialization(\"Dumping the shared archive is not supported with an exploded module build\");\n-  }\n-}\n-\n-bool Arguments::check_unsupported_cds_runtime_properties() {\n-  assert(UseSharedSpaces, \"this function is only used with -Xshare:{on,auto}\");\n-  assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), \"must be\");\n-  if (ArchiveClassesAtExit != nullptr) {\n-    \/\/ dynamic dumping, just return false for now.\n-    \/\/ check_unsupported_dumping_properties() will be called later to check the same set of\n-    \/\/ properties, and will exit the VM with the correct error message if the unsupported properties\n-    \/\/ are used.\n-    return false;\n-  }\n-  for (uint i = 0; i < ARRAY_SIZE(unsupported_properties); i++) {\n-    if (get_property(unsupported_properties[i]) != nullptr) {\n-      if (RequireSharedSpaces) {\n-        warning(\"CDS is disabled when the %s option is specified.\", unsupported_options[i]);\n-      } else {\n-        log_info(cds)(\"CDS is disabled when the %s option is specified.\", unsupported_options[i]);\n-      }\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-#endif\n-\n@@ -1435,1 +1365,1 @@\n-static void no_shared_spaces(const char* message) {\n+void Arguments::no_shared_spaces(const char* message) {\n@@ -3040,25 +2970,1 @@\n-#if INCLUDE_CDS\n-  if (CDSConfig::is_dumping_static_archive()) {\n-    if (!mode_flag_cmd_line) {\n-      \/\/ By default, -Xshare:dump runs in interpreter-only mode, which is required for deterministic archive.\n-      \/\/\n-      \/\/ If your classlist is large and you don't care about deterministic dumping, you can use\n-      \/\/ -Xshare:dump -Xmixed to improve dumping speed.\n-      set_mode_flags(_int);\n-    } else if (_mode == _comp) {\n-      \/\/ -Xcomp may use excessive CPU for the test tiers. Also, -Xshare:dump runs a small and fixed set of\n-      \/\/ Java code, so there's not much benefit in running -Xcomp.\n-      log_info(cds)(\"reduced -Xcomp to -Xmixed for static dumping\");\n-      set_mode_flags(_mixed);\n-    }\n-\n-    \/\/ String deduplication may cause CDS to iterate the strings in different order from one\n-    \/\/ run to another which resulting in non-determinstic CDS archives.\n-    \/\/ Disable UseStringDeduplication while dumping CDS archive.\n-    UseStringDeduplication = false;\n-  }\n-\n-  \/\/ RecordDynamicDumpInfo is not compatible with ArchiveClassesAtExit\n-  if (ArchiveClassesAtExit != nullptr && RecordDynamicDumpInfo) {\n-    jio_fprintf(defaultStream::output_stream(),\n-                \"-XX:+RecordDynamicDumpInfo cannot be used with -XX:ArchiveClassesAtExit.\\n\");\n+  if (!CDSConfig::check_vm_args_consistency(patch_mod_javabase, mode_flag_cmd_line)) {\n@@ -3068,33 +2974,0 @@\n-  if (ArchiveClassesAtExit == nullptr && !RecordDynamicDumpInfo) {\n-    CDSConfig::disable_dumping_dynamic_archive();\n-  } else {\n-    CDSConfig::enable_dumping_dynamic_archive();\n-  }\n-\n-  if (AutoCreateSharedArchive) {\n-    if (SharedArchiveFile == nullptr) {\n-      log_warning(cds)(\"-XX:+AutoCreateSharedArchive requires -XX:SharedArchiveFile\");\n-      return JNI_ERR;\n-    }\n-    if (ArchiveClassesAtExit != nullptr) {\n-      log_warning(cds)(\"-XX:+AutoCreateSharedArchive does not work with ArchiveClassesAtExit\");\n-      return JNI_ERR;\n-    }\n-  }\n-\n-  if (UseSharedSpaces && patch_mod_javabase) {\n-    no_shared_spaces(\"CDS is disabled when \" JAVA_BASE_NAME \" module is patched.\");\n-  }\n-  if (UseSharedSpaces && check_unsupported_cds_runtime_properties()) {\n-    UseSharedSpaces = false;\n-  }\n-\n-  if (CDSConfig::is_dumping_archive()) {\n-    \/\/ Always verify non-system classes during CDS dump\n-    if (!BytecodeVerificationRemote) {\n-      BytecodeVerificationRemote = true;\n-      log_info(cds)(\"All non-system classes will be verified (-Xverify:remote) during CDS dump time.\");\n-    }\n-  }\n-#endif\n-\n@@ -3368,181 +3241,0 @@\n-void Arguments::set_shared_spaces_flags_and_archive_paths() {\n-  if (CDSConfig::is_dumping_static_archive()) {\n-    if (RequireSharedSpaces) {\n-      warning(\"Cannot dump shared archive while using shared archive\");\n-    }\n-    UseSharedSpaces = false;\n-  }\n-#if INCLUDE_CDS\n-  \/\/ Initialize shared archive paths which could include both base and dynamic archive paths\n-  \/\/ This must be after set_ergonomics_flags() called so flag UseCompressedOops is set properly.\n-  \/\/\n-  \/\/ UseSharedSpaces may be disabled if -XX:SharedArchiveFile is invalid.\n-  if (CDSConfig::is_dumping_static_archive() || UseSharedSpaces) {\n-    init_shared_archive_paths();\n-  }\n-#endif  \/\/ INCLUDE_CDS\n-}\n-\n-#if INCLUDE_CDS\n-\/\/ Sharing support\n-\/\/ Construct the path to the archive\n-char* Arguments::get_default_shared_archive_path() {\n-  if (_default_shared_archive_path == nullptr) {\n-    char jvm_path[JVM_MAXPATHLEN];\n-    os::jvm_path(jvm_path, sizeof(jvm_path));\n-    char *end = strrchr(jvm_path, *os::file_separator());\n-    if (end != nullptr) *end = '\\0';\n-    size_t jvm_path_len = strlen(jvm_path);\n-    size_t file_sep_len = strlen(os::file_separator());\n-    const size_t len = jvm_path_len + file_sep_len + 20;\n-    _default_shared_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);\n-    jio_snprintf(_default_shared_archive_path, len,\n-                LP64_ONLY(!UseCompressedOops ? \"%s%sclasses_nocoops.jsa\":) \"%s%sclasses.jsa\",\n-                jvm_path, os::file_separator());\n-  }\n-  return _default_shared_archive_path;\n-}\n-\n-int Arguments::num_archives(const char* archive_path) {\n-  if (archive_path == nullptr) {\n-    return 0;\n-  }\n-  int npaths = 1;\n-  char* p = (char*)archive_path;\n-  while (*p != '\\0') {\n-    if (*p == os::path_separator()[0]) {\n-      npaths++;\n-    }\n-    p++;\n-  }\n-  return npaths;\n-}\n-\n-void Arguments::extract_shared_archive_paths(const char* archive_path,\n-                                         char** base_archive_path,\n-                                         char** top_archive_path) {\n-  char* begin_ptr = (char*)archive_path;\n-  char* end_ptr = strchr((char*)archive_path, os::path_separator()[0]);\n-  if (end_ptr == nullptr || end_ptr == begin_ptr) {\n-    vm_exit_during_initialization(\"Base archive was not specified\", archive_path);\n-  }\n-  size_t len = end_ptr - begin_ptr;\n-  char* cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);\n-  strncpy(cur_path, begin_ptr, len);\n-  cur_path[len] = '\\0';\n-  *base_archive_path = cur_path;\n-\n-  begin_ptr = ++end_ptr;\n-  if (*begin_ptr == '\\0') {\n-    vm_exit_during_initialization(\"Top archive was not specified\", archive_path);\n-  }\n-  end_ptr = strchr(begin_ptr, '\\0');\n-  assert(end_ptr != nullptr, \"sanity\");\n-  len = end_ptr - begin_ptr;\n-  cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);\n-  strncpy(cur_path, begin_ptr, len + 1);\n-  *top_archive_path = cur_path;\n-}\n-\n-void Arguments::init_shared_archive_paths() {\n-  if (ArchiveClassesAtExit != nullptr) {\n-    assert(!RecordDynamicDumpInfo, \"already checked\");\n-    if (CDSConfig::is_dumping_static_archive()) {\n-      vm_exit_during_initialization(\"-XX:ArchiveClassesAtExit cannot be used with -Xshare:dump\");\n-    }\n-    check_unsupported_dumping_properties();\n-\n-    if (os::same_files(get_default_shared_archive_path(), ArchiveClassesAtExit)) {\n-      vm_exit_during_initialization(\n-        \"Cannot specify the default CDS archive for -XX:ArchiveClassesAtExit\", get_default_shared_archive_path());\n-    }\n-  }\n-\n-  if (SharedArchiveFile == nullptr) {\n-    SharedArchivePath = get_default_shared_archive_path();\n-  } else {\n-    int archives = num_archives(SharedArchiveFile);\n-    assert(archives > 0, \"must be\");\n-\n-    if (CDSConfig::is_dumping_archive() && archives > 1) {\n-      vm_exit_during_initialization(\n-        \"Cannot have more than 1 archive file specified in -XX:SharedArchiveFile during CDS dumping\");\n-    }\n-\n-    if (CDSConfig::is_dumping_static_archive()) {\n-      assert(archives == 1, \"must be\");\n-      \/\/ Static dump is simple: only one archive is allowed in SharedArchiveFile. This file\n-      \/\/ will be overwritten no matter regardless of its contents\n-      SharedArchivePath = os::strdup_check_oom(SharedArchiveFile, mtArguments);\n-    } else {\n-      \/\/ SharedArchiveFile may specify one or two files. In case (c), the path for base.jsa\n-      \/\/ is read from top.jsa\n-      \/\/    (a) 1 file:  -XX:SharedArchiveFile=base.jsa\n-      \/\/    (b) 2 files: -XX:SharedArchiveFile=base.jsa:top.jsa\n-      \/\/    (c) 2 files: -XX:SharedArchiveFile=top.jsa\n-      \/\/\n-      \/\/ However, if either RecordDynamicDumpInfo or ArchiveClassesAtExit is used, we do not\n-      \/\/ allow cases (b) and (c). Case (b) is already checked above.\n-\n-      if (archives > 2) {\n-        vm_exit_during_initialization(\n-          \"Cannot have more than 2 archive files specified in the -XX:SharedArchiveFile option\");\n-      }\n-      if (archives == 1) {\n-        char* base_archive_path = nullptr;\n-        bool success =\n-          FileMapInfo::get_base_archive_name_from_header(SharedArchiveFile, &base_archive_path);\n-        if (!success) {\n-          \/\/ If +AutoCreateSharedArchive and the specified shared archive does not exist,\n-          \/\/ regenerate the dynamic archive base on default archive.\n-          if (AutoCreateSharedArchive && !os::file_exists(SharedArchiveFile)) {\n-            CDSConfig::enable_dumping_dynamic_archive();\n-            ArchiveClassesAtExit = const_cast<char *>(SharedArchiveFile);\n-            SharedArchivePath = get_default_shared_archive_path();\n-            SharedArchiveFile = nullptr;\n-          } else {\n-            if (AutoCreateSharedArchive) {\n-              warning(\"-XX:+AutoCreateSharedArchive is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\");\n-              AutoCreateSharedArchive = false;\n-            }\n-            no_shared_spaces(\"invalid archive\");\n-          }\n-        } else if (base_archive_path == nullptr) {\n-          \/\/ User has specified a single archive, which is a static archive.\n-          SharedArchivePath = const_cast<char *>(SharedArchiveFile);\n-        } else {\n-          \/\/ User has specified a single archive, which is a dynamic archive.\n-          SharedDynamicArchivePath = const_cast<char *>(SharedArchiveFile);\n-          SharedArchivePath = base_archive_path; \/\/ has been c-heap allocated.\n-        }\n-      } else {\n-        extract_shared_archive_paths((const char*)SharedArchiveFile,\n-                                      &SharedArchivePath, &SharedDynamicArchivePath);\n-        if (SharedArchivePath == nullptr) {\n-          assert(SharedDynamicArchivePath == nullptr, \"must be\");\n-          no_shared_spaces(\"invalid archive\");\n-        }\n-      }\n-\n-      if (SharedDynamicArchivePath != nullptr) {\n-        \/\/ Check for case (c)\n-        if (RecordDynamicDumpInfo) {\n-          vm_exit_during_initialization(\"-XX:+RecordDynamicDumpInfo is unsupported when a dynamic CDS archive is specified in -XX:SharedArchiveFile\",\n-                                        SharedArchiveFile);\n-        }\n-        if (ArchiveClassesAtExit != nullptr) {\n-          vm_exit_during_initialization(\"-XX:ArchiveClassesAtExit is unsupported when a dynamic CDS archive is specified in -XX:SharedArchiveFile\",\n-                                        SharedArchiveFile);\n-        }\n-      }\n-\n-      if (ArchiveClassesAtExit != nullptr && os::same_files(SharedArchiveFile, ArchiveClassesAtExit)) {\n-          vm_exit_during_initialization(\n-            \"Cannot have the same archive file specified for -XX:SharedArchiveFile and -XX:ArchiveClassesAtExit\",\n-            SharedArchiveFile);\n-      }\n-    }\n-  }\n-}\n-#endif \/\/ INCLUDE_CDS\n-\n@@ -3993,1 +3685,1 @@\n-  set_shared_spaces_flags_and_archive_paths();\n+  CDSConfig::initialize();\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":312,"binary":false,"changes":316,"status":"modified"},{"patch":"@@ -251,1 +251,0 @@\n-  static void set_mode_flags(Mode mode);\n@@ -267,1 +266,0 @@\n-  static void set_shared_spaces_flags_and_archive_paths();\n@@ -366,4 +364,0 @@\n-\n-  static char*  _default_shared_archive_path;\n-  static char*  SharedArchivePath;\n-  static char*  SharedDynamicArchivePath;\n@@ -371,3 +365,0 @@\n-  static void extract_shared_archive_paths(const char* archive_path,\n-                                         char** base_archive_path,\n-                                         char** top_archive_path) NOT_CDS_RETURN;\n@@ -376,1 +367,0 @@\n-  static int num_archives(const char* archive_path) NOT_CDS_RETURN_(0);\n@@ -444,2 +434,1 @@\n-  static const char* GetSharedArchivePath() { return SharedArchivePath; }\n-  static const char* GetSharedDynamicArchivePath() { return SharedDynamicArchivePath; }\n+  static void no_shared_spaces(const char* message);\n@@ -504,3 +493,0 @@\n-  static char* get_default_shared_archive_path() NOT_CDS_RETURN_(nullptr);\n-  static void  init_shared_archive_paths() NOT_CDS_RETURN;\n-\n@@ -509,0 +495,1 @@\n+  static void set_mode_flags(Mode mode);\n@@ -520,4 +507,0 @@\n-  static void check_unsupported_dumping_properties() NOT_CDS_RETURN;\n-\n-  static bool check_unsupported_cds_runtime_properties() NOT_CDS_RETURN0;\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -267,2 +267,2 @@\n-\/\/ mangled name of Arguments::SharedArchivePath\n-#define SHARED_ARCHIVE_PATH_SYM \"_ZN9Arguments17SharedArchivePathE\"\n+\/\/ mangled name of CDSConfig::_static_archive_path\n+#define SHARED_ARCHIVE_PATH_SYM \"_ZN9CDSConfig20_static_archive_pathE\"\n@@ -275,2 +275,2 @@\n-\/\/ mangled name of Arguments::SharedArchivePath\n-#define SHARED_ARCHIVE_PATH_SYM \"__ZN9Arguments17SharedArchivePathE\"\n+\/\/ mangled name of CDSConfig::_static_archive_path\n+#define SHARED_ARCHIVE_PATH_SYM \"__ZN9CDSConfig20_static_archive_pathE\"\n","filename":"src\/jdk.hotspot.agent\/share\/native\/libsaproc\/ps_core_common.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}