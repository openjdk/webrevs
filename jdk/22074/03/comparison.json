{"files":[{"patch":"@@ -59,1 +59,1 @@\n-  size_t start_size_log_2 = MAX2(ceil_log2(table_size), (size_t)2); \/\/ 2 is minimum size even though some dictionaries only have one entry\n+  size_t start_size_log_2 = MAX2((size_t)ceil_log2(table_size), (size_t)2); \/\/ 2 is minimum size even though some dictionaries only have one entry\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,4 +124,11 @@\n-template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n-inline T ceil_log2(T value) {\n-  T ret;\n-  for (ret = 1; ((T)1 << ret) < value; ++ret);\n+template <typename T, typename U = typename std::make_unsigned<T>::type, ENABLE_IF(std::is_integral<T>::value)>\n+inline int ceil_log2(T value) {\n+  assert(value > 0 && \"Invalid value\");\n+  U unsigned_value = static_cast<U>(value);\n+  int max_bits = sizeof(U) * 8;\n+  int ret;\n+  for (ret = 0; ret < max_bits; ++ret) {\n+    if ((U(1) << ret) >= unsigned_value) {\n+      break;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/utilities\/powerOfTwo.hpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -308,0 +308,28 @@\n+\n+template <typename T> void test_ceil_log2() {\n+  EXPECT_EQ(ceil_log2(T(1)), 0) << \"value = \" << T(1);\n+  EXPECT_EQ(ceil_log2(T(2)), 1) << \"value = \" << T(2);\n+  EXPECT_EQ(ceil_log2(T(3)), 2) << \"value = \" << T(3);\n+  EXPECT_EQ(ceil_log2(T(4)), 2) << \"value = \" << T(4);\n+  EXPECT_EQ(ceil_log2(T(5)), 3) << \"value = \" << T(5);\n+\n+  \/\/ Test max values\n+  if (std::is_unsigned<T>::value) {\n+    EXPECT_EQ(ceil_log2(std::numeric_limits<T>::max()),\n+            (int)(sizeof(T) * 8)) << \"value = \" << std::numeric_limits<T>::max();\n+  } else {\n+    EXPECT_EQ(ceil_log2(std::numeric_limits<T>::max()),\n+            (int)(sizeof(T) * 8 - 1)) << \"value = \" << std::numeric_limits<T>::max();\n+  }\n+}\n+\n+TEST(power_of_2, ceil_log2) {\n+  test_ceil_log2<int8_t>();\n+  test_ceil_log2<int16_t>();\n+  test_ceil_log2<int32_t>();\n+  test_ceil_log2<int64_t>();\n+  test_ceil_log2<uint8_t>();\n+  test_ceil_log2<uint16_t>();\n+  test_ceil_log2<uint32_t>();\n+  test_ceil_log2<uint64_t>();\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_powerOfTwo.cpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"}]}