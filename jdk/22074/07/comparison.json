{"files":[{"patch":"@@ -59,1 +59,1 @@\n-  size_t start_size_log_2 = MAX2(ceil_log2(table_size), (size_t)2); \/\/ 2 is minimum size even though some dictionaries only have one entry\n+  size_t start_size_log_2 = MAX2(ceil_log2(table_size), 2); \/\/ 2 is minimum size even though some dictionaries only have one entry\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,4 +125,3 @@\n-inline T ceil_log2(T value) {\n-  T ret;\n-  for (ret = 1; ((T)1 << ret) < value; ++ret);\n-  return ret;\n+inline int ceil_log2(T value) {\n+  assert(value > 0, \"Invalid value\");\n+  return log2i_graceful(value - 1) + 1;\n","filename":"src\/hotspot\/share\/utilities\/powerOfTwo.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -308,0 +308,41 @@\n+\n+template <typename T> void test_ceil_log2() {\n+  EXPECT_EQ(ceil_log2(T(1)), 0) << \"value = \" << T(1);\n+  EXPECT_EQ(ceil_log2(T(2)), 1) << \"value = \" << T(2);\n+  EXPECT_EQ(ceil_log2(T(3)), 2) << \"value = \" << T(3);\n+  EXPECT_EQ(ceil_log2(T(4)), 2) << \"value = \" << T(4);\n+  EXPECT_EQ(ceil_log2(T(5)), 3) << \"value = \" << T(5);\n+  EXPECT_EQ(ceil_log2(T(6)), 3) << \"value = \" << T(6);\n+  EXPECT_EQ(ceil_log2(T(7)), 3) << \"value = \" << T(7);\n+  EXPECT_EQ(ceil_log2(T(8)), 3) << \"value = \" << T(8);\n+  EXPECT_EQ(ceil_log2(T(9)), 4) << \"value = \" << T(9);\n+  EXPECT_EQ(ceil_log2(T(10)), 4) << \"value = \" << T(10);\n+\n+  \/\/ Test max values\n+  if (std::is_unsigned<T>::value) {\n+    EXPECT_EQ(ceil_log2(std::numeric_limits<T>::max()),\n+            (int)(sizeof(T) * 8)) << \"value = \" << std::numeric_limits<T>::max();\n+  } else {\n+    EXPECT_EQ(ceil_log2(std::numeric_limits<T>::max()),\n+            (int)(sizeof(T) * 8 - 1)) << \"value = \" << std::numeric_limits<T>::max();\n+  }\n+}\n+\n+TEST(power_of_2, ceil_log2) {\n+  test_ceil_log2<int8_t>();\n+  test_ceil_log2<int16_t>();\n+  test_ceil_log2<int32_t>();\n+  test_ceil_log2<int64_t>();\n+  test_ceil_log2<uint8_t>();\n+  test_ceil_log2<uint16_t>();\n+  test_ceil_log2<uint32_t>();\n+  test_ceil_log2<uint64_t>();\n+}\n+\n+#ifdef ASSERT\n+TEST_VM_ASSERT_MSG(power_of_2, ceil_log2_invalid,\n+    \".*Invalid value\") {\n+  ceil_log2(0);\n+}\n+\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/utilities\/test_powerOfTwo.cpp","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"}]}