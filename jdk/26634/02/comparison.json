{"files":[{"patch":"@@ -1938,1 +1938,1 @@\n-                TemporalField field = FIELD_MAP.get(cur);\n+                TemporalField field = getField(cur);\n@@ -2186,42 +2186,48 @@\n-    \/** Map of letters to fields. *\/\n-    private static final Map<Character, TemporalField> FIELD_MAP = new HashMap<>();\n-    static {\n-        \/\/ SDF = SimpleDateFormat\n-        FIELD_MAP.put('G', ChronoField.ERA);                       \/\/ SDF, LDML (different to both for 1\/2 chars)\n-        FIELD_MAP.put('y', ChronoField.YEAR_OF_ERA);               \/\/ SDF, LDML\n-        FIELD_MAP.put('u', ChronoField.YEAR);                      \/\/ LDML (different in SDF)\n-        FIELD_MAP.put('Q', IsoFields.QUARTER_OF_YEAR);             \/\/ LDML (removed quarter from 310)\n-        FIELD_MAP.put('q', IsoFields.QUARTER_OF_YEAR);             \/\/ LDML (stand-alone)\n-        FIELD_MAP.put('M', ChronoField.MONTH_OF_YEAR);             \/\/ SDF, LDML\n-        FIELD_MAP.put('L', ChronoField.MONTH_OF_YEAR);             \/\/ SDF, LDML (stand-alone)\n-        FIELD_MAP.put('D', ChronoField.DAY_OF_YEAR);               \/\/ SDF, LDML\n-        FIELD_MAP.put('d', ChronoField.DAY_OF_MONTH);              \/\/ SDF, LDML\n-        FIELD_MAP.put('F', ChronoField.ALIGNED_WEEK_OF_MONTH);     \/\/ SDF, LDML\n-        FIELD_MAP.put('E', ChronoField.DAY_OF_WEEK);               \/\/ SDF, LDML (different to both for 1\/2 chars)\n-        FIELD_MAP.put('c', ChronoField.DAY_OF_WEEK);               \/\/ LDML (stand-alone)\n-        FIELD_MAP.put('e', ChronoField.DAY_OF_WEEK);               \/\/ LDML (needs localized week number)\n-        FIELD_MAP.put('a', ChronoField.AMPM_OF_DAY);               \/\/ SDF, LDML\n-        FIELD_MAP.put('H', ChronoField.HOUR_OF_DAY);               \/\/ SDF, LDML\n-        FIELD_MAP.put('k', ChronoField.CLOCK_HOUR_OF_DAY);         \/\/ SDF, LDML\n-        FIELD_MAP.put('K', ChronoField.HOUR_OF_AMPM);              \/\/ SDF, LDML\n-        FIELD_MAP.put('h', ChronoField.CLOCK_HOUR_OF_AMPM);        \/\/ SDF, LDML\n-        FIELD_MAP.put('m', ChronoField.MINUTE_OF_HOUR);            \/\/ SDF, LDML\n-        FIELD_MAP.put('s', ChronoField.SECOND_OF_MINUTE);          \/\/ SDF, LDML\n-        FIELD_MAP.put('S', ChronoField.NANO_OF_SECOND);            \/\/ LDML (SDF uses milli-of-second number)\n-        FIELD_MAP.put('A', ChronoField.MILLI_OF_DAY);              \/\/ LDML\n-        FIELD_MAP.put('n', ChronoField.NANO_OF_SECOND);            \/\/ 310 (proposed for LDML)\n-        FIELD_MAP.put('N', ChronoField.NANO_OF_DAY);               \/\/ 310 (proposed for LDML)\n-        FIELD_MAP.put('g', JulianFields.MODIFIED_JULIAN_DAY);\n-        \/\/ 310 - z - time-zone names, matches LDML and SimpleDateFormat 1 to 4\n-        \/\/ 310 - Z - matches SimpleDateFormat and LDML\n-        \/\/ 310 - V - time-zone id, matches LDML\n-        \/\/ 310 - v - general timezone names, not matching exactly with LDML because LDML specify to fall back\n-        \/\/           to 'VVVV' if general-nonlocation unavailable but here it's not falling back because of lack of data\n-        \/\/ 310 - p - prefix for padding\n-        \/\/ 310 - X - matches LDML, almost matches SDF for 1, exact match 2&3, extended 4&5\n-        \/\/ 310 - x - matches LDML\n-        \/\/ 310 - w, W, and Y are localized forms matching LDML\n-        \/\/ LDML - B - day periods\n-        \/\/ LDML - U - cycle year name, not supported by 310 yet\n-        \/\/ LDML - l - deprecated\n-        \/\/ LDML - j - not relevant\n+    \/**\n+     * Returns the TemporalField for the given pattern character.\n+     *\n+     * @param ch the pattern character\n+     * @return the TemporalField for the given pattern character, or null if not applicable\n+     *\/\n+    private static TemporalField getField(char ch) {\n+        return switch (ch) {\n+            case 'G' -> ChronoField.ERA;                       \/\/ SDF, LDML (different to both for 1\/2 chars)\n+            case 'y' -> ChronoField.YEAR_OF_ERA;               \/\/ SDF, LDML\n+            case 'u' -> ChronoField.YEAR;                      \/\/ LDML (different in SDF)\n+            case 'Q' -> IsoFields.QUARTER_OF_YEAR;             \/\/ LDML (removed quarter from 310)\n+            case 'q' -> IsoFields.QUARTER_OF_YEAR;             \/\/ LDML (stand-alone)\n+            case 'M' -> ChronoField.MONTH_OF_YEAR;             \/\/ SDF, LDML\n+            case 'L' -> ChronoField.MONTH_OF_YEAR;             \/\/ SDF, LDML (stand-alone)\n+            case 'D' -> ChronoField.DAY_OF_YEAR;               \/\/ SDF, LDML\n+            case 'd' -> ChronoField.DAY_OF_MONTH;              \/\/ SDF, LDML\n+            case 'F' -> ChronoField.ALIGNED_WEEK_OF_MONTH;     \/\/ SDF, LDML\n+            case 'E' -> ChronoField.DAY_OF_WEEK;               \/\/ SDF, LDML (different to both for 1\/2 chars)\n+            case 'c' -> ChronoField.DAY_OF_WEEK;               \/\/ LDML (stand-alone)\n+            case 'e' -> ChronoField.DAY_OF_WEEK;               \/\/ LDML (needs localized week number)\n+            case 'a' -> ChronoField.AMPM_OF_DAY;               \/\/ SDF, LDML\n+            case 'H' -> ChronoField.HOUR_OF_DAY;               \/\/ SDF, LDML\n+            case 'k' -> ChronoField.CLOCK_HOUR_OF_DAY;         \/\/ SDF, LDML\n+            case 'K' -> ChronoField.HOUR_OF_AMPM;              \/\/ SDF, LDML\n+            case 'h' -> ChronoField.CLOCK_HOUR_OF_AMPM;        \/\/ SDF, LDML\n+            case 'm' -> ChronoField.MINUTE_OF_HOUR;            \/\/ SDF, LDML\n+            case 's' -> ChronoField.SECOND_OF_MINUTE;          \/\/ SDF, LDML\n+            case 'S' -> ChronoField.NANO_OF_SECOND;            \/\/ LDML (SDF uses milli-of-second number)\n+            case 'A' -> ChronoField.MILLI_OF_DAY;              \/\/ LDML\n+            case 'n' -> ChronoField.NANO_OF_SECOND;            \/\/ 310 (proposed for LDML)\n+            case 'N' -> ChronoField.NANO_OF_DAY;               \/\/ 310 (proposed for LDML)\n+            case 'g' -> JulianFields.MODIFIED_JULIAN_DAY;\n+            default -> null;\n+            \/\/ 310 - z - time-zone names, matches LDML and SimpleDateFormat 1 to 4\n+            \/\/ 310 - Z - matches SimpleDateFormat and LDML\n+            \/\/ 310 - V - time-zone id, matches LDML\n+            \/\/ 310 - v - general timezone names, not matching exactly with LDML because LDML specify to fall back\n+            \/\/           to 'VVVV' if general-nonlocation unavailable but here it's not falling back because of lack of data\n+            \/\/ 310 - p - prefix for padding\n+            \/\/ 310 - X - matches LDML, almost matches SDF for 1, exact match 2&3, extended 4&5\n+            \/\/ 310 - x - matches LDML\n+            \/\/ 310 - w, W, and Y are localized forms matching LDML\n+            \/\/ LDML - B - day periods\n+            \/\/ LDML - U - cycle year name, not supported by 310 yet\n+            \/\/ LDML - l - deprecated\n+            \/\/ LDML - j - not relevant\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":49,"deletions":43,"binary":false,"changes":92,"status":"modified"}]}