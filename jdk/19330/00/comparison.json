{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,8 +92,0 @@\n-    \/**\n-     * {@return the UTF8 constant pool entry at the given index of the constant\n-     * pool}  The given index must correspond to a valid constant pool index\n-     * whose slot holds a UTF8 constant.\n-     * @param index the index into the constant pool\n-     *\/\n-    Utf8Entry utf8EntryByIndex(int index);\n-\n@@ -103,0 +95,5 @@\n+     *\n+     * @apiNote\n+     * If only a particular type of entry is expected, use {@link #readEntry(\n+     * int, Class) readEntry(int, Class)}.\n+     *\n@@ -124,0 +121,5 @@\n+     *\n+     * @apiNote\n+     * If only a particular type of entry is expected, use {@link #readEntryOrNull(\n+     * int, Class) readEntryOrNull(int, Class)}.\n+     *\n@@ -130,0 +132,14 @@\n+    \/**\n+     * {@return the constant pool entry of a given type whose index is given\n+     * at the specified offset within the classfile, or null if the index at\n+     * the specified offset is zero}\n+     *\n+     * @param <T> the entry type\n+     * @param offset the offset of the index within the classfile\n+     * @param cls the entry type\n+     * @throws ConstantPoolException if the index is out of range of the\n+     *         constant pool size, or zero, or the entry is not of the given type\n+     * @since 24\n+     *\/\n+    <T extends PoolEntry> T readEntryOrNull(int offset, Class<T> cls);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassReader.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,4 @@\n+     * @apiNote\n+     * If only a particular type of entry is expected, use {@link #entryByIndex(\n+     * int, Class) entryByIndex(int, Class)}.\n+     *\n@@ -60,0 +64,12 @@\n+    \/**\n+     * {@return the entry of a given type at the specified index}\n+     *\n+     * @param <T> the entry type\n+     * @param index the index within the pool of the desired entry\n+     * @param cls the entry type\n+     * @throws ConstantPoolException if the index is out of range of the\n+     *         constant pool, or the entry is not of the given type\n+     * @since 24\n+     *\/\n+    <T extends PoolEntry> T entryByIndex(int index, Class<T> cls);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPool.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-            nameEntry = (Utf8Entry) code.constantPool().entryByIndex(nameIndex());\n+            nameEntry = code.constantPool().entryByIndex(nameIndex(), Utf8Entry.class);\n@@ -59,1 +59,1 @@\n-            secondaryEntry = (Utf8Entry) code.constantPool().entryByIndex(secondaryIndex());\n+            secondaryEntry = code.constantPool().entryByIndex(secondaryIndex(), Utf8Entry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractBoundLocalVariable.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -690,2 +690,1 @@\n-            return (LoadableConstantEntry)\n-                    code.classReader.entryByIndex(op == Opcode.LDC\n+            return code.classReader.entryByIndex(op == Opcode.LDC\n@@ -693,1 +692,2 @@\n-                                                  : code.classReader.readU2(pos + 1));\n+                                                  : code.classReader.readU2(pos + 1),\n+                            LoadableConstantEntry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,1 +130,1 @@\n-        Utf8Entry annotationClass = classReader.utf8EntryByIndex(classReader.readU2(p));\n+        Utf8Entry annotationClass = classReader.entryByIndex(classReader.readU2(p), Utf8Entry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -633,1 +633,1 @@\n-                            (Utf8Entry) classReader.readEntryOrNull(p + 4));\n+                            classReader.readEntryOrNull(p + 4, Utf8Entry.class));\n@@ -772,9 +772,3 @@\n-                    ClassEntry innerClass = classReader.readClassEntry(p); \/\/ TODO FIXME\n-                    int outerClassIndex = classReader.readU2(p + 2);\n-                    ClassEntry outerClass = outerClassIndex == 0\n-                            ? null\n-                            : (ClassEntry) classReader.entryByIndex(outerClassIndex);\n-                    int innerNameIndex = classReader.readU2(p + 4);\n-                    Utf8Entry innerName = innerNameIndex == 0\n-                            ? null\n-                            : (Utf8Entry) classReader.entryByIndex(innerNameIndex);\n+                    ClassEntry innerClass = classReader.readClassEntry(p);\n+                    var outerClass = classReader.readEntryOrNull(p + 2, ClassEntry.class);\n+                    var innerName = classReader.readEntryOrNull(p + 4, Utf8Entry.class);\n@@ -804,1 +798,1 @@\n-            return Optional.ofNullable((NameAndTypeEntry) classReader.readEntryOrNull(payloadStart + 2));\n+            return Optional.ofNullable(classReader.readEntryOrNull(payloadStart + 2, NameAndTypeEntry.class));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -31,0 +33,1 @@\n+import java.util.Objects;\n@@ -161,2 +164,1 @@\n-            int scIndex = readU2(thisClassPos + 2);\n-            superclass = Optional.ofNullable(scIndex == 0 ? null : (ClassEntry) entryByIndex(scIndex));\n+            superclass = Optional.ofNullable(readEntryOrNull(thisClassPos + 2, ClassEntry.class));\n@@ -342,1 +344,36 @@\n-        return entryByIndex(index, 0, 0xff);\n+        return entryByIndex(index, PoolEntry.class);\n+    }\n+\n+    private static final @Stable Class<?>[] TAG_TO_TYPE;\n+    private static final int TAG_TABLE_SIZE = 32;\n+\n+    static {\n+        @SuppressWarnings(\"unchecked\")\n+        var a = (Class<? extends PoolEntry>[]) new Class<?>[TAG_TABLE_SIZE];\n+        \/\/ JVMS Table 4.4-B. Constant pool tags\n+        a[1] = AbstractPoolEntry.Utf8EntryImpl.class;\n+        a[3] = AbstractPoolEntry.IntegerEntryImpl.class;\n+        a[4] = AbstractPoolEntry.FloatEntryImpl.class;\n+        a[5] = AbstractPoolEntry.LongEntryImpl.class;\n+        a[6] = AbstractPoolEntry.DoubleEntryImpl.class;\n+        a[7] = AbstractPoolEntry.ClassEntryImpl.class;\n+        a[8] = AbstractPoolEntry.StringEntryImpl.class;\n+        a[9] = AbstractPoolEntry.FieldRefEntryImpl.class;\n+        a[10] = AbstractPoolEntry.MethodRefEntryImpl.class;\n+        a[11] = AbstractPoolEntry.InterfaceMethodRefEntryImpl.class;\n+        a[12] = AbstractPoolEntry.NameAndTypeEntryImpl.class;\n+        a[15] = AbstractPoolEntry.MethodHandleEntryImpl.class;\n+        a[16] = AbstractPoolEntry.MethodTypeEntryImpl.class;\n+        a[17] = AbstractPoolEntry.ConstantDynamicEntryImpl.class;\n+        a[18] = AbstractPoolEntry.InvokeDynamicEntryImpl.class;\n+        a[19] = AbstractPoolEntry.ModuleEntryImpl.class;\n+        a[20] = AbstractPoolEntry.PackageEntryImpl.class;\n+        TAG_TO_TYPE = a;\n+    }\n+\n+    private static boolean checkTag(int tag, Class<?> cls) {\n+        if (0 <= tag && tag < TAG_TABLE_SIZE) {\n+            var type = TAG_TO_TYPE[tag];\n+            return type != null && cls.isAssignableFrom(type);\n+        }\n+        return false;\n@@ -345,1 +382,3 @@\n-    private PoolEntry entryByIndex(int index, int lowerBoundTag, int upperBoundTag) {\n+    @Override\n+    public <T extends PoolEntry> T entryByIndex(int index, Class<T> cls) {\n+        Objects.requireNonNull(cls);\n@@ -356,1 +395,1 @@\n-            if (tag < lowerBoundTag || tag > upperBoundTag) {\n+            if (!checkTag(tag, cls)) {\n@@ -358,1 +397,1 @@\n-                        \"Bad tag (\" + tag + \") at index (\" + index + \") position (\" + offset + \")\");\n+                        \"Bad tag (\" + tag + \") at index (\" + index + \") position (\" + offset + \"), expected \" + cls.getSimpleName());\n@@ -378,1 +417,1 @@\n-                                                                                     readEntry(q + 1, AbstractPoolEntry.AbstractMemberRefEntry.class, TAG_FIELDREF, TAG_INTERFACEMETHODREF));\n+                                                                                     readEntry(q + 1, AbstractPoolEntry.AbstractMemberRefEntry.class));\n@@ -389,9 +428,1 @@\n-        return info;\n-    }\n-\n-    @Override\n-    public AbstractPoolEntry.Utf8EntryImpl utf8EntryByIndex(int index) {\n-        if (entryByIndex(index, TAG_UTF8, TAG_UTF8) instanceof AbstractPoolEntry.Utf8EntryImpl utf8) {\n-            return utf8;\n-        }\n-        throw new ConstantPoolException(\"Not a UTF8 - index: \" + index);\n+        return checkType(info, index, cls);\n@@ -423,1 +454,1 @@\n-        return readEntry(pos, cls, 0, 0xff);\n+        return entryByIndex(readU2(pos), cls);\n@@ -426,6 +457,1 @@\n-    private <T extends PoolEntry> T readEntry(int pos, Class<T> cls, int expectedTag) {\n-        return readEntry(pos, cls, expectedTag, expectedTag);\n-    }\n-\n-    private <T extends PoolEntry> T readEntry(int pos, Class<T> cls, int lowerBoundTag, int upperBoundTag) {\n-        var e = entryByIndex(readU2(pos), lowerBoundTag, upperBoundTag);\n+    static <T extends PoolEntry> T checkType(PoolEntry e, int index, Class<T> cls) {\n@@ -433,1 +459,1 @@\n-        throw new ConstantPoolException(\"Not a \" + cls.getSimpleName() + \" at index: \" + readU2(pos));\n+        throw new ConstantPoolException(\"Not a \" + cls.getSimpleName() + \" at index: \" + index);\n@@ -445,0 +471,9 @@\n+    @Override\n+    public <T extends PoolEntry> T readEntryOrNull(int offset, Class<T> cls) {\n+        int index = readU2(offset);\n+        if (index == 0)\n+            return null;\n+\n+        return entryByIndex(index, cls);\n+    }\n+\n@@ -448,1 +483,1 @@\n-        return utf8EntryByIndex(index);\n+        return entryByIndex(index, Utf8Entry.class);\n@@ -457,1 +492,1 @@\n-        return utf8EntryByIndex(index);\n+        return entryByIndex(index, Utf8Entry.class);\n@@ -462,1 +497,1 @@\n-        return readEntry(pos, ModuleEntry.class, TAG_MODULE);\n+        return entryByIndex(readU2(pos), ModuleEntry.class);\n@@ -467,1 +502,1 @@\n-        return readEntry(pos, PackageEntry.class, TAG_PACKAGE);\n+        return entryByIndex(readU2(pos), PackageEntry.class);\n@@ -472,1 +507,1 @@\n-        return readEntry(pos, ClassEntry.class, TAG_CLASS);\n+        return entryByIndex(readU2(pos), ClassEntry.class);\n@@ -477,1 +512,1 @@\n-        return readEntry(pos, NameAndTypeEntry.class, TAG_NAMEANDTYPE);\n+        return entryByIndex(readU2(pos), NameAndTypeEntry.class);\n@@ -482,1 +517,1 @@\n-        return readEntry(pos, MethodHandleEntry.class, TAG_METHODHANDLE);\n+        return entryByIndex(readU2(pos), MethodHandleEntry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":66,"deletions":31,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-                                                             : (ClassEntry) constantPool().entryByIndex(c);\n+                                                             : constantPool().entryByIndex(c, ClassEntry.class);\n@@ -340,1 +340,1 @@\n-                                                    : (ClassEntry) classReader.entryByIndex(c);\n+                                                    : classReader.entryByIndex(c, ClassEntry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.util.Objects;\n@@ -117,0 +116,5 @@\n+    @Override\n+    public <T extends PoolEntry> T entryByIndex(int index, Class<T> cls) {\n+        return ClassReaderImpl.checkType(entryByIndex(index), index, cls);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-                        var tk = TypeKind.fromDescriptor(((MemberRefEntry)cp.entryByIndex(bcs.getIndexU2())).nameAndType().type().stringValue());\n+                        var tk = TypeKind.fromDescriptor(cp.entryByIndex(bcs.getIndexU2(), MemberRefEntry.class).nameAndType().type());\n@@ -371,1 +371,1 @@\n-                addStackSlot(((ConstantDynamicEntry)cp.entryByIndex(index)).typeKind().slotSize());\n+                addStackSlot(cp.entryByIndex(index, ConstantDynamicEntry.class).typeKind().slotSize());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -234,1 +234,1 @@\n-            case VT_OBJECT -> new ObjectVerificationTypeInfoImpl((ClassEntry)classReader.entryByIndex(u2()));\n+            case VT_OBJECT -> new ObjectVerificationTypeInfoImpl(classReader.entryByIndex(u2(), ClassEntry.class));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.classfile.constantpool.InvokeDynamicEntry;\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n@@ -400,1 +402,1 @@\n-        return Type.referenceType(((ClassEntry)cp.entryByIndex(index)).asSymbol());\n+        return Type.referenceType(cp.entryByIndex(index, ClassEntry.class).asSymbol());\n@@ -703,1 +705,1 @@\n-                currentFrame.pushStack(((ConstantDynamicEntry)cp.entryByIndex(index)).asSymbol().constantType());\n+                currentFrame.pushStack(cp.entryByIndex(index, ConstantDynamicEntry.class).asSymbol().constantType());\n@@ -750,1 +752,1 @@\n-        var desc = Util.fieldTypeSymbol(((MemberRefEntry)cp.entryByIndex(bcs.getIndexU2())).nameAndType());\n+        var desc = Util.fieldTypeSymbol(cp.entryByIndex(bcs.getIndexU2(), MemberRefEntry.class).nameAndType());\n@@ -774,2 +776,3 @@\n-        var cpe = cp.entryByIndex(index);\n-        var nameAndType = opcode == INVOKEDYNAMIC ? ((DynamicConstantPoolEntry)cpe).nameAndType() : ((MemberRefEntry)cpe).nameAndType();\n+        var nameAndType = opcode == INVOKEDYNAMIC\n+                ? cp.entryByIndex(index, InvokeDynamicEntry.class).nameAndType()\n+                : cp.entryByIndex(index, MemberRefEntry.class).nameAndType();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,0 +173,5 @@\n+    @Override\n+    public <T extends PoolEntry> T entryByIndex(int index, Class<T> cls) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TemporaryConstantPool.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,1 +169,1 @@\n-            return ((ClassEntry)cp.entryByIndex(index)).asInternalName();\n+            return cp.entryByIndex(index, ClassEntry.class).asInternalName();\n@@ -173,1 +173,1 @@\n-            return ((DynamicConstantPoolEntry)cp.entryByIndex(index)).type().stringValue();\n+            return cp.entryByIndex(index, DynamicConstantPoolEntry.class).type().stringValue();\n@@ -195,1 +195,1 @@\n-            return ((MemberRefEntry)cp.entryByIndex(index)).owner().index();\n+            return cp.entryByIndex(index, MemberRefEntry.class).owner().index();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationWrapper.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}