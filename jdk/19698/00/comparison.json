{"files":[{"patch":"@@ -2791,0 +2791,126 @@\n+\/\/ Look up the method for a megamorphic invokeinterface call in a single pass over itable:\n+\/\/ - check recv_klass (actual object class) is a subtype of resolved_klass from CompiledICHolder\n+\/\/ - find a holder_klass (class that implements the method) vtable offset and get the method from vtable by index\n+\/\/ The target method is determined by <holder_klass, itable_index>.\n+\/\/ The receiver klass is in recv_klass.\n+\/\/ On success, the result will be in method_result, and execution falls through.\n+\/\/ On failure, execution transfers to the given label.\n+void MacroAssembler::lookup_interface_method_stub(Register recv_klass,\n+                                                  Register holder_klass,\n+                                                  Register resolved_klass,\n+                                                  Register method_result,\n+                                                  Register temp_itbl_klass,\n+                                                  Register scan_temp,\n+                                                  int itable_index,\n+                                                  Label& L_no_such_interface) {\n+  \/\/ 'method_result' is only used as output register at the very end of this method.\n+  \/\/ Until then, we can reuse it as 'holder_offset'.\n+  Register holder_offset = method_result;\n+\n+  assert_different_registers(resolved_klass, recv_klass, holder_klass, temp_itbl_klass, scan_temp, holder_offset);\n+\n+  BLOCK_COMMENT(\"lookup_interface_method_stub {\");\n+\n+  int vtable_start_offset = in_bytes(Klass::vtable_start_offset());\n+  int itable_offset_entry_size = itableOffsetEntry::size() * wordSize;\n+  int ioffset = in_bytes(itableOffsetEntry::interface_offset());\n+  int ooffset = in_bytes(itableOffsetEntry::offset_offset());\n+\n+  Label L_loop_search_resolved_entry, L_resolved_found, L_holder_found;\n+\n+  z_llgf(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));\n+  add2reg(recv_klass, vtable_start_offset + ioffset);\n+\n+  \/\/ itableOffsetEntry[] itable = recv_klass + Klass::vtable_start_offset() + sizeof(vtableEntry) * recv_klass->_vtable_len;\n+  \/\/ temp_itbl_klass = itable[0]._interface;\n+  int vtblEntrySize = vtableEntry::size_in_bytes();\n+  z_sllg(scan_temp, scan_temp, exact_log2(vtblEntrySize));\n+  z_lg(temp_itbl_klass, Address(recv_klass, scan_temp));\n+\n+  z_lghi(holder_offset, 0);\n+\n+  \/\/ scan_temp = &(itable[0]._interface)\n+  z_la(scan_temp, Address(recv_klass, scan_temp));\n+\n+  \/\/ Initial checks:\n+  \/\/   - if (holder_klass != resolved_klass), go to \"scan for resolved\"\n+  \/\/   - if (itable[0] == holder_klass), shortcut to \"holder found\"\n+  \/\/   - if (itable[0] == 0), no such interface\n+  z_cgr(holder_klass, resolved_klass);\n+  z_brne(L_loop_search_resolved_entry);\n+\n+  z_cgr(temp_itbl_klass, holder_klass);\n+  z_bre(L_holder_found);\n+\n+  z_cghi(temp_itbl_klass, 0);\n+  branch_optimized(bcondEqual, L_no_such_interface);\n+\n+  \/\/ Loop: Look for holder_klass record in itable\n+  \/\/   do {\n+  \/\/     temp_itbl_klass = *(scan_temp);\n+  \/\/     if (temp_itbl_klass == holder_klass) {\n+  \/\/       goto holder_found; \/\/ Found!\n+  \/\/     }\n+  \/\/     scan_temp += itable_offset_entry_size\n+  \/\/   } while (temp_itbl_klass != 0);\n+  \/\/   goto no_such_interface \/\/ Not found.\n+  NearLabel L_search_holder;\n+  bind(L_search_holder);\n+  add2reg(scan_temp, itable_offset_entry_size);\n+  z_lg(temp_itbl_klass, Address(scan_temp));\n+  z_cgr(temp_itbl_klass, holder_klass);\n+  z_bre(L_holder_found);\n+  z_cghi(temp_itbl_klass, 0);\n+  z_brne(L_search_holder);\n+\n+  z_bru(L_no_such_interface); \/\/ not found, we're done here\n+\n+  \/\/ Loop: Look for resolved_class record in itable\n+  \/\/   while (true) {\n+  \/\/     temp_itbl_klass = *(scan_temp);\n+  \/\/     scan_temp += itable_offset_entry_size\n+  \/\/     if (temp_itbl_klass == 0) {\n+  \/\/       goto L_no_such_interface;\n+  \/\/     }\n+  \/\/     if (temp_itbl_klass == resolved_klass) {\n+  \/\/        goto L_resolved_found;  \/\/ Found!\n+  \/\/     }\n+  \/\/     if (temp_itbl_klass == holder_klass) {\n+  \/\/        holder_offset = scan_temp;\n+  \/\/     }\n+  \/\/   }\n+  \/\/\n+  NearLabel L_loop_search_resolved;\n+  bind(L_loop_search_resolved);\n+  add2reg(scan_temp, itable_offset_entry_size);\n+\n+  z_lg(temp_itbl_klass, Address(scan_temp));\n+\n+  bind(L_loop_search_resolved_entry);\n+\n+  z_cghi(temp_itbl_klass, 0);\n+  branch_optimized(bcondEqual, L_no_such_interface);\n+\n+  z_cgr(temp_itbl_klass, resolved_klass);\n+  z_bre(L_resolved_found);\n+\n+  z_cgr(temp_itbl_klass, holder_klass);\n+  z_brne(L_loop_search_resolved);\n+  z_lgr(holder_offset, scan_temp);\n+\n+  z_bru(L_loop_search_resolved);\n+\n+  bind(L_resolved_found);\n+  z_cghi(holder_offset, 0);\n+  z_bre(L_search_holder);\n+  z_lgr(scan_temp, holder_offset);\n+\n+  \/\/ Finally, scan_temp contains holder_klass vtable offset\n+  bind(L_holder_found);\n+  z_llgf(method_result, Address(scan_temp, ooffset - ioffset));\n+  add2reg(recv_klass, itable_index * wordSize + in_bytes(itableMethodEntry::method_offset())\n+    - vtable_start_offset - ioffset); \/\/ subtract offsets to restore the original value of recv_klass\n+  z_lg(method_result, Address(recv_klass, method_result));\n+  BLOCK_COMMENT(\"} lookup_interface_method_stub\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -673,0 +673,9 @@\n+  void lookup_interface_method_stub(Register r_recv_klass,\n+                                    Register r_holder_klass,\n+                                    Register r_resolved_klass,\n+                                    Register r_method_result,\n+                                    Register r_temp,\n+                                    Register r_temp2,\n+                                    int      itable_index,\n+                                    Label&   nl_no_such_interface);\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -188,1 +188,1 @@\n-  \/\/  Z_method: Interface\n+  \/\/  Z_method: CompiledICData\n@@ -191,2 +191,7 @@\n-  const Register rcvr_klass = Z_tmp_1,\n-                 interface  = Z_tmp_2;\n+  const Register recv_klass     = Z_tmp_1,\n+                 holder_klass   = Z_tmp_2, \/\/ declaring interface klass (DEFC)\n+                 resolved_klass = Z_tmp_3, \/\/ resolved interface klass (REFC)\n+                 temp           = Z_R1_scratch,\n+                 temp2          = Z_tmp_4;\n+\n+\n@@ -197,1 +202,1 @@\n-  __ load_klass(rcvr_klass, Z_ARG1);\n+  __ load_klass(recv_klass, Z_ARG1);\n@@ -199,4 +204,2 @@\n-  \/\/ Receiver subtype check against REFC.\n-  __ z_lg(interface, Address(Z_method, CompiledICData::itable_refc_klass_offset()));\n-  __ lookup_interface_method(rcvr_klass, interface, noreg,\n-                             noreg, Z_R1, no_such_interface, \/*return_method=*\/ false);\n+  __ z_lg(holder_klass, Address(Z_method, CompiledICData::itable_defc_klass_offset()));\n+  __ z_lg(resolved_klass, Address(Z_method, CompiledICData::itable_refc_klass_offset()));\n@@ -204,4 +207,2 @@\n-  \/\/ Get Method* and entrypoint for compiler\n-  __ z_lg(interface, Address(Z_method, CompiledICData::itable_defc_klass_offset()));\n-  __ lookup_interface_method(rcvr_klass, interface, itable_index,\n-                             Z_method, Z_R1, no_such_interface, \/*return_method=*\/ true);\n+  __ lookup_interface_method_stub(recv_klass, holder_klass, resolved_klass, Z_method,\n+                                  temp, temp2, itable_index, no_such_interface);\n@@ -211,1 +212,0 @@\n-    NearLabel ok1;\n@@ -213,3 +213,1 @@\n-    __ z_brne(ok1);\n-    __ stop(\"method is null\", 103);\n-    __ bind(ok1);\n+    __ asm_assert(Assembler::bcondNotEqual, \"method is null\", 103); \/\/ Z_method should be NE to 0\n","filename":"src\/hotspot\/cpu\/s390\/vtableStubs_s390.cpp","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"}]}