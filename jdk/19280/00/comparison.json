{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-void Compiler::init_c1_runtime() {\n+bool Compiler::init_c1_runtime() {\n@@ -53,1 +53,1 @@\n-  Runtime1::initialize(buffer_blob);\n+  if (!Runtime1::initialize(buffer_blob)) return false;\n@@ -61,0 +61,1 @@\n+  return true;\n@@ -69,1 +70,1 @@\n-    if (buffer_blob == nullptr) {\n+    if (buffer_blob == nullptr || !init_c1_runtime()) {\n@@ -74,1 +75,0 @@\n-      init_c1_runtime();\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-  static void init_c1_runtime();\n+  static bool init_c1_runtime();\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -235,2 +235,2 @@\n-                                                 must_gc_arguments);\n-  assert(blob != nullptr, \"blob must exist\");\n+                                                 must_gc_arguments,\n+                                                 false);\n@@ -240,1 +240,1 @@\n-void Runtime1::generate_blob_for(BufferBlob* buffer_blob, StubID id) {\n+bool Runtime1::generate_blob_for(BufferBlob* buffer_blob, StubID id) {\n@@ -262,0 +262,1 @@\n+  return blob != nullptr;\n@@ -264,1 +265,1 @@\n-void Runtime1::initialize(BufferBlob* blob) {\n+bool Runtime1::initialize(BufferBlob* blob) {\n@@ -268,1 +269,3 @@\n-  for (int id = 0; id < number_of_ids; id++) generate_blob_for(blob, (StubID)id);\n+  for (int id = 0; id < number_of_ids; id++) {\n+    if (!generate_blob_for(blob, (StubID) id)) return false;\n+  }\n@@ -283,0 +286,1 @@\n+  return true;\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-  static void       generate_blob_for(BufferBlob* blob, StubID id);\n+  static bool       generate_blob_for(BufferBlob* blob, StubID id);\n@@ -169,1 +169,1 @@\n-  static void initialize(BufferBlob* blob);\n+  static bool initialize(BufferBlob* blob);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3468,0 +3468,1 @@\n+                                                      false,\n@@ -3469,3 +3470,5 @@\n-      assert(rs != nullptr && rs->is_runtime_stub(), \"sanity check\");\n-\n-      C->set_stub_entry_point(rs->entry_point());\n+      if (rs == nullptr) {\n+        C->record_failure(\"CodeCache is full\");\n+      } else {\n+        C->set_stub_entry_point(rs->entry_point());\n+      }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -79,2 +79,0 @@\n-compiler\/startup\/StartupOutput.java 8326615 generic-x64\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}