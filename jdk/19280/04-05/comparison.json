{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-bool Compiler::init_c1_runtime() {\n+void Compiler::init_c1_runtime() {\n@@ -53,3 +53,1 @@\n-  if (!Runtime1::initialize(buffer_blob)) {\n-    return false;\n-  }\n+  Runtime1::initialize(buffer_blob);\n@@ -63,1 +61,0 @@\n-  return true;\n@@ -72,1 +69,1 @@\n-    if (buffer_blob == nullptr || !init_c1_runtime()) {\n+    if (buffer_blob == nullptr) {\n@@ -77,0 +74,1 @@\n+      init_c1_runtime();\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-  static bool init_c1_runtime();\n+  static void init_c1_runtime();\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -235,2 +235,2 @@\n-                                                 must_gc_arguments,\n-                                                 false);\n+                                                 must_gc_arguments);\n+  assert(blob != nullptr, \"blob must exist\");\n@@ -240,1 +240,1 @@\n-bool Runtime1::generate_blob_for(BufferBlob* buffer_blob, StubID id) {\n+void Runtime1::generate_blob_for(BufferBlob* buffer_blob, StubID id) {\n@@ -262,1 +262,0 @@\n-  return blob != nullptr;\n@@ -265,1 +264,1 @@\n-bool Runtime1::initialize(BufferBlob* blob) {\n+void Runtime1::initialize(BufferBlob* blob) {\n@@ -269,5 +268,1 @@\n-  for (int id = 0; id < number_of_ids; id++) {\n-    if (!generate_blob_for(blob, (StubID) id)) {\n-      return false;\n-    }\n-  }\n+  for (int id = 0; id < number_of_ids; id++) generate_blob_for(blob, (StubID)id);\n@@ -287,1 +282,1 @@\n-  return bs->generate_c1_runtime_stubs(blob);\n+  bs->generate_c1_runtime_stubs(blob);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-  static bool       generate_blob_for(BufferBlob* blob, StubID id);\n+  static void       generate_blob_for(BufferBlob* blob, StubID id);\n@@ -169,1 +169,1 @@\n-  static bool initialize(BufferBlob* blob);\n+  static void initialize(BufferBlob* blob);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-  const size_t min_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3); \/\/ Make sure we have enough space for VM internal code\n+  const size_t min_cache_size = CompilerConfig::min_code_cache_size(); \/\/ Make sure we have enough space for VM internal code\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-      int max_count = (ReservedCodeCacheSize - (CodeCacheMinimumUseSpace DEBUG_ONLY(* 3))) \/ (int)buffer_size;\n+      int max_count = (int)CompilerConfig::min_code_cache_size() \/ (int)buffer_size;\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,2 +478,1 @@\n-  \/\/ Template Interpreter code is approximately 3X larger in debug builds.\n-  uint min_code_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3);\n+  size_t min_code_cache_size = CompilerConfig::min_code_cache_size();\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -168,0 +168,2 @@\n+  inline static size_t min_code_cache_size();\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"c1\/c1_Compiler.hpp\"\n+#include \"opto\/c2compiler.hpp\"\n@@ -135,0 +137,9 @@\n+inline size_t CompilerConfig::min_code_cache_size() {\n+  size_t min_code_cache_size = CodeCacheMinimumUseSpace;\n+  COMPILER1_PRESENT(min_code_cache_size += Compiler::code_buffer_size());\n+  COMPILER2_PRESENT(min_code_cache_size += C2Compiler::initial_code_buffer_size());\n+  \/\/ Template Interpreter code is approximately 3X larger in debug builds.\n+  DEBUG_ONLY(min_code_cache_size *= 3);\n+  return min_code_cache_size;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.inline.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -219,1 +219,1 @@\n-bool G1BarrierSetC1::generate_c1_runtime_stubs(BufferBlob* buffer_blob) {\n+void G1BarrierSetC1::generate_c1_runtime_stubs(BufferBlob* buffer_blob) {\n@@ -226,1 +226,0 @@\n-  return _pre_barrier_c1_runtime_code_blob != nullptr && _post_barrier_c1_runtime_code_blob != nullptr;\n","filename":"src\/hotspot\/share\/gc\/g1\/c1\/g1BarrierSetC1.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-  virtual bool generate_c1_runtime_stubs(BufferBlob* buffer_blob);\n+  virtual void generate_c1_runtime_stubs(BufferBlob* buffer_blob);\n","filename":"src\/hotspot\/share\/gc\/g1\/c1\/g1BarrierSetC1.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,1 +138,1 @@\n-  virtual bool generate_c1_runtime_stubs(BufferBlob* buffer_blob) { return true; }\n+  virtual void generate_c1_runtime_stubs(BufferBlob* buffer_blob) {}\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/barrierSetC1.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,1 +267,1 @@\n-bool ShenandoahBarrierSetC1::generate_c1_runtime_stubs(BufferBlob* buffer_blob) {\n+void ShenandoahBarrierSetC1::generate_c1_runtime_stubs(BufferBlob* buffer_blob) {\n@@ -270,1 +269,0 @@\n-  bool reference_barrier_success = true;\n@@ -294,4 +292,0 @@\n-    reference_barrier_success = _load_reference_barrier_strong_rt_code_blob != nullptr &&\n-                                _load_reference_barrier_strong_native_rt_code_blob != nullptr &&\n-                                _load_reference_barrier_weak_rt_code_blob != nullptr &&\n-                                _load_reference_barrier_phantom_rt_code_blob != nullptr;\n@@ -299,1 +293,0 @@\n-  return _pre_barrier_c1_runtime_code_blob != nullptr && reference_barrier_success;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -250,1 +249,1 @@\n-  virtual bool generate_c1_runtime_stubs(BufferBlob* buffer_blob);\n+  virtual void generate_c1_runtime_stubs(BufferBlob* buffer_blob);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-  return (code_blob != nullptr) ? code_blob->code_begin() : nullptr;\n+  return code_blob->code_begin();\n@@ -232,1 +232,1 @@\n-bool XBarrierSetC1::generate_c1_runtime_stubs(BufferBlob* blob) {\n+void XBarrierSetC1::generate_c1_runtime_stubs(BufferBlob* blob) {\n@@ -237,2 +237,0 @@\n-  return _load_barrier_on_oop_field_preloaded_runtime_stub != nullptr &&\n-         _load_barrier_on_weak_oop_field_preloaded_runtime_stub != nullptr;\n","filename":"src\/hotspot\/share\/gc\/x\/c1\/xBarrierSetC1.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-  virtual bool generate_c1_runtime_stubs(BufferBlob* blob);\n+  virtual void generate_c1_runtime_stubs(BufferBlob* blob);\n","filename":"src\/hotspot\/share\/gc\/x\/c1\/xBarrierSetC1.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -511,1 +511,1 @@\n-  return (code_blob != nullptr) ? code_blob->code_begin() : nullptr;\n+  return code_blob->code_begin();\n@@ -531,1 +531,1 @@\n-  return (code_blob != nullptr) ? code_blob->code_begin() : nullptr;\n+  return code_blob->code_begin();\n@@ -534,1 +534,1 @@\n-bool ZBarrierSetC1::generate_c1_runtime_stubs(BufferBlob* blob) {\n+void ZBarrierSetC1::generate_c1_runtime_stubs(BufferBlob* blob) {\n@@ -544,4 +544,0 @@\n-  return _load_barrier_on_oop_field_preloaded_runtime_stub != nullptr &&\n-         _load_barrier_on_weak_oop_field_preloaded_runtime_stub != nullptr &&\n-         _store_barrier_on_oop_field_with_healing != nullptr &&\n-         _store_barrier_on_oop_field_without_healing != nullptr;\n","filename":"src\/hotspot\/share\/gc\/z\/c1\/zBarrierSetC1.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-  virtual bool generate_c1_runtime_stubs(BufferBlob* blob);\n+  virtual void generate_c1_runtime_stubs(BufferBlob* blob);\n","filename":"src\/hotspot\/share\/gc\/z\/c1\/zBarrierSetC1.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3468,1 +3468,0 @@\n-                                                      false,\n@@ -3470,5 +3469,3 @@\n-      if (rs == nullptr) {\n-        C->record_failure(\"CodeCache is full\");\n-      } else {\n-        C->set_stub_entry_point(rs->entry_point());\n-      }\n+      assert(rs != nullptr && rs->is_runtime_stub(), \"sanity check\");\n+\n+      C->set_stub_entry_point(rs->entry_point());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -190,2 +190,11 @@\n-        \/\/ minimum size: CodeCacheMinimumUseSpace DEBUG_ONLY(* 3)\n-        long minSize = (Platform.isDebugBuild() ? 3 : 1) * minUseSpace;\n+        long nMethodSizeLimit = WHITE_BOX.getIntxVMFlag(\"NMethodSizeLimit\");\n+        long codeEntryAlignment = WHITE_BOX.getIntxVMFlag(\"CodeEntryAlignment\");\n+        long c1MinCodeCacheSize = 11 * nMethodSizeLimit \/ 10;\n+        long c2MinCodeCacheSize = 2048 \/* PhaseOutput::MAX_inst_size *\/ +\n+                                  128 \/* PhaseOutput::MAX_stubs_size *\/ +\n+                                  4 * 1024 \/* initial_const_capacity *\/ +\n+                                  2 * Math.max(64, codeEntryAlignment) \/* 2 * CodeSection::end_slop() *\/ +\n+                                  2 * 128 \/* sizeof(relocInfo) * PhaseOutput::MAX_locs_size *\/;\n+        \/\/ minimum size: CompilerConfig::min_code_cache_size =\n+        \/\/ (CodeCacheMinimumUseSpace + Compiler::code_buffer_size() + C2Compiler::initial_code_buffer_size())) DEBUG_ONLY(* 3)\n+        long minSize = (minUseSpace + c1MinCodeCacheSize + c2MinCodeCacheSize) * (Platform.isDebugBuild() ? 3 : 1);\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckSegmentedCodeCache.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"}]}