{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"classfile\/classPrinter.hpp\"\n@@ -58,0 +59,1 @@\n+#include \"runtime\/threads.hpp\"\n@@ -170,0 +172,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VMDebugDCmd>(full_export, true, true));\n@@ -1180,0 +1183,71 @@\n+VMDebugDCmd::VMDebugDCmd(outputStream* output, bool heap) :\n+                                     DCmdWithParser(output, heap),\n+  _subcommand(\"subcommand\", \"\", \"STRING\", true, nullptr),\n+  _arg1(\"arg1\", \"\", \"STRING\", false, nullptr),\n+  _arg2(\"arg2\", \"\", \"STRING\", false, nullptr),\n+  _arg3(\"arg3\", \"\", \"STRING\", false, nullptr),\n+  _verbose(\"-verbose\", \"\", \"BOOLEAN\", false, \"false\") {\n+\n+  _dcmdparser.add_dcmd_argument(&_subcommand);\n+  _dcmdparser.add_dcmd_argument(&_arg1);\n+  _dcmdparser.add_dcmd_argument(&_arg2);\n+  _dcmdparser.add_dcmd_argument(&_arg3);\n+  _dcmdparser.add_dcmd_option(&_verbose);\n+}\n+\n+void VMDebugDCmd::find() {\n+  if (!_arg1.has_value()) {\n+    output()->print_cr(\"Usage: VM.debug find ADDRESS\");\n+  } else {\n+    intptr_t x = strtoll(_arg1.value(), nullptr, 0);\n+    if (!os::is_readable_pointer((intptr_t*) x)) {\n+      output()->print_cr(\"address not safe\");\n+    } else {\n+      if (Universe::heap()->is_in((oopDesc*) x)) {\n+        if (x != align_down(x, ObjectAlignmentInBytes)) {\n+          output()->print_cr(\"misaligned oop\");\n+          return;\n+        }\n+        if (!dbg_is_good_oop_detailed((oopDesc*) x)) {\n+          output()->print_cr(\"bad oop\");\n+          return;\n+        }\n+      }\n+      os::print_location(output(), x, _verbose.is_set());\n+    }\n+  }\n+}\n+\n+void VMDebugDCmd::execute(DCmdSource source, TRAPS) {\n+  DebuggingContext dc{}; \/\/ avoid asserts\n+\n+  if (!UnlockDiagnosticVMOptions) {\n+    output()->print_cr(\"-XX:+UnlockDiagnosticVMOptions is required\");\n+    return;\n+  }\n+  \/\/ Interpret _subcommand, using further args _arg1, etc as required.\n+  if (strcmp(\"threads\", _subcommand.value()) == 0) {\n+    char buf[1024];\n+    Threads::print_on_error(output(), THREAD, buf, sizeof(buf));\n+  } else if (strcmp(\"findclass\", _subcommand.value()) == 0) {\n+    if (!_arg1.has_value() || !_arg2.has_value()) {\n+      output()->print_cr(\"Usage: VM.debug findclass CLASS_PATTERN FLAGS\");\n+    } else {\n+      long flags = strtol(_arg2.value(), nullptr, 0);\n+      ClassPrinter::print_classes(_arg1.value(), flags, output());\n+    }\n+  } else if (strcmp(\"findmethod\", _subcommand.value()) == 0) {\n+    if (!_arg1.has_value() || !_arg2.has_value() || !_arg3.has_value()) {\n+      output()->print_cr(\"Usage: VM.debug findmethod CLASS_PATTERN METHOD_PATTERN FLAGS\");\n+    } else {\n+      long flags = strtol(_arg3.value(), nullptr, 0);\n+      ClassPrinter::print_methods(_arg1.value(), _arg2.value(), flags, output());\n+    }\n+  } else if (strcmp(\"find\", _subcommand.value()) == 0) {\n+      find();\n+  } else {\n+    output()->print_cr(\"VM.debug: unknown sub-command.\");\n+    output()->print_cr(\"%s\", description());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -579,0 +579,28 @@\n+\/\/ VM state inspection. Subcommands to provide utilities similar to debug.cpp.\n+class VMDebugDCmd: public DCmdWithParser {\n+protected:\n+  DCmdArgument<char*> _subcommand;\n+  DCmdArgument<char*> _arg1;\n+  DCmdArgument<char*> _arg2;\n+  DCmdArgument<char*> _arg3;\n+  DCmdArgument<bool> _verbose;\n+public:\n+  static int num_arguments() { return 5; }\n+  VMDebugDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"VM.debug\";\n+  }\n+  static const char* description() {\n+    return \"Inspect VM state. Requires -XX:+UnlockDiagnosticVMOptions. Subcommands: threads, find ADDRESS, findclass CLASS_PATTERN FLAGS, findmethod CLASS_PATTERN METHOD_PATTERN FLAGS\";\n+  }\n+  static const char* impact() {\n+      return \"High: not recommended for live production use.\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", nullptr};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+  void find();\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -671,0 +671,1 @@\n+\n@@ -675,0 +676,24 @@\n+\/\/ Additional \"good oop\" checks, separate method to not disturb existing asserts.\n+extern \"C\" bool dbg_is_good_oop_detailed(oopDesc* o) {\n+  bool good = dbg_is_safe(o, -1)\n+              && *(uintptr_t*) o != 0\n+              && *((uintptr_t*) o + (sizeof(uintptr_t))) != 0;\n+\n+  if (good) {\n+    if (!UseCompressedClassPointers) {\n+      good = dbg_is_safe(o->klass(), -1)\n+             && o->klass()->is_klass();\n+    } else {\n+      \/\/ Fetch compressed class pointer (no accessor for o._metadata._compressed_klass)\n+      uintptr_t ccpAddr = (uintptr_t) o + sizeof(uintptr_t);\n+      uintptr_t* ccp =  (uintptr_t*) CompressedKlassPointers::decode_raw(*(uintptr_t*) ccpAddr);\n+      good = dbg_is_safe(ccp, -1)\n+             && dbg_is_safe((void*) *ccp, -1);\n+    }\n+  }\n+  if (good) {\n+    good = good && oopDesc::is_oop(o);\n+  }\n+  return good;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -297,0 +297,1 @@\n+extern \"C\" bool dbg_is_good_oop_detailed(oopDesc* o);\n","filename":"src\/hotspot\/share\/utilities\/debug.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318026\n+ * @summary Test of diagnostic command VM.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run testng\/othervm -Dvmdebug.enabled=true -XX:+UnlockDiagnosticVMOptions VMDebugTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318026\n+ * @summary Test of diagnostic command VM.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run testng\/othervm -Dvmdebug.enabled=false VMDebugTest\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.dcmd.CommandExecutor;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+\n+import java.math.BigInteger;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class VMDebugTest {\n+\n+    \/\/ - locked <0x00000007dd0135e8> (a MyLock)\n+    static Pattern waiting_on_mylock =\n+        Pattern.compile(\"- waiting on \\\\<0x(\\\\p{XDigit}+)\\\\> \\\\(a MyLock\\\\)\");\n+\n+    \/\/  tid=0x0000153418029c20\n+    static Pattern thread_id_line =\n+        Pattern.compile(\" tid=0x(\\\\p{XDigit}+) \");\n+\n+    public void run(CommandExecutor executor) throws ClassNotFoundException {\n+        DcmdTestClass test = new DcmdTestClass();\n+        test.work();\n+        BigInteger ptr = null;\n+        OutputAnalyzer output = null;\n+\n+        \/\/ Testing VM.debug requires UnlockDiagnosticVMOptions or a debug JVM.\n+        \/\/ This test runs with a System Property set as a hint whether UnlockDiagnosticVMOptions is set.\n+        boolean enabled = Platform.isDebugBuild() || Boolean.getBoolean(\"vmdebug.enabled\");\n+        System.out.println(\"VM.debug should be enabled = \" + enabled);\n+        if (!enabled) {\n+            \/\/ Use any pointer, command should be refused:\n+            output = executor.execute(\"VM.debug find 0x0\");\n+            output.shouldContain(\"-XX:+UnlockDiagnosticVMOptions is required\");\n+            return; \/\/ no more testing\n+        }\n+\n+        \/\/ Tests with VM.debug enabled:\n+        output = executor.execute(\"help\");\n+        output.shouldNotContain(\"VM.debug\"); \/\/ debug is not promoted in help\n+        output = executor.execute(\"help VM.debug\");\n+        output.shouldContain(\"Syntax : VM.debug\"); \/\/ but help is available\n+\n+        \/\/ Test the VM.debug subcommands, without being too specific and vulnerable to format changes.\n+\n+        \/\/ Test VM.debug threads:\n+        output = executor.execute(\"VM.debug threads\");\n+        output.shouldContain(\"Threads class SMR info:\");\n+        output.shouldContain(\"Java Threads:\");\n+        output.shouldContain(\"JavaThread \\\"main\\\"\");\n+        output.shouldContain(\"VMThread \\\"VM Thread\\\"\");\n+\n+        \/\/ Test VM.debug findclass:\n+        output = executor.execute(\"VM.debug findclass\");\n+        output.shouldContain(\"Usage: VM.debug findclass \");\n+        output = executor.execute(\"VM.debug findclass java\/lang\/String 3\");\n+        output.shouldContain(\"class java\/lang\/String\");\n+\n+        \/\/ Test VM.debug findmethod:\n+        output = executor.execute(\"VM.debug findmethod\");\n+        output.shouldContain(\"Usage: VM.debug findmethod \");\n+        output = executor.execute(\"VM.debug findmethod java\/lang\/String contains 3\");\n+        output.shouldContain(\"class java\/lang\/String\");\n+\n+        \/\/ Test VM.debug find:\n+        testFind(executor);\n+    }\n+\n+    public void testFind(CommandExecutor executor) {\n+        boolean testMisaligned = true;\n+        OutputAnalyzer output = executor.execute(\"VM.debug find\");\n+        output.shouldContain(\"Usage: VM.debug find \");\n+        \/\/ Find and test a thread id:\n+        OutputAnalyzer threadPrintOutput = executor.execute(\"Thread.print\");\n+        BigInteger ptr = findPointer(threadPrintOutput, thread_id_line, 1);\n+        output = executor.execute(\"VM.debug find \" + pointerText(ptr));\n+        output.shouldContain(\" is a thread\");\n+        \/\/ verbose shows output like:\n+        \/\/ \"main\" #1 [17235] prio=5 os_prio=0 cpu=1265.79ms elapsed=6.12s tid=0x000014e37802bd80 nid=17235 in Object.wait()  [0x000014e3817d4000]\n+        \/\/    java.lang.Thread.State: WAITING (on object monitor)\n+        \/\/ Thread: 0x000014e37802bd80  [0x4353] State: _running _at_poll_safepoint 0\n+        \/\/ ...\n+        \/\/ Also a debug vm shows: JavaThread state: _thread_blocked\n+        \/\/ ...\n+        output = executor.execute(\"VM.debug find -verbose \" + pointerText(ptr));\n+        output.shouldContain(\"java.lang.Thread.State: WAITING\");\n+\n+        \/\/ Known bad pointers:\n+        output = executor.execute(\"VM.debug find 0x0\");\n+        output.shouldContain(\"address not safe\");\n+\n+        output = executor.execute(\"VM.debug find -1\");\n+        output.shouldContain(\"address not safe\");\n+\n+        \/\/ Find and test a Java Object:\n+        threadPrintOutput = executor.execute(\"Thread.print\");\n+        ptr = findPointer(threadPrintOutput, waiting_on_mylock, 1);\n+        output = executor.execute(\"VM.debug find \" + pointerText(ptr));\n+        System.out.println(output);\n+        \/\/ Some tests put ZGC options in test.java.opts, not test.vm.opts\n+        String testOpts = System.getProperty(\"test.vm.opts\", \"\")\n+                          + System.getProperty(\"test.java.opts\", \"\");\n+        if (!testOpts.contains(\"-XX:+UseZGC\")) {\n+            output.shouldContain(\" is an oop: \");\n+        } else {\n+            \/\/ ZGC has two variations:\n+            if (testOpts.contains(\"-XX:+ZGenerational\")) {\n+                output.shouldContain(\"is a zaddress\");\n+                testMisaligned = false;\n+            } else {\n+                output.shouldContain(\"is a good oop\");\n+            }\n+        }\n+        output.shouldContain(\" - ---- fields (total size\");\n+        \/\/ \" - private 'myInt' 'I' @12  12345 (0x00003039)\"\n+        output.shouldContain(\" - private 'myInt' 'I'\");\n+        output.shouldContain(\" 12345 (\");\n+\n+        \/\/ ZGenerational will show the raw memory of our misaligned pointer, e.g.\n+        \/\/ 0x0000040001852491 points into unknown readable memory: 0b 00 d8 57 14 00 00\n+        \/\/ ...so don't check for that error.\n+        if (testMisaligned) {\n+            BigInteger badPtr = ptr.add(BigInteger.ONE);\n+            output = executor.execute(\"VM.debug find \" + pointerText(badPtr));\n+            output.shouldContain(\"misaligned\");\n+            badPtr = badPtr.add(BigInteger.ONE);\n+            output = executor.execute(\"VM.debug find \" + pointerText(badPtr));\n+            output.shouldContain(\"misaligned\");\n+        }\n+    }\n+\n+    public BigInteger findPointer(OutputAnalyzer output, Pattern pattern, int regexGroup) {\n+        Iterator<String> lines = output.asLines().iterator();\n+        Boolean foundMatch = false;\n+        BigInteger ptr = null;\n+        while (lines.hasNext()) {\n+            String line = lines.next();\n+            Matcher m = pattern.matcher(line);\n+            if (m.find()) {\n+                System.out.println(\"Matched line: \" + line);\n+                foundMatch = true;\n+                String p = m.group(regexGroup);\n+                ptr = new BigInteger(p, 16);\n+                System.out.println(\"Using pointer: 0x\" + ptr.toString(16));\n+                break;\n+            }\n+        }\n+        if (!foundMatch) {\n+            Assert.fail(\"Failed to find '\" + pattern + \"' in output:\" + output.getOutput());\n+        }\n+        return ptr;\n+    }\n+\n+    public static String pointerText(BigInteger p) {\n+        return \"0x\" + p.toString(16);\n+    }\n+\n+    @Test\n+    public void cli() throws Throwable {\n+        run(new PidJcmdExecutor());\n+    }\n+\n+   \/**\n+    * JMX Diagnostic intentionally not implemented.\n+    *\/\n+    \/\/@Test\n+    \/\/public void jmx() throws ClassNotFoundException {\n+    \/\/    run(new JMXExecutor());\n+    \/\/}\n+}\n+\n+\n+class MyLock extends Object {\n+    private int myInt = 12345;\n+}\n+\n+class DcmdTestClass {\n+\n+    protected static MyLock lock = new MyLock();\n+\n+    public void work() {{\n+        Runnable r = () -> {\n+          System.out.println(\"Hello\");\n+          synchronized(lock) {\n+            try {\n+              lock.wait();\n+            } catch (Exception e) { }\n+          }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+      }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/VMDebugTest.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"}]}