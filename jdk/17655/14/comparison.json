{"files":[{"patch":"@@ -173,0 +173,3 @@\n+  product(bool, UnlockDiagnosticVMFeatures, trueInDebug,                    \\\n+          \"Enable VM features relating to field diagnostics\")               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VMInspectDCmd>(full_export, true, true));\n@@ -1241,0 +1242,38 @@\n+VMInspectDCmd::VMInspectDCmd(outputStream* output, bool heap) :\n+                                     DCmdWithParser(output, heap),\n+  _address(\"address\", \"\", \"STRING\", true, nullptr),\n+  _verbose(\"-verbose\", \"\", \"BOOLEAN\", false, \"false\") {\n+\n+  _dcmdparser.add_dcmd_argument(&_address);\n+  _dcmdparser.add_dcmd_option(&_verbose);\n+}\n+\n+void VMInspectDCmd::execute(DCmdSource source, TRAPS) {\n+  DebuggingContext dc{}; \/\/ avoid asserts\n+\n+  if (!UnlockDiagnosticVMFeatures) {\n+    output()->print_cr(\"-XX:+UnlockDiagnosticVMFeatures is required\");\n+    return;\n+  }\n+  if (!_address.has_value()) {\n+    output()->print_cr(\"Usage: VM.inspect ADDRESS\");\n+  } else {\n+    intptr_t x = strtoll(_address.value(), nullptr, 0);\n+    if (!os::is_readable_pointer((intptr_t*) x)) {\n+      output()->print_cr(\"address not safe\");\n+    } else {\n+      if (Universe::heap()->is_in((oopDesc*) x)) {\n+        if (x != align_down(x, ObjectAlignmentInBytes)) {\n+          output()->print_cr(\"misaligned oop\");\n+          return;\n+        }\n+        if (!dbg_is_good_oop((oopDesc*) x)) {\n+          output()->print_cr(\"bad oop\");\n+          return;\n+        }\n+      }\n+      os::print_location(output(), x, _verbose.is_set());\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -579,0 +579,23 @@\n+class VMInspectDCmd: public DCmdWithParser {\n+protected:\n+  DCmdArgument<char*> _address;\n+  DCmdArgument<bool> _verbose;\n+public:\n+  static int num_arguments() { return 2; }\n+  VMInspectDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"VM.inspect\";\n+  }\n+  static const char* description() {\n+    return \"Inspect at address: decode Java heap and some other areas and objects known to the VM.\";\n+  }\n+  static const char* impact() {\n+      return \"High: not recommended for live production use.\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", nullptr};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -674,0 +674,1 @@\n+\n@@ -675,1 +676,24 @@\n-  return dbg_is_safe(o, -1) && dbg_is_safe(o->klass(), -1) && oopDesc::is_oop(o) && o->klass()->is_klass();\n+  bool good = dbg_is_safe(o, -1)\n+              && *(uintptr_t*) o != 0;\n+\n+  if (good) {\n+    \/\/ Check Klass ptr or narrowKlass ptr is not null.\n+    \/\/ No accessor for private o._metadata\n+    good = (*((uintptr_t*) ((uintptr_t) o + sizeof(uintptr_t))) != 0);\n+  }\n+  if (good) {\n+    if (!UseCompressedClassPointers) {\n+      good = dbg_is_safe(o->klass(), -1);\n+    } else {\n+      \/\/ Fetch compressed class pointer (no accessor for o._metadata._compressed_klass)\n+      uintptr_t ccpAddr = (uintptr_t) o + sizeof(uintptr_t);\n+      uintptr_t* ccp =  (uintptr_t*) CompressedKlassPointers::decode_without_asserts(*(uintptr_t*) ccpAddr);\n+      good = dbg_is_safe(ccp, -1)\n+             && dbg_is_safe((void*) *ccp, -1);\n+    }\n+  }\n+  if (good) {\n+    good = good && oopDesc::is_oop(o)\n+           && o->klass()->is_klass();\n+  }\n+  return good;\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318026\n+ * @summary Test of diagnostic command VM.inspect\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run testng\/othervm -Dvminspect.enabled=true -XX:+UnlockDiagnosticVMFeatures VMInspectTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318026\n+ * @summary Test of diagnostic command VM.inspect\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run testng\/othervm -Dvminspect.enabled=false VMInspectTest\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.dcmd.CommandExecutor;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+\n+import java.math.BigInteger;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class VMInspectTest {\n+\n+    \/\/ - locked <0x00000007dd0135e8> (a MyLock)\n+    static Pattern waiting_on_mylock =\n+        Pattern.compile(\"- waiting on \\\\<0x(\\\\p{XDigit}+)\\\\> \\\\(a MyLock\\\\)\");\n+\n+    \/\/ Event: 2301.131 Thread 0x00007fc6cc2866a0 nmethod 1298 0x00007fc6b4f82610 code [0x00007fc6b4f82a40, 0x00007fc6b4f83aa0]\n+    static Pattern compilation_event =\n+        Pattern.compile(\"Event: .* Thread .* nmethod \\\\d+ 0x(\\\\p{XDigit}+) code \");\n+\n+    \/\/ Compressed class space mapped at: 0x00007fc62f000000-0x00007fc66f000000, reserved size: 1073741824\n+    static Pattern compressed_class_space =\n+        Pattern.compile(\"Compressed class space mapped at: 0x(\\\\p{XDigit}+)\\\\-0x(\\\\p{XDigit}+), \");\n+\n+    \/\/ Narrow klass base: 0x00007fc62e000000, Narrow klass shift: 0, Narrow klass range: 0x100000000\n+    static Pattern narrow_klass_base =\n+        Pattern.compile(\"Narrow klass base: 0x(\\\\p{XDigit}+), \");\n+\n+    \/\/  tid=0x0000153418029c20\n+    static Pattern thread_id_line =\n+        Pattern.compile(\" tid=0x(\\\\p{XDigit}+) \");\n+\n+    public void run(CommandExecutor executor) throws ClassNotFoundException {\n+        DcmdTestClass test = new DcmdTestClass();\n+        test.work();\n+        BigInteger ptr = null;\n+        OutputAnalyzer output = null;\n+\n+        \/\/ Testing VM.inspect requires UnlockDiagnosticVMFeatures or a debug JVM.\n+        \/\/ This test runs with a System Property set as a hint whether UnlockDiagnosticVMFeatures is set.\n+        boolean enabled = Platform.isDebugBuild() || Boolean.getBoolean(\"vminspect.enabled\");\n+        System.out.println(\"VM.inspect should be enabled = \" + enabled);\n+        if (!enabled) {\n+            \/\/ Use any pointer, command should be refused:\n+            output = executor.execute(\"VM.inspect 0x0\");\n+            output.shouldContain(\"-XX:+UnlockDiagnosticVMFeatures is required\");\n+            return; \/\/ no more testing\n+        }\n+\n+        \/\/ Tests with VM.inspect enabled:\n+        output = executor.execute(\"help\");\n+        output.shouldNotContain(\"VM.inspect\"); \/\/ VM.inspect is not promoted in help\n+        output = executor.execute(\"help VM.inspect\");\n+        output.shouldContain(\"Syntax : VM.inspect\"); \/\/ but help is available\n+\n+        testInspectAddress(executor);\n+        testInspectAddressThread(executor);\n+        testInspectAddressNMethod(executor);\n+        testInspectAddressMetadata(executor);\n+\n+        \/\/ Some tests put ZGC options in test.java.opts, not test.vm.opts\n+        String testOpts = System.getProperty(\"test.vm.opts\", \"\")\n+                          + System.getProperty(\"test.java.opts\", \"\");\n+\n+        boolean isZGC = testOpts.contains(\"-XX:+UseZGC\");\n+        boolean isGenZGC = testOpts.contains(\"-XX:+ZGenerational\");\n+\n+        testInspectJavaObject(executor, isZGC, isGenZGC);\n+    }\n+\n+    public void testInspectAddress(CommandExecutor executor) {\n+        \/\/ Test that address is mandatory:\n+        \/\/ java.lang.IllegalArgumentException: The argument 'address' is mandatory.\n+        OutputAnalyzer output = executor.execute(\"VM.inspect\");\n+        output.shouldContain(\"is mandatory\");\n+\n+        \/\/ Known bad pointers:\n+        output = executor.execute(\"VM.inspect 0x0\");\n+        output.shouldContain(\"address not safe\");\n+        output = executor.execute(\"VM.inspect -1\");\n+        output.shouldContain(\"address not safe\");\n+    }\n+\n+    public void testInspectAddressThread(CommandExecutor executor) {\n+        \/\/ Find and test a thread id:\n+        OutputAnalyzer jcmdOutput = executor.execute(\"Thread.print\", true \/* silent *\/);\n+        BigInteger ptr = findPointer(jcmdOutput, thread_id_line, 1, true);\n+        OutputAnalyzer output = executor.execute(\"VM.inspect \" + pointerText(ptr));\n+        output.shouldContain(\" is a thread\");\n+\n+        \/\/ Using -verbose on a thread pointer shows output like:\n+        \/\/ \"main\" #1 [17235] prio=5 os_prio=0 cpu=1265.79ms elapsed=6.12s tid=0x000014e37802bd80 nid=17235 in Object.wait()  [0x000014e3817d4000]\n+        \/\/    java.lang.Thread.State: WAITING (on object monitor)\n+        \/\/ Thread: 0x000014e37802bd80  [0x4353] State: _running _at_poll_safepoint 0\n+        \/\/ ...\n+        \/\/ Also a debug vm shows: JavaThread state: _thread_blocked\n+        \/\/ ...\n+        output = executor.execute(\"VM.inspect -verbose \" + pointerText(ptr));\n+        output.shouldContain(\"java.lang.Thread.State: WAITING\");\n+    }\n+\n+    public void testInspectAddressNMethod(CommandExecutor executor) {\n+        \/\/ Find and test a compiled method:\n+        OutputAnalyzer jcmdOutput = executor.execute(\"VM.info\", true \/* silent *\/);\n+        BigInteger ptr = findPointer(jcmdOutput, compilation_event, 1, false);\n+        if (ptr != null) {\n+            OutputAnalyzer output = executor.execute(\"VM.inspect \" + pointerText(ptr));\n+            System.out.println(output);\n+            output.shouldContain(\"Compiled method \");\n+        } else{\n+            System.out.println(\"No compilation event found.\");\n+        }\n+    }\n+\n+    public void testInspectAddressMetadata(CommandExecutor executor) {\n+        \/\/ Test pointer into metadata:\n+        OutputAnalyzer jcmdOutput = executor.execute(\"VM.info\", true \/* silent *\/);\n+        BigInteger ptr = findPointer(jcmdOutput, compressed_class_space, 1, false);\n+        if (ptr != null) {\n+            OutputAnalyzer output = executor.execute(\"VM.inspect \" + pointerText(ptr));\n+            System.out.println(output);\n+            output.shouldContain(\"metadata\");\n+        } else{\n+            System.out.println(\"No Compressed class space found.\");\n+        }\n+\n+        ptr = findPointer(jcmdOutput, narrow_klass_base, 1, false);\n+        if (ptr != null) {\n+            OutputAnalyzer output = executor.execute(\"VM.inspect \" + pointerText(ptr));\n+            System.out.println(output);\n+            output.shouldContain(\"metadata\");\n+        } else {\n+            System.out.println(\"No narrow klass base found.\");\n+        }\n+    }\n+\n+    public static final int OBJECT_TRIES = 3;\n+\n+    public void testInspectJavaObject(CommandExecutor executor, boolean isZGC, boolean isGenZGC) {\n+        \/\/ Find and test a Java Object:\n+        \/\/ Process is live.  Very rarely, an Object seen in Thread.print may move due to GC,\n+        \/\/ so make a few attempts.\n+        BigInteger ptr = null;\n+        for (int i = 0; i < OBJECT_TRIES; i++) {\n+            System.gc();\n+            ptr = testInspectJavaObjectPointer(executor, isZGC, isGenZGC);\n+            if (ptr != null) {\n+                break;\n+            }\n+        }\n+        if (ptr == null) {\n+            throw new RuntimeException(\"Failed to inspect Java object from thread dump.\");\n+        }\n+\n+        \/\/ Test misaligned object pointer:\n+        \/\/ ZGenerational will show the raw memory of our misaligned pointer, e.g.\n+        \/\/ 0x0000040001852491 points into unknown readable memory: 0b 00 d8 57 14 00 00\n+        \/\/ ...so don't check for this error.\n+        if (!isGenZGC) {\n+            BigInteger badPtr = ptr.add(BigInteger.ONE);\n+            OutputAnalyzer output = executor.execute(\"VM.inspect \" + pointerText(badPtr));\n+            output.shouldContain(\"misaligned\");\n+            badPtr = badPtr.add(BigInteger.ONE);\n+            output = executor.execute(\"VM.inspect \" + pointerText(badPtr));\n+            output.shouldContain(\"misaligned\");\n+        }\n+    }\n+\n+    public BigInteger testInspectJavaObjectPointer(CommandExecutor executor, boolean isZGC, boolean isGenZGC) {\n+        \/\/ Inspect the MyLock object found in Thread.print output.\n+        String expected = \" is an oop: \";\n+        if (isZGC) {\n+            \/\/ ZGC has two variations:\n+            expected =  isGenZGC ? \"is a zaddress\" : \"is a good oop\";\n+        }\n+        OutputAnalyzer jcmdOutput = executor.execute(\"Thread.print\");\n+        BigInteger ptr = findPointer(jcmdOutput, waiting_on_mylock, 1, true);\n+        OutputAnalyzer output = executor.execute(\"VM.inspect \" + pointerText(ptr));\n+        if (!output.contains(expected)) {\n+            System.out.println(\"VM.inspect does not find expected text for 0x\" + ptr.toString(16));\n+            return null;\n+        }\n+\n+        output.shouldContain(\" - ---- fields (total size\");\n+        \/\/ \" - private 'myInt' 'I' @12  12345 (0x00003039)\"\n+        output.shouldContain(\" - private 'myInt' 'I'\");\n+        output.shouldContain(\" 12345 (\");\n+        return ptr;\n+    }\n+\n+    public BigInteger findPointer(OutputAnalyzer output, Pattern pattern, int regexGroup, boolean mustFind) {\n+        Iterator<String> lines = output.asLines().iterator();\n+        Boolean foundMatch = false;\n+        BigInteger ptr = null;\n+        while (lines.hasNext()) {\n+            String line = lines.next();\n+            Matcher m = pattern.matcher(line);\n+            if (m.find()) {\n+                System.out.println(\"Matched line: \" + line);\n+                foundMatch = true;\n+                String p = m.group(regexGroup);\n+                ptr = new BigInteger(p, 16);\n+                System.out.println(\"Using pointer: 0x\" + ptr.toString(16));\n+                break;\n+            }\n+        }\n+        if (!foundMatch) {\n+            String msg = \"Failed to find '\" + pattern + \"' in output:\" + output.getOutput();\n+            if (mustFind) {\n+                Assert.fail(msg);\n+            } else {\n+                System.out.println(msg);\n+            }\n+        }\n+        return ptr;\n+    }\n+\n+    public static String pointerText(BigInteger p) {\n+        return \"0x\" + p.toString(16);\n+    }\n+\n+    @Test\n+    public void cli() throws Throwable {\n+        run(new PidJcmdExecutor());\n+    }\n+\n+   \/**\n+    * JMX Diagnostic intentionally not implemented.\n+    *\/\n+    \/\/@Test\n+    \/\/public void jmx() throws ClassNotFoundException {\n+    \/\/    run(new JMXExecutor());\n+    \/\/}\n+}\n+\n+\n+class MyLock extends Object {\n+    private int myInt = 12345;\n+}\n+\n+class DcmdTestClass {\n+\n+    protected static MyLock lock = new MyLock();\n+\n+    public void work() {\n+        Runnable r = () -> {\n+            System.out.println(\"Hello\");\n+            synchronized(lock) {\n+                try {\n+                    lock.wait();\n+                } catch (Exception e) { }\n+            }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/VMInspectTest.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"}]}