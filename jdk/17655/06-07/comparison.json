{"files":[{"patch":"@@ -173,1 +173,1 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VMDebugDCmd>(full_export, true, true));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VMInspectDCmd>(full_export, true, true));\n@@ -1244,1 +1244,1 @@\n-VMDebugDCmd::VMDebugDCmd(outputStream* output, bool heap) :\n+VMInspectDCmd::VMInspectDCmd(outputStream* output, bool heap) :\n@@ -1246,1 +1246,0 @@\n-  _subcommand(\"subcommand\", \"\", \"STRING\", true, nullptr),\n@@ -1248,2 +1247,0 @@\n-  _arg2(\"arg2\", \"\", \"STRING\", false, nullptr),\n-  _arg3(\"arg3\", \"\", \"STRING\", false, nullptr),\n@@ -1252,1 +1249,0 @@\n-  _dcmdparser.add_dcmd_argument(&_subcommand);\n@@ -1254,2 +1250,0 @@\n-  _dcmdparser.add_dcmd_argument(&_arg2);\n-  _dcmdparser.add_dcmd_argument(&_arg3);\n@@ -1259,1 +1253,7 @@\n-void VMDebugDCmd::find() {\n+void VMInspectDCmd::execute(DCmdSource source, TRAPS) {\n+  DebuggingContext dc{}; \/\/ avoid asserts\n+\n+  if (!UnlockDiagnosticVMOptions) {\n+    output()->print_cr(\"-XX:+UnlockDiagnosticVMOptions is required\");\n+    return;\n+  }\n@@ -1261,1 +1261,1 @@\n-    output()->print_cr(\"Usage: VM.debug find ADDRESS\");\n+    output()->print_cr(\"Usage: VM.inspect ADDRESS\");\n@@ -1282,33 +1282,0 @@\n-void VMDebugDCmd::execute(DCmdSource source, TRAPS) {\n-  DebuggingContext dc{}; \/\/ avoid asserts\n-\n-  if (!UnlockDiagnosticVMOptions) {\n-    output()->print_cr(\"-XX:+UnlockDiagnosticVMOptions is required\");\n-    return;\n-  }\n-  \/\/ Interpret _subcommand, using further args _arg1, etc as required.\n-  if (strcmp(\"threads\", _subcommand.value()) == 0) {\n-    char buf[1024];\n-    Threads::print_on_error(output(), THREAD, buf, sizeof(buf));\n-  } else if (strcmp(\"findclass\", _subcommand.value()) == 0) {\n-    if (!_arg1.has_value() || !_arg2.has_value()) {\n-      output()->print_cr(\"Usage: VM.debug findclass CLASS_PATTERN FLAGS\");\n-    } else {\n-      long flags = strtol(_arg2.value(), nullptr, 0);\n-      ClassPrinter::print_classes(_arg1.value(), flags, output());\n-    }\n-  } else if (strcmp(\"findmethod\", _subcommand.value()) == 0) {\n-    if (!_arg1.has_value() || !_arg2.has_value() || !_arg3.has_value()) {\n-      output()->print_cr(\"Usage: VM.debug findmethod CLASS_PATTERN METHOD_PATTERN FLAGS\");\n-    } else {\n-      long flags = strtol(_arg3.value(), nullptr, 0);\n-      ClassPrinter::print_methods(_arg1.value(), _arg2.value(), flags, output());\n-    }\n-  } else if (strcmp(\"find\", _subcommand.value()) == 0) {\n-      find();\n-  } else {\n-    output()->print_cr(\"VM.debug: unknown sub-command.\");\n-    output()->print_cr(\"%s\", description());\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":10,"deletions":43,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -579,2 +579,1 @@\n-\/\/ VM state inspection. Subcommands to provide utilities similar to debug.cpp.\n-class VMDebugDCmd: public DCmdWithParser {\n+class VMInspectDCmd: public DCmdWithParser {\n@@ -582,1 +581,0 @@\n-  DCmdArgument<char*> _subcommand;\n@@ -584,2 +582,0 @@\n-  DCmdArgument<char*> _arg2;\n-  DCmdArgument<char*> _arg3;\n@@ -588,2 +584,2 @@\n-  static int num_arguments() { return 5; }\n-  VMDebugDCmd(outputStream* output, bool heap);\n+  static int num_arguments() { return 1; }\n+  VMInspectDCmd(outputStream* output, bool heap);\n@@ -591,1 +587,1 @@\n-    return \"VM.debug\";\n+    return \"VM.inspect\";\n@@ -594,1 +590,1 @@\n-    return \"Inspect VM state. Requires -XX:+UnlockDiagnosticVMOptions. Subcommands: threads, find ADDRESS, findclass CLASS_PATTERN FLAGS, findmethod CLASS_PATTERN METHOD_PATTERN FLAGS\";\n+    return \"Inspect VM object at address.\";\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,240 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8318026\n- * @summary Test of diagnostic command VM.debug\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- * @run testng\/othervm -Dvmdebug.enabled=true -XX:+UnlockDiagnosticVMOptions VMDebugTest\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8318026\n- * @summary Test of diagnostic command VM.debug\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- * @run testng\/othervm -Dvmdebug.enabled=false VMDebugTest\n- *\/\n-\n-import org.testng.annotations.Test;\n-import org.testng.Assert;\n-\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.dcmd.CommandExecutor;\n-import jdk.test.lib.dcmd.PidJcmdExecutor;\n-\n-import java.math.BigInteger;\n-import java.io.IOException;\n-import java.util.Iterator;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-public class VMDebugTest {\n-\n-    \/\/ - locked <0x00000007dd0135e8> (a MyLock)\n-    static Pattern waiting_on_mylock =\n-        Pattern.compile(\"- waiting on \\\\<0x(\\\\p{XDigit}+)\\\\> \\\\(a MyLock\\\\)\");\n-\n-    \/\/  tid=0x0000153418029c20\n-    static Pattern thread_id_line =\n-        Pattern.compile(\" tid=0x(\\\\p{XDigit}+) \");\n-\n-    public void run(CommandExecutor executor) throws ClassNotFoundException {\n-        DcmdTestClass test = new DcmdTestClass();\n-        test.work();\n-        BigInteger ptr = null;\n-        OutputAnalyzer output = null;\n-\n-        \/\/ Testing VM.debug requires UnlockDiagnosticVMOptions or a debug JVM.\n-        \/\/ This test runs with a System Property set as a hint whether UnlockDiagnosticVMOptions is set.\n-        boolean enabled = Platform.isDebugBuild() || Boolean.getBoolean(\"vmdebug.enabled\");\n-        System.out.println(\"VM.debug should be enabled = \" + enabled);\n-        if (!enabled) {\n-            \/\/ Use any pointer, command should be refused:\n-            output = executor.execute(\"VM.debug find 0x0\");\n-            output.shouldContain(\"-XX:+UnlockDiagnosticVMOptions is required\");\n-            return; \/\/ no more testing\n-        }\n-\n-        \/\/ Tests with VM.debug enabled:\n-        output = executor.execute(\"help\");\n-        output.shouldNotContain(\"VM.debug\"); \/\/ debug is not promoted in help\n-        output = executor.execute(\"help VM.debug\");\n-        output.shouldContain(\"Syntax : VM.debug\"); \/\/ but help is available\n-\n-        \/\/ Test the VM.debug subcommands, without being too specific and vulnerable to format changes.\n-\n-        \/\/ Test VM.debug threads:\n-        output = executor.execute(\"VM.debug threads\");\n-        output.shouldContain(\"Threads class SMR info:\");\n-        output.shouldContain(\"Java Threads:\");\n-        output.shouldContain(\"JavaThread \\\"main\\\"\");\n-        output.shouldContain(\"VMThread \\\"VM Thread\\\"\");\n-\n-        \/\/ Test VM.debug findclass:\n-        output = executor.execute(\"VM.debug findclass\");\n-        output.shouldContain(\"Usage: VM.debug findclass \");\n-        output = executor.execute(\"VM.debug findclass java\/lang\/String 3\");\n-        output.shouldContain(\"class java\/lang\/String\");\n-\n-        \/\/ Test VM.debug findmethod:\n-        output = executor.execute(\"VM.debug findmethod\");\n-        output.shouldContain(\"Usage: VM.debug findmethod \");\n-        output = executor.execute(\"VM.debug findmethod java\/lang\/String contains 3\");\n-        output.shouldContain(\"class java\/lang\/String\");\n-\n-        \/\/ Test VM.debug find:\n-        testFind(executor);\n-    }\n-\n-    public void testFind(CommandExecutor executor) {\n-        boolean testMisaligned = true;\n-        OutputAnalyzer output = executor.execute(\"VM.debug find\");\n-        output.shouldContain(\"Usage: VM.debug find \");\n-        \/\/ Find and test a thread id:\n-        OutputAnalyzer threadPrintOutput = executor.execute(\"Thread.print\");\n-        BigInteger ptr = findPointer(threadPrintOutput, thread_id_line, 1);\n-        output = executor.execute(\"VM.debug find \" + pointerText(ptr));\n-        output.shouldContain(\" is a thread\");\n-        \/\/ verbose shows output like:\n-        \/\/ \"main\" #1 [17235] prio=5 os_prio=0 cpu=1265.79ms elapsed=6.12s tid=0x000014e37802bd80 nid=17235 in Object.wait()  [0x000014e3817d4000]\n-        \/\/    java.lang.Thread.State: WAITING (on object monitor)\n-        \/\/ Thread: 0x000014e37802bd80  [0x4353] State: _running _at_poll_safepoint 0\n-        \/\/ ...\n-        \/\/ Also a debug vm shows: JavaThread state: _thread_blocked\n-        \/\/ ...\n-        output = executor.execute(\"VM.debug find -verbose \" + pointerText(ptr));\n-        output.shouldContain(\"java.lang.Thread.State: WAITING\");\n-\n-        \/\/ Known bad pointers:\n-        output = executor.execute(\"VM.debug find 0x0\");\n-        output.shouldContain(\"address not safe\");\n-\n-        output = executor.execute(\"VM.debug find -1\");\n-        output.shouldContain(\"address not safe\");\n-\n-        \/\/ Find and test a Java Object:\n-        threadPrintOutput = executor.execute(\"Thread.print\");\n-        ptr = findPointer(threadPrintOutput, waiting_on_mylock, 1);\n-        output = executor.execute(\"VM.debug find \" + pointerText(ptr));\n-        System.out.println(output);\n-        \/\/ Some tests put ZGC options in test.java.opts, not test.vm.opts\n-        String testOpts = System.getProperty(\"test.vm.opts\", \"\")\n-                          + System.getProperty(\"test.java.opts\", \"\");\n-        if (!testOpts.contains(\"-XX:+UseZGC\")) {\n-            output.shouldContain(\" is an oop: \");\n-        } else {\n-            \/\/ ZGC has two variations:\n-            if (testOpts.contains(\"-XX:+ZGenerational\")) {\n-                output.shouldContain(\"is a zaddress\");\n-                testMisaligned = false;\n-            } else {\n-                output.shouldContain(\"is a good oop\");\n-            }\n-        }\n-        output.shouldContain(\" - ---- fields (total size\");\n-        \/\/ \" - private 'myInt' 'I' @12  12345 (0x00003039)\"\n-        output.shouldContain(\" - private 'myInt' 'I'\");\n-        output.shouldContain(\" 12345 (\");\n-\n-        \/\/ ZGenerational will show the raw memory of our misaligned pointer, e.g.\n-        \/\/ 0x0000040001852491 points into unknown readable memory: 0b 00 d8 57 14 00 00\n-        \/\/ ...so don't check for that error.\n-        if (testMisaligned) {\n-            BigInteger badPtr = ptr.add(BigInteger.ONE);\n-            output = executor.execute(\"VM.debug find \" + pointerText(badPtr));\n-            output.shouldContain(\"misaligned\");\n-            badPtr = badPtr.add(BigInteger.ONE);\n-            output = executor.execute(\"VM.debug find \" + pointerText(badPtr));\n-            output.shouldContain(\"misaligned\");\n-        }\n-    }\n-\n-    public BigInteger findPointer(OutputAnalyzer output, Pattern pattern, int regexGroup) {\n-        Iterator<String> lines = output.asLines().iterator();\n-        Boolean foundMatch = false;\n-        BigInteger ptr = null;\n-        while (lines.hasNext()) {\n-            String line = lines.next();\n-            Matcher m = pattern.matcher(line);\n-            if (m.find()) {\n-                System.out.println(\"Matched line: \" + line);\n-                foundMatch = true;\n-                String p = m.group(regexGroup);\n-                ptr = new BigInteger(p, 16);\n-                System.out.println(\"Using pointer: 0x\" + ptr.toString(16));\n-                break;\n-            }\n-        }\n-        if (!foundMatch) {\n-            Assert.fail(\"Failed to find '\" + pattern + \"' in output:\" + output.getOutput());\n-        }\n-        return ptr;\n-    }\n-\n-    public static String pointerText(BigInteger p) {\n-        return \"0x\" + p.toString(16);\n-    }\n-\n-    @Test\n-    public void cli() throws Throwable {\n-        run(new PidJcmdExecutor());\n-    }\n-\n-   \/**\n-    * JMX Diagnostic intentionally not implemented.\n-    *\/\n-    \/\/@Test\n-    \/\/public void jmx() throws ClassNotFoundException {\n-    \/\/    run(new JMXExecutor());\n-    \/\/}\n-}\n-\n-\n-class MyLock extends Object {\n-    private int myInt = 12345;\n-}\n-\n-class DcmdTestClass {\n-\n-    protected static MyLock lock = new MyLock();\n-\n-    public void work() {{\n-        Runnable r = () -> {\n-          System.out.println(\"Hello\");\n-          synchronized(lock) {\n-            try {\n-              lock.wait();\n-            } catch (Exception e) { }\n-          }\n-        };\n-        Thread t = new Thread(r);\n-        t.start();\n-      }\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/VMDebugTest.java","additions":0,"deletions":240,"binary":false,"changes":240,"status":"deleted"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318026\n+ * @summary Test of diagnostic command VM.inspect\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run testng\/othervm -Dvminspect.enabled=true -XX:+UnlockDiagnosticVMOptions VMInspectTest \n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318026\n+ * @summary Test of diagnostic command VM.inspect\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run testng\/othervm -Dvminspect.enabled=false VMInspectTest\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.dcmd.CommandExecutor;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+\n+import java.math.BigInteger;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class VMInspectTest {\n+\n+    \/\/ - locked <0x00000007dd0135e8> (a MyLock)\n+    static Pattern waiting_on_mylock =\n+        Pattern.compile(\"- waiting on \\\\<0x(\\\\p{XDigit}+)\\\\> \\\\(a MyLock\\\\)\");\n+\n+    \/\/  tid=0x0000153418029c20\n+    static Pattern thread_id_line =\n+        Pattern.compile(\" tid=0x(\\\\p{XDigit}+) \");\n+\n+    public void run(CommandExecutor executor) throws ClassNotFoundException {\n+        DcmdTestClass test = new DcmdTestClass();\n+        test.work();\n+        BigInteger ptr = null;\n+        OutputAnalyzer output = null;\n+\n+        \/\/ Testing VM.inspect requires UnlockDiagnosticVMOptions or a debug JVM.\n+        \/\/ This test runs with a System Property set as a hint whether UnlockDiagnosticVMOptions is set.\n+        boolean enabled = Platform.isDebugBuild() || Boolean.getBoolean(\"vminspect.enabled\");\n+        System.out.println(\"VM.inspect should be enabled = \" + enabled);\n+        if (!enabled) {\n+            \/\/ Use any pointer, command should be refused:\n+            output = executor.execute(\"VM.inspect 0x0\");\n+            output.shouldContain(\"-XX:+UnlockDiagnosticVMOptions is required\");\n+            return; \/\/ no more testing\n+        }\n+\n+        \/\/ Tests where enabled:\n+        output = executor.execute(\"help\");\n+        output.shouldNotContain(\"VM.inspect\"); \/\/ VM.inspect is not promoted in help\n+        output = executor.execute(\"help VM.inspect\");\n+        output.shouldContain(\"Syntax : VM.inspect\"); \/\/ but help is available\n+\n+        \/\/ Test VM.inspect:\n+        testFind(executor);\n+    }\n+\n+    public void testFind(CommandExecutor executor) {\n+        boolean testMisaligned = true;\n+        OutputAnalyzer output = executor.execute(\"VM.inspect\");\n+        output.shouldContain(\"Usage: VM.inspect\");\n+        \/\/ Find and test a thread id:\n+        OutputAnalyzer threadPrintOutput = executor.execute(\"Thread.print\");\n+        BigInteger ptr = findPointer(threadPrintOutput, thread_id_line, 1);\n+        output = executor.execute(\"VM.inspect \" + pointerText(ptr));\n+        output.shouldContain(\" is a thread\");\n+        \/\/ verbose shows output like:\n+        \/\/ \"main\" #1 [17235] prio=5 os_prio=0 cpu=1265.79ms elapsed=6.12s tid=0x000014e37802bd80 nid=17235 in Object.wait()  [0x000014e3817d4000]\n+        \/\/    java.lang.Thread.State: WAITING (on object monitor)\n+        \/\/ Thread: 0x000014e37802bd80  [0x4353] State: _running _at_poll_safepoint 0\n+        \/\/ ...\n+        \/\/ Also a debug vm shows: JavaThread state: _thread_blocked\n+        \/\/ ...\n+        output = executor.execute(\"VM.inspect -verbose \" + pointerText(ptr));\n+        output.shouldContain(\"java.lang.Thread.State: WAITING\");\n+\n+        \/\/ Known bad pointers:\n+        output = executor.execute(\"VM.inspect 0x0\");\n+        output.shouldContain(\"address not safe\");\n+\n+        output = executor.execute(\"VM.inspect -1\");\n+        output.shouldContain(\"address not safe\");\n+\n+        \/\/ Find and test a Java Object:\n+        threadPrintOutput = executor.execute(\"Thread.print\");\n+        ptr = findPointer(threadPrintOutput, waiting_on_mylock, 1);\n+        output = executor.execute(\"VM.inspect \" + pointerText(ptr));\n+        System.out.println(output);\n+        \/\/ Some tests put ZGC options in test.java.opts, not test.vm.opts\n+        String testOpts = System.getProperty(\"test.vm.opts\", \"\")\n+                          + System.getProperty(\"test.java.opts\", \"\");\n+        if (!testOpts.contains(\"-XX:+UseZGC\")) {\n+            output.shouldContain(\" is an oop: \");\n+        } else {\n+            \/\/ ZGC has two variations:\n+            if (testOpts.contains(\"-XX:+ZGenerational\")) {\n+                output.shouldContain(\"is a zaddress\");\n+                testMisaligned = false;\n+            } else {\n+                output.shouldContain(\"is a good oop\");\n+            }\n+        }\n+        output.shouldContain(\" - ---- fields (total size\");\n+        \/\/ \" - private 'myInt' 'I' @12  12345 (0x00003039)\"\n+        output.shouldContain(\" - private 'myInt' 'I'\");\n+        output.shouldContain(\" 12345 (\");\n+\n+        \/\/ ZGenerational will show the raw memory of our misaligned pointer, e.g.\n+        \/\/ 0x0000040001852491 points into unknown readable memory: 0b 00 d8 57 14 00 00\n+        \/\/ ...so don't check for that error.\n+        if (testMisaligned) {\n+            BigInteger badPtr = ptr.add(BigInteger.ONE);\n+            output = executor.execute(\"VM.inspect \" + pointerText(badPtr));\n+            output.shouldContain(\"misaligned\");\n+            badPtr = badPtr.add(BigInteger.ONE);\n+            output = executor.execute(\"VM.inspect \" + pointerText(badPtr));\n+            output.shouldContain(\"misaligned\");\n+        }\n+    }\n+\n+    public BigInteger findPointer(OutputAnalyzer output, Pattern pattern, int regexGroup) {\n+        Iterator<String> lines = output.asLines().iterator();\n+        Boolean foundMatch = false;\n+        BigInteger ptr = null;\n+        while (lines.hasNext()) {\n+            String line = lines.next();\n+            Matcher m = pattern.matcher(line);\n+            if (m.find()) {\n+                System.out.println(\"Matched line: \" + line);\n+                foundMatch = true;\n+                String p = m.group(regexGroup);\n+                ptr = new BigInteger(p, 16);\n+                System.out.println(\"Using pointer: 0x\" + ptr.toString(16));\n+                break;\n+            }\n+        }\n+        if (!foundMatch) {\n+            Assert.fail(\"Failed to find '\" + pattern + \"' in output:\" + output.getOutput());\n+        }\n+        return ptr;\n+    }\n+\n+    public static String pointerText(BigInteger p) {\n+        return \"0x\" + p.toString(16);\n+    }\n+\n+    @Test\n+    public void cli() throws Throwable {\n+        run(new PidJcmdExecutor());\n+    }\n+\n+   \/**\n+    * JMX Diagnostic intentionally not implemented.\n+    *\/\n+    \/\/@Test\n+    \/\/public void jmx() throws ClassNotFoundException {\n+    \/\/    run(new JMXExecutor());\n+    \/\/}\n+}\n+\n+\n+class MyLock extends Object {\n+    private int myInt = 12345;\n+}\n+\n+class DcmdTestClass {\n+\n+    protected static MyLock lock = new MyLock();\n+\n+    public void work() {{\n+        Runnable r = () -> {\n+          System.out.println(\"Hello\");\n+          synchronized(lock) {\n+            try {\n+              lock.wait();\n+            } catch (Exception e) { }\n+          }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+      }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/VMInspectTest.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"}]}