{"files":[{"patch":"@@ -81,2 +81,2 @@\n-        Reference.reachabilityFence(obj);\n-        obj = null;\n+        try {\n+            obj = null;\n@@ -84,5 +84,5 @@\n-        int retries = (int)(timeout \/ 200);\n-        for (; retries >= 0; retries--) {\n-            if (booleanSupplier.getAsBoolean()) {\n-                return true;\n-            }\n+            int retries = (int) (timeout \/ 200);\n+            for (; retries >= 0; retries--) {\n+                if (booleanSupplier.getAsBoolean()) {\n+                    return true;\n+                }\n@@ -90,1 +90,1 @@\n-            System.gc();\n+                System.gc();\n@@ -92,8 +92,9 @@\n-            try {\n-                \/\/ The remove() will always block for the specified milliseconds\n-                \/\/ if the reference has already been removed from the queue.\n-                \/\/ But it is fine.  For most cases, the 1st GC is sufficient\n-                \/\/ to trigger and complete the cleanup.\n-                queue.remove(200L);\n-            } catch (InterruptedException ie) {\n-                \/\/ ignore, the loop will try again\n+                try {\n+                    \/\/ The remove() will always block for the specified milliseconds\n+                    \/\/ if the reference has already been removed from the queue.\n+                    \/\/ But it is fine.  For most cases, the 1st GC is sufficient\n+                    \/\/ to trigger and complete the cleanup.\n+                    queue.remove(200L);\n+                } catch (InterruptedException ie) {\n+                    \/\/ ignore, the loop will try again\n+                }\n@@ -101,0 +102,2 @@\n+        } finally {\n+            Reference.reachabilityFence(ref);\n@@ -102,2 +105,0 @@\n-        Reference.reachabilityFence(ref);\n-\n","filename":"test\/lib\/jdk\/test\/lib\/util\/ForceGC.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"}]}