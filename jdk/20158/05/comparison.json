{"files":[{"patch":"@@ -440,0 +440,1 @@\n+    has_scoped_access(),\n@@ -581,0 +582,1 @@\n+, _has_scoped_access(method->is_scoped())\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+  bool               _has_scoped_access; \/\/ For shared scope closure\n@@ -146,0 +147,1 @@\n+  bool has_scoped_access() const                 { return _has_scoped_access; }\n@@ -178,0 +180,1 @@\n+  void set_has_scoped_access(bool f)             { _has_scoped_access = f; }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3521,0 +3521,3 @@\n+  if (callee->is_scoped()) {\n+    compilation->set_has_scoped_access(true);\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1035,0 +1035,1 @@\n+                            bool has_scoped_access,\n@@ -1127,0 +1128,1 @@\n+      nm->set_has_scoped_access(has_scoped_access);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -386,0 +386,1 @@\n+                       bool                      has_scoped_access,\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -962,0 +962,8 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciMethod::is_scoped\n+\/\/\n+\/\/ Return true for methods annotated with @Scoped\n+bool ciMethod::is_scoped() const {\n+   return get_Method()->is_scoped();\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -363,0 +363,1 @@\n+  bool is_scoped() const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1237,0 +1237,1 @@\n+  _has_scoped_access          = 0;\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -274,0 +274,1 @@\n+          _has_scoped_access:1,        \/\/ used by for shared scope closure (scopedMemoryAccess.cpp)\n@@ -667,0 +668,3 @@\n+  bool  has_scoped_access() const                 { return _has_scoped_access; }\n+  void  set_has_scoped_access(bool z)             { _has_scoped_access = z; }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2186,0 +2186,1 @@\n+        nm->set_has_scoped_access(true); \/\/ conservative\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1064,0 +1064,1 @@\n+  set_has_scoped_access(false);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -357,0 +357,1 @@\n+  bool                  _has_scoped_access;     \/\/ For shared scope closure\n@@ -675,0 +676,2 @@\n+  bool              has_scoped_access() const    { return _has_scoped_access; }\n+  void          set_has_scoped_access(bool v)    { _has_scoped_access = v; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3437,0 +3437,1 @@\n+                                     C->has_scoped_access(),\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -440,0 +440,4 @@\n+  if (parse_method->is_scoped()) {\n+    C->set_has_scoped_access(true);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -38,1 +39,11 @@\n-static bool is_in_scoped_access(JavaThread* jt, oop session) {\n+template<typename Func>\n+static bool for_scoped_method(JavaThread* jt, const Func& func) {\n+  ResourceMark rm;\n+#ifdef ASSERT\n+  LogMessage(foreign) msg;\n+  NonInterleavingLogStream ls{LogLevelType::Trace, msg};\n+  if (ls.is_enabled()) {\n+    ls.print_cr(\"Walking thread: %s\", jt->name());\n+  }\n+#endif\n+\n@@ -43,12 +54,12 @@\n-    if (m->is_scoped()) {\n-      StackValueCollection* locals = stream.asJavaVFrame()->locals();\n-      for (int i = 0; i < locals->size(); i++) {\n-        StackValue* var = locals->at(i);\n-        if (var->type() == T_OBJECT) {\n-          if (var->get_obj() == session) {\n-            assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n-            return true;\n-          }\n-        }\n-      }\n-      break;\n+    bool is_scoped = m->is_scoped();\n+\n+#ifdef ASSERT\n+    if (ls.is_enabled()) {\n+      stream.asJavaVFrame()->print_value(&ls);\n+      ls.print_cr(\"    is_scoped=%s\", is_scoped ? \"true\" : \"false\");\n+    }\n+#endif\n+\n+    if (is_scoped) {\n+      assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n+      return func(stream);\n@@ -57,0 +68,1 @@\n+\n@@ -58,0 +70,2 @@\n+    \/\/ On debug builds, just keep searching the stack\n+    \/\/ in case we missed an @Scoped method further up\n@@ -63,1 +77,0 @@\n-\n@@ -67,0 +80,29 @@\n+static bool is_accessing_session(JavaThread* jt, oop session, bool& in_scoped) {\n+  return for_scoped_method(jt, [&](vframeStream& stream){\n+    in_scoped = true;\n+    StackValueCollection* locals = stream.asJavaVFrame()->locals();\n+    for (int i = 0; i < locals->size(); i++) {\n+      StackValue* var = locals->at(i);\n+      if (var->type() == T_OBJECT) {\n+        if (var->get_obj() == session) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  });\n+}\n+\n+static frame get_last_frame(JavaThread* jt) {\n+  frame last_frame = jt->last_frame();\n+  RegisterMap register_map(jt,\n+                            RegisterMap::UpdateMap::include,\n+                            RegisterMap::ProcessFrames::include,\n+                            RegisterMap::WalkContinuation::skip);\n+\n+  if (last_frame.is_safepoint_blob_frame()) {\n+    last_frame = last_frame.sender(&register_map);\n+  }\n+  return last_frame;\n+}\n+\n@@ -81,2 +123,2 @@\n-    ResourceMark rm;\n-    if (is_in_scoped_access(jt, _session.resolve())) {\n+    bool ignored;\n+    if (is_accessing_session(jt, _session.resolve(), ignored)) {\n@@ -107,18 +149,0 @@\n-    frame last_frame = jt->last_frame();\n-    RegisterMap register_map(jt,\n-                             RegisterMap::UpdateMap::include,\n-                             RegisterMap::ProcessFrames::include,\n-                             RegisterMap::WalkContinuation::skip);\n-\n-    if (last_frame.is_safepoint_blob_frame()) {\n-      last_frame = last_frame.sender(&register_map);\n-    }\n-\n-    ResourceMark rm;\n-    if (last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n-      \/\/ FIXME: we would like to conditionally deoptimize only if the corresponding\n-      \/\/ _session is reachable from the frame, but reachabilityFence doesn't currently\n-      \/\/ work the way it should. Therefore we deopt unconditionally for now.\n-      Deoptimization::deoptimize(jt, last_frame);\n-    }\n-\n@@ -131,1 +155,2 @@\n-    if (is_in_scoped_access(jt, JNIHandles::resolve(_session))) {\n+    bool in_scoped = false;\n+    if (is_accessing_session(jt, JNIHandles::resolve(_session), in_scoped)) {\n@@ -139,0 +164,41 @@\n+    } else if (!in_scoped) {\n+      frame last_frame = get_last_frame(jt);\n+      if (last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n+        \/\/ We are not at a safepoint that is 'in' an @Scoped method, but due to the compiler\n+        \/\/ moving code around\/hoisting checks, we may be in a situation like this:\n+        \/\/\n+        \/\/ liveness check (from @Scoped method)\n+        \/\/ for (...) {\n+        \/\/    for (...) { \/\/ strip-mining inner loop\n+        \/\/        memory access (from @Scoped method)\n+        \/\/    }\n+        \/\/    safepoint <-- STOPPED HERE\n+        \/\/ }\n+        \/\/\n+        \/\/ The safepoint at which we're stopped may be in between the liveness check\n+        \/\/ and actual memory access, but is itself 'outside' of @Scoped code\n+        \/\/\n+        \/\/ However, we're not sure whether we are in this exact situation, and\n+        \/\/ we're also not sure whether a memory access will actually occur after\n+        \/\/ this safepoint. So, we can not just install an async exception here\n+        \/\/\n+        \/\/ Instead, we mark the frame for deoptimization (which happens just before\n+        \/\/ execution in this frame continues) to get back to code like this:\n+        \/\/\n+        \/\/ for (...) {\n+        \/\/     call to ScopedMemoryAccess\n+        \/\/     safepoint <-- STOPPED HERE\n+        \/\/ }\n+        \/\/\n+        \/\/ This means that we will re-do the liveness check before attempting\n+        \/\/ another memory access. If the scope has been closed at that point,\n+        \/\/ the target thread will see it and throw an exception.\n+\n+        nmethod* code = last_frame.cb()->as_nmethod();\n+        if (code->has_scoped_access()) {\n+          \/\/ We would like to deoptimize here only if last_frame::oops_do\n+          \/\/ reports the session oop being live at this safepoint, but this\n+          \/\/ currently isn't possible due to JDK-8290892\n+          Deoptimization::deoptimize(jt, last_frame);\n+        }\n+      }\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":102,"deletions":36,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -621,2 +621,2 @@\n-void vframe::print() {\n-  if (WizardMode) _fr.print_value_on(tty,nullptr);\n+void vframe::print(outputStream* output) {\n+  if (WizardMode) _fr.print_value_on(output, nullptr);\n@@ -625,2 +625,2 @@\n-void vframe::print_value() const {\n-  ((vframe*)this)->print();\n+void vframe::print_value(outputStream* output) const {\n+  ((vframe*)this)->print(output);\n@@ -630,2 +630,2 @@\n-void entryVFrame::print_value() const {\n-  ((entryVFrame*)this)->print();\n+void entryVFrame::print_value(outputStream* output) const {\n+  ((entryVFrame*)this)->print(output);\n@@ -634,4 +634,4 @@\n-void entryVFrame::print() {\n-  vframe::print();\n-  tty->print_cr(\"C Chunk in between Java\");\n-  tty->print_cr(\"C     link \" INTPTR_FORMAT, p2i(_fr.link()));\n+void entryVFrame::print(outputStream* output) {\n+  vframe::print(output);\n+  output->print_cr(\"C Chunk in between Java\");\n+  output->print_cr(\"C     link \" INTPTR_FORMAT, p2i(_fr.link()));\n@@ -643,1 +643,1 @@\n-static void print_stack_values(const char* title, StackValueCollection* values) {\n+static void print_stack_values(outputStream* output, const char* title, StackValueCollection* values) {\n@@ -645,1 +645,1 @@\n-  tty->print_cr(\"\\t%s:\", title);\n+  output->print_cr(\"\\t%s:\", title);\n@@ -650,1 +650,1 @@\n-void javaVFrame::print() {\n+void javaVFrame::print(outputStream* output) {\n@@ -655,2 +655,2 @@\n-  vframe::print();\n-  tty->print(\"\\t\");\n+  vframe::print(output);\n+  output->print(\"\\t\");\n@@ -658,2 +658,2 @@\n-  tty->cr();\n-  tty->print_cr(\"\\tbci:    %d\", bci());\n+  output->cr();\n+  output->print_cr(\"\\tbci:    %d\", bci());\n@@ -661,2 +661,2 @@\n-  print_stack_values(\"locals\",      locals());\n-  print_stack_values(\"expressions\", expressions());\n+  print_stack_values(output, \"locals\",      locals());\n+  print_stack_values(output, \"expressions\", expressions());\n@@ -666,1 +666,1 @@\n-  tty->print_cr(\"\\tmonitor list:\");\n+  output->print_cr(\"\\tmonitor list:\");\n@@ -669,1 +669,1 @@\n-    tty->print(\"\\t  obj\\t\");\n+    output->print(\"\\t  obj\\t\");\n@@ -672,1 +672,1 @@\n-      tty->print(\"( is scalar replaced %s)\", k->external_name());\n+      output->print(\"( is scalar replaced %s)\", k->external_name());\n@@ -674,1 +674,1 @@\n-      tty->print(\"( null )\");\n+      output->print(\"( null )\");\n@@ -677,1 +677,1 @@\n-      tty->print(\"(owner=\" INTPTR_FORMAT \")\", p2i(monitor->owner()));\n+      output->print(\"(owner=\" INTPTR_FORMAT \")\", p2i(monitor->owner()));\n@@ -681,1 +681,1 @@\n-        tty->print(\" ( lock is eliminated in compiled frame )\");\n+        output->print(\" ( lock is eliminated in compiled frame )\");\n@@ -683,1 +683,1 @@\n-        tty->print(\" ( lock is eliminated, frame not compiled )\");\n+        output->print(\" ( lock is eliminated, frame not compiled )\");\n@@ -686,4 +686,4 @@\n-    tty->cr();\n-    tty->print(\"\\t  \");\n-    monitor->lock()->print_on(tty, monitor->owner());\n-    tty->cr();\n+    output->cr();\n+    output->print(\"\\t  \");\n+    monitor->lock()->print_on(output, monitor->owner());\n+    output->cr();\n@@ -694,1 +694,1 @@\n-void javaVFrame::print_value() const {\n+void javaVFrame::print_value(outputStream* output) const {\n@@ -697,1 +697,1 @@\n-  tty->print_cr(\"frame( sp=\" INTPTR_FORMAT \", unextended_sp=\" INTPTR_FORMAT \", fp=\" INTPTR_FORMAT \", pc=\" INTPTR_FORMAT \")\",\n+  output->print_cr(\"frame( sp=\" INTPTR_FORMAT \", unextended_sp=\" INTPTR_FORMAT \", fp=\" INTPTR_FORMAT \", pc=\" INTPTR_FORMAT \")\",\n@@ -699,1 +699,1 @@\n-  tty->print(\"%s.%s\", k->internal_name(), m->name()->as_C_string());\n+  output->print(\"%s.%s\", k->internal_name(), m->name()->as_C_string());\n@@ -705,1 +705,1 @@\n-      tty->print(\"(%s:%d)\", source_name->as_C_string(), line_number);\n+      output->print(\"(%s:%d)\", source_name->as_C_string(), line_number);\n@@ -708,1 +708,1 @@\n-    tty->print(\"(Native Method)\");\n+    output->print(\"(Native Method)\");\n@@ -722,1 +722,1 @@\n-void javaVFrame::print_activation(int index) const {\n+void javaVFrame::print_activation(int index, outputStream* output) const {\n@@ -724,1 +724,1 @@\n-  tty->print(\"%2d - \", index);\n+  output->print(\"%2d - \", index);\n@@ -726,1 +726,1 @@\n-  tty->cr();\n+  output->cr();\n@@ -730,1 +730,1 @@\n-    tty->cr();\n+    output->cr();\n@@ -736,2 +736,2 @@\n-void externalVFrame::print() {\n-  _fr.print_value_on(tty,nullptr);\n+void externalVFrame::print(outputStream* output) {\n+  _fr.print_value_on(output, nullptr);\n@@ -740,2 +740,2 @@\n-void externalVFrame::print_value() const {\n-  ((vframe*)this)->print();\n+void externalVFrame::print_value(outputStream* output) const {\n+  ((vframe*)this)->print(output);\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -102,2 +102,2 @@\n-  virtual void print_value() const;\n-  virtual void print();\n+  virtual void print_value(outputStream* output = tty) const;\n+  virtual void print(outputStream* output = tty);\n@@ -148,3 +148,3 @@\n-  void print();\n-  void print_value() const;\n-  void print_activation(int index) const;\n+  void print(outputStream* output = tty);\n+  void print_value(outputStream* output = tty) const;\n+  void print_activation(int index, outputStream* output = tty) const;\n@@ -198,2 +198,2 @@\n-  void print_value() const;\n-  void print();\n+  void print_value(outputStream* output = tty) const;\n+  void print(outputStream* output = tty);\n@@ -214,2 +214,2 @@\n-  void print_value() const;\n-  void print();\n+  void print_value(outputStream* output = tty) const;\n+  void print(outputStream* output = tty);\n","filename":"src\/hotspot\/share\/runtime\/vframe.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.compiler2.enabled\n+ * @modules java.base\/jdk.internal.vm.annotation java.base\/jdk.internal.misc\n+ * @key randomness\n+ * @library \/test\/lib\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run testng\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -XX:CompileCommand=dontinline,TestConcurrentClose$SegmentAccessor::doAccess\n+ *   TestConcurrentClose\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.reflect.Method;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestConcurrentClose {\n+    static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    static final Method DO_ACCESS_METHOD;\n+    static final int C2_COMPILED_LEVEL = 4;\n+\n+    static {\n+        try {\n+            DO_ACCESS_METHOD = SegmentAccessor.class.getDeclaredMethod(\"doAccess\");\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    static final int ITERATIONS = 5;\n+    static final int SEGMENT_SIZE = 10_000;\n+    static final int MAX_EXECUTOR_WAIT_SECONDS = 20;\n+    static final int NUM_ACCESSORS = 50;\n+\n+    static final AtomicLong start = new AtomicLong();\n+    static final AtomicBoolean started = new AtomicBoolean();\n+\n+    @Test\n+    public void testHandshake() throws InterruptedException {\n+        for (int it = 0; it < ITERATIONS; it++) {\n+            System.out.println(\"ITERATION \" + it + \" - starting\");\n+            ExecutorService accessExecutor = Executors.newCachedThreadPool();\n+            start.set(System.currentTimeMillis());\n+            started.set(false);\n+            CountDownLatch startClosureLatch = new CountDownLatch(1);\n+\n+            for (int i = 0; i < NUM_ACCESSORS ; i++) {\n+                Arena arena = Arena.ofShared();\n+                MemorySegment segment = arena.allocate(SEGMENT_SIZE, 1);\n+                accessExecutor.execute(new SegmentAccessor(i, segment));\n+                accessExecutor.execute(new Closer(i, startClosureLatch, arena));\n+            }\n+\n+            awaitCompilation();\n+\n+            long closeDelay = System.currentTimeMillis() - start.get();\n+            System.out.println(\"Starting closers after delay of \" + closeDelay + \" millis\");\n+            startClosureLatch.countDown();\n+            accessExecutor.shutdown();\n+            assertTrue(accessExecutor.awaitTermination(MAX_EXECUTOR_WAIT_SECONDS, TimeUnit.SECONDS));\n+            long finishDelay = System.currentTimeMillis() - start.get();\n+            System.out.println(\"ITERATION \" + it + \" - finished, after \" + finishDelay + \"milis\");\n+        }\n+    }\n+\n+    static class SegmentAccessor implements Runnable {\n+        final MemorySegment segment;\n+        final int id;\n+        boolean hasFailed = false;\n+\n+        SegmentAccessor(int id, MemorySegment segment) {\n+            this.id = id;\n+            this.segment = segment;\n+        }\n+\n+        @Override\n+        public final void run() {\n+            start(\"Accessor #\" + id);\n+            while (segment.scope().isAlive()) {\n+                try {\n+                    doAccess();\n+                } catch (IllegalStateException ex) {\n+                    \/\/ scope was closed, loop should exit\n+                    assertFalse(hasFailed);\n+                    hasFailed = true;\n+                }\n+            }\n+            long delay = System.currentTimeMillis() - start.get();\n+            System.out.println(\"Accessor #\" + id + \" terminated - elapsed (ms): \" + delay);\n+        }\n+\n+        \/\/ keep this out of line, so it has a chance to be fully C2 compiled\n+        private int doAccess() {\n+            int sum = 0;\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                sum += segment.get(JAVA_BYTE, i);\n+            }\n+            return sum;\n+        }\n+    }\n+\n+    static class Closer implements Runnable {\n+        final int id;\n+        final Arena arena;\n+        final CountDownLatch startLatch;\n+\n+        Closer(int id, CountDownLatch startLatch, Arena arena) {\n+            this.id = id;\n+            this.arena = arena;\n+            this.startLatch = startLatch;\n+        }\n+\n+        @Override\n+        public void run() {\n+            start(\"Closer #\" + id);\n+            try {\n+                \/\/ try to close all at the same time, to simulate concurrent\n+                \/\/ closures of unrelated arenas\n+                startLatch.await();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"Unexpected interruption\", e);\n+            }\n+            arena.close(); \/\/ This should NOT throw\n+            long delay = System.currentTimeMillis() - start.get();\n+            System.out.println(\"Closer #\" + id + \"terminated - elapsed (ms): \" + delay);\n+        }\n+    }\n+\n+    static void start(String name) {\n+        if (started.compareAndSet(false, true)) {\n+            long delay = System.currentTimeMillis() - start.get();\n+            System.out.println(\"Started first thread: \" + name + \" ; elapsed (ms): \" + delay);\n+        }\n+    }\n+\n+    private static void awaitCompilation() throws InterruptedException {\n+        int retries = 0;\n+        while (WB.getMethodCompilationLevel(DO_ACCESS_METHOD, false) != C2_COMPILED_LEVEL) {\n+            if (retries > 20) {\n+                throw new IllegalStateException(\"SegmentAccessor::doAccess method not being compiled\");\n+            }\n+            Thread.sleep(1000);\n+            retries++;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestConcurrentClose.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -103,1 +103,1 @@\n-            start(\"\\\"Accessor #\\\" + id\");\n+            start(\"Accessor #\" + id);\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 10, time = 10, timeUnit = TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(1)\n+public class ConcurrentClose {\n+\n+    static final int SIZE = 10_000;\n+\n+    MemorySegment segment;\n+    byte[] array;\n+\n+    @Setup\n+    public void setup() {\n+        segment = Arena.global().allocate(SIZE);\n+        array = new byte[SIZE];\n+    }\n+\n+    @Benchmark\n+    @GroupThreads(1)\n+    @Group(\"sharedClose\")\n+    public void closing() {\n+        Arena arena = Arena.ofShared();\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    @GroupThreads(1)\n+    @Group(\"sharedClose\")\n+    public int memorySegmentAccess() {\n+        int sum = 0;\n+        for (int i = 0; i < segment.byteSize(); i++) {\n+            sum += segment.get(JAVA_BYTE, i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    @GroupThreads(1)\n+    @Group(\"sharedClose\")\n+    public int otherAccess() {\n+        int sum = 0;\n+        for (int i = 0; i < array.length; i++) {\n+            sum += array[i];\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ConcurrentClose.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}