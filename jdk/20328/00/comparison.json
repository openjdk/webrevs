{"files":[{"patch":"@@ -86,0 +86,6 @@\n+  \/\/ Return immediately if VM is not safe.\n+  if (!is_safe()) {\n+    log_info(jfr)(\"VM is not in safe state to perform path to GC roots operation, skipping\");\n+    return;\n+  }\n+\n@@ -132,0 +138,13 @@\n+\n+bool PathToGcRootsOperation::is_safe() {\n+#if INCLUDE_SHENANDOAHGC\n+  if (UseShenandoahGC) {\n+    \/\/ This operation uses mark words to track objects. While the operation\n+    \/\/ would restore the mark words after completion, it would interact with\n+    \/\/ mark word uses by Shenandoah itself, if we hit the op during the concurrent\n+    \/\/ GC cycle.\n+    return ShenandoahHeap::heap()->is_idle();\n+  }\n+#endif\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/pathToGcRootsOperation.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+  \/\/ Checks if VM is in safe state to perform this operation.\n+  bool is_safe();\n+\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/pathToGcRootsOperation.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,3 @@\n+            \/\/ Let GC catch up before we stop the recording and do the old object sample\n+            Thread.sleep(5000);\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestFieldInformation.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,0 +88,4 @@\n+\n+            \/\/ Let GC catch up before we stop the recording and do the old object sample\n+            Thread.sleep(5000);\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestLargeRootSet.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}