{"files":[{"patch":"@@ -50,0 +50,4 @@\n+#include \"utilities\/macros.hpp\"\n+#if INCLUDE_SHENANDOAHGC\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#endif\n@@ -86,0 +90,6 @@\n+  \/\/ Return immediately if VM is not safe.\n+  if (!is_safe()) {\n+    log_info(jfr)(\"VM is not in safe state to perform path to GC roots operation, skipping\");\n+    return;\n+  }\n+\n@@ -132,0 +142,14 @@\n+\n+bool PathToGcRootsOperation::is_safe() {\n+#if INCLUDE_SHENANDOAHGC\n+  if (UseShenandoahGC) {\n+    \/\/ This operation uses mark words to track objects. While the operation\n+    \/\/ would restore the mark words after completion, it would interact with\n+    \/\/ mark word uses by Shenandoah itself. This is a problem if we hit the op\n+    \/\/ when Shenandoah has forwarded objects, which means it uses mark words\n+    \/\/ to carry GC metadata.\n+    return !ShenandoahHeap::heap()->has_forwarded_objects();\n+  }\n+#endif\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/pathToGcRootsOperation.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+  \/\/ Checks if VM is in safe state to perform this operation.\n+  bool is_safe();\n+\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/pathToGcRootsOperation.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,15 @@\n+        \/\/ OldObjectSample might be skipped if GC is running shortly after\n+        \/\/ the allocations. Try with a few backoff intervals to let GC finish\n+        \/\/ before we stop the recording. This currently affects Shenandoah only.\n+        \/\/ There is no reason to wait unconditionally, if GC can manage with\n+        \/\/ a short backoff.\n+        for (int power = 0; power < 13; power++) {\n+            if (tryWith(1 << power)) {\n+                return;\n+            }\n+        }\n+\n+        Asserts.fail(\"Could not find old object with field 'testField'\");\n+    }\n+\n+    public static boolean tryWith(int backoff) throws Exception {\n@@ -60,0 +75,2 @@\n+            Thread.sleep(backoff);\n+\n@@ -63,1 +80,0 @@\n-            Events.hasEvents(events);\n@@ -66,1 +82,1 @@\n-                    return;\n+                    return true;\n@@ -69,2 +85,1 @@\n-            System.out.println(events);\n-            Asserts.fail(\"Could not find old object with field 'testField'\");\n+            return false;\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestFieldInformation.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.test.lib.Asserts;\n@@ -77,0 +78,16 @@\n+\n+        \/\/ OldObjectSample might be skipped if GC is running shortly after\n+        \/\/ the allocations. Try with a few backoff intervals to let GC finish\n+        \/\/ before we stop the recording. This currently affects Shenandoah only.\n+        \/\/ There is no reason to wait unconditionally, if GC can manage with\n+        \/\/ a short backoff.\n+        for (int power = 0; power < 13; power++) {\n+            if (tryWith(1 << power)) {\n+                return;\n+            }\n+        }\n+\n+        Asserts.fail(\"No events\");\n+    }\n+\n+    public static boolean tryWith(int backoff) throws Exception {\n@@ -88,0 +105,3 @@\n+\n+            Thread.sleep(backoff);\n+\n@@ -90,1 +110,0 @@\n-            Events.hasEvents(events);\n@@ -94,1 +113,1 @@\n-                    return;\n+                    return true;\n@@ -98,0 +117,2 @@\n+\n+        return false;\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestLargeRootSet.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"}]}