{"files":[{"patch":"@@ -50,0 +50,4 @@\n+#include \"utilities\/macros.hpp\"\n+#if INCLUDE_SHENANDOAHGC\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#endif\n@@ -86,0 +90,6 @@\n+  \/\/ Return immediately if VM is not safe.\n+  if (!is_safe()) {\n+    log_info(jfr)(\"VM is not in safe state to perform path to GC roots operation, skipping\");\n+    return;\n+  }\n+\n@@ -132,0 +142,14 @@\n+\n+bool PathToGcRootsOperation::is_safe() {\n+#if INCLUDE_SHENANDOAHGC\n+  if (UseShenandoahGC) {\n+    \/\/ This operation uses mark words to track objects. While the operation\n+    \/\/ would restore the mark words after completion, it would interact with\n+    \/\/ mark word uses by Shenandoah itself. This is a problem if we hit the op\n+    \/\/ when Shenandoah has forwarded objects, which means it uses mark words\n+    \/\/ to carry GC metadata.\n+    return !ShenandoahHeap::heap()->has_forwarded_objects();\n+  }\n+#endif\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/pathToGcRootsOperation.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+  \/\/ Checks if VM is in safe state to perform this operation.\n+  bool is_safe();\n+\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/pathToGcRootsOperation.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,14 @@\n+        \/\/ OldObjectSample is emitted at the end of the recording, and we need\n+        \/\/ to let GC catch up before we do the event. There is no reason to wait\n+        \/\/ for a long time if GC can manage it quickly. Try a few backoff intervals,\n+        \/\/ but try to complete as fast as possible.\n+        for (int power = 0; power < 13; power++) {\n+            if (tryWith(1 << power)) {\n+                return;\n+            }\n+        }\n+\n+        Asserts.fail(\"Could not find old object with field 'testField'\");\n+    }\n+\n+    public static boolean tryWith(int backoff) throws Exception {\n@@ -60,0 +74,2 @@\n+            Thread.sleep(backoff);\n+\n@@ -63,1 +79,0 @@\n-            Events.hasEvents(events);\n@@ -66,1 +81,1 @@\n-                    return;\n+                    return true;\n@@ -69,2 +84,1 @@\n-            System.out.println(events);\n-            Asserts.fail(\"Could not find old object with field 'testField'\");\n+            return false;\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestFieldInformation.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.test.lib.Asserts;\n@@ -77,0 +78,15 @@\n+\n+        \/\/ OldObjectSample is emitted at the end of the recording, and we need\n+        \/\/ to let GC catch up before we do the event. There is no reason to wait\n+        \/\/ for a long time if GC can manage it quickly. Try a few backoff intervals,\n+        \/\/ but try to complete as fast as possible.\n+        for (int power = 0; power < 13; power++) {\n+            if (tryWith(1 << power)) {\n+                return;\n+            }\n+        }\n+\n+        Asserts.fail(\"No events\");\n+    }\n+\n+    public static boolean tryWith(int backoff) throws Exception {\n@@ -88,0 +104,3 @@\n+\n+            Thread.sleep(backoff);\n+\n@@ -90,1 +109,0 @@\n-            Events.hasEvents(events);\n@@ -94,1 +112,1 @@\n-                    return;\n+                    return true;\n@@ -98,0 +116,2 @@\n+\n+        return false;\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestLargeRootSet.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"}]}