{"files":[{"patch":"@@ -216,7 +216,1 @@\n-  \/\/ But here we have to pay extra attention:\n-  \/\/ Do not narrow the type of range check dependent CastIINodes to\n-  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n-  \/\/ the corresponding range check is not removed.\n-  if (!_range_check_dependency) {\n-    res = widen_type(phase, res, T_INT);\n-  }\n+  res = widen_type(phase, res, T_INT);\n@@ -227,2 +221,4 @@\n-static Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, Node* control, const TypeInteger* type, ConstraintCastNode::DependencyType dependency, BasicType bt) {\n-  Node* n = ConstraintCastNode::make_cast_for_basic_type(control, parent, type, dependency, bt);\n+Node* ConstraintCastNode::find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const {\n+  Node* n = clone();\n+  n->set_req(1, parent);\n+  n->as_ConstraintCast()->set_type(type);\n@@ -242,1 +238,1 @@\n-  if (can_reshape && !_range_check_dependency && !phase->C->post_loop_opts_phase()) {\n+  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n@@ -246,1 +242,1 @@\n-  if (!_range_check_dependency) {\n+  if (!_range_check_dependency || phase->C->post_loop_opts_phase()) {\n@@ -249,0 +245,1 @@\n+  phase->C->record_for_post_loop_opts_igvn(this);\n@@ -257,7 +254,0 @@\n-  if (_range_check_dependency) {\n-    if (phase->C->post_loop_opts_phase()) {\n-      return this->in(1);\n-    } else {\n-      phase->C->record_for_post_loop_opts_igvn(this);\n-    }\n-  }\n@@ -292,0 +282,28 @@\n+void CastIINode::remove_range_check_cast(Compile* C) {\n+  if (has_range_check()) {\n+    \/\/ Range check CastII nodes feed into an address computation subgraph. Remove them to let that subgraph float freely.\n+    \/\/ For memory access or integer divisions nodes that depend on the cast, record the dependency on the cast's control\n+    \/\/ as a precedence edge, so they can't float above the cast in case that cast's narrowed type helped eliminate a\n+    \/\/ range check or a null divisor check.\n+    assert(in(0) != nullptr, \"All RangeCheck CastII must have a control dependency\");\n+    ResourceMark rm;\n+    Unique_Node_List wq;\n+    wq.push(this);\n+    for (uint next = 0; next < wq.size(); ++next) {\n+      Node* m = wq.at(next);\n+      for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n+        Node* use = m->fast_out(i);\n+        if (use->is_Mem() || use->is_div_or_mod(T_INT) || use->is_div_or_mod(T_LONG)) {\n+          use->ensure_control_or_add_prec(in(0));\n+        } else if (!use->is_CFG() && !use->is_Phi()) {\n+          wq.push(use);\n+        }\n+      }\n+    }\n+    subsume_by(in(1), C);\n+    if (outcnt() == 0) {\n+      disconnect_inputs(C);\n+    }\n+  }\n+}\n+\n@@ -492,2 +510,2 @@\n-    Node* cx = find_or_make_integer_cast(igvn, x, in(0), rx, _dependency, bt);\n-    Node* cy = find_or_make_integer_cast(igvn, y, in(0), ry, _dependency, bt);\n+    Node* cx = find_or_make_integer_cast(igvn, x, rx);\n+    Node* cy = find_or_make_integer_cast(igvn, y, ry);\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":38,"deletions":20,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const;\n@@ -124,0 +125,1 @@\n+  void remove_range_check_cast(Compile* C);\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3146,0 +3146,7 @@\n+    \/\/ If the divisor input for a Div (or Mod etc.) is not zero, then the control input of the Div is set to zero.\n+    \/\/ It could be that the divisor input is found not zero because its type is narrowed down by a CastII in the\n+    \/\/ subgraph for that input. Range check CastIIs are removed during final graph reshape. To preserve the dependency\n+    \/\/ carried by a CastII, precedence edges are added to the Div node. We need to transfer the precedence edges to the\n+    \/\/ DivMod node so the dependency is not lost.\n+    divmod->add_prec_from(n);\n+    divmod->add_prec_from(d);\n@@ -3431,0 +3438,4 @@\n+  case Op_CastII: {\n+    n->as_CastII()->remove_range_check_cast(this);\n+    break;\n+  }\n@@ -3582,10 +3593,0 @@\n-#ifdef ASSERT\n-  case Op_CastII:\n-    \/\/ Verify that all range check dependent CastII nodes were removed.\n-    if (n->isa_CastII()->has_range_check()) {\n-      n->dump(3);\n-      assert(false, \"Range check dependent CastII node was not removed\");\n-    }\n-    break;\n-#endif\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2897,0 +2897,9 @@\n+void Node::add_prec_from(Node* n) {\n+  for (uint i = n->req(); i < n->len(); i++) {\n+    Node* prec = n->in(i);\n+    if (prec != nullptr) {\n+      add_prec(prec);\n+    }\n+  }\n+}\n+\n@@ -2920,0 +2929,3 @@\n+bool Node::is_div_or_mod(BasicType bt) const { return Opcode() == Op_Div(bt) || Opcode() == Op_Mod(bt) ||\n+                                                      Opcode() == Op_UDiv(bt) || Opcode() == Op_UMod(bt); }\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1170,0 +1170,1 @@\n+  void add_prec_from(Node* n);\n@@ -1281,0 +1282,2 @@\n+  bool is_div_or_mod(BasicType bt) const;\n+\n@@ -2060,0 +2063,4 @@\n+Op_IL(Div)\n+Op_IL(Mod)\n+Op_IL(UDiv)\n+Op_IL(UMod)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,474 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8332827\n+ * @summary [REDO] C2: crash in compiled code because of dependency on removed range check CastIIs\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ *\n+ *\/\n+\n+public class TestArrayAccessAboveRCAfterRCCastIIEliminated {\n+    private static int intField;\n+    private static long longField;\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(9, 10, 1, true);\n+            test1(9, 10, 1, false);\n+            test2(9, 10, 1, true);\n+            test2(9, 10, 1, false);\n+            test3(9, 10, 1, true);\n+            test3(9, 10, 1, false);\n+            test4(9, 10, 1, true);\n+            test4(9, 10, 1, false);\n+            test5(9, 10, 1, true);\n+            test5(9, 10, 1, false);\n+            test6(9, 10, 1, true);\n+            test6(9, 10, 1, false);\n+            test7(9, 10, 1, true);\n+            test7(9, 10, 1, false);\n+            test8(9, 10, 1, true);\n+            test8(9, 10, 1, false);\n+            test9(9, 10, 1, true);\n+            test9(9, 10, 1, false);\n+            test10(9, 10, 1, true);\n+            test10(9, 10, 1, false);\n+            test11(9, 10, 1, true);\n+            test11(9, 10, 1, false);\n+            test12(9, 10, 1, true);\n+            test12(9, 10, 1, false);\n+            test13(9, 10, 1, true);\n+            test13(9, 10, 1, false);\n+        }\n+        try {\n+            test1(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test2(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test3(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test4(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test5(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test6(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test7(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test8(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test9(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test10(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test11(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test12(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test13(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+    }\n+\n+    private static void test1(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test2(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test3(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test4(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test5(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test6(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test7(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+    private static void test8(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test9(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test10(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test11(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test12(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n+                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n+                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test13(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n+                    Long.divideUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n+                    Long.divideUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void notInlined(int[] array) {\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java","additions":474,"deletions":0,"binary":false,"changes":474,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8332827\n+ * @summary [REDO] C2: crash in compiled code because of dependency on removed range check CastIIs\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation TestRangeCheckCastIISplitThruPhi\n+ * @run main TestRangeCheckCastIISplitThruPhi\n+ *\n+ *\/\n+\n+import java.util.Arrays;\n+\n+public class TestRangeCheckCastIISplitThruPhi {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[100];\n+        int[] baseline = null;\n+        for (int i = 0; i < 20_000; i++) {\n+            Arrays.fill(array, 0);\n+            test1(array);\n+            if (baseline == null) {\n+                baseline = array.clone();\n+            } else {\n+                boolean failures = false;\n+                for (int j = 0; j < array.length; j++) {\n+                    if (array[j] != baseline[j]) {\n+                        System.out.println(\"XXX @\" + j + \" \" + array[j] + \" != \" + baseline[j]);\n+                       failures = true;\n+                    }\n+                }\n+                if (failures) {\n+                    throw new RuntimeException();\n+                }\n+            }\n+            test2(array, true);\n+            test2(array, false);\n+        }\n+    }\n+\n+    private static void test1(int[] array) {\n+        int[] array2 = new int[100];\n+        int j = 4;\n+        int i = 3;\n+        int k;\n+        for (k = 1; k < 2; k *= 2) {\n+\n+        }\n+        int stride = k \/ 2;\n+        do {\n+            synchronized (new Object()) {\n+            }\n+            array2[j-1] = 42;\n+            array[j+1] = 42;\n+            j = i;\n+            i -= stride;\n+        } while (i >= 0);\n+    }\n+\n+    private static void test2(int[] array, boolean flag) {\n+        int[] array2 = new int[100];\n+        int j = 4;\n+        int i = 3;\n+        int k;\n+        for (k = 1; k < 2; k *= 2) {\n+\n+        }\n+        int stride = k \/ 2;\n+        if (flag) {\n+            volatileField = 42;\n+            array[0] = 42;\n+        } else {\n+            do {\n+                synchronized (new Object()) {\n+                }\n+                array2[j - 1] = 42;\n+                array[j + 1] = 42;\n+                j = i;\n+                i -= stride;\n+            } while (i >= 0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckCastIISplitThruPhi.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8332827\n+ * @summary [REDO] C2: crash in compiled code because of dependency on removed range check CastIIs\n+ *\n+ * @library \/test\/lib \/\n+ * @run driver TestVectorizationNegativeScale\n+ *\n+ *\/\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Arrays;\n+\n+public class TestVectorizationNegativeScale {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    static byte[] array = new byte[1000];\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR , \">= 1\"})\n+    private static void test1(byte[] array, int start) {\n+        for (int i = start; i < array.length; i++) {\n+            array[array.length - i - 1] = 0x42;\n+        }\n+    }\n+\n+    @Run(test = \"test1\")\n+    private static void test1Runner() {\n+        Arrays.fill(array, (byte)0);\n+        test1(array, 0);\n+        for (int j = 0; j < array.length; j++) {\n+            if (array[j] != 0x42) {\n+                throw new RuntimeException(\"For index \" + j + \": \" + array[j]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorizationNegativeScale.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"}]}