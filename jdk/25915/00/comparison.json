{"files":[{"patch":"@@ -32,1 +32,0 @@\n-#include \"interpreter\/interpreterRuntime.hpp\"\n@@ -37,3 +36,1 @@\n-#include \"oops\/resolvedFieldEntry.hpp\"\n-#include \"oops\/resolvedIndyEntry.hpp\"\n-#include \"oops\/resolvedMethodEntry.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -42,2 +39,0 @@\n-#include \"runtime\/osThread.hpp\"\n-#include \"runtime\/timer.hpp\"\n@@ -88,4 +83,5 @@\n-  BytecodePrinter(int flags = 0) {\n-    _is_wide = false;\n-    _code = Bytecodes::_illegal;\n-    _flags = flags;\n+  BytecodePrinter(int flags = 0) : _is_wide(false), _code(Bytecodes::_illegal), _flags(flags) {}\n+\n+#ifndef PRODUCT\n+  BytecodePrinter(Method* prev_method) : BytecodePrinter(0) {\n+    _current_method = prev_method;\n@@ -99,0 +95,4 @@\n+    _current_method = method();\n+    _is_linked = method->method_holder()->is_linked();\n+    assert(_is_linked, \"this function must be called on methods that are already executing\");\n+\n@@ -110,3 +110,0 @@\n-      _current_method = method();\n-      _is_linked = method->method_holder()->is_linked();\n-      assert(_is_linked, \"this function must be called on methods that are already executing\");\n@@ -145,1 +142,0 @@\n-#ifndef PRODUCT\n@@ -149,1 +145,0 @@\n-#endif\n@@ -151,0 +146,1 @@\n+#endif\n@@ -152,1 +148,1 @@\n-  \/\/ Used for Method*::print_codes().  The input bcp comes from\n+  \/\/ Used for Method::print_codes().  The input bcp comes from\n@@ -182,3 +178,4 @@\n-\/\/ We need a global instance to keep track of the states when the bytecodes\n-\/\/ are executed. Access by multiple threads are controlled by ttyLocker.\n-static BytecodePrinter _interpreter_printer;\n+\/\/ We need a global instance to keep track of the method being printed so we can report that\n+\/\/ the method has changed. If this method is redefined and removed, that's ok because the method passed in won't match, and\n+\/\/ this will print that one.\n+static Method* _current_method = nullptr;\n@@ -188,7 +185,4 @@\n-    ttyLocker ttyl;  \/\/ 5065316: keep the following output coherent\n-    \/\/ The ttyLocker also prevents races between two threads\n-    \/\/ trying to use the single instance of BytecodePrinter.\n-    \/\/\n-    \/\/ There used to be a leaf mutex here, but the ttyLocker will\n-    \/\/ work just as well, as long as the printing operations never block.\n-    _interpreter_printer.trace(method, bcp, tos, tos2, st);\n+    BytecodePrinter printer(_current_method);\n+    printer.trace(method, bcp, tos, tos2, st);\n+    \/\/ Save current method to detect when method printing changes.\n+    Atomic::release_store(&_current_method, method());\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":20,"deletions":26,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm -XX:+TraceBytecodes -XX:TraceBytecodesAt=2000 -XX:TraceBytecodesStopAt=3000 TraceBytecodes\n+ * @run main\/othervm -XX:+TraceBytecodes -XX:TraceBytecodesAt=1000000 -XX:TraceBytecodesStopAt=1001000 TraceBytecodes\n@@ -32,1 +32,2 @@\n-\/\/ This is just a very simple sanity test. Trace about 1000 bytecodes. See the .jtr file for the output.\n+\/\/ CountBytecodes returns 1826384 bytecodes, so trace starting at a million to trace parallel threads.\n+\/\/ This is just a very simple sanity test. See the .jtr file for the output.\n@@ -34,2 +35,2 @@\n-public class TraceBytecodes {\n-    public static void main(String args[]) {\n+public class TraceBytecodes extends Thread {\n+    public void run() {\n@@ -38,0 +39,28 @@\n+\n+    private static TraceBytecodes[] threads = new TraceBytecodes[2];\n+    private static boolean success = true;\n+\n+    private static boolean report_success() {\n+        for (int i = 0; i < 2; i++) {\n+          try {\n+            threads[i].join();\n+          } catch (InterruptedException e) {}\n+        }\n+        return success;\n+    }\n+\n+    public static void main(String args[]) {\n+        threads[0] = new TraceBytecodes();\n+        threads[1] = new TraceBytecodes();\n+        for (int i = 0; i < 2; i++) {\n+            threads[i].setName(\"Loading Thread #\" + (i + 1));\n+            threads[i].start();\n+            System.out.println(\"Thread \" + (i + 1) + \" was started...\");\n+        }\n+\n+        if (report_success()) {\n+           System.out.println(\"PASSED\");\n+        } else {\n+            throw new RuntimeException(\"FAILED\");\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/TraceBytecodes.java","additions":34,"deletions":5,"binary":false,"changes":39,"status":"modified"}]}