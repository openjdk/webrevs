{"files":[{"patch":"@@ -54,0 +54,1 @@\n+import jdk.tools.jlink.internal.plugins.StripJavaDebugAttributesPlugin;\n@@ -421,0 +422,3 @@\n+            \/\/ reference to the enabled DefaultStripDebugPlugin\n+            DefaultStripDebugPlugin defaultStripDebugPlugin = null;\n+\n@@ -441,0 +445,4 @@\n+                    if (plugin instanceof DefaultStripDebugPlugin p) {\n+                        defaultStripDebugPlugin = p;\n+                    }\n+\n@@ -455,0 +463,5 @@\n+            \/\/ disable StripJavaDebugAttributesPlugin within DefaultStripDebug plugin if both enabled\n+            if (seenPlugins.contains(StripJavaDebugAttributesPlugin.NAME) && defaultStripDebugPlugin != null) {\n+                defaultStripDebugPlugin.enableJavaStripPlugin(false);\n+            }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/TaskHelper.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+    private boolean isJavaStripPluginEnabled = true;\n+\n@@ -62,0 +64,4 @@\n+    public void enableJavaStripPlugin(boolean enableJavaStripPlugin) {\n+        isJavaStripPluginEnabled = enableJavaStripPlugin;\n+    }\n+\n@@ -69,0 +75,5 @@\n+\n+            if (!isJavaStripPluginEnabled) {\n+                return stripNativePlugin.transform(in, out);\n+            }\n+\n@@ -75,1 +86,1 @@\n-        } else {\n+        } else if (isJavaStripPluginEnabled) {\n@@ -77,0 +88,2 @@\n+        } else {\n+            return in;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/DefaultStripDebugPlugin.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    public static final String NAME = \"strip-java-debug-attributes\";\n@@ -52,1 +53,1 @@\n-        super(\"strip-java-debug-attributes\");\n+        super(NAME);\n@@ -72,5 +73,3 @@\n-                                                            || cle instanceof SourceDebugExtensionAttribute)\n-                                              .andThen(ClassTransform.transformingMethods(MethodTransform\n-                                                    .dropping(me -> me instanceof MethodParametersAttribute)\n-                                                    .andThen(MethodTransform\n-                                                            .transformingCode(CodeTransform.ACCEPT_ALL)))));\n+                                                        || cle instanceof SourceDebugExtensionAttribute)\n+                                        .andThen(ClassTransform.transformingMethods(MethodTransform\n+                                                .transformingCode(CodeTransform.ACCEPT_ALL))));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/StripJavaDebugAttributesPlugin.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -76,0 +76,34 @@\n+    public void testOnlyNativePlugin() {\n+        MockStripPlugin javaPlugin = new MockStripPlugin(false);\n+        MockStripPlugin nativePlugin = new MockStripPlugin(true);\n+        TestNativeStripPluginFactory nativeFactory =\n+                                 new TestNativeStripPluginFactory(nativePlugin);\n+        DefaultStripDebugPlugin plugin = new DefaultStripDebugPlugin(javaPlugin,\n+                                                                     nativeFactory);\n+        plugin.enableJavaStripPlugin(false);\n+\n+        ResourcePoolManager inManager = new ResourcePoolManager();\n+        ResourcePool pool = plugin.transform(inManager.resourcePool(),\n+                                             inManager.resourcePoolBuilder());\n+        if (pool.findEntry(MockStripPlugin.JAVA_PATH).isPresent() ||\n+            !pool.findEntry(MockStripPlugin.NATIVE_PATH).isPresent()) {\n+            throw new AssertionError(\"Expected only native to get called\");\n+        }\n+    }\n+\n+    public void testNoOperation() {\n+        MockStripPlugin javaPlugin = new MockStripPlugin(false);\n+        TestNativeStripPluginFactory nativeFactory =\n+                                         new TestNativeStripPluginFactory(null);\n+        DefaultStripDebugPlugin plugin = new DefaultStripDebugPlugin(javaPlugin,\n+                                                                     nativeFactory);\n+        plugin.enableJavaStripPlugin(false);\n+        ResourcePoolManager inManager = new ResourcePoolManager();\n+        ResourcePool pool = plugin.transform(inManager.resourcePool(),\n+                                             inManager.resourcePoolBuilder());\n+        if (pool.findEntry(MockStripPlugin.JAVA_PATH).isPresent() ||\n+            pool.findEntry(MockStripPlugin.NATIVE_PATH).isPresent()) {\n+            throw new AssertionError(\"Expected both native and java not called\");\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jlink\/plugins\/DefaultStripDebugPluginTest.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.FieldSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.io.IOException;\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import java.util.spi.ToolProvider;\n+\n+import tests.JImageGenerator;\n+import tests.JImageGenerator.InMemorySourceFile;\n+import tests.Result;\n+\n+\/*\n+ * @test\n+ * @summary Test jlink strip debug plugins handle method parameter names.\n+ * @bug 8347007\n+ * @library ..\/..\/lib\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jmod\n+ *          jdk.jlink\/jdk.tools.jimage\n+ *          jdk.compiler\n+ * @build tests.*\n+ * @run junit\/othervm StripParameterNamesTest\n+ *\/\n+public class StripParameterNamesTest {\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+            .orElseThrow(() -> new RuntimeException(\"javac tool not found\"));\n+\n+    private static Path src = Paths.get(\"src\").toAbsolutePath();\n+    private static List<Jmod> testJmods = new ArrayList<>();\n+\n+    record Jmod(Path moduleDir, boolean withDebugInfo, boolean withParameterNames) {}\n+\n+    @BeforeAll\n+    public static void setup() throws IOException {\n+        Files.createDirectory(src);\n+        var mainClassSource = new InMemorySourceFile(\"test\", \"InspectParameterNames\", \"\"\"\n+                package test;\n+\n+                public class InspectParameterNames {\n+                    int add(int a, int b) {\n+                        return a + b;\n+                    }\n+\n+                    public static boolean hasParameterNames() throws NoSuchMethodException {\n+                        \/\/ Get add method in the class\n+                        var method = InspectParameterNames.class.getDeclaredMethod(\"add\", int.class, int.class);\n+\n+                        \/\/ Get method parameters\n+                        var parameters = method.getParameters();\n+\n+                        \/\/ validate parameter names\n+                        return parameters[0].getName().equals(\"a\") && parameters[1].getName().equals(\"b\");\n+                    }\n+\n+                    public static void main(String[] args) throws NoSuchMethodException {\n+                        System.out.println(hasParameterNames());\n+                    }\n+                }\n+            \"\"\");\n+        var moduleDir = JImageGenerator.generateSources(src, \"bug8347007x\", List.of(mainClassSource));\n+        JImageGenerator.generateModuleInfo(moduleDir, List.of(\"test\"));\n+        testJmods.add(buildJmod(true, true));\n+        testJmods.add(buildJmod(true, false));\n+        testJmods.add(buildJmod(false, true));\n+        testJmods.add(buildJmod(false, false));\n+    }\n+\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        rmdir(Paths.get(\"img\"));\n+    }\n+\n+    static void report(String command, List<String> args) {\n+        System.out.println(command + \" \" + String.join(\" \", args));\n+    }\n+\n+    static void javac(List<String> args) {\n+        report(\"javac\", args);\n+        JAVAC_TOOL.run(System.out, System.err, args.toArray(new String[0]));\n+    }\n+    \/**\n+     * Recursively remove a Directory\n+     *\n+     * @param dir Directory to delete\n+     * @throws IOException If an error occurs\n+     *\/\n+    static void rmdir(Path dir) throws IOException {\n+        \/\/ Nothing to do if the file does not exist\n+        if (!Files.exists(dir)) {\n+            return;\n+        }\n+        try (Stream<Path> walk = Files.walk(dir)) {\n+            walk.sorted(Comparator.reverseOrder())\n+                    .map(Path::toFile)\n+                    .forEach(File::delete);\n+        }\n+    }\n+\n+    \/**\n+     * Build jmods from the module source path\n+     *\/\n+    static Jmod buildJmod(boolean withDebugInfo, boolean withParameterNames) {\n+        String dirName = \"jmods\";\n+        List<String> options = new ArrayList<>();\n+\n+        if (withDebugInfo) {\n+            options.add(\"-g\");\n+            dirName += \"g\";\n+        }\n+\n+        if (withParameterNames) {\n+            options.add(\"-parameters\");\n+            dirName += \"p\";\n+        }\n+\n+        Path moduleDir = Paths.get(dirName).toAbsolutePath();\n+\n+        options.add(\"-d\");\n+        options.add(moduleDir.toString());\n+        options.add(\"--module-source-path\");\n+        options.add(src.toString());\n+        options.add(\"--module\");\n+        options.add(\"bug8347007x\");\n+\n+        javac(options);\n+        return new Jmod(moduleDir, withDebugInfo, withParameterNames);\n+    }\n+\n+    Result buildImage(Path modulePath, Path imageDir, String... options) {\n+        var jlinkTask = JImageGenerator.getJLinkTask()\n+                .modulePath(modulePath.toString())\n+                .output(imageDir);\n+\n+        for (var option: options) {\n+            jlinkTask.option(option);\n+        }\n+\n+        return jlinkTask.addMods(\"bug8347007x\")\n+                .call();\n+    }\n+\n+    void assertHasParameterNames(Path imageDir, boolean expected) throws IOException, InterruptedException {\n+        Path binDir = imageDir.resolve(\"bin\").toAbsolutePath();\n+        Path bin = binDir.resolve(\"java\");\n+\n+        ProcessBuilder processBuilder = new ProcessBuilder(bin.toString(),\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+BytecodeVerificationLocal\",\n+                \"-m\", \"bug8347007x\/test.InspectParameterNames\");\n+        processBuilder.directory(binDir.toFile());\n+        Process process = processBuilder.start();\n+        int exitCode = process.waitFor();\n+        var output = process.inputReader().readLine();\n+        System.out.println(output);\n+        assertEquals(expected, Boolean.parseBoolean(output));\n+    }\n+\n+    Stream<Jmod> provideTestJmods() {\n+        return testJmods.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @FieldSource(\"testJmods\")\n+    public void testDefaultBehavior(Jmod jmod) throws Exception {\n+        var imageDir = Paths.get(\"img\");\n+        buildImage(jmod.moduleDir(), imageDir)\n+            .assertSuccess();\n+        var hasParameter = jmod.withParameterNames();\n+        assertHasParameterNames(imageDir, hasParameter);\n+    }\n+\n+    @ParameterizedTest\n+    @FieldSource(\"testJmods\")\n+    public void testStripDebug(Jmod jmod) throws Exception {\n+        var imageDir = Paths.get(\"img\");\n+        buildImage(jmod.moduleDir(), imageDir,\n+                \"--strip-debug\")\n+            .assertSuccess();\n+        var hasParameter = jmod.withParameterNames();\n+        assertHasParameterNames(imageDir, hasParameter);\n+    }\n+\n+    @Test\n+    public void testWithoutStripParameterName() throws Exception {\n+        var imageDir = Paths.get(\"img\");\n+        var jmod = testJmods.get(0);\n+        buildImage(jmod.moduleDir(), imageDir,\n+                \"--strip-debug\", \"--strip-java-debug-attributes\")\n+            .assertSuccess();\n+        assertHasParameterNames(imageDir, jmod.withParameterNames());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jlink\/plugins\/StripParameterNamesTest.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"}]}