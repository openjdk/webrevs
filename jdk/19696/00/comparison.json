{"files":[{"patch":"@@ -810,0 +810,5 @@\n+\/\/ We use two comparisons, because a subtraction could underflow.\n+#define RETURN_CMP_VALUE_IF_NOT_EQUAL(a, b) \\\n+  if (a < b) { return -1; }                 \\\n+  if (a > b) { return  1; }\n+\n@@ -816,5 +821,3 @@\n-  int cmp_base = a->base()->_idx - b->base()->_idx;\n-  if (cmp_base != 0) { return cmp_base; }\n-\n-  int cmp_opcode = a->mem()->Opcode() - b->mem()->Opcode();\n-  if (cmp_opcode != 0) { return cmp_opcode; }\n+  RETURN_CMP_VALUE_IF_NOT_EQUAL(a->base()->_idx,     b->base()->_idx);\n+  RETURN_CMP_VALUE_IF_NOT_EQUAL(a->mem()->Opcode(),  b->mem()->Opcode());\n+  RETURN_CMP_VALUE_IF_NOT_EQUAL(a->scale_in_bytes(), b->scale_in_bytes());\n@@ -822,2 +825,3 @@\n-  int cmp_scale = a->scale_in_bytes() - b->scale_in_bytes();\n-  if (cmp_scale != 0) { return cmp_scale; }\n+  int a_inva_idx = a->invar() == nullptr ? 0 : a->invar()->_idx;\n+  int b_inva_idx = b->invar() == nullptr ? 0 : b->invar()->_idx;\n+  RETURN_CMP_VALUE_IF_NOT_EQUAL(a_inva_idx,          b_inva_idx);\n@@ -825,3 +829,1 @@\n-  int cmp_invar = (a->invar() == nullptr ? 0 : a->invar()->_idx) -\n-                  (b->invar() == nullptr ? 0 : b->invar()->_idx);\n-  return cmp_invar;\n+  return 0; \/\/ equal\n@@ -838,4 +840,3 @@\n-  int cmp_offset = a->offset_in_bytes() - b->offset_in_bytes();\n-  if (cmp_offset != 0) { return cmp_offset; }\n-\n-  return a->mem()->_idx - b->mem()->_idx;\n+  RETURN_CMP_VALUE_IF_NOT_EQUAL(a->offset_in_bytes(), b->offset_in_bytes());\n+  RETURN_CMP_VALUE_IF_NOT_EQUAL(a->mem()->_idx,       b->mem()->_idx);\n+  return 0; \/\/ equal\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8334228\n+ * @summary Test sorting of VPointer by offset, when subtraction of two offsets can overflow.\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.vectorization.TestOffsetSorting::test -Xcomp compiler.vectorization.TestOffsetSorting\n+ * @run main compiler.vectorization.TestOffsetSorting\n+ *\/\n+\n+package compiler.vectorization;\n+\n+public class TestOffsetSorting {\n+    static int RANGE = 10_000;\n+\n+    public static void main(String[] args) {\n+        int[] a = new int[RANGE];\n+        for (int i = 0; i < 10_000; i++) {\n+            try {\n+                test(a, 0);\n+                throw new RuntimeException(\"test should go out-of-bounds\");\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+            }\n+        }\n+    }\n+\n+    static void test(int[] a, int invar) {\n+        int large = (1 << 28) + (1 << 20);\n+        for (int i = 0; i < 1_000; i++) {\n+            a[i + invar - large] = 42;\n+            a[i + invar + large] = 42;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestOffsetSorting.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"}]}