{"files":[{"patch":"@@ -755,0 +755,2 @@\n+  template(encodeAnnotations_name,                     \"encodeAnnotations\")                                       \\\n+  template(encodeAnnotations_signature,                \"([BLjava\/lang\/Class;Ljdk\/internal\/reflect\/ConstantPool;Z[Ljava\/lang\/Class;)[B\")\\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2625,3 +2625,1 @@\n-C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), jint index))\n-  requireInHotSpot(\"asReflectionField\", JVMCI_CHECK_NULL);\n-  Klass* klass = UNPACK_PAIR(Klass, klass);\n+static InstanceKlass* check_field(Klass* klass, jint index, JVMCI_TRAPS) {\n@@ -2634,1 +2632,1 @@\n-  if (index < 0 ||index > fields->length()) {\n+  if (index < 0 || index > fields->length()) {\n@@ -2638,0 +2636,7 @@\n+  return iklass;\n+}\n+\n+C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), jint index))\n+  requireInHotSpot(\"asReflectionField\", JVMCI_CHECK_NULL);\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  InstanceKlass* iklass = check_field(klass, index, JVMCIENV);\n@@ -2643,0 +2648,98 @@\n+static jbyteArray get_encoded_annotation_data(InstanceKlass* holder, typeArrayHandle annotations, bool for_class,\n+                                              jint filter_length, InstanceKlass** filter,\n+                                              JavaThread* THREAD, JVMCIEnv* JVMCIENV) {\n+  \/\/ Get a ConstantPool object for annotation parsing\n+  Handle jcp = reflect_ConstantPool::create(CHECK_NULL);\n+  reflect_ConstantPool::set_cp(jcp(), holder->constants());\n+\n+  \/\/ load VMSupport\n+  Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();\n+  Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK_NULL);\n+\n+  InstanceKlass* vm_support = InstanceKlass::cast(k);\n+  if (vm_support->should_be_initialized()) {\n+    vm_support->initialize(CHECK_NULL);\n+  }\n+\n+  objArrayOop filter_oop = oopFactory::new_objectArray(filter_length, CHECK_NULL);\n+  objArrayHandle filter_classes(THREAD, filter_oop);\n+  for (int i = 0; i < filter_length; i++) {\n+    filter_classes->obj_at_put(i, filter[i]->java_mirror());\n+  }\n+\n+  \/\/ invoke VMSupport.encodeAnnotations\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_oop(annotations);\n+  args.push_oop(Handle(THREAD, holder->java_mirror()));\n+  args.push_oop(jcp);\n+  args.push_int(for_class);\n+  args.push_oop(filter_classes);\n+  Symbol* signature = vmSymbols::encodeAnnotations_signature();\n+  JavaCalls::call_static(&result,\n+                         vm_support,\n+                         vmSymbols::encodeAnnotations_name(),\n+                         signature,\n+                         &args,\n+                         CHECK_NULL);\n+\n+  oop res = result.get_oop();\n+  if (JVMCIENV->is_hotspot()) {\n+    return (jbyteArray) JNIHandles::make_local(THREAD, res);\n+  }\n+\n+  typeArrayOop ba = typeArrayOop(res);\n+  int ba_len = ba->length();\n+  if (ba_len <= 256) {\n+    \/\/ Avoid resource allocation for the common case.\n+    jbyte ba_buf[256];\n+    memcpy(ba_buf, ba->byte_at_addr(0), ba_len);\n+    JVMCIPrimitiveArray ba_dest = JVMCIENV->new_byteArray(ba_len, JVMCI_CHECK_NULL);\n+    JVMCIENV->copy_bytes_from(ba_buf, ba_dest, 0, ba_len);\n+    return JVMCIENV->get_jbyteArray(ba_dest);\n+  }\n+\n+  jbyte* ba_buf = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, jbyte, ba_len);\n+  if (ba_buf == nullptr) {\n+    JVMCI_THROW_MSG_NULL(InternalError,\n+              err_msg(\"could not allocate %d bytes\", ba_len));\n+\n+  }\n+  memcpy(ba_buf, ba->byte_at_addr(0), ba_len);\n+  JVMCIPrimitiveArray ba_dest = JVMCIENV->new_byteArray(ba_len, JVMCI_CHECK_NULL);\n+  JVMCIENV->copy_bytes_from(ba_buf, ba_dest, 0, ba_len);\n+  return JVMCIENV->get_jbyteArray(ba_dest);\n+}\n+\n+C2V_VMENTRY_NULL(jbyteArray, getEncodedClassAnnotationData, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass),\n+                 jobject filter, jint filter_length, jlong filter_klass_pointers))\n+  InstanceKlass* holder = InstanceKlass::cast(UNPACK_PAIR(Klass, klass));\n+  InstanceKlass** filter_klasses = (InstanceKlass**) filter_klass_pointers;\n+\n+  typeArrayOop annotations_oop = Annotations::make_java_array(holder->class_annotations(), CHECK_NULL);\n+  typeArrayHandle annotations = typeArrayHandle(THREAD, annotations_oop);\n+  return get_encoded_annotation_data(holder, annotations, true, filter_length, filter_klasses, THREAD, JVMCIENV);\n+C2V_END\n+\n+C2V_VMENTRY_NULL(jbyteArray, getEncodedExecutableAnnotationData, (JNIEnv* env, jobject, ARGUMENT_PAIR(method),\n+                 jobject filter, jint filter_length, jlong filter_klass_pointers))\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n+  InstanceKlass* holder = method->method_holder();\n+  InstanceKlass** filter_klasses = (InstanceKlass**) filter_klass_pointers;\n+\n+  typeArrayOop annotations_oop = Annotations::make_java_array(method->annotations(), CHECK_NULL);\n+  typeArrayHandle annotations = typeArrayHandle(THREAD, annotations_oop);\n+  return get_encoded_annotation_data(holder, annotations, false, filter_length, filter_klasses, THREAD, JVMCIENV);\n+C2V_END\n+\n+C2V_VMENTRY_NULL(jbyteArray, getEncodedFieldAnnotationData, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), jint index,\n+                 jobject filter, jint filter_length, jlong filter_klass_pointers))\n+  InstanceKlass* holder = check_field(InstanceKlass::cast(UNPACK_PAIR(Klass, klass)), index, JVMCIENV);\n+  InstanceKlass** filter_klasses = (InstanceKlass**) filter_klass_pointers;\n+  fieldDescriptor fd(holder, index);\n+\n+  typeArrayOop annotations_oop = Annotations::make_java_array(fd.annotations(), CHECK_NULL);\n+  typeArrayHandle annotations = typeArrayHandle(THREAD, annotations_oop);\n+  return get_encoded_annotation_data(holder, annotations, false, filter_length, filter_klasses, THREAD, JVMCIENV);\n+C2V_END\n+\n@@ -2920,0 +3023,3 @@\n+  {CC \"getEncodedClassAnnotationData\",                CC \"(\" HS_KLASS2 OBJECT \"IJ)[B\",                                                      FN_PTR(getEncodedClassAnnotationData)},\n+  {CC \"getEncodedExecutableAnnotationData\",           CC \"(\" HS_METHOD2 OBJECT \"IJ)[B\",                                                     FN_PTR(getEncodedExecutableAnnotationData)},\n+  {CC \"getEncodedFieldAnnotationData\",                CC \"(\" HS_KLASS2 \"I\" OBJECT \"IJ)[B\",                                                  FN_PTR(getEncodedFieldAnnotationData)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":110,"deletions":4,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  nonstatic_field(Annotations,                 _class_annotations,                     AnnotationArray*)                             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,10 @@\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.misc.VM;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.reflect.ConstantPool;\n+import sun.reflect.annotation.AnnotationParser;\n+import sun.reflect.annotation.AnnotationSupport;\n+import sun.reflect.annotation.AnnotationType;\n+\n+import java.io.ByteArrayInputStream;\n@@ -28,0 +38,2 @@\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n@@ -29,0 +41,5 @@\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.IncompleteAnnotationException;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n@@ -31,6 +48,0 @@\n-import java.util.jar.JarFile;\n-import java.util.jar.Manifest;\n-import java.util.jar.Attributes;\n-\n-import jdk.internal.misc.VM;\n-import jdk.internal.misc.Unsafe;\n@@ -69,1 +80,1 @@\n-     * @returns a Properties object containing only the entries in {@code p}\n+     * @return a Properties object containing only the entries in {@code p}\n@@ -150,0 +161,470 @@\n+\n+    \/**\n+     * Parses {@code rawAnnotationBytes} into a list of {@link Annotation}s and then\n+     * serializes them to a byte array with {@link #encodeAnnotations(Collection)}.\n+     *\/\n+    public static byte[] encodeAnnotations(byte[] rawAnnotations,\n+                                           Class<?> declaringClass,\n+                                           ConstantPool cp,\n+                                           boolean forClass,\n+                                           Class<? extends Annotation>[] selectAnnotationClasses)\n+    {\n+        Map<Class<? extends Annotation>, Annotation> annotations =\n+                AnnotationParser.parseSelectAnnotations(rawAnnotations, cp, declaringClass, selectAnnotationClasses);\n+        if (forClass && annotations.size() != selectAnnotationClasses.length) {\n+            Class<?> superClass = declaringClass.getSuperclass();\n+            nextSuperClass:\n+            while (superClass != null) {\n+                JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+                Map<Class<? extends Annotation>, Annotation> superAnnotations =\n+                    AnnotationParser.parseSelectAnnotations(\n+                            jla.getRawClassAnnotations(superClass),\n+                            jla.getConstantPool(superClass),\n+                            superClass,\n+                            selectAnnotationClasses);\n+\n+                for (Map.Entry<Class<? extends Annotation>, Annotation> e : superAnnotations.entrySet()) {\n+                    Class<? extends Annotation> annotationClass = e.getKey();\n+                    if (!annotations.containsKey(annotationClass) && AnnotationType.getInstance(annotationClass).isInherited()) {\n+                        if (annotations.isEmpty()) {\n+                            \/\/ An empty map might be unmodifiable (e.g. Collections.emptyMap()).\n+                            annotations = new LinkedHashMap<Class<? extends Annotation>, Annotation>();\n+                        }\n+                        annotations.put(annotationClass, e.getValue());\n+                        if (annotations.size() == selectAnnotationClasses.length) {\n+                            break nextSuperClass;\n+                        }\n+                    }\n+                }\n+                superClass = superClass.getSuperclass();\n+            }\n+        }\n+        return encodeAnnotations(annotations.values());\n+    }\n+\n+    \/**\n+     * Encodes a list of annotations to a byte array. The byte array can be decoded with {@link #decodeAnnotations(byte[], AnnotationDecoder)}.\n+     *\/\n+    public static byte[] encodeAnnotations(Collection<Annotation> annotations) {\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream(128);\n+            try(DataOutputStream dos = new DataOutputStream(baos)) {\n+                writeLength(dos, annotations.size());\n+                for (Annotation a : annotations) {\n+                    encodeAnnotation(dos, a);\n+                }\n+            }\n+            return baos.toByteArray();\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private static void encodeAnnotation(DataOutputStream dos, Annotation a) throws Exception {\n+        Class<? extends Annotation> type = a.annotationType();\n+        Map<String, Object> values = AnnotationSupport.memberValues(a);\n+        dos.writeUTF(type.getName());\n+        writeLength(dos, values.size());\n+        for (Map.Entry<String, Object> e : values.entrySet()) {\n+            Object value = e.getValue();\n+            if (value == null) {\n+                \/\/ IncompleteAnnotationException\n+                dos.writeByte('x');\n+                dos.writeUTF(new IncompleteAnnotationException(type, e.getKey()).toString());\n+                continue;\n+            }\n+            Class<?> valueType = value.getClass();\n+            dos.writeUTF(e.getKey());\n+            if (valueType == Byte.class) {\n+                dos.writeByte('B');\n+                dos.writeByte((byte) value);\n+            } else if (valueType == Character.class) {\n+                dos.writeByte('C');\n+                dos.writeChar((char) value);\n+            } else if (valueType == Double.class) {\n+                dos.writeByte('D');\n+                dos.writeDouble((double) value);\n+            } else if (valueType == Float.class) {\n+                dos.writeByte('F');\n+                dos.writeFloat((float) value);\n+            } else if (valueType == Integer.class) {\n+                dos.writeByte('I');\n+                dos.writeInt((int) value);\n+            } else if (valueType == Long.class) {\n+                dos.writeByte('J');\n+                dos.writeLong((long) value);\n+            } else if (valueType == Short.class) {\n+                dos.writeByte('S');\n+                dos.writeShort((short) value);\n+            } else if (valueType == Boolean.class) {\n+                dos.writeByte('Z');\n+                dos.writeBoolean((boolean) value);\n+            } else if (valueType == String.class) {\n+                dos.writeByte('s');\n+                dos.writeUTF((String) value);\n+            } else if (valueType == Class.class) {\n+                dos.writeByte('c');\n+                dos.writeUTF(((Class<?>) value).getName());\n+            } else if (valueType.isEnum()) {\n+                dos.writeByte('e');\n+                dos.writeUTF(valueType.getName());\n+                dos.writeUTF(((Enum<?>) value).name());\n+            } else if (value instanceof Annotation) {\n+                dos.writeByte('@');\n+                encodeAnnotation(dos, (Annotation) value);\n+            } else if (valueType.isArray()) {\n+                Class<?> componentType = valueType.getComponentType();\n+                if (componentType == byte.class) {\n+                    byte[] array = (byte[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('B');\n+                    writeLength(dos, array.length);\n+                    dos.write(array);\n+                } else if (componentType == char.class) {\n+                    char[] array = (char[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('C');\n+                    writeLength(dos, array.length);\n+                    for (char c : array) {\n+                        dos.writeChar(c);\n+                    }\n+                } else if (componentType == double.class) {\n+                    double[] array = (double[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('D');\n+                    writeLength(dos, array.length);\n+                    for (double v : array) {\n+                        dos.writeDouble(v);\n+                    }\n+                } else if (componentType == float.class) {\n+                    float[] array = (float[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('F');\n+                    writeLength(dos, array.length);\n+                    for (float v : array) {\n+                        dos.writeFloat(v);\n+                    }\n+                } else if (componentType == int.class) {\n+                    int[] array = (int[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('I');\n+                    writeLength(dos, array.length);\n+                    for (int j : array) {\n+                        dos.writeInt(j);\n+                    }\n+                } else if (componentType == long.class) {\n+                    long[] array = (long[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('J');\n+                    writeLength(dos, array.length);\n+                    for (long l : array) {\n+                        dos.writeLong(l);\n+                    }\n+                } else if (componentType == short.class) {\n+                    short[] array = (short[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('S');\n+                    writeLength(dos, array.length);\n+                    for (short item : array) {\n+                        dos.writeShort(item);\n+                    }\n+                } else if (componentType == boolean.class) {\n+                    boolean[] array = (boolean[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('Z');\n+                    writeLength(dos, array.length);\n+                    for (boolean b : array) {\n+                        dos.writeBoolean(b);\n+                    }\n+                } else if (componentType == String.class) {\n+                    String[] array = (String[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('s');\n+                    writeLength(dos, array.length);\n+                    for (String s : array) {\n+                        dos.writeUTF(s);\n+                    }\n+                } else if (componentType == Class.class) {\n+                    Class<?>[] array = (Class<?>[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('c');\n+                    writeLength(dos, array.length);\n+                    for (Class<?> aClass : array) {\n+                        dos.writeUTF(aClass.getName());\n+                    }\n+                } else if (componentType.isEnum()) {\n+                    Enum<?>[] array = (Enum<?>[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('e');\n+                    dos.writeUTF(componentType.getName());\n+                    writeLength(dos, array.length);\n+                    for (Enum<?> anEnum : array) {\n+                        dos.writeUTF(anEnum.name());\n+                    }\n+                } else if (componentType.isAnnotation()) {\n+                    Annotation[] array = (Annotation[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('@');\n+                    writeLength(dos, array.length);\n+                    for (Annotation annotation : array) {\n+                        encodeAnnotation(dos, annotation);\n+                    }\n+                } else {\n+                    dos.writeByte('x');\n+                    dos.writeUTF(value.toString());\n+                }\n+\n+            } else {\n+                dos.writeByte('x');\n+                dos.writeUTF(value.toString());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Helper for {@link #decodeAnnotations(byte[], AnnotationDecoder)} to convert a byte\n+     * array (ostensibly produced by {@link VMSupport#encodeAnnotations}) into objects.\n+     *\n+     * @param <T> type to which a type name is {@linkplain #resolveType(String) resolved}\n+     * @param <A> type of the object representing a decoded annotation\n+     * @param <E> type of the object representing a decoded enum constant\n+     * @param <X> type of the object representing a decoded error\n+     *\/\n+    public interface AnnotationDecoder<T, A, E, X> {\n+        \/**\n+         * Resolves a name in {@link Class#getName()} format to an object of type {@code T}.\n+         *\/\n+        T resolveType(String name);\n+\n+        \/**\n+         * Creates an object representing a decoded annotation.\n+         *\n+         * @param type the annotation interface of the annotation\n+         * @param names element names\n+         * @param values element values\n+         *\/\n+        A newAnnotation(T type, String[] names, Object[] values);\n+\n+        \/**\n+         * Creates an object representing a decoded enum constant.\n+         *\n+         * @param enumType the enum type\n+         * @param name the name of the enum constant\n+         *\/\n+        E newEnumValue(T enumType, String name);\n+\n+        \/**\n+         * Creates and returns an array of type {@code T}.\n+         *\/\n+        T[] newClassArray(int length);\n+\n+        \/**\n+         * Creates and returns an array of type {@code A}.\n+         *\/\n+        A[] newAnnotationArray(int length);\n+\n+        \/**\n+         * Creates and returns an array of type {@code E}.\n+         *\/\n+        E[] newEnumValues(int length);\n+\n+        \/**\n+         * Creates an object representing a decoded error value.\n+         *\n+         * @param description of the error\n+         *\/\n+        X newErrorValue(String description);\n+    }\n+\n+    \/**\n+     * Decodes annotations serialized in {@code encoded} to objects.\n+     *\n+     * @param <T> type to which a type name is resolved\n+     * @param <A> type of the object representing a decoded annotation\n+     * @param <E> type of the object representing a decoded enum constant\n+     * @param <X> type of the object representing a decoded error\n+     *\/\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public static <T, A, E, X> A[] decodeAnnotations(byte[] encoded, AnnotationDecoder<T, A, E, X> decoder) {\n+        try {\n+            ByteArrayInputStream bais = new ByteArrayInputStream(encoded);\n+            DataInputStream dis = new DataInputStream(bais);\n+            return readAnnotationArray(dis, decoder);\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    private static <T, A, E, X> A decodeAnnotation(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n+        String typeName = dis.readUTF();\n+        T type = decoder.resolveType(typeName);\n+        int n = readLength(dis);\n+        String[] names = new String[n];\n+        Object[] values = new Object[n];\n+        for (int i = 0; i < n; i++) {\n+            String name = dis.readUTF();\n+            names[i] = name;\n+            byte tag = dis.readByte();\n+            values[i] = switch (tag) {\n+                case 'B' -> dis.readByte();\n+                case 'C' -> dis.readChar();\n+                case 'D' -> dis.readDouble();\n+                case 'F' -> dis.readFloat();\n+                case 'I' -> dis.readInt();\n+                case 'J' -> dis.readLong();\n+                case 'S' -> dis.readShort();\n+                case 'Z' -> dis.readBoolean();\n+                case 's' -> dis.readUTF();\n+                case 'c' -> decoder.resolveType(dis.readUTF());\n+                case 'e' -> decoder.newEnumValue(decoder.resolveType(dis.readUTF()), dis.readUTF());\n+                case '@' -> decodeAnnotation(dis, decoder);\n+                case '[' -> decodeArray(dis, decoder);\n+                case 'x' -> decoder.newErrorValue(dis.readUTF());\n+                default -> throw new InternalError(\"Unsupported tag: \" + tag);\n+            };\n+        }\n+        return decoder.newAnnotation(type, names, values);\n+    }\n+\n+    private static <T, A, E, X> Object decodeArray(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n+        byte componentTag = dis.readByte();\n+        return switch (componentTag) {\n+            case 'B' -> readByteArray(dis);\n+            case 'C' -> readCharArray(dis);\n+            case 'D' -> readDoubleArray(dis);\n+            case 'F' -> readFloatArray(dis);\n+            case 'I' -> readIntArray(dis);\n+            case 'J' -> readLongArray(dis);\n+            case 'S' -> readShortArray(dis);\n+            case 'Z' -> readBooleanArray(dis);\n+            case 's' -> readStringArray(dis);\n+            case 'c' -> readClassArray(dis, decoder);\n+            case 'e' -> readEnumArray(dis, decoder);\n+            case '@' -> readAnnotationArray(dis, decoder);\n+            default -> throw new InternalError(\"Unsupported component tag: \" + componentTag);\n+        };\n+    }\n+\n+    private static <T, A, E, X> A[] readAnnotationArray(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n+        int length = readLength(dis);\n+        A[] array = decoder.newAnnotationArray(length);\n+        for (int i = 0; i < length; i++) {\n+            array[i] = decodeAnnotation(dis, decoder);\n+        }\n+        return array;\n+    }\n+\n+    private static <T, A, E, X> E[] readEnumArray(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n+        T enumType = decoder.resolveType(dis.readUTF());\n+        E[] array = decoder.newEnumValues(readLength(dis));\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = decoder.newEnumValue(enumType, dis.readUTF());\n+        }\n+        return array;\n+    }\n+\n+    private static <T, A, E, X> T[] readClassArray(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n+        T[] array = decoder.newClassArray(readLength(dis));\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = decoder.resolveType(dis.readUTF());\n+        }\n+        return array;\n+    }\n+\n+    private static String[] readStringArray(DataInputStream dis) throws IOException {\n+        String[] array = new String[readLength(dis)];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = dis.readUTF();\n+        }\n+        return array;\n+    }\n+\n+    private static boolean[] readBooleanArray(DataInputStream dis) throws IOException {\n+        boolean[] array = new boolean[readLength(dis)];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = dis.readBoolean();\n+        }\n+        return array;\n+    }\n+\n+    private static short[] readShortArray(DataInputStream dis) throws IOException {\n+        short[] array = new short[readLength(dis)];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = dis.readShort();\n+        }\n+        return array;\n+    }\n+\n+    private static long[] readLongArray(DataInputStream dis) throws IOException {\n+        long[] array = new long[readLength(dis)];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = dis.readLong();\n+        }\n+        return array;\n+    }\n+\n+    private static int[] readIntArray(DataInputStream dis) throws IOException {\n+        int[] array = new int[readLength(dis)];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = dis.readInt();\n+        }\n+        return array;\n+    }\n+\n+    private static float[] readFloatArray(DataInputStream dis) throws IOException {\n+        float[] array = new float[readLength(dis)];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = dis.readFloat();\n+        }\n+        return array;\n+    }\n+\n+    private static double[] readDoubleArray(DataInputStream dis) throws IOException {\n+        double[] array = new double[readLength(dis)];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = dis.readDouble();\n+        }\n+        return array;\n+    }\n+\n+    private static char[] readCharArray(DataInputStream dis) throws IOException {\n+        char[] array = new char[readLength(dis)];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = dis.readChar();\n+        }\n+        return array;\n+    }\n+\n+    private static byte[] readByteArray(DataInputStream dis) throws IOException {\n+        byte[] array = new byte[readLength(dis)];\n+        dis.readFully(array);\n+        return array;\n+    }\n+\n+    \/**\n+     * Encodes {@code length} in 1 byte if it is less than 128.\n+     *\/\n+    private static void writeLength(DataOutputStream dos, int length) throws IOException {\n+        if (length < 0) {\n+            throw new NegativeArraySizeException();\n+        } else if (length <= 127) {\n+            dos.writeByte((byte) (0x80 | length));\n+        } else  {\n+            dos.writeInt(length);\n+        }\n+    }\n+\n+    private static int readLength(DataInputStream dis) throws IOException {\n+        int ch1 = dis.readByte();\n+        int length;\n+        if (ch1 < 0) {\n+            length = ch1 & 0x7F;\n+        } else {\n+            int ch2 = dis.read();\n+            int ch3 = dis.read();\n+            int ch4 = dis.read();\n+            length = (ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0);\n+        }\n+        return length;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VMSupport.java","additions":488,"deletions":7,"binary":false,"changes":495,"status":"modified"},{"patch":"@@ -257,1 +257,2 @@\n-        jdk.management.agent;\n+        jdk.management.agent,\n+        jdk.internal.vm.ci;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -680,0 +680,7 @@\n+    \/**\n+     * Gets an unmodifiable view on the member values.\n+     *\/\n+    Map<String, Object> memberValues() {\n+        return Collections.unmodifiableMap(memberValues);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationInvocationHandler.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-     * This method is only used to parse select meta annotations in the construction\n+     * This method is used to parse select meta annotations in the construction\n@@ -93,1 +93,1 @@\n-    static Map<Class<? extends Annotation>, Annotation> parseSelectAnnotations(\n+    public static Map<Class<? extends Annotation>, Annotation> parseSelectAnnotations(\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -284,0 +284,9 @@\n+\n+    \/**\n+     * Gets an unmodifiable view of {@code a}'s elements.\n+     *\n+     * @return a map from element names to element values\n+     *\/\n+    public static Map<String, Object> memberValues(Annotation a) {\n+        return ((AnnotationInvocationHandler) Proxy.getInvocationHandler(a)).memberValues();\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationSupport.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot;\n+\n+import jdk.internal.vm.VMSupport.AnnotationDecoder;\n+import jdk.vm.ci.meta.AnnotationData;\n+import jdk.vm.ci.meta.EnumData;\n+import jdk.vm.ci.meta.JavaType;\n+import jdk.vm.ci.meta.MetaUtil;\n+import jdk.vm.ci.meta.UnresolvedJavaType;\n+\n+\/**\n+ * Implementation of {@link AnnotationDecoder} that resolves type names to {@link JavaType} values\n+ * and employs {@link AnnotationData} and {@link EnumData} to represent decoded annotations and enum\n+ * constants respectively.\n+ *\/\n+class AnnotationDataDecoder implements AnnotationDecoder<JavaType, AnnotationData, EnumData, StringBuilder> {\n+\n+    public static final AnnotationData[] NO_ANNOTATION_DATA = {};\n+\n+    @Override\n+    public JavaType resolveType(String name) {\n+        String internalName = MetaUtil.toInternalName(name);\n+        return UnresolvedJavaType.create(internalName);\n+    }\n+\n+    @Override\n+    public AnnotationData newAnnotation(JavaType type, String[] names, Object[] values) {\n+        return new AnnotationData(type, names, values);\n+    }\n+\n+    @Override\n+    public EnumData newEnumValue(JavaType enumType, String name) {\n+        return new EnumData(enumType, name);\n+    }\n+\n+    @Override\n+    public JavaType[] newClassArray(int length) {\n+        return new JavaType[length];\n+    }\n+\n+    @Override\n+    public AnnotationData[] newAnnotationArray(int length) {\n+        return new AnnotationData[length];\n+    }\n+\n+    @Override\n+    public EnumData[] newEnumValues(int length) {\n+        return new EnumData[length];\n+    }\n+\n+    @Override\n+    public StringBuilder newErrorValue(String description) {\n+        return new StringBuilder(description);\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/AnnotationDataDecoder.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -51,0 +52,6 @@\n+ *\n+ * Note also that some calls pass a raw VM value to avoid a JNI upcall. For example,\n+ * {@link #getBytecode(HotSpotResolvedJavaMethodImpl, long)} needs the raw {@code Method*} value\n+ * (stored in {@link HotSpotResolvedJavaMethodImpl#methodHandle}) in the C++ implementation. The\n+ * {@link HotSpotResolvedJavaMethodImpl} wrapper is still passed as well as it may be the last\n+ * reference keeping the raw value alive.\n@@ -1297,0 +1304,74 @@\n+\n+    \/**\n+     * Gets the serialized annotation info for {@code type} by calling\n+     * {@code VMSupport.encodeAnnotations} in the HotSpot heap.\n+     *\/\n+    byte[] getEncodedClassAnnotationData(HotSpotResolvedObjectTypeImpl type, ResolvedJavaType[] filter) {\n+        try (KlassPointers a = new KlassPointers(filter)) {\n+            return getEncodedClassAnnotationData(type, type.getKlassPointer(),\n+                            a.types, a.types.length, a.buffer());\n+        }\n+    }\n+\n+    native byte[] getEncodedClassAnnotationData(HotSpotResolvedObjectTypeImpl type, long klassPointer,\n+                    Object filter, int filterLength, long filterKlassPointers);\n+\n+    \/**\n+     * Gets the serialized annotation info for {@code method} by calling\n+     * {@code VMSupport.encodeAnnotations} in the HotSpot heap.\n+     *\/\n+    byte[] getEncodedExecutableAnnotationData(HotSpotResolvedJavaMethodImpl method, ResolvedJavaType[] filter) {\n+        try (KlassPointers a = new KlassPointers(filter)) {\n+            return getEncodedExecutableAnnotationData(method, method.getMethodPointer(),\n+                            a.types, a.types.length, a.buffer());\n+        }\n+    }\n+\n+    native byte[] getEncodedExecutableAnnotationData(HotSpotResolvedJavaMethodImpl method, long methodPointer,\n+                    Object filter, int filterLength, long filterKlassPointers);\n+\n+    \/**\n+     * Gets the serialized annotation info for the field denoted by {@code holder} and\n+     * {@code fieldIndex} by calling {@code VMSupport.encodeAnnotations} in the HotSpot heap.\n+     *\/\n+    byte[] getEncodedFieldAnnotationData(HotSpotResolvedObjectTypeImpl holder, int fieldIndex, ResolvedJavaType[] filter) {\n+        try (KlassPointers a = new KlassPointers(filter)) {\n+            return getEncodedFieldAnnotationData(holder, holder.getKlassPointer(), fieldIndex,\n+                            a.types, a.types.length, a.buffer());\n+        }\n+    }\n+\n+    native byte[] getEncodedFieldAnnotationData(HotSpotResolvedObjectTypeImpl holder, long klassPointer, int fieldIndex,\n+                    Object filterTypes, int filterLength, long filterKlassPointers);\n+\n+    \/**\n+     * Helper for passing an array of {@Klass*} values in a native buffer to native code.\n+     *\/\n+    static final class KlassPointers implements AutoCloseable {\n+        final ResolvedJavaType[] types;\n+        final long pointers;\n+        final Unsafe unsafe = UnsafeAccess.UNSAFE;\n+\n+        KlassPointers(ResolvedJavaType[] types) {\n+            int length = types.length;\n+            this.types = types;\n+            pointers = unsafe.allocateMemory(length * Long.BYTES);\n+        }\n+\n+        \/\/ Separate from constructor so that deallocation is ensured\n+        \/\/ in the context of a ClassCastException from the cast below\n+        long buffer() {\n+            long pos = pointers;\n+            for (int i = 0; i < types.length; i++) {\n+                HotSpotResolvedObjectTypeImpl hsType = (HotSpotResolvedObjectTypeImpl) types[i];\n+                unsafe.putLong(pos, hsType.getKlassPointer());\n+                pos += Long.BYTES;\n+            }\n+            return pointers;\n+        }\n+\n+        @Override\n+        public void close() {\n+            unsafe.freeMemory(pointers);\n+        }\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;\n@@ -34,0 +35,2 @@\n+import jdk.internal.vm.VMSupport;\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -224,0 +227,9 @@\n+\n+    @Override\n+    public AnnotationData[] getAnnotationData(ResolvedJavaType... filter) {\n+        if (!hasAnnotations()) {\n+            return AnnotationDataDecoder.NO_ANNOTATION_DATA;\n+        }\n+        byte[] encoded = compilerToVM().getEncodedFieldAnnotationData(holder, index, filter);\n+        return VMSupport.decodeAnnotations(encoded, new AnnotationDataDecoder());\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldImpl.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.internal.vm.VMSupport;\n@@ -42,0 +43,1 @@\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -526,1 +528,1 @@\n-        if ((getConstMethodFlags() & config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {\n+        if (!hasAnnotations()) {\n@@ -534,1 +536,1 @@\n-        if ((getConstMethodFlags() & config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {\n+        if (!hasAnnotations()) {\n@@ -542,1 +544,1 @@\n-        if ((getConstMethodFlags() & config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {\n+        if (!hasAnnotations()) {\n@@ -548,0 +550,7 @@\n+    \/**\n+     * Returns whether this method has annotations.\n+     *\/\n+    private boolean hasAnnotations() {\n+        return (getConstMethodFlags() & config().constMethodHasMethodAnnotations) != 0 && !isClassInitializer();\n+    }\n+\n@@ -755,0 +764,9 @@\n+\n+    @Override\n+    public AnnotationData[] getAnnotationData(ResolvedJavaType... filter) {\n+        if (filter.length == 0 || !hasAnnotations()) {\n+            return AnnotationDataDecoder.NO_ANNOTATION_DATA;\n+        }\n+        byte[] encoded = compilerToVM().getEncodedExecutableAnnotationData(this, filter);\n+        return VMSupport.decodeAnnotations(encoded, new AnnotationDataDecoder());\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.internal.vm.VMSupport;\n@@ -42,0 +43,1 @@\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -874,0 +876,30 @@\n+    \/**\n+     * Determines if this type may have annotations. A positive result\n+     * does not mean this type has annotations but a negative result guarantees\n+     * this type has no annotations.\n+     *\n+     * @param includingInherited if true, expand this query to include superclasses of this type\n+     *\/\n+    private boolean mayHaveAnnotations(boolean includingInherited) {\n+        if (isArray()) {\n+            return false;\n+        }\n+        HotSpotVMConfig config = config();\n+        final long metaspaceAnnotations = UNSAFE.getAddress(getKlassPointer() + config.instanceKlassAnnotationsOffset);\n+        if (metaspaceAnnotations != 0) {\n+            long classAnnotations = UNSAFE.getAddress(metaspaceAnnotations + config.annotationsClassAnnotationsOffset);\n+            if (classAnnotations != 0) {\n+                return true;\n+            }\n+        }\n+        if (includingInherited) {\n+            HotSpotResolvedObjectTypeImpl superClass = getSuperclass();\n+            if (superClass != null) {\n+                return superClass.mayHaveAnnotations(true);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static final Annotation[] NO_ANNOTATIONS = {};\n+\n@@ -876,0 +908,3 @@\n+        if (!mayHaveAnnotations(true)) {\n+            return NO_ANNOTATIONS;\n+        }\n@@ -881,0 +916,3 @@\n+        if (!mayHaveAnnotations(false)) {\n+            return NO_ANNOTATIONS;\n+        }\n@@ -886,0 +924,3 @@\n+        if (!mayHaveAnnotations(true)) {\n+            return null;\n+        }\n@@ -1065,0 +1106,9 @@\n+\n+    @Override\n+    public AnnotationData[] getAnnotationData(ResolvedJavaType... filter) {\n+        if (!mayHaveAnnotations(true)) {\n+            return AnnotationDataDecoder.NO_ANNOTATION_DATA;\n+        }\n+        byte[] encoded = compilerToVM().getEncodedClassAnnotationData(this, filter);\n+        return VMSupport.decodeAnnotations(encoded, new AnnotationDataDecoder());\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -320,0 +321,5 @@\n+\n+    @Override\n+    public AnnotationData[] getAnnotationData(ResolvedJavaType... filter) {\n+        return AnnotationDataDecoder.NO_ANNOTATION_DATA;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedPrimitiveType.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+    final int annotationsClassAnnotationsOffset = getFieldOffset(\"Annotations::_class_annotations\", Integer.class, \"AnnotationArray*\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-     * An object handle in {@code JVMCI::_object_handles}.\n+     * An object handle in {@code JVMCIRuntime::_oop_handles}.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/IndirectHotSpotObjectConstantImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.meta;\n+\n+\/**\n+ * Represents a program element such as a method, constructor, field or class for which annotations\n+ * may be present.\n+ *\/\n+public interface Annotated {\n+\n+    \/**\n+     * Gets the annotations of this element whose types are in {@code filter}.\n+     * The search for annotations of this element includes inherited annotations\n+     * if this element is a class.\n+     * \n+     * All enum types referenced by the returned annotation are initialized.\n+     * Class initialization is not performed for enum types referenced by other\n+     * annotations of this element.\n+     *\n+     * The caller of this method is free to modify the returned array; it will\n+     * have no effect on the arrays returned to other callers.\n+     *\n+     * @param filter an array of types\n+     * @return the annotations of this type whose types are in {@code filter}\n+     * @throws UnsupportedOperationException if this operation is not supported\n+     *\/\n+    default AnnotationData[] getAnnotationData(ResolvedJavaType... filter) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Gets this element's annotation of type {@code type}.\n+     *\n+     * @param type the type object corresponding to the annotation type\n+     * @return this element's annotation for the specified annotation type if present on this\n+     *         element, else null\n+     * @throws UnsupportedOperationException if this operation is not supported\n+     *\/\n+    default AnnotationData getAnnotationDataFor(ResolvedJavaType type) {\n+        AnnotationData[] a = getAnnotationData(type);\n+        return a.length == 1 ? a[0] : null;\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/Annotated.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,507 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.meta;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+\n+\/**\n+ * Represents an annotation where {@link Class} values are represented with {@link JavaType}, enum\n+ * values are represented with {@link EnumData} and error values are represented with\n+ * {@link StringBuilder}.\n+ *\n+ * This is in contrast to the standard annotation API based on {@link Annotation}. Use of\n+ * {@link AnnotationData} allows annotations to be queried without the JVMCI runtime having to\n+ * support dynamic loading of arbitrary {@link Annotation} subclasses. Such support is impossible in\n+ * a closed world, ahead-of-time compiled environment such as libgraal.\n+ *\/\n+public final class AnnotationData {\n+\n+    \/\/ Implementation note: The functionality for equals, hashCode and toString\n+    \/\/ is largely copied from sun.reflect.annotation.AnnotationInvocationHandler\n+    \/\/ so that AnnotationData behaves mostly like java.lang.annotation.Annotation.\n+\n+    private final JavaType type;\n+    private final String[] names;\n+    private final Object[] values;\n+\n+    \/**\n+     * Gets the entry in {@code annotations} whose {@linkplain #getType() type} equals\n+     * {@code annotationType}.\n+     *\n+     * @return {@code null} if there is no match\n+     *\/\n+    public static AnnotationData getAnnotation(AnnotationData[] annotations, JavaType annotationType) {\n+        for (AnnotationData a : annotations) {\n+            if (a.getType().equals(annotationType)) {\n+                return a;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Creates an annotation.\n+     *\n+     * @param type the annotation interface of this annotation, represented as a {@link JavaType}\n+     * @param values the values of this annotation's element values. There is no distinction between\n+     *            values explicitly present in the annotation and those derived from an element's\n+     *            default value.\n+     *\/\n+    public AnnotationData(JavaType type, String[] names, Object[] values) {\n+        assert names.length == values.length;\n+        this.type = type;\n+        this.names = names;\n+        this.values = values;\n+    }\n+\n+    \/**\n+     * @return the annotation interface of this annotation, represented as a {@link JavaType}\n+     *\/\n+    public JavaType getType() {\n+        return type;\n+    }\n+\n+    private Object lookup(String name) {\n+        for (int i = 0; i < names.length; i++) {\n+            if (names[i].equals(name)) {\n+                return values[i];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Determines if this annotation has an element named {@code name}.\n+     *\/\n+    public boolean has(String name) {\n+        return lookup(name) != null;\n+    }\n+\n+    \/**\n+     * Gets the annotation element denoted by {@code name}. If {@code name} denotes an enum\n+     * constant, the name of the enumm constant is returned as a string. To get an {@link EnumData}\n+     * value for an enum constant, call {@link #getEnum(String)} instead.\n+     *\n+     * If the returned value is an array, the caller of this method is free to modify it; it will\n+     * have no effect on arrays returned to other callers.\n+     *\n+     * @param <V> the type of the element\n+     * @return the annotation element denoted by {@code name}\n+     * @throws ClassCastException if the element is not of type {@code V}\n+     * @throws IllegalArgumentException if this annotation {@link #has} no element named\n+     *             {@code name} or if there was an error parsing or creating the element value\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public <V> V get(String name) {\n+        Object val = lookup(name);\n+        if (val == null) {\n+            throw new IllegalArgumentException(\"no element named \" + name);\n+        }\n+        Class<? extends Object> valClass = val.getClass();\n+        if (valClass == StringBuilder.class) {\n+            throw new IllegalArgumentException(val.toString());\n+        }\n+        if (valClass.isArray() && Array.getLength(val) != 0) {\n+            val = cloneArray(val);\n+        }\n+        return (V) val;\n+    }\n+\n+    private static Object cloneArray(Object array) {\n+        Class<?> type = array.getClass();\n+\n+        if (type == byte[].class) {\n+            byte[] byteArray = (byte[]) array;\n+            return byteArray.clone();\n+        }\n+        if (type == char[].class) {\n+            char[] charArray = (char[]) array;\n+            return charArray.clone();\n+        }\n+        if (type == double[].class) {\n+            double[] doubleArray = (double[]) array;\n+            return doubleArray.clone();\n+        }\n+        if (type == float[].class) {\n+            float[] floatArray = (float[]) array;\n+            return floatArray.clone();\n+        }\n+        if (type == int[].class) {\n+            int[] intArray = (int[]) array;\n+            return intArray.clone();\n+        }\n+        if (type == long[].class) {\n+            long[] longArray = (long[]) array;\n+            return longArray.clone();\n+        }\n+        if (type == short[].class) {\n+            short[] shortArray = (short[]) array;\n+            return shortArray.clone();\n+        }\n+        if (type == boolean[].class) {\n+            boolean[] booleanArray = (boolean[]) array;\n+            return booleanArray.clone();\n+        }\n+\n+        Object[] objectArray = (Object[]) array;\n+        return objectArray.clone();\n+    }\n+\n+    \/**\n+     * Gets the boolean element denoted by {@code name}.\n+     *\n+     * @see #get(String)\n+     *\/\n+    public boolean getBoolean(String name) {\n+        return (Boolean) get(name);\n+    }\n+\n+    \/**\n+     * Gets the boolean element denoted by {@code name}.\n+     *\n+     * @see #get(String)\n+     *\/\n+    public byte getByte(String name) {\n+        return (Byte) get(name);\n+    }\n+\n+    \/**\n+     * Gets the char element denoted by {@code name}.\n+     *\n+     * @see #get(String)\n+     *\/\n+    public char getChar(String name) {\n+        return (Character) get(name);\n+    }\n+\n+    \/**\n+     * Gets the short element denoted by {@code name}.\n+     *\n+     * @see #get(String)\n+     *\/\n+    public short getShort(String name) {\n+        return (Short) get(name);\n+    }\n+\n+    \/**\n+     * Gets the int element denoted by {@code name}.\n+     *\n+     * @see #get(String)\n+     *\/\n+    public int getInt(String name) {\n+        return (Integer) get(name);\n+    }\n+\n+    \/**\n+     * Gets the float element denoted by {@code name}.\n+     *\n+     * @see #get(String)\n+     *\/\n+    public float getFloat(String name) {\n+        return (Float) get(name);\n+    }\n+\n+    \/**\n+     * Gets the long element denoted by {@code name}.\n+     *\n+     * @see #get(String)\n+     *\/\n+    public long getLong(String name) {\n+        return (Long) get(name);\n+    }\n+\n+    \/**\n+     * Gets the double element denoted by {@code name}.\n+     *\n+     * @see #get(String)\n+     *\/\n+    public double getDouble(String name) {\n+        return (Double) get(name);\n+    }\n+\n+    \/**\n+     * Gets the String element denoted by {@code name}.\n+     *\n+     * @see #get(String)\n+     *\/\n+    public String getString(String name) {\n+        return (String) get(name);\n+    }\n+\n+    \/**\n+     * Gets the Class element denoted by {@code name}.\n+     *\n+     * @see #get(String)\n+     *\/\n+    public JavaType getClass(String name) {\n+        return (JavaType) get(name);\n+    }\n+\n+    \/**\n+     * Gets an {@link EnumData} value for the enum annotation element denoted by {@code name}.\n+     *\n+     * @see #get(String)\n+     *\/\n+    public EnumData getEnum(String name) {\n+        return (EnumData) get(name);\n+    }\n+\n+    \/**\n+     * Gets an {@link AnnotationData} value for the sub-annotation element denoted by {@code name}.\n+     *\n+     * @see #get(String)\n+     *\/\n+    public AnnotationData getAnnotation(String name) {\n+        return (AnnotationData) get(name);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder result = new StringBuilder(128);\n+        result.append('@');\n+        result.append(type.toClassName().replace('$', '.'));\n+        result.append('(');\n+        boolean firstMember = true;\n+        boolean loneValue = names.length == 1;\n+        for (int i = 0; i < names.length; i++) {\n+            if (firstMember) {\n+                firstMember = false;\n+            } else {\n+                result.append(\", \");\n+            }\n+\n+            String key = names[i];\n+            if (!loneValue || !\"value\".equals(key)) {\n+                result.append(key);\n+                result.append('=');\n+            }\n+            loneValue = false;\n+            Object value = values[i];\n+            if (!value.getClass().isArray()) {\n+                result.append(valueToString(value));\n+            } else {\n+                int len = Array.getLength(value);\n+                result.append('{');\n+                for (int j = 0; j < len; j++) {\n+                    if (j != 0) {\n+                        result.append(\", \");\n+                    }\n+                    result.append(valueToString(Array.get(value, j)));\n+                }\n+                result.append('}');\n+            }\n+\n+        }\n+        result.append(')');\n+        return result.toString();\n+    }\n+\n+    private static String toSourceString(byte b) {\n+        return String.format(\"(byte)0x%02x\", b);\n+    }\n+\n+    private static String toSourceString(long ell) {\n+        return String.valueOf(ell) + \"L\";\n+    }\n+\n+    private static String toSourceString(float f) {\n+        if (Float.isFinite(f)) {\n+            return Float.toString(f) + \"f\";\n+        } else {\n+            if (Float.isInfinite(f)) {\n+                return (f < 0.0f) ? \"-1.0f\/0.0f\" : \"1.0f\/0.0f\";\n+            } else {\n+                return \"0.0f\/0.0f\";\n+            }\n+        }\n+    }\n+\n+    private static String toSourceString(double d) {\n+        if (Double.isFinite(d)) {\n+            return Double.toString(d);\n+        } else {\n+            if (Double.isInfinite(d)) {\n+                return (d < 0.0f) ? \"-1.0\/0.0\" : \"1.0\/0.0\";\n+            } else {\n+                return \"0.0\/0.0\";\n+            }\n+        }\n+    }\n+\n+    private static String toSourceString(char c) {\n+        StringBuilder sb = new StringBuilder(4);\n+        sb.append('\\'');\n+        sb.append(quote(c));\n+        return sb.append('\\'').toString();\n+    }\n+\n+    \/**\n+     * Escapes a character if it has an escape sequence or is non-printable ASCII. Leaves non-ASCII\n+     * characters alone.\n+     *\/\n+    private static String quote(char ch) {\n+        \/\/ @formatter:off\n+        switch (ch) {\n+        case '\\b':  return \"\\\\b\";\n+        case '\\f':  return \"\\\\f\";\n+        case '\\n':  return \"\\\\n\";\n+        case '\\r':  return \"\\\\r\";\n+        case '\\t':  return \"\\\\t\";\n+        case '\\'':  return \"\\\\'\";\n+        case '\\\"':  return \"\\\\\\\"\";\n+        case '\\\\':  return \"\\\\\\\\\";\n+        default:\n+            return (isPrintableAscii(ch))\n+                ? String.valueOf(ch)\n+                : String.format(\"\\\\u%04x\", (int) ch);\n+        }\n+        \/\/ @formatter:on\n+    }\n+\n+    \/**\n+     * Is a character printable ASCII?\n+     *\/\n+    private static boolean isPrintableAscii(char ch) {\n+        return ch >= ' ' && ch <= '~';\n+    }\n+\n+    private static String valueToString(Object value) {\n+        if (value instanceof JavaType) {\n+            return ((JavaType) value).toClassName().replace('$', '.') + \".class\";\n+        } else if (value instanceof Byte) {\n+            return toSourceString((byte) value);\n+        } else if (value instanceof Long) {\n+            return toSourceString((long) value);\n+        } else if (value instanceof Float) {\n+            return toSourceString((float) value);\n+        } else if (value instanceof Double) {\n+            return toSourceString((double) value);\n+        } else if (value instanceof String) {\n+            return \"\\\"\" + value + \"\\\"\";\n+        } else if (value instanceof Character) {\n+            return toSourceString((char) value);\n+        }\n+        return value.toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof AnnotationData) {\n+            AnnotationData that = (AnnotationData) obj;\n+            if (this.type.equals(that.type) &&\n+                            Arrays.equals(this.names, that.names) && this.values.length == that.values.length) {\n+                for (int i = 0; i < values.length; i++) {\n+                    if (!memberValueEquals(this.values[i], that.values[i])) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean memberValueEquals(Object v1, Object v2) {\n+        Class<?> type = v1.getClass();\n+\n+        if (!type.isArray()) {\n+            return v1.equals(v2);\n+        }\n+\n+        if (v1 instanceof Object[] && v2 instanceof Object[]) {\n+            return Arrays.equals((Object[]) v1, (Object[]) v2);\n+        }\n+\n+        \/\/ Deal with array of primitives\n+        if (type == byte[].class) {\n+            return Arrays.equals((byte[]) v1, (byte[]) v2);\n+        }\n+        if (type == char[].class) {\n+            return Arrays.equals((char[]) v1, (char[]) v2);\n+        }\n+        if (type == double[].class) {\n+            return Arrays.equals((double[]) v1, (double[]) v2);\n+        }\n+        if (type == float[].class) {\n+            return Arrays.equals((float[]) v1, (float[]) v2);\n+        }\n+        if (type == int[].class) {\n+            return Arrays.equals((int[]) v1, (int[]) v2);\n+        }\n+        if (type == long[].class) {\n+            return Arrays.equals((long[]) v1, (long[]) v2);\n+        }\n+        if (type == short[].class) {\n+            return Arrays.equals((short[]) v1, (short[]) v2);\n+        }\n+        assert type == boolean[].class;\n+        return Arrays.equals((boolean[]) v1, (boolean[]) v2);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = type.hashCode();\n+        for (int i = 0; i < names.length; i++) {\n+            result += (127 * names[i].hashCode()) ^\n+                            valueHashCode(values[i]);\n+        }\n+        return result;\n+    }\n+\n+    private static int valueHashCode(Object value) {\n+        Class<?> type = value.getClass();\n+        if (!type.isArray()) {\n+            return value.hashCode();\n+        }\n+        if (type == byte[].class) {\n+            return Arrays.hashCode((byte[]) value);\n+        }\n+        if (type == char[].class) {\n+            return Arrays.hashCode((char[]) value);\n+        }\n+        if (type == double[].class) {\n+            return Arrays.hashCode((double[]) value);\n+        }\n+        if (type == float[].class) {\n+            return Arrays.hashCode((float[]) value);\n+        }\n+        if (type == int[].class) {\n+            return Arrays.hashCode((int[]) value);\n+        }\n+        if (type == long[].class) {\n+            return Arrays.hashCode((long[]) value);\n+        }\n+        if (type == short[].class) {\n+            return Arrays.hashCode((short[]) value);\n+        }\n+        if (type == boolean[].class) {\n+            return Arrays.hashCode((boolean[]) value);\n+        }\n+        return Arrays.hashCode((Object[]) value);\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/AnnotationData.java","additions":507,"deletions":0,"binary":false,"changes":507,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.meta;\n+\n+\/**\n+ * Represents an enum constant within {@link AnnotationData}.\n+ *\/\n+public final class EnumData {\n+    private final JavaType type;\n+    private final String name;\n+\n+    \/**\n+     * Creates an enum constant.\n+     *\n+     * @param type the {@linkplain Enum enum type}\n+     * @param name the {@linkplain Enum#name() name} of the enum\n+     *\/\n+    public EnumData(JavaType type, String name) {\n+        this.type = type;\n+        this.name = name;\n+    }\n+\n+    \/**\n+     * Gets the {@linkplain Enum enum type}.\n+     *\/\n+    public JavaType getEnumType() {\n+        return type;\n+    }\n+\n+    \/**\n+     * Gets the {@linkplain Enum#name() name} of the enum.\n+     *\/\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof EnumData) {\n+            EnumData that = (EnumData) obj;\n+            return this.type.equals(that.type) && this.name.equals(that.name);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return this.type.hashCode() ^ this.name.hashCode();\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/EnumData.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-public interface ResolvedJavaField extends JavaField, ModifiersProvider, AnnotatedElement {\n+public interface ResolvedJavaField extends JavaField, ModifiersProvider, AnnotatedElement, Annotated {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaField.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-public interface ResolvedJavaMethod extends JavaMethod, InvokeTarget, ModifiersProvider, AnnotatedElement {\n+public interface ResolvedJavaMethod extends JavaMethod, InvokeTarget, ModifiersProvider, AnnotatedElement, Annotated {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-public interface ResolvedJavaType extends JavaType, ModifiersProvider, AnnotatedElement {\n+public interface ResolvedJavaType extends JavaType, ModifiersProvider, AnnotatedElement, Annotated {\n@@ -140,2 +140,2 @@\n-     * Returns {@code null} since support for VM anonymous class was removed by JDK-8243287.\n-     * This method is preserved for JVMCI backwards compatibility.\n+     * Returns {@code null} since support for VM anonymous class was removed by JDK-8243287. This\n+     * method is preserved for JVMCI backwards compatibility.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/AnnotationTestInput.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberTypeChanged.java\n+ *          TestResolvedJavaType.java\n+ * @clean jdk.internal.vm.test.AnnotationTestInput$Missing\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberTypeChanged.java\n@@ -31,0 +38,1 @@\n+ *          java.base\/jdk.internal.reflect\n@@ -32,0 +40,2 @@\n+ *          java.base\/jdk.internal.vm\n+ *          java.base\/sun.reflect.annotation\n@@ -60,0 +70,1 @@\n+import jdk.internal.vm.test.AnnotationTestInput;\n@@ -184,0 +195,8 @@\n+    @Test\n+    public void getAnnotationDataTest() throws Exception {\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredField(\"annotatedField\"));\n+        for (Field f : fields.keySet()) {\n+            TestResolvedJavaType.getAnnotationDataTest(f);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaField.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/AnnotationTestInput.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberTypeChanged.java\n+ *          TestResolvedJavaType.java\n+ * @clean jdk.internal.vm.test.AnnotationTestInput$Missing\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberTypeChanged.java\n@@ -30,0 +37,2 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.common\n+ *          java.base\/jdk.internal.reflect\n@@ -31,0 +40,2 @@\n+ *          java.base\/jdk.internal.vm\n+ *          java.base\/sun.reflect.annotation\n@@ -36,0 +47,7 @@\n+import static jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.ALL_NUMBERS;\n+import static jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersDE.Eins;\n+import static jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersDE.Zwei;\n+import static jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersEN.One;\n+import static jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersEN.Two;\n+import static jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersUA.Dva;\n+import static jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersUA.Odyn;\n@@ -64,0 +82,1 @@\n+import jdk.internal.vm.test.AnnotationTestInput;\n@@ -69,0 +88,3 @@\n+import jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.Annotation1;\n+import jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.Annotation2;\n+import jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.Annotation3;\n@@ -477,0 +499,90 @@\n+    \/**\n+     * Encapsulates input for {@link TestResolvedJavaMethod#getAnnotationDataTest}.\n+     *\/\n+    static class AnnotationDataTest {\n+\n+        public enum NumbersEN {\n+            One,\n+            Two;\n+\n+            NumbersEN() {\n+                ALL_NUMBERS.add(this);\n+            }\n+        }\n+\n+        public enum NumbersDE {\n+            Eins,\n+            Zwei;\n+\n+            NumbersDE() {\n+                ALL_NUMBERS.add(this);\n+            }\n+        }\n+\n+        public enum NumbersUA {\n+            Odyn,\n+            Dva;\n+\n+            NumbersUA() {\n+                ALL_NUMBERS.add(this);\n+            }\n+        }\n+\n+        static final Set<Object> ALL_NUMBERS = new HashSet<>();\n+\n+        @Retention(RetentionPolicy.RUNTIME)\n+        public @interface Annotation1 {\n+            NumbersEN value() default NumbersEN.One;\n+        }\n+\n+        @Retention(RetentionPolicy.RUNTIME)\n+        public @interface Annotation2 {\n+            NumbersDE value() default NumbersDE.Eins;\n+        }\n+\n+        @Retention(RetentionPolicy.RUNTIME)\n+        public @interface Annotation3 {\n+            NumbersUA value() default NumbersUA.Odyn;\n+        }\n+\n+        @Annotation1\n+        @Annotation2\n+        @Annotation3(NumbersUA.Dva)\n+        static void methodWithThreeAnnotations() {\n+\n+        }\n+    }\n+\n+    @Test\n+    public void getAnnotationDataTest() throws Exception {\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"annotatedMethod\"));\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"missingAnnotation\"));\n+        try {\n+            TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"missingNestedAnnotation\"));\n+            throw new AssertionError(\"expected \" + NoClassDefFoundError.class.getName());\n+        } catch (NoClassDefFoundError e) {\n+            Assert.assertEquals(\"jdk\/internal\/vm\/test\/AnnotationTestInput$Missing\", e.getMessage());\n+        }\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"missingTypeOfClassMember\"));\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"missingMember\"));\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"changeTypeOfMember\"));\n+\n+        for (Method m : methods.keySet()) {\n+            TestResolvedJavaType.getAnnotationDataTest(m);\n+        }\n+\n+        ResolvedJavaMethod m = metaAccess.lookupJavaMethod(AnnotationDataTest.class.getDeclaredMethod(\"methodWithThreeAnnotations\"));\n+        ResolvedJavaType a1 = metaAccess.lookupJavaType(Annotation1.class);\n+        ResolvedJavaType a2 = metaAccess.lookupJavaType(Annotation2.class);\n+        ResolvedJavaType a3 = metaAccess.lookupJavaType(Annotation3.class);\n+        ResolvedJavaType a4 = metaAccess.lookupJavaType(AnnotationDataTest.class);\n+\n+        \/\/ Ensure NumbersDE is not initialized before Annotation2 is requested\n+        Assert.assertEquals(2, m.getAnnotationData(a1, a3).length);\n+        Assert.assertEquals(ALL_NUMBERS, Set.of(One, Two, Odyn, Dva));\n+\n+        \/\/ Ensure NumbersDE is initialized after Annotation2 is requested\n+        Assert.assertEquals(1, m.getAnnotationData(a2).length);\n+        Assert.assertEquals(ALL_NUMBERS, Set.of(One, Two, Odyn, Dva, Eins, Zwei));\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":113,"deletions":1,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,6 @@\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/AnnotationTestInput.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberTypeChanged.java\n+ * @clean jdk.internal.vm.test.AnnotationTestInput$Missing\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberTypeChanged.java\n@@ -34,0 +40,2 @@\n+ *          java.base\/jdk.internal.vm\n+ *          java.base\/sun.reflect.annotation\n@@ -60,0 +68,2 @@\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Array;\n@@ -66,0 +76,1 @@\n+import java.util.function.BiConsumer;\n@@ -69,0 +80,1 @@\n+import java.util.List;\n@@ -71,0 +83,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -75,1 +89,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n@@ -77,0 +90,1 @@\n+import jdk.internal.vm.test.AnnotationTestInput;\n@@ -78,0 +92,3 @@\n+import jdk.vm.ci.meta.Annotated;\n+import jdk.vm.ci.meta.AnnotationData;\n+import jdk.vm.ci.meta.EnumData;\n@@ -81,0 +98,1 @@\n+import jdk.vm.ci.meta.JavaType;\n@@ -84,0 +102,1 @@\n+import sun.reflect.annotation.AnnotationSupport;\n@@ -180,1 +199,2 @@\n-        \/\/ Verify that the last dot in lambda types is properly handled when transitioning from internal name to java\n+        \/\/ Verify that the last dot in lambda types is properly handled when transitioning from\n+        \/\/ internal name to java\n@@ -906,5 +926,5 @@\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(AccessibleObject.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Constructor.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Field.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Method.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Module.class))) {\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(AccessibleObject.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Constructor.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Field.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Method.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Module.class))) {\n@@ -1134,0 +1154,34 @@\n+    @Test\n+    public void getAnnotationDataTest() throws Exception {\n+        getAnnotationDataTest(AnnotationTestInput.AnnotatedClass.class);\n+        getAnnotationDataTest(int.class);\n+        getAnnotationDataTest(void.class);\n+        for (Class<?> c : classes) {\n+            getAnnotationDataTest(c);\n+        }\n+\n+        \/\/ Primitive classes have no annotations but we cannot directly\n+        \/\/ test absence of annotations. Instead, just ensure empty answers\n+        \/\/ are returned when looking up an arbitrary annotation type.\n+        Class<?>[] prims = {void.class, byte.class, int.class, double.class, float.class, short.class, char.class, long.class};\n+        ResolvedJavaType overrideType = metaAccess.lookupJavaType(Override.class);\n+        for (Class<?> c : prims) {\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            AnnotationData ad = type.getAnnotationDataFor(overrideType);\n+            Assert.assertNull(String.valueOf(ad), ad);\n+            AnnotationData[] adArray = type.getAnnotationData(overrideType);\n+            Assert.assertEquals(0, adArray.length);\n+        }\n+\n+        \/\/ Test that inherited annotations are handled properly.\n+        ResolvedJavaType namedType = metaAccess.lookupJavaType(AnnotationTestInput.Named.class);\n+        AnnotationData ad = metaAccess.lookupJavaType(AnnotationTestInput.OwnName.class).getAnnotationDataFor(namedType);\n+        Assert.assertEquals(\"NonInheritedValue\", ad.getString(\"value\"));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName1.class).getAnnotationDataFor(namedType);\n+        Assert.assertEquals(\"Super1\", ad.getString(\"value\"));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName2.class).getAnnotationDataFor(namedType);\n+        Assert.assertEquals(\"Super2\", ad.getString(\"value\"));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName3.class).getAnnotationDataFor(namedType);\n+        Assert.assertEquals(\"Super1\", ad.getString(\"value\"));\n+    }\n+\n@@ -1177,0 +1231,245 @@\n+\n+    \/**\n+     * Tests that {@link AnnotationData} obtained from a {@link Class}, {@link Method} or\n+     * {@link Field} matches {@link AnnotatedElement#getAnnotations()} for the corresponding JVMCI\n+     * object.\n+     *\n+     * @param annotated a {@link Class}, {@link Method} or {@link Field} object\n+     *\/\n+    public static void getAnnotationDataTest(AnnotatedElement annotated) throws Exception {\n+        testGetAnnotationData(annotated, List.of(annotated.getAnnotations()));\n+    }\n+\n+    private static void testGetAnnotationData(AnnotatedElement annotated, List<Annotation> annotations) throws AssertionError {\n+        for (Annotation a : annotations) {\n+            AnnotationData ad = toAnnotated(annotated).getAnnotationDataFor(metaAccess.lookupJavaType(a.annotationType()));\n+            assertAnnotationsEquals(a, ad);\n+        }\n+        for (int i = 0; i < annotations.size(); i++) {\n+\n+            ResolvedJavaType[] filter = annotations.\/\/\n+                            subList(0, i + 1).\/\/\n+                            stream().map(a -> metaAccess.lookupJavaType(a.annotationType())).\/\/\n+                            toArray(ResolvedJavaType[]::new);\n+            AnnotationData[] annotationData = toAnnotated(annotated).getAnnotationData(filter);\n+            assertEquals(filter.length, annotationData.length);\n+\n+            \/\/ Test typed getters in AnnotationData\n+            for (int j = 0; j < filter.length; j++) {\n+                Annotation a = annotations.get(j);\n+                AnnotationData ad = annotationData[j];\n+                if (ad == null) {\n+                    String sep = String.format(\"%n  \");\n+                    String keys = Stream.of(annotationData).map(e -> e.getType().toString()).collect(Collectors.joining(sep));\n+                    String message = String.format(\"%s: missing %s at index %d in:%s%s\", annotated, a.annotationType(), j, sep, keys);\n+                    throw new AssertionError(message);\n+                }\n+                assertAnnotationsEquals(a, ad);\n+            }\n+        }\n+    }\n+\n+    private static Annotated toAnnotated(AnnotatedElement element) {\n+        if (element instanceof Class<?> t) {\n+            return metaAccess.lookupJavaType(t);\n+        } else if (element instanceof Method m) {\n+            return metaAccess.lookupJavaMethod(m);\n+        } else {\n+            Field f = (Field) element;\n+            return metaAccess.lookupJavaField(f);\n+        }\n+    }\n+\n+    private static void assertAnnotationsEquals(Annotation a, AnnotationData ad) {\n+        String aString = a.toString();\n+        String adString = ad.toString();\n+        assertEquals(aString, adString);\n+\n+        Map<String, Object> values = AnnotationSupport.memberValues(a);\n+        for (Map.Entry<String, Object> e : values.entrySet()) {\n+            String name = e.getKey();\n+            if (ad.has(name)) {\n+                Object aValue = e.getValue();\n+                Object adValue;\n+                try {\n+                    adValue = ad.get(name);\n+                } catch (IllegalArgumentException ex) {\n+                    assertEquals(aValue.toString(), ex.getMessage());\n+                    continue;\n+                }\n+                Class<?> valueType = aValue.getClass();\n+                if (valueType == Byte.class) {\n+                    assertEquals(aValue, adValue);\n+                    assertEquals(ad.getByte(name), adValue);\n+                } else if (valueType == Character.class) {\n+                    assertEquals(aValue, adValue);\n+                    assertEquals(ad.getChar(name), adValue);\n+                } else if (valueType == Double.class) {\n+                    assertEquals(aValue, adValue);\n+                    assertEquals(ad.getDouble(name), adValue);\n+                } else if (valueType == Float.class) {\n+                    assertEquals(aValue, adValue);\n+                    assertEquals(ad.getFloat(name), adValue);\n+                } else if (valueType == Integer.class) {\n+                    assertEquals(aValue, adValue);\n+                    assertEquals(ad.getInt(name), adValue);\n+                } else if (valueType == Long.class) {\n+                    assertEquals(aValue, adValue);\n+                    assertEquals(ad.getLong(name), adValue);\n+                } else if (valueType == Short.class) {\n+                    assertEquals(aValue, adValue);\n+                    assertEquals(ad.getShort(name), adValue);\n+                } else if (valueType == Boolean.class) {\n+                    assertEquals(aValue, adValue);\n+                    assertEquals(ad.getBoolean(name), adValue);\n+                } else if (valueType == String.class) {\n+                    assertEquals(aValue, adValue);\n+                    assertEquals(ad.getString(name), adValue);\n+                } else if (valueType == Class.class) {\n+                    assertClassObjectsEquals(aValue, adValue);\n+                    assertEquals(ad.getClass(name), adValue);\n+                } else if (valueType.isEnum()) {\n+                    assertEnumObjectsEquals(aValue, adValue);\n+                    assertEquals(ad.getEnum(name), adValue);\n+                } else if (aValue instanceof Annotation) {\n+                    AnnotationData adAnnotationValue = ad.getAnnotation(name);\n+                    assertEquals(adAnnotationValue, adValue);\n+                    assertAnnotationObjectsEquals(aValue, adValue);\n+                } else if (valueType.isArray()) {\n+                    int length = Array.getLength(aValue);\n+                    assertEquals(length, Array.getLength(adValue));\n+                    Class<?> componentType = valueType.getComponentType();\n+                    if (componentType == byte.class) {\n+                        byte[] adByteArray = (byte[]) adValue;\n+                        assertArrayEquals((byte[]) aValue, adByteArray);\n+                        if (length != 0) {\n+                            \/\/ Test for defensive copying of arrays\n+                            adByteArray[0]++;\n+                            assertArrayEquals((byte[]) aValue, (byte[]) ad.get(name));\n+                        }\n+                    } else if (componentType == char.class) {\n+                        char[] adCharArray = (char[]) adValue;\n+                        assertArrayEquals((char[]) aValue, adCharArray);\n+                        if (length != 0) {\n+                            \/\/ Test for defensive copying of arrays\n+                            adCharArray[0]++;\n+                            assertArrayEquals((char[]) aValue, (char[]) ad.get(name));\n+                        }\n+                    } else if (componentType == double.class) {\n+                        double[] adDoubleArray = (double[]) adValue;\n+                        assertArrayEquals((double[]) aValue, adDoubleArray, 0.0D);\n+                        if (length != 0) {\n+                            \/\/ Test for defensive copying of arrays\n+                            adDoubleArray[0]++;\n+                            assertArrayEquals((double[]) aValue, (double[]) ad.get(name), 0.0D);\n+                        }\n+                    } else if (componentType == float.class) {\n+                        float[] adFloatArray = (float[]) adValue;\n+                        assertArrayEquals((float[]) aValue, adFloatArray, 0.0F);\n+                        if (length != 0) {\n+                            \/\/ Test for defensive copying of arrays\n+                            adFloatArray[0]++;\n+                            assertArrayEquals((float[]) aValue, (float[]) ad.get(name), 0.0F);\n+                        }\n+                    } else if (componentType == int.class) {\n+                        int[] adIntArray = (int[]) adValue;\n+                        assertArrayEquals((int[]) aValue, adIntArray);\n+                        if (length != 0) {\n+                            \/\/ Test for defensive copying of arrays\n+                            adIntArray[0]++;\n+                            assertArrayEquals((int[]) aValue, (int[]) ad.get(name));\n+                        }\n+                    } else if (componentType == long.class) {\n+                        long[] adLongArray = (long[]) adValue;\n+                        assertArrayEquals((long[]) aValue, adLongArray);\n+                        if (length != 0) {\n+                            \/\/ Test for defensive copying of arrays\n+                            adLongArray[0]++;\n+                            assertArrayEquals((long[]) aValue, (long[]) ad.get(name));\n+                        }\n+                    } else if (componentType == short.class) {\n+                        assertArrayEquals((short[]) aValue, (short[]) adValue);\n+                        if (length != 0) {\n+                            \/\/ Test for defensive copying of arrays\n+                            ((short[]) adValue)[0]++;\n+                            assertArrayEquals((short[]) aValue, (short[]) ad.get(name));\n+                        }\n+                    } else if (componentType == boolean.class) {\n+                        boolean[] adBooleanArray = (boolean[]) adValue;\n+                        assertArrayEquals((boolean[]) aValue, adBooleanArray);\n+                        if (length != 0) {\n+                            \/\/ Test for defensive copying of arrays\n+                            adBooleanArray[0] = !adBooleanArray[0];\n+                            assertArrayEquals((boolean[]) aValue, (boolean[]) ad.get(name));\n+                        }\n+                    } else if (componentType == String.class) {\n+                        String[] adStringArray = (String[]) adValue;\n+                        assertArrayEquals((String[]) aValue, adStringArray);\n+                        if (length != 0) {\n+                            \/\/ Test for defensive copying of arrays\n+                            adStringArray[0] = adStringArray[0] + \"extra\";\n+                            assertArrayEquals((String[]) aValue, (String[]) ad.get(name));\n+                        }\n+                    } else if (componentType == Class.class) {\n+                        assertArraysEqual(aValue, adValue, length, TestResolvedJavaType::assertClassObjectsEquals);\n+                        if (length != 0) {\n+                            \/\/ Test for defensive copying of arrays\n+                            JavaType[] adClassArray = (JavaType[]) adValue;\n+                            adClassArray[0] = null;\n+                            assertArraysEqual(aValue, ad.get(name), length, TestResolvedJavaType::assertClassObjectsEquals);\n+                        }\n+                    } else if (componentType.isEnum()) {\n+                        assertArraysEqual(aValue, adValue, length, TestResolvedJavaType::assertEnumObjectsEquals);\n+                        if (length != 0) {\n+                            \/\/ Test for defensive copying of arrays\n+                            EnumData[] adEnumArray = (EnumData[]) adValue;\n+                            adEnumArray[0] = null;\n+                            assertArraysEqual(aValue, ad.get(name), length, TestResolvedJavaType::assertEnumObjectsEquals);\n+                        }\n+                    } else if (componentType.isAnnotation()) {\n+                        assertArraysEqual(aValue, adValue, length, TestResolvedJavaType::assertAnnotationObjectsEquals);\n+                        if (length != 0) {\n+                            \/\/ Test for defensive copying of arrays\n+                            AnnotationData[] adAnnotationArray = (AnnotationData[]) adValue;\n+                            adAnnotationArray[0] = null;\n+                            assertArraysEqual(aValue, ad.get(name), length, TestResolvedJavaType::assertAnnotationObjectsEquals);\n+                        }\n+                    } else {\n+                        throw new AssertionError(\"Unsupported annotation element named \\\"\" + name + \"\\\" with type: \" + valueType.getName());\n+                    }\n+                } else {\n+                    \/\/ Error member values should have same toString representation\n+                    assertEquals(aValue.toString(), adValue.toString());\n+                }\n+            } else {\n+                throw new AssertionError(\"Annotation element named \\\"\" + name + \"\\\" not found in \" + ad);\n+            }\n+        }\n+    }\n+\n+    private static void assertClassObjectsEquals(Object aValue, Object adValue) {\n+        String aName = ((Class<?>) aValue).getName();\n+        String adName = ((JavaType) adValue).toClassName();\n+        assertEquals(aName, adName);\n+    }\n+\n+    private static void assertEnumObjectsEquals(Object aValue, Object adValue) {\n+        EnumData adEnum = (EnumData) adValue;\n+        String adEnumName = adEnum.getName();\n+        String aEnumName = ((Enum<?>) aValue).name();\n+        assertEquals(adEnumName, aEnumName);\n+    }\n+\n+    private static void assertAnnotationObjectsEquals(Object aValue, Object adValue) {\n+        Annotation aAnnotation = (Annotation) aValue;\n+        AnnotationData adAnnotation = (AnnotationData) adValue;\n+        assertAnnotationsEquals(aAnnotation, adAnnotation);\n+    }\n+\n+    private static void assertArraysEqual(Object aValue, Object adValue, int length, BiConsumer<Object, Object> assertEqualty) {\n+        Object[] aArray = (Object[]) aValue;\n+        Object[] adArray = (Object[]) adValue;\n+        for (int i = 0; i < length; i++) {\n+            assertEqualty.accept(aArray[i], adArray[i]);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":307,"deletions":8,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -25,8 +25,2 @@\n-import jdk.internal.misc.Unsafe;\n-import jdk.vm.ci.meta.ConstantReflectionProvider;\n-import jdk.vm.ci.meta.JavaConstant;\n-import jdk.vm.ci.meta.MetaAccessProvider;\n-import jdk.vm.ci.meta.ResolvedJavaField;\n-import jdk.vm.ci.meta.ResolvedJavaType;\n-import jdk.vm.ci.runtime.JVMCI;\n-import org.junit.Test;\n+import static java.lang.reflect.Modifier.isFinal;\n+import static java.lang.reflect.Modifier.isStatic;\n@@ -57,2 +51,9 @@\n-import static java.lang.reflect.Modifier.isFinal;\n-import static java.lang.reflect.Modifier.isStatic;\n+import org.junit.Test;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.vm.ci.meta.ConstantReflectionProvider;\n+import jdk.vm.ci.meta.JavaConstant;\n+import jdk.vm.ci.meta.MetaAccessProvider;\n+import jdk.vm.ci.meta.ResolvedJavaField;\n+import jdk.vm.ci.meta.ResolvedJavaType;\n+import jdk.vm.ci.runtime.JVMCI;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TypeUniverse.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,375 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+public class AnnotationTestInput {\n+\n+    enum Mood {\n+        HAPPY,\n+        SAD,\n+        CONFUSED;\n+    }\n+\n+    private class PrivateClass {}\n+\n+    @Single(string = \"a\",\n+            stringArray = {\"a\", \"b\"},\n+            classValue = String.class,\n+            classArray = {String.class, Exception.class},\n+            byteValue = 1,\n+            byteArray = {1, 2, Byte.MIN_VALUE, Byte.MAX_VALUE},\n+            charValue = 'a',\n+            charArray = {'a', 'b',\n+                         Character.MIN_VALUE, Character.MAX_VALUE,\n+                         '\\b', '\\f', '\\n', '\\r', '\\t', '\\\\', '\\'', '\\\"', '\\u012A'},\n+            doubleValue = 3.3D,\n+            doubleArray = {3.3D, 4.4D,\n+                           Double.MIN_VALUE, Double.MAX_VALUE,\n+                           Double.NaN,\n+                           Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY},\n+            floatValue = 4.4F,\n+            floatArray = {4.4F, 5.5F,\n+                          Float.MIN_VALUE, Float.MAX_VALUE,\n+                          Float.NaN,\n+                          Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            intValue = 5,\n+            intArray = {5, 6, Integer.MIN_VALUE, Integer.MAX_VALUE},\n+            longValue = 6L,\n+            longArray = {6L, 7L, Long.MIN_VALUE, Long.MAX_VALUE},\n+            shortValue = 7,\n+            shortArray = {7, 8, Short.MIN_VALUE, Short.MAX_VALUE},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.SAD,\n+            moodArray = {Mood.CONFUSED, Mood.HAPPY},\n+            nested = @NestedAnno(\"nested1\"),\n+            nestedArray = {@NestedAnno(\"nested2\"), @NestedAnno(\"nested3\")})\n+    @Single(string = \"A\",\n+            stringArray = {\"A\", \"B\"},\n+            classValue = Thread.class,\n+            classArray = {Thread.class, PrivateClass.class},\n+            byteValue = -1,\n+            byteArray = {-1, -2},\n+            charValue = 'A',\n+            charArray = {'a', 'b'},\n+            doubleValue = -3.3D,\n+            doubleArray = {3.3D, 4.4D},\n+            floatValue = -4.4F,\n+            floatArray = {4.4F, 5.5F},\n+            intValue = -5,\n+            intArray = {5, 6},\n+            longValue = -6L,\n+            longArray = {6L, 7L},\n+            shortValue = -7,\n+            shortArray = {7, 8},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.CONFUSED,\n+            moodArray = {Mood.SAD, Mood.CONFUSED},\n+            nested = @NestedAnno(\"nested4\"),\n+            nestedArray = {@NestedAnno(\"nested5\"), @NestedAnno(\"nested6\")})\n+    @SingleWithDefaults\n+    @Deprecated\n+    @SuppressWarnings(\"unchecked\")\n+    public void annotatedMethod() {\n+    }\n+\n+    @Named(\"Super1\")\n+    public static class Super1 {}\n+    @Named(\"Super2\")\n+    public static class Super2 extends Super1 {}\n+    public static class Super3 extends Super1 {}\n+\n+    @Named(\"NonInheritedValue\")\n+    public static class OwnName extends Super1 {}\n+\n+    public static class InheritedName1 extends Super1 {}\n+    public static class InheritedName2 extends Super2 {}\n+    public static class InheritedName3 extends Super3 {}\n+\n+    @Named(\"AnnotatedClass\")\n+    @Single(string = \"a\",\n+            stringArray = {\"a\", \"b\"},\n+            classValue = String.class,\n+            classArray = {String.class, Exception.class},\n+            byteValue = 1,\n+            byteArray = {1, 2, Byte.MIN_VALUE, Byte.MAX_VALUE},\n+            charValue = 'a',\n+            charArray = {'a', 'b',\n+                    Character.MIN_VALUE, Character.MAX_VALUE,\n+                    '\\b', '\\f', '\\n', '\\r', '\\t', '\\\\', '\\'', '\\\"', '\\u012A'},\n+            doubleValue = 3.3D,\n+            doubleArray = {3.3D, 4.4D,\n+                    Double.MIN_VALUE, Double.MAX_VALUE,\n+                    Double.NaN,\n+                    Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY},\n+            floatValue = 4.4F,\n+            floatArray = {4.4F, 5.5F,\n+                    Float.MIN_VALUE, Float.MAX_VALUE,\n+                    Float.NaN,\n+                    Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            intValue = 5,\n+            intArray = {5, 6, Integer.MIN_VALUE, Integer.MAX_VALUE},\n+            longValue = 6L,\n+            longArray = {6L, 7L, Long.MIN_VALUE, Long.MAX_VALUE},\n+            shortValue = 7,\n+            shortArray = {7, 8, Short.MIN_VALUE, Short.MAX_VALUE},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.SAD,\n+            moodArray = {Mood.CONFUSED, Mood.HAPPY},\n+            nested = @NestedAnno(\"nested7\"),\n+            nestedArray = {@NestedAnno(\"nested8\"), @NestedAnno(\"nested9\")})\n+    @Single(string = \"A\",\n+            stringArray = {\"A\", \"B\"},\n+            classValue = Thread.class,\n+            classArray = {Thread.class, PrivateClass.class},\n+            byteValue = -1,\n+            byteArray = {-1, -2},\n+            charValue = 'A',\n+            charArray = {'a', 'b'},\n+            doubleValue = -3.3D,\n+            doubleArray = {3.3D, 4.4D},\n+            floatValue = -4.4F,\n+            floatArray = {4.4F, 5.5F},\n+            intValue = -5,\n+            intArray = {5, 6},\n+            longValue = -6L,\n+            longArray = {6L, 7L},\n+            shortValue = -7,\n+            shortArray = {7, 8},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.CONFUSED,\n+            moodArray = {Mood.SAD, Mood.CONFUSED},\n+            nested = @NestedAnno(\"nested10\"),\n+            nestedArray = {@NestedAnno(\"nested11\"), @NestedAnno(\"nested12\")})\n+    @Deprecated\n+    @SuppressWarnings({\"rawtypes\", \"all\"})\n+    public static class AnnotatedClass {}\n+\n+    @Single(string = \"a\",\n+            stringArray = {\"a\", \"b\"},\n+            classValue = String.class,\n+            classArray = {String.class, Exception.class},\n+            byteValue = 1,\n+            byteArray = {1, 2, Byte.MIN_VALUE, Byte.MAX_VALUE},\n+            charValue = 'a',\n+            charArray = {'a', 'b',\n+                    Character.MIN_VALUE, Character.MAX_VALUE,\n+                    '\\b', '\\f', '\\n', '\\r', '\\t', '\\\\', '\\'', '\\\"', '\\u012A'},\n+            doubleValue = 3.3D,\n+            doubleArray = {3.3D, 4.4D,\n+                    Double.MIN_VALUE, Double.MAX_VALUE,\n+                    Double.NaN,\n+                    Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY},\n+            floatValue = 4.4F,\n+            floatArray = {4.4F, 5.5F,\n+                    Float.MIN_VALUE, Float.MAX_VALUE,\n+                    Float.NaN,\n+                    Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            intValue = 5,\n+            intArray = {5, 6, Integer.MIN_VALUE, Integer.MAX_VALUE},\n+            longValue = 6L,\n+            longArray = {6L, 7L, Long.MIN_VALUE, Long.MAX_VALUE},\n+            shortValue = 7,\n+            shortArray = {7, 8, Short.MIN_VALUE, Short.MAX_VALUE},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.SAD,\n+            moodArray = {Mood.CONFUSED, Mood.HAPPY},\n+            nested = @NestedAnno(\"nested12\"),\n+            nestedArray = {@NestedAnno(\"nested13\"), @NestedAnno(\"nested14\")})\n+    @Single(string = \"A\",\n+            stringArray = {\"A\", \"B\"},\n+            classValue = Thread.class,\n+            classArray = {Thread.class, PrivateClass.class},\n+            byteValue = -1,\n+            byteArray = {-1, -2},\n+            charValue = 'A',\n+            charArray = {'a', 'b'},\n+            doubleValue = -3.3D,\n+            doubleArray = {3.3D, 4.4D},\n+            floatValue = -4.4F,\n+            floatArray = {4.4F, 5.5F},\n+            intValue = -5,\n+            intArray = {5, 6},\n+            longValue = -6L,\n+            longArray = {6L, 7L},\n+            shortValue = -7,\n+            shortArray = {7, 8},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.CONFUSED,\n+            moodArray = {Mood.SAD, Mood.CONFUSED},\n+            nested = @NestedAnno(\"nested15\"),\n+            nestedArray = {@NestedAnno(\"nested16\"), @NestedAnno(\"nested17\")})\n+    private static final int annotatedField = 45;\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface NestedAnno {\n+        String value();\n+    }\n+\n+    @Inherited\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface Named {\n+        String value();\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Repeatable(SingleList.class)\n+    public @interface Single {\n+        Class<?> classValue();\n+        Class<?>[] classArray();\n+\n+        String string();\n+        String[] stringArray();\n+\n+        byte byteValue();\n+        byte[] byteArray();\n+\n+        char charValue();\n+        char[] charArray();\n+\n+        double doubleValue();\n+        double[] doubleArray();\n+\n+        float floatValue();\n+        float[] floatArray();\n+\n+        int intValue();\n+        int[] intArray();\n+\n+        long longValue();\n+        long[] longArray();\n+\n+        short shortValue();\n+        short[] shortArray();\n+\n+        boolean booleanValue();\n+        boolean[] booleanArray();\n+\n+        Mood mood();\n+        Mood[] moodArray();\n+\n+        NestedAnno nested();\n+        NestedAnno[] nestedArray();\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface SingleWithDefaults {\n+        Class<?> classValue() default SingleWithDefaults.class;\n+        Class<?>[] classArray() default {};\n+\n+        String string() default \"anonymous\";\n+        String[] stringArray() default {};\n+\n+        byte byteValue() default 101;\n+        byte[] byteArray() default {};\n+\n+        char charValue() default 'Z';\n+        char[] charArray() default {};\n+\n+        double doubleValue() default 102.102D;\n+        double[] doubleArray() default {};\n+\n+        float floatValue() default 103.103F;\n+        float[] floatArray() default {};\n+\n+        int intValue() default 104;\n+        int[] intArray() default {};\n+\n+        long longValue() default 105L;\n+        long[] longArray() default {};\n+\n+        short shortValue() default 105;\n+        short[] shortArray() default {};\n+\n+        boolean booleanValue() default true;\n+        boolean[] booleanArray() default {};\n+\n+        Mood mood() default Mood.HAPPY;\n+        Mood[] moodArray() default {};\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface SingleList {\n+        Single[] value();\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface Missing {}\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface MissingWrapper {\n+        Missing value();\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface MissingContainer {\n+        Class<?> value();\n+    }\n+\n+    \/**\n+     * Method with a directly missing annotation.\n+     *\/\n+    @Missing\n+    public void missingAnnotation() {}\n+\n+    \/**\n+     * Method with an indirectly missing nested annotation.\n+     *\/\n+    @MissingWrapper(@Missing)\n+    public void missingNestedAnnotation() {}\n+\n+    \/**\n+     * Method with an annotation that has a Class member\n+     * that cannot be resolved.\n+     *\/\n+    @MissingContainer(Missing.class)\n+    public void missingTypeOfClassMember() {}\n+\n+    \/**\n+     * Method with an annotation that has a member\n+     * that is deleted in a newer version of the annotation.\n+     *\/\n+    @MemberDeleted(value = \"evolving\", retained = -34, deleted = 56)\n+    public void missingMember() {}\n+\n+    \/**\n+     * Method with an annotation that has a member named \"any\"\n+     * whose type is chnaged from int to String in a newer version\n+     * of the annotation.\n+     *\/\n+    @MemberTypeChanged(value = \"evolving\", retained = -34, any = 56)\n+    public void changeTypeOfMember() {}\n+\n+}\n+\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/AnnotationTestInput.java","additions":375,"deletions":0,"binary":false,"changes":375,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface MemberDeleted {\n+    String value();\n+    int retained();\n+    int deleted();\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberDeleted.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface MemberTypeChanged {\n+    String value();\n+    int retained();\n+    int any();\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberTypeChanged.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @compile AnnotationTestInput.java MemberDeleted.java MemberTypeChanged.java\n+ * @modules java.base\/jdk.internal.vm\n+ *          java.base\/sun.reflect.annotation\n+ * @clean jdk.internal.vm.test.AnnotationTestInput$Missing\n+ * @compile alt\/MemberDeleted.java alt\/MemberTypeChanged.java\n+ * @run testng\/othervm\n+ *      jdk.internal.vm.test.TestAnnotationEncodingDecoding\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Method;\n+import java.util.LinkedHashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import sun.reflect.annotation.AnnotationParser;\n+\n+import jdk.internal.vm.VMSupport;\n+import jdk.internal.vm.VMSupport.AnnotationDecoder;\n+\n+public class TestAnnotationEncodingDecoding {\n+\n+    @Test\n+    public void encodeDecodeTest() throws Exception {\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredField(\"annotatedField\"));\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"annotatedMethod\"));\n+        checkDecodedEqualsEncoded(AnnotationTestInput.AnnotatedClass.class);\n+\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingAnnotation\"));\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingNestedAnnotation\"), true, true);\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingTypeOfClassMember\"), false, true);\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingMember\"));\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"changeTypeOfMember\"), false, true);\n+    }\n+\n+    private void checkDecodedEqualsEncoded(AnnotatedElement annotated) throws ClassNotFoundException {\n+        checkDecodedEqualsEncoded(annotated, false, false);\n+    }\n+\n+    private void checkDecodedEqualsEncoded(AnnotatedElement annotated, boolean expectNCDFE, boolean onlyStringEquality) throws ClassNotFoundException {\n+        Annotation[] annotations = getAnnotations(annotated, expectNCDFE);\n+        if (annotations == null) {\n+            return;\n+        }\n+\n+        byte[] encoded = VMSupport.encodeAnnotations(List.of(annotations));\n+        MyDecoder decoder = new MyDecoder();\n+        AnnotationConst[] decoded = VMSupport.decodeAnnotations(encoded, decoder);\n+        int i = 0;\n+        for (AnnotationConst ac : decoded) {\n+            Class<? extends Annotation> type = (Class<? extends Annotation>) ac.getType();\n+            Map<String, Object> memberValues = new LinkedHashMap<>(ac.names.length);\n+            decodeAnnotation(ac, memberValues);\n+            Annotation expect = annotations[i];\n+            Annotation actual = AnnotationParser.annotationForMap(type, memberValues);\n+            if (!onlyStringEquality) {\n+                checkEquals(actual, expect);\n+            }\n+            checkEquals(actual.toString(), expect.toString());\n+            i++;\n+        }\n+    }\n+\n+    private static Annotation[] getAnnotations(AnnotatedElement annotated, boolean expectNCDFE) throws AssertionError {\n+        try {\n+            Annotation[] annotations = annotated.getAnnotations();\n+            Assert.assertFalse(expectNCDFE, annotated.toString());\n+            return annotations;\n+        } catch (NoClassDefFoundError e) {\n+            if (!expectNCDFE) {\n+                throw new AssertionError(annotated.toString(), e);\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private static void checkEquals(Object actual, Object expect) {\n+        if (!actual.equals(expect)) {\n+            throw new AssertionError(String.format(\"actual != expect%nactual: %s%n%nexpect: %s\", actual, expect));\n+        }\n+    }\n+\n+    public static final class AnnotationConst {\n+        final Class<?> type;\n+        final String[] names;\n+        final Object[] values;\n+\n+        AnnotationConst(Class<?> type, String[] names, Object[] values) {\n+            this.type = type;\n+            this.names = names;\n+            this.values = values;\n+        }\n+\n+        public Class<?> getType() {\n+            return type;\n+        }\n+    }\n+\n+    public static final class EnumConst {\n+        final Class<?> type;\n+        final String name;\n+\n+        public EnumConst(Class<?> type, String name) {\n+            this.type = type;\n+            this.name = name;\n+        }\n+\n+        public Class<?> getEnumType() {\n+            return type;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+    }\n+\n+    static class MyDecoder implements AnnotationDecoder<Class<?>, AnnotationConst, EnumConst, StringBuilder> {\n+        @Override\n+        public Class<?> resolveType(String name) {\n+            try {\n+                return Class.forName(name);\n+            } catch (ClassNotFoundException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public AnnotationConst newAnnotation(Class<?> type, String[] names, Object[] values) {\n+            return new AnnotationConst(type, names, values);\n+        }\n+\n+        @Override\n+        public EnumConst newEnumValue(Class<?> enumType, String name) {\n+            return new EnumConst(enumType, name);\n+        }\n+\n+        @Override\n+        public Class<?>[] newClassArray(int length) {\n+            return new Class<?>[length];\n+        }\n+\n+        @Override\n+        public AnnotationConst[] newAnnotationArray(int length) {\n+            return new AnnotationConst[length];\n+        }\n+\n+        @Override\n+        public EnumConst[] newEnumValues(int length) {\n+            return new EnumConst[length];\n+        }\n+\n+        @Override\n+        public StringBuilder newErrorValue(String description) {\n+            return new StringBuilder(description);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private void decodeAnnotation(AnnotationConst ac, Map<String, Object> memberValues) throws ClassNotFoundException {\n+        for (int i = 0; i < ac.names.length; i++) {\n+            String name = ac.names[i];\n+            Object value = ac.values[i];\n+            Class<?> valueType = value.getClass();\n+            if (valueType == EnumConst.class) {\n+                EnumConst enumConst = (EnumConst) value;\n+                String enumName = enumConst.getName();\n+                Class<? extends Enum> enumType = (Class<? extends Enum>) enumConst.getEnumType();\n+                memberValues.put(name, asEnum(enumType, enumName));\n+            } else if (valueType == AnnotationConst.class) {\n+                AnnotationConst innerAc = (AnnotationConst) value;\n+                Map<String, Object> innerAcMemberValues = new LinkedHashMap<>(innerAc.names.length);\n+                decodeAnnotation(innerAc, innerAcMemberValues);\n+                Class<? extends Annotation> innerAcType = (Class<? extends Annotation>) innerAc.getType();\n+                Annotation innerA = AnnotationParser.annotationForMap(innerAcType, innerAcMemberValues);\n+                memberValues.put(name, innerA);\n+            } else if (valueType.isArray()) {\n+                Class<?> componentType = valueType.getComponentType();\n+                if (componentType == AnnotationConst.class) {\n+                    AnnotationConst[] array = (AnnotationConst[]) value;\n+                    Annotation[] dst = new Annotation[array.length];\n+                    for (int j = 0; j < array.length; j++) {\n+                        AnnotationConst e = array[j];\n+                        Class<? extends Annotation> type = (Class<? extends Annotation>) e.getType();\n+                        Map<String, Object> eValues = new LinkedHashMap<>(e.names.length);\n+                        decodeAnnotation(e, eValues);\n+                        dst[j] = AnnotationParser.annotationForMap(type, eValues);\n+                    }\n+                    memberValues.put(name, dst);\n+                } else if (componentType == EnumConst.class) {\n+                    EnumConst[] array = (EnumConst[]) value;\n+                    if (array.length == 0) {\n+                        Object[] dst = {};\n+                        memberValues.put(name, dst);\n+                    } else {\n+                        EnumConst ec = array[0];\n+                        Class<? extends Enum> enumType = (Class<? extends Enum>) ec.getEnumType();\n+                        Object[] dst = (Object[]) Array.newInstance(enumType, array.length);\n+                        for (int j = 0; j < array.length; j++) {\n+                            ec = array[j];\n+                            dst[j] = asEnum(enumType, ec.getName());\n+                        }\n+                        memberValues.put(name, dst);\n+                    }\n+                } else {\n+                    memberValues.put(name, value);\n+                }\n+            } else {\n+                memberValues.put(name, value);\n+            }\n+        }\n+    }\n+\n+    private static Object asEnum(Class<? extends Enum> enumType, String enumName) {\n+        return Enum.valueOf(enumType, enumName);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/TestAnnotationEncodingDecoding.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface MemberDeleted {\n+    String value();\n+    int retained();\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberDeleted.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface MemberTypeChanged {\n+    String value();\n+    int retained();\n+    String any();\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberTypeChanged.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -61,9 +61,0 @@\n-    @SuppressWarnings(\"unchecked\")\n-    @Test\n-    public void encodeDecodeTest2() throws Exception {\n-        Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n-        for (int i = 0; i < 10; i++) {\n-            throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n-        }\n-        encodeDecode(throwable);\n-    }\n","filename":"test\/jdk\/jdk\/internal\/vm\/TestTranslatedException.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"}]}