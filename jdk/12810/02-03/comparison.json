{"files":[{"patch":"@@ -2648,2 +2648,2 @@\n-static jbyteArray get_encoded_annotation_data(InstanceKlass* holder, typeArrayHandle annotations, bool for_class,\n-                                              jint filter_length, InstanceKlass** filter,\n+static jbyteArray get_encoded_annotation_data(InstanceKlass* holder, AnnotationArray* annotations_array, bool for_class,\n+                                              jint filter_length, jlong filter_klass_pointers,\n@@ -2664,0 +2664,6 @@\n+  typeArrayOop annotations_oop = Annotations::make_java_array(annotations_array, CHECK_NULL);\n+  typeArrayHandle annotations = typeArrayHandle(THREAD, annotations_oop);\n+\n+  InstanceKlass** filter = filter_length == 1 ?\n+      (InstanceKlass**) &filter_klass_pointers:\n+      (InstanceKlass**) filter_klass_pointers;\n@@ -2717,5 +2723,1 @@\n-  InstanceKlass** filter_klasses = (InstanceKlass**) filter_klass_pointers;\n-\n-  typeArrayOop annotations_oop = Annotations::make_java_array(holder->class_annotations(), CHECK_NULL);\n-  typeArrayHandle annotations = typeArrayHandle(THREAD, annotations_oop);\n-  return get_encoded_annotation_data(holder, annotations, true, filter_length, filter_klasses, THREAD, JVMCIENV);\n+  return get_encoded_annotation_data(holder, holder->class_annotations(), true, filter_length, filter_klass_pointers, THREAD, JVMCIENV);\n@@ -2727,6 +2729,1 @@\n-  InstanceKlass* holder = method->method_holder();\n-  InstanceKlass** filter_klasses = (InstanceKlass**) filter_klass_pointers;\n-\n-  typeArrayOop annotations_oop = Annotations::make_java_array(method->annotations(), CHECK_NULL);\n-  typeArrayHandle annotations = typeArrayHandle(THREAD, annotations_oop);\n-  return get_encoded_annotation_data(holder, annotations, false, filter_length, filter_klasses, THREAD, JVMCIENV);\n+  return get_encoded_annotation_data(method->method_holder(), method->annotations(), false, filter_length, filter_klass_pointers, THREAD, JVMCIENV);\n@@ -2738,1 +2735,0 @@\n-  InstanceKlass** filter_klasses = (InstanceKlass**) filter_klass_pointers;\n@@ -2740,4 +2736,1 @@\n-\n-  typeArrayOop annotations_oop = Annotations::make_java_array(fd.annotations(), CHECK_NULL);\n-  typeArrayHandle annotations = typeArrayHandle(THREAD, annotations_oop);\n-  return get_encoded_annotation_data(holder, annotations, false, filter_length, filter_klasses, THREAD, JVMCIENV);\n+  return get_encoded_annotation_data(holder, fd.annotations(), false, filter_length, filter_klass_pointers, THREAD, JVMCIENV);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.List;\n@@ -172,0 +173,5 @@\n+        for (Class<?> c : selectAnnotationClasses) {\n+            if (!c.isAnnotation()) {\n+                throw new IllegalArgumentException(c + \" is not an annotation interface\");\n+            }\n+        }\n@@ -403,2 +409,1 @@\n-         * @param names element names\n-         * @param values element values\n+         * @param elements elements of the annotation\n@@ -406,1 +411,1 @@\n-        A newAnnotation(T type, String[] names, Object[] values);\n+        A newAnnotation(T type, Map.Entry<String, Object>[] elements);\n@@ -416,15 +421,0 @@\n-        \/**\n-         * Creates and returns an array of type {@code T}.\n-         *\/\n-        T[] newClassArray(int length);\n-\n-        \/**\n-         * Creates and returns an array of type {@code A}.\n-         *\/\n-        A[] newAnnotationArray(int length);\n-\n-        \/**\n-         * Creates and returns an array of type {@code E}.\n-         *\/\n-        E[] newEnumValues(int length);\n-\n@@ -446,0 +436,1 @@\n+     * @return an immutable list of {@code A} objects\n@@ -448,1 +439,1 @@\n-    public static <T, A, E, X> A[] decodeAnnotations(byte[] encoded, AnnotationDecoder<T, A, E, X> decoder) {\n+    public static <T, A, E, X> List<A> decodeAnnotations(byte[] encoded, AnnotationDecoder<T, A, E, X> decoder) {\n@@ -452,1 +443,1 @@\n-            return readAnnotationArray(dis, decoder);\n+            return (List<A>) readArray(dis, () -> decodeAnnotation(dis, decoder));\n@@ -463,2 +454,1 @@\n-        String[] names = new String[n];\n-        Object[] values = new Object[n];\n+        Map.Entry[] elements = new Map.Entry[n];\n@@ -467,1 +457,0 @@\n-            names[i] = name;\n@@ -469,1 +458,1 @@\n-            values[i] = switch (tag) {\n+            elements[i] = Map.entry(name, switch (tag) {\n@@ -485,1 +474,1 @@\n-            };\n+            });\n@@ -487,1 +476,5 @@\n-        return decoder.newAnnotation(type, names, values);\n+        return decoder.newAnnotation(type, (Map.Entry<String, Object>[]) elements);\n+    }\n+    @FunctionalInterface\n+    interface IOReader {\n+        Object read() throws IOException;\n@@ -493,12 +486,15 @@\n-            case 'B' -> readByteArray(dis);\n-            case 'C' -> readCharArray(dis);\n-            case 'D' -> readDoubleArray(dis);\n-            case 'F' -> readFloatArray(dis);\n-            case 'I' -> readIntArray(dis);\n-            case 'J' -> readLongArray(dis);\n-            case 'S' -> readShortArray(dis);\n-            case 'Z' -> readBooleanArray(dis);\n-            case 's' -> readStringArray(dis);\n-            case 'c' -> readClassArray(dis, decoder);\n-            case 'e' -> readEnumArray(dis, decoder);\n-            case '@' -> readAnnotationArray(dis, decoder);\n+            case 'B' -> readArray(dis, dis::readByte);\n+            case 'C' -> readArray(dis, dis::readChar);\n+            case 'D' -> readArray(dis, dis::readDouble);\n+            case 'F' -> readArray(dis, dis::readFloat);\n+            case 'I' -> readArray(dis, dis::readInt);\n+            case 'J' -> readArray(dis, dis::readLong);\n+            case 'S' -> readArray(dis, dis::readShort);\n+            case 'Z' -> readArray(dis, dis::readBoolean);\n+            case 's' -> readArray(dis, dis::readUTF);\n+            case 'c' -> readArray(dis, () -> readClass(dis, decoder));\n+            case 'e' -> {\n+                T enumType = decoder.resolveType(dis.readUTF());\n+                yield readArray(dis, () -> readEnum(dis, decoder, enumType));\n+            }\n+            case '@' -> readArray(dis, () -> decodeAnnotation(dis, decoder));\n@@ -509,72 +505,6 @@\n-    private static <T, A, E, X> A[] readAnnotationArray(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n-        int length = readLength(dis);\n-        A[] array = decoder.newAnnotationArray(length);\n-        for (int i = 0; i < length; i++) {\n-            array[i] = decodeAnnotation(dis, decoder);\n-        }\n-        return array;\n-    }\n-\n-    private static <T, A, E, X> E[] readEnumArray(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n-        T enumType = decoder.resolveType(dis.readUTF());\n-        E[] array = decoder.newEnumValues(readLength(dis));\n-        for (int i = 0; i < array.length; i++) {\n-            array[i] = decoder.newEnumValue(enumType, dis.readUTF());\n-        }\n-        return array;\n-    }\n-\n-    private static <T, A, E, X> T[] readClassArray(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n-        T[] array = decoder.newClassArray(readLength(dis));\n-        for (int i = 0; i < array.length; i++) {\n-            array[i] = decoder.resolveType(dis.readUTF());\n-        }\n-        return array;\n-    }\n-\n-    private static String[] readStringArray(DataInputStream dis) throws IOException {\n-        String[] array = new String[readLength(dis)];\n-        for (int i = 0; i < array.length; i++) {\n-            array[i] = dis.readUTF();\n-        }\n-        return array;\n-    }\n-\n-    private static boolean[] readBooleanArray(DataInputStream dis) throws IOException {\n-        boolean[] array = new boolean[readLength(dis)];\n-        for (int i = 0; i < array.length; i++) {\n-            array[i] = dis.readBoolean();\n-        }\n-        return array;\n-    }\n-\n-    private static short[] readShortArray(DataInputStream dis) throws IOException {\n-        short[] array = new short[readLength(dis)];\n-        for (int i = 0; i < array.length; i++) {\n-            array[i] = dis.readShort();\n-        }\n-        return array;\n-    }\n-\n-    private static long[] readLongArray(DataInputStream dis) throws IOException {\n-        long[] array = new long[readLength(dis)];\n-        for (int i = 0; i < array.length; i++) {\n-            array[i] = dis.readLong();\n-        }\n-        return array;\n-    }\n-\n-    private static int[] readIntArray(DataInputStream dis) throws IOException {\n-        int[] array = new int[readLength(dis)];\n-        for (int i = 0; i < array.length; i++) {\n-            array[i] = dis.readInt();\n-        }\n-        return array;\n-    }\n-\n-    private static float[] readFloatArray(DataInputStream dis) throws IOException {\n-        float[] array = new float[readLength(dis)];\n-        for (int i = 0; i < array.length; i++) {\n-            array[i] = dis.readFloat();\n-        }\n-        return array;\n+    \/**\n+     * Reads an enum encoded at the current read position of {@code dis} and\n+     * returns it as an object of type {@code E}.\n+     *\/\n+    private static <T, A, E, X> E readEnum(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder, T enumType) throws IOException {\n+        return decoder.newEnumValue(enumType, dis.readUTF());\n@@ -583,6 +513,6 @@\n-    private static double[] readDoubleArray(DataInputStream dis) throws IOException {\n-        double[] array = new double[readLength(dis)];\n-        for (int i = 0; i < array.length; i++) {\n-            array[i] = dis.readDouble();\n-        }\n-        return array;\n+    \/**\n+     * Reads a class encoded at the current read position of {@code dis} and\n+     * returns it as an object of type {@code T}.\n+     *\/\n+    private static <T, A, E, X> T readClass(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n+        return decoder.resolveType(dis.readUTF());\n@@ -591,2 +521,9 @@\n-    private static char[] readCharArray(DataInputStream dis) throws IOException {\n-        char[] array = new char[readLength(dis)];\n+    \/**\n+     * Reads an array encoded at the current read position of {@code dis} and\n+     * returns it in an immutable list.\n+     *\n+     * @param reader reads array elements from {@code dis}\n+     * @return an immutable list of {@code A} objects\n+     *\/\n+    private static List<Object> readArray(DataInputStream dis, IOReader reader) throws IOException {\n+        Object[] array = new Object[readLength(dis)];\n@@ -594,1 +531,1 @@\n-            array[i] = dis.readChar();\n+            array[i] = reader.read();\n@@ -596,7 +533,1 @@\n-        return array;\n-    }\n-\n-    private static byte[] readByteArray(DataInputStream dis) throws IOException {\n-        byte[] array = new byte[readLength(dis)];\n-        dis.readFully(array);\n-        return array;\n+        return List.of(array);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VMSupport.java","additions":57,"deletions":126,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.util.Map;\n+\n@@ -28,0 +30,1 @@\n+import jdk.vm.ci.meta.ErrorData;\n@@ -30,0 +33,1 @@\n+import jdk.vm.ci.meta.ResolvedJavaType;\n@@ -37,1 +41,1 @@\n-class AnnotationDataDecoder implements AnnotationDecoder<JavaType, AnnotationData, EnumData, StringBuilder> {\n+final class AnnotationDataDecoder implements AnnotationDecoder<JavaType, AnnotationData, EnumData, ErrorData> {\n@@ -39,1 +43,1 @@\n-    public static final AnnotationData[] NO_ANNOTATION_DATA = {};\n+    static final AnnotationDataDecoder INSTANCE = new AnnotationDataDecoder();\n@@ -48,2 +52,2 @@\n-    public AnnotationData newAnnotation(JavaType type, String[] names, Object[] values) {\n-        return new AnnotationData(type, names, values);\n+    public AnnotationData newAnnotation(JavaType type, Map.Entry<String, Object>[] elements) {\n+        return new AnnotationData(type, elements);\n@@ -58,7 +62,2 @@\n-    public JavaType[] newClassArray(int length) {\n-        return new JavaType[length];\n-    }\n-\n-    @Override\n-    public AnnotationData[] newAnnotationArray(int length) {\n-        return new AnnotationData[length];\n+    public ErrorData newErrorValue(String description) {\n+        return new ErrorData(description);\n@@ -67,8 +66,6 @@\n-    @Override\n-    public EnumData[] newEnumValues(int length) {\n-        return new EnumData[length];\n-    }\n-\n-    @Override\n-    public StringBuilder newErrorValue(String description) {\n-        return new StringBuilder(description);\n+    static ResolvedJavaType[] asArray(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        ResolvedJavaType[] filter = new ResolvedJavaType[2 + types.length];\n+        filter[0] = type1;\n+        filter[1] = type2;\n+        System.arraycopy(types, 0, filter, 2, types.length);\n+        return filter;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/AnnotationDataDecoder.java","additions":16,"deletions":19,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1348,1 +1348,1 @@\n-     * Helper for passing an array of {@Klass*} values in a native buffer to native code.\n+     * Helper for passing {@Klass*} values to native code.\n@@ -1352,1 +1352,1 @@\n-        final long pointers;\n+        long pointersArray;\n@@ -1356,1 +1356,0 @@\n-            int length = types.length;\n@@ -1358,1 +1357,0 @@\n-            pointers = unsafe.allocateMemory(length * Long.BYTES);\n@@ -1361,2 +1359,6 @@\n-        \/\/ Separate from constructor so that deallocation is ensured\n-        \/\/ in the context of a ClassCastException from the cast below\n+        \/**\n+         * Gets the buffer in which to pass the {@Klass*} values to JNI.\n+         *\n+         * @return a {@Klass*} value if {@code types.length == 1} otherwise the address of a native\n+         *         buffer holding an array of {@Klass*} values\n+         *\/\n@@ -1364,5 +1366,11 @@\n-            long pos = pointers;\n-            for (int i = 0; i < types.length; i++) {\n-                HotSpotResolvedObjectTypeImpl hsType = (HotSpotResolvedObjectTypeImpl) types[i];\n-                unsafe.putLong(pos, hsType.getKlassPointer());\n-                pos += Long.BYTES;\n+            int length = types.length;\n+            if (length == 1) {\n+                return ((HotSpotResolvedObjectTypeImpl) types[0]).getKlassPointer();\n+            } else {\n+                pointersArray = unsafe.allocateMemory(length * Long.BYTES);\n+                long pos = pointersArray;\n+                for (int i = 0; i < types.length; i++) {\n+                    HotSpotResolvedObjectTypeImpl hsType = (HotSpotResolvedObjectTypeImpl) types[i];\n+                    unsafe.putLong(pos, hsType.getKlassPointer());\n+                    pos += Long.BYTES;\n+                }\n@@ -1370,1 +1378,1 @@\n-            return pointers;\n+            return pointersArray;\n@@ -1375,1 +1383,4 @@\n-            unsafe.freeMemory(pointers);\n+            if (types.length != 1 && pointersArray != 0) {\n+                unsafe.freeMemory(pointersArray);\n+                pointersArray = 0;\n+            }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-\n-import jdk.internal.vm.annotation.Stable;\n+import java.util.Collections;\n+import java.util.List;\n@@ -229,1 +229,1 @@\n-    public AnnotationData[] getAnnotationData(ResolvedJavaType... filter) {\n+    public AnnotationData getAnnotationData(ResolvedJavaType annotationType) {\n@@ -231,1 +231,1 @@\n-            return AnnotationDataDecoder.NO_ANNOTATION_DATA;\n+            return null;\n@@ -233,0 +233,12 @@\n+        return getAnnotationData0(annotationType).get(0);\n+    }\n+\n+    @Override\n+    public List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        if (!hasAnnotations()) {\n+            return Collections.emptyList();\n+        }\n+        return getAnnotationData0(AnnotationDataDecoder.asArray(type1, type2, types));\n+    }\n+\n+    private List<AnnotationData> getAnnotationData0(ResolvedJavaType... filter) {\n@@ -234,1 +246,1 @@\n-        return VMSupport.decodeAnnotations(encoded, new AnnotationDataDecoder());\n+        return VMSupport.decodeAnnotations(encoded, AnnotationDataDecoder.INSTANCE);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldImpl.java","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import java.util.Collections;\n+import java.util.List;\n@@ -766,3 +768,3 @@\n-    public AnnotationData[] getAnnotationData(ResolvedJavaType... filter) {\n-        if (filter.length == 0 || !hasAnnotations()) {\n-            return AnnotationDataDecoder.NO_ANNOTATION_DATA;\n+    public AnnotationData getAnnotationData(ResolvedJavaType type) {\n+        if (!hasAnnotations()) {\n+            return null;\n@@ -770,0 +772,12 @@\n+        return getAnnotationData0(type).get(0);\n+    }\n+\n+    @Override\n+    public List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        if (!hasAnnotations()) {\n+            return Collections.emptyList();\n+        }\n+        return getAnnotationData0(AnnotationDataDecoder.asArray(type1, type2, types));\n+    }\n+\n+    private List<AnnotationData> getAnnotationData0(ResolvedJavaType... filter) {\n@@ -771,1 +785,1 @@\n-        return VMSupport.decodeAnnotations(encoded, new AnnotationDataDecoder());\n+        return VMSupport.decodeAnnotations(encoded, AnnotationDataDecoder.INSTANCE);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.Collections;\n@@ -40,0 +41,1 @@\n+import java.util.List;\n@@ -877,3 +879,2 @@\n-     * Determines if this type may have annotations. A positive result\n-     * does not mean this type has annotations but a negative result guarantees\n-     * this type has no annotations.\n+     * Determines if this type may have annotations. A positive result does not mean this type has\n+     * annotations but a negative result guarantees this type has no annotations.\n@@ -1108,1 +1109,1 @@\n-    public AnnotationData[] getAnnotationData(ResolvedJavaType... filter) {\n+    public AnnotationData getAnnotationData(ResolvedJavaType annotationType) {\n@@ -1110,1 +1111,9 @@\n-            return AnnotationDataDecoder.NO_ANNOTATION_DATA;\n+            return null;\n+        }\n+        return getAnnotationData0(annotationType).get(0);\n+    }\n+\n+    @Override\n+    public List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        if (!mayHaveAnnotations(true)) {\n+            return Collections.emptyList();\n@@ -1112,0 +1121,4 @@\n+        return getAnnotationData0(AnnotationDataDecoder.asArray(type1, type2, types));\n+    }\n+\n+    private List<AnnotationData> getAnnotationData0(ResolvedJavaType... filter) {\n@@ -1113,1 +1126,1 @@\n-        return VMSupport.decodeAnnotations(encoded, new AnnotationDataDecoder());\n+        return VMSupport.decodeAnnotations(encoded, AnnotationDataDecoder.INSTANCE);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.util.Collections;\n+import java.util.List;\n@@ -323,2 +325,2 @@\n-    public AnnotationData[] getAnnotationData(ResolvedJavaType... filter) {\n-        return AnnotationDataDecoder.NO_ANNOTATION_DATA;\n+    public AnnotationData getAnnotationData(ResolvedJavaType type) {\n+        return null;\n@@ -326,0 +328,6 @@\n+\n+    @Override\n+    public List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        return Collections.emptyList();\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedPrimitiveType.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.lang.annotation.Inherited;\n+import java.util.List;\n+\n@@ -32,6 +35,3 @@\n-     * Gets the annotations of this element whose types are in {@code filter}.\n-     * The search for annotations of this element includes inherited annotations\n-     * if this element is a class.\n-     *\n-     * All enum types referenced by the returned annotation are initialized.\n-     * Class initialization is not performed for enum types referenced by other\n+     * Gets this element's annotations whose types are in the set composed of {@code type1},\n+     * {@code type2} and {@code types}. All enum types referenced by the returned annotation are\n+     * initialized. Class initialization is not triggered for enum types referenced by other\n@@ -40,2 +40,2 @@\n-     * The caller of this method is free to modify the returned array; it will\n-     * have no effect on the arrays returned to other callers.\n+     * If this element is a class, then {@link Inherited} annotations are included in set of\n+     * annotations considered.\n@@ -43,2 +43,7 @@\n-     * @param filter an array of types\n-     * @return the annotations of this type whose types are in {@code filter}\n+     * @param type1 an annotation type\n+     * @param type2 an annotation type\n+     * @param types more annotation types\n+     * @return an immutable list of the annotations present on this element that match one of the\n+     *         given types\n+     * @throws IllegalArgumentException if any type in the set composed of {@code type1},\n+     *             {@code type2} and {@code types} is not an annotation interface type\n@@ -47,1 +52,1 @@\n-    default AnnotationData[] getAnnotationData(ResolvedJavaType... filter) {\n+    default List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n@@ -54,1 +59,1 @@\n-     * @param type the type object corresponding to the annotation type\n+     * @param type the type object corresponding to the annotation interface type\n@@ -57,0 +62,1 @@\n+     * @throws IllegalArgumentException if {@code type} is not an annotation interface type\n@@ -59,3 +65,2 @@\n-    default AnnotationData getAnnotationDataFor(ResolvedJavaType type) {\n-        AnnotationData[] a = getAnnotationData(type);\n-        return a.length == 1 ? a[0] : null;\n+    default AnnotationData getAnnotationData(ResolvedJavaType type) {\n+        throw new UnsupportedOperationException();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/Annotated.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -26,2 +26,4 @@\n-import java.lang.reflect.Array;\n-import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n@@ -30,3 +32,2 @@\n- * Represents an annotation where {@link Class} values are represented with {@link JavaType}, enum\n- * values are represented with {@link EnumData} and error values are represented with\n- * {@link StringBuilder}.\n+ * Represents an annotation where element values are represented with the types described\n+ * {@linkplain #get here}.\n@@ -34,1 +35,1 @@\n- * This is in contrast to the standard annotation API based on {@link Annotation}. Use of\n+ * In contrast to the standard annotation API based on {@link Annotation}, use of\n@@ -36,2 +37,2 @@\n- * support dynamic loading of arbitrary {@link Annotation} subclasses. Such support is impossible in\n- * a closed world, ahead-of-time compiled environment such as libgraal.\n+ * support dynamic loading of arbitrary {@link Annotation} classes. Such support is impossible in a\n+ * closed world, ahead-of-time compiled environment such as libgraal.\n@@ -41,4 +42,0 @@\n-    \/\/ Implementation note: The functionality for equals, hashCode and toString\n-    \/\/ is largely copied from sun.reflect.annotation.AnnotationInvocationHandler\n-    \/\/ so that AnnotationData behaves mostly like java.lang.annotation.Annotation.\n-\n@@ -46,17 +43,14 @@\n-    private final String[] names;\n-    private final Object[] values;\n-\n-    \/**\n-     * Gets the entry in {@code annotations} whose {@linkplain #getType() type} equals\n-     * {@code annotationType}.\n-     *\n-     * @return {@code null} if there is no match\n-     *\/\n-    public static AnnotationData getAnnotation(AnnotationData[] annotations, JavaType annotationType) {\n-        for (AnnotationData a : annotations) {\n-            if (a.getType().equals(annotationType)) {\n-                return a;\n-            }\n-        }\n-        return null;\n-    }\n+    private final Map<String, Object> elements;\n+\n+    private static final Set<Class<?>> ELEMENT_TYPES = Set.of(\n+                    Boolean.class,\n+                    Byte.class,\n+                    Character.class,\n+                    Short.class,\n+                    Integer.class,\n+                    Float.class,\n+                    Long.class,\n+                    Double.class,\n+                    String.class,\n+                    EnumData.class,\n+                    AnnotationData.class);\n@@ -68,22 +62,20 @@\n-     * @param values the values of this annotation's element values. There is no distinction between\n-     *            values explicitly present in the annotation and those derived from an element's\n-     *            default value.\n-     *\/\n-    public AnnotationData(JavaType type, String[] names, Object[] values) {\n-        assert names.length == values.length;\n-        this.type = type;\n-        this.names = names;\n-        this.values = values;\n-    }\n-\n-    \/**\n-     * @return the annotation interface of this annotation, represented as a {@link JavaType}\n-     *\/\n-    public JavaType getType() {\n-        return type;\n-    }\n-\n-    private Object lookup(String name) {\n-        for (int i = 0; i < names.length; i++) {\n-            if (names[i].equals(name)) {\n-                return values[i];\n+     * @param elements the names and values of this annotation's element values. Each value's type\n+     *            must be one of the {@code AnnotationData} types described {@linkplain #get here}\n+     *            or it must be a {@link ErrorData} object whose {@code toString()} value describes\n+     *            the error raised while parsing the element. There is no distinction between a\n+     *            value explicitly present in the annotation and an element's default value.\n+     * @throws IllegalArgumentException if the value of an entry in {@code elements} is not of an\n+     *             accepted type\n+     * @throws NullPointerException if any of the above parameters is null or any entry in\n+     *             {@code elements} is null\n+     *\/\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public AnnotationData(JavaType type, Map.Entry<String, Object>[] elements) {\n+        this.type = Objects.requireNonNull(type);\n+        for (Map.Entry<String, Object> e : elements) {\n+            Object value = e.getValue();\n+            if (!(value instanceof ErrorData) &&\n+                            !(value instanceof JavaType) &&\n+                            !(value instanceof List) &&\n+                            !ELEMENT_TYPES.contains(value.getClass())) {\n+                throw new IllegalArgumentException(\"illegal type for element \" + e.getKey() + \": \" + value.getClass().getName());\n@@ -92,1 +84,1 @@\n-        return null;\n+        this.elements = Map.ofEntries(elements);\n@@ -96,1 +88,1 @@\n-     * Determines if this annotation has an element named {@code name}.\n+     * @return the annotation interface of this annotation, represented as a {@link JavaType}\n@@ -98,2 +90,2 @@\n-    public boolean has(String name) {\n-        return lookup(name) != null;\n+    public JavaType getAnnotationType() {\n+        return type;\n@@ -102,9 +94,28 @@\n-    \/**\n-     * Gets the annotation element denoted by {@code name}. If {@code name} denotes an enum\n-     * constant, the name of the enumm constant is returned as a string. To get an {@link EnumData}\n-     * value for an enum constant, call {@link #getEnum(String)} instead.\n-     *\n-     * If the returned value is an array, the caller of this method is free to modify it; it will\n-     * have no effect on arrays returned to other callers.\n-     *\n-     * @param <V> the type of the element\n+    \/\/ @formatter:off\n+    \/**\n+     * Gets the annotation element denoted by {@code name}. The following table shows the\n+     * correspondence between the type of an element as declared by a method in the annotation\n+     * interface and the type of value returned by this method:\n+     * <table>\n+     * <thead>\n+     * <tr><th>Annotation<\/th> <th>AnnotationData<\/th><\/tr>\n+     * <\/thead><tbody>\n+     * <tr><td>boolean<\/td>    <td>Boolean<\/td><\/tr>\n+     * <tr><td>byte<\/td>       <td>Byte<\/td><\/tr>\n+     * <tr><td>char<\/td>       <td>Character<\/td><\/tr>\n+     * <tr><td>short<\/td>      <td>Short<\/td><\/tr>\n+     * <tr><td>int<\/td>        <td>Integer<\/td><\/tr>\n+     * <tr><td>float<\/td>      <td>Float<\/td><\/tr>\n+     * <tr><td>long<\/td>       <td>Long<\/td><\/tr>\n+     * <tr><td>double<\/td>     <td>Double<\/td><\/tr>\n+     * <tr><td>String<\/td>     <td>String<\/td><\/tr>\n+     * <tr><td>Class<\/td>      <td>JavaType<\/td><\/tr>\n+     * <tr><td>Enum<\/td>       <td>EnumData<\/td><\/tr>\n+     * <tr><td>Annotation<\/td> <td>AnnotationData<\/td><\/tr>\n+     * <tr><td>[]<\/td><td>immutable List&lt;T&gt; where T is one of the above types<\/td><\/tr>\n+     * <\/tbody>\n+     * <\/table>\n+     *\n+     * @param <V> the type of the element as per the {@code AnnotationData} column in the above\n+     *            table or {@link Object}\n+     * @param elementType the class for the type of the element\n@@ -113,2 +124,2 @@\n-     * @throws IllegalArgumentException if this annotation {@link #has} no element named\n-     *             {@code name} or if there was an error parsing or creating the element value\n+     * @throws IllegalArgumentException if this annotation has no element named {@code name} or if\n+     *             there was an error parsing or creating the element value\n@@ -116,0 +127,1 @@\n+    \/\/ @formatter:on\n@@ -117,2 +129,2 @@\n-    public <V> V get(String name) {\n-        Object val = lookup(name);\n+    public <V> V get(String name, Class<V> elementType) {\n+        Object val = elements.get(name);\n@@ -123,1 +135,1 @@\n-        if (valClass == StringBuilder.class) {\n+        if (valClass == ErrorData.class) {\n@@ -126,152 +138,1 @@\n-        if (valClass.isArray() && Array.getLength(val) != 0) {\n-            val = cloneArray(val);\n-        }\n-        return (V) val;\n-    }\n-\n-    private static Object cloneArray(Object array) {\n-        Class<?> type = array.getClass();\n-\n-        if (type == byte[].class) {\n-            byte[] byteArray = (byte[]) array;\n-            return byteArray.clone();\n-        }\n-        if (type == char[].class) {\n-            char[] charArray = (char[]) array;\n-            return charArray.clone();\n-        }\n-        if (type == double[].class) {\n-            double[] doubleArray = (double[]) array;\n-            return doubleArray.clone();\n-        }\n-        if (type == float[].class) {\n-            float[] floatArray = (float[]) array;\n-            return floatArray.clone();\n-        }\n-        if (type == int[].class) {\n-            int[] intArray = (int[]) array;\n-            return intArray.clone();\n-        }\n-        if (type == long[].class) {\n-            long[] longArray = (long[]) array;\n-            return longArray.clone();\n-        }\n-        if (type == short[].class) {\n-            short[] shortArray = (short[]) array;\n-            return shortArray.clone();\n-        }\n-        if (type == boolean[].class) {\n-            boolean[] booleanArray = (boolean[]) array;\n-            return booleanArray.clone();\n-        }\n-\n-        Object[] objectArray = (Object[]) array;\n-        return objectArray.clone();\n-    }\n-\n-    \/**\n-     * Gets the boolean element denoted by {@code name}.\n-     *\n-     * @see #get(String)\n-     *\/\n-    public boolean getBoolean(String name) {\n-        return (Boolean) get(name);\n-    }\n-\n-    \/**\n-     * Gets the boolean element denoted by {@code name}.\n-     *\n-     * @see #get(String)\n-     *\/\n-    public byte getByte(String name) {\n-        return (Byte) get(name);\n-    }\n-\n-    \/**\n-     * Gets the char element denoted by {@code name}.\n-     *\n-     * @see #get(String)\n-     *\/\n-    public char getChar(String name) {\n-        return (Character) get(name);\n-    }\n-\n-    \/**\n-     * Gets the short element denoted by {@code name}.\n-     *\n-     * @see #get(String)\n-     *\/\n-    public short getShort(String name) {\n-        return (Short) get(name);\n-    }\n-\n-    \/**\n-     * Gets the int element denoted by {@code name}.\n-     *\n-     * @see #get(String)\n-     *\/\n-    public int getInt(String name) {\n-        return (Integer) get(name);\n-    }\n-\n-    \/**\n-     * Gets the float element denoted by {@code name}.\n-     *\n-     * @see #get(String)\n-     *\/\n-    public float getFloat(String name) {\n-        return (Float) get(name);\n-    }\n-\n-    \/**\n-     * Gets the long element denoted by {@code name}.\n-     *\n-     * @see #get(String)\n-     *\/\n-    public long getLong(String name) {\n-        return (Long) get(name);\n-    }\n-\n-    \/**\n-     * Gets the double element denoted by {@code name}.\n-     *\n-     * @see #get(String)\n-     *\/\n-    public double getDouble(String name) {\n-        return (Double) get(name);\n-    }\n-\n-    \/**\n-     * Gets the String element denoted by {@code name}.\n-     *\n-     * @see #get(String)\n-     *\/\n-    public String getString(String name) {\n-        return (String) get(name);\n-    }\n-\n-    \/**\n-     * Gets the Class element denoted by {@code name}.\n-     *\n-     * @see #get(String)\n-     *\/\n-    public JavaType getClass(String name) {\n-        return (JavaType) get(name);\n-    }\n-\n-    \/**\n-     * Gets an {@link EnumData} value for the enum annotation element denoted by {@code name}.\n-     *\n-     * @see #get(String)\n-     *\/\n-    public EnumData getEnum(String name) {\n-        return (EnumData) get(name);\n-    }\n-\n-    \/**\n-     * Gets an {@link AnnotationData} value for the sub-annotation element denoted by {@code name}.\n-     *\n-     * @see #get(String)\n-     *\/\n-    public AnnotationData getAnnotation(String name) {\n-        return (AnnotationData) get(name);\n+        return elementType.cast(val);\n@@ -282,125 +143,1 @@\n-        StringBuilder result = new StringBuilder(128);\n-        result.append('@');\n-        result.append(type.toClassName().replace('$', '.'));\n-        result.append('(');\n-        boolean firstMember = true;\n-        boolean loneValue = names.length == 1;\n-        for (int i = 0; i < names.length; i++) {\n-            if (firstMember) {\n-                firstMember = false;\n-            } else {\n-                result.append(\", \");\n-            }\n-\n-            String key = names[i];\n-            if (!loneValue || !\"value\".equals(key)) {\n-                result.append(key);\n-                result.append('=');\n-            }\n-            loneValue = false;\n-            Object value = values[i];\n-            if (!value.getClass().isArray()) {\n-                result.append(valueToString(value));\n-            } else {\n-                int len = Array.getLength(value);\n-                result.append('{');\n-                for (int j = 0; j < len; j++) {\n-                    if (j != 0) {\n-                        result.append(\", \");\n-                    }\n-                    result.append(valueToString(Array.get(value, j)));\n-                }\n-                result.append('}');\n-            }\n-\n-        }\n-        result.append(')');\n-        return result.toString();\n-    }\n-\n-    private static String toSourceString(byte b) {\n-        return String.format(\"(byte)0x%02x\", b);\n-    }\n-\n-    private static String toSourceString(long ell) {\n-        return String.valueOf(ell) + \"L\";\n-    }\n-\n-    private static String toSourceString(float f) {\n-        if (Float.isFinite(f)) {\n-            return Float.toString(f) + \"f\";\n-        } else {\n-            if (Float.isInfinite(f)) {\n-                return (f < 0.0f) ? \"-1.0f\/0.0f\" : \"1.0f\/0.0f\";\n-            } else {\n-                return \"0.0f\/0.0f\";\n-            }\n-        }\n-    }\n-\n-    private static String toSourceString(double d) {\n-        if (Double.isFinite(d)) {\n-            return Double.toString(d);\n-        } else {\n-            if (Double.isInfinite(d)) {\n-                return (d < 0.0f) ? \"-1.0\/0.0\" : \"1.0\/0.0\";\n-            } else {\n-                return \"0.0\/0.0\";\n-            }\n-        }\n-    }\n-\n-    private static String toSourceString(char c) {\n-        StringBuilder sb = new StringBuilder(4);\n-        sb.append('\\'');\n-        sb.append(quote(c));\n-        return sb.append('\\'').toString();\n-    }\n-\n-    \/**\n-     * Escapes a character if it has an escape sequence or is non-printable ASCII. Leaves non-ASCII\n-     * characters alone.\n-     *\/\n-    private static String quote(char ch) {\n-        \/\/ @formatter:off\n-        switch (ch) {\n-        case '\\b':  return \"\\\\b\";\n-        case '\\f':  return \"\\\\f\";\n-        case '\\n':  return \"\\\\n\";\n-        case '\\r':  return \"\\\\r\";\n-        case '\\t':  return \"\\\\t\";\n-        case '\\'':  return \"\\\\'\";\n-        case '\\\"':  return \"\\\\\\\"\";\n-        case '\\\\':  return \"\\\\\\\\\";\n-        default:\n-            return (isPrintableAscii(ch))\n-                ? String.valueOf(ch)\n-                : String.format(\"\\\\u%04x\", (int) ch);\n-        }\n-        \/\/ @formatter:on\n-    }\n-\n-    \/**\n-     * Is a character printable ASCII?\n-     *\/\n-    private static boolean isPrintableAscii(char ch) {\n-        return ch >= ' ' && ch <= '~';\n-    }\n-\n-    private static String valueToString(Object value) {\n-        if (value instanceof JavaType) {\n-            return ((JavaType) value).toClassName().replace('$', '.') + \".class\";\n-        } else if (value instanceof Byte) {\n-            return toSourceString((byte) value);\n-        } else if (value instanceof Long) {\n-            return toSourceString((long) value);\n-        } else if (value instanceof Float) {\n-            return toSourceString((float) value);\n-        } else if (value instanceof Double) {\n-            return toSourceString((double) value);\n-        } else if (value instanceof String) {\n-            return \"\\\"\" + value + \"\\\"\";\n-        } else if (value instanceof Character) {\n-            return toSourceString((char) value);\n-        }\n-        return value.toString();\n+        return \"@\" + type.getName() + \"(\" + elements + \")\";\n@@ -416,23 +153,1 @@\n-            if (this.type.equals(that.type) &&\n-                            Arrays.equals(this.names, that.names) && this.values.length == that.values.length) {\n-                for (int i = 0; i < values.length; i++) {\n-                    if (!memberValueEquals(this.values[i], that.values[i])) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private static boolean memberValueEquals(Object v1, Object v2) {\n-        Class<?> type = v1.getClass();\n-\n-        if (!type.isArray()) {\n-            return v1.equals(v2);\n-        }\n-\n-        if (v1 instanceof Object[] && v2 instanceof Object[]) {\n-            return Arrays.equals((Object[]) v1, (Object[]) v2);\n-        }\n+            return this.type.equals(that.type) && this.elements.equals(that.elements);\n@@ -440,3 +155,0 @@\n-        \/\/ Deal with array of primitives\n-        if (type == byte[].class) {\n-            return Arrays.equals((byte[]) v1, (byte[]) v2);\n@@ -444,20 +156,1 @@\n-        if (type == char[].class) {\n-            return Arrays.equals((char[]) v1, (char[]) v2);\n-        }\n-        if (type == double[].class) {\n-            return Arrays.equals((double[]) v1, (double[]) v2);\n-        }\n-        if (type == float[].class) {\n-            return Arrays.equals((float[]) v1, (float[]) v2);\n-        }\n-        if (type == int[].class) {\n-            return Arrays.equals((int[]) v1, (int[]) v2);\n-        }\n-        if (type == long[].class) {\n-            return Arrays.equals((long[]) v1, (long[]) v2);\n-        }\n-        if (type == short[].class) {\n-            return Arrays.equals((short[]) v1, (short[]) v2);\n-        }\n-        assert type == boolean[].class;\n-        return Arrays.equals((boolean[]) v1, (boolean[]) v2);\n+        return false;\n@@ -468,38 +161,1 @@\n-        int result = type.hashCode();\n-        for (int i = 0; i < names.length; i++) {\n-            result += (127 * names[i].hashCode()) ^\n-                            valueHashCode(values[i]);\n-        }\n-        return result;\n-    }\n-\n-    private static int valueHashCode(Object value) {\n-        Class<?> type = value.getClass();\n-        if (!type.isArray()) {\n-            return value.hashCode();\n-        }\n-        if (type == byte[].class) {\n-            return Arrays.hashCode((byte[]) value);\n-        }\n-        if (type == char[].class) {\n-            return Arrays.hashCode((char[]) value);\n-        }\n-        if (type == double[].class) {\n-            return Arrays.hashCode((double[]) value);\n-        }\n-        if (type == float[].class) {\n-            return Arrays.hashCode((float[]) value);\n-        }\n-        if (type == int[].class) {\n-            return Arrays.hashCode((int[]) value);\n-        }\n-        if (type == long[].class) {\n-            return Arrays.hashCode((long[]) value);\n-        }\n-        if (type == short[].class) {\n-            return Arrays.hashCode((short[]) value);\n-        }\n-        if (type == boolean[].class) {\n-            return Arrays.hashCode((boolean[]) value);\n-        }\n-        return Arrays.hashCode((Object[]) value);\n+        return type.hashCode() ^ elements.hashCode();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/AnnotationData.java","additions":86,"deletions":430,"binary":false,"changes":516,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.meta;\n+\n+\/**\n+ * Represents an error constant within {@link AnnotationData}.\n+ *\n+ * Similar to {@code sun.reflect.annotation.ExceptionProxy}.\n+ *\/\n+public final class ErrorData {\n+    private final String description;\n+\n+    \/**\n+     * Creates an error constant.\n+     *\n+     * @param description description of the error\n+     *\/\n+    public ErrorData(String description) {\n+        this.description = description;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof ErrorData) {\n+            ErrorData that = (ErrorData) obj;\n+            return this.description.equals(that.description);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return description.hashCode();\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ErrorData.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -47,7 +47,0 @@\n-import static jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.ALL_NUMBERS;\n-import static jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersDE.Eins;\n-import static jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersDE.Zwei;\n-import static jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersEN.One;\n-import static jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersEN.Two;\n-import static jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersUA.Dva;\n-import static jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersUA.Odyn;\n@@ -91,0 +84,1 @@\n+import jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersDE;\n@@ -507,4 +501,0 @@\n-\n-            NumbersEN() {\n-                ALL_NUMBERS.add(this);\n-            }\n@@ -516,4 +506,0 @@\n-\n-            NumbersDE() {\n-                ALL_NUMBERS.add(this);\n-            }\n@@ -525,4 +511,0 @@\n-\n-            NumbersUA() {\n-                ALL_NUMBERS.add(this);\n-            }\n@@ -531,2 +513,0 @@\n-        static final Set<Object> ALL_NUMBERS = new HashSet<>();\n-\n@@ -579,0 +559,1 @@\n+        ResolvedJavaType numbersDEType = metaAccess.lookupJavaType(NumbersDE.class);\n@@ -581,2 +562,2 @@\n-        Assert.assertEquals(2, m.getAnnotationData(a1, a3).length);\n-        Assert.assertEquals(ALL_NUMBERS, Set.of(One, Two, Odyn, Dva));\n+        Assert.assertFalse(numbersDEType.isInitialized());\n+        Assert.assertEquals(2, m.getAnnotationData(a1, a3).size());\n@@ -585,2 +566,2 @@\n-        Assert.assertEquals(1, m.getAnnotationData(a2).length);\n-        Assert.assertEquals(ALL_NUMBERS, Set.of(One, Two, Odyn, Dva, Eins, Zwei));\n+        Assert.assertNotNull(m.getAnnotationData(a2));\n+        Assert.assertTrue(numbersDEType.isInitialized());\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":6,"deletions":25,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+import jdk.vm.ci.meta.MetaUtil;\n@@ -102,0 +103,1 @@\n+import jdk.vm.ci.meta.UnresolvedJavaType;\n@@ -1170,1 +1172,1 @@\n-            AnnotationData ad = type.getAnnotationDataFor(overrideType);\n+            AnnotationData ad = type.getAnnotationData(overrideType);\n@@ -1172,2 +1174,2 @@\n-            AnnotationData[] adArray = type.getAnnotationData(overrideType);\n-            Assert.assertEquals(0, adArray.length);\n+            List<AnnotationData> adArray = type.getAnnotationData(overrideType, overrideType);\n+            Assert.assertEquals(0, adArray.size());\n@@ -1178,8 +1180,8 @@\n-        AnnotationData ad = metaAccess.lookupJavaType(AnnotationTestInput.OwnName.class).getAnnotationDataFor(namedType);\n-        Assert.assertEquals(\"NonInheritedValue\", ad.getString(\"value\"));\n-        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName1.class).getAnnotationDataFor(namedType);\n-        Assert.assertEquals(\"Super1\", ad.getString(\"value\"));\n-        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName2.class).getAnnotationDataFor(namedType);\n-        Assert.assertEquals(\"Super2\", ad.getString(\"value\"));\n-        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName3.class).getAnnotationDataFor(namedType);\n-        Assert.assertEquals(\"Super1\", ad.getString(\"value\"));\n+        AnnotationData ad = metaAccess.lookupJavaType(AnnotationTestInput.OwnName.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"NonInheritedValue\", ad.get(\"value\", String.class));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName1.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"Super1\", ad.get(\"value\", String.class));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName2.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"Super2\", ad.get(\"value\", String.class));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName3.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"Super1\", ad.get(\"value\", String.class));\n@@ -1245,1 +1247,1 @@\n-            AnnotationData ad = toAnnotated(annotated).getAnnotationDataFor(metaAccess.lookupJavaType(a.annotationType()));\n+            AnnotationData ad = toAnnotated(annotated).getAnnotationData(metaAccess.lookupJavaType(a.annotationType()));\n@@ -1247,0 +1249,7 @@\n+\n+            \/\/ Check that encoding\/decoding produces a stable result\n+            AnnotationData ad2 = toAnnotated(annotated).getAnnotationData(metaAccess.lookupJavaType(a.annotationType()));\n+            assertEquals(ad, ad2);\n+        }\n+        if (annotations.size() < 2) {\n+            return;\n@@ -1248,1 +1257,3 @@\n-        for (int i = 0; i < annotations.size(); i++) {\n+        ResolvedJavaType type1 = metaAccess.lookupJavaType(annotations.get(0).annotationType());\n+        ResolvedJavaType type2 = metaAccess.lookupJavaType(annotations.get(1).annotationType());\n+        for (int i = 2; i < annotations.size(); i++) {\n@@ -1250,2 +1261,2 @@\n-            ResolvedJavaType[] filter = annotations.\/\/\n-                            subList(0, i + 1).\/\/\n+            ResolvedJavaType[] types = annotations.\/\/\n+                            subList(2, i + 1).\/\/\n@@ -1254,2 +1265,2 @@\n-            AnnotationData[] annotationData = toAnnotated(annotated).getAnnotationData(filter);\n-            assertEquals(filter.length, annotationData.length);\n+            List<AnnotationData> annotationData = toAnnotated(annotated).getAnnotationData(type1, type2, types);\n+            assertEquals(2 + types.length, annotationData.size());\n@@ -1257,2 +1268,1 @@\n-            \/\/ Test typed getters in AnnotationData\n-            for (int j = 0; j < filter.length; j++) {\n+            for (int j = 0; j < annotationData.size(); j++) {\n@@ -1260,7 +1270,1 @@\n-                AnnotationData ad = annotationData[j];\n-                if (ad == null) {\n-                    String sep = String.format(\"%n  \");\n-                    String keys = Stream.of(annotationData).map(e -> e.getType().toString()).collect(Collectors.joining(sep));\n-                    String message = String.format(\"%s: missing %s at index %d in:%s%s\", annotated, a.annotationType(), j, sep, keys);\n-                    throw new AssertionError(message);\n-                }\n+                AnnotationData ad = annotationData.get(j);\n@@ -1283,4 +1287,3 @@\n-    private static void assertAnnotationsEquals(Annotation a, AnnotationData ad) {\n-        String aString = a.toString();\n-        String adString = ad.toString();\n-        assertEquals(aString, adString);\n+    private static UnresolvedJavaType asType(Class<?> valueType) {\n+        return UnresolvedJavaType.create(MetaUtil.toInternalName(valueType.getName()));\n+    }\n@@ -1288,0 +1291,1 @@\n+    private static void assertAnnotationsEquals(Annotation a, AnnotationData ad) {\n@@ -1291,155 +1295,30 @@\n-            if (ad.has(name)) {\n-                Object aValue = e.getValue();\n-                Object adValue;\n-                try {\n-                    adValue = ad.get(name);\n-                } catch (IllegalArgumentException ex) {\n-                    assertEquals(aValue.toString(), ex.getMessage());\n-                    continue;\n-                }\n-                Class<?> valueType = aValue.getClass();\n-                if (valueType == Byte.class) {\n-                    assertEquals(aValue, adValue);\n-                    assertEquals(ad.getByte(name), adValue);\n-                } else if (valueType == Character.class) {\n-                    assertEquals(aValue, adValue);\n-                    assertEquals(ad.getChar(name), adValue);\n-                } else if (valueType == Double.class) {\n-                    assertEquals(aValue, adValue);\n-                    assertEquals(ad.getDouble(name), adValue);\n-                } else if (valueType == Float.class) {\n-                    assertEquals(aValue, adValue);\n-                    assertEquals(ad.getFloat(name), adValue);\n-                } else if (valueType == Integer.class) {\n-                    assertEquals(aValue, adValue);\n-                    assertEquals(ad.getInt(name), adValue);\n-                } else if (valueType == Long.class) {\n-                    assertEquals(aValue, adValue);\n-                    assertEquals(ad.getLong(name), adValue);\n-                } else if (valueType == Short.class) {\n-                    assertEquals(aValue, adValue);\n-                    assertEquals(ad.getShort(name), adValue);\n-                } else if (valueType == Boolean.class) {\n-                    assertEquals(aValue, adValue);\n-                    assertEquals(ad.getBoolean(name), adValue);\n-                } else if (valueType == String.class) {\n-                    assertEquals(aValue, adValue);\n-                    assertEquals(ad.getString(name), adValue);\n-                } else if (valueType == Class.class) {\n-                    assertClassObjectsEquals(aValue, adValue);\n-                    assertEquals(ad.getClass(name), adValue);\n-                } else if (valueType.isEnum()) {\n-                    assertEnumObjectsEquals(aValue, adValue);\n-                    assertEquals(ad.getEnum(name), adValue);\n-                } else if (aValue instanceof Annotation) {\n-                    AnnotationData adAnnotationValue = ad.getAnnotation(name);\n-                    assertEquals(adAnnotationValue, adValue);\n-                    assertAnnotationObjectsEquals(aValue, adValue);\n-                } else if (valueType.isArray()) {\n-                    int length = Array.getLength(aValue);\n-                    assertEquals(length, Array.getLength(adValue));\n-                    Class<?> componentType = valueType.getComponentType();\n-                    if (componentType == byte.class) {\n-                        byte[] adByteArray = (byte[]) adValue;\n-                        assertArrayEquals((byte[]) aValue, adByteArray);\n-                        if (length != 0) {\n-                            \/\/ Test for defensive copying of arrays\n-                            adByteArray[0]++;\n-                            assertArrayEquals((byte[]) aValue, (byte[]) ad.get(name));\n-                        }\n-                    } else if (componentType == char.class) {\n-                        char[] adCharArray = (char[]) adValue;\n-                        assertArrayEquals((char[]) aValue, adCharArray);\n-                        if (length != 0) {\n-                            \/\/ Test for defensive copying of arrays\n-                            adCharArray[0]++;\n-                            assertArrayEquals((char[]) aValue, (char[]) ad.get(name));\n-                        }\n-                    } else if (componentType == double.class) {\n-                        double[] adDoubleArray = (double[]) adValue;\n-                        assertArrayEquals((double[]) aValue, adDoubleArray, 0.0D);\n-                        if (length != 0) {\n-                            \/\/ Test for defensive copying of arrays\n-                            adDoubleArray[0]++;\n-                            assertArrayEquals((double[]) aValue, (double[]) ad.get(name), 0.0D);\n-                        }\n-                    } else if (componentType == float.class) {\n-                        float[] adFloatArray = (float[]) adValue;\n-                        assertArrayEquals((float[]) aValue, adFloatArray, 0.0F);\n-                        if (length != 0) {\n-                            \/\/ Test for defensive copying of arrays\n-                            adFloatArray[0]++;\n-                            assertArrayEquals((float[]) aValue, (float[]) ad.get(name), 0.0F);\n-                        }\n-                    } else if (componentType == int.class) {\n-                        int[] adIntArray = (int[]) adValue;\n-                        assertArrayEquals((int[]) aValue, adIntArray);\n-                        if (length != 0) {\n-                            \/\/ Test for defensive copying of arrays\n-                            adIntArray[0]++;\n-                            assertArrayEquals((int[]) aValue, (int[]) ad.get(name));\n-                        }\n-                    } else if (componentType == long.class) {\n-                        long[] adLongArray = (long[]) adValue;\n-                        assertArrayEquals((long[]) aValue, adLongArray);\n-                        if (length != 0) {\n-                            \/\/ Test for defensive copying of arrays\n-                            adLongArray[0]++;\n-                            assertArrayEquals((long[]) aValue, (long[]) ad.get(name));\n-                        }\n-                    } else if (componentType == short.class) {\n-                        assertArrayEquals((short[]) aValue, (short[]) adValue);\n-                        if (length != 0) {\n-                            \/\/ Test for defensive copying of arrays\n-                            ((short[]) adValue)[0]++;\n-                            assertArrayEquals((short[]) aValue, (short[]) ad.get(name));\n-                        }\n-                    } else if (componentType == boolean.class) {\n-                        boolean[] adBooleanArray = (boolean[]) adValue;\n-                        assertArrayEquals((boolean[]) aValue, adBooleanArray);\n-                        if (length != 0) {\n-                            \/\/ Test for defensive copying of arrays\n-                            adBooleanArray[0] = !adBooleanArray[0];\n-                            assertArrayEquals((boolean[]) aValue, (boolean[]) ad.get(name));\n-                        }\n-                    } else if (componentType == String.class) {\n-                        String[] adStringArray = (String[]) adValue;\n-                        assertArrayEquals((String[]) aValue, adStringArray);\n-                        if (length != 0) {\n-                            \/\/ Test for defensive copying of arrays\n-                            adStringArray[0] = adStringArray[0] + \"extra\";\n-                            assertArrayEquals((String[]) aValue, (String[]) ad.get(name));\n-                        }\n-                    } else if (componentType == Class.class) {\n-                        assertArraysEqual(aValue, adValue, length, TestResolvedJavaType::assertClassObjectsEquals);\n-                        if (length != 0) {\n-                            \/\/ Test for defensive copying of arrays\n-                            JavaType[] adClassArray = (JavaType[]) adValue;\n-                            adClassArray[0] = null;\n-                            assertArraysEqual(aValue, ad.get(name), length, TestResolvedJavaType::assertClassObjectsEquals);\n-                        }\n-                    } else if (componentType.isEnum()) {\n-                        assertArraysEqual(aValue, adValue, length, TestResolvedJavaType::assertEnumObjectsEquals);\n-                        if (length != 0) {\n-                            \/\/ Test for defensive copying of arrays\n-                            EnumData[] adEnumArray = (EnumData[]) adValue;\n-                            adEnumArray[0] = null;\n-                            assertArraysEqual(aValue, ad.get(name), length, TestResolvedJavaType::assertEnumObjectsEquals);\n-                        }\n-                    } else if (componentType.isAnnotation()) {\n-                        assertArraysEqual(aValue, adValue, length, TestResolvedJavaType::assertAnnotationObjectsEquals);\n-                        if (length != 0) {\n-                            \/\/ Test for defensive copying of arrays\n-                            AnnotationData[] adAnnotationArray = (AnnotationData[]) adValue;\n-                            adAnnotationArray[0] = null;\n-                            assertArraysEqual(aValue, ad.get(name), length, TestResolvedJavaType::assertAnnotationObjectsEquals);\n-                        }\n-                    } else {\n-                        throw new AssertionError(\"Unsupported annotation element named \\\"\" + name + \"\\\" with type: \" + valueType.getName());\n-                    }\n-                } else {\n-                    \/\/ Error member values should have same toString representation\n-                    assertEquals(aValue.toString(), adValue.toString());\n-                }\n-            } else {\n-                throw new AssertionError(\"Annotation element named \\\"\" + name + \"\\\" not found in \" + ad);\n+            Object aValue = e.getValue();\n+            Object adValue;\n+            try {\n+                adValue = ad.get(name, Object.class);\n+            } catch (IllegalArgumentException ex) {\n+                assertEquals(aValue.toString(), ex.getMessage());\n+                continue;\n+            }\n+            try {\n+                assertAnnotationElementsEqual(aValue, adValue);\n+            } catch (ClassCastException ex) {\n+                throw new AssertionError(a.getClass().getName() + \".\" + name + \" has wrong type: \" + adValue.getClass().getName(), ex);\n+            }\n+        }\n+    }\n+\n+    private static void assertAnnotationElementsEqual(Object aValue, Object adValue) {\n+        Class<?> valueType = aValue.getClass();\n+        if (valueType.isEnum()) {\n+            assertEnumObjectsEquals(aValue, adValue);\n+        } else if (aValue instanceof Class) {\n+            assertClassObjectsEquals(aValue, adValue);\n+        } else if (aValue instanceof Annotation) {\n+            assertAnnotationObjectsEquals(aValue, adValue);\n+        } else if (valueType.isArray()) {\n+            List<?> adList = (List<?>) adValue;\n+            int length = Array.getLength(aValue);\n+            assertEquals(length, adList.size());\n+            for (int i = 0; i < length; i++) {\n+                assertAnnotationElementsEqual(Array.get(aValue, i), adList.get(i));\n@@ -1447,0 +1326,3 @@\n+        } else {\n+            assertEquals(aValue.getClass(), adValue.getClass());\n+            assertEquals(aValue, adValue);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":67,"deletions":185,"binary":false,"changes":252,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n-     * whose type is chnaged from int to String in a newer version\n+     * whose type is changed from int to String in a newer version\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/AnnotationTestInput.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.HashMap;\n@@ -44,0 +45,1 @@\n+import java.util.Objects;\n@@ -49,0 +51,1 @@\n+import sun.reflect.annotation.AnnotationSupport;\n@@ -50,0 +53,1 @@\n+import sun.reflect.annotation.ExceptionProxy;\n@@ -63,2 +67,2 @@\n-        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingNestedAnnotation\"), true, true);\n-        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingTypeOfClassMember\"), false, true);\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingNestedAnnotation\"), true);\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingTypeOfClassMember\"), false);\n@@ -66,1 +70,1 @@\n-        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"changeTypeOfMember\"), false, true);\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"changeTypeOfMember\"), false);\n@@ -69,2 +73,2 @@\n-    private void checkDecodedEqualsEncoded(AnnotatedElement annotated) throws ClassNotFoundException {\n-        checkDecodedEqualsEncoded(annotated, false, false);\n+    private void checkDecodedEqualsEncoded(AnnotatedElement annotated) {\n+        checkDecodedEqualsEncoded(annotated, false);\n@@ -73,1 +77,1 @@\n-    private void checkDecodedEqualsEncoded(AnnotatedElement annotated, boolean expectNCDFE, boolean onlyStringEquality) throws ClassNotFoundException {\n+    private void checkDecodedEqualsEncoded(AnnotatedElement annotated, boolean expectNCDFE) {\n@@ -81,1 +85,1 @@\n-        AnnotationConst[] decoded = VMSupport.decodeAnnotations(encoded, decoder);\n+        List<AnnotationConst> decoded = VMSupport.decodeAnnotations(encoded, decoder);\n@@ -83,9 +87,3 @@\n-        for (AnnotationConst ac : decoded) {\n-            Class<? extends Annotation> type = (Class<? extends Annotation>) ac.getType();\n-            Map<String, Object> memberValues = new LinkedHashMap<>(ac.names.length);\n-            decodeAnnotation(ac, memberValues);\n-            Annotation expect = annotations[i];\n-            Annotation actual = AnnotationParser.annotationForMap(type, memberValues);\n-            if (!onlyStringEquality) {\n-                checkEquals(actual, expect);\n-            }\n+        for (AnnotationConst actual : decoded) {\n+            AnnotationConst expect = new AnnotationConst(annotations[i]);\n+            checkEquals(actual, expect);\n@@ -118,2 +116,1 @@\n-        final String[] names;\n-        final Object[] values;\n+        final Map<String, Object> elements;\n@@ -121,1 +118,1 @@\n-        AnnotationConst(Class<?> type, String[] names, Object[] values) {\n+        AnnotationConst(Class<?> type, Map.Entry<String, Object>[] elements) {\n@@ -123,2 +120,47 @@\n-            this.names = names;\n-            this.values = values;\n+            this.elements = Map.ofEntries(elements);\n+        }\n+\n+        AnnotationConst(Annotation a) {\n+            Map<String, Object> values = AnnotationSupport.memberValues(a);\n+            this.type = a.annotationType();\n+            Map.Entry[] elements = new Map.Entry[values.size()];\n+            int i = 0;\n+            for (Map.Entry<String, Object> e : values.entrySet()) {\n+                elements[i++] = Map.entry(e.getKey(), decodeValue(e.getValue()));\n+            }\n+            this.elements = Map.ofEntries(elements);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof AnnotationConst) {\n+                AnnotationConst that = (AnnotationConst) obj;\n+                return this.type.equals(that.type) &&\n+                        this.elements.equals(that.elements);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"@\" + type.getName() + \"(\" + elements + \")\";\n+        }\n+\n+        private Object decodeValue(Object value) {\n+            Class<?> valueType = value.getClass();\n+            if (value instanceof Enum) {\n+                return new EnumConst(valueType, ((Enum<?>) value).name());\n+            } else if (value instanceof Annotation) {\n+                return new AnnotationConst((Annotation) value);\n+            } else if (valueType.isArray()) {\n+                int len = Array.getLength(value);\n+                Object[] arr = new Object[len];\n+                for (int i = 0; i < len; i++) {\n+                    arr[i] = decodeValue(Array.get(value, i));\n+                }\n+                return List.of(arr);\n+            } else if (value instanceof ExceptionProxy) {\n+                return new ErrorConst(value.toString());\n+            } else {\n+                return value;\n+            }\n@@ -132,0 +174,25 @@\n+    public static final class ErrorConst {\n+        final String desc;\n+        public ErrorConst(String desc) {\n+            this.desc = Objects.requireNonNull(desc);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return desc;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return desc.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof ErrorConst) {\n+                return ((ErrorConst) obj).desc.equals(desc);\n+            }\n+            return false;\n+        }\n+    }\n+\n@@ -141,0 +208,15 @@\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof EnumConst) {\n+                EnumConst that = (EnumConst) obj;\n+                return this.type.equals(that.type) &&\n+                        this.name.equals(that.name);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return type.getName() + \".\" + name;\n+        }\n+\n@@ -150,1 +232,1 @@\n-    static class MyDecoder implements AnnotationDecoder<Class<?>, AnnotationConst, EnumConst, StringBuilder> {\n+    static class MyDecoder implements AnnotationDecoder<Class<?>, AnnotationConst, EnumConst, ErrorConst> {\n@@ -161,2 +243,2 @@\n-        public AnnotationConst newAnnotation(Class<?> type, String[] names, Object[] values) {\n-            return new AnnotationConst(type, names, values);\n+        public AnnotationConst newAnnotation(Class<?> type, Map.Entry<String, Object>[] elements) {\n+            return new AnnotationConst(type, elements);\n@@ -171,72 +253,2 @@\n-        public Class<?>[] newClassArray(int length) {\n-            return new Class<?>[length];\n-        }\n-\n-        @Override\n-        public AnnotationConst[] newAnnotationArray(int length) {\n-            return new AnnotationConst[length];\n-        }\n-\n-        @Override\n-        public EnumConst[] newEnumValues(int length) {\n-            return new EnumConst[length];\n-        }\n-\n-        @Override\n-        public StringBuilder newErrorValue(String description) {\n-            return new StringBuilder(description);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private void decodeAnnotation(AnnotationConst ac, Map<String, Object> memberValues) throws ClassNotFoundException {\n-        for (int i = 0; i < ac.names.length; i++) {\n-            String name = ac.names[i];\n-            Object value = ac.values[i];\n-            Class<?> valueType = value.getClass();\n-            if (valueType == EnumConst.class) {\n-                EnumConst enumConst = (EnumConst) value;\n-                String enumName = enumConst.getName();\n-                Class<? extends Enum> enumType = (Class<? extends Enum>) enumConst.getEnumType();\n-                memberValues.put(name, asEnum(enumType, enumName));\n-            } else if (valueType == AnnotationConst.class) {\n-                AnnotationConst innerAc = (AnnotationConst) value;\n-                Map<String, Object> innerAcMemberValues = new LinkedHashMap<>(innerAc.names.length);\n-                decodeAnnotation(innerAc, innerAcMemberValues);\n-                Class<? extends Annotation> innerAcType = (Class<? extends Annotation>) innerAc.getType();\n-                Annotation innerA = AnnotationParser.annotationForMap(innerAcType, innerAcMemberValues);\n-                memberValues.put(name, innerA);\n-            } else if (valueType.isArray()) {\n-                Class<?> componentType = valueType.getComponentType();\n-                if (componentType == AnnotationConst.class) {\n-                    AnnotationConst[] array = (AnnotationConst[]) value;\n-                    Annotation[] dst = new Annotation[array.length];\n-                    for (int j = 0; j < array.length; j++) {\n-                        AnnotationConst e = array[j];\n-                        Class<? extends Annotation> type = (Class<? extends Annotation>) e.getType();\n-                        Map<String, Object> eValues = new LinkedHashMap<>(e.names.length);\n-                        decodeAnnotation(e, eValues);\n-                        dst[j] = AnnotationParser.annotationForMap(type, eValues);\n-                    }\n-                    memberValues.put(name, dst);\n-                } else if (componentType == EnumConst.class) {\n-                    EnumConst[] array = (EnumConst[]) value;\n-                    if (array.length == 0) {\n-                        Object[] dst = {};\n-                        memberValues.put(name, dst);\n-                    } else {\n-                        EnumConst ec = array[0];\n-                        Class<? extends Enum> enumType = (Class<? extends Enum>) ec.getEnumType();\n-                        Object[] dst = (Object[]) Array.newInstance(enumType, array.length);\n-                        for (int j = 0; j < array.length; j++) {\n-                            ec = array[j];\n-                            dst[j] = asEnum(enumType, ec.getName());\n-                        }\n-                        memberValues.put(name, dst);\n-                    }\n-                } else {\n-                    memberValues.put(name, value);\n-                }\n-            } else {\n-                memberValues.put(name, value);\n-            }\n+        public ErrorConst newErrorValue(String description) {\n+            return new ErrorConst(description);\n@@ -245,4 +257,0 @@\n-\n-    private static Object asEnum(Class<? extends Enum> enumType, String enumName) {\n-        return Enum.valueOf(enumType, enumName);\n-    }\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/TestAnnotationEncodingDecoding.java","additions":108,"deletions":100,"binary":false,"changes":208,"status":"modified"}]}