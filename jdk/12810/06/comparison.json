{"files":[{"patch":"@@ -755,0 +755,2 @@\n+  template(encodeAnnotations_name,                     \"encodeAnnotations\")                                       \\\n+  template(encodeAnnotations_signature,                \"([BLjava\/lang\/Class;Ljdk\/internal\/reflect\/ConstantPool;Z[Ljava\/lang\/Class;)[B\")\\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2625,3 +2625,1 @@\n-C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), jint index))\n-  requireInHotSpot(\"asReflectionField\", JVMCI_CHECK_NULL);\n-  Klass* klass = UNPACK_PAIR(Klass, klass);\n+static InstanceKlass* check_field(Klass* klass, jint index, JVMCI_TRAPS) {\n@@ -2634,1 +2632,1 @@\n-  if (index < 0 ||index > fields->length()) {\n+  if (index < 0 || index > fields->length()) {\n@@ -2638,0 +2636,7 @@\n+  return iklass;\n+}\n+\n+C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), jint index))\n+  requireInHotSpot(\"asReflectionField\", JVMCI_CHECK_NULL);\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  InstanceKlass* iklass = check_field(klass, index, JVMCIENV);\n@@ -2643,0 +2648,82 @@\n+static jbyteArray get_encoded_annotation_data(InstanceKlass* holder, AnnotationArray* annotations_array, bool for_class,\n+                                              jint filter_length, jlong filter_klass_pointers,\n+                                              JavaThread* THREAD, JVMCIEnv* JVMCIENV) {\n+  \/\/ Get a ConstantPool object for annotation parsing\n+  Handle jcp = reflect_ConstantPool::create(CHECK_NULL);\n+  reflect_ConstantPool::set_cp(jcp(), holder->constants());\n+\n+  \/\/ load VMSupport\n+  Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();\n+  Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK_NULL);\n+\n+  InstanceKlass* vm_support = InstanceKlass::cast(k);\n+  if (vm_support->should_be_initialized()) {\n+    vm_support->initialize(CHECK_NULL);\n+  }\n+\n+  typeArrayOop annotations_oop = Annotations::make_java_array(annotations_array, CHECK_NULL);\n+  typeArrayHandle annotations = typeArrayHandle(THREAD, annotations_oop);\n+\n+  InstanceKlass** filter = filter_length == 1 ?\n+      (InstanceKlass**) &filter_klass_pointers:\n+      (InstanceKlass**) filter_klass_pointers;\n+  objArrayOop filter_oop = oopFactory::new_objectArray(filter_length, CHECK_NULL);\n+  objArrayHandle filter_classes(THREAD, filter_oop);\n+  for (int i = 0; i < filter_length; i++) {\n+    filter_classes->obj_at_put(i, filter[i]->java_mirror());\n+  }\n+\n+  \/\/ invoke VMSupport.encodeAnnotations\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_oop(annotations);\n+  args.push_oop(Handle(THREAD, holder->java_mirror()));\n+  args.push_oop(jcp);\n+  args.push_int(for_class);\n+  args.push_oop(filter_classes);\n+  Symbol* signature = vmSymbols::encodeAnnotations_signature();\n+  JavaCalls::call_static(&result,\n+                         vm_support,\n+                         vmSymbols::encodeAnnotations_name(),\n+                         signature,\n+                         &args,\n+                         CHECK_NULL);\n+\n+  oop res = result.get_oop();\n+  if (JVMCIENV->is_hotspot()) {\n+    return (jbyteArray) JNIHandles::make_local(THREAD, res);\n+  }\n+\n+  typeArrayOop ba = typeArrayOop(res);\n+  int ba_len = ba->length();\n+  jbyte* ba_buf = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, jbyte, ba_len);\n+  if (ba_buf == nullptr) {\n+    JVMCI_THROW_MSG_NULL(InternalError,\n+              err_msg(\"could not allocate %d bytes\", ba_len));\n+\n+  }\n+  memcpy(ba_buf, ba->byte_at_addr(0), ba_len);\n+  JVMCIPrimitiveArray ba_dest = JVMCIENV->new_byteArray(ba_len, JVMCI_CHECK_NULL);\n+  JVMCIENV->copy_bytes_from(ba_buf, ba_dest, 0, ba_len);\n+  return JVMCIENV->get_jbyteArray(ba_dest);\n+}\n+\n+C2V_VMENTRY_NULL(jbyteArray, getEncodedClassAnnotationData, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass),\n+                 jobject filter, jint filter_length, jlong filter_klass_pointers))\n+  InstanceKlass* holder = InstanceKlass::cast(UNPACK_PAIR(Klass, klass));\n+  return get_encoded_annotation_data(holder, holder->class_annotations(), true, filter_length, filter_klass_pointers, THREAD, JVMCIENV);\n+C2V_END\n+\n+C2V_VMENTRY_NULL(jbyteArray, getEncodedExecutableAnnotationData, (JNIEnv* env, jobject, ARGUMENT_PAIR(method),\n+                 jobject filter, jint filter_length, jlong filter_klass_pointers))\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n+  return get_encoded_annotation_data(method->method_holder(), method->annotations(), false, filter_length, filter_klass_pointers, THREAD, JVMCIENV);\n+C2V_END\n+\n+C2V_VMENTRY_NULL(jbyteArray, getEncodedFieldAnnotationData, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), jint index,\n+                 jobject filter, jint filter_length, jlong filter_klass_pointers))\n+  InstanceKlass* holder = check_field(InstanceKlass::cast(UNPACK_PAIR(Klass, klass)), index, JVMCIENV);\n+  fieldDescriptor fd(holder, index);\n+  return get_encoded_annotation_data(holder, fd.annotations(), false, filter_length, filter_klass_pointers, THREAD, JVMCIENV);\n+C2V_END\n+\n@@ -2920,0 +3007,3 @@\n+  {CC \"getEncodedClassAnnotationData\",                CC \"(\" HS_KLASS2 OBJECT \"IJ)[B\",                                                      FN_PTR(getEncodedClassAnnotationData)},\n+  {CC \"getEncodedExecutableAnnotationData\",           CC \"(\" HS_METHOD2 OBJECT \"IJ)[B\",                                                     FN_PTR(getEncodedExecutableAnnotationData)},\n+  {CC \"getEncodedFieldAnnotationData\",                CC \"(\" HS_KLASS2 \"I\" OBJECT \"IJ)[B\",                                                  FN_PTR(getEncodedFieldAnnotationData)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":94,"deletions":4,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  nonstatic_field(Annotations,                 _class_annotations,                     AnnotationArray*)                             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,10 @@\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.misc.VM;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.reflect.ConstantPool;\n+import sun.reflect.annotation.AnnotationParser;\n+import sun.reflect.annotation.AnnotationSupport;\n+import sun.reflect.annotation.AnnotationType;\n+\n+import java.io.ByteArrayInputStream;\n@@ -28,0 +38,2 @@\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n@@ -29,0 +41,5 @@\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.IncompleteAnnotationException;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n@@ -31,6 +48,1 @@\n-import java.util.jar.JarFile;\n-import java.util.jar.Manifest;\n-import java.util.jar.Attributes;\n-\n-import jdk.internal.misc.VM;\n-import jdk.internal.misc.Unsafe;\n+import java.util.List;\n@@ -170,0 +182,400 @@\n+\n+    \/**\n+     * Parses {@code rawAnnotationBytes} into a list of {@link Annotation}s and then\n+     * serializes them to a byte array with {@link #encodeAnnotations(Collection)}.\n+     *\/\n+    public static byte[] encodeAnnotations(byte[] rawAnnotations,\n+                                           Class<?> declaringClass,\n+                                           ConstantPool cp,\n+                                           boolean forClass,\n+                                           Class<? extends Annotation>[] selectAnnotationClasses)\n+    {\n+        for (Class<?> c : selectAnnotationClasses) {\n+            if (!c.isAnnotation()) {\n+                throw new IllegalArgumentException(c + \" is not an annotation interface\");\n+            }\n+        }\n+        Map<Class<? extends Annotation>, Annotation> annotations =\n+                AnnotationParser.parseSelectAnnotations(rawAnnotations, cp, declaringClass, selectAnnotationClasses);\n+        if (forClass && annotations.size() != selectAnnotationClasses.length) {\n+            Class<?> superClass = declaringClass.getSuperclass();\n+            nextSuperClass:\n+            while (superClass != null) {\n+                JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+                Map<Class<? extends Annotation>, Annotation> superAnnotations =\n+                    AnnotationParser.parseSelectAnnotations(\n+                            jla.getRawClassAnnotations(superClass),\n+                            jla.getConstantPool(superClass),\n+                            superClass,\n+                            selectAnnotationClasses);\n+\n+                for (Map.Entry<Class<? extends Annotation>, Annotation> e : superAnnotations.entrySet()) {\n+                    Class<? extends Annotation> annotationClass = e.getKey();\n+                    if (!annotations.containsKey(annotationClass) && AnnotationType.getInstance(annotationClass).isInherited()) {\n+                        if (annotations.isEmpty()) {\n+                            \/\/ An empty map might be unmodifiable (e.g. Collections.emptyMap()).\n+                            annotations = new LinkedHashMap<Class<? extends Annotation>, Annotation>();\n+                        }\n+                        annotations.put(annotationClass, e.getValue());\n+                        if (annotations.size() == selectAnnotationClasses.length) {\n+                            break nextSuperClass;\n+                        }\n+                    }\n+                }\n+                superClass = superClass.getSuperclass();\n+            }\n+        }\n+        return encodeAnnotations(annotations.values());\n+    }\n+\n+    \/**\n+     * Encodes a list of annotations to a byte array. The byte array can be decoded with {@link #decodeAnnotations(byte[], AnnotationDecoder)}.\n+     *\/\n+    public static byte[] encodeAnnotations(Collection<Annotation> annotations) {\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream(128);\n+            try (DataOutputStream dos = new DataOutputStream(baos)) {\n+                writeLength(dos, annotations.size());\n+                for (Annotation a : annotations) {\n+                    encodeAnnotation(dos, a);\n+                }\n+            }\n+            return baos.toByteArray();\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private static void encodeAnnotation(DataOutputStream dos, Annotation a) throws Exception {\n+        Class<? extends Annotation> type = a.annotationType();\n+        Map<String, Object> values = AnnotationSupport.memberValues(a);\n+        dos.writeUTF(type.getName());\n+        writeLength(dos, values.size());\n+        for (Map.Entry<String, Object> e : values.entrySet()) {\n+            Object value = e.getValue();\n+            if (value == null) {\n+                \/\/ IncompleteAnnotationException\n+                dos.writeByte('x');\n+                dos.writeUTF(new IncompleteAnnotationException(type, e.getKey()).toString());\n+                continue;\n+            }\n+            Class<?> valueType = value.getClass();\n+            dos.writeUTF(e.getKey());\n+            if (valueType == Byte.class) {\n+                dos.writeByte('B');\n+                dos.writeByte((byte) value);\n+            } else if (valueType == Character.class) {\n+                dos.writeByte('C');\n+                dos.writeChar((char) value);\n+            } else if (valueType == Double.class) {\n+                dos.writeByte('D');\n+                dos.writeDouble((double) value);\n+            } else if (valueType == Float.class) {\n+                dos.writeByte('F');\n+                dos.writeFloat((float) value);\n+            } else if (valueType == Integer.class) {\n+                dos.writeByte('I');\n+                dos.writeInt((int) value);\n+            } else if (valueType == Long.class) {\n+                dos.writeByte('J');\n+                dos.writeLong((long) value);\n+            } else if (valueType == Short.class) {\n+                dos.writeByte('S');\n+                dos.writeShort((short) value);\n+            } else if (valueType == Boolean.class) {\n+                dos.writeByte('Z');\n+                dos.writeBoolean((boolean) value);\n+            } else if (valueType == String.class) {\n+                dos.writeByte('s');\n+                dos.writeUTF((String) value);\n+            } else if (valueType == Class.class) {\n+                dos.writeByte('c');\n+                dos.writeUTF(((Class<?>) value).getName());\n+            } else if (valueType.isEnum()) {\n+                dos.writeByte('e');\n+                dos.writeUTF(valueType.getName());\n+                dos.writeUTF(((Enum<?>) value).name());\n+            } else if (value instanceof Annotation) {\n+                dos.writeByte('@');\n+                encodeAnnotation(dos, (Annotation) value);\n+            } else if (valueType.isArray()) {\n+                Class<?> componentType = valueType.getComponentType();\n+                if (componentType == byte.class) {\n+                    byte[] array = (byte[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('B');\n+                    writeLength(dos, array.length);\n+                    dos.write(array);\n+                } else if (componentType == char.class) {\n+                    char[] array = (char[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('C');\n+                    writeLength(dos, array.length);\n+                    for (char c : array) {\n+                        dos.writeChar(c);\n+                    }\n+                } else if (componentType == double.class) {\n+                    double[] array = (double[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('D');\n+                    writeLength(dos, array.length);\n+                    for (double v : array) {\n+                        dos.writeDouble(v);\n+                    }\n+                } else if (componentType == float.class) {\n+                    float[] array = (float[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('F');\n+                    writeLength(dos, array.length);\n+                    for (float v : array) {\n+                        dos.writeFloat(v);\n+                    }\n+                } else if (componentType == int.class) {\n+                    int[] array = (int[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('I');\n+                    writeLength(dos, array.length);\n+                    for (int j : array) {\n+                        dos.writeInt(j);\n+                    }\n+                } else if (componentType == long.class) {\n+                    long[] array = (long[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('J');\n+                    writeLength(dos, array.length);\n+                    for (long l : array) {\n+                        dos.writeLong(l);\n+                    }\n+                } else if (componentType == short.class) {\n+                    short[] array = (short[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('S');\n+                    writeLength(dos, array.length);\n+                    for (short item : array) {\n+                        dos.writeShort(item);\n+                    }\n+                } else if (componentType == boolean.class) {\n+                    boolean[] array = (boolean[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('Z');\n+                    writeLength(dos, array.length);\n+                    for (boolean b : array) {\n+                        dos.writeBoolean(b);\n+                    }\n+                } else if (componentType == String.class) {\n+                    String[] array = (String[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('s');\n+                    writeLength(dos, array.length);\n+                    for (String s : array) {\n+                        dos.writeUTF(s);\n+                    }\n+                } else if (componentType == Class.class) {\n+                    Class<?>[] array = (Class<?>[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('c');\n+                    writeLength(dos, array.length);\n+                    for (Class<?> aClass : array) {\n+                        dos.writeUTF(aClass.getName());\n+                    }\n+                } else if (componentType.isEnum()) {\n+                    Enum<?>[] array = (Enum<?>[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('e');\n+                    dos.writeUTF(componentType.getName());\n+                    writeLength(dos, array.length);\n+                    for (Enum<?> anEnum : array) {\n+                        dos.writeUTF(anEnum.name());\n+                    }\n+                } else if (componentType.isAnnotation()) {\n+                    Annotation[] array = (Annotation[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('@');\n+                    writeLength(dos, array.length);\n+                    for (Annotation annotation : array) {\n+                        encodeAnnotation(dos, annotation);\n+                    }\n+                } else {\n+                    dos.writeByte('x');\n+                    dos.writeUTF(value.toString());\n+                }\n+\n+            } else {\n+                dos.writeByte('x');\n+                dos.writeUTF(value.toString());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Helper for {@link #decodeAnnotations(byte[], AnnotationDecoder)} to convert a byte\n+     * array (ostensibly produced by {@link VMSupport#encodeAnnotations}) into objects.\n+     *\n+     * @param <T> type to which a type name is {@linkplain #resolveType(String) resolved}\n+     * @param <A> type of the object representing a decoded annotation\n+     * @param <E> type of the object representing a decoded enum constant\n+     * @param <X> type of the object representing a decoded error\n+     *\/\n+    public interface AnnotationDecoder<T, A, E, X> {\n+        \/**\n+         * Resolves a name in {@link Class#getName()} format to an object of type {@code T}.\n+         *\/\n+        T resolveType(String name);\n+\n+        \/**\n+         * Creates an object representing a decoded annotation.\n+         *\n+         * @param type the annotation interface of the annotation\n+         * @param elements elements of the annotation\n+         *\/\n+        A newAnnotation(T type, Map.Entry<String, Object>[] elements);\n+\n+        \/**\n+         * Creates an object representing a decoded enum constant.\n+         *\n+         * @param enumType the enum type\n+         * @param name the name of the enum constant\n+         *\/\n+        E newEnumValue(T enumType, String name);\n+\n+        \/**\n+         * Creates an object representing a decoded error value.\n+         *\n+         * @param description of the error\n+         *\/\n+        X newErrorValue(String description);\n+    }\n+\n+    \/**\n+     * Decodes annotations serialized in {@code encoded} to objects.\n+     *\n+     * @param <T> type to which a type name is resolved\n+     * @param <A> type of the object representing a decoded annotation\n+     * @param <E> type of the object representing a decoded enum constant\n+     * @param <X> type of the object representing a decoded error\n+     * @return an immutable list of {@code A} objects\n+     *\/\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public static <T, A, E, X> List<A> decodeAnnotations(byte[] encoded, AnnotationDecoder<T, A, E, X> decoder) {\n+        try {\n+            ByteArrayInputStream bais = new ByteArrayInputStream(encoded);\n+            DataInputStream dis = new DataInputStream(bais);\n+            return (List<A>) readArray(dis, () -> decodeAnnotation(dis, decoder));\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    private static <T, A, E, X> A decodeAnnotation(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n+        String typeName = dis.readUTF();\n+        T type = decoder.resolveType(typeName);\n+        int n = readLength(dis);\n+        Map.Entry[] elements = new Map.Entry[n];\n+        for (int i = 0; i < n; i++) {\n+            String name = dis.readUTF();\n+            byte tag = dis.readByte();\n+            elements[i] = Map.entry(name, switch (tag) {\n+                case 'B' -> dis.readByte();\n+                case 'C' -> dis.readChar();\n+                case 'D' -> dis.readDouble();\n+                case 'F' -> dis.readFloat();\n+                case 'I' -> dis.readInt();\n+                case 'J' -> dis.readLong();\n+                case 'S' -> dis.readShort();\n+                case 'Z' -> dis.readBoolean();\n+                case 's' -> dis.readUTF();\n+                case 'c' -> decoder.resolveType(dis.readUTF());\n+                case 'e' -> decoder.newEnumValue(decoder.resolveType(dis.readUTF()), dis.readUTF());\n+                case '@' -> decodeAnnotation(dis, decoder);\n+                case '[' -> decodeArray(dis, decoder);\n+                case 'x' -> decoder.newErrorValue(dis.readUTF());\n+                default -> throw new InternalError(\"Unsupported tag: \" + tag);\n+            });\n+        }\n+        return decoder.newAnnotation(type, (Map.Entry<String, Object>[]) elements);\n+    }\n+    @FunctionalInterface\n+    interface IOReader {\n+        Object read() throws IOException;\n+    }\n+\n+    private static <T, A, E, X> Object decodeArray(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n+        byte componentTag = dis.readByte();\n+        return switch (componentTag) {\n+            case 'B' -> readArray(dis, dis::readByte);\n+            case 'C' -> readArray(dis, dis::readChar);\n+            case 'D' -> readArray(dis, dis::readDouble);\n+            case 'F' -> readArray(dis, dis::readFloat);\n+            case 'I' -> readArray(dis, dis::readInt);\n+            case 'J' -> readArray(dis, dis::readLong);\n+            case 'S' -> readArray(dis, dis::readShort);\n+            case 'Z' -> readArray(dis, dis::readBoolean);\n+            case 's' -> readArray(dis, dis::readUTF);\n+            case 'c' -> readArray(dis, () -> readClass(dis, decoder));\n+            case 'e' -> {\n+                T enumType = decoder.resolveType(dis.readUTF());\n+                yield readArray(dis, () -> readEnum(dis, decoder, enumType));\n+            }\n+            case '@' -> readArray(dis, () -> decodeAnnotation(dis, decoder));\n+            default -> throw new InternalError(\"Unsupported component tag: \" + componentTag);\n+        };\n+    }\n+\n+    \/**\n+     * Reads an enum encoded at the current read position of {@code dis} and\n+     * returns it as an object of type {@code E}.\n+     *\/\n+    private static <T, A, E, X> E readEnum(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder, T enumType) throws IOException {\n+        return decoder.newEnumValue(enumType, dis.readUTF());\n+    }\n+\n+    \/**\n+     * Reads a class encoded at the current read position of {@code dis} and\n+     * returns it as an object of type {@code T}.\n+     *\/\n+    private static <T, A, E, X> T readClass(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n+        return decoder.resolveType(dis.readUTF());\n+    }\n+\n+    \/**\n+     * Reads an array encoded at the current read position of {@code dis} and\n+     * returns it in an immutable list.\n+     *\n+     * @param reader reads array elements from {@code dis}\n+     * @return an immutable list of {@code A} objects\n+     *\/\n+    private static List<Object> readArray(DataInputStream dis, IOReader reader) throws IOException {\n+        Object[] array = new Object[readLength(dis)];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = reader.read();\n+        }\n+        return List.of(array);\n+    }\n+\n+    \/**\n+     * Encodes {@code length} in 1 byte if it is less than 128.\n+     *\/\n+    private static void writeLength(DataOutputStream dos, int length) throws IOException {\n+        if (length < 0) {\n+            throw new NegativeArraySizeException();\n+        } else if (length <= 127) {\n+            dos.writeByte((byte) (0x80 | length));\n+        } else {\n+            dos.writeInt(length);\n+        }\n+    }\n+\n+    private static int readLength(DataInputStream dis) throws IOException {\n+        int ch1 = dis.readByte();\n+        int length;\n+        if (ch1 < 0) {\n+            length = ch1 & 0x7F;\n+        } else {\n+            int ch2 = dis.read();\n+            int ch3 = dis.read();\n+            int ch4 = dis.read();\n+            length = (ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0);\n+        }\n+        return length;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VMSupport.java","additions":418,"deletions":6,"binary":false,"changes":424,"status":"modified"},{"patch":"@@ -257,1 +257,2 @@\n-        jdk.management.agent;\n+        jdk.management.agent,\n+        jdk.internal.vm.ci;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -680,0 +680,7 @@\n+    \/**\n+     * Gets an unmodifiable view on the member values.\n+     *\/\n+    Map<String, Object> memberValues() {\n+        return Collections.unmodifiableMap(memberValues);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationInvocationHandler.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-     * This method is only used to parse select meta annotations in the construction\n+     * This method is used to parse select meta annotations in the construction\n@@ -93,1 +93,1 @@\n-    static Map<Class<? extends Annotation>, Annotation> parseSelectAnnotations(\n+    public static Map<Class<? extends Annotation>, Annotation> parseSelectAnnotations(\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -284,0 +284,9 @@\n+\n+    \/**\n+     * Gets an unmodifiable view of {@code a}'s elements.\n+     *\n+     * @return a map from element names to element values\n+     *\/\n+    public static Map<String, Object> memberValues(Annotation a) {\n+        return ((AnnotationInvocationHandler) Proxy.getInvocationHandler(a)).memberValues();\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationSupport.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot;\n+\n+import java.util.Map;\n+\n+import jdk.internal.vm.VMSupport.AnnotationDecoder;\n+import jdk.vm.ci.meta.AnnotationData;\n+import jdk.vm.ci.meta.EnumData;\n+import jdk.vm.ci.meta.ErrorData;\n+import jdk.vm.ci.meta.JavaType;\n+import jdk.vm.ci.meta.MetaUtil;\n+import jdk.vm.ci.meta.ResolvedJavaType;\n+import jdk.vm.ci.meta.UnresolvedJavaType;\n+\n+\/**\n+ * Implementation of {@link AnnotationDecoder} that resolves type names to {@link JavaType} values\n+ * and employs {@link AnnotationData} and {@link EnumData} to represent decoded annotations and enum\n+ * constants respectively.\n+ *\/\n+final class AnnotationDataDecoder implements AnnotationDecoder<JavaType, AnnotationData, EnumData, ErrorData> {\n+\n+    static final AnnotationDataDecoder INSTANCE = new AnnotationDataDecoder();\n+\n+    @Override\n+    public JavaType resolveType(String name) {\n+        String internalName = MetaUtil.toInternalName(name);\n+        return UnresolvedJavaType.create(internalName);\n+    }\n+\n+    @Override\n+    public AnnotationData newAnnotation(JavaType type, Map.Entry<String, Object>[] elements) {\n+        return new AnnotationData(type, elements);\n+    }\n+\n+    @Override\n+    public EnumData newEnumValue(JavaType enumType, String name) {\n+        return new EnumData(enumType, name);\n+    }\n+\n+    @Override\n+    public ErrorData newErrorValue(String description) {\n+        return new ErrorData(description);\n+    }\n+\n+    static ResolvedJavaType[] asArray(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        ResolvedJavaType[] filter = new ResolvedJavaType[2 + types.length];\n+        filter[0] = type1;\n+        filter[1] = type2;\n+        System.arraycopy(types, 0, filter, 2, types.length);\n+        return filter;\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/AnnotationDataDecoder.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -51,0 +52,6 @@\n+ *\n+ * Note also that some calls pass a raw VM value to avoid a JNI upcall. For example,\n+ * {@link #getBytecode(HotSpotResolvedJavaMethodImpl, long)} needs the raw {@code Method*} value\n+ * (stored in {@link HotSpotResolvedJavaMethodImpl#methodHandle}) in the C++ implementation. The\n+ * {@link HotSpotResolvedJavaMethodImpl} wrapper is still passed as well as it may be the last\n+ * reference keeping the raw value alive.\n@@ -1297,0 +1304,85 @@\n+\n+    \/**\n+     * Gets the serialized annotation info for {@code type} by calling\n+     * {@code VMSupport.encodeAnnotations} in the HotSpot heap.\n+     *\/\n+    byte[] getEncodedClassAnnotationData(HotSpotResolvedObjectTypeImpl type, ResolvedJavaType[] filter) {\n+        try (KlassPointers a = new KlassPointers(filter)) {\n+            return getEncodedClassAnnotationData(type, type.getKlassPointer(),\n+                            a.types, a.types.length, a.buffer());\n+        }\n+    }\n+\n+    native byte[] getEncodedClassAnnotationData(HotSpotResolvedObjectTypeImpl type, long klassPointer,\n+                    Object filter, int filterLength, long filterKlassPointers);\n+\n+    \/**\n+     * Gets the serialized annotation info for {@code method} by calling\n+     * {@code VMSupport.encodeAnnotations} in the HotSpot heap.\n+     *\/\n+    byte[] getEncodedExecutableAnnotationData(HotSpotResolvedJavaMethodImpl method, ResolvedJavaType[] filter) {\n+        try (KlassPointers a = new KlassPointers(filter)) {\n+            return getEncodedExecutableAnnotationData(method, method.getMethodPointer(),\n+                            a.types, a.types.length, a.buffer());\n+        }\n+    }\n+\n+    native byte[] getEncodedExecutableAnnotationData(HotSpotResolvedJavaMethodImpl method, long methodPointer,\n+                    Object filter, int filterLength, long filterKlassPointers);\n+\n+    \/**\n+     * Gets the serialized annotation info for the field denoted by {@code holder} and\n+     * {@code fieldIndex} by calling {@code VMSupport.encodeAnnotations} in the HotSpot heap.\n+     *\/\n+    byte[] getEncodedFieldAnnotationData(HotSpotResolvedObjectTypeImpl holder, int fieldIndex, ResolvedJavaType[] filter) {\n+        try (KlassPointers a = new KlassPointers(filter)) {\n+            return getEncodedFieldAnnotationData(holder, holder.getKlassPointer(), fieldIndex,\n+                            a.types, a.types.length, a.buffer());\n+        }\n+    }\n+\n+    native byte[] getEncodedFieldAnnotationData(HotSpotResolvedObjectTypeImpl holder, long klassPointer, int fieldIndex,\n+                    Object filterTypes, int filterLength, long filterKlassPointers);\n+\n+    \/**\n+     * Helper for passing {@Klass*} values to native code.\n+     *\/\n+    static final class KlassPointers implements AutoCloseable {\n+        final ResolvedJavaType[] types;\n+        long pointersArray;\n+        final Unsafe unsafe = UnsafeAccess.UNSAFE;\n+\n+        KlassPointers(ResolvedJavaType[] types) {\n+            this.types = types;\n+        }\n+\n+        \/**\n+         * Gets the buffer in which to pass the {@Klass*} values to JNI.\n+         *\n+         * @return a {@Klass*} value if {@code types.length == 1} otherwise the address of a native\n+         *         buffer holding an array of {@Klass*} values\n+         *\/\n+        long buffer() {\n+            int length = types.length;\n+            if (length == 1) {\n+                return ((HotSpotResolvedObjectTypeImpl) types[0]).getKlassPointer();\n+            } else {\n+                pointersArray = unsafe.allocateMemory(length * Long.BYTES);\n+                long pos = pointersArray;\n+                for (int i = 0; i < types.length; i++) {\n+                    HotSpotResolvedObjectTypeImpl hsType = (HotSpotResolvedObjectTypeImpl) types[i];\n+                    unsafe.putLong(pos, hsType.getKlassPointer());\n+                    pos += Long.BYTES;\n+                }\n+            }\n+            return pointersArray;\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (types.length != 1 && pointersArray != 0) {\n+                unsafe.freeMemory(pointersArray);\n+                pointersArray = 0;\n+            }\n+        }\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;\n@@ -31,0 +32,2 @@\n+import java.util.Collections;\n+import java.util.List;\n@@ -32,2 +35,2 @@\n-import jdk.internal.vm.annotation.Stable;\n-\n+import jdk.internal.vm.VMSupport;\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -224,0 +227,21 @@\n+\n+    @Override\n+    public AnnotationData getAnnotationData(ResolvedJavaType annotationType) {\n+        if (!hasAnnotations()) {\n+            return null;\n+        }\n+        return getAnnotationData0(annotationType).get(0);\n+    }\n+\n+    @Override\n+    public List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        if (!hasAnnotations()) {\n+            return Collections.emptyList();\n+        }\n+        return getAnnotationData0(AnnotationDataDecoder.asArray(type1, type2, types));\n+    }\n+\n+    private List<AnnotationData> getAnnotationData0(ResolvedJavaType... filter) {\n+        byte[] encoded = compilerToVM().getEncodedFieldAnnotationData(holder, index, filter);\n+        return VMSupport.decodeAnnotations(encoded, AnnotationDataDecoder.INSTANCE);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldImpl.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import java.util.Collections;\n+import java.util.List;\n@@ -40,0 +42,1 @@\n+import jdk.internal.vm.VMSupport;\n@@ -42,0 +45,1 @@\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -526,1 +530,1 @@\n-        if ((getConstMethodFlags() & config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {\n+        if (!hasAnnotations()) {\n@@ -534,1 +538,1 @@\n-        if ((getConstMethodFlags() & config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {\n+        if (!hasAnnotations()) {\n@@ -542,1 +546,1 @@\n-        if ((getConstMethodFlags() & config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {\n+        if (!hasAnnotations()) {\n@@ -548,0 +552,7 @@\n+    \/**\n+     * Returns whether this method has annotations.\n+     *\/\n+    private boolean hasAnnotations() {\n+        return (getConstMethodFlags() & config().constMethodHasMethodAnnotations) != 0 && !isClassInitializer();\n+    }\n+\n@@ -755,0 +766,21 @@\n+\n+    @Override\n+    public AnnotationData getAnnotationData(ResolvedJavaType type) {\n+        if (!hasAnnotations()) {\n+            return null;\n+        }\n+        return getAnnotationData0(type).get(0);\n+    }\n+\n+    @Override\n+    public List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        if (!hasAnnotations()) {\n+            return Collections.emptyList();\n+        }\n+        return getAnnotationData0(AnnotationDataDecoder.asArray(type1, type2, types));\n+    }\n+\n+    private List<AnnotationData> getAnnotationData0(ResolvedJavaType... filter) {\n+        byte[] encoded = compilerToVM().getEncodedExecutableAnnotationData(this, filter);\n+        return VMSupport.decodeAnnotations(encoded, AnnotationDataDecoder.INSTANCE);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.Collections;\n@@ -40,0 +41,1 @@\n+import java.util.List;\n@@ -41,0 +43,1 @@\n+import jdk.internal.vm.VMSupport;\n@@ -42,0 +45,1 @@\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -874,0 +878,29 @@\n+    \/**\n+     * Determines if this type may have annotations. A positive result does not mean this type has\n+     * annotations but a negative result guarantees this type has no annotations.\n+     *\n+     * @param includingInherited if true, expand this query to include superclasses of this type\n+     *\/\n+    private boolean mayHaveAnnotations(boolean includingInherited) {\n+        if (isArray()) {\n+            return false;\n+        }\n+        HotSpotVMConfig config = config();\n+        final long metaspaceAnnotations = UNSAFE.getAddress(getKlassPointer() + config.instanceKlassAnnotationsOffset);\n+        if (metaspaceAnnotations != 0) {\n+            long classAnnotations = UNSAFE.getAddress(metaspaceAnnotations + config.annotationsClassAnnotationsOffset);\n+            if (classAnnotations != 0) {\n+                return true;\n+            }\n+        }\n+        if (includingInherited) {\n+            HotSpotResolvedObjectTypeImpl superClass = getSuperclass();\n+            if (superClass != null) {\n+                return superClass.mayHaveAnnotations(true);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static final Annotation[] NO_ANNOTATIONS = {};\n+\n@@ -876,0 +909,3 @@\n+        if (!mayHaveAnnotations(true)) {\n+            return NO_ANNOTATIONS;\n+        }\n@@ -881,0 +917,3 @@\n+        if (!mayHaveAnnotations(false)) {\n+            return NO_ANNOTATIONS;\n+        }\n@@ -886,0 +925,3 @@\n+        if (!mayHaveAnnotations(true)) {\n+            return null;\n+        }\n@@ -1065,0 +1107,21 @@\n+\n+    @Override\n+    public AnnotationData getAnnotationData(ResolvedJavaType annotationType) {\n+        if (!mayHaveAnnotations(true)) {\n+            return null;\n+        }\n+        return getAnnotationData0(annotationType).get(0);\n+    }\n+\n+    @Override\n+    public List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        if (!mayHaveAnnotations(true)) {\n+            return Collections.emptyList();\n+        }\n+        return getAnnotationData0(AnnotationDataDecoder.asArray(type1, type2, types));\n+    }\n+\n+    private List<AnnotationData> getAnnotationData0(ResolvedJavaType... filter) {\n+        byte[] encoded = compilerToVM().getEncodedClassAnnotationData(this, filter);\n+        return VMSupport.decodeAnnotations(encoded, AnnotationDataDecoder.INSTANCE);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.util.Collections;\n+import java.util.List;\n@@ -33,0 +35,1 @@\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -320,0 +323,11 @@\n+\n+    @Override\n+    public AnnotationData getAnnotationData(ResolvedJavaType type) {\n+        return null;\n+    }\n+\n+    @Override\n+    public List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        return Collections.emptyList();\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedPrimitiveType.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+    final int annotationsClassAnnotationsOffset = getFieldOffset(\"Annotations::_class_annotations\", Integer.class, \"AnnotationArray*\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-     * An object handle in {@code JVMCI::_object_handles}.\n+     * An object handle in {@code JVMCIRuntime::_oop_handles}.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/IndirectHotSpotObjectConstantImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.meta;\n+\n+import java.lang.annotation.Inherited;\n+import java.util.List;\n+\n+\/**\n+ * Represents a program element such as a method, constructor, field or class for which annotations\n+ * may be present.\n+ *\/\n+public interface Annotated {\n+\n+    \/**\n+     * Gets this element's annotations whose types are in the set composed of {@code type1},\n+     * {@code type2} and {@code types}. All enum types referenced by the returned annotation are\n+     * initialized. Class initialization is not triggered for enum types referenced by other\n+     * annotations of this element.\n+     *\n+     * If this element is a class, then {@link Inherited} annotations are included in the set of\n+     * annotations considered.\n+     *\n+     * @param type1 an annotation type\n+     * @param type2 an annotation type\n+     * @param types more annotation types\n+     * @return an immutable list of the annotations present on this element that match one of the\n+     *         given types\n+     * @throws IllegalArgumentException if any type in the set composed of {@code type1},\n+     *             {@code type2} and {@code types} is not an annotation interface type\n+     * @throws UnsupportedOperationException if this operation is not supported\n+     *\/\n+    default List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Gets this element's annotation of type {@code type}.\n+     *\n+     * @param type the type object corresponding to the annotation interface type\n+     * @return this element's annotation for the specified annotation type if present on this\n+     *         element, else null\n+     * @throws IllegalArgumentException if {@code type} is not an annotation interface type\n+     * @throws UnsupportedOperationException if this operation is not supported\n+     *\/\n+    default AnnotationData getAnnotationData(ResolvedJavaType type) {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/Annotated.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.meta;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+\/**\n+ * Represents an annotation where element values are represented with the types described\n+ * {@linkplain #get here}.\n+ *\n+ * In contrast to the standard annotation API based on {@link Annotation}, use of\n+ * {@link AnnotationData} allows annotations to be queried without the JVMCI runtime having to\n+ * support dynamic loading of arbitrary {@link Annotation} classes. Such support is impossible in a\n+ * closed world, ahead-of-time compiled environment such as libgraal.\n+ *\/\n+public final class AnnotationData {\n+\n+    private final JavaType type;\n+    private final Map<String, Object> elements;\n+\n+    private static final Set<Class<?>> ELEMENT_TYPES = Set.of(\n+                    Boolean.class,\n+                    Byte.class,\n+                    Character.class,\n+                    Short.class,\n+                    Integer.class,\n+                    Float.class,\n+                    Long.class,\n+                    Double.class,\n+                    String.class,\n+                    EnumData.class,\n+                    AnnotationData.class);\n+\n+    \/**\n+     * Creates an annotation.\n+     *\n+     * @param type the annotation interface of this annotation, represented as a {@link JavaType}\n+     * @param elements the names and values of this annotation's element values. Each value's type\n+     *            must be one of the {@code AnnotationData} types described {@linkplain #get here}\n+     *            or it must be a {@link ErrorData} object whose {@code toString()} value describes\n+     *            the error raised while parsing the element. There is no distinction between a\n+     *            value explicitly present in the annotation and an element's default value.\n+     * @throws IllegalArgumentException if the value of an entry in {@code elements} is not of an\n+     *             accepted type\n+     * @throws NullPointerException if any of the above parameters is null or any entry in\n+     *             {@code elements} is null\n+     *\/\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public AnnotationData(JavaType type, Map.Entry<String, Object>[] elements) {\n+        this.type = Objects.requireNonNull(type);\n+        for (Map.Entry<String, Object> e : elements) {\n+            Object value = e.getValue();\n+            if (!(value instanceof ErrorData) &&\n+                            !(value instanceof JavaType) &&\n+                            !(value instanceof List) &&\n+                            !ELEMENT_TYPES.contains(value.getClass())) {\n+                throw new IllegalArgumentException(\"illegal type for element \" + e.getKey() + \": \" + value.getClass().getName());\n+            }\n+        }\n+        this.elements = Map.ofEntries(elements);\n+    }\n+\n+    \/**\n+     * @return the annotation interface of this annotation, represented as a {@link JavaType}\n+     *\/\n+    public JavaType getAnnotationType() {\n+        return type;\n+    }\n+\n+    \/\/ @formatter:off\n+    \/**\n+     * Gets the annotation element denoted by {@code name}. The following table shows the\n+     * correspondence between the type of an element as declared by a method in the annotation\n+     * interface and the type of value returned by this method:\n+     * <table>\n+     * <thead>\n+     * <tr><th>Annotation<\/th> <th>AnnotationData<\/th><\/tr>\n+     * <\/thead><tbody>\n+     * <tr><td>boolean<\/td>    <td>Boolean<\/td><\/tr>\n+     * <tr><td>byte<\/td>       <td>Byte<\/td><\/tr>\n+     * <tr><td>char<\/td>       <td>Character<\/td><\/tr>\n+     * <tr><td>short<\/td>      <td>Short<\/td><\/tr>\n+     * <tr><td>int<\/td>        <td>Integer<\/td><\/tr>\n+     * <tr><td>float<\/td>      <td>Float<\/td><\/tr>\n+     * <tr><td>long<\/td>       <td>Long<\/td><\/tr>\n+     * <tr><td>double<\/td>     <td>Double<\/td><\/tr>\n+     * <tr><td>String<\/td>     <td>String<\/td><\/tr>\n+     * <tr><td>Class<\/td>      <td>JavaType<\/td><\/tr>\n+     * <tr><td>Enum<\/td>       <td>EnumData<\/td><\/tr>\n+     * <tr><td>Annotation<\/td> <td>AnnotationData<\/td><\/tr>\n+     * <tr><td>[]<\/td><td>immutable List&lt;T&gt; where T is one of the above types<\/td><\/tr>\n+     * <\/tbody>\n+     * <\/table>\n+     *\n+     * @param <V> the type of the element as per the {@code AnnotationData} column in the above\n+     *            table or {@link Object}\n+     * @param elementType the class for the type of the element\n+     * @return the annotation element denoted by {@code name}\n+     * @throws ClassCastException if the element is not of type {@code V}\n+     * @throws IllegalArgumentException if this annotation has no element named {@code name} or if\n+     *             there was an error parsing or creating the element value\n+     *\/\n+    \/\/ @formatter:on\n+    @SuppressWarnings(\"unchecked\")\n+    public <V> V get(String name, Class<V> elementType) {\n+        Object val = elements.get(name);\n+        if (val == null) {\n+            throw new IllegalArgumentException(\"no element named \" + name);\n+        }\n+        Class<? extends Object> valClass = val.getClass();\n+        if (valClass == ErrorData.class) {\n+            throw new IllegalArgumentException(val.toString());\n+        }\n+        return elementType.cast(val);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"@\" + type.getName() + \"(\" + elements + \")\";\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof AnnotationData) {\n+            AnnotationData that = (AnnotationData) obj;\n+            return this.type.equals(that.type) && this.elements.equals(that.elements);\n+\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return type.hashCode() ^ elements.hashCode();\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/AnnotationData.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.meta;\n+\n+\/**\n+ * Represents an enum constant within {@link AnnotationData}.\n+ *\/\n+public final class EnumData {\n+    private final JavaType type;\n+    private final String name;\n+\n+    \/**\n+     * Creates an enum constant.\n+     *\n+     * @param type the {@linkplain Enum enum type}\n+     * @param name the {@linkplain Enum#name() name} of the enum\n+     *\/\n+    public EnumData(JavaType type, String name) {\n+        this.type = type;\n+        this.name = name;\n+    }\n+\n+    \/**\n+     * Gets the {@linkplain Enum enum type}.\n+     *\/\n+    public JavaType getEnumType() {\n+        return type;\n+    }\n+\n+    \/**\n+     * Gets the {@linkplain Enum#name() name} of the enum.\n+     *\/\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof EnumData) {\n+            EnumData that = (EnumData) obj;\n+            return this.type.equals(that.type) && this.name.equals(that.name);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return this.type.hashCode() ^ this.name.hashCode();\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/EnumData.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.meta;\n+\n+\/**\n+ * Represents an error constant within {@link AnnotationData}.\n+ *\n+ * Similar to {@code sun.reflect.annotation.ExceptionProxy}.\n+ *\/\n+public final class ErrorData {\n+    private final String description;\n+\n+    \/**\n+     * Creates an error constant.\n+     *\n+     * @param description description of the error\n+     *\/\n+    public ErrorData(String description) {\n+        this.description = description;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof ErrorData) {\n+            ErrorData that = (ErrorData) obj;\n+            return this.description.equals(that.description);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return description.hashCode();\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ErrorData.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-public interface ResolvedJavaField extends JavaField, ModifiersProvider, AnnotatedElement {\n+public interface ResolvedJavaField extends JavaField, ModifiersProvider, AnnotatedElement, Annotated {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaField.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-public interface ResolvedJavaMethod extends JavaMethod, InvokeTarget, ModifiersProvider, AnnotatedElement {\n+public interface ResolvedJavaMethod extends JavaMethod, InvokeTarget, ModifiersProvider, AnnotatedElement, Annotated {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-public interface ResolvedJavaType extends JavaType, ModifiersProvider, AnnotatedElement {\n+public interface ResolvedJavaType extends JavaType, ModifiersProvider, AnnotatedElement, Annotated {\n@@ -140,2 +140,2 @@\n-     * Returns {@code null} since support for VM anonymous class was removed by JDK-8243287.\n-     * This method is preserved for JVMCI backwards compatibility.\n+     * Returns {@code null} since support for VM anonymous class was removed by JDK-8243287. This\n+     * method is preserved for JVMCI backwards compatibility.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/AnnotationTestInput.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberTypeChanged.java\n+ *          TestResolvedJavaType.java\n+ * @clean jdk.internal.vm.test.AnnotationTestInput$Missing\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberTypeChanged.java\n@@ -31,0 +38,1 @@\n+ *          java.base\/jdk.internal.reflect\n@@ -32,0 +40,2 @@\n+ *          java.base\/jdk.internal.vm\n+ *          java.base\/sun.reflect.annotation\n@@ -60,0 +70,1 @@\n+import jdk.internal.vm.test.AnnotationTestInput;\n@@ -184,0 +195,8 @@\n+    @Test\n+    public void getAnnotationDataTest() throws Exception {\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredField(\"annotatedField\"));\n+        for (Field f : fields.keySet()) {\n+            TestResolvedJavaType.getAnnotationDataTest(f);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaField.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/AnnotationTestInput.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberTypeChanged.java\n+ *          TestResolvedJavaType.java\n+ * @clean jdk.internal.vm.test.AnnotationTestInput$Missing\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberTypeChanged.java\n@@ -30,0 +37,2 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.common\n+ *          java.base\/jdk.internal.reflect\n@@ -31,0 +40,2 @@\n+ *          java.base\/jdk.internal.vm\n+ *          java.base\/sun.reflect.annotation\n@@ -64,0 +75,1 @@\n+import jdk.internal.vm.test.AnnotationTestInput;\n@@ -69,0 +81,4 @@\n+import jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.Annotation1;\n+import jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.Annotation2;\n+import jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.Annotation3;\n+import jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersDE;\n@@ -477,0 +493,77 @@\n+    \/**\n+     * Encapsulates input for {@link TestResolvedJavaMethod#getAnnotationDataTest}.\n+     *\/\n+    static class AnnotationDataTest {\n+\n+        public enum NumbersEN {\n+            One,\n+            Two;\n+        }\n+\n+        public enum NumbersDE {\n+            Eins,\n+            Zwei;\n+        }\n+\n+        public enum NumbersUA {\n+            Odyn,\n+            Dva;\n+        }\n+\n+        @Retention(RetentionPolicy.RUNTIME)\n+        public @interface Annotation1 {\n+            NumbersEN value() default NumbersEN.One;\n+        }\n+\n+        @Retention(RetentionPolicy.RUNTIME)\n+        public @interface Annotation2 {\n+            NumbersDE value() default NumbersDE.Eins;\n+        }\n+\n+        @Retention(RetentionPolicy.RUNTIME)\n+        public @interface Annotation3 {\n+            NumbersUA value() default NumbersUA.Odyn;\n+        }\n+\n+        @Annotation1\n+        @Annotation2\n+        @Annotation3(NumbersUA.Dva)\n+        static void methodWithThreeAnnotations() {\n+\n+        }\n+    }\n+\n+    @Test\n+    public void getAnnotationDataTest() throws Exception {\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"annotatedMethod\"));\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"missingAnnotation\"));\n+        try {\n+            TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"missingNestedAnnotation\"));\n+            throw new AssertionError(\"expected \" + NoClassDefFoundError.class.getName());\n+        } catch (NoClassDefFoundError e) {\n+            Assert.assertEquals(\"jdk\/internal\/vm\/test\/AnnotationTestInput$Missing\", e.getMessage());\n+        }\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"missingTypeOfClassMember\"));\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"missingMember\"));\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"changeTypeOfMember\"));\n+\n+        for (Method m : methods.keySet()) {\n+            TestResolvedJavaType.getAnnotationDataTest(m);\n+        }\n+\n+        ResolvedJavaMethod m = metaAccess.lookupJavaMethod(AnnotationDataTest.class.getDeclaredMethod(\"methodWithThreeAnnotations\"));\n+        ResolvedJavaType a1 = metaAccess.lookupJavaType(Annotation1.class);\n+        ResolvedJavaType a2 = metaAccess.lookupJavaType(Annotation2.class);\n+        ResolvedJavaType a3 = metaAccess.lookupJavaType(Annotation3.class);\n+        ResolvedJavaType a4 = metaAccess.lookupJavaType(AnnotationDataTest.class);\n+        ResolvedJavaType numbersDEType = metaAccess.lookupJavaType(NumbersDE.class);\n+\n+        \/\/ Ensure NumbersDE is not initialized before Annotation2 is requested\n+        Assert.assertFalse(numbersDEType.isInitialized());\n+        Assert.assertEquals(2, m.getAnnotationData(a1, a3).size());\n+\n+        \/\/ Ensure NumbersDE is initialized after Annotation2 is requested\n+        Assert.assertNotNull(m.getAnnotationData(a2));\n+        Assert.assertTrue(numbersDEType.isInitialized());\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":94,"deletions":1,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,6 @@\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/AnnotationTestInput.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberTypeChanged.java\n+ * @clean jdk.internal.vm.test.AnnotationTestInput$Missing\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberTypeChanged.java\n@@ -34,0 +40,2 @@\n+ *          java.base\/jdk.internal.vm\n+ *          java.base\/sun.reflect.annotation\n@@ -60,0 +68,2 @@\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Array;\n@@ -66,0 +76,1 @@\n+import java.util.function.BiConsumer;\n@@ -69,0 +80,1 @@\n+import java.util.List;\n@@ -71,0 +83,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -75,1 +89,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n@@ -77,0 +90,1 @@\n+import jdk.internal.vm.test.AnnotationTestInput;\n@@ -78,0 +92,3 @@\n+import jdk.vm.ci.meta.Annotated;\n+import jdk.vm.ci.meta.AnnotationData;\n+import jdk.vm.ci.meta.EnumData;\n@@ -81,0 +98,2 @@\n+import jdk.vm.ci.meta.JavaType;\n+import jdk.vm.ci.meta.MetaUtil;\n@@ -84,0 +103,2 @@\n+import jdk.vm.ci.meta.UnresolvedJavaType;\n+import sun.reflect.annotation.AnnotationSupport;\n@@ -180,1 +201,2 @@\n-        \/\/ Verify that the last dot in lambda types is properly handled when transitioning from internal name to java\n+        \/\/ Verify that the last dot in lambda types is properly handled when transitioning from\n+        \/\/ internal name to java\n@@ -906,5 +928,5 @@\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(AccessibleObject.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Constructor.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Field.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Method.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Module.class))) {\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(AccessibleObject.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Constructor.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Field.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Method.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Module.class))) {\n@@ -1134,0 +1156,34 @@\n+    @Test\n+    public void getAnnotationDataTest() throws Exception {\n+        getAnnotationDataTest(AnnotationTestInput.AnnotatedClass.class);\n+        getAnnotationDataTest(int.class);\n+        getAnnotationDataTest(void.class);\n+        for (Class<?> c : classes) {\n+            getAnnotationDataTest(c);\n+        }\n+\n+        \/\/ Primitive classes have no annotations but we cannot directly\n+        \/\/ test absence of annotations. Instead, just ensure empty answers\n+        \/\/ are returned when looking up an arbitrary annotation type.\n+        Class<?>[] prims = {void.class, byte.class, int.class, double.class, float.class, short.class, char.class, long.class};\n+        ResolvedJavaType overrideType = metaAccess.lookupJavaType(Override.class);\n+        for (Class<?> c : prims) {\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            AnnotationData ad = type.getAnnotationData(overrideType);\n+            Assert.assertNull(String.valueOf(ad), ad);\n+            List<AnnotationData> adArray = type.getAnnotationData(overrideType, overrideType);\n+            Assert.assertEquals(0, adArray.size());\n+        }\n+\n+        \/\/ Test that inherited annotations are handled properly.\n+        ResolvedJavaType namedType = metaAccess.lookupJavaType(AnnotationTestInput.Named.class);\n+        AnnotationData ad = metaAccess.lookupJavaType(AnnotationTestInput.OwnName.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"NonInheritedValue\", ad.get(\"value\", String.class));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName1.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"Super1\", ad.get(\"value\", String.class));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName2.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"Super2\", ad.get(\"value\", String.class));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName3.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"Super1\", ad.get(\"value\", String.class));\n+    }\n+\n@@ -1177,0 +1233,125 @@\n+\n+    \/**\n+     * Tests that {@link AnnotationData} obtained from a {@link Class}, {@link Method} or\n+     * {@link Field} matches {@link AnnotatedElement#getAnnotations()} for the corresponding JVMCI\n+     * object.\n+     *\n+     * @param annotated a {@link Class}, {@link Method} or {@link Field} object\n+     *\/\n+    public static void getAnnotationDataTest(AnnotatedElement annotated) throws Exception {\n+        testGetAnnotationData(annotated, List.of(annotated.getAnnotations()));\n+    }\n+\n+    private static void testGetAnnotationData(AnnotatedElement annotated, List<Annotation> annotations) throws AssertionError {\n+        for (Annotation a : annotations) {\n+            AnnotationData ad = toAnnotated(annotated).getAnnotationData(metaAccess.lookupJavaType(a.annotationType()));\n+            assertAnnotationsEquals(a, ad);\n+\n+            \/\/ Check that encoding\/decoding produces a stable result\n+            AnnotationData ad2 = toAnnotated(annotated).getAnnotationData(metaAccess.lookupJavaType(a.annotationType()));\n+            assertEquals(ad, ad2);\n+        }\n+        if (annotations.size() < 2) {\n+            return;\n+        }\n+        ResolvedJavaType type1 = metaAccess.lookupJavaType(annotations.get(0).annotationType());\n+        ResolvedJavaType type2 = metaAccess.lookupJavaType(annotations.get(1).annotationType());\n+        for (int i = 2; i < annotations.size(); i++) {\n+\n+            ResolvedJavaType[] types = annotations.\/\/\n+                            subList(2, i + 1).\/\/\n+                            stream().map(a -> metaAccess.lookupJavaType(a.annotationType())).\/\/\n+                            toArray(ResolvedJavaType[]::new);\n+            List<AnnotationData> annotationData = toAnnotated(annotated).getAnnotationData(type1, type2, types);\n+            assertEquals(2 + types.length, annotationData.size());\n+\n+            for (int j = 0; j < annotationData.size(); j++) {\n+                Annotation a = annotations.get(j);\n+                AnnotationData ad = annotationData.get(j);\n+                assertAnnotationsEquals(a, ad);\n+            }\n+        }\n+    }\n+\n+    private static Annotated toAnnotated(AnnotatedElement element) {\n+        if (element instanceof Class<?> t) {\n+            return metaAccess.lookupJavaType(t);\n+        } else if (element instanceof Method m) {\n+            return metaAccess.lookupJavaMethod(m);\n+        } else {\n+            Field f = (Field) element;\n+            return metaAccess.lookupJavaField(f);\n+        }\n+    }\n+\n+    private static UnresolvedJavaType asType(Class<?> valueType) {\n+        return UnresolvedJavaType.create(MetaUtil.toInternalName(valueType.getName()));\n+    }\n+\n+    private static void assertAnnotationsEquals(Annotation a, AnnotationData ad) {\n+        Map<String, Object> values = AnnotationSupport.memberValues(a);\n+        for (Map.Entry<String, Object> e : values.entrySet()) {\n+            String name = e.getKey();\n+            Object aValue = e.getValue();\n+            Object adValue;\n+            try {\n+                adValue = ad.get(name, Object.class);\n+            } catch (IllegalArgumentException ex) {\n+                assertEquals(aValue.toString(), ex.getMessage());\n+                continue;\n+            }\n+            try {\n+                assertAnnotationElementsEqual(aValue, adValue);\n+            } catch (ClassCastException ex) {\n+                throw new AssertionError(a.getClass().getName() + \".\" + name + \" has wrong type: \" + adValue.getClass().getName(), ex);\n+            }\n+        }\n+    }\n+\n+    private static void assertAnnotationElementsEqual(Object aValue, Object adValue) {\n+        Class<?> valueType = aValue.getClass();\n+        if (valueType.isEnum()) {\n+            assertEnumObjectsEquals(aValue, adValue);\n+        } else if (aValue instanceof Class) {\n+            assertClassObjectsEquals(aValue, adValue);\n+        } else if (aValue instanceof Annotation) {\n+            assertAnnotationObjectsEquals(aValue, adValue);\n+        } else if (valueType.isArray()) {\n+            List<?> adList = (List<?>) adValue;\n+            int length = Array.getLength(aValue);\n+            assertEquals(length, adList.size());\n+            for (int i = 0; i < length; i++) {\n+                assertAnnotationElementsEqual(Array.get(aValue, i), adList.get(i));\n+            }\n+        } else {\n+            assertEquals(aValue.getClass(), adValue.getClass());\n+            assertEquals(aValue, adValue);\n+        }\n+    }\n+\n+    private static void assertClassObjectsEquals(Object aValue, Object adValue) {\n+        String aName = ((Class<?>) aValue).getName();\n+        String adName = ((JavaType) adValue).toClassName();\n+        assertEquals(aName, adName);\n+    }\n+\n+    private static void assertEnumObjectsEquals(Object aValue, Object adValue) {\n+        EnumData adEnum = (EnumData) adValue;\n+        String adEnumName = adEnum.getName();\n+        String aEnumName = ((Enum<?>) aValue).name();\n+        assertEquals(adEnumName, aEnumName);\n+    }\n+\n+    private static void assertAnnotationObjectsEquals(Object aValue, Object adValue) {\n+        Annotation aAnnotation = (Annotation) aValue;\n+        AnnotationData adAnnotation = (AnnotationData) adValue;\n+        assertAnnotationsEquals(aAnnotation, adAnnotation);\n+    }\n+\n+    private static void assertArraysEqual(Object aValue, Object adValue, int length, BiConsumer<Object, Object> assertEqualty) {\n+        Object[] aArray = (Object[]) aValue;\n+        Object[] adArray = (Object[]) adValue;\n+        for (int i = 0; i < length; i++) {\n+            assertEqualty.accept(aArray[i], adArray[i]);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":189,"deletions":8,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -25,8 +25,2 @@\n-import jdk.internal.misc.Unsafe;\n-import jdk.vm.ci.meta.ConstantReflectionProvider;\n-import jdk.vm.ci.meta.JavaConstant;\n-import jdk.vm.ci.meta.MetaAccessProvider;\n-import jdk.vm.ci.meta.ResolvedJavaField;\n-import jdk.vm.ci.meta.ResolvedJavaType;\n-import jdk.vm.ci.runtime.JVMCI;\n-import org.junit.Test;\n+import static java.lang.reflect.Modifier.isFinal;\n+import static java.lang.reflect.Modifier.isStatic;\n@@ -57,2 +51,9 @@\n-import static java.lang.reflect.Modifier.isFinal;\n-import static java.lang.reflect.Modifier.isStatic;\n+import org.junit.Test;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.vm.ci.meta.ConstantReflectionProvider;\n+import jdk.vm.ci.meta.JavaConstant;\n+import jdk.vm.ci.meta.MetaAccessProvider;\n+import jdk.vm.ci.meta.ResolvedJavaField;\n+import jdk.vm.ci.meta.ResolvedJavaType;\n+import jdk.vm.ci.runtime.JVMCI;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TypeUniverse.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,375 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+public class AnnotationTestInput {\n+\n+    enum Mood {\n+        HAPPY,\n+        SAD,\n+        CONFUSED;\n+    }\n+\n+    private class PrivateClass {}\n+\n+    @Single(string = \"a\",\n+            stringArray = {\"a\", \"b\"},\n+            classValue = String.class,\n+            classArray = {String.class, Exception.class},\n+            byteValue = 1,\n+            byteArray = {1, 2, Byte.MIN_VALUE, Byte.MAX_VALUE},\n+            charValue = 'a',\n+            charArray = {'a', 'b',\n+                         Character.MIN_VALUE, Character.MAX_VALUE,\n+                         '\\b', '\\f', '\\n', '\\r', '\\t', '\\\\', '\\'', '\\\"', '\\u012A'},\n+            doubleValue = 3.3D,\n+            doubleArray = {3.3D, 4.4D,\n+                           Double.MIN_VALUE, Double.MAX_VALUE,\n+                           Double.NaN,\n+                           Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY},\n+            floatValue = 4.4F,\n+            floatArray = {4.4F, 5.5F,\n+                          Float.MIN_VALUE, Float.MAX_VALUE,\n+                          Float.NaN,\n+                          Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            intValue = 5,\n+            intArray = {5, 6, Integer.MIN_VALUE, Integer.MAX_VALUE},\n+            longValue = 6L,\n+            longArray = {6L, 7L, Long.MIN_VALUE, Long.MAX_VALUE},\n+            shortValue = 7,\n+            shortArray = {7, 8, Short.MIN_VALUE, Short.MAX_VALUE},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.SAD,\n+            moodArray = {Mood.CONFUSED, Mood.HAPPY},\n+            nested = @NestedAnno(\"nested1\"),\n+            nestedArray = {@NestedAnno(\"nested2\"), @NestedAnno(\"nested3\")})\n+    @Single(string = \"A\",\n+            stringArray = {\"A\", \"B\"},\n+            classValue = Thread.class,\n+            classArray = {Thread.class, PrivateClass.class},\n+            byteValue = -1,\n+            byteArray = {-1, -2},\n+            charValue = 'A',\n+            charArray = {'a', 'b'},\n+            doubleValue = -3.3D,\n+            doubleArray = {3.3D, 4.4D},\n+            floatValue = -4.4F,\n+            floatArray = {4.4F, 5.5F},\n+            intValue = -5,\n+            intArray = {5, 6},\n+            longValue = -6L,\n+            longArray = {6L, 7L},\n+            shortValue = -7,\n+            shortArray = {7, 8},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.CONFUSED,\n+            moodArray = {Mood.SAD, Mood.CONFUSED},\n+            nested = @NestedAnno(\"nested4\"),\n+            nestedArray = {@NestedAnno(\"nested5\"), @NestedAnno(\"nested6\")})\n+    @SingleWithDefaults\n+    @Deprecated\n+    @SuppressWarnings(\"unchecked\")\n+    public void annotatedMethod() {\n+    }\n+\n+    @Named(\"Super1\")\n+    public static class Super1 {}\n+    @Named(\"Super2\")\n+    public static class Super2 extends Super1 {}\n+    public static class Super3 extends Super1 {}\n+\n+    @Named(\"NonInheritedValue\")\n+    public static class OwnName extends Super1 {}\n+\n+    public static class InheritedName1 extends Super1 {}\n+    public static class InheritedName2 extends Super2 {}\n+    public static class InheritedName3 extends Super3 {}\n+\n+    @Named(\"AnnotatedClass\")\n+    @Single(string = \"a\",\n+            stringArray = {\"a\", \"b\"},\n+            classValue = String.class,\n+            classArray = {String.class, Exception.class},\n+            byteValue = 1,\n+            byteArray = {1, 2, Byte.MIN_VALUE, Byte.MAX_VALUE},\n+            charValue = 'a',\n+            charArray = {'a', 'b',\n+                    Character.MIN_VALUE, Character.MAX_VALUE,\n+                    '\\b', '\\f', '\\n', '\\r', '\\t', '\\\\', '\\'', '\\\"', '\\u012A'},\n+            doubleValue = 3.3D,\n+            doubleArray = {3.3D, 4.4D,\n+                    Double.MIN_VALUE, Double.MAX_VALUE,\n+                    Double.NaN,\n+                    Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY},\n+            floatValue = 4.4F,\n+            floatArray = {4.4F, 5.5F,\n+                    Float.MIN_VALUE, Float.MAX_VALUE,\n+                    Float.NaN,\n+                    Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            intValue = 5,\n+            intArray = {5, 6, Integer.MIN_VALUE, Integer.MAX_VALUE},\n+            longValue = 6L,\n+            longArray = {6L, 7L, Long.MIN_VALUE, Long.MAX_VALUE},\n+            shortValue = 7,\n+            shortArray = {7, 8, Short.MIN_VALUE, Short.MAX_VALUE},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.SAD,\n+            moodArray = {Mood.CONFUSED, Mood.HAPPY},\n+            nested = @NestedAnno(\"nested7\"),\n+            nestedArray = {@NestedAnno(\"nested8\"), @NestedAnno(\"nested9\")})\n+    @Single(string = \"A\",\n+            stringArray = {\"A\", \"B\"},\n+            classValue = Thread.class,\n+            classArray = {Thread.class, PrivateClass.class},\n+            byteValue = -1,\n+            byteArray = {-1, -2},\n+            charValue = 'A',\n+            charArray = {'a', 'b'},\n+            doubleValue = -3.3D,\n+            doubleArray = {3.3D, 4.4D},\n+            floatValue = -4.4F,\n+            floatArray = {4.4F, 5.5F},\n+            intValue = -5,\n+            intArray = {5, 6},\n+            longValue = -6L,\n+            longArray = {6L, 7L},\n+            shortValue = -7,\n+            shortArray = {7, 8},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.CONFUSED,\n+            moodArray = {Mood.SAD, Mood.CONFUSED},\n+            nested = @NestedAnno(\"nested10\"),\n+            nestedArray = {@NestedAnno(\"nested11\"), @NestedAnno(\"nested12\")})\n+    @Deprecated\n+    @SuppressWarnings({\"rawtypes\", \"all\"})\n+    public static class AnnotatedClass {}\n+\n+    @Single(string = \"a\",\n+            stringArray = {\"a\", \"b\"},\n+            classValue = String.class,\n+            classArray = {String.class, Exception.class},\n+            byteValue = 1,\n+            byteArray = {1, 2, Byte.MIN_VALUE, Byte.MAX_VALUE},\n+            charValue = 'a',\n+            charArray = {'a', 'b',\n+                    Character.MIN_VALUE, Character.MAX_VALUE,\n+                    '\\b', '\\f', '\\n', '\\r', '\\t', '\\\\', '\\'', '\\\"', '\\u012A'},\n+            doubleValue = 3.3D,\n+            doubleArray = {3.3D, 4.4D,\n+                    Double.MIN_VALUE, Double.MAX_VALUE,\n+                    Double.NaN,\n+                    Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY},\n+            floatValue = 4.4F,\n+            floatArray = {4.4F, 5.5F,\n+                    Float.MIN_VALUE, Float.MAX_VALUE,\n+                    Float.NaN,\n+                    Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            intValue = 5,\n+            intArray = {5, 6, Integer.MIN_VALUE, Integer.MAX_VALUE},\n+            longValue = 6L,\n+            longArray = {6L, 7L, Long.MIN_VALUE, Long.MAX_VALUE},\n+            shortValue = 7,\n+            shortArray = {7, 8, Short.MIN_VALUE, Short.MAX_VALUE},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.SAD,\n+            moodArray = {Mood.CONFUSED, Mood.HAPPY},\n+            nested = @NestedAnno(\"nested12\"),\n+            nestedArray = {@NestedAnno(\"nested13\"), @NestedAnno(\"nested14\")})\n+    @Single(string = \"A\",\n+            stringArray = {\"A\", \"B\"},\n+            classValue = Thread.class,\n+            classArray = {Thread.class, PrivateClass.class},\n+            byteValue = -1,\n+            byteArray = {-1, -2},\n+            charValue = 'A',\n+            charArray = {'a', 'b'},\n+            doubleValue = -3.3D,\n+            doubleArray = {3.3D, 4.4D},\n+            floatValue = -4.4F,\n+            floatArray = {4.4F, 5.5F},\n+            intValue = -5,\n+            intArray = {5, 6},\n+            longValue = -6L,\n+            longArray = {6L, 7L},\n+            shortValue = -7,\n+            shortArray = {7, 8},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.CONFUSED,\n+            moodArray = {Mood.SAD, Mood.CONFUSED},\n+            nested = @NestedAnno(\"nested15\"),\n+            nestedArray = {@NestedAnno(\"nested16\"), @NestedAnno(\"nested17\")})\n+    private static final int annotatedField = 45;\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface NestedAnno {\n+        String value();\n+    }\n+\n+    @Inherited\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface Named {\n+        String value();\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Repeatable(SingleList.class)\n+    public @interface Single {\n+        Class<?> classValue();\n+        Class<?>[] classArray();\n+\n+        String string();\n+        String[] stringArray();\n+\n+        byte byteValue();\n+        byte[] byteArray();\n+\n+        char charValue();\n+        char[] charArray();\n+\n+        double doubleValue();\n+        double[] doubleArray();\n+\n+        float floatValue();\n+        float[] floatArray();\n+\n+        int intValue();\n+        int[] intArray();\n+\n+        long longValue();\n+        long[] longArray();\n+\n+        short shortValue();\n+        short[] shortArray();\n+\n+        boolean booleanValue();\n+        boolean[] booleanArray();\n+\n+        Mood mood();\n+        Mood[] moodArray();\n+\n+        NestedAnno nested();\n+        NestedAnno[] nestedArray();\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface SingleWithDefaults {\n+        Class<?> classValue() default SingleWithDefaults.class;\n+        Class<?>[] classArray() default {};\n+\n+        String string() default \"anonymous\";\n+        String[] stringArray() default {};\n+\n+        byte byteValue() default 101;\n+        byte[] byteArray() default {};\n+\n+        char charValue() default 'Z';\n+        char[] charArray() default {};\n+\n+        double doubleValue() default 102.102D;\n+        double[] doubleArray() default {};\n+\n+        float floatValue() default 103.103F;\n+        float[] floatArray() default {};\n+\n+        int intValue() default 104;\n+        int[] intArray() default {};\n+\n+        long longValue() default 105L;\n+        long[] longArray() default {};\n+\n+        short shortValue() default 105;\n+        short[] shortArray() default {};\n+\n+        boolean booleanValue() default true;\n+        boolean[] booleanArray() default {};\n+\n+        Mood mood() default Mood.HAPPY;\n+        Mood[] moodArray() default {};\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface SingleList {\n+        Single[] value();\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface Missing {}\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface MissingWrapper {\n+        Missing value();\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface MissingContainer {\n+        Class<?> value();\n+    }\n+\n+    \/**\n+     * Method with a directly missing annotation.\n+     *\/\n+    @Missing\n+    public void missingAnnotation() {}\n+\n+    \/**\n+     * Method with an indirectly missing nested annotation.\n+     *\/\n+    @MissingWrapper(@Missing)\n+    public void missingNestedAnnotation() {}\n+\n+    \/**\n+     * Method with an annotation that has a Class member\n+     * that cannot be resolved.\n+     *\/\n+    @MissingContainer(Missing.class)\n+    public void missingTypeOfClassMember() {}\n+\n+    \/**\n+     * Method with an annotation that has a member\n+     * that is deleted in a newer version of the annotation.\n+     *\/\n+    @MemberDeleted(value = \"evolving\", retained = -34, deleted = 56)\n+    public void missingMember() {}\n+\n+    \/**\n+     * Method with an annotation that has a member named \"any\"\n+     * whose type is changed from int to String in a newer version\n+     * of the annotation.\n+     *\/\n+    @MemberTypeChanged(value = \"evolving\", retained = -34, any = 56)\n+    public void changeTypeOfMember() {}\n+\n+}\n+\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/AnnotationTestInput.java","additions":375,"deletions":0,"binary":false,"changes":375,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface MemberDeleted {\n+    String value();\n+    int retained();\n+    int deleted();\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberDeleted.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface MemberTypeChanged {\n+    String value();\n+    int retained();\n+    int any();\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberTypeChanged.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,257 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @compile AnnotationTestInput.java MemberDeleted.java MemberTypeChanged.java\n+ * @modules java.base\/jdk.internal.vm\n+ *          java.base\/sun.reflect.annotation\n+ * @clean jdk.internal.vm.test.AnnotationTestInput$Missing\n+ * @compile alt\/MemberDeleted.java alt\/MemberTypeChanged.java\n+ * @run testng\/othervm\n+ *      jdk.internal.vm.test.TestAnnotationEncodingDecoding\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Method;\n+import java.util.LinkedHashMap;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import sun.reflect.annotation.AnnotationSupport;\n+import sun.reflect.annotation.AnnotationParser;\n+import sun.reflect.annotation.ExceptionProxy;\n+\n+import jdk.internal.vm.VMSupport;\n+import jdk.internal.vm.VMSupport.AnnotationDecoder;\n+\n+public class TestAnnotationEncodingDecoding {\n+\n+    @Test\n+    public void encodeDecodeTest() throws Exception {\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredField(\"annotatedField\"));\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"annotatedMethod\"));\n+        checkDecodedEqualsEncoded(AnnotationTestInput.AnnotatedClass.class);\n+\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingAnnotation\"));\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingNestedAnnotation\"), true);\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingTypeOfClassMember\"), false);\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingMember\"));\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"changeTypeOfMember\"), false);\n+    }\n+\n+    private void checkDecodedEqualsEncoded(AnnotatedElement annotated) {\n+        checkDecodedEqualsEncoded(annotated, false);\n+    }\n+\n+    private void checkDecodedEqualsEncoded(AnnotatedElement annotated, boolean expectNCDFE) {\n+        Annotation[] annotations = getAnnotations(annotated, expectNCDFE);\n+        if (annotations == null) {\n+            return;\n+        }\n+\n+        byte[] encoded = VMSupport.encodeAnnotations(List.of(annotations));\n+        MyDecoder decoder = new MyDecoder();\n+        List<AnnotationConst> decoded = VMSupport.decodeAnnotations(encoded, decoder);\n+        int i = 0;\n+        for (AnnotationConst actual : decoded) {\n+            AnnotationConst expect = new AnnotationConst(annotations[i]);\n+            checkEquals(actual, expect);\n+            checkEquals(actual.toString(), expect.toString());\n+            i++;\n+        }\n+    }\n+\n+    private static Annotation[] getAnnotations(AnnotatedElement annotated, boolean expectNCDFE) throws AssertionError {\n+        try {\n+            Annotation[] annotations = annotated.getAnnotations();\n+            Assert.assertFalse(expectNCDFE, annotated.toString());\n+            return annotations;\n+        } catch (NoClassDefFoundError e) {\n+            if (!expectNCDFE) {\n+                throw new AssertionError(annotated.toString(), e);\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private static void checkEquals(Object actual, Object expect) {\n+        if (!actual.equals(expect)) {\n+            throw new AssertionError(String.format(\"actual != expect%nactual: %s%n%nexpect: %s\", actual, expect));\n+        }\n+    }\n+\n+    public static final class AnnotationConst {\n+        final Class<?> type;\n+        final Map<String, Object> elements;\n+\n+        AnnotationConst(Class<?> type, Map.Entry<String, Object>[] elements) {\n+            this.type = type;\n+            this.elements = Map.ofEntries(elements);\n+        }\n+\n+        AnnotationConst(Annotation a) {\n+            Map<String, Object> values = AnnotationSupport.memberValues(a);\n+            this.type = a.annotationType();\n+            Map.Entry[] elements = new Map.Entry[values.size()];\n+            int i = 0;\n+            for (Map.Entry<String, Object> e : values.entrySet()) {\n+                elements[i++] = Map.entry(e.getKey(), decodeValue(e.getValue()));\n+            }\n+            this.elements = Map.ofEntries(elements);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof AnnotationConst) {\n+                AnnotationConst that = (AnnotationConst) obj;\n+                return this.type.equals(that.type) &&\n+                        this.elements.equals(that.elements);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"@\" + type.getName() + \"(\" + elements + \")\";\n+        }\n+\n+        private Object decodeValue(Object value) {\n+            Class<?> valueType = value.getClass();\n+            if (value instanceof Enum) {\n+                return new EnumConst(valueType, ((Enum<?>) value).name());\n+            } else if (value instanceof Annotation) {\n+                return new AnnotationConst((Annotation) value);\n+            } else if (valueType.isArray()) {\n+                int len = Array.getLength(value);\n+                Object[] arr = new Object[len];\n+                for (int i = 0; i < len; i++) {\n+                    arr[i] = decodeValue(Array.get(value, i));\n+                }\n+                return List.of(arr);\n+            } else if (value instanceof ExceptionProxy) {\n+                return new ErrorConst(value.toString());\n+            } else {\n+                return value;\n+            }\n+        }\n+\n+        public Class<?> getType() {\n+            return type;\n+        }\n+    }\n+\n+    public static final class ErrorConst {\n+        final String desc;\n+        public ErrorConst(String desc) {\n+            this.desc = Objects.requireNonNull(desc);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return desc;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return desc.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof ErrorConst) {\n+                return ((ErrorConst) obj).desc.equals(desc);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class EnumConst {\n+        final Class<?> type;\n+        final String name;\n+\n+        public EnumConst(Class<?> type, String name) {\n+            this.type = type;\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof EnumConst) {\n+                EnumConst that = (EnumConst) obj;\n+                return this.type.equals(that.type) &&\n+                        this.name.equals(that.name);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return type.getName() + \".\" + name;\n+        }\n+\n+        public Class<?> getEnumType() {\n+            return type;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+    }\n+\n+    static class MyDecoder implements AnnotationDecoder<Class<?>, AnnotationConst, EnumConst, ErrorConst> {\n+        @Override\n+        public Class<?> resolveType(String name) {\n+            try {\n+                return Class.forName(name);\n+            } catch (ClassNotFoundException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public AnnotationConst newAnnotation(Class<?> type, Map.Entry<String, Object>[] elements) {\n+            return new AnnotationConst(type, elements);\n+        }\n+\n+        @Override\n+        public EnumConst newEnumValue(Class<?> enumType, String name) {\n+            return new EnumConst(enumType, name);\n+        }\n+\n+        @Override\n+        public ErrorConst newErrorValue(String description) {\n+            return new ErrorConst(description);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/TestAnnotationEncodingDecoding.java","additions":257,"deletions":0,"binary":false,"changes":257,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface MemberDeleted {\n+    String value();\n+    int retained();\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberDeleted.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface MemberTypeChanged {\n+    String value();\n+    int retained();\n+    String any();\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberTypeChanged.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -61,9 +61,0 @@\n-    @SuppressWarnings(\"unchecked\")\n-    @Test\n-    public void encodeDecodeTest2() throws Exception {\n-        Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n-        for (int i = 0; i < 10; i++) {\n-            throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n-        }\n-        encodeDecode(throwable);\n-    }\n","filename":"test\/jdk\/jdk\/internal\/vm\/TestTranslatedException.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"}]}