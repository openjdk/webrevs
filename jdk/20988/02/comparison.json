{"files":[{"patch":"@@ -479,0 +479,4 @@\n+LogDecorators LogConfiguration::get_default_decorators(LogSelectionList selection_list) {\n+  return LogDecorators(selection_list.get_defaults_mask());\n+}\n+\n@@ -494,1 +498,1 @@\n-  LogDecorators decorators;\n+  LogDecorators decorators = get_default_decorators(selections);\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+  static LogDecorators get_default_decorators(LogSelectionList selection_list);\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,7 @@\n+#include \"logDecorators.hpp\"\n+\n+const LogLevelType AnyLevel = LogLevelType::NotMentioned;\n+const LogTagType AnyTag     = LogTagType::__NO_TAG;\n+#define DEFAULT_DECORATORS \\\n+  DEFAULT_VALUE(mask_from_decorators(NoDecorators), AnyLevel, LOG_TAGS(jit, inlining)) \\\n+  DEFAULT_VALUE(mask_from_decorators(uptime_decorator, level_decorator, tags_decorator), AnyLevel, AnyTag)\n@@ -48,0 +55,7 @@\n+const LogDecorators::DefaultDecorator LogDecorators::default_decorators[] = {\n+#define DEFAULT_VALUE(mask, level, ...) LogDecorators::DefaultDecorator(level, mask, __VA_ARGS__),\n+  DEFAULT_DECORATORS\n+#undef DEFAULT_VALUE\n+};\n+const size_t LogDecorators::number_of_default_decorators = sizeof(default_decorators) \/ sizeof(LogDecorators::DefaultDecorator);\n+\n@@ -60,1 +74,1 @@\n-    _decorators = DefaultDecoratorsMask;\n+    \/\/ No decorators supplied, keep default decorators\n@@ -96,0 +110,22 @@\n+\n+void LogDecorators::get_default_decorators(const LogSelection& selection, uint* mask, const DefaultDecorator* defaults, size_t defaults_count) {\n+  size_t max_specificity = 0;\n+  uint tmp_mask = 0;\n+  for (size_t i = 0; i < defaults_count; ++i) {\n+    auto current_default = defaults[i];\n+    const bool ignore_level = current_default.selection().level() == AnyLevel;\n+    const bool level_matches = ignore_level || selection.level() == current_default.selection().level();\n+    if (!level_matches) continue;\n+    if (!selection.superset_of(current_default.selection())) {\n+      continue;\n+    }\n+    size_t specificity = current_default.selection().ntags();\n+    if (specificity > max_specificity) {\n+      tmp_mask = current_default.mask();\n+      max_specificity = specificity;\n+    } else if (specificity == max_specificity) {\n+      tmp_mask |= current_default.mask();\n+    }\n+  }\n+  *mask |= tmp_mask;\n+}\n","filename":"src\/hotspot\/share\/logging\/logDecorators.cpp","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"logging\/logSelection.hpp\"\n@@ -62,0 +63,1 @@\n+  friend class TestLogDecorators;\n@@ -68,1 +70,29 @@\n-    Invalid\n+    Invalid,\n+    NoDecorators\n+  };\n+\n+  class DefaultDecorator {\n+    friend class TestLogDecorators;\n+    LogSelection _selection;\n+    uint         _mask;\n+\n+    DefaultDecorator() : _selection(LogSelection::Invalid), _mask(0) {}\n+\n+  public:\n+    template<typename... Tags>\n+    DefaultDecorator(LogLevelType level, uint mask, LogTagType first, Tags... rest) : _selection(LogSelection::Invalid), _mask(mask) {\n+      static_assert(1 + sizeof...(rest) <= LogTag::MaxTags + 1,\n+                    \"Too many tags specified!\");\n+\n+      LogTagType tag_arr[LogTag::MaxTags + 1] = { first, rest... };\n+\n+      if (sizeof...(rest) == LogTag::MaxTags) {\n+        assert(tag_arr[sizeof...(rest)] == LogTag::__NO_TAG,\n+               \"Too many tags specified! Can only have up to \" SIZE_FORMAT \" tags in a tag set.\", LogTag::MaxTags);\n+      }\n+\n+      _selection = LogSelection(tag_arr, false, level);\n+    }\n+\n+    const LogSelection& selection() const { return _selection; }\n+    uint mask()                     const { return _mask; }\n@@ -74,1 +104,2 @@\n-  static const uint DefaultDecoratorsMask = (1 << uptime_decorator) | (1 << level_decorator) | (1 << tags_decorator);\n+  static const LogDecorators::DefaultDecorator default_decorators[];\n+  static const size_t number_of_default_decorators;\n@@ -80,2 +111,0 @@\n-  constexpr LogDecorators(uint mask) : _decorators(mask) {\n-  }\n@@ -87,2 +116,3 @@\n-  LogDecorators() : _decorators(DefaultDecoratorsMask) {\n-  }\n+  constexpr LogDecorators(uint mask) : _decorators(mask) {}\n+\n+  LogDecorators() : _decorators(0) {}\n@@ -102,0 +132,15 @@\n+  template<typename... Decorators>\n+  static uint mask_from_decorators(LogDecorators::Decorator first, Decorators... rest) {\n+    uint bitmask = 0;\n+    LogDecorators::Decorator decorators[1 + sizeof...(rest)] = { first, rest... };\n+    for (const LogDecorators::Decorator decorator : decorators) {\n+      if (decorator == NoDecorators) return 0;\n+      bitmask |= mask(decorator);\n+    }\n+    return bitmask;\n+  }\n+\n+  \/\/ Check if we have some default decorators for a given LogSelection. If that is the case,\n+  \/\/ the output parameter mask will contain the defaults-specified decorators mask\n+  static void get_default_decorators(const LogSelection& selection, uint* mask, const DefaultDecorator* defaults = default_decorators, size_t defaults_count = number_of_default_decorators);\n+\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":51,"deletions":6,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -72,0 +72,20 @@\n+bool LogSelection::superset_of(const LogSelection& other) const {\n+  \/\/ Every set contains the empty set, so if other is empty we return true\n+  if (other._tags[0] == LogTag::__NO_TAG) return true;\n+  \n+  bool match;\n+  for (size_t i = 0; i < other.ntags(); ++i) {\n+    match = false;\n+    for (size_t j = 0; j < _ntags; ++j) {\n+      if (other._tags[i] == _tags[j]) {\n+        match = true;\n+        break;\n+      }\n+    }\n+\n+    if (!match) return false;\n+  }\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/logging\/logSelection.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+  bool superset_of(const LogSelection& ref) const;\n+\n","filename":"src\/hotspot\/share\/logging\/logSelection.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,7 @@\n+uint LogSelectionList::get_defaults_mask() const {\n+  uint mask = 0;\n+  for (size_t i = 0; i < _nselections; ++i) {\n+    LogDecorators::get_default_decorators(_selections[i], &mask);\n+  }\n+  return mask;\n+}\n@@ -94,1 +101,1 @@\n-  for (size_t i= 0; i < _nselections; i++) {\n+  for (size_t i = 0; i < _nselections; i++) {\n","filename":"src\/hotspot\/share\/logging\/logSelectionList.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+\n+  uint get_defaults_mask() const;\n","filename":"src\/hotspot\/share\/logging\/logSelectionList.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"logging\/logDecorators.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"unittest.hpp\"\n+\n+\n+class TestLogDecorators : public testing::Test {\n+  using DefaultDecorator = LogDecorators::DefaultDecorator;\n+  using LD = LogDecorators;\n+\n+  static const size_t defaults_cnt = 6;\n+  DefaultDecorator defaults[defaults_cnt] = {\n+    { LogLevelType::Trace, LD::mask_from_decorators(LD::pid_decorator), LogTagType::_gc },\n+    { LogLevelType::Trace, LD::mask_from_decorators(LD::NoDecorators), LogTagType::_jit },\n+    { LogLevelType::NotMentioned, LD::mask_from_decorators(LD::pid_decorator, LD::tid_decorator), LogTagType::_ref },\n+    { LogLevelType::Trace, LD::mask_from_decorators(LD::time_decorator), LogTagType::_gc },\n+    { LogLevelType::Debug, LD::mask_from_decorators(LD::pid_decorator), LogTagType::_compilation },\n+    { LogLevelType::Debug, LD::mask_from_decorators(LD::uptimemillis_decorator), LogTagType::_compilation, LogTagType::_codecache }\n+  };\n+\n+public:\n+  void test_default_decorators() {\n+    LogTagType tags[LogTag::MaxTags] = { LogTag::__NO_TAG, LogTag::__NO_TAG, LogTag::__NO_TAG, LogTag::__NO_TAG, LogTag::__NO_TAG };\n+    uint out_mask = 0;\n+\n+\n+    \/\/ Log selection with matching tag exactly should find default\n+    tags[0] = LogTagType::_jit;\n+    LD::get_default_decorators(LogSelection(tags, false, LogLevelType::Trace), &out_mask, defaults, defaults_cnt);\n+    EXPECT_EQ(LD::mask_from_decorators(LD::NoDecorators), out_mask);\n+\n+\n+    \/\/ Wildcards are ignored\n+    tags[0] = LogTag::_compilation;\n+    out_mask = 0;\n+    LD::get_default_decorators(LogSelection(tags, true, LogLevelType::Debug), &out_mask, defaults, defaults_cnt);\n+    EXPECT_EQ(LD::mask_from_decorators(LD::pid_decorator), out_mask);\n+\n+\n+    \/\/ If several defaults match with the same specificity, all defaults are applied\n+    tags[0] = LogTagType::_gc;\n+    out_mask = 0;\n+    LD::get_default_decorators(LogSelection(tags, false, LogLevelType::Trace), &out_mask, defaults, defaults_cnt);\n+    EXPECT_EQ(LD::mask_from_decorators(LD::pid_decorator, LD::time_decorator), out_mask);\n+\n+\n+    \/\/ If several defaults match but one has higher specificity, only its defaults are applied\n+    tags[0] = LogTagType::_compilation;\n+    tags[1] = LogTagType::_codecache;\n+    out_mask = 0;\n+    LD::get_default_decorators(LogSelection(tags, false, LogLevelType::Debug), &out_mask, defaults, defaults_cnt);\n+    EXPECT_EQ(LD::mask_from_decorators(LD::uptimemillis_decorator), out_mask);\n+\n+\n+    \/\/ If a level is not specified to match (via AnyTag or NotMentioned), it should not be taken into account\n+    tags[0] = LogTagType::_ref;\n+    tags[1] = LogTagType::__NO_TAG;\n+    out_mask = 0;\n+    LD::get_default_decorators(LogSelection(tags, false, LogLevelType::Info), &out_mask, defaults, defaults_cnt);\n+    EXPECT_EQ(LD::mask_from_decorators(LD::pid_decorator, LD::tid_decorator), out_mask);\n+    out_mask = 0;\n+    LD::get_default_decorators(LogSelection(tags, false, LogLevelType::Trace), &out_mask, defaults, defaults_cnt);\n+    EXPECT_EQ(LD::mask_from_decorators(LD::pid_decorator, LD::tid_decorator), out_mask);\n+\n+\n+    \/\/ In spite of the previous, higher specificities should still prevail\n+    defaults[5] = { LogLevelType::Debug, LD::mask_from_decorators(LD::uptimemillis_decorator), LogTagType::_ref, LogTagType::_codecache };\n+    tags[1] = LogTagType::_codecache;\n+    out_mask = 0;\n+    LD::get_default_decorators(LogSelection(tags, false, LogLevelType::Debug), &out_mask, defaults, defaults_cnt);\n+    EXPECT_EQ(LD::mask_from_decorators(LD::uptimemillis_decorator), out_mask);\n+  }\n+\n+  void test_mask_from_decorators() {\n+    \/\/ Single tags should yield 2^{decorator_value_in_enum}\n+    EXPECT_EQ(LD::mask_from_decorators(LD::time_decorator), (uint)(1 << LD::time_decorator));\n+    EXPECT_EQ(LD::mask_from_decorators(LD::pid_decorator),  (uint)(1 << LD::pid_decorator));\n+    EXPECT_EQ(LD::mask_from_decorators(LD::tid_decorator),  (uint)(1 << LD::tid_decorator));\n+    EXPECT_EQ(LD::mask_from_decorators(LD::tags_decorator), (uint)(1 << LD::tags_decorator));\n+\n+\n+    \/\/ NoDecorators should yield an empty mask\n+    EXPECT_EQ(LD::mask_from_decorators(LD::NoDecorators), 0U);\n+\n+\n+    \/\/ Combinations of decorators should fill the mask accordingly to their bitmask positions\n+    uint mask = (1 << LD::time_decorator) | (1 << LD::uptimemillis_decorator) | (1 << LD::tid_decorator);\n+    EXPECT_EQ(LD::mask_from_decorators(LD::time_decorator, LD::uptimemillis_decorator, LD::tid_decorator), mask);\n+\n+\n+    \/\/ If a combination has NoDecorators in it, it takes precedence and the mask is zero\n+    EXPECT_EQ(LD::mask_from_decorators(LD::time_decorator, LD::NoDecorators, LD::tid_decorator), 0U);\n+  }\n+};\n+\n+TEST_VM_F(TestLogDecorators, MaskFromDecorators) {\n+  test_mask_from_decorators();\n+}\n+\n+TEST_VM_F(TestLogDecorators, HasDefaultDecorators) {\n+  test_default_decorators();\n+}\n","filename":"test\/hotspot\/gtest\/logging\/test_logDefaultDecorators.cpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.flagless\n+ * @summary Running -Xlog with tags which have default decorators should pick them\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver DefaultLogDecoratorsTest\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.regex.Pattern;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+\n+public class DefaultLogDecoratorsTest {\n+    private static Pattern DECORATED_LINE = Pattern.compile(\"(\\\\[.+\\\\])+ .*\");\n+\n+    private static void doTest(boolean shouldHave, String... xlog) throws Exception {\n+        List<String> argsList = new ArrayList<String>();\n+        for (String string : xlog) {\n+            argsList.add(string);\n+        }\n+        argsList.add(InnerClass.class.getName());\n+        String[] args = argsList.toArray(new String[0]);\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        List<String> allLines = Files.readAllLines(Path.of(\"decorators.log\"));\n+        for (String line : allLines) {\n+            if (DECORATED_LINE.matcher(line).find() == !shouldHave) {\n+                throw new RuntimeException(\"Logging should \" + (shouldHave ? \"\" : \"not \") + \"contain decorators!\");\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ JIT inlining logging, as per defaults, shall have all decorators disabled\n+        doTest(false, \"-Xlog:jit+inlining*=trace:decorators.log\");\n+\n+\n+        \/\/ If decorators are specified, the defaults are not taken into account\n+        doTest(true, \"-Xlog:jit+inlining*=trace:decorators.log:time\");\n+\n+\n+        \/\/ Even if decorators are only supplied for another tag(s), the defaults are not taken into account\n+        doTest(true, \"-Xlog:jit+inlining*=trace:decorators.log\", \"-Xlog:gc*=info:decorators.log:time\");\n+\n+\n+        \/\/ Defaults are not taken into account also when another tag implicitly imposes the \"standard\" defaults\n+        doTest(true, \"-Xlog:jit+inlining*=trace:decorators.log\", \"-Xlog:gc*=info:decorators.log\");\n+\n+\n+        \/\/ Other logging shall not be affected by a tag with defaults\n+        doTest(true, \"-Xlog:gc*=trace:decorators.log\");\n+    }\n+\n+    public static class InnerClass {\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"DefaultLogDecorators test\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/DefaultLogDecoratorsTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}