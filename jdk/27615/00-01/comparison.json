{"files":[{"patch":"@@ -292,0 +292,39 @@\n+    record Indices(String tr, int startIdx, int endIdx) {\n+        \/\/ first invocation\n+        static Indices findNext(String tr, int startIdx) {\n+            int endIdx = tr.indexOf('\/', startIdx);\n+            if (endIdx != -1) { \/\/ found a slash\n+                \/\/ check the presence of special algorithms with \"\/\" in the\n+                \/\/ name, e.g. truncated SHA512, which can cause the parsing\n+                \/\/ logic to go wrong\n+                int sha512Idx = tr.indexOf(SHA512TRUNCATED, startIdx);\n+                int sha512SlashIdx = (sha512Idx != -1 ? sha512Idx + 3 : -2);\n+                \/\/ if the current slash is the special algorithm slash,\n+                \/\/ move forward to the next non-algorithm slash\n+                while (endIdx == sha512SlashIdx) {\n+                    endIdx = tr.indexOf('\/', endIdx + 1);\n+                    \/\/ check for the next truncated SHA512 and update\n+                    sha512Idx = tr.indexOf(SHA512TRUNCATED, sha512SlashIdx + 1);\n+                    sha512SlashIdx = (sha512Idx != -1 ? sha512Idx + 3 : -2);\n+                }\n+            }\n+            return new Indices(tr, startIdx, endIdx);\n+        }\n+\n+        \/\/ find the next set of indices given the current set of indices;\n+        \/\/ called when curr.endIdx != -1\n+        static Indices findNext(Indices curr) {\n+            return findNext(curr.tr, curr.endIdx + 1);\n+        }\n+\n+        \/\/ check and return the trimmed string, i.e. from startIdx to endIdx.\n+        String getValue(String errMsg) throws NoSuchAlgorithmException {\n+            String value = (endIdx == -1 ? tr.substring(startIdx).trim() :\n+                    tr.substring(startIdx, endIdx).trim());\n+            if (value.isEmpty()) {\n+                throw new NoSuchAlgorithmException(errMsg);\n+            }\n+            return value;\n+        }\n+    }\n+\n@@ -309,7 +348,4 @@\n-        int endIdx = transformation.indexOf('\/');\n-        if (endIdx == -1) { \/\/ done, algo only\n-            String algo = transformation.trim();\n-            if (algo.isEmpty()) {\n-                throw new NoSuchAlgorithmException(\n-                        \"Invalid transformation: algorithm not specified\");\n-            }\n+        Indices marker = Indices.findNext(transformation, 0);\n+        String algo = marker.getValue(\n+                \"Invalid transformation: algorithm not specified\");\n+        if (marker.endIdx == -1) { \/\/ done, algo only\n@@ -317,1 +353,5 @@\n-        }\n+        } else { \/\/ should be algo\/mode\/padding\n+            marker = Indices.findNext(marker);\n+            if (marker.endIdx != -1) {\n+                String mode = marker.getValue(\n+                        \"Invalid transformation: missing mode\");\n@@ -319,39 +359,1 @@\n-        \/\/ check the presence of special algorithms with \"\/\" in the name, e.g.\n-        \/\/ truncated SHA512, which can cause the parsing logic to go wrong\n-        int sha512Idx = transformation.indexOf(SHA512TRUNCATED);\n-        int sha512SlashIdx = (sha512Idx != -1 ? sha512Idx + 3 : -2);\n-        \/\/ check for the known algorithm slash\n-        while (endIdx == sha512SlashIdx) {\n-            endIdx = transformation.indexOf('\/', sha512SlashIdx + 1);\n-            sha512Idx = transformation.indexOf(SHA512TRUNCATED, sha512SlashIdx +\n-                    SHA512TRUNCATED.length());\n-            sha512SlashIdx = (sha512Idx != -1 ? sha512Idx + 3 : -2);\n-        }\n-        String algo = (endIdx == -1 ? transformation.trim() :\n-                transformation.substring(0, endIdx).trim());\n-        if (algo.isEmpty()) {\n-            throw new NoSuchAlgorithmException(\n-                    \"Invalid transformation: algorithm not specified\");\n-        }\n-        if (endIdx == -1) { \/\/ done, algo only\n-            return new String[] { algo };\n-        } else { \/\/ continue parsing for mode and padding\n-            int startIdx = endIdx + 1;\n-            endIdx = transformation.indexOf('\/', startIdx);\n-            if (endIdx != -1) {\n-                \/\/ no truncated SHA in mode\n-                String mode = transformation.substring(startIdx,\n-                        endIdx).trim();\n-                if (mode.isEmpty()) {\n-                    throw new NoSuchAlgorithmException(\n-                            \"Invalid transformation: missing mode\");\n-                }\n-                startIdx = endIdx + 1;\n-                endIdx = transformation.indexOf('\/', startIdx);\n-                \/\/ check for the known algorithm slash\n-                while (endIdx == sha512SlashIdx) {\n-                    endIdx = transformation.indexOf('\/', sha512SlashIdx + 1);\n-                    sha512Idx = transformation.indexOf(SHA512TRUNCATED,\n-                            sha512SlashIdx + SHA512TRUNCATED.length());\n-                    sha512SlashIdx = (sha512Idx != -1 ? sha512Idx + 3 : -2);\n-                }\n+                marker = Indices.findNext(marker);\n@@ -359,6 +361,3 @@\n-                if (endIdx == -1) {\n-                    String padding = transformation.substring(startIdx).trim();\n-                    if (padding.isEmpty()) {\n-                        throw new NoSuchAlgorithmException(\n-                                \"Invalid transformation: missing padding\");\n-                    }\n+                if (marker.endIdx == -1) {\n+                    String padding = marker.getValue(\n+                            \"Invalid transformation: missing padding\");\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":52,"deletions":53,"binary":false,"changes":105,"status":"modified"}]}