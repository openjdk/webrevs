{"files":[{"patch":"@@ -406,1 +406,6 @@\n-  return attempt_allocation(min_size, requested_size, actual_size, false \/* is_tlab *\/);\n+  \/\/ Do not allow a GC because we are allocating a new TLAB to avoid an issue\n+  \/\/ with UseGCOverheadLimit: although this GC would return null if the overhead\n+  \/\/ limit would be exceeded, but it would likely free at least some space.\n+  \/\/ So the subsequent outside-TLAB allocation could be successful anyway and\n+  \/\/ the indication that the overhead limit had been exceeded swallowed.\n+  return attempt_allocation(min_size, requested_size, actual_size, false \/* allow_gc *\/);\n@@ -416,1 +421,1 @@\n-  return attempt_allocation(word_size, word_size, &dummy, true \/* is_tlab *\/);\n+  return attempt_allocation(word_size, word_size, &dummy, true \/* allow_gc *\/);\n@@ -617,1 +622,1 @@\n-                                                     bool is_tlab) {\n+                                                     bool allow_gc) {\n@@ -629,1 +634,1 @@\n-    result = attempt_allocation_slow(node_index, desired_word_size, is_tlab);\n+    result = attempt_allocation_slow(node_index, desired_word_size, allow_gc);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -463,1 +463,1 @@\n-                                      bool is_tlab);\n+                                      bool allow_gc);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}