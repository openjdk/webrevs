[{"commit":{"message":"8370325\n\nHi all,\n\n  please review this change to the allocation path to only allow one path doing GCs during that time.\n\nCurrently, when allocating an object, G1 (or actually any collector) first allocates from TLABs, then allocates from outside TLABs.\n\nWhen G1 can't find space for a TLAB in the current region, it passes on control to `G1CollectedHeap::attempt_allocation[_slow]` that first tries to allocate a new region, or do a GC. Allocation from outside TLABs does the same.\n\nG1's behavior to do a GC during failed TLAB allocation is problematic for the `UseGCOverheadLimit` functionality I'm also working on: if the GC overhead limit triggers in a particular operation, returning null for that TLAB allocation. This will will cause another GC right away trying to allocate outside TLAB. Since the garbage collections for TLAB allocations did free some memory (but because of exceeded gc overhead we returned null for the TLAB allocation), that allocation\/collection for this outside-tlab allocation will succeed, effectively swallowing the attempt to tell the mutator that GC overhead has been exceeded.\n\nTesting: tier1-5, performance neutral after some tests\n\nHth,\n  Thomas"},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp"}],"sha":"d75147e37d1b3ebd9d1513c9510f74ad639a3164"}]