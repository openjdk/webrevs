{"files":[{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8235459\n+ * @summary Confirm that HttpRequest.BodyPublishers#ofFile(Path)\n+ *          works as expected\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters jdk.test.lib.net.SimpleSSLContext\n+ *        SecureZipFSProvider\n+ * @run testng\/othervm FilePublisherPermsTest\n+ *\/\n+\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublisher;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.*;\n+import java.util.Map;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n+public class FilePublisherPermsTest implements HttpServerAdapters {\n+\n+    SSLContext sslContext;\n+    HttpServerAdapters.HttpTestServer httpTestServer;    \/\/ HTTP\/1.1      [ 4 servers ]\n+    HttpServerAdapters.HttpTestServer httpsTestServer;   \/\/ HTTPS\/1.1\n+    HttpServerAdapters.HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    HttpServerAdapters.HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    FileSystem zipFs;\n+    static Path zipFsPath;\n+    static Path defaultFsPath;\n+\n+    String policyFile;\n+\n+    \/\/ Default file system set up\n+    static final String DEFAULT_FS_MSG = \"default fs\";\n+\n+    private Path defaultFsFile() throws Exception {\n+        var file = Path.of(\"defaultFile.txt\");\n+        if (Files.notExists(file)) {\n+            Files.createFile(file);\n+            Files.writeString(file, DEFAULT_FS_MSG);\n+        }\n+        assertEquals(Files.readString(file), DEFAULT_FS_MSG);\n+        return file;\n+    }\n+\n+    @DataProvider(name = \"defaultFsData\")\n+    public Object[][] defaultFsData() {\n+        return new Object[][]{\n+                { httpURI,   defaultFsPath },\n+                { httpsURI,  defaultFsPath },\n+                { http2URI,  defaultFsPath },\n+                { https2URI, defaultFsPath },\n+                { httpURI,   defaultFsPath },\n+                { httpsURI,  defaultFsPath },\n+                { http2URI,  defaultFsPath },\n+                { https2URI, defaultFsPath },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"defaultFsData\")\n+    public void testDefaultFs(String uriString, Path path)\n+            throws Exception {\n+        out.printf(\"\\n\\n--- testDefaultFs(%s, %s): starting\\n\",\n+                uriString, path);\n+        BodyPublisher bodyPublisher = BodyPublishers.ofFile(path);\n+        send(uriString, bodyPublisher);\n+    }\n+\n+    \/\/ Zip File system set up\n+    static final String ZIP_FS_MSG = \"zip fs\";\n+\n+    static FileSystem newZipFs(Path zipFile) throws Exception {\n+        return FileSystems.newFileSystem(zipFile, Map.of(\"create\", \"true\"));\n+    }\n+\n+    static FileSystem newSecureZipFs(Path zipFile) throws Exception {\n+        FileSystem fs = newZipFs(zipFile);\n+        return new SecureZipFSProvider(fs.provider()).newFileSystem(fs);\n+    }\n+\n+    static Path zipFsFile(FileSystem fs) throws Exception {\n+        var file = fs.getPath(\"fileInZip.txt\");\n+        if (Files.notExists(file)) {\n+            Files.createFile(file);\n+            Files.writeString(file, ZIP_FS_MSG);\n+        }\n+        assertEquals(Files.readString(file), ZIP_FS_MSG);\n+        return file;\n+    }\n+\n+    @DataProvider(name = \"zipFsData\")\n+    public Object[][] zipFsData() {\n+        return new Object[][]{\n+                { httpURI,   zipFsPath },\n+                { httpsURI,  zipFsPath },\n+                { http2URI,  zipFsPath },\n+                { https2URI, zipFsPath },\n+                { httpURI,   zipFsPath },\n+                { httpsURI,  zipFsPath },\n+                { http2URI,  zipFsPath },\n+                { https2URI, zipFsPath },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"zipFsData\")\n+    public void testZipFs(String uriString, Path path) throws Exception {\n+        out.printf(\"\\n\\n--- testZipFsCustomPerm(%s, %s): starting\\n\", uriString, path);\n+        BodyPublisher bodyPublisher = BodyPublishers.ofFile(path);\n+        send(uriString, bodyPublisher);\n+    }\n+\n+    @Test\n+    public void testFileNotFound() throws Exception {\n+        out.printf(\"\\n\\n--- testFileNotFound(): starting\\n\");\n+        var zipPath = Path.of(\"fileNotFound.zip\");\n+        try (FileSystem fs = newZipFs(zipPath)) {\n+            Path fileInZip = zipFsFile(fs);\n+            Files.deleteIfExists(fileInZip);\n+            BodyPublishers.ofFile(fileInZip);\n+            fail();\n+        } catch (FileNotFoundException e) {\n+            out.println(\"Caught expected: \" + e);\n+        }\n+        var path = Path.of(\"fileNotFound.txt\");\n+        try {\n+            Files.deleteIfExists(path);\n+            BodyPublishers.ofFile(path);\n+            fail();\n+        } catch (FileNotFoundException e) {\n+            out.println(\"Caught expected: \" + e);\n+        }\n+    }\n+\n+    private void send(String uriString, BodyPublisher bodyPublisher)\n+        throws Exception {\n+        HttpClient client = HttpClient.newBuilder()\n+                        .proxy(NO_PROXY)\n+                        .sslContext(sslContext)\n+                        .build();\n+        var req = HttpRequest.newBuilder(URI.create(uriString))\n+                .POST(bodyPublisher)\n+                .build();\n+        client.send(req, HttpResponse.BodyHandlers.discarding());\n+    }\n+\n+\n+    static class HttpEchoHandler implements HttpServerAdapters.HttpTestHandler {\n+        @Override\n+        public void handle(HttpServerAdapters.HttpTestExchange t) throws IOException {\n+            try (InputStream is = t.getRequestBody();\n+                 OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = is.readAllBytes();\n+                t.sendResponseHeaders(200, bytes.length);\n+                os.write(bytes);\n+            }\n+        }\n+    }\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        zipFs = newSecureZipFs(Path.of(\"file.zip\"));\n+        zipFsPath = zipFsFile(zipFs);\n+        defaultFsPath = defaultFsFile();\n+\n+        httpTestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1);\n+        httpTestServer.addHandler(\n+                new FilePublisherPermsTest.HttpEchoHandler(), \"\/http1\/echo\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/echo\";\n+\n+        httpsTestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1, sslContext);\n+        httpsTestServer.addHandler(\n+                new FilePublisherPermsTest.HttpEchoHandler(), \"\/https1\/echo\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/echo\";\n+\n+        http2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2);\n+        http2TestServer.addHandler(\n+                new FilePublisherPermsTest.HttpEchoHandler(), \"\/http2\/echo\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/echo\";\n+\n+        https2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2, sslContext);\n+        https2TestServer.addHandler(\n+                new FilePublisherPermsTest.HttpEchoHandler(), \"\/https2\/echo\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/echo\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+            zipFs.close();\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/FilePublisher\/FilePublisherPermsTest.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -0,0 +1,446 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.file.AccessMode;\n+import java.nio.file.CopyOption;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileStore;\n+import java.nio.file.FileSystem;\n+import java.nio.file.LinkOption;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.nio.file.ProviderMismatchException;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileAttribute;\n+import java.nio.file.attribute.FileAttributeView;\n+import java.nio.file.attribute.UserPrincipalLookupService;\n+import java.nio.file.spi.FileSystemProvider;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SecureZipFSProvider extends FileSystemProvider {\n+    private final ConcurrentHashMap<FileSystem, SecureZipFS> map =\n+            new ConcurrentHashMap<>();\n+    private final FileSystemProvider defaultProvider;\n+\n+    public SecureZipFSProvider(FileSystemProvider provider) {\n+        defaultProvider = provider;\n+    }\n+\n+    @Override\n+    public String getScheme() {\n+        return \"jar\";\n+    }\n+\n+    public FileSystem newFileSystem(FileSystem fs) {\n+        return map.computeIfAbsent(fs, (sfs) ->\n+                new SecureZipFS(this, fs));\n+    }\n+\n+    @Override\n+    public FileSystem newFileSystem(URI uri, Map<String, ?> env)\n+            throws IOException {\n+        FileSystem fs = defaultProvider.newFileSystem(uri, env);\n+        return map.computeIfAbsent(fs, (sfs) ->\n+                new SecureZipFS(this, fs)\n+        );\n+    }\n+\n+    @Override\n+    public FileSystem getFileSystem(URI uri) {\n+        return map.get(defaultProvider.getFileSystem(uri));\n+    }\n+\n+    @Override\n+    public Path getPath(URI uri) {\n+        Path p = defaultProvider.getPath(uri);\n+        return map.get(defaultProvider.getFileSystem(uri)).wrap(p);\n+    }\n+\n+    @Override\n+    public InputStream newInputStream(Path path, OpenOption... options)\n+            throws IOException {\n+        Path p = toTestPath(path).unwrap();\n+        return defaultProvider.newInputStream(p, options);\n+    }\n+\n+    @Override\n+    public SeekableByteChannel newByteChannel(Path path,\n+                                              Set<? extends OpenOption> options,\n+                                              FileAttribute<?>... attrs)\n+            throws IOException {\n+        Path p = toTestPath(path).unwrap();\n+        return defaultProvider.newByteChannel(p, options, attrs);\n+    }\n+\n+    @Override\n+    public FileChannel newFileChannel(Path path,\n+                                      Set<? extends OpenOption> options,\n+                                      FileAttribute<?>... attrs)\n+            throws IOException {\n+        Path p = toTestPath(path).unwrap();\n+        return defaultProvider.newFileChannel(p, options, attrs);\n+    }\n+\n+\n+    @Override\n+    public DirectoryStream<Path> newDirectoryStream(Path dir,\n+                                                    DirectoryStream.Filter<? super Path> filter) {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void createDirectory(Path dir, FileAttribute<?>... attrs)\n+            throws IOException {\n+        Path p = toTestPath(dir).unwrap();\n+        defaultProvider.createDirectory(p, attrs);\n+    }\n+\n+    @Override\n+    public void delete(Path path) throws IOException {\n+        Path p = toTestPath(path).unwrap();\n+        defaultProvider.delete(p);\n+    }\n+\n+    @Override\n+    public void copy(Path source, Path target, CopyOption... options)\n+            throws IOException {\n+        Path sp = toTestPath(source).unwrap();\n+        Path tp = toTestPath(target).unwrap();\n+        defaultProvider.copy(sp, tp, options);\n+    }\n+\n+    @Override\n+    public void move(Path source, Path target, CopyOption... options)\n+            throws IOException {\n+        Path sp = toTestPath(source).unwrap();\n+        Path tp = toTestPath(target).unwrap();\n+        defaultProvider.move(sp, tp, options);\n+    }\n+\n+    @Override\n+    public boolean isSameFile(Path path, Path path2)\n+            throws IOException {\n+        Path p = toTestPath(path).unwrap();\n+        Path p2 = toTestPath(path2).unwrap();\n+        return defaultProvider.isSameFile(p, p2);\n+    }\n+\n+    @Override\n+    public boolean isHidden(Path path) throws IOException {\n+        Path p = toTestPath(path).unwrap();\n+        return defaultProvider.isHidden(p);\n+    }\n+\n+    @Override\n+    public FileStore getFileStore(Path path) throws IOException {\n+        Path p = toTestPath(path).unwrap();\n+        return defaultProvider.getFileStore(p);\n+    }\n+\n+    @Override\n+    public void checkAccess(Path path, AccessMode... modes) throws IOException {\n+        Path p = toTestPath(path).unwrap();\n+        defaultProvider.checkAccess(p, modes);\n+    }\n+\n+    @Override\n+    public <V extends FileAttributeView> V getFileAttributeView(Path path,\n+                                                                Class<V> type,\n+                                                                LinkOption... options) {\n+        Path p = toTestPath(path).unwrap();\n+        return defaultProvider.getFileAttributeView(p, type, options);\n+    }\n+\n+    @Override\n+    public <A extends BasicFileAttributes> A readAttributes(Path path,\n+                                                            Class<A> type,\n+                                                            LinkOption... options)\n+            throws IOException {\n+        Path p = toTestPath(path).unwrap();\n+        return defaultProvider.readAttributes(p, type, options);\n+    }\n+\n+    @Override\n+    public Map<String, Object> readAttributes(Path path,\n+                                              String attributes,\n+                                              LinkOption... options)\n+            throws IOException {\n+        Path p = toTestPath(path).unwrap();\n+        return defaultProvider.readAttributes(p, attributes, options);\n+    }\n+\n+    @Override\n+    public void setAttribute(Path path, String attribute,\n+                             Object value, LinkOption... options)\n+            throws IOException {\n+        Path p = toTestPath(path).unwrap();\n+        defaultProvider.setAttribute(p, attribute, options);\n+    }\n+\n+    \/\/ Checks that the given file is a TestPath\n+    static TestPath toTestPath(Path obj) {\n+        if (obj == null)\n+            throw new NullPointerException();\n+        if (!(obj instanceof TestPath))\n+            throw new ProviderMismatchException();\n+        return (TestPath) obj;\n+    }\n+\n+    static class SecureZipFS extends FileSystem {\n+        private final SecureZipFSProvider provider;\n+        private final FileSystem delegate;\n+\n+        public SecureZipFS(SecureZipFSProvider provider, FileSystem delegate) {\n+            this.provider = provider;\n+            this.delegate = delegate;\n+        }\n+\n+        Path wrap(Path path) {\n+            return (path != null) ? new TestPath(this, path) : null;\n+        }\n+\n+        Path unwrap(Path wrapper) {\n+            if (wrapper == null)\n+                throw new NullPointerException();\n+            if (!(wrapper instanceof TestPath))\n+                throw new ProviderMismatchException();\n+            return ((TestPath) wrapper).unwrap();\n+        }\n+\n+        @Override\n+        public FileSystemProvider provider() {\n+            return provider;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            delegate.close();\n+        }\n+\n+        @Override\n+        public boolean isOpen() {\n+            return delegate.isOpen();\n+        }\n+\n+        @Override\n+        public boolean isReadOnly() {\n+            return delegate.isReadOnly();\n+        }\n+\n+        @Override\n+        public String getSeparator() {\n+            return delegate.getSeparator();\n+        }\n+\n+        @Override\n+        public Iterable<Path> getRootDirectories() {\n+            return delegate.getRootDirectories();\n+        }\n+\n+        @Override\n+        public Iterable<FileStore> getFileStores() {\n+            return delegate.getFileStores();\n+        }\n+\n+        @Override\n+        public Set<String> supportedFileAttributeViews() {\n+            return delegate.supportedFileAttributeViews();\n+        }\n+\n+        @Override\n+        public Path getPath(String first, String... more) {\n+            return wrap(delegate.getPath(first, more));\n+        }\n+\n+        @Override\n+        public PathMatcher getPathMatcher(String syntaxAndPattern) {\n+            return delegate.getPathMatcher(syntaxAndPattern);\n+        }\n+\n+        @Override\n+        public UserPrincipalLookupService getUserPrincipalLookupService() {\n+            return delegate.getUserPrincipalLookupService();\n+        }\n+\n+        @Override\n+        public WatchService newWatchService() throws IOException {\n+            return delegate.newWatchService();\n+        }\n+    }\n+\n+    static class TestPath implements Path {\n+        private final SecureZipFS fs;\n+        private final Path delegate;\n+\n+        TestPath(SecureZipFS fs, Path delegate) {\n+            this.fs = fs;\n+            this.delegate = delegate;\n+        }\n+\n+        Path unwrap() {\n+            return delegate;\n+        }\n+\n+        @Override\n+        public SecureZipFS getFileSystem() {\n+            return fs;\n+        }\n+\n+        @Override\n+        public boolean isAbsolute() {\n+            return delegate.isAbsolute();\n+        }\n+\n+        @Override\n+        public Path getRoot() {\n+            return fs.wrap(delegate.getRoot());\n+        }\n+\n+        @Override\n+        public Path getFileName() {\n+            return fs.wrap(delegate.getFileName());\n+        }\n+\n+        @Override\n+        public Path getParent() {\n+            return fs.wrap(delegate.getParent());\n+        }\n+\n+        @Override\n+        public int getNameCount() {\n+            return delegate.getNameCount();\n+        }\n+\n+        @Override\n+        public Path getName(int index) {\n+            return fs.wrap(delegate.getName(index));\n+        }\n+\n+        @Override\n+        public Path subpath(int beginIndex, int endIndex) {\n+            return fs.wrap(delegate.subpath(beginIndex, endIndex));\n+        }\n+\n+        @Override\n+        public boolean startsWith(Path other) {\n+            return delegate.startsWith(other);\n+        }\n+\n+        @Override\n+        public boolean endsWith(Path other) {\n+            return delegate.endsWith(other);\n+        }\n+\n+        @Override\n+        public Path normalize() {\n+            return fs.wrap(delegate.normalize());\n+        }\n+\n+        @Override\n+        public Path resolve(Path other) {\n+            return fs.wrap(delegate.resolve(fs.wrap(other)));\n+        }\n+\n+        @Override\n+        public Path relativize(Path other) {\n+            return fs.wrap(delegate.relativize(fs.wrap(other)));\n+        }\n+\n+        @Override\n+        public URI toUri() {\n+            String ssp = delegate.toUri().getSchemeSpecificPart();\n+            return URI.create(fs.provider().getScheme() + \":\" + ssp);\n+        }\n+\n+        @Override\n+        public Path toAbsolutePath() {\n+            return fs.wrap(delegate.toAbsolutePath());\n+        }\n+\n+        @Override\n+        public Path toRealPath(LinkOption... options) throws IOException {\n+            return fs.wrap(delegate.toRealPath(options));\n+        }\n+\n+        @Override\n+        public WatchKey register(WatchService watcher,\n+                                 WatchEvent.Kind<?>[] events,\n+                                 WatchEvent.Modifier... modifiers)\n+                throws IOException {\n+            return delegate.register(watcher, events, modifiers);\n+        }\n+\n+        @Override\n+        public Iterator<Path> iterator() {\n+            final Iterator<Path> itr = delegate.iterator();\n+            return new Iterator<>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return itr.hasNext();\n+                }\n+\n+                @Override\n+                public Path next() {\n+                    return fs.wrap(itr.next());\n+                }\n+\n+                @Override\n+                public void remove() {\n+                    itr.remove();\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public int compareTo(Path other) {\n+            return delegate.compareTo(fs.unwrap(other));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return delegate.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            return other instanceof TestPath && delegate.equals(fs.unwrap((TestPath) other));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return delegate.toString();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/FilePublisher\/SecureZipFSProvider.java","additions":446,"deletions":0,"binary":false,"changes":446,"status":"added"}]}