{"files":[{"patch":"@@ -40,0 +40,1 @@\n+#include \"opto\/graphKit.hpp\"\n@@ -956,0 +957,2 @@\n+  \/\/ The stack from before the throwing bytecode is gone, cannot reexecute here\n+  jvms()->set_should_reexecute(false);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.exceptions;\n+\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+import java.lang.classfile.Label;\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import jdk.test.lib.Asserts;\n+import test.java.lang.invoke.lib.InstructionHelper;\n+\n+\/**\n+ * @test\n+ * @bug 8350208\n+ * @summary Safepoints added during the processing of exception handlers should never reexecute\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ *\n+ * @run main\/othervm compiler.exceptions.TestDebugDuringExceptionCatching\n+ *\/\n+public class TestDebugDuringExceptionCatching {\n+\n+    public static class V {\n+        int v;\n+    }\n+\n+    static final int ITERATIONS = 100;\n+    static final RuntimeException EXCEPTION = new RuntimeException();\n+\n+    \/**\n+     * Construct something that looks like this:\n+     * <pre>{@code\n+     * int snippet(V v) {\n+     *     int i = 0;\n+     *     LoopHead: {\n+     *         if (i >= 100) {\n+     *             goto LoopEnd;\n+     *         }\n+     *         i++;\n+     *         try {\n+     *             v.v = 1;\n+     *         } catch (Throwable) {\n+     *             \/\/ Not really, the LoopHead is the exception Handler\n+     *             goto LoopHead;\n+     *         }\n+     *     }\n+     *     LoopEnd:\n+     *     return i;\n+     * }\n+     * }<\/pre>\n+     *\/\n+    static final MethodHandle SNIPPET_HANDLE;\n+    static final ClassDesc CLASS_DESC = TestDebugDuringExceptionCatching.class.describeConstable().get();\n+    static {\n+        SNIPPET_HANDLE = InstructionHelper.buildMethodHandle(MethodHandles.lookup(),\n+                \"snippet\",\n+                MethodType.methodType(int.class, V.class),\n+                CODE -> {\n+                    Label loopHead = CODE.newLabel();\n+                    Label loopEnd = CODE.newLabel();\n+                    Label tryStart = CODE.newLabel();\n+                    Label tryEnd = CODE.newLabel();\n+                    CODE.\n+                            iconst_0().\n+                            istore(1).\n+                            \/\/ The loop head should have a RuntimeException as the sole element on the stack\n+                            getstatic(CLASS_DESC, \"EXCEPTION\", RuntimeException.class.describeConstable().get()).\n+                            labelBinding(loopHead).\n+                            pop().\n+                            iload(1).\n+                            ldc(ITERATIONS).\n+                            if_icmpge(loopEnd).\n+                            iinc(1, 1).\n+                            aload(0).\n+                            iconst_1().\n+                            labelBinding(tryStart).\n+                            putfield(V.class.describeConstable().get(), \"v\", int.class.describeConstable().get()).\n+                            labelBinding(tryEnd).\n+                            \/\/ The stack is empty here\n+                            labelBinding(loopEnd).\n+                            iload(1).\n+                            ireturn();\n+                    CODE.exceptionCatchAll(tryStart, tryEnd, loopHead);\n+                });\n+    }\n+\n+    @Test\n+    private static int testBackwardHandler(V v) throws Throwable {\n+        return (int) SNIPPET_HANDLE.invokeExact(v);\n+    }\n+\n+    @Run(test = \"testBackwardHandler\")\n+    public void run() throws Throwable {\n+        Asserts.assertEQ(ITERATIONS, testBackwardHandler(null));\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/TestDebugDuringExceptionCatching.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.classfile.CodeBuilder;\n@@ -35,0 +36,1 @@\n+import java.util.function.Consumer;\n@@ -138,0 +140,21 @@\n+\n+    public static MethodHandle buildMethodHandle(MethodHandles.Lookup l, String methodName, MethodType methodType, Consumer<? super CodeBuilder> builder) {\n+        ClassDesc genClassDesc = classDesc(l.lookupClass(), \"$Code_\" + COUNT.getAndIncrement());\n+        return buildMethodHandle(l, genClassDesc, methodName, methodType, builder);\n+    }\n+\n+    private static MethodHandle buildMethodHandle(MethodHandles.Lookup l, ClassDesc classDesc, String methodName, MethodType methodType, Consumer<? super CodeBuilder> builder) {\n+        try {\n+            byte[] bytes = ClassFile.of().build(classDesc, classBuilder -> {\n+                classBuilder.withMethod(methodName,\n+                        MethodTypeDesc.ofDescriptor(methodType.toMethodDescriptorString()),\n+                        ClassFile.ACC_PUBLIC + ClassFile.ACC_STATIC,\n+                        methodBuilder -> methodBuilder.withCode(builder));\n+            });\n+            Class<?> clazz = l.defineClass(bytes);\n+            return l.findStatic(clazz, methodName, methodType);\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+            throw new RuntimeException(\"Failed to buildMethodHandle: \" + methodName + \" type \" + methodType);\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"}]}