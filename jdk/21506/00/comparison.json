{"files":[{"patch":"@@ -29,5 +29,4 @@\n- * The constants of this enumerated class provide a simple classification of the\n- * syntactic locations where annotations may appear in a Java program. These\n- * constants are used in {@link java.lang.annotation.Target Target}\n- * meta-annotations to specify where it is legal to write annotations of a\n- * given type.\n+ * A syntactic location where an annotation may appear in Java code.\n+ * An annotation interface may optionally restrict its usage to a\n+ * particular subset of these locations using the {@link\n+ * java.lang.annotation.Target @Target} meta-annotation.\n@@ -35,4 +34,2 @@\n- * <p>The syntactic locations where annotations may appear are split into\n- * <em>declaration contexts<\/em>, where annotations apply to declarations, and\n- * <em>type contexts<\/em>, where annotations apply to types used in\n- * declarations and expressions.\n+ * <p>For example, an annotation of the following type may only appear\n+ * as part of a type parameter or local variable declaration:\n@@ -40,4 +37,4 @@\n- * <p>The constants {@link #ANNOTATION_TYPE}, {@link #CONSTRUCTOR}, {@link\n- * #FIELD}, {@link #LOCAL_VARIABLE}, {@link #METHOD}, {@link #PACKAGE}, {@link\n- * #MODULE}, {@link #PARAMETER}, {@link #TYPE}, and {@link #TYPE_PARAMETER}\n- * correspond to the declaration contexts in JLS {@jls 9.6.4.1}.\n+ * {@snippet id='example' :\n+ * @Target({ElementType.TYPE_PARAMETER, ElementType.LOCAL_VARIABLE})\n+ * public @interface MyAnnotation {}\n+ * }\n@@ -45,3 +42,2 @@\n- * <p>For example, an annotation whose interface is meta-annotated with\n- * {@code @Target(ElementType.FIELD)} may only be written as a modifier for a\n- * field declaration.\n+ * <h2 id=\"kinds-of-annotations\">Declaration annotations and type-use\n+ * annotations<\/h2>\n@@ -49,4 +45,8 @@\n- * <p>The constant {@link #TYPE_USE} corresponds to the type contexts in JLS\n- * {@jls 4.11}, as well as to two declaration contexts: class and interface\n- * declarations (including annotation declarations) and type parameter\n- * declarations.\n+ * <p>Most annotations in Java code are <b>declaration\n+ * annotations<\/b>, which act like modifiers of declarations (such as\n+ * a field or method declaration). The constants of this class cover\n+ * all ten kinds of annotatable declarations, plus a subcategory of\n+ * {@link #TYPE} called {@link #ANNOTATION_TYPE}. An annotation\n+ * interface can be used as a declaration annotation if it either\n+ * omits {@link java.lang.annotation.Target @Target}, or uses it to\n+ * list which specific kinds of declarations it should apply to.\n@@ -54,5 +54,6 @@\n- * <p>For example, an annotation whose interface is meta-annotated with\n- * {@code @Target(ElementType.TYPE_USE)} may be written on the class or\n- * interface of a field (or within the class or interface of the field, if it\n- * is a nested or parameterized class or interface, or array class), and may\n- * also appear as a modifier for, say, a class declaration.\n+ * <p>There are also <b>type-use annotations<\/b> (sometimes called\n+ * \"type annotations\"), which can appear anywhere a Java type is being\n+ * indicated (normally, immediately preceding that type). To be used\n+ * as a type-use annotation, an annotation interface must use {@link\n+ * java.lang.annotation.Target @Target} and include {@link #TYPE_USE}\n+ * explicitly.\n@@ -60,9 +61,31 @@\n- * <p>The {@code TYPE_USE} constant includes class and interface declarations\n- * and type parameter declarations as a convenience for designers of\n- * type checkers which give semantics to annotation interfaces. For example,\n- * if the annotation interface {@code NonNull} is meta-annotated with\n- * {@code @Target(ElementType.TYPE_USE)}, then {@code @NonNull}\n- * {@code class C {...}} could be treated by a type checker as indicating that\n- * all variables of class {@code C} are non-null, while still allowing\n- * variables of other classes to be non-null or not non-null based on whether\n- * {@code @NonNull} appears at the variable's declaration.\n+ * <h3 id=\"ambiguous\">Ambiguous contexts<\/h3>\n+ *\n+ * <p>For six kinds of declarations, type-use annotations can also\n+ * appear freely intermingled with declaration annotations and\n+ * modifiers:\n+ *\n+ * <ul>\n+ * <li>a field, parameter, local variable, or record component\n+ *     (treated as if it precedes that variable's type)\n+ * <li>a non-void method (treated as if it precedes the method's\n+ *     return type)\n+ * <li>a constructor (treated as if it modifies the constructed type,\n+ *     even though this is not technically a type context)\n+ * <\/ul>\n+ *\n+ * <p>In general, a library method for reading declaration annotations\n+ * (like {@link java.lang.reflect.Field#getAnnotations}) will not\n+ * return type-use annotations found in the same location, and\n+ * vice-versa.\n+ *\n+ * <p>An annotation interface may specify both {@link #TYPE_USE} and\n+ * declaration targets, and thereby be fully usable as either kind.\n+ * When an annotation of this type appears in one of the six ambiguous\n+ * contexts just listed, it functions as <em>both<\/em> a declaration\n+ * annotation and a type-use annotation at the same time. The results\n+ * may be counterintuitive in two cases: when the variable type or\n+ * method return type is an inner type or an array type. In these\n+ * cases, the declaration annotation applies to the \"entire\"\n+ * declaration, yet the type-use annotation applies more narrowly to\n+ * the <em>outer type<\/em> or to the <em>component type<\/em> of the\n+ * array.\n@@ -72,2 +95,1 @@\n- * @jls 9.6.4.1 @Target\n- * @jls 4.1 The Kinds of Types and Values\n+ * @jls 9.7.4 Where Annotations May Appear\n@@ -76,2 +98,12 @@\n-    \/** Class, interface (including annotation interface), enum, or record\n-     * declaration *\/\n+\n+    \/**\n+     * The declaration of a named class or interface. Classes without\n+     * names, such as an anonymous class or an enum constant with a\n+     * class body, cannot be annotated.\n+     *\n+     * <p><b>Terminology note:<\/b> despite this constant's name, an\n+     * annotation applied to a class declaration is not a \"type\n+     * annotation\". That phrase is only ever used as an abbreviation\n+     * of \"type-use annotation\", which is supported by {@link\n+     * #TYPE_USE}.\n+     *\/\n@@ -80,1 +112,8 @@\n-    \/** Field declaration (includes enum constants) *\/\n+    \/**\n+     * The declaration of a field (including of an enum constant).\n+     *\n+     * <p>Any annotation valid for a field declaration may also appear\n+     * on the declaration of a record component, and is automatically\n+     * copied to the private field of the same name that is generated\n+     * during compilation.\n+     *\/\n@@ -83,1 +122,9 @@\n-    \/** Method declaration *\/\n+    \/**\n+     * The declaration of a method (including of an element of an\n+     * annotation interface).\n+     *\n+     * <p>Any annotation valid for a method declaration may also appear\n+     * on the declaration of a record component, and is automatically\n+     * copied to the accessor method of the same name if one is\n+     * generated during compilation.\n+     *\/\n@@ -86,1 +133,15 @@\n-    \/** Formal parameter declaration *\/\n+    \/**\n+     * The declaration of a formal parameter of a method, constructor,\n+     * or lambda expression, or of an exception parameter.\n+     *\n+     * <p>Any annotation valid for a parameter declaration may also\n+     * appear on the declaration of a record component. Unless the\n+     * canonical constructor's full signature was provided explicitly in\n+     * the source code, this annotation is automatically copied to the\n+     * corresponding parameter declaration of the constructor generated\n+     * during compilation.\n+     *\n+     * <p>Lambda parameter declarations using the <em>concise\n+     * syntax<\/em> cannot be annotated; either a type or the `var`\n+     * keyword must be provided for each.\n+     *\/\n@@ -89,1 +150,3 @@\n-    \/** Constructor declaration *\/\n+    \/**\n+     * The declaration of a constructor.\n+     *\/\n@@ -92,1 +155,8 @@\n-    \/** Local variable declaration *\/\n+    \/**\n+     * The declaration of a local variable. This may be an ordinary\n+     * declaration statement, or declared within the header of a {@code\n+     * for} or {@code try} statement, or within a pattern as a pattern\n+     * variable. However, the similar case of an exception variable\n+     * declared in a {@code catch} clause is considered a {@link\n+     * #PARAMETER} instead.\n+     *\/\n@@ -95,1 +165,7 @@\n-    \/** Annotation interface declaration (Formerly known as an annotation type.) *\/\n+    \/**\n+     * The declaration of an annotation interface (a subcategory of\n+     * {@link #TYPE}). An annotation that itself appears on the\n+     * declaration of an annotation interface is sometimes informally\n+     * called a \"meta-annotation\"; {@link Target} itself is a primary\n+     * example.\n+     *\/\n@@ -98,1 +174,6 @@\n-    \/** Package declaration *\/\n+    \/**\n+     * The declaration of a package in a {@code package-info.java} file.\n+     * Package declarations in other source files cannot be annotated.\n+     *\n+     * @jls 7.4 Package Declarations\n+     *\/\n@@ -102,1 +183,2 @@\n-     * Type parameter declaration\n+     * The declaration of a type parameter within a generic class,\n+     * method, or constructor declaration.\n@@ -109,1 +191,15 @@\n-     * Use of a type\n+     * A code location where a compile-time type is being indicated.\n+     * An annotation in such a location is called a \"type-use\n+     * annotation\" (sometimes called just \"type annotation\", but be\n+     * careful not to confuse this with {@link #TYPE}, which is only\n+     * for <em>class<\/em> declarations).\n+     *\n+     * <p>This is a very broad category: {@jls 4.11} lists seventeen\n+     * kinds of type contexts, followed by five more locations where\n+     * type-use annotations can also legally appear. Six of these\n+     * locations are also annotatable <em>declarations<\/em>\n+     * themselves; see <a href=\"#ambiguous\">ambiguous cases<\/a> above.\n+     *\n+     * <p>In addition, specifying this target automatically includes\n+     * the declaration targets {@link #TYPE} and {@link\n+     * #TYPE_PARAMETER}, though these are not type contexts.\n@@ -116,1 +212,1 @@\n-     * Module declaration.\n+     * The declaration of a module in a {@code module-info.java} file.\n@@ -119,0 +215,1 @@\n+     * @jls 7.7 Module Declarations\n@@ -123,1 +220,9 @@\n-     * Record component\n+     * The declaration of a record component, in the header of a record\n+     * class declaration. If an annotation interface should apply\n+     * conceptually to the field, accessor method, or constructor\n+     * parameter that is generated corresponding to a record component,\n+     * it should specify the appropriate element types ({@link #FIELD},\n+     * {@link #METHOD}, or {@link #PARAMETER}), instead of {@code\n+     * RECORD_COMPONENT} or in addition to it. This allows the\n+     * annotation to be automatically copied to any generated elements\n+     * it applies to.\n@@ -125,2 +230,4 @@\n-     * @jls 8.10.3 Record Members\n-     * @jls 9.7.4 Where Annotations May Appear\n+     * <p>{@link #RECORD_COMPONENT} must be included explicitly in\n+     * {@code @Target} in order for annotations of that type to be\n+     * available via the {@link java.lang.reflect.RecordComponent\n+     * RecordComponent} reflection API.\n@@ -129,0 +236,1 @@\n+     * @jls 8.10.1 Record Components\n","filename":"src\/java.base\/share\/classes\/java\/lang\/annotation\/ElementType.java","additions":159,"deletions":51,"binary":false,"changes":210,"status":"modified"}]}