{"files":[{"patch":"@@ -66,1 +66,3 @@\n-    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path,\n+                                                       cg_infos[MEMORY_IDX]._cgroup_path,\n+                                                       cg_infos[MEMORY_IDX]._read_only);\n@@ -103,1 +105,1 @@\n-        memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n+        memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path, info._read_only);\n@@ -106,1 +108,1 @@\n-        cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -109,1 +111,1 @@\n-        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -112,1 +114,1 @@\n-        cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -115,1 +117,1 @@\n-        pids = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        pids = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -130,1 +132,2 @@\n-                                                  char* root_path) {\n+                                                  char* root_path,\n+                                                  bool read_only) {\n@@ -142,0 +145,1 @@\n+      cg_infos[controller]._read_only = read_only;\n@@ -149,0 +153,1 @@\n+    cg_infos[controller]._read_only = read_only;\n@@ -152,0 +157,56 @@\n+\/*\n+ * Determine whether or not the mount options, which are comma separated,\n+ * contain the 'ro' string.\n+ *\/\n+static bool find_ro_opt(char* mount_opts) {\n+  char* token;\n+  char* mo_ptr = mount_opts;\n+  \/\/ mount options are comma-separated (man proc).\n+  while ((token = strsep(&mo_ptr, \",\")) != NULL) {\n+    if (strcmp(token, \"ro\") == 0) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/*\n+ * Read values of a \/proc\/self\/mountinfo line into variables. For cgroups v1\n+ * super options are needed. On cgroups v2 super options are not used.\n+ *\n+ * The scanning of a single mountinfo line entry is as follows:\n+ *\n+ * 36  35  98:0      \/mnt1 \/mnt2 rw,noatime master:1 - ext3 \/dev\/root rw,errors=continue\n+ * (1) (2) (3):(4)   (5)   (6)      (7)      (8)   (9) (10)   (11)         (12)\n+ *\n+ * The numbers in parentheses are labels for the descriptions below:\n+ *\n+ *  (1)   mount ID:        matched with '%*d' and discarded\n+ *  (2)   parent ID:       matched with '%*d' and discarded\n+ *  (3)   major:           ---,---> major, minor separated by ':'. matched with '%*d:%*d' and discarded\n+ *  (4)   minor:           ---'\n+ *  (5)   root:            matched with '%s' and captured in 'tmproot'. Must be non-empty.\n+ *  (6)   mount point:     matched with '%s' and captured in 'tmpmount'. Must be non-empty.\n+ *  (7)   mount options:   matched with '%s' and captured in 'mount_opts'. Must be non-empty.\n+ *  (8)   optional fields: ---,---> matched with '%*[^-]-'. Anything not a hyphen, followed by a hyphen\n+ *  (9)   separator:       ---'     and discarded. Note: The discarded match is space characters if there\n+ *                                  are no optionals. Otherwise it includes the optional fields as well.\n+ * (10)   filesystem type: matched with '%s' and captured in 'tmp_fs_type'\n+ * (11)   mount source:    matched with '%*s' and discarded\n+ * (12)   super options:   matched with '%s' and captured in 'tmpcgroups'\n+ *\/\n+static inline bool match_mount_info_line(char* line,\n+                                         char* tmproot,\n+                                         char* tmpmount,\n+                                         char* mount_opts,\n+                                         char* tmp_fs_type,\n+                                         char* tmpcgroups) {\n+ return sscanf(line,\n+               \"%*d %*d %*d:%*d %s %s %s%*[^-]- %s %*s %s\",\n+               tmproot,\n+               tmpmount,\n+               mount_opts,\n+               tmp_fs_type,\n+               tmpcgroups) == 5;\n+}\n+\n@@ -321,0 +382,1 @@\n+    char mount_opts[MAXPATHLEN+1];\n@@ -324,4 +386,13 @@\n-    \/\/ Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n-    \/\/ as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n-    \/\/ block in the hybrid case.\n-    if (is_cgroupsV2 && sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s %*s %*s\", tmproot, tmpmount, tmp_fs_type) == 3) {\n+    \/* Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n+     * as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n+     * block in the hybrid case.\n+     *\n+     * We collect the read only mount option in the cgroup infos so as to have that\n+     * info ready when determining is_containerized().\n+     *\/\n+    if (is_cgroupsV2 && match_mount_info_line(p,\n+                                              tmproot,\n+                                              tmpmount,\n+                                              mount_opts,\n+                                              tmp_fs_type,\n+                                              tmpcgroups \/* unused *\/)) {\n@@ -332,0 +403,3 @@\n+        \/\/ For unified we only have a single line with cgroup2 fs type.\n+        \/\/ Therefore use that option for all CG info structs.\n+        bool ro_option = find_ro_opt(mount_opts);\n@@ -333,1 +407,1 @@\n-          set_controller_paths(cg_infos, i, \"(cg2, unified)\", tmpmount, tmproot);\n+          set_controller_paths(cg_infos, i, \"(cg2, unified)\", tmpmount, tmproot, ro_option);\n@@ -340,1 +414,2 @@\n-     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct, pids\n+     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct, pids. For each controller\n+     * determine whether or not they show up as mounted read only or not.\n@@ -349,0 +424,1 @@\n+     *\n@@ -350,1 +426,1 @@\n-    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s %*s %s\", tmproot, tmpmount, tmp_fs_type, tmpcgroups) == 4) {\n+    if (match_mount_info_line(p, tmproot, tmpmount, mount_opts, tmp_fs_type, tmpcgroups)) {\n@@ -358,1 +434,2 @@\n-          set_controller_paths(cg_infos, MEMORY_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, MEMORY_IDX, token, tmpmount, tmproot, ro_option);\n@@ -362,1 +439,2 @@\n-          set_controller_paths(cg_infos, CPUSET_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPUSET_IDX, token, tmpmount, tmproot, ro_option);\n@@ -366,1 +444,2 @@\n-          set_controller_paths(cg_infos, CPU_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPU_IDX, token, tmpmount, tmproot, ro_option);\n@@ -370,1 +449,2 @@\n-          set_controller_paths(cg_infos, CPUACCT_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPUACCT_IDX, token, tmpmount, tmproot, ro_option);\n@@ -374,1 +454,2 @@\n-          set_controller_paths(cg_infos, PIDS_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, PIDS_IDX, token, tmpmount, tmproot, ro_option);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":100,"deletions":19,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+    virtual bool is_read_only() = 0;\n@@ -214,0 +215,1 @@\n+    virtual bool is_containerized() = 0;\n@@ -236,0 +238,1 @@\n+    bool _read_only;            \/\/ whether or not the mount path is mounted read-only\n@@ -246,0 +249,1 @@\n+      _read_only = false;\n@@ -277,1 +281,2 @@\n-                                     char* root_path);\n+                                     char* root_path,\n+                                     bool read_only);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -218,0 +218,11 @@\n+bool CgroupV1Subsystem::is_containerized() {\n+  \/\/ containerized iff all required controllers are mounted\n+  \/\/ read-only. See OSContainer::is_containerized() for\n+  \/\/ the full logic.\n+  \/\/\n+  return _memory->controller()->is_read_only() &&\n+         _cpu->controller()->is_read_only() &&\n+         _cpuacct->is_read_only() &&\n+         _cpuset->is_read_only();\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+    bool _read_only;\n@@ -44,1 +45,1 @@\n-    CgroupV1Controller(char *root, char *mountpoint) {\n+    CgroupV1Controller(char *root, char *mountpoint, bool ro) {\n@@ -48,0 +49,1 @@\n+      _read_only = ro;\n@@ -52,0 +54,1 @@\n+    bool is_read_only() { return _read_only; }\n@@ -68,1 +71,1 @@\n-    CgroupV1MemoryController(char *root, char *mountpoint) : CgroupV1Controller(root, mountpoint) {\n+    CgroupV1MemoryController(char *root, char *mountpoint, bool ro) : CgroupV1Controller(root, mountpoint, ro) {\n@@ -100,0 +103,1 @@\n+    bool is_containerized();\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -97,0 +97,4 @@\n+bool CgroupV2Subsystem::is_containerized() {\n+  return _unified->is_read_only();\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+    bool _read_only;\n@@ -42,1 +43,1 @@\n-    CgroupV2Controller(char * mount_path, char *cgroup_path) {\n+    CgroupV2Controller(char * mount_path, char *cgroup_path, bool ro) {\n@@ -46,0 +47,1 @@\n+      _read_only = ro;\n@@ -49,0 +51,1 @@\n+    bool is_read_only() { return _read_only; }\n@@ -86,0 +89,1 @@\n+    bool is_containerized();\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,2 +61,37 @@\n-\n-  _is_containerized = true;\n+  \/*\n+   * In order to avoid a false positive on is_containerized() on\n+   * Linux systems outside a container *and* to ensure compatibility\n+   * with in-container usage, we detemine is_containerized() by two\n+   * steps:\n+   * 1.) Determine if all the cgroup controllers are mounted read only.\n+   *     If yes, is_containerized() == true. Otherwise, do the fallback\n+   *     in 2.)\n+   * 2.) Query for memory and cpu limits. If any limit is set, we set\n+   *     is_containerized() == true.\n+   *\n+   * Step 1.) covers the basic in container use-cases. Step 2.) ensures\n+   * that limits enforced by other means (e.g. systemd slice) are properly\n+   * detected.\n+   *\/\n+  const char *reason;\n+  bool any_mem_cpu_limit_present = false;\n+  bool controllers_read_only = cgroup_subsystem->is_containerized();\n+  if (controllers_read_only) {\n+    \/\/ in-container case\n+    reason = \" because all controllers are mounted read-only (container case)\";\n+  } else {\n+    \/\/ We can be in one of two cases:\n+    \/\/  1.) On a physical Linux system without any limit\n+    \/\/  2.) On a physical Linux system with a limit enforced by other means (like systemd slice)\n+    any_mem_cpu_limit_present = cgroup_subsystem->memory_limit_in_bytes() > 0 ||\n+                                     os::Linux::active_processor_count() != cgroup_subsystem->active_processor_count();\n+    if (any_mem_cpu_limit_present) {\n+      reason = \" because either a cpu or a memory limit is present\";\n+    } else {\n+      reason = \" because no cpu or memory limit is present\";\n+    }\n+  }\n+  _is_containerized = controllers_read_only || any_mem_cpu_limit_present;\n+  log_debug(os, container)(\"OSContainer::init: is_containerized() = %s%s\",\n+                                                            _is_containerized ? \"true\" : \"false\",\n+                                                            reason);\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -153,0 +153,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsContainerized(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -116,0 +116,3 @@\n+#ifdef LINUX\n+#include \"osContainer_linux.hpp\"\n+#endif\n@@ -499,0 +502,9 @@\n+JVM_LEAF(jboolean, JVM_IsContainerized(void))\n+#ifdef LINUX\n+  if (OSContainer::is_containerized()) {\n+    return JNI_TRUE;\n+  }\n+#endif\n+  return JNI_FALSE;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+    @Override\n+    public boolean isContainerized() {\n+        return isContainerized0();\n+    }\n+\n@@ -197,0 +202,1 @@\n+    private static native boolean isContainerized0();\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,5 @@\n+\n+    default boolean isContainerized() {\n+        return false; \/\/ This default impl is never used\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,6 @@\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_platform_CgroupMetrics_isContainerized0(JNIEnv *env, jclass ignored)\n+{\n+    return JVM_IsContainerized();\n+}\n+\n","filename":"src\/java.base\/linux\/native\/libjava\/CgroupMetrics.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,0 +74,17 @@\n+    \/**\n+     * Determines whether or not the underlying system\n+     * has useful metrics (a.k.a. is containerized).\n+     *\n+     * @implNote\n+     * Note that Metrics on some systems aren't useful.\n+     * For example on a regular Linux system with cgroups\n+     * present, with no limits enforced and not running in\n+     * a container, Metric aren't useful. This can be used\n+     * in order to determine if the system is containerized.\n+     *\n+     * @return true when the JVM runs in containerized mode.\n+     *         false otherwise.\n+     *\n+     *\/\n+    public boolean isContainerized();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/platform\/Metrics.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -373,0 +373,4 @@\n+        if (!c.isContainerized()) {\n+            ostream.println(INDENT + \"System not containerized.\");\n+            return;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+  bool is_read_only() override {\n+    return true; \/\/ doesn't matter\n+  }\n@@ -439,1 +442,2 @@\n-                                                       (char*)testCases[i]->mount_path);\n+                                                       (char*)testCases[i]->mount_path,\n+                                                       true \/* read-only mount *\/);\n@@ -463,1 +467,2 @@\n-                                                       (char*)testCases[i]->cgroup_path);\n+                                                       (char*)testCases[i]->cgroup_path,\n+                                                       true \/* read-only mount *\/);\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -115,1 +115,0 @@\n-containers\/cgroup\/PlainRead.java 8333967,8261242 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test PlainRead\n- * @key cgroups\n- * @requires os.family == \"linux\"\n- * @requires vm.flagless\n- * @library \/testlibrary \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI PlainRead\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.Platform;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class PlainRead {\n-\n-    static public void match(OutputAnalyzer oa, String what, String value) {\n-       oa.shouldMatch(\"^.*\" + what + \" *\" + value + \".*$\");\n-    }\n-\n-    static public void noMatch(OutputAnalyzer oa, String what, String value) {\n-       oa.shouldNotMatch(\"^.*\" + what + \" *\" + value + \".*$\");\n-    }\n-\n-    static final String good_value = \"(\\\\d+|-1|-2|Unlimited)\";\n-    static final String bad_value = \"(failed)\";\n-\n-    static final String[] variables = {\"Memory Limit is:\", \"CPU Quota is:\", \"CPU Period is:\", \"active_processor_count:\"};\n-\n-    static public void isContainer(OutputAnalyzer oa) {\n-        for (String v: variables) {\n-            match(oa, v, good_value);\n-        }\n-        for (String v: variables) {\n-            noMatch(oa, v, bad_value);\n-        }\n-    }\n-\n-    static public void isNotContainer(OutputAnalyzer oa) {\n-       oa.shouldMatch(\"^.*Can't open \/proc\/self\/mountinfo.*$\");\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:os+container=trace\", \"-version\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-\n-        if (wb.isContainerized()) {\n-            System.out.println(\"Inside a cgroup, testing...\");\n-            isContainer(output);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/PlainRead.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8261242\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @requires vm.flagless\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestContainerized\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestContainerized {\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        if (wb.isContainerized()) {\n+            throw new RuntimeException(\"Test failed! Expected not containerized on plain Linux.\");\n+        }\n+        System.out.println(\"Plain linux, no limits. Passed!\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/TestContainerized.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @build TestSystemSettings\n+ * @run main\/othervm TestSystemSettings\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestSystemSettings {\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XshowSettings:system\", \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContain(\"System not containerized.\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestSystemSettings.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -72,0 +72,10 @@\n+        testContainerized(m, inContainer);\n+    }\n+\n+    private void testContainerized(Metrics m, boolean inContainer) {\n+        if (m.isContainerized() != inContainer) {\n+            throw new RuntimeException(\"containerized test failed. \" +\n+                                       \"Expected isContainerized()==\" + inContainer +\n+                                       \" but got '\" + m.isContainerized() + \"'\");\n+        }\n+        System.out.println(\"testContainerized() PASSED!\");\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTester.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}