{"files":[{"patch":"@@ -68,1 +68,1 @@\n-                                                       cg_infos[MEMORY_IDX]._is_ro);\n+                                                       cg_infos[MEMORY_IDX]._read_only);\n@@ -105,1 +105,1 @@\n-        memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path, info._is_ro);\n+        memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path, info._read_only);\n@@ -108,1 +108,1 @@\n-        cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._is_ro);\n+        cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -111,1 +111,1 @@\n-        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._is_ro);\n+        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -114,1 +114,1 @@\n-        cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._is_ro);\n+        cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -117,1 +117,1 @@\n-        pids = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._is_ro);\n+        pids = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -133,1 +133,1 @@\n-                                                  bool is_read_only) {\n+                                                  bool read_only) {\n@@ -145,1 +145,1 @@\n-      cg_infos[controller]._is_ro = is_read_only;\n+      cg_infos[controller]._read_only = read_only;\n@@ -153,1 +153,1 @@\n-    cg_infos[controller]._is_ro = is_read_only;\n+    cg_infos[controller]._read_only = read_only;\n@@ -346,6 +346,28 @@\n-    \/\/ Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n-    \/\/ as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n-    \/\/ block in the hybrid case.\n-    \/\/\n-    \/\/ We collect the read only mount option in the cgroup infos so as to have that\n-    \/\/ info ready when determining is_containerized().\n+    \/* Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n+     * as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n+     * block in the hybrid case.\n+     *\n+     * We collect the read only mount option in the cgroup infos so as to have that\n+     * info ready when determining is_containerized().\n+     *\n+     * The scanning of a single mountinfo line entry is as follows:\n+     *\n+     * 36  35  98:0      \/mnt1 \/mnt2 rw,noatime master:1 - ext3 \/dev\/root rw,errors=continue\n+     * (1) (2) (3):(4)   (5)   (6)      (7)      (8)   (9) (10)   (11)         (12)\n+     *\n+     * The numbers in parentheses are labels for the descriptions below:\n+     *\n+     *  (1)   mount ID:        matched with '%*d' and discarded\n+     *  (2)   parent ID:       matched with '%*d' and discarded\n+     *  (3)   major:           ---,---> major, minor separated by ':'. matched with '%*d:%*d' and discarded\n+     *  (4)   minor:           ---'\n+     *  (5)   root:            matched with '%s' and captured in 'tmproot'. Must be non-empty.\n+     *  (6)   mount point:     matched with '%s' and captured in 'tmpmount'. Must be non-empty.\n+     *  (7)   mount options:   matched with '%s' and captured in 'mount_opts'. Must be non-empty.\n+     *  (8)   optional fields: ---,---> matched with '%*[^-]-'. Anything not a hyphen, followed by a hyphen\n+     *  (9)   separator:       ---'     and discarded. Note: The discarded match is space characters if there\n+     *                                  are no optionals. Otherwise it includes the optional fields as well.\n+     * (10)   filesystem type: matched with '%s' and captured in 'tmp_fs_type'\n+     * (11)   mount source:    matched with '%*s' and discarded\n+     * (12)   super options:   matched with '%*s' and discarded\n+     *\/\n@@ -359,1 +381,1 @@\n-        bool ro_opt = find_ro_opt(mount_opts);\n+        bool ro_option = find_ro_opt(mount_opts);\n@@ -361,1 +383,1 @@\n-          set_controller_paths(cg_infos, i, \"(cg2, unified)\", tmpmount, tmproot, ro_opt);\n+          set_controller_paths(cg_infos, i, \"(cg2, unified)\", tmpmount, tmproot, ro_option);\n@@ -378,0 +400,21 @@\n+     *\n+     * The scanning of a single mountinfo line entry is as follows:\n+     *\n+     * 36  35  98:0      \/mnt1 \/mnt2 rw,noatime master:1 - ext3 \/dev\/root rw,errors=continue\n+     * (1) (2) (3):(4)   (5)   (6)      (7)      (8)   (9) (10)   (11)         (12)\n+     *\n+     * The numbers in parentheses are labels for the descriptions below:\n+     *\n+     *  (1)   mount ID:        matched with '%*d' and discarded\n+     *  (2)   parent ID:       matched with '%*d' and discarded\n+     *  (3)   major:           ---,---> major, minor separated by ':'. matched with '%*d:%*d' and discarded\n+     *  (4)   minor:           ---'\n+     *  (5)   root:            matched with '%s' and captured in 'tmproot'. Must be non-empty.\n+     *  (6)   mount point:     matched with '%s' and captured in 'tmpmount'. Must be non-empty.\n+     *  (7)   mount options:   matched with '%s' and captured in 'mount_opts'. Must be non-empty.\n+     *  (8)   optional fields: ---,---> matched with '%*[^-]-'. Anything not a hyphen, followed by a hyphen\n+     *  (9)   separator:       ---'     and discarded. Note: The discarded match is space characters if there\n+     *                                  are no optionals. Otherwise it includes the optional fields as well.\n+     * (10)   filesystem type: matched with '%s' and captured in 'tmp_fs_type'\n+     * (11)   mount source:    matched with '%*s' and discarded\n+     * (12)   super options:   matched with '%s' and captured in 'tmpcgroups'\n@@ -387,2 +430,2 @@\n-          bool ro_opt = find_ro_opt(mount_opts);\n-          set_controller_paths(cg_infos, MEMORY_IDX, token, tmpmount, tmproot, ro_opt);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, MEMORY_IDX, token, tmpmount, tmproot, ro_option);\n@@ -392,2 +435,2 @@\n-          bool ro_opt = find_ro_opt(mount_opts);\n-          set_controller_paths(cg_infos, CPUSET_IDX, token, tmpmount, tmproot, ro_opt);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPUSET_IDX, token, tmpmount, tmproot, ro_option);\n@@ -397,2 +440,2 @@\n-          bool ro_opt = find_ro_opt(mount_opts);\n-          set_controller_paths(cg_infos, CPU_IDX, token, tmpmount, tmproot, ro_opt);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPU_IDX, token, tmpmount, tmproot, ro_option);\n@@ -402,2 +445,2 @@\n-          bool ro_opt = find_ro_opt(mount_opts);\n-          set_controller_paths(cg_infos, CPUACCT_IDX, token, tmpmount, tmproot, ro_opt);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPUACCT_IDX, token, tmpmount, tmproot, ro_option);\n@@ -407,2 +450,2 @@\n-          bool ro_opt = find_ro_opt(mount_opts);\n-          set_controller_paths(cg_infos, PIDS_IDX, token, tmpmount, tmproot, ro_opt);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, PIDS_IDX, token, tmpmount, tmproot, ro_option);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":70,"deletions":27,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-    bool _is_ro;            \/\/ whether or not the mount path is mounted read-only\n+    bool _read_only;            \/\/ whether or not the mount path is mounted read-only\n@@ -307,1 +307,1 @@\n-      _is_ro = false;\n+      _read_only = false;\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,2 +78,2 @@\n-  bool ctrl_ro = cgroup_subsystem->is_containerized();\n-  if (ctrl_ro) {\n+  bool controllers_read_only = cgroup_subsystem->is_containerized();\n+  if (controllers_read_only) {\n@@ -94,1 +94,1 @@\n-  _is_containerized = ctrl_ro || any_mem_cpu_limit_present;\n+  _is_containerized = controllers_read_only || any_mem_cpu_limit_present;\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}