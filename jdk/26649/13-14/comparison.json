{"files":[{"patch":"@@ -180,3 +180,2 @@\n-     * Close all writer and reader streams and terminate the process.\n-     * The streams are closed immediately and the process is terminated without waiting.\n-     * This method is idempotent, if the process has already been closed\n+     * Close all writer and reader streams immediately and wait for the process to terminate.\n+     * This method is idempotent, if this {@code Process} has already been closed\n@@ -185,2 +184,3 @@\n-     * If the data from the process streams is needed, it must be read before calling this method.\n-     * The contents of streams that have not been read fully are lost, they are discarded or ignored.\n+     * If the data from the process input or error streams is needed, it must be read before\n+     * calling this method. The contents of streams that have not been read to end of stream\n+     * are lost, they are discarded or ignored.\n@@ -188,5 +188,2 @@\n-     * If the process should be allowed to run to completion or the exit value of the process\n-     * is of interest, then the caller must {@linkplain #waitFor() wait} for the process\n-     * to complete before calling this method.\n-     * Calling {@link #waitFor() waitFor} before calling {@code close} or exiting\n-     * the try-with-resources block allows the process time to clean up and exit normally.\n+     * If the process exit value of the process is of interest, then the caller must\n+     * {@linkplain #waitFor() wait} for the process to terminate before calling this method.\n@@ -196,2 +193,2 @@\n-     * If an {@code IOException} occurs when closing a stream it is\n-     * re-thrown after the process is terminated. Additional {@code IOExceptions}\n+     * If an {@code IOException} occurs when closing a stream it is thrown\n+     * when this method returns. Additional {@code IOExceptions}\n@@ -201,9 +198,5 @@\n-     * The process may already have terminated or be in the process of terminating;\n-     * if it is {@linkplain #isAlive() alive}, it is {@linkplain #destroy destroyed}.\n-     * On some platforms, {@linkplain #supportsNormalTermination() normal termination}\n-     * is not available and the process is forcibly terminated.\n-     * Calling {@linkplain #waitFor() waitFor} after\n-     * {@linkplain #close() close} or after the try-with-resources block exits\n-     * can verify that the process has been terminated.\n-     * The status returned may be from normal termination or the result of\n-     * {@link #destroy() destroying the process}.\n+     * After the streams are closed this method {@linkplain #waitFor() waits for} the\n+     * process to terminate. If interrupted while {@linkplain #waitFor waiting for termination}\n+     * the process is {@linkplain #destroyForcibly() forcibly destroyed}.\n+     * The interrupt status will be re-asserted before this method returns and\n+     * any {@code IOExceptions} are thrown.\n@@ -235,1 +228,9 @@\n-            destroy();      \/\/ no-op if process is not alive\n+            try {\n+                \/\/ Wait for process to terminate normally.\n+                waitFor();\n+            } catch (InterruptedException e) {\n+                \/\/ Waiting interrupted; forcibly destroy the process\n+                destroyForcibly();\n+                \/\/ Re-assert the interrupt\n+                Thread.currentThread().interrupt();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":23,"deletions":22,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import java.time.Duration;\n+import java.time.Instant;\n@@ -49,0 +51,2 @@\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.TimeUnit;\n@@ -64,0 +68,12 @@\n+    private static final boolean DEBUG = Boolean.getBoolean(\"DEBUG\");\n+    private final static ScopedValue<Appendable> OUT = ScopedValue.newInstance();\n+    private final static ScopedValue.Carrier LOG = setupLog();\n+\n+    private static ScopedValue.Carrier setupLog() {\n+        if (DEBUG) {\n+            return ScopedValue.where(OUT, System.err);\n+        } else {\n+            return ScopedValue.where(OUT, new StringBuffer());\n+        }\n+    }\n+\n@@ -86,0 +102,9 @@\n+    private static void logPrintf(String format, Object... args) {\n+        try {\n+            var log = LOG.get(OUT);\n+            log.append(format.formatted(args));\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n@@ -92,1 +117,1 @@\n-     * - A expected final ExitStatus\n+     * - A List of commands to be invoked on the process after the close or T-W-R exit.\n@@ -99,2 +124,2 @@\n-                                ProcessCommand.PROCESS_EXPECT_EXIT_NORMAL),\n-                        ExitStatus.NORMAL),\n+                                ExitStatus.NORMAL),\n+                        List.of(ExitStatus.NORMAL)),\n@@ -103,1 +128,1 @@\n-                        ExitStatus.RACY),\n+                        List.of(ExitStatus.RACY)),\n@@ -108,1 +133,1 @@\n-                        ExitStatus.RACY),\n+                        List.of(ExitStatus.RACY)),\n@@ -113,1 +138,1 @@\n-                        ExitStatus.RACY),\n+                        List.of(ExitStatus.RACY)),\n@@ -117,2 +142,2 @@\n-                                ProcessCommand.PROCESS_EXPECT_EXIT_NORMAL),\n-                        ExitStatus.NORMAL),\n+                                ExitStatus.NORMAL),\n+                        List.of(ExitStatus.NORMAL)),\n@@ -122,1 +147,1 @@\n-                        ExitStatus.RACY),\n+                        List.of(ExitStatus.RACY)),\n@@ -126,1 +151,1 @@\n-                        ExitStatus.RACY),\n+                        List.of(ExitStatus.RACY)),\n@@ -130,1 +155,1 @@\n-                        ExitStatus.NORMAL),\n+                        List.of(ExitStatus.NORMAL)),\n@@ -132,2 +157,13 @@\n-                        List.of(ProcessCommand.PROCESS_EXPECT_EXIT_FAIL),\n-                        ExitStatus.FAIL),       \/\/ Got expected status == 1\n+                        List.of(ExitStatus.FAIL),\n+                        List.of(ExitStatus.FAIL)),       \/\/ Got expected status == 1\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_INTERRUPT, \/\/ schedule an interrupt (in 1sec)\n+                                ProcessCommand.PROCESS_CLOSE,\n+                                ProcessCommand.PROCESS_CHECK_INTERRUPT), \/\/ Verify re-interrupted\n+                        List.of(ExitStatus.KILLED)), \/\/ And process was destroyed\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_INTERRUPT), \/\/ Should interrupt the TWR close\n+                        List.of(ProcessCommand.PROCESS_CHECK_INTERRUPT, ExitStatus.KILLED)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ExitStatus.NORMAL), \/\/ waitFor before T-W-R exit\n+                        List.of(ExitStatus.NORMAL)),\n@@ -136,1 +172,1 @@\n-                        ExitStatus.RACY), \/\/ Racy, not deterministic\n+                        List.of(ExitStatus.RACY)), \/\/ Racy, not deterministic\n@@ -140,1 +176,1 @@\n-                        ExitStatus.RACY),  \/\/ Racy, not deterministic\n+                        List.of(ExitStatus.RACY)),  \/\/ Racy, not deterministic\n@@ -143,1 +179,1 @@\n-                        ExitStatus.RACY), \/\/ Racy, not deterministic\n+                        List.of(ExitStatus.RACY)), \/\/ Racy, not deterministic\n@@ -147,1 +183,1 @@\n-                        ExitStatus.RACY), \/\/ Racy, not deterministic\n+                        List.of(ExitStatus.RACY)), \/\/ Racy, not deterministic\n@@ -149,2 +185,2 @@\n-                        List.of(ProcessCommand.PROCESS_EXPECT_EXIT_NORMAL),\n-                        ExitStatus.RACY)\n+                        List.of(ExitStatus.NORMAL),\n+                        List.of(ExitStatus.RACY))\n@@ -154,7 +190,2 @@\n-\n-    @ParameterizedTest\n-    @MethodSource(\"singleThreadTestCases\")\n-    void simple(List<String> args, List<ProcessCommand> commands, ExitStatus exitStatus) throws IOException {\n-        ProcessBuilder pb = new ProcessBuilder(args);\n-        Process p = pb.start();\n-        System.err.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+    \/\/ Utility to process each command on the process\n+    private static void doCommands(Process proc, List<Consumer<Process>> commands) {\n@@ -162,2 +193,2 @@\n-            System.err.printf(\"    %s\\n\", c);\n-            c.command.accept(p);\n+            logPrintf(\"    %s\\n\", c);\n+            c.accept(proc);\n@@ -165,2 +196,0 @@\n-        p.close();\n-        ProcessCommand.processExpectExit(p, exitStatus);\n@@ -171,12 +200,13 @@\n-    void autoCloseable(List<String> args, List<ProcessCommand> commands, ExitStatus exitStatus) {\n-        ProcessBuilder pb = new ProcessBuilder(args);\n-        Process proc = null;\n-        try (Process p = pb.start()) {\n-            proc = p;\n-            System.err.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n-            commands.forEach(c -> {\n-                System.err.printf(\"    %s\\n\", c);\n-                c.command.accept(p);\n-            });\n-        } catch (IOException ioe) {\n-            Assertions.fail(ioe);\n+    void simple(List<String> args, List<Consumer<Process>> commands,\n+                List<Consumer<Process>> postCommands) throws IOException {\n+        var log = LOG.get(OUT);\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process p = pb.start(); \/\/ Buffer any debug output\n+            logPrintf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+            doCommands(p, commands);\n+            p.close();\n+            doCommands(p, postCommands);\n+        } catch (Exception ex) {\n+            System.err.print(log);\n+            throw ex;\n@@ -184,1 +214,0 @@\n-        ProcessCommand.processExpectExit(proc, exitStatus);\n@@ -187,0 +216,21 @@\n+    @ParameterizedTest\n+    @MethodSource(\"singleThreadTestCases\")\n+    void autoCloseable(List<String> args, List<Consumer<Process>> commands,\n+                       List<Consumer<Process>> postCommands) {\n+        var log = LOG.get(OUT);\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process proc = null;\n+            try (Process p = pb.start()) {\n+                proc = p;\n+                logPrintf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+                doCommands(p, commands);\n+            } catch (IOException ioe) {\n+                Assertions.fail(ioe);\n+            }\n+            doCommands(proc, postCommands);\n+        } catch (Exception ex) {\n+            System.err.println(log);\n+            throw ex;\n+        }\n+    }\n@@ -192,1 +242,1 @@\n-     * @param exitStatus The expected final exit status\n+     * @param postCommands The expected final exit status\n@@ -196,14 +246,19 @@\n-    void autoCloseableAll(List<String> args, List<ProcessCommand> commands, ExitStatus exitStatus) {\n-        ProcessBuilder pb = new ProcessBuilder(args);\n-        Process proc = null;\n-        try (Process p = pb.start(); var out = p.getOutputStream();\n-             var in = p.getInputStream();\n-             var err = p.getErrorStream()) {\n-            proc = p;\n-            System.err.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n-            commands.forEach(c -> {\n-                System.err.printf(\"    %s\\n\", c);\n-                c.command.accept(p);\n-            });\n-        } catch (IOException ioe) {\n-            Assertions.fail(ioe);\n+    void autoCloseableAll(List<String> args, List<Consumer<Process>> commands,\n+                          List<Consumer<Process>> postCommands) {\n+        var log = LOG.get(OUT);\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process proc = null;\n+            try (Process p = pb.start(); var out = p.getOutputStream();\n+                 var in = p.getInputStream();\n+                 var err = p.getErrorStream()) {\n+                proc = p;\n+                logPrintf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+                doCommands(p, commands);\n+            } catch (IOException ioe) {\n+                Assertions.fail(ioe);\n+            }\n+            doCommands(proc, postCommands);\n+        }  catch (Exception ex) {\n+            System.err.println(log);\n+            throw ex;\n@@ -211,1 +266,0 @@\n-        ProcessCommand.processExpectExit(proc, exitStatus);\n@@ -215,2 +269,2 @@\n-        \/\/ ExitStatus named values and assertions\n-    enum ExitStatus {\n+    \/\/ ExitStatus named values and assertions\n+    enum ExitStatus implements Consumer<Process> {\n@@ -218,4 +272,5 @@\n-        FAIL(1),\n-        PIPE(1, 141),\n-        KILLED(0, 143),\n-        RACY(0, 1, 143),\n+            FAIL(1),\n+            PIPE(1, 141),   \/\/ SIGPIPE\n+            KILLED(1, 137), \/\/ SIGKILL\n+            TERMINATED(0, 143), \/\/ SIGTERM\n+            RACY(0, 1, 137, 143),\n@@ -229,0 +284,13 @@\n+        \/\/ If used as a process command, checks the exit status\n+        public void accept(Process p) {\n+            try {\n+                Instant begin = Instant.now();\n+                final int exitStatus = p.waitFor();\n+                Duration latency = begin.until(Instant.now());\n+                logPrintf(\"    ExitStatus: %d, waitFor latency: %s%n\", exitStatus, latency);\n+                assertEquals(exitStatus);\n+            } catch (InterruptedException ie) {\n+                Assertions.fail(\"Unexpected InterruptedException checking status: \" + this);\n+            }\n+        }\n+\n@@ -238,1 +306,1 @@\n-                System.err.printf(\"Racy exit status: %d\\n\", actual);\n+                logPrintf(\"Racy exit status: %d\\n\", actual);\n@@ -248,3 +316,1 @@\n-    enum ProcessCommand {\n-        PROCESS_EXPECT_EXIT_NORMAL(ProcessCommand::processExpectExitNormal),\n-        PROCESS_EXPECT_EXIT_FAIL(ProcessCommand::processExpectExitFail),\n+    enum ProcessCommand implements Consumer<Process> {\n@@ -266,0 +332,2 @@\n+        PROCESS_INTERRUPT(ProcessCommand::processInterruptThread),\n+        PROCESS_CHECK_INTERRUPT(ProcessCommand::processAssertInterrupted),\n@@ -273,0 +341,4 @@\n+        public void accept(Process p) {\n+            command.accept(p);\n+        }\n+\n@@ -277,2 +349,2 @@\n-                System.err.printf(\"        %d lines\\n\", lines.size());\n-                System.err.println(lines.toString().indent(8));\n+                logPrintf(\"        %d lines\\n\", lines.size());\n+                logPrintf(\"%s%n\", lines.toString().indent(8));\n@@ -288,2 +360,2 @@\n-                System.err.printf(\"        %d lines\\n\", lines.size());\n-                System.err.println(lines.toString().indent(8));\n+                logPrintf(\"        %d lines\\n\", lines.size());\n+                logPrintf(\"%s%n\", lines.toString().indent(8));\n@@ -369,20 +441,0 @@\n-        \/\/ Expect a normal exit\n-        private static void processExpectExitNormal(Process p) {\n-            processExpectExit(p, ExitStatus.NORMAL);\n-        }\n-\n-        \/\/ expect an error (1) status\n-        private static void processExpectExitFail(Process p) {\n-            processExpectExit(p, ExitStatus.FAIL);\n-        }\n-\n-        \/\/ Process.processExpectExit an expected status\n-        private static void processExpectExit(Process p, ExitStatus expected) {\n-            try {\n-                int st = p.waitFor();\n-                expected.assertEquals(st);\n-            } catch (InterruptedException ie) {\n-                Assertions.fail(\"Unexpected InterruptedException\");\n-            }\n-        }\n-\n@@ -415,0 +467,12 @@\n+\n+        \/\/ Hard coded to interrupt the invoking thread after 1 second\n+        private static void processInterruptThread(Process p) {\n+            final Thread targetThread = Thread.currentThread();\n+            ForkJoinPool common = ForkJoinPool.commonPool();\n+            common.schedule(targetThread::interrupt, 500, TimeUnit.MILLISECONDS);\n+        }\n+\n+        \/\/ Verify that an interrupt is pending and reset it\n+        private static void processAssertInterrupted(Process p) {\n+            Assertions.assertTrue(Thread.interrupted(), \"Expected an interrupt\");\n+        }\n@@ -421,1 +485,1 @@\n-        SLEEP5(ChildCommand::sleep5),\n+        SLEEP(ChildCommand::SLEEP),\n@@ -431,1 +495,3 @@\n-        private static void sleep5() {\n+        \/\/ The child sleeps before continuing with next ChildCommand\n+        private static void SLEEP() {\n+            final int sleepMS = 2_000;\n@@ -433,1 +499,1 @@\n-                Thread.sleep(5_000);\n+                Thread.sleep(sleepMS);\n@@ -436,0 +502,1 @@\n+                System.err.println(\"Sleep interrupted\");  \/\/ Note the interruption in the log\n@@ -473,1 +540,1 @@\n-                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n@@ -475,2 +542,2 @@\n-                        ExitStatus.RACY, List.of(badFDMsg)),\n-                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n@@ -478,2 +545,2 @@\n-                        ExitStatus.RACY, List.of(badFDMsg)),\n-                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n@@ -481,2 +548,2 @@\n-                        ExitStatus.RACY, List.of(badFDMsg)),\n-                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n@@ -486,2 +553,2 @@\n-                        ExitStatus.RACY, List.of(badFDMsg, badFDMsg, badFDMsg)),\n-                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg, badFDMsg, badFDMsg)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n@@ -490,2 +557,2 @@\n-                        ExitStatus.RACY, List.of(badFDMsg, badFDMsg)),\n-                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg, badFDMsg)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n@@ -494,2 +561,2 @@\n-                        ExitStatus.RACY, List.of(badFDMsg, badFDMsg)),\n-                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg, badFDMsg)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n@@ -498,1 +565,1 @@\n-                        ExitStatus.RACY, List.of(badFDMsg, badFDMsg)),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg, badFDMsg)),\n@@ -501,1 +568,1 @@\n-                        ExitStatus.RACY, List.of(badFDMsg))\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg))\n@@ -510,1 +577,1 @@\n-     * @param exitStatus The expected final exit status\n+     * @param postCommands The expected final exit status\n@@ -515,27 +582,27 @@\n-    void testStreamsCloseThrowing(List<String> args, List<ProcessCommand> commands,\n-                                  ExitStatus exitStatus, List<String> expectedMessages) {\n-        ProcessBuilder pb = new ProcessBuilder(args);\n-        Process proc = null;\n-        IOException expectedIOE = null;\n-        try (Process p = pb.start()) {\n-            proc = p;\n-            System.err.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n-            commands.forEach(c -> {\n-                System.err.printf(\"    %s\\n\", c);\n-                c.command.accept(p);\n-            });\n-        } catch (IOException ioe) {\n-            expectedIOE = ioe;\n-        }\n-        \/\/ Check the exceptions thrown, if any\n-        if (expectedIOE != null) {\n-            \/\/ Check each exception that it is expected\n-            Assertions.assertEquals(expectedMessages.getFirst(), expectedIOE.getMessage(),\n-                    \"Unexpected exception message\");\n-            var suppressedEx = expectedIOE.getSuppressed();\n-            Assertions.assertEquals(expectedMessages.size() - 1, suppressedEx.length,\n-                    \"Number of suppressed exceptions\");\n-            for (int i = 1; i < expectedMessages.size(); i++) {\n-                Assertions.assertEquals(expectedMessages.get(i),\n-                        suppressedEx[i - 1].getMessage(),\n-                        \"Unexpected suppressed exception message\");\n+    void testStreamsCloseThrowing(List<String> args, List<Consumer<Process>> commands,\n+                                  List<Consumer<Process>> postCommands, List<String> expectedMessages) {\n+        var log = LOG.get(OUT);\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process proc = null;\n+            IOException expectedIOE = null;\n+            try (Process p = pb.start()) {\n+                proc = p;\n+                logPrintf(\"Program: %s; pid: %d\\n\",args, p.pid());\n+                doCommands(p, commands);\n+            } catch (IOException ioe) {\n+                expectedIOE = ioe;\n+            }\n+            \/\/ Check the exceptions thrown, if any\n+            if (expectedIOE != null) {\n+                \/\/ Check each exception that it is expected\n+                Assertions.assertEquals(expectedMessages.getFirst(), expectedIOE.getMessage(),\n+                        \"Unexpected exception message\");\n+                var suppressedEx = expectedIOE.getSuppressed();\n+                Assertions.assertEquals(expectedMessages.size() - 1, suppressedEx.length,\n+                        \"Number of suppressed exceptions\");\n+                for (int i = 1; i < expectedMessages.size(); i++) {\n+                    Assertions.assertEquals(expectedMessages.get(i),\n+                            suppressedEx[i - 1].getMessage(),\n+                            \"Unexpected suppressed exception message\");\n+                }\n@@ -543,0 +610,5 @@\n+            Assertions.assertNotNull(proc, \"Process is null\");\n+            doCommands(proc, postCommands);\n+        }  catch (Exception ex) {\n+            System.err.println(log);\n+            throw ex;\n@@ -544,2 +616,0 @@\n-        Assertions.assertNotNull(proc, \"Process is null\");\n-        ProcessCommand.processExpectExit(proc, exitStatus);\n@@ -611,1 +681,1 @@\n-            System.err.printf(\"FileDescriptor.handle: %08x%n\", handle);\n+            logPrintf(\"FileDescriptor.handle: %08x%n\", handle);\n@@ -616,1 +686,1 @@\n-            System.err.printf(\"FileDescriptor.handle to close again and fail: %08x%n\", handle);\n+            logPrintf(\"FileDescriptor.handle to close again and fail: %08x%n\", handle);\n@@ -622,1 +692,1 @@\n-            System.err.printf(\"FileDescriptor.fd: %08x%n\", fd);\n+            logPrintf(\"FileDescriptor.fd: %08x%n\", fd);\n@@ -627,1 +697,1 @@\n-            System.err.printf(\"FileDescriptor.fd to close again and fail: %08x%n\", fd);\n+            logPrintf(\"FileDescriptor.fd to close again and fail: %08x%n\", fd);\n","filename":"test\/jdk\/java\/lang\/Process\/ProcessCloseTest.java","additions":215,"deletions":145,"binary":false,"changes":360,"status":"modified"}]}