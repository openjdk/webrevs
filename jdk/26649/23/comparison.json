{"files":[{"patch":"@@ -88,1 +88,18 @@\n- * <p>Subclasses of Process should override the {@link #onExit()} and\n+ * <p>Subclasses of Process should ensure that each overridden method\n+ * invokes the superclass method.\n+ * For example, if {@linkplain #close() close} is overridden, the subclass should\n+ * ensure that {@code Process.close()} is called.\n+ * {@snippet lang = \"java\" :\n+ * public class LoggingProcess extends java.lang.Process {\n+ *     ...\n+ *     @Override\n+ *     public void close() throws IOException  {\n+ *         super.close();\n+ *         LOGGER.log(\"process closed\");\n+ *     }\n+ *     ...\n+ * }\n+ * }\n+ *\n+ * <p>Subclasses of Process that wrap another Process instance\n+ * should override and delegate the {@link #onExit()} and\n@@ -102,1 +119,4 @@\n- * or readers, or they have been closed.\n+ * or readers, or they have been closed. The Process {@linkplain Process#close close} method closes\n+ * all the streams and terminates the process to release the resources. Using try-with-resources to\n+ * {@linkplain ProcessBuilder#start()} the process can ensure the process\n+ * is terminated when the try-with-resources block exits.\n@@ -117,2 +137,2 @@\n- *     Process process = pb.start();\n- *     try (BufferedReader in = process.inputReader()) {\n+ *     try (Process process = pb.start();\n+ *          BufferedReader in = process.inputReader()) {\n@@ -142,1 +162,1 @@\n-public abstract class Process {\n+public abstract class Process implements Closeable {\n@@ -152,0 +172,1 @@\n+    private boolean closed;     \/\/ true if close() has been called\n@@ -158,0 +179,105 @@\n+    \/**\n+     * Close all reader and writer streams and wait for the process to terminate.\n+     * This method is idempotent, if this {@code Process} has already been closed\n+     * invoking this method has no effect.\n+     * <p>\n+     * If the data from the process input or error streams is needed, it must be read before\n+     * calling this method. The contents of streams that have not been read to end of stream\n+     * are lost, they are discarded or ignored.\n+     * <p>\n+     * If the process exit value of the process is of interest, then the caller must\n+     * {@linkplain #waitFor() wait for} the process to terminate before calling this method.\n+     * <p>\n+     * Streams should be closed when no longer needed.\n+     * Closing an already closed stream usually has no effect but is specific to the stream.\n+     * If an {@code IOException} occurs when closing a stream it is thrown\n+     * after the process has terminated. {@linkplain Exception}s\n+     * thrown by closing the streams, if any, are added to the first\n+     * {@code IOException} as {@linkplain IOException#addSuppressed suppressed exceptions}.\n+     * <p>\n+     * After the streams are closed this method {@linkplain #waitFor() waits for} the\n+     * process to terminate. If interrupted while {@linkplain #waitFor waiting} for termination\n+     * the process is {@linkplain #destroyForcibly() forcibly destroyed} and\n+     * this method continues to wait for the process to terminate.\n+     * The interrupted status is re-asserted before this method returns and\n+     * any {@code IOExceptions} are thrown.\n+     * <p>\n+     * Try-with-resources example to write text to a process, read back the\n+     * response, and close the streams and process:\n+     * {@snippet class=ProcessExamples region=example}\n+     *\n+     * @implNote\n+     * Concrete implementations that override this class are strongly encouraged to\n+     * override this method and invoke the superclass {@code close} method.\n+     *\n+     * @implSpec\n+     * The {@code outputWriter} and {@code outputStream} to the process are closed.\n+     * The {@code inputReader} and {@code inputStream} from the process are closed.\n+     * The {@code errorReader} and {@code errorStream} from the process are closed.\n+     * This method {@linkplain #waitFor() waits for the process} to terminate.\n+     * If {@linkplain #waitFor() waitFor()} is {@linkplain Thread#interrupt() interrupted}\n+     * the process is {@linkplain #destroyForcibly() forcibly destroyed}\n+     * and {@code close()} waits for the process to terminate.\n+     * @throws IOException if closing any of the streams throws an exception\n+     * @since 26\n+     *\/\n+    @Override\n+    public void close() throws IOException {\n+        synchronized(this) {\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n+            \/\/ Close each stream\n+            IOException ioe = quietClose(outputWriter != null ? outputWriter : getOutputStream(), null);\n+            ioe = quietClose(inputReader != null ? inputReader : getInputStream(), ioe);\n+            ioe = quietClose(errorReader != null ? errorReader : getErrorStream(), ioe);\n+\n+            \/\/ Wait for the process to terminate\n+            \/\/ If waitFor is interrupted, destroy the process\n+            \/\/ Continue waiting indefinitely for the process to terminate\n+            if (!tryWait()) {\n+                destroyForcibly();\n+                while (!tryWait()) {\n+                    continue;\n+                }\n+                \/\/ Re-assert the interrupted status\n+                Thread.currentThread().interrupt();\n+            }\n+            if (ioe != null) {\n+                throw ioe;\n+            }\n+        }\n+    }\n+\n+    \/\/ Try to wait for the process to terminate.\n+    \/\/ Return true if the process has terminated, false if wait is interrupted.\n+    private boolean tryWait() {\n+        try {\n+            waitFor();\n+            return true;\n+        } catch (InterruptedException ie) {\n+            return false;\n+        }\n+    }\n+\n+    \/\/ Quietly close.\n+    \/\/ If an IOException occurs, and it is the first, return it.\n+    \/\/ If there is no first IOException, a first IOException is created with the Throwable.\n+    \/\/ Otherwise, add the Throwable as a suppressed exception to the first.\n+    private static IOException quietClose(Closeable c, IOException firstIOE) {\n+        try {\n+            c.close();\n+            return firstIOE;\n+        } catch (Throwable th) {\n+            if (firstIOE == null && th instanceof IOException ioe) {\n+                return ioe;\n+            } else if (firstIOE == null) {\n+                firstIOE = new IOException(th);\n+            } else {\n+                firstIOE.addSuppressed(th);\n+            }\n+            return firstIOE;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":131,"deletions":5,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.Reader;\n+import java.io.Writer;\n+\n+public class ProcessExamples {\n+    \/\/ @start region=example\n+    void example() {\n+        try (Process p = new ProcessBuilder(\"cat\").start();\n+             Writer writer = p.outputWriter();\n+             Reader reader = p.inputReader()) {\n+            writer.write(haiku);\n+            writer.close();\n+            \/\/ Read all lines and print each\n+            reader.readAllLines()\n+                    .forEach(System.out::println);\n+            var status = p.waitFor();\n+            if (status != 0)\n+                throw new RuntimeException(\"unexpected process status: \" + status);\n+        } catch (Exception e) {\n+            System.out.println(\"Process failed: \" + e);\n+        }\n+    }\n+\n+    static final String haiku = \"\"\"\n+                Oh, the sunrise glow;\n+                Paddling with the river flow;\n+                Chilling still, go slow.\n+                \"\"\";\n+    \/\/ @end region=example\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/snippet-files\/ProcessExamples.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,783 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.java.lang.Process;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FilterInputStream;\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @bug 8364361\n+ * @summary Tests for Process.close\n+ * @modules java.base\/java.io:+open\n+ * @run junit jdk.java.lang.Process.ProcessCloseTest\n+ *\/\n+public class ProcessCloseTest {\n+\n+    private final static boolean OS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+    private final static String CAT_PROGRAM = \"cat\";\n+    private static List<String> JAVA_ARGS;\n+\n+    private static List<String> setupJavaEXE() {\n+        String JAVA_HOME = System.getProperty(\"test.jdk\");\n+        if (JAVA_HOME == null)\n+            JAVA_HOME = System.getProperty(\"JAVA_HOME\");\n+        String classPath = System.getProperty(\"test.class.path\");\n+        return  List.of(JAVA_HOME + \"\/bin\/java\", \"-cp\", classPath, ProcessCloseTest.class.getName());\n+    }\n+\n+    private static List<String> javaArgs(ChildCommand... moreArgs) {\n+\n+        List<String> javaArgs = JAVA_ARGS;\n+        if (javaArgs == null) {\n+            JAVA_ARGS = javaArgs = setupJavaEXE();\n+        }\n+        List<String> args = new ArrayList<>(javaArgs);\n+        for (ChildCommand arg : moreArgs) {\n+            args.add(arg.toString());\n+        }\n+        return args;\n+    }\n+\n+    \/**\n+     * {@return A Stream of Arguments}\n+     * Each Argument consists of three lists.\n+     * - A List of command line arguments to start a process.\n+     *   `javaArgs can be used to launch a Java child with ChildCommands\n+     * - A List of ProcessCommand actions to be invoked on that process\n+     * - A List of commands to be invoked on the process after the close or T-W-R exit.\n+     *\/\n+    static Stream<Arguments> singleThreadTestCases() {\n+        return Stream.of(\n+                Arguments.of(List.of(\"echo\", \"xyz0\"),\n+                        List.of(ProcessCommand.STDOUT_PRINT_ALL_LINES,\n+                                ProcessCommand.STDERR_EXPECT_EMPTY,\n+                                ExitStatus.NORMAL),\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(List.of(\"echo\", \"xyz1\"),\n+                        List.of(ProcessCommand.STDOUT_PRINT_ALL_LINES),\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(javaArgs(ChildCommand.STDOUT_ECHO),\n+                        List.of(ProcessCommand.WRITER_WRITE,\n+                                ProcessCommand.WRITER_CLOSE,\n+                                ProcessCommand.STDOUT_PRINT_ALL_LINES),\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(javaArgs(ChildCommand.STDOUT_ECHO),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.STDOUT_CLOSE,\n+                                ProcessCommand.STDOUT_PRINT_ALL_LINES),\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(javaArgs(ChildCommand.STDOUT_ECHO),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.STDOUT_CLOSE,\n+                                ExitStatus.NORMAL),\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(List.of(CAT_PROGRAM, \"NoSuchFile.txt\"),\n+                        List.of(ProcessCommand.STDERR_PRINT_ALL_LINES,\n+                                ProcessCommand.STDOUT_EXPECT_EMPTY),\n+                        List.of(ExitStatus.FAIL)),\n+                Arguments.of(javaArgs(ChildCommand.STDOUT_MARCO),\n+                        List.of(ProcessCommand.STDOUT_EXPECT_POLO,\n+                                ProcessCommand.STDERR_EXPECT_EMPTY),\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(javaArgs(ChildCommand.STDERR_MARCO),\n+                        List.of(ProcessCommand.STDERR_EXPECT_POLO,\n+                                ProcessCommand.STDOUT_EXPECT_EMPTY),\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(javaArgs(ChildCommand.PROCESS_EXIT1),\n+                        List.of(ExitStatus.FAIL),\n+                        List.of(ExitStatus.FAIL)),       \/\/ Got expected status == 1\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_INTERRUPT, \/\/ schedule an interrupt (in .2 sec)\n+                                ProcessCommand.PROCESS_CLOSE,\n+                                ProcessCommand.PROCESS_CHECK_INTERRUPTED), \/\/ Verify interrupted status\n+                        List.of(ExitStatus.KILLED)), \/\/ And process was destroyed\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_INTERRUPT), \/\/ interrupts the TWR\/close\n+                        List.of(ProcessCommand.PROCESS_CHECK_INTERRUPTED, ExitStatus.KILLED)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ExitStatus.NORMAL), \/\/ waitFor before T-W-R exit\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(List.of(\"echo\", \"abc\"),\n+                        List.of(ProcessCommand.PROCESS_CLOSE),\n+                        List.of(ExitStatus.RACY)),\n+                Arguments.of(javaArgs(ChildCommand.STDOUT_ECHO),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.PROCESS_CLOSE),\n+                        List.of(ExitStatus.PIPE)),\n+                Arguments.of(List.of(\"echo\", \"def\"),\n+                        List.of(ProcessCommand.PROCESS_DESTROY),\n+                        List.of(ExitStatus.RACY)), \/\/ Racy, not deterministic\n+                Arguments.of(javaArgs(ChildCommand.STDOUT_ECHO),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.PROCESS_DESTROY),\n+                        List.of(ExitStatus.RACY)), \/\/ Racy, not deterministic\n+                Arguments.of(List.of(\"echo\"),\n+                        List.of(ExitStatus.NORMAL),\n+                        List.of(ExitStatus.NORMAL))\n+        );\n+    }\n+\n+    \/\/ Utility to process each command on the process\n+    private static void doCommands(Process proc, List<Consumer<Process>> commands) {\n+        commands.forEach(c -> {\n+            Log.printf(\"    %s\\n\", c);\n+            c.accept(proc);\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"singleThreadTestCases\")\n+    void simple(List<String> args, List<Consumer<Process>> commands,\n+                List<Consumer<Process>> postCommands) throws IOException {\n+        var log = Log.get();\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process p = pb.start(); \/\/ Buffer any debug output\n+            Log.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+            doCommands(p, commands);\n+            p.close();\n+            doCommands(p, postCommands);\n+        } catch (Throwable ex) {\n+            System.err.print(log);\n+            throw ex;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"singleThreadTestCases\")\n+    void autoCloseable(List<String> args, List<Consumer<Process>> commands,\n+                       List<Consumer<Process>> postCommands) {\n+        var log = Log.get();\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process proc = null;\n+            try (Process p = pb.start()) {\n+                proc = p;\n+                Log.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+                doCommands(p, commands);\n+            } catch (IOException ioe) {\n+                Assertions.fail(ioe);\n+            }\n+            doCommands(proc, postCommands);\n+        } catch (Throwable ex) {\n+            System.err.println(log);\n+            throw ex;\n+        }\n+    }\n+\n+    \/**\n+     * Test AutoCloseable for the process and out, in, and err streams.\n+     * @param args The command line arguments\n+     * @param commands the commands to the process\n+     * @param postCommands The expected final exit status\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"singleThreadTestCases\")\n+    void autoCloseableAll(List<String> args, List<Consumer<Process>> commands,\n+                          List<Consumer<Process>> postCommands) {\n+        var log = Log.get();\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process proc = null;\n+            try (Process p = pb.start(); var out = p.getOutputStream();\n+                 var in = p.getInputStream();\n+                 var err = p.getErrorStream()) {\n+                proc = p;\n+                Log.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+                doCommands(p, commands);\n+            } catch (IOException ioe) {\n+                Assertions.fail(ioe);\n+            }\n+            doCommands(proc, postCommands);\n+        }  catch (Throwable ex) {\n+            System.err.println(log);\n+            throw ex;\n+        }\n+    }\n+\n+    \/**\n+     * ExitStatus named values and assertions\n+     *\/\n+    enum ExitStatus implements Consumer<Process> {\n+        NORMAL(0),\n+            FAIL(1),\n+            PIPE(0, 1, 141),   \/\/ SIGPIPE\n+            KILLED(1, 137), \/\/ SIGKILL\n+            TERMINATED(0, 143), \/\/ SIGTERM\n+            RACY(0, 1, 137, 143),\n+        ;\n+        private final int[] allowedStatus;\n+\n+        ExitStatus(int... status) {\n+            this.allowedStatus = status;\n+        }\n+\n+        \/\/ If used as a process command, checks the exit status\n+        public void accept(Process p) {\n+            try {\n+                Instant begin = Instant.now();\n+                final int exitStatus = p.waitFor();\n+                Duration latency = begin.until(Instant.now());\n+                Log.printf(\"    ExitStatus: %d, sig#: %d, waitFor latency: %s%n\",\n+                        exitStatus, exitStatus & 0x7f, latency);\n+                assertEquals(exitStatus);\n+            } catch (InterruptedException ie) {\n+                Assertions.fail(\"Unexpected InterruptedException checking status: \" + this);\n+            }\n+        }\n+\n+        \/\/ Check a status matches one of the allowed exit status values\n+        void assertEquals(int actual) {\n+            for (int status : allowedStatus) {\n+                if (status == actual) {\n+                    return;     \/\/ status is expected\n+                }\n+            }\n+            if (this == RACY) {\n+                \/\/ Not an error but report the actual status\n+                Log.printf(\"Racy exit status: %d\\n\", actual);\n+            } else {\n+                Assertions.fail(\"Status: \" + actual + \", sig#: \" + (actual & 0x7f) +\n+                        \", expected one of: \" + Arrays.toString(allowedStatus));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Commands on a Process that can be sequenced in the parent.\n+     * See ChildCommands for commands that can be sent to the child process.\n+     *\/\n+    enum ProcessCommand implements Consumer<Process> {\n+        PROCESS_CLOSE(ProcessCommand::processClose),\n+        PROCESS_DESTROY(ProcessCommand::processDestroy),\n+        PROCESS_FORCE_OUT_CLOSE_EXCEPTION(ProcessCommand::processForceOutCloseException),\n+        PROCESS_FORCE_IN_CLOSE_EXCEPTION(ProcessCommand::processForceInCloseException),\n+        PROCESS_FORCE_ERROR_CLOSE_EXCEPTION(ProcessCommand::processForceErrorCloseException),\n+        WRITER_WRITE(ProcessCommand::writerWrite),\n+        WRITER_CLOSE(ProcessCommand::writerClose),\n+        STDOUT_PRINT_ALL_LINES(ProcessCommand::stdoutPrintAllLines),\n+        STDERR_PRINT_ALL_LINES(ProcessCommand::stderrPrintAllLines),\n+        STDOUT_WRITE(ProcessCommand::stdoutWrite),\n+        STDOUT_CLOSE(ProcessCommand::stdoutClose),\n+        STDOUT_EXPECT_POLO(ProcessCommand::stdoutExpectPolo),\n+        STDERR_EXPECT_POLO(ProcessCommand::stderrExpectPolo),\n+        STDOUT_EXPECT_EMPTY(ProcessCommand::stdoutExpectEmpty),\n+        STDERR_EXPECT_EMPTY(ProcessCommand::stderrExpectEmpty),\n+        PROCESS_INTERRUPT(ProcessCommand::processInterruptThread),\n+        PROCESS_CHECK_INTERRUPTED(ProcessCommand::processAssertInterrupted),\n+        ;\n+        private final Consumer<Process> command;\n+\n+        ProcessCommand(Consumer<Process> command) {\n+            this.command = command;\n+        }\n+\n+        public void accept(Process p) {\n+            command.accept(p);\n+        }\n+\n+        private static void stdoutPrintAllLines(Process p) {\n+            try {\n+                var lines = p.inputReader().readAllLines();\n+                Assertions.assertNotEquals(0, lines.size(), \"stdout should not be empty\");\n+                Log.printf(\"        %d lines\\n\", lines.size());\n+                Log.printf(\"%s%n\", lines.toString().indent(8));\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void stderrPrintAllLines(Process p) {\n+            try {\n+                var lines = p.errorReader().readAllLines();\n+                Assertions.assertNotEquals(0, lines.size(), \"stderr should not be empty\");\n+                Log.printf(\"        %d lines\\n\", lines.size());\n+                Log.printf(\"%s%n\", lines.toString().indent(8));\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void writerWrite(Process p) {\n+            try {\n+                p.outputWriter().write(\"Now is the time.\");\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void writerClose(Process p) {\n+            try {\n+                p.outputWriter().close();\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void stdoutExpectPolo(Process p) {\n+            String line = readLine(p.getInputStream());\n+            Assertions.assertEquals(\"Polo\", line, \"Stdout Expected Polo\");\n+        }\n+\n+        private static void stderrExpectPolo(Process p) {\n+            String line = readLine(p.getErrorStream());\n+            Assertions.assertEquals(\"Polo\", line, \"Stderr Expected Polo\");\n+        }\n+\n+        private static void stdoutExpectEmpty(Process p) {\n+            String line = readLine(p.getInputStream());\n+            Assertions.assertEquals(\"\", line, \"Stdout Expected Empty\");\n+        }\n+\n+        private static void stderrExpectEmpty(Process p) {\n+            String line = readLine(p.getErrorStream());\n+            Assertions.assertEquals(\"\", line, \"Stderr Expected Empty\");\n+        }\n+\n+        private static String readLine(InputStream in) {\n+            StringBuilder sb = new StringBuilder();\n+            try {\n+                int ch;\n+                while ((ch = in.read()) != -1) {\n+                    if (ch == '\\n') {\n+                        \/\/ end of line\n+                        return sb.toString();\n+                    }\n+                    if (ch != '\\r') {       \/\/ ignore cr - Windows defense\n+                        sb.append((char) ch);\n+                    }\n+                }\n+                \/\/ EOF - return string if no LF found\n+                return sb.toString();\n+            } catch (IOException ioe) {\n+                return ioe.getMessage();\n+            }\n+        }\n+\n+        private static void stdoutWrite(Process p) {\n+            try {\n+                var out = p.getOutputStream();\n+                out.write(\"stdout-write\".getBytes(StandardCharsets.UTF_8));\n+                out.flush();\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void stdoutClose(Process p) {\n+            try {\n+                p.getOutputStream().close();\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void processClose(Process p) {\n+            try {\n+                p.close();\n+            } catch (IOException ioe) {\n+                Assertions.fail(ioe);\n+            }\n+        }\n+\n+        private static void processDestroy(Process p) {\n+            p.destroy();\n+        }\n+\n+        private static void processForceOutCloseException(Process p) {\n+            var out = p.getOutputStream();\n+            closeOutputStreamPrematurely(out);\n+        }\n+\n+        private static void processForceInCloseException(Process p) {\n+            var in = p.getInputStream();\n+            closeInputStreamPrematurely(in);\n+        }\n+\n+        private static void processForceErrorCloseException(Process p) {\n+            var err = p.getErrorStream();\n+            closeInputStreamPrematurely(err);\n+        }\n+\n+        \/\/ Hard coded to interrupt the invoking thread at a fixed rate of .2 second, if process is alive\n+        private static void processInterruptThread(Process p) {\n+            if (p.isAlive()) {\n+                int delay = 200;\n+                final Thread targetThread = Thread.currentThread();\n+                ForkJoinPool common = ForkJoinPool.commonPool();\n+                final ThreadInterruptor interrupter = new ThreadInterruptor(p, targetThread);\n+                common.scheduleAtFixedRate(interrupter, delay, delay, TimeUnit.MILLISECONDS);\n+            }\n+        }\n+\n+        \/\/ Verify that an interrupt is pending and reset it\n+        private static void processAssertInterrupted(Process p) {\n+            Assertions.assertTrue(Thread.interrupted(), \"Expected an interrupt\");\n+        }\n+    }\n+\n+    \/\/ Runnable scheduled at a fixed rate to interrupt a thread if a process is alive.\n+    private static class ThreadInterruptor implements Runnable {\n+        private final Process process;\n+        private final Thread targetThread;\n+        private int count;\n+\n+        ThreadInterruptor(Process process, Thread targetThread) {\n+            this.process = process;\n+            this.targetThread = targetThread;\n+            this.count = 0;\n+        }\n+\n+        public void run() {\n+            if (process.isAlive()) {\n+                count++;\n+                Log.printf(\"Interrupting thread, count: %d%n\", count);\n+                targetThread.interrupt();\n+            } else {\n+                throw new RuntimeException(\"process not alive\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Commands to Java child sent as command line arguments\n+    enum ChildCommand {\n+        STDOUT_ECHO(ChildCommand::stdoutEchoBytes),\n+        STDERR_ECHO(ChildCommand::stderrEchoBytes),\n+        SLEEP(ChildCommand::SLEEP),\n+        STDOUT_MARCO(ChildCommand::stdoutMarco),\n+        STDERR_MARCO(ChildCommand::stderrMarco),\n+        PROCESS_EXIT1(ChildCommand::processExit1),\n+        ;\n+        private final Runnable command;\n+        ChildCommand(Runnable cmd) {\n+            this.command = cmd;\n+        }\n+\n+        \/\/ The child sleeps before continuing with next ChildCommand\n+        private static void SLEEP() {\n+            final int sleepMS = 2_000;\n+            try {\n+                Thread.sleep(sleepMS);\n+            } catch (InterruptedException ie) {\n+                \/\/ Interrupted sleep, re-assert interrupted status\n+                System.err.println(\"Sleep interrupted\");  \/\/ Note the interruption in the log\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+\n+        private static void stdoutEchoBytes() {\n+            echoBytes(System.in, System.out);\n+        }\n+\n+        private static void stderrEchoBytes() {\n+            echoBytes(System.in, System.err);\n+        }\n+\n+        private static void echoBytes(InputStream in, PrintStream out) {\n+            try {\n+                byte[] bytes = in.readAllBytes();\n+                out.write(bytes);\n+            } catch (IOException ioe) {\n+                out.println(ioe);\n+            }\n+        }\n+\n+        private static void stdoutMarco() {\n+            System.out.println(\"Polo\");\n+        }\n+\n+        private static void stderrMarco() {\n+            System.err.println(\"Polo\");\n+        }\n+\n+        private static void processExit1() {\n+            System.exit(1);\n+        }\n+    }\n+\n+    static Stream<Arguments> closeExceptions() {\n+        final String badFDMsg = OS_WINDOWS ? \"The handle is invalid\" : \"Bad file descriptor\";\n+        return Stream.of(\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg, badFDMsg, badFDMsg)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg, badFDMsg)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg, badFDMsg)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg, badFDMsg)),\n+                Arguments.of(List.of(\"echo\", \"xyz1\"),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(badFDMsg))\n+        );\n+    }\n+    \/**\n+     * Test AutoCloseable for cases that are expected to throw exceptions.\n+     * The list of ProcessCommands controls what is sent to the process and closing of streams.\n+     * The command line arguments control the sequence of actions taken by the child.\n+     * @param args The command line arguments for the child process\n+     * @param commands the commands to this process controlling the child\n+     * @param postCommands The expected final exit status\n+     * @param expectedMessages the list of exception messages expected by close()\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"closeExceptions\")\n+    void testStreamsCloseThrowing(List<String> args, List<Consumer<Process>> commands,\n+                                  List<Consumer<Process>> postCommands, List<String> expectedMessages) {\n+        var log = Log.get();\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process proc = null;\n+            IOException expectedIOE = null;\n+            try (Process p = pb.start()) {\n+                proc = p;\n+                Log.printf(\"Program: %s; pid: %d\\n\",args, p.pid());\n+                doCommands(p, commands);\n+            } catch (IOException ioe) {\n+                expectedIOE = ioe;\n+            }\n+            \/\/ Check the exceptions thrown, if any\n+            if (expectedIOE != null) {\n+                \/\/ Check each exception that it is expected\n+                Assertions.assertEquals(expectedMessages.getFirst(), expectedIOE.getMessage(),\n+                        \"Unexpected exception message\");\n+                var suppressedEx = expectedIOE.getSuppressed();\n+                Assertions.assertEquals(expectedMessages.size() - 1, suppressedEx.length,\n+                        \"Number of suppressed exceptions\");\n+                for (int i = 1; i < expectedMessages.size(); i++) {\n+                    Assertions.assertEquals(expectedMessages.get(i),\n+                            suppressedEx[i - 1].getMessage(),\n+                            \"Unexpected suppressed exception message\");\n+                }\n+            }\n+            Assertions.assertNotNull(proc, \"Process is null\");\n+            doCommands(proc, postCommands);\n+        }  catch (Exception ex) {\n+            System.err.println(log);\n+            throw ex;\n+        }\n+    }\n+\n+    \/*\n+     * Invasive hack to force closing a FileDescriptor to throw an exception on FileDescriptor.close().\n+     * The output stream is pealed back to get the FileDescriptor containing the fd or handle.\n+     * On Linux, the existing fd is closed to prevent a leak and the fd is replaced by a bad fd.\n+     * On Windows, the existing handle is closed\n+     * @param an OutputStream from Process.getOutputStream\n+     *\/\n+    private static void closeOutputStreamPrematurely(OutputStream out) {\n+        try {\n+            Field fosOutField = FilterOutputStream.class.getDeclaredField(\"out\");\n+            fosOutField.setAccessible(true);\n+            FileOutputStream pipeOut = (FileOutputStream) fosOutField.get(out);\n+\n+            Field fosFdField = FileOutputStream.class.getDeclaredField(\"fd\");\n+            fosFdField.setAccessible(true);\n+            FileDescriptor fileDescriptor = (FileDescriptor) fosFdField.get(pipeOut);\n+            closeFDPrematurely(fileDescriptor);\n+        } catch (Exception ex) {\n+            Assertions.fail(\"Failed to setup OutputStream FileDescriptor for bad close\", ex);\n+        }\n+    }\n+\n+    \/*\n+     * Invasive hack to force closing a FileDescriptor to throw an exception on FileDescriptor.close().\n+     * The input stream is pealed back to get the FileDescriptor containing the fd or handle.\n+     * On Linux, the existing fd is closed to prevent a leak and the fd is replaced by a bad fd.\n+     * On Windows, the existing handle is closed\n+     * @param in an InputStream from Process.getInputStream\n+     *\/\n+    private static void closeInputStreamPrematurely(InputStream in) {\n+        try {\n+            if (in instanceof FilterInputStream fis) {\n+                \/\/ On Linux and Mac, the pipe is wrapped in a ProcessPipeInputStream (a FilterInputStream)\n+                Field fisInField = FilterInputStream.class.getDeclaredField(\"in\");\n+                fisInField.setAccessible(true);\n+                in = (FileInputStream) fisInField.get(fis);\n+            }\n+            FileInputStream pipeIn = (FileInputStream) in;\n+            Field fisFdField = FileInputStream.class.getDeclaredField(\"fd\");\n+            fisFdField.setAccessible(true);\n+            FileDescriptor fileDescriptor = (FileDescriptor) fisFdField.get(pipeIn);\n+            closeFDPrematurely(fileDescriptor);\n+        } catch (Exception ex) {\n+            Assertions.fail(\"Failed to setup InputStream FileDescriptor for bad close\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * Close the FileDescriptor and reset the fd or handle to cause an IOException when closed again.\n+     * On Linux, the FileDescriptor fd is closed to prevent a leak and the fd is restored to the same fd.\n+     * On Windows, the existing handle is closed and the handle is restored.\n+     * Closing the fd or the handle again throws an IOException\n+     * @param fileDescriptor FileDescriptor from a process input or output stream\n+     * @throws Exception if setup or invoking close fails\n+     *\/\n+    private static void closeFDPrematurely(FileDescriptor fileDescriptor) throws Exception {\n+        Method fdCloseMethod = FileDescriptor.class.getDeclaredMethod(\"close\");\n+        fdCloseMethod.setAccessible(true);\n+\n+        if (OS_WINDOWS) {\n+            Field fdHandleField = FileDescriptor.class.getDeclaredField(\"handle\");\n+            fdHandleField.setAccessible(true);\n+            final long handle = (long) fdHandleField.get(fileDescriptor);\n+            Log.printf(\"FileDescriptor.handle: %08x%n\", handle);\n+            \/\/ Close the known handle\n+            \/\/ And restore the handle so normal close() will throw an exception\n+            fdCloseMethod.invoke(fileDescriptor);\n+            fdHandleField.set(fileDescriptor, handle);\n+            Log.printf(\"FileDescriptor.handle to close again and fail: %08x%n\", handle);\n+        } else {\n+            \/\/ Linux\n+            Field fdFdField = FileDescriptor.class.getDeclaredField(\"fd\");\n+            fdFdField.setAccessible(true);\n+            final int fd = (int) fdFdField.get(fileDescriptor);\n+            Log.printf(\"FileDescriptor.fd: %08x%n\", fd);\n+            \/\/ Close the known fd\n+            \/\/ And restore the fd so normal close() will throw an exception\n+            fdCloseMethod.invoke(fileDescriptor);\n+            fdFdField.set(fileDescriptor, fd);\n+            Log.printf(\"FileDescriptor.fd to close again and fail: %08x%n\", fd);\n+        }\n+    }\n+\n+    \/\/ Copy of ProcessExamples in java\/lang\/snippet-files\/ProcessExamples.java\n+    @Test\n+    void example() {\n+        try (Process p = new ProcessBuilder(CAT_PROGRAM).start();\n+             Writer writer = p.outputWriter();\n+             Reader reader = p.inputReader()) {\n+            writer.write(haiku);\n+            writer.close();\n+            \/\/ Read all lines and print each\n+            reader.readAllLines()\n+                    .forEach(System.out::println);\n+            var status = p.waitFor();\n+            if (status != 0)\n+                throw new RuntimeException(\"unexpected process status: \" + status);\n+        } catch (Exception e) {\n+            System.err.println(\"Process failed: \" + e);\n+        }\n+    }\n+\n+    String haiku = \"\"\"\n+                Oh, the sunrise glow;\n+                Paddling with the river flow;\n+                Chilling still, go slow.\n+                \"\"\";\n+\n+    \/**\n+     * Child program that executes child actions as named by command line args.\n+     * @param childCommands a sequence of ChildCommand names.\n+     *\/\n+    public static void main(String... childCommands)  {\n+        List<String> args = List.of(childCommands);\n+        List<ChildCommand> commands = args.stream().map(ChildCommand::valueOf).toList();\n+        commands.forEach(c -> c.command.run());\n+    }\n+\n+    \/**\n+     * Log of output produced on a thread during a test.\n+     * Normally, the output is buffered and only output to stderr if the test fails.\n+     * Set -DDEBUG=true to send all output to stderr as it occurs.\n+     *\/\n+    private static class Log {\n+\n+        private static final boolean DEBUG = Boolean.getBoolean(\"DEBUG\");\n+        private final static ScopedValue<Appendable> OUT = ScopedValue.newInstance();\n+        private final static ScopedValue.Carrier LOG = setupLog();\n+\n+        private static ScopedValue.Carrier setupLog() {\n+            if (DEBUG) {\n+                return ScopedValue.where(OUT, System.err);\n+            } else {\n+                return ScopedValue.where(OUT, new StringBuffer());\n+            }\n+        }\n+\n+        \/\/ Return the log for this thread and clear the buffer.\n+        private static Appendable get() {\n+            var log = LOG.get(OUT);\n+            if (log instanceof StringBuffer sb)\n+                sb.setLength(0);\n+            return log;\n+        }\n+\n+        \/\/ Printf to the log for this thread.\n+        private static void printf(String format, Object... args) {\n+            try {\n+                var log = LOG.get(OUT);\n+                log.append(format.formatted(args));\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Process\/ProcessCloseTest.java","additions":783,"deletions":0,"binary":false,"changes":783,"status":"added"}]}