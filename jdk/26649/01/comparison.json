{"files":[{"patch":"@@ -40,0 +40,1 @@\n+import java.util.function.Supplier;\n@@ -90,0 +91,1 @@\n+ * {@linkplain #close() close},\n@@ -102,1 +104,4 @@\n- * or readers, or they have been closed.\n+ * or readers, or they have been closed. {@linkplain Process#close close()} closes\n+ * all the streams and terminates the process. Using try-with-resources to\n+ * {@linkplain ProcessBuilder#start()} the process can ensure the process\n+ * is terminated when the try-with-resources block exits.\n@@ -117,2 +122,2 @@\n- *     Process process = pb.start();\n- *     try (BufferedReader in = process.inputReader()) {\n+ *     try (Process process = pb.start();\n+ *          BufferedReader in = process.inputReader()) {\n@@ -142,1 +147,5 @@\n-public abstract class Process {\n+public abstract class Process implements AutoCloseable {\n+\n+    \/\/ Logger for exceptions\n+    private static final Supplier<System.Logger> LOGGER =\n+            StableValue.supplier( () -> System.getLogger(\"java.lang.Process\") );\n@@ -615,0 +624,47 @@\n+    \/**\n+     * Close all writer and reader streams and terminate the process.\n+     * The streams are closed immediately and the process is terminated without waiting.\n+     * <p>\n+     * Before calling {@code close} the caller should read the streams for any\n+     * data or text and call {@linkplain #waitFor() waitFor} if the exit value is needed.\n+     * The contents of streams that have not been read fully are lost;\n+     * they are discarded or ignored.\n+     * Streams should be {@code closed} when no longer needed.\n+     * Closing an already closed stream usually has no effect but is specific to the stream.\n+     * Any {@code IOException} that occurs when closing a stream is ignored.\n+     * <p>\n+     * The process may already have exited or be in the process of exiting;\n+     * if it is {@linkplain #isAlive() alive}, it is {@linkplain #destroy destroyed}.\n+     * Any {@code IOException} that occurs when destroying the process is ignored.\n+     * <p>\n+     * Example using try-with-resources writing text to a process, reading back the\n+     * response, and closing the streams and process:\n+     * {@snippet class=ProcessExamples region=example}\n+     *\n+     * @implSpec\n+     * The {@code outputWriter} and {@code outputStream} to the process are closed.\n+     * The {@code inputReader} and {@code inputStream} from the process are closed.\n+     * The {@code errorReader} and {@code errorStream} from the process are closed.\n+     * The process is destroyed.\n+     * @since 26\n+     *\/\n+    public void close() {\n+        \/\/ Close each stream\n+        quietClose(outputWriter != null ? outputWriter : getOutputStream());\n+        quietClose(inputReader != null ? inputReader  : getInputStream());\n+        quietClose(errorReader != null ? errorReader : getErrorStream());\n+\n+        destroy();      \/\/ no-op if process is not alive\n+    }\n+\n+    \/\/ Quietly close and log exception\n+    private void quietClose(Closeable c) {\n+        try {\n+            c.close();\n+        } catch (IOException ioe) {\n+            LOGGER.get().log(System.Logger.Level.DEBUG,\n+                    \"Exception closing process: pid: \" + pid() , ioe);\n+        }\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":60,"deletions":4,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.Reader;\n+import java.io.Writer;\n+\n+public class ProcessExamples {\n+    \/\/ @start region=example\n+    static final String haiku = \"\"\"\n+                Oh, the sunrise glow;\n+                Paddling with the river flow;\n+                Chilling still, go slow.\n+                \"\"\";\n+\n+    void example() {\n+        try (Process p = new ProcessBuilder(\"cat\").start();\n+             Writer writer = p.outputWriter();\n+             Reader reader = p.inputReader()) {\n+            writer.write(haiku);\n+            writer.close();\n+            \/\/ Read all lines and print each\n+            reader.readAllLines()\n+                    .forEach(System.err::println);\n+            var status = p.waitFor();\n+            if (status != 0)\n+                throw new RuntimeException(\"unexpected process status: \" + status);\n+        } catch (Exception e) {\n+            System.out.println(\"Process failed: \" + e);\n+        }\n+    }\/\/ @end region=example\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/snippet-files\/ProcessExamples.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,476 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.java.lang.Process;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @bug 8336479\n+ * @summary Tests for Process.close\n+ * @run junit\/othervm -Djava.util.logging.config.file=${test.src}\/ProcessLogging-FINE.properties\n+ *       jdk.java.lang.Process.ProcessCloseTest\n+ *\/\n+\n+public class ProcessCloseTest {\n+\n+    private static List<String> JAVA_ARGS;\n+\n+    private static List<String> setupJavaEXE() {\n+        String JAVA_HOME = System.getProperty(\"test.jdk\");\n+        if (JAVA_HOME == null)\n+            JAVA_HOME = System.getProperty(\"JAVA_HOME\");\n+        String classPath = System.getProperty(\"test.class.path\");\n+        return  List.of(JAVA_HOME + \"\/bin\/java\", \"-cp\", classPath, ProcessCloseTest.class.getName());\n+    }\n+\n+    private static List<String> javaArgs(ChildCommand... moreArgs) {\n+\n+        List<String> javaArgs = JAVA_ARGS;\n+        if (javaArgs == null) {\n+            JAVA_ARGS = javaArgs = setupJavaEXE();\n+        }\n+        List<String> args = new ArrayList<>(javaArgs);\n+        for (ChildCommand arg : moreArgs) {\n+            args.add(arg.toString());\n+        }\n+        return args;\n+    }\n+\n+    \/\/ Permutations\n+    \/\/ Parent single thread vs concurrent close\n+    \/\/ child waiting on stdin\n+    \/\/ child sending on stdout and on stderr\n+    \/\/ child exited and not exited\n+    \/\/ parent abandoning stdin and stderr and either-or,\n+    \/\/ parent waiting for exit before closing vs not waiting\n+\n+    static Stream<Arguments> singleThreadTestCases() {\n+        return Stream.of(\n+                Arguments.of(List.of(\"echo\", \"xyz0\"),\n+                        List.of(ProcessCommand.STDOUT_PRINT_ALL_LINES,\n+                                ProcessCommand.STDERR_EXPECT_EMPTY,\n+                                ProcessCommand.PROCESS_EXPECT_EXIT_NORMAL),\n+                        ExitStatus.NORMAL),\n+                Arguments.of(List.of(\"echo\", \"xyz1\"),\n+                        List.of(ProcessCommand.STDOUT_PRINT_ALL_LINES),\n+                        ExitStatus.RACY),\n+                Arguments.of(List.of(\"cat\", \"-\"),\n+                        List.of(ProcessCommand.WRITER_WRITE,\n+                                ProcessCommand.WRITER_CLOSE,\n+                                ProcessCommand.STDOUT_PRINT_ALL_LINES),\n+                        ExitStatus.RACY),\n+                Arguments.of(List.of(\"cat\", \"-\"),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.STDOUT_CLOSE,\n+                                ProcessCommand.STDOUT_PRINT_ALL_LINES),\n+                        ExitStatus.RACY),\n+                Arguments.of(List.of(\"cat\", \"-\"),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.STDOUT_CLOSE,\n+                                ProcessCommand.PROCESS_EXPECT_EXIT_NORMAL),\n+                        ExitStatus.NORMAL),\n+                Arguments.of(List.of(\"cat\", \"NoSuchFile.txt\"),\n+                        List.of(ProcessCommand.STDERR_PRINT_ALL_LINES,\n+                                ProcessCommand.STDOUT_EXPECT_EMPTY),\n+                        ExitStatus.RACY),\n+                Arguments.of(javaArgs(ChildCommand.STDOUT_MARCO),\n+                        List.of(ProcessCommand.STDOUT_EXPECT_POLO,\n+                                ProcessCommand.STDERR_EXPECT_EMPTY),\n+                        ExitStatus.RACY),\n+                Arguments.of(javaArgs(ChildCommand.STDERR_MARCO),\n+                        List.of(ProcessCommand.STDERR_EXPECT_POLO,\n+                                ProcessCommand.STDOUT_EXPECT_EMPTY),\n+                        ExitStatus.NORMAL),\n+                Arguments.of(javaArgs(ChildCommand.PROCESS_EXIT1),\n+                        List.of(ProcessCommand.PROCESS_EXPECT_EXIT_FAIL),\n+                        ExitStatus.FAIL),       \/\/ Got expected status == 1\n+                Arguments.of(List.of(\"echo\", \"abc\"),\n+                        List.of(ProcessCommand.PROCESS_CLOSE),\n+                        ExitStatus.RACY), \/\/ Racy, not deterministic\n+                Arguments.of(List.of(\"cat\", \"-\"),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.PROCESS_CLOSE),\n+                        ExitStatus.RACY),  \/\/ Racy, not deterministic\n+                Arguments.of(List.of(\"echo\", \"abc\"),\n+                        List.of(ProcessCommand.PROCESS_DESTROY),\n+                        ExitStatus.RACY), \/\/ Racy, not deterministic\n+                Arguments.of(List.of(\"cat\", \"-\"),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.PROCESS_DESTROY),\n+                        ExitStatus.RACY), \/\/ Racy, not deterministic\n+                Arguments.of(List.of(\"echo\"),\n+                        List.of(ProcessCommand.PROCESS_EXPECT_EXIT_NORMAL),\n+                        ExitStatus.RACY)\n+        );\n+    }\n+\n+\n+    @ParameterizedTest\n+    @MethodSource(\"singleThreadTestCases\")\n+    void simple(List<String> args, List<ProcessCommand> commands, ExitStatus exitStatus) throws IOException {\n+        ProcessBuilder pb = new ProcessBuilder(args);\n+        Process p = pb.start();\n+        System.err.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+        commands.forEach(c -> {\n+            System.err.printf(\"    %s\\n\", c);\n+            c.command.accept(p);\n+        });\n+        p.close();\n+        ProcessCommand.processExpectExit(p, exitStatus);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"singleThreadTestCases\")\n+    void autoCloseable(List<String> args, List<ProcessCommand> commands, ExitStatus exitStatus) {\n+        ProcessBuilder pb = new ProcessBuilder(args);\n+        Process proc = null;\n+        try (Process p = pb.start()) {\n+            proc = p;\n+            System.err.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+            commands.forEach(c -> {\n+                System.err.printf(\"    %s\\n\", c);\n+                c.command.accept(p);\n+            });\n+        }  catch (IOException ioe) {\n+            Assertions.fail(ioe);\n+        }\n+        ProcessCommand.processExpectExit(proc, exitStatus);\n+    }\n+\n+\n+    \/**\n+     * Test AutoCloseable for the process and out, in, and err streams.\n+     * @param args The command line arguments\n+     * @param commands the commands to the process\n+     * @param exitStatus The expected final exit status\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"singleThreadTestCases\")\n+    void autoCloseableAll(List<String> args, List<ProcessCommand> commands, ExitStatus exitStatus) {\n+        ProcessBuilder pb = new ProcessBuilder(args);\n+        Process proc = null;\n+        try (Process p = pb.start(); var out = p.getOutputStream();\n+             var in = p.getInputStream();\n+             var err = p.getErrorStream()) {\n+            proc = p;\n+            System.err.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+            commands.forEach(c -> {\n+                System.err.printf(\"    %s\\n\", c);\n+                c.command.accept(p);\n+            });\n+        } catch (IOException ioe) {\n+            Assertions.fail(ioe);\n+        }\n+        ProcessCommand.processExpectExit(proc, exitStatus);\n+    }\n+\n+\n+        \/\/ ExitStatus named values and assertions\n+    enum ExitStatus {\n+        NORMAL(0),\n+        FAIL(1),\n+        PIPE(1, 141),\n+        KILLED(0, 143),\n+        RACY(0, 1, 143),\n+        ;\n+        private final int[] allowedStatus;\n+\n+        ExitStatus(int... status) {\n+            this.allowedStatus = status;\n+        }\n+\n+        \/\/ Check a status matches one of the allowed exit status values\n+        void assertEquals(int actual) {\n+            for (int status : allowedStatus) {\n+                if (status == actual) {\n+                    return;     \/\/ status is expected\n+                }\n+            }\n+            if (this == RACY) {\n+                \/\/ Not an error but report the actual status\n+                System.err.printf(\"Racy exit status: %d\\n\", actual);\n+            } else {\n+                Assertions.fail(\"Status: \" + actual + \", expected one of: \" + Arrays.toString(allowedStatus));\n+            }\n+        }\n+    }\n+    \/**\n+     * Commands on a Process that can be sequenced in the parent.\n+     *\n+     * See ChildCommands for commands that can be sent to the child process.\n+     *\/\n+    enum ProcessCommand {\n+        PROCESS_EXPECT_EXIT_NORMAL(ProcessCommand::processExpectExitNormal),\n+        PROCESS_EXPECT_EXIT_FAIL(ProcessCommand::processExpectExitFail),\n+        PROCESS_CLOSE(ProcessCommand::processClose),\n+        PROCESS_DESTROY(ProcessCommand::processDestroy),\n+        WRITER_WRITE(ProcessCommand::writerWrite),\n+        WRITER_CLOSE(ProcessCommand::writerClose),\n+        STDOUT_PRINT_ALL_LINES(ProcessCommand::stdoutPrintAllLines),\n+        STDERR_PRINT_ALL_LINES(ProcessCommand::stderrPrintAllLines),\n+        STDOUT_WRITE(ProcessCommand::stdoutWrite),\n+        STDOUT_CLOSE(ProcessCommand::stdoutClose),\n+        STDOUT_EXPECT_POLO(ProcessCommand::stdoutExpectPolo),\n+        STDERR_EXPECT_POLO(ProcessCommand::stderrExpectPolo),\n+        STDOUT_EXPECT_EMPTY(ProcessCommand::stdoutExpectEmpty),\n+        STDERR_EXPECT_EMPTY(ProcessCommand::stderrExpectEmpty),\n+        ;\n+        private final Consumer<Process> command;\n+\n+        ProcessCommand(Consumer<Process> command) {\n+            this.command = command;\n+        }\n+\n+        private static void stdoutPrintAllLines(Process p) {\n+            try {\n+                var lines = p.inputReader().readAllLines();\n+                Assertions.assertNotEquals(0, lines.size(), \"stdout should not be empty\");\n+                System.err.printf(\"        %d lines\\n\", lines.size());\n+                System.err.println(lines.toString().indent(8));\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void stderrPrintAllLines(Process p) {\n+            try {\n+                var lines = p.errorReader().readAllLines();\n+                Assertions.assertNotEquals(0, lines.size(), \"stderr should not be empty\");\n+                System.err.printf(\"        %d lines\\n\", lines.size());\n+                System.err.println(lines.toString().indent(8));\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void writerWrite(Process p) {\n+            try {\n+                p.outputWriter().write(\"Now is the time.\");\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void writerClose(Process p) {\n+            try {\n+                p.outputWriter().close();\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void stdoutExpectPolo(Process p) {\n+            String line = readLine(p.getInputStream());\n+            Assertions.assertEquals(\"Polo\", line, \"Stdout Expected Polo\");\n+        }\n+\n+        private static void stderrExpectPolo(Process p) {\n+            String line = readLine(p.getErrorStream());\n+            Assertions.assertEquals(\"Polo\", line, \"Stderr Expected Empty\");        }\n+\n+        private static void stdoutExpectEmpty(Process p) {\n+            String line = readLine(p.getInputStream());\n+            Assertions.assertEquals(\"\", line, \"Stdout Expected Empty\");\n+        }\n+\n+        private static void stderrExpectEmpty(Process p) {\n+            String line = readLine(p.getErrorStream());\n+            Assertions.assertEquals(\"\", line, \"Stderr Expected Polo\");        }\n+\n+        private static String readLine(InputStream in) {\n+            StringBuilder sb = new StringBuilder();\n+            byte[] bytes = new byte[1];\n+            try {\n+                int ch;\n+                while ((ch = in.read()) != -1) {\n+                    if (ch == '\\n') {\n+                        \/\/ end of line\n+                        return sb.toString();\n+                    }\n+                    if (ch != '\\r') {       \/\/ ignore cr - Windows defense\n+                        sb.append((char) ch);\n+                    }\n+                }\n+                \/\/ EOF - return string if no LF found\n+                return sb.toString();\n+            } catch (IOException ioe) {\n+                return ioe.getMessage();\n+            }\n+        }\n+\n+        private static void stdoutWrite(Process p) {\n+            try {\n+                var out = p.getOutputStream();\n+                out.write(\"stdout-write\".getBytes(StandardCharsets.UTF_8));\n+                out.flush();\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void stdoutClose(Process p) {\n+            try {\n+                p.getOutputStream().close();\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        \/\/ Expect a normal exit\n+        private static void processExpectExitNormal(Process p) {\n+            processExpectExit(p, ExitStatus.NORMAL);\n+        }\n+\n+        \/\/ expect an error (1) status\n+        private static void processExpectExitFail(Process p) {\n+            processExpectExit(p, ExitStatus.FAIL);\n+        }\n+\n+        \/\/ Process.processExpectExitNormal an expected status\n+        private static void processExpectExit(Process p, ExitStatus expected) {\n+            while (true) {\n+                try {\n+                    int st = p.waitFor();\n+                    expected.assertEquals(st);\n+                    break;\n+                } catch (InterruptedException ie) {\n+                    \/\/ retry above\n+                }\n+            }\n+        }\n+\n+        private static void processClose(Process p) {\n+            p.close();\n+        }\n+\n+        private static void processDestroy(Process p) {\n+            p.destroy();\n+        }\n+    }\n+\n+    \/\/ Commands to Java child sent as command line arguments\n+    enum ChildCommand {\n+        STDOUT_ECHO(ChildCommand::stdoutEchoBytes),\n+        STDERR_ECHO(ChildCommand::stderrEchoBytes),\n+        SLEEP5(ChildCommand::sleep5),\n+        STDOUT_MARCO(ChildCommand::stdoutMarco),\n+        STDERR_MARCO(ChildCommand::stderrMarco),\n+        PROCESS_EXIT1(ChildCommand::processExit1),\n+        ;\n+        private final Runnable command;\n+        ChildCommand(Runnable cmd) {\n+            this.command = cmd;\n+        }\n+\n+        private static void sleep5() {\n+            try {\n+                Thread.sleep(5_000);\n+            } catch (InterruptedException ie) {\n+                \/\/ Interrupted sleep, re-assert interrupt\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+\n+        private static void stdoutEchoBytes() {\n+            echoBytes(System.in, System.out);\n+        }\n+\n+        private static void stderrEchoBytes() {\n+            echoBytes(System.in, System.err);\n+        }\n+\n+        private static void echoBytes(InputStream in, PrintStream out) {\n+            try {\n+                byte[] bytes = in.readAllBytes();\n+                out.write(bytes);\n+            } catch (IOException ioe) {\n+                out.println(ioe);\n+            }\n+        }\n+\n+        private static void stdoutMarco() {\n+            System.out.println(\"Polo\");\n+        }\n+\n+        private static void stderrMarco() {\n+            System.err.println(\"Polo\");\n+        }\n+\n+        private static void processExit1() {\n+            System.exit(1);\n+        }\n+    }\n+\n+    \/\/ Copy of ProcessExamples in java\/lang\/snippet-files\/ProcessExamples.java\n+    @Test\n+    void example() {\n+        String haiku = \"\"\"\n+                Oh, the sunrise glow;\n+                Paddling with the river flow;\n+                Chilling still, go slow.\n+                \"\"\";\n+        try (Process p = new ProcessBuilder(\"cat\").start();\n+             Writer writer = p.outputWriter();\n+             Reader reader = p.inputReader()) {\n+            writer.write(haiku);\n+            writer.close();\n+            \/\/ Read all lines and print each\n+            reader.readAllLines()\n+                    .forEach(System.err::println);\n+            var status = p.waitFor();\n+            if (status != 0)\n+                throw new RuntimeException(\"unexpected process status: \" + status);\n+        } catch (Exception e) {\n+            System.err.println(\"Process failed: \" + e);\n+        }\n+    }\n+\n+    \/**\n+     * Child program that executes child actions as named by command line args.\n+     * @param childCommands a sequence of ChildCommand names.\n+     *\/\n+    public static void main(String... childCommands)  {\n+        List<String> args = List.of(childCommands);\n+        List<ChildCommand> cmds = args.stream().map(ChildCommand::valueOf).toList();\n+        cmds.forEach(c -> c.command.run());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/Process\/ProcessCloseTest.java","additions":476,"deletions":0,"binary":false,"changes":476,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+############################################################\n+#  Enable logging java.lang.Process to the console\n+############################################################\n+\n+handlers= java.util.logging.ConsoleHandler\n+\n+java.util.logging.ConsoleHandler.level = ALL\n+java.lang.Process.level=FINE\n","filename":"test\/jdk\/java\/lang\/Process\/ProcessLogging-FINE.properties","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"}]}