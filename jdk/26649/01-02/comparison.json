{"files":[{"patch":"@@ -161,0 +161,1 @@\n+    private volatile boolean closed;     \/\/ true if close() has been called\n@@ -627,0 +628,1 @@\n+     * This method is idempotent, if the stream is already closed invoking this method has no effect.\n@@ -634,1 +636,2 @@\n-     * Any {@code IOException} that occurs when closing a stream is ignored.\n+     * Any {@code IOException} that occurs when closing a stream is\n+     * re-thrown after the process is destroyed.\n@@ -649,0 +652,1 @@\n+     * @throws IOException if any of the stream closes throws an exception\n@@ -651,5 +655,10 @@\n-    public void close() {\n-        \/\/ Close each stream\n-        quietClose(outputWriter != null ? outputWriter : getOutputStream());\n-        quietClose(inputReader != null ? inputReader  : getInputStream());\n-        quietClose(errorReader != null ? errorReader : getErrorStream());\n+    public void close() throws IOException {\n+        synchronized(this) {\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n+            \/\/ Close each stream\n+            IOException ioe = quietClose(outputWriter != null ? outputWriter : getOutputStream(), null);\n+            ioe = quietClose(inputReader != null ? inputReader : getInputStream(), ioe);\n+            ioe = quietClose(errorReader != null ? errorReader : getErrorStream(), ioe);\n@@ -657,1 +666,5 @@\n-        destroy();      \/\/ no-op if process is not alive\n+            destroy();      \/\/ no-op if process is not alive\n+            if (ioe != null) {\n+                throw ioe;\n+            }\n+        }\n@@ -660,2 +673,4 @@\n-    \/\/ Quietly close and log exception\n-    private void quietClose(Closeable c) {\n+    \/\/ Quietly close.\n+    \/\/ If an IOException occurs and it is the first, return it.\n+    \/\/ Otherwise, add the exception as a suppressed exception to the first.\n+    private IOException quietClose(Closeable c, IOException firstIOE) {\n@@ -664,0 +679,1 @@\n+            return firstIOE;\n@@ -665,2 +681,6 @@\n-            LOGGER.get().log(System.Logger.Level.DEBUG,\n-                    \"Exception closing process: pid: \" + pid() , ioe);\n+            if (firstIOE == null) {\n+                return ioe;\n+            } else {\n+                firstIOE.addSuppressed(ioe);\n+                return firstIOE;\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -31,0 +31,5 @@\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FilterInputStream;\n+import java.io.FilterOutputStream;\n@@ -33,0 +38,1 @@\n+import java.io.OutputStream;\n@@ -37,0 +43,2 @@\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n@@ -47,0 +55,1 @@\n+ * @modules java.base\/java.io:+open\n@@ -48,2 +57,1 @@\n- * @run junit\/othervm -Djava.util.logging.config.file=${test.src}\/ProcessLogging-FINE.properties\n- *       jdk.java.lang.Process.ProcessCloseTest\n+ * @run junit\/othervm jdk.java.lang.Process.ProcessCloseTest\n@@ -54,0 +62,1 @@\n+    private final static boolean OS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n@@ -237,1 +246,0 @@\n-     *\n@@ -245,0 +253,3 @@\n+        PROCESS_FORCE_OUT_CLOSE_EXCEPTION(ProcessCommand::processForceOutCloseException),\n+        PROCESS_FORCE_IN_CLOSE_EXCEPTION(ProcessCommand::processForceInCloseException),\n+        PROCESS_FORCE_ERROR_CLOSE_EXCEPTION(ProcessCommand::processForceErrorCloseException),\n@@ -320,1 +331,0 @@\n-            byte[] bytes = new byte[1];\n@@ -381,1 +391,5 @@\n-            p.close();\n+            try {\n+                p.close();\n+            } catch (IOException ioe) {\n+                Assertions.fail(ioe);\n+            }\n@@ -387,0 +401,15 @@\n+\n+        private static void processForceOutCloseException(Process p) {\n+            var out = p.getOutputStream();\n+            closeOutputStreamPrematurely(out);\n+        }\n+\n+        private static void processForceInCloseException(Process p) {\n+            var in = p.getInputStream();\n+            closeInputStreamPrematurely(in);\n+        }\n+\n+        private static void processForceErrorCloseException(Process p) {\n+            var err = p.getErrorStream();\n+            closeInputStreamPrematurely(err);\n+        }\n@@ -442,0 +471,157 @@\n+    static Stream<Arguments> closeExceptions() {\n+        return Stream.of(\n+                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\")),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\")),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\")),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\",\n+                                \"Bad file descriptor\",\n+                                \"Bad file descriptor\")),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\",\n+                                \"Bad file descriptor\")),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\",\n+                                \"Bad file descriptor\")),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\",\n+                                \"Bad file descriptor\")),\n+                Arguments.of(List.of(\"echo\", \"xyz1\"),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\"))\n+        );\n+    }\n+    \/**\n+     * Test AutoCloseable for the process and out, in, and err streams.\n+     * @param args The command line arguments\n+     * @param commands the commands to the process\n+     * @param exitStatus The expected final exit status\n+     *\/\n+    @ParameterizedTest()\n+    @MethodSource(\"closeExceptions\")\n+    void testStreamsCloseThrowing(List<String> args, List<ProcessCommand> commands,\n+                                  ExitStatus exitStatus, List<String> expectedMessages) {\n+        ProcessBuilder pb = new ProcessBuilder(args);\n+        Process proc = null;\n+        IOException expectedIOE = null;\n+        try (Process p = pb.start()) {\n+            proc = p;\n+            System.err.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+            commands.forEach(c -> {\n+                System.err.printf(\"    %s\\n\", c);\n+                c.command.accept(p);\n+            });\n+        } catch (IOException ioe) {\n+            expectedIOE = ioe;\n+        }\n+        Assertions.assertNotNull(expectedIOE, \"Missing IOException\");\n+        \/\/ Check each exception that it is expected\n+        Assertions.assertEquals(expectedMessages.getFirst(), expectedIOE.getMessage(),\n+                \"Unexpected exception message\");\n+        var suppressedEx = expectedIOE.getSuppressed();\n+        Assertions.assertEquals(expectedMessages.size() - 1, suppressedEx.length,\n+                \"Number of suppressed exceptions\");\n+        for (int i = 1; i < expectedMessages.size(); i++) {\n+            Assertions.assertEquals(expectedMessages.get(i),\n+                    suppressedEx[i - 1].getMessage(),\n+                    \"Unexpected suppressed exception message\");\n+        }\n+        Assertions.assertNotNull(proc, \"Process is null\");\n+        ProcessCommand.processExpectExit(proc, exitStatus);\n+    }\n+\n+    \/*\n+     * Invasive hack to force closing a FileDescriptor to throw an exception on FileDescriptor.close().\n+     * The output stream is pealed back to get the FileDescriptor containing the fd or handle.\n+     * On Linux, the existing fd is closed to prevent a leak and the fd is replaced by a bad fd.\n+     * On Windows, the existing handle is closed\n+     * @param an OutputStream from Process.getOutputStream\n+     *\/\n+    private static void closeOutputStreamPrematurely(OutputStream out) {\n+        try {\n+            Field fosOutField = FilterOutputStream.class.getDeclaredField(\"out\");\n+            fosOutField.setAccessible(true);\n+            FileOutputStream pipeOut = (FileOutputStream) fosOutField.get(out);\n+\n+            Field fosFdField = FileOutputStream.class.getDeclaredField(\"fd\");\n+            fosFdField.setAccessible(true);\n+            FileDescriptor fileDescriptor = (FileDescriptor) fosFdField.get(pipeOut);\n+            closeFDPrematurely(fileDescriptor);\n+        } catch (Exception ex) {\n+            Assertions.fail(\"Failed to setup OutputStream FileDescriptor for bad close\", ex);\n+        }\n+    }\n+\n+    \/*\n+     * Invasive hack to force closing a FileDescriptor to throw an exception on FileDescriptor.close().\n+     * The output stream is pealed back to get the FileDescriptor containing the fd or handle.\n+     * On Linux, the existing fd is closed to prevent a leak and the fd is replaced by a bad fd.\n+     * On Windows, the existing handle is closed\n+     * @param an OutputStream from Process.getOutputStream\n+     *\/\n+    private static void closeInputStreamPrematurely(InputStream in) {\n+        try {\n+            Field fisInField = FilterInputStream.class.getDeclaredField(\"in\");\n+            fisInField.setAccessible(true);\n+            FileInputStream pipeIn = (FileInputStream) fisInField.get(in);\n+\n+            Field fisFdField = FileInputStream.class.getDeclaredField(\"fd\");\n+            fisFdField.setAccessible(true);\n+            FileDescriptor fileDescriptor = (FileDescriptor) fisFdField.get(pipeIn);\n+            closeFDPrematurely(fileDescriptor);\n+        } catch (Exception ex) {\n+            Assertions.fail(\"Failed to setup InputStream FileDescriptor for bad close\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * Close the FileDescriptor and reset the fd or handle to cause an IOException when closed again.\n+     * On Linux, the FileDescriptor fd is closed to prevent a leak and the fd is restored to the same fd.\n+     * On Windows, the existing handle is closed and the handle is restored.\n+     * Closing the fd or the handle again throws an IOException\n+     * @param fileDescriptor FileDescriptor from a process input or output stream\n+     * @throws Exception if setup or invoking close fails\n+     *\/\n+    private static void closeFDPrematurely(FileDescriptor fileDescriptor) throws Exception {\n+        Method fdCloseMethod = FileDescriptor.class.getDeclaredMethod(\"close\");\n+        fdCloseMethod.setAccessible(true);\n+\n+        if (OS_WINDOWS) {\n+            Field fdHandleField = FileDescriptor.class.getDeclaredField(\"handle\");\n+            fdHandleField.setAccessible(true);\n+            final long handle = (long) fdHandleField.get(fileDescriptor);\n+            System.err.printf(\"FileDescriptor.handle: %08x%n\", handle);\n+            \/\/ Close the known handle\n+            \/\/ And restore the handle so normal close() will throw an exception\n+            fdCloseMethod.invoke(fileDescriptor);\n+            fdHandleField.set(fileDescriptor, handle);\n+            System.err.printf(\"FileDescriptor.handle to close again and fail: %08x%n\", handle);\n+        } else {\n+            \/\/ Linux\n+            Field fdFdField = FileDescriptor.class.getDeclaredField(\"fd\");\n+            fdFdField.setAccessible(true);\n+            final int fd = (int) fdFdField.get(fileDescriptor);\n+            System.err.printf(\"FileDescriptor.fd: %08x%n\", fd);\n+            \/\/ Close the known fd\n+            \/\/ And restore the fd so normal close() will throw an exception\n+            fdCloseMethod.invoke(fileDescriptor);\n+            fdFdField.set(fileDescriptor, fd);\n+            System.err.printf(\"FileDescriptor.fd to close again and fail: %08x%n\", fd);\n+        }\n+    }\n+\n@@ -472,2 +658,2 @@\n-        List<ChildCommand> cmds = args.stream().map(ChildCommand::valueOf).toList();\n-        cmds.forEach(c -> c.command.run());\n+        List<ChildCommand> commands = args.stream().map(ChildCommand::valueOf).toList();\n+        commands.forEach(c -> c.command.run());\n","filename":"test\/jdk\/java\/lang\/Process\/ProcessCloseTest.java","additions":193,"deletions":7,"binary":false,"changes":200,"status":"modified"}]}