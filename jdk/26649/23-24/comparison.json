{"files":[{"patch":"@@ -31,3 +31,0 @@\n-import java.io.FileDescriptor;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n@@ -44,1 +41,0 @@\n-import java.lang.reflect.Method;\n@@ -60,1 +56,1 @@\n- * @modules java.base\/java.io:+open\n+ * @modules java.base\/java.lang:+open java.base\/java.io:+open\n@@ -67,0 +63,1 @@\n+    public static final String FORCED_CLOSE_MSG = \"Forced close\";\n@@ -436,3 +433,11 @@\n-        private static void processForceOutCloseException(Process p) {\n-            var out = p.getOutputStream();\n-            closeOutputStreamPrematurely(out);\n+        \/\/ Interpose an input stream that throws on close()\n+        private static void processForceInCloseException(Process p) {\n+            try {\n+                synchronized (p) {\n+                    Field stdinField = p.getClass().getDeclaredField(OS_WINDOWS ? \"stdin_stream\" : \"stdin\");\n+                    stdinField.setAccessible(true);\n+                    stdinField.set(p, new ThrowingOutputStream((OutputStream) stdinField.get(p)));\n+                }\n+            } catch (Exception ex) {\n+                Assertions.fail(\"Failed to setup InputStream for throwing close\", ex);\n+            }\n@@ -441,3 +446,11 @@\n-        private static void processForceInCloseException(Process p) {\n-            var in = p.getInputStream();\n-            closeInputStreamPrematurely(in);\n+        \/\/ Interpose an output stream that throws on close()\n+        private static void processForceOutCloseException(Process p) {\n+            try {\n+                synchronized (p) {\n+                    Field stdoutField = p.getClass().getDeclaredField(OS_WINDOWS ? \"stdout_stream\" : \"stdout\");\n+                    stdoutField.setAccessible(true);\n+                    stdoutField.set(p, new ThrowingInputStream((InputStream) stdoutField.get(p)));\n+                }\n+            } catch (Exception ex) {\n+                Assertions.fail(\"Failed to setup OutputStream throwing close\", ex);\n+            }\n@@ -446,0 +459,1 @@\n+        \/\/ Interpose an error stream that throws on close()\n@@ -447,2 +461,9 @@\n-            var err = p.getErrorStream();\n-            closeInputStreamPrematurely(err);\n+            try {\n+                synchronized (p) {\n+                    Field stderrField = p.getClass().getDeclaredField(OS_WINDOWS ? \"stderr_stream\" : \"stderr\");\n+                    stderrField.setAccessible(true);\n+                    stderrField.set(p, new ThrowingInputStream((InputStream) stderrField.get(p)));\n+                }\n+            } catch (Exception ex) {\n+                Assertions.fail(\"Failed to setup OutputStream for throwing close\", ex);\n+            }\n@@ -548,1 +569,0 @@\n-        final String badFDMsg = OS_WINDOWS ? \"The handle is invalid\" : \"Bad file descriptor\";\n@@ -552,1 +572,1 @@\n-                        List.of(ExitStatus.RACY), List.of(badFDMsg)),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG)),\n@@ -555,1 +575,1 @@\n-                        List.of(ExitStatus.RACY), List.of(badFDMsg)),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG)),\n@@ -558,1 +578,1 @@\n-                        List.of(ExitStatus.RACY), List.of(badFDMsg)),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG)),\n@@ -563,1 +583,1 @@\n-                        List.of(ExitStatus.RACY), List.of(badFDMsg, badFDMsg, badFDMsg)),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG, FORCED_CLOSE_MSG, FORCED_CLOSE_MSG)),\n@@ -567,1 +587,1 @@\n-                        List.of(ExitStatus.RACY), List.of(badFDMsg, badFDMsg)),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG, FORCED_CLOSE_MSG)),\n@@ -571,1 +591,1 @@\n-                        List.of(ExitStatus.RACY), List.of(badFDMsg, badFDMsg)),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG, FORCED_CLOSE_MSG)),\n@@ -575,1 +595,1 @@\n-                        List.of(ExitStatus.RACY), List.of(badFDMsg, badFDMsg)),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG, FORCED_CLOSE_MSG)),\n@@ -578,1 +598,1 @@\n-                        List.of(ExitStatus.RACY), List.of(badFDMsg))\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG))\n@@ -628,6 +648,2 @@\n-    \/*\n-     * Invasive hack to force closing a FileDescriptor to throw an exception on FileDescriptor.close().\n-     * The output stream is pealed back to get the FileDescriptor containing the fd or handle.\n-     * On Linux, the existing fd is closed to prevent a leak and the fd is replaced by a bad fd.\n-     * On Windows, the existing handle is closed\n-     * @param an OutputStream from Process.getOutputStream\n+    \/**\n+     * An OutputStream that delegates to another stream and always throws IOException on close().\n@@ -635,12 +651,3 @@\n-    private static void closeOutputStreamPrematurely(OutputStream out) {\n-        try {\n-            Field fosOutField = FilterOutputStream.class.getDeclaredField(\"out\");\n-            fosOutField.setAccessible(true);\n-            FileOutputStream pipeOut = (FileOutputStream) fosOutField.get(out);\n-\n-            Field fosFdField = FileOutputStream.class.getDeclaredField(\"fd\");\n-            fosFdField.setAccessible(true);\n-            FileDescriptor fileDescriptor = (FileDescriptor) fosFdField.get(pipeOut);\n-            closeFDPrematurely(fileDescriptor);\n-        } catch (Exception ex) {\n-            Assertions.fail(\"Failed to setup OutputStream FileDescriptor for bad close\", ex);\n+    private static class ThrowingOutputStream extends FilterOutputStream {\n+        public ThrowingOutputStream(OutputStream out) {\n+            super(out);\n@@ -648,1 +655,0 @@\n-    }\n@@ -650,14 +656,7 @@\n-    \/*\n-     * Invasive hack to force closing a FileDescriptor to throw an exception on FileDescriptor.close().\n-     * The input stream is pealed back to get the FileDescriptor containing the fd or handle.\n-     * On Linux, the existing fd is closed to prevent a leak and the fd is replaced by a bad fd.\n-     * On Windows, the existing handle is closed\n-     * @param in an InputStream from Process.getInputStream\n-     *\/\n-    private static void closeInputStreamPrematurely(InputStream in) {\n-        try {\n-            if (in instanceof FilterInputStream fis) {\n-                \/\/ On Linux and Mac, the pipe is wrapped in a ProcessPipeInputStream (a FilterInputStream)\n-                Field fisInField = FilterInputStream.class.getDeclaredField(\"in\");\n-                fisInField.setAccessible(true);\n-                in = (FileInputStream) fisInField.get(fis);\n+        @Override\n+        public void close() throws IOException {\n+            try {\n+                out.close();\n+            } catch (IOException ioe) {\n+                \/\/ ignore except to log the exception; may be useful to debug\n+                ioe.printStackTrace(System.err);\n@@ -665,7 +664,1 @@\n-            FileInputStream pipeIn = (FileInputStream) in;\n-            Field fisFdField = FileInputStream.class.getDeclaredField(\"fd\");\n-            fisFdField.setAccessible(true);\n-            FileDescriptor fileDescriptor = (FileDescriptor) fisFdField.get(pipeIn);\n-            closeFDPrematurely(fileDescriptor);\n-        } catch (Exception ex) {\n-            Assertions.fail(\"Failed to setup InputStream FileDescriptor for bad close\", ex);\n+            throw new IOException(FORCED_CLOSE_MSG);\n@@ -676,6 +669,1 @@\n-     * Close the FileDescriptor and reset the fd or handle to cause an IOException when closed again.\n-     * On Linux, the FileDescriptor fd is closed to prevent a leak and the fd is restored to the same fd.\n-     * On Windows, the existing handle is closed and the handle is restored.\n-     * Closing the fd or the handle again throws an IOException\n-     * @param fileDescriptor FileDescriptor from a process input or output stream\n-     * @throws Exception if setup or invoking close fails\n+     * An InputStream that delegates to another stream and always throws IOException on close().\n@@ -683,25 +671,14 @@\n-    private static void closeFDPrematurely(FileDescriptor fileDescriptor) throws Exception {\n-        Method fdCloseMethod = FileDescriptor.class.getDeclaredMethod(\"close\");\n-        fdCloseMethod.setAccessible(true);\n-\n-        if (OS_WINDOWS) {\n-            Field fdHandleField = FileDescriptor.class.getDeclaredField(\"handle\");\n-            fdHandleField.setAccessible(true);\n-            final long handle = (long) fdHandleField.get(fileDescriptor);\n-            Log.printf(\"FileDescriptor.handle: %08x%n\", handle);\n-            \/\/ Close the known handle\n-            \/\/ And restore the handle so normal close() will throw an exception\n-            fdCloseMethod.invoke(fileDescriptor);\n-            fdHandleField.set(fileDescriptor, handle);\n-            Log.printf(\"FileDescriptor.handle to close again and fail: %08x%n\", handle);\n-        } else {\n-            \/\/ Linux\n-            Field fdFdField = FileDescriptor.class.getDeclaredField(\"fd\");\n-            fdFdField.setAccessible(true);\n-            final int fd = (int) fdFdField.get(fileDescriptor);\n-            Log.printf(\"FileDescriptor.fd: %08x%n\", fd);\n-            \/\/ Close the known fd\n-            \/\/ And restore the fd so normal close() will throw an exception\n-            fdCloseMethod.invoke(fileDescriptor);\n-            fdFdField.set(fileDescriptor, fd);\n-            Log.printf(\"FileDescriptor.fd to close again and fail: %08x%n\", fd);\n+    private static class ThrowingInputStream extends FilterInputStream {\n+        public ThrowingInputStream(InputStream in) {\n+            super(in);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            try {\n+                in.close();\n+            } catch (IOException ioe) {\n+                \/\/ ignore except to log the exception; may be useful to debug\n+                ioe.printStackTrace(System.err);\n+            }\n+            throw new IOException(FORCED_CLOSE_MSG);\n","filename":"test\/jdk\/java\/lang\/Process\/ProcessCloseTest.java","additions":70,"deletions":93,"binary":false,"changes":163,"status":"modified"}]}