{"files":[{"patch":"@@ -90,0 +90,1 @@\n+ * {@linkplain #close() close},\n@@ -102,1 +103,4 @@\n- * or readers, or they have been closed.\n+ * or readers, or they have been closed. {@linkplain Process#close close()} closes\n+ * all the streams and terminates the process. Using try-with-resources to\n+ * {@linkplain ProcessBuilder#start()} the process can ensure the process\n+ * is terminated when the try-with-resources block exits.\n@@ -117,2 +121,2 @@\n- *     Process process = pb.start();\n- *     try (BufferedReader in = process.inputReader()) {\n+ *     try (Process process = pb.start();\n+ *          BufferedReader in = process.inputReader()) {\n@@ -142,1 +146,1 @@\n-public abstract class Process {\n+public abstract class Process implements Closeable {\n@@ -152,0 +156,1 @@\n+    private volatile boolean closed;     \/\/ true if close() has been called\n@@ -615,0 +620,69 @@\n+    \/**\n+     * Close all writer and reader streams and terminate the process.\n+     * The streams are closed immediately and the process is terminated without waiting.\n+     * This method is idempotent, if the process has already been closed\n+     * invoking this method has no effect.\n+     * <p>\n+     * Before calling {@code close} the caller should read the streams for any\n+     * data or text and call {@linkplain #waitFor() waitFor} if the exit value is needed.\n+     * The contents of streams that have not been read fully are lost;\n+     * they are discarded or ignored.\n+     * Streams should be {@code closed} when no longer needed.\n+     * Closing an already closed stream usually has no effect but is specific to the stream.\n+     * If an {@code IOException} occurs when closing a stream it is\n+     * re-thrown after the process is destroyed. Additional {@code IOExceptions}\n+     * thrown by closing the remaining streams, if any, are added to the first\n+     * {@code IOException} as {@linkplain IOException#addSuppressed suppressed exceptions}.\n+     * <p>\n+     * The process may already have exited or be in the process of exiting;\n+     * if it is {@linkplain #isAlive() alive}, it is {@linkplain #destroy destroyed}.\n+     * <p>\n+     * Example using try-with-resources writing text to a process, reading back the\n+     * response, and closing the streams and process:\n+     * {@snippet class=ProcessExamples region=example}\n+     *\n+     * @implSpec\n+     * The {@code outputWriter} and {@code outputStream} to the process are closed.\n+     * The {@code inputReader} and {@code inputStream} from the process are closed.\n+     * The {@code errorReader} and {@code errorStream} from the process are closed.\n+     * The process is destroyed.\n+     * @throws IOException if closing any of the streams throws an exception\n+     * @since 26\n+     *\/\n+    @Override\n+    public void close() throws IOException {\n+        synchronized(this) {\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n+            \/\/ Close each stream\n+            IOException ioe = quietClose(outputWriter != null ? outputWriter : getOutputStream(), null);\n+            ioe = quietClose(inputReader != null ? inputReader : getInputStream(), ioe);\n+            ioe = quietClose(errorReader != null ? errorReader : getErrorStream(), ioe);\n+\n+            destroy();      \/\/ no-op if process is not alive\n+            if (ioe != null) {\n+                throw ioe;\n+            }\n+        }\n+    }\n+\n+    \/\/ Quietly close.\n+    \/\/ If an IOException occurs and it is the first, return it.\n+    \/\/ Otherwise, add the exception as a suppressed exception to the first.\n+    private IOException quietClose(Closeable c, IOException firstIOE) {\n+        try {\n+            c.close();\n+            return firstIOE;\n+        } catch (IOException ioe) {\n+            if (firstIOE == null) {\n+                return ioe;\n+            } else {\n+                firstIOE.addSuppressed(ioe);\n+                return firstIOE;\n+            }\n+        }\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":78,"deletions":4,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.Reader;\n+import java.io.Writer;\n+\n+public class ProcessExamples {\n+    \/\/ @start region=example\n+    void example() {\n+        try (Process p = new ProcessBuilder(\"cat\").start();\n+             Writer writer = p.outputWriter();\n+             Reader reader = p.inputReader()) {\n+            writer.write(haiku);\n+            writer.close();\n+            \/\/ Read all lines and print each\n+            reader.readAllLines()\n+                    .forEach(System.err::println);\n+            var status = p.waitFor();\n+            if (status != 0)\n+                throw new RuntimeException(\"unexpected process status: \" + status);\n+        } catch (Exception e) {\n+            System.out.println(\"Process failed: \" + e);\n+        }\n+    }\n+\n+    static final String haiku = \"\"\"\n+                Oh, the sunrise glow;\n+                Paddling with the river flow;\n+                Chilling still, go slow.\n+                \"\"\";\n+    \/\/ @end region=example\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/snippet-files\/ProcessExamples.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,662 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.java.lang.Process;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FilterInputStream;\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @bug 8336479\n+ * @modules java.base\/java.io:+open\n+ * @summary Tests for Process.close\n+ * @run junit\/othervm jdk.java.lang.Process.ProcessCloseTest\n+ *\/\n+\n+public class ProcessCloseTest {\n+\n+    private final static boolean OS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+    private static List<String> JAVA_ARGS;\n+\n+    private static List<String> setupJavaEXE() {\n+        String JAVA_HOME = System.getProperty(\"test.jdk\");\n+        if (JAVA_HOME == null)\n+            JAVA_HOME = System.getProperty(\"JAVA_HOME\");\n+        String classPath = System.getProperty(\"test.class.path\");\n+        return  List.of(JAVA_HOME + \"\/bin\/java\", \"-cp\", classPath, ProcessCloseTest.class.getName());\n+    }\n+\n+    private static List<String> javaArgs(ChildCommand... moreArgs) {\n+\n+        List<String> javaArgs = JAVA_ARGS;\n+        if (javaArgs == null) {\n+            JAVA_ARGS = javaArgs = setupJavaEXE();\n+        }\n+        List<String> args = new ArrayList<>(javaArgs);\n+        for (ChildCommand arg : moreArgs) {\n+            args.add(arg.toString());\n+        }\n+        return args;\n+    }\n+\n+    \/**\n+     * {@return A Stream of Arguments}\n+     * Each Argument consists of three elements.\n+     * - A List of command line arguments to start a process.\n+     *   `javaArgs can be used to launch a Java child with ChildCommands\n+     * - A List of ProcessCommand actions to be invoked on that process\n+     * - A expected final ExitStatus\n+     * @return\n+     *\/\n+    static Stream<Arguments> singleThreadTestCases() {\n+        return Stream.of(\n+                Arguments.of(List.of(\"echo\", \"xyz0\"),\n+                        List.of(ProcessCommand.STDOUT_PRINT_ALL_LINES,\n+                                ProcessCommand.STDERR_EXPECT_EMPTY,\n+                                ProcessCommand.PROCESS_EXPECT_EXIT_NORMAL),\n+                        ExitStatus.NORMAL),\n+                Arguments.of(List.of(\"echo\", \"xyz1\"),\n+                        List.of(ProcessCommand.STDOUT_PRINT_ALL_LINES),\n+                        ExitStatus.RACY),\n+                Arguments.of(List.of(\"cat\", \"-\"),\n+                        List.of(ProcessCommand.WRITER_WRITE,\n+                                ProcessCommand.WRITER_CLOSE,\n+                                ProcessCommand.STDOUT_PRINT_ALL_LINES),\n+                        ExitStatus.RACY),\n+                Arguments.of(List.of(\"cat\", \"-\"),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.STDOUT_CLOSE,\n+                                ProcessCommand.STDOUT_PRINT_ALL_LINES),\n+                        ExitStatus.RACY),\n+                Arguments.of(List.of(\"cat\", \"-\"),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.STDOUT_CLOSE,\n+                                ProcessCommand.PROCESS_EXPECT_EXIT_NORMAL),\n+                        ExitStatus.NORMAL),\n+                Arguments.of(List.of(\"cat\", \"NoSuchFile.txt\"),\n+                        List.of(ProcessCommand.STDERR_PRINT_ALL_LINES,\n+                                ProcessCommand.STDOUT_EXPECT_EMPTY),\n+                        ExitStatus.RACY),\n+                Arguments.of(javaArgs(ChildCommand.STDOUT_MARCO),\n+                        List.of(ProcessCommand.STDOUT_EXPECT_POLO,\n+                                ProcessCommand.STDERR_EXPECT_EMPTY),\n+                        ExitStatus.RACY),\n+                Arguments.of(javaArgs(ChildCommand.STDERR_MARCO),\n+                        List.of(ProcessCommand.STDERR_EXPECT_POLO,\n+                                ProcessCommand.STDOUT_EXPECT_EMPTY),\n+                        ExitStatus.NORMAL),\n+                Arguments.of(javaArgs(ChildCommand.PROCESS_EXIT1),\n+                        List.of(ProcessCommand.PROCESS_EXPECT_EXIT_FAIL),\n+                        ExitStatus.FAIL),       \/\/ Got expected status == 1\n+                Arguments.of(List.of(\"echo\", \"abc\"),\n+                        List.of(ProcessCommand.PROCESS_CLOSE),\n+                        ExitStatus.RACY), \/\/ Racy, not deterministic\n+                Arguments.of(List.of(\"cat\", \"-\"),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.PROCESS_CLOSE),\n+                        ExitStatus.RACY),  \/\/ Racy, not deterministic\n+                Arguments.of(List.of(\"echo\", \"abc\"),\n+                        List.of(ProcessCommand.PROCESS_DESTROY),\n+                        ExitStatus.RACY), \/\/ Racy, not deterministic\n+                Arguments.of(List.of(\"cat\", \"-\"),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.PROCESS_DESTROY),\n+                        ExitStatus.RACY), \/\/ Racy, not deterministic\n+                Arguments.of(List.of(\"echo\"),\n+                        List.of(ProcessCommand.PROCESS_EXPECT_EXIT_NORMAL),\n+                        ExitStatus.RACY)\n+        );\n+    }\n+\n+\n+    @ParameterizedTest\n+    @MethodSource(\"singleThreadTestCases\")\n+    void simple(List<String> args, List<ProcessCommand> commands, ExitStatus exitStatus) throws IOException {\n+        ProcessBuilder pb = new ProcessBuilder(args);\n+        Process p = pb.start();\n+        System.err.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+        commands.forEach(c -> {\n+            System.err.printf(\"    %s\\n\", c);\n+            c.command.accept(p);\n+        });\n+        p.close();\n+        ProcessCommand.processExpectExit(p, exitStatus);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"singleThreadTestCases\")\n+    void autoCloseable(List<String> args, List<ProcessCommand> commands, ExitStatus exitStatus) {\n+        ProcessBuilder pb = new ProcessBuilder(args);\n+        Process proc = null;\n+        try (Process p = pb.start()) {\n+            proc = p;\n+            System.err.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+            commands.forEach(c -> {\n+                System.err.printf(\"    %s\\n\", c);\n+                c.command.accept(p);\n+            });\n+        } catch (IOException ioe) {\n+            Assertions.fail(ioe);\n+        }\n+        ProcessCommand.processExpectExit(proc, exitStatus);\n+    }\n+\n+\n+    \/**\n+     * Test AutoCloseable for the process and out, in, and err streams.\n+     * @param args The command line arguments\n+     * @param commands the commands to the process\n+     * @param exitStatus The expected final exit status\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"singleThreadTestCases\")\n+    void autoCloseableAll(List<String> args, List<ProcessCommand> commands, ExitStatus exitStatus) {\n+        ProcessBuilder pb = new ProcessBuilder(args);\n+        Process proc = null;\n+        try (Process p = pb.start(); var out = p.getOutputStream();\n+             var in = p.getInputStream();\n+             var err = p.getErrorStream()) {\n+            proc = p;\n+            System.err.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+            commands.forEach(c -> {\n+                System.err.printf(\"    %s\\n\", c);\n+                c.command.accept(p);\n+            });\n+        } catch (IOException ioe) {\n+            Assertions.fail(ioe);\n+        }\n+        ProcessCommand.processExpectExit(proc, exitStatus);\n+    }\n+\n+\n+        \/\/ ExitStatus named values and assertions\n+    enum ExitStatus {\n+        NORMAL(0),\n+        FAIL(1),\n+        PIPE(1, 141),\n+        KILLED(0, 143),\n+        RACY(0, 1, 143),\n+        ;\n+        private final int[] allowedStatus;\n+\n+        ExitStatus(int... status) {\n+            this.allowedStatus = status;\n+        }\n+\n+        \/\/ Check a status matches one of the allowed exit status values\n+        void assertEquals(int actual) {\n+            for (int status : allowedStatus) {\n+                if (status == actual) {\n+                    return;     \/\/ status is expected\n+                }\n+            }\n+            if (this == RACY) {\n+                \/\/ Not an error but report the actual status\n+                System.err.printf(\"Racy exit status: %d\\n\", actual);\n+            } else {\n+                Assertions.fail(\"Status: \" + actual + \", expected one of: \" + Arrays.toString(allowedStatus));\n+            }\n+        }\n+    }\n+    \/**\n+     * Commands on a Process that can be sequenced in the parent.\n+     * See ChildCommands for commands that can be sent to the child process.\n+     *\/\n+    enum ProcessCommand {\n+        PROCESS_EXPECT_EXIT_NORMAL(ProcessCommand::processExpectExitNormal),\n+        PROCESS_EXPECT_EXIT_FAIL(ProcessCommand::processExpectExitFail),\n+        PROCESS_CLOSE(ProcessCommand::processClose),\n+        PROCESS_DESTROY(ProcessCommand::processDestroy),\n+        PROCESS_FORCE_OUT_CLOSE_EXCEPTION(ProcessCommand::processForceOutCloseException),\n+        PROCESS_FORCE_IN_CLOSE_EXCEPTION(ProcessCommand::processForceInCloseException),\n+        PROCESS_FORCE_ERROR_CLOSE_EXCEPTION(ProcessCommand::processForceErrorCloseException),\n+        WRITER_WRITE(ProcessCommand::writerWrite),\n+        WRITER_CLOSE(ProcessCommand::writerClose),\n+        STDOUT_PRINT_ALL_LINES(ProcessCommand::stdoutPrintAllLines),\n+        STDERR_PRINT_ALL_LINES(ProcessCommand::stderrPrintAllLines),\n+        STDOUT_WRITE(ProcessCommand::stdoutWrite),\n+        STDOUT_CLOSE(ProcessCommand::stdoutClose),\n+        STDOUT_EXPECT_POLO(ProcessCommand::stdoutExpectPolo),\n+        STDERR_EXPECT_POLO(ProcessCommand::stderrExpectPolo),\n+        STDOUT_EXPECT_EMPTY(ProcessCommand::stdoutExpectEmpty),\n+        STDERR_EXPECT_EMPTY(ProcessCommand::stderrExpectEmpty),\n+        ;\n+        private final Consumer<Process> command;\n+\n+        ProcessCommand(Consumer<Process> command) {\n+            this.command = command;\n+        }\n+\n+        private static void stdoutPrintAllLines(Process p) {\n+            try {\n+                var lines = p.inputReader().readAllLines();\n+                Assertions.assertNotEquals(0, lines.size(), \"stdout should not be empty\");\n+                System.err.printf(\"        %d lines\\n\", lines.size());\n+                System.err.println(lines.toString().indent(8));\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void stderrPrintAllLines(Process p) {\n+            try {\n+                var lines = p.errorReader().readAllLines();\n+                Assertions.assertNotEquals(0, lines.size(), \"stderr should not be empty\");\n+                System.err.printf(\"        %d lines\\n\", lines.size());\n+                System.err.println(lines.toString().indent(8));\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void writerWrite(Process p) {\n+            try {\n+                p.outputWriter().write(\"Now is the time.\");\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void writerClose(Process p) {\n+            try {\n+                p.outputWriter().close();\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void stdoutExpectPolo(Process p) {\n+            String line = readLine(p.getInputStream());\n+            Assertions.assertEquals(\"Polo\", line, \"Stdout Expected Polo\");\n+        }\n+\n+        private static void stderrExpectPolo(Process p) {\n+            String line = readLine(p.getErrorStream());\n+            Assertions.assertEquals(\"Polo\", line, \"Stderr Expected Empty\");        }\n+\n+        private static void stdoutExpectEmpty(Process p) {\n+            String line = readLine(p.getInputStream());\n+            Assertions.assertEquals(\"\", line, \"Stdout Expected Empty\");\n+        }\n+\n+        private static void stderrExpectEmpty(Process p) {\n+            String line = readLine(p.getErrorStream());\n+            Assertions.assertEquals(\"\", line, \"Stderr Expected Polo\");\n+        }\n+\n+        private static String readLine(InputStream in) {\n+            StringBuilder sb = new StringBuilder();\n+            try {\n+                int ch;\n+                while ((ch = in.read()) != -1) {\n+                    if (ch == '\\n') {\n+                        \/\/ end of line\n+                        return sb.toString();\n+                    }\n+                    if (ch != '\\r') {       \/\/ ignore cr - Windows defense\n+                        sb.append((char) ch);\n+                    }\n+                }\n+                \/\/ EOF - return string if no LF found\n+                return sb.toString();\n+            } catch (IOException ioe) {\n+                return ioe.getMessage();\n+            }\n+        }\n+\n+        private static void stdoutWrite(Process p) {\n+            try {\n+                var out = p.getOutputStream();\n+                out.write(\"stdout-write\".getBytes(StandardCharsets.UTF_8));\n+                out.flush();\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void stdoutClose(Process p) {\n+            try {\n+                p.getOutputStream().close();\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        \/\/ Expect a normal exit\n+        private static void processExpectExitNormal(Process p) {\n+            processExpectExit(p, ExitStatus.NORMAL);\n+        }\n+\n+        \/\/ expect an error (1) status\n+        private static void processExpectExitFail(Process p) {\n+            processExpectExit(p, ExitStatus.FAIL);\n+        }\n+\n+        \/\/ Process.processExpectExitNormal an expected status\n+        private static void processExpectExit(Process p, ExitStatus expected) {\n+            try {\n+                int st = p.waitFor();\n+                expected.assertEquals(st);\n+            } catch (InterruptedException ie) {\n+                Assertions.fail(\"Unexpected InterruptedException\");\n+            }\n+        }\n+\n+        private static void processClose(Process p) {\n+            try {\n+                p.close();\n+            } catch (IOException ioe) {\n+                Assertions.fail(ioe);\n+            }\n+        }\n+\n+        private static void processDestroy(Process p) {\n+            p.destroy();\n+        }\n+\n+        private static void processForceOutCloseException(Process p) {\n+            var out = p.getOutputStream();\n+            closeOutputStreamPrematurely(out);\n+        }\n+\n+        private static void processForceInCloseException(Process p) {\n+            var in = p.getInputStream();\n+            closeInputStreamPrematurely(in);\n+        }\n+\n+        private static void processForceErrorCloseException(Process p) {\n+            var err = p.getErrorStream();\n+            closeInputStreamPrematurely(err);\n+        }\n+    }\n+\n+    \/\/ Commands to Java child sent as command line arguments\n+    enum ChildCommand {\n+        STDOUT_ECHO(ChildCommand::stdoutEchoBytes),\n+        STDERR_ECHO(ChildCommand::stderrEchoBytes),\n+        SLEEP5(ChildCommand::sleep5),\n+        STDOUT_MARCO(ChildCommand::stdoutMarco),\n+        STDERR_MARCO(ChildCommand::stderrMarco),\n+        PROCESS_EXIT1(ChildCommand::processExit1),\n+        ;\n+        private final Runnable command;\n+        ChildCommand(Runnable cmd) {\n+            this.command = cmd;\n+        }\n+\n+        private static void sleep5() {\n+            try {\n+                Thread.sleep(5_000);\n+            } catch (InterruptedException ie) {\n+                \/\/ Interrupted sleep, re-assert interrupt\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+\n+        private static void stdoutEchoBytes() {\n+            echoBytes(System.in, System.out);\n+        }\n+\n+        private static void stderrEchoBytes() {\n+            echoBytes(System.in, System.err);\n+        }\n+\n+        private static void echoBytes(InputStream in, PrintStream out) {\n+            try {\n+                byte[] bytes = in.readAllBytes();\n+                out.write(bytes);\n+            } catch (IOException ioe) {\n+                out.println(ioe);\n+            }\n+        }\n+\n+        private static void stdoutMarco() {\n+            System.out.println(\"Polo\");\n+        }\n+\n+        private static void stderrMarco() {\n+            System.err.println(\"Polo\");\n+        }\n+\n+        private static void processExit1() {\n+            System.exit(1);\n+        }\n+    }\n+\n+    static Stream<Arguments> closeExceptions() {\n+        return Stream.of(\n+                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\")),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\")),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\")),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\",\n+                                \"Bad file descriptor\",\n+                                \"Bad file descriptor\")),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\",\n+                                \"Bad file descriptor\")),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\",\n+                                \"Bad file descriptor\")),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP5),\n+                        List.of(ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\",\n+                                \"Bad file descriptor\")),\n+                Arguments.of(List.of(\"echo\", \"xyz1\"),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION),\n+                        ExitStatus.RACY, List.of(\"Bad file descriptor\"))\n+        );\n+    }\n+    \/**\n+     * Test AutoCloseable for the process and out, in, and err streams.\n+     * @param args The command line arguments\n+     * @param commands the commands to the process\n+     * @param exitStatus The expected final exit status\n+     *\/\n+    @ParameterizedTest()\n+    @MethodSource(\"closeExceptions\")\n+    void testStreamsCloseThrowing(List<String> args, List<ProcessCommand> commands,\n+                                  ExitStatus exitStatus, List<String> expectedMessages) {\n+        ProcessBuilder pb = new ProcessBuilder(args);\n+        Process proc = null;\n+        IOException expectedIOE = null;\n+        try (Process p = pb.start()) {\n+            proc = p;\n+            System.err.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+            commands.forEach(c -> {\n+                System.err.printf(\"    %s\\n\", c);\n+                c.command.accept(p);\n+            });\n+        } catch (IOException ioe) {\n+            expectedIOE = ioe;\n+        }\n+        Assertions.assertNotNull(expectedIOE, \"Missing IOException\");\n+        \/\/ Check each exception that it is expected\n+        Assertions.assertEquals(expectedMessages.getFirst(), expectedIOE.getMessage(),\n+                \"Unexpected exception message\");\n+        var suppressedEx = expectedIOE.getSuppressed();\n+        Assertions.assertEquals(expectedMessages.size() - 1, suppressedEx.length,\n+                \"Number of suppressed exceptions\");\n+        for (int i = 1; i < expectedMessages.size(); i++) {\n+            Assertions.assertEquals(expectedMessages.get(i),\n+                    suppressedEx[i - 1].getMessage(),\n+                    \"Unexpected suppressed exception message\");\n+        }\n+        Assertions.assertNotNull(proc, \"Process is null\");\n+        ProcessCommand.processExpectExit(proc, exitStatus);\n+    }\n+\n+    \/*\n+     * Invasive hack to force closing a FileDescriptor to throw an exception on FileDescriptor.close().\n+     * The output stream is pealed back to get the FileDescriptor containing the fd or handle.\n+     * On Linux, the existing fd is closed to prevent a leak and the fd is replaced by a bad fd.\n+     * On Windows, the existing handle is closed\n+     * @param an OutputStream from Process.getOutputStream\n+     *\/\n+    private static void closeOutputStreamPrematurely(OutputStream out) {\n+        try {\n+            Field fosOutField = FilterOutputStream.class.getDeclaredField(\"out\");\n+            fosOutField.setAccessible(true);\n+            FileOutputStream pipeOut = (FileOutputStream) fosOutField.get(out);\n+\n+            Field fosFdField = FileOutputStream.class.getDeclaredField(\"fd\");\n+            fosFdField.setAccessible(true);\n+            FileDescriptor fileDescriptor = (FileDescriptor) fosFdField.get(pipeOut);\n+            closeFDPrematurely(fileDescriptor);\n+        } catch (Exception ex) {\n+            Assertions.fail(\"Failed to setup OutputStream FileDescriptor for bad close\", ex);\n+        }\n+    }\n+\n+    \/*\n+     * Invasive hack to force closing a FileDescriptor to throw an exception on FileDescriptor.close().\n+     * The output stream is pealed back to get the FileDescriptor containing the fd or handle.\n+     * On Linux, the existing fd is closed to prevent a leak and the fd is replaced by a bad fd.\n+     * On Windows, the existing handle is closed\n+     * @param an OutputStream from Process.getOutputStream\n+     *\/\n+    private static void closeInputStreamPrematurely(InputStream in) {\n+        try {\n+            Field fisInField = FilterInputStream.class.getDeclaredField(\"in\");\n+            fisInField.setAccessible(true);\n+            FileInputStream pipeIn = (FileInputStream) fisInField.get(in);\n+\n+            Field fisFdField = FileInputStream.class.getDeclaredField(\"fd\");\n+            fisFdField.setAccessible(true);\n+            FileDescriptor fileDescriptor = (FileDescriptor) fisFdField.get(pipeIn);\n+            closeFDPrematurely(fileDescriptor);\n+        } catch (Exception ex) {\n+            Assertions.fail(\"Failed to setup InputStream FileDescriptor for bad close\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * Close the FileDescriptor and reset the fd or handle to cause an IOException when closed again.\n+     * On Linux, the FileDescriptor fd is closed to prevent a leak and the fd is restored to the same fd.\n+     * On Windows, the existing handle is closed and the handle is restored.\n+     * Closing the fd or the handle again throws an IOException\n+     * @param fileDescriptor FileDescriptor from a process input or output stream\n+     * @throws Exception if setup or invoking close fails\n+     *\/\n+    private static void closeFDPrematurely(FileDescriptor fileDescriptor) throws Exception {\n+        Method fdCloseMethod = FileDescriptor.class.getDeclaredMethod(\"close\");\n+        fdCloseMethod.setAccessible(true);\n+\n+        if (OS_WINDOWS) {\n+            Field fdHandleField = FileDescriptor.class.getDeclaredField(\"handle\");\n+            fdHandleField.setAccessible(true);\n+            final long handle = (long) fdHandleField.get(fileDescriptor);\n+            System.err.printf(\"FileDescriptor.handle: %08x%n\", handle);\n+            \/\/ Close the known handle\n+            \/\/ And restore the handle so normal close() will throw an exception\n+            fdCloseMethod.invoke(fileDescriptor);\n+            fdHandleField.set(fileDescriptor, handle);\n+            System.err.printf(\"FileDescriptor.handle to close again and fail: %08x%n\", handle);\n+        } else {\n+            \/\/ Linux\n+            Field fdFdField = FileDescriptor.class.getDeclaredField(\"fd\");\n+            fdFdField.setAccessible(true);\n+            final int fd = (int) fdFdField.get(fileDescriptor);\n+            System.err.printf(\"FileDescriptor.fd: %08x%n\", fd);\n+            \/\/ Close the known fd\n+            \/\/ And restore the fd so normal close() will throw an exception\n+            fdCloseMethod.invoke(fileDescriptor);\n+            fdFdField.set(fileDescriptor, fd);\n+            System.err.printf(\"FileDescriptor.fd to close again and fail: %08x%n\", fd);\n+        }\n+    }\n+\n+    \/\/ Copy of ProcessExamples in java\/lang\/snippet-files\/ProcessExamples.java\n+    @Test\n+    void example() {\n+        try (Process p = new ProcessBuilder(\"cat\").start();\n+             Writer writer = p.outputWriter();\n+             Reader reader = p.inputReader()) {\n+            writer.write(haiku);\n+            writer.close();\n+            \/\/ Read all lines and print each\n+            reader.readAllLines()\n+                    .forEach(System.err::println);\n+            var status = p.waitFor();\n+            if (status != 0)\n+                throw new RuntimeException(\"unexpected process status: \" + status);\n+        } catch (Exception e) {\n+            System.err.println(\"Process failed: \" + e);\n+        }\n+    }\n+\n+    String haiku = \"\"\"\n+                Oh, the sunrise glow;\n+                Paddling with the river flow;\n+                Chilling still, go slow.\n+                \"\"\";\n+\n+    \/**\n+     * Child program that executes child actions as named by command line args.\n+     * @param childCommands a sequence of ChildCommand names.\n+     *\/\n+    public static void main(String... childCommands)  {\n+        List<String> args = List.of(childCommands);\n+        List<ChildCommand> commands = args.stream().map(ChildCommand::valueOf).toList();\n+        commands.forEach(c -> c.command.run());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/Process\/ProcessCloseTest.java","additions":662,"deletions":0,"binary":false,"changes":662,"status":"added"}]}