{"files":[{"patch":"@@ -241,0 +241,1 @@\n+        java.naming,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,4 @@\n+import java.lang.ref.Cleaner.Cleanable;\n+import java.lang.ref.Reference;\n+import jdk.internal.ref.CleanerFactory;\n+\n@@ -45,3 +49,0 @@\n-    private boolean cleaned = false;\n-    private LdapResult res;\n-    private LdapClient enumClnt;\n@@ -52,1 +53,1 @@\n-    protected LdapCtx homeCtx;\n+\n@@ -56,0 +57,43 @@\n+    \/* Context class containing the pieces of state that need to be cleaned up (or\n+     * are needed for cleanup). It gets registered with Cleaner to perform cleanup.\n+     *\n+     * reachabilityFences are used to ensure that an AbstractLdapNamingEnumeration\n+     * instance does not become unreachable while one of its methods is still\n+     * executing (possibly leading to EnumCtx being cleaned up while it's still in use).\n+     * The fences also ensure that changes made to mutable state on the\n+     * main\/program thread are visible on the cleanup thread. See\n+     * \"Memory Consistency Properties\" in the java.lang.ref package spec.\n+     *\/\n+    private static class EnumCtx implements Runnable {\n+        private LdapCtx homeCtx;\n+        private LdapResult res;\n+        private LdapClient enumClnt;\n+\n+        private EnumCtx(LdapCtx homeCtx, LdapResult answer, LdapClient client) {\n+            this.homeCtx = homeCtx;\n+            this.res = answer;\n+            this.enumClnt = client;\n+        }\n+\n+        @Override\n+        public void run() {\n+            if (enumClnt != null) {\n+                if (homeCtx != null) {\n+                    enumClnt.clearSearchReply(res, homeCtx.reqCtls);\n+                }\n+                enumClnt = null;\n+            }\n+            if (homeCtx != null) {\n+                homeCtx.decEnumCount();\n+                homeCtx = null;\n+            }\n+        }\n+    }\n+\n+    private final EnumCtx enumCtx;\n+    private final Cleanable cleanable;\n+\n+    \/\/ Subclasses interact directly with the LdapCtx. This method provides\n+    \/\/ access to the LdapCtx within the EnumCtx.\n+    protected final LdapCtx getHomeCtx() { return enumCtx.homeCtx; }\n+\n@@ -87,1 +131,0 @@\n-            res = answer;\n@@ -97,0 +140,1 @@\n+            this.enumCtx = new EnumCtx(homeCtx, answer, homeCtx.clnt);\n@@ -98,3 +142,2 @@\n-            this.homeCtx = homeCtx;\n-            homeCtx.incEnumCount();\n-            enumClnt = homeCtx.clnt; \/\/ remember\n+            this.enumCtx.homeCtx.incEnumCount();\n+            this.cleanable = CleanerFactory.cleaner().register(this, this.enumCtx);\n@@ -111,0 +154,3 @@\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n@@ -122,0 +168,3 @@\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n@@ -129,0 +178,6 @@\n+        try {\n+            enumCtx.res = enumCtx.homeCtx.getSearchReply(enumCtx.enumClnt, enumCtx.res);\n+            if (enumCtx.res == null) {\n+                limit = posn = 0;\n+                return;\n+            }\n@@ -130,9 +185,3 @@\n-        res = homeCtx.getSearchReply(enumClnt, res);\n-        if (res == null) {\n-            limit = posn = 0;\n-            return;\n-        }\n-\n-        entries = res.entries;\n-        limit = (entries == null) ? 0 : entries.size(); \/\/ handle empty set\n-        posn = 0; \/\/ reset\n+            entries = enumCtx.res.entries;\n+            limit = (entries == null) ? 0 : entries.size(); \/\/ handle empty set\n+            posn = 0; \/\/ reset\n@@ -140,5 +189,5 @@\n-        \/\/ minimize the number of calls to processReturnCode()\n-        \/\/ (expensive when batchSize is small and there are many results)\n-        if ((res.status != LdapClient.LDAP_SUCCESS) ||\n-            ((res.status == LdapClient.LDAP_SUCCESS) &&\n-                (res.referrals != null))) {\n+            \/\/ minimize the number of calls to processReturnCode()\n+            \/\/ (expensive when batchSize is small and there are many results)\n+            if ((enumCtx.res.status != LdapClient.LDAP_SUCCESS) ||\n+                ((enumCtx.res.status == LdapClient.LDAP_SUCCESS) &&\n+                    (enumCtx.res.referrals != null))) {\n@@ -146,3 +195,3 @@\n-            try {\n-                \/\/ convert referrals into a chain of LdapReferralException\n-                homeCtx.processReturnCode(res, listArg);\n+                try {\n+                    \/\/ convert referrals into a chain of LdapReferralException\n+                    enumCtx.homeCtx.processReturnCode(enumCtx.res, listArg);\n@@ -150,2 +199,2 @@\n-            } catch (LimitExceededException | PartialResultException e) {\n-                setNamingException(e);\n+                } catch (LimitExceededException | PartialResultException e) {\n+                    setNamingException(e);\n@@ -153,0 +202,1 @@\n+                }\n@@ -154,1 +204,0 @@\n-        }\n@@ -156,6 +205,8 @@\n-        \/\/ merge any newly received referrals with any current referrals\n-        if (res.refEx != null) {\n-            if (refEx == null) {\n-                refEx = res.refEx;\n-            } else {\n-                refEx = refEx.appendUnprocessedReferrals(res.refEx);\n+            \/\/ merge any newly received referrals with any current referrals\n+            if (enumCtx.res.refEx != null) {\n+                if (refEx == null) {\n+                    refEx = enumCtx.res.refEx;\n+                } else {\n+                    refEx = refEx.appendUnprocessedReferrals(enumCtx.res.refEx);\n+                }\n+                enumCtx.res.refEx = null; \/\/ reset\n@@ -163,2 +214,0 @@\n-            res.refEx = null; \/\/ reset\n-        }\n@@ -166,2 +215,6 @@\n-        if (res.resControls != null) {\n-            homeCtx.respCtls = res.resControls;\n+            if (enumCtx.res.resControls != null) {\n+                enumCtx.homeCtx.respCtls = enumCtx.res.resControls;\n+            }\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n@@ -179,0 +232,4 @@\n+        try {\n+            if (hasMoreCalled) {\n+                return more;\n+            }\n@@ -180,5 +237,1 @@\n-        if (hasMoreCalled) {\n-            return more;\n-        }\n-\n-        hasMoreCalled = true;\n+            hasMoreCalled = true;\n@@ -186,4 +239,8 @@\n-        if (!more) {\n-            return false;\n-        } else {\n-            return (more = hasMoreImpl());\n+            if (!more) {\n+                return false;\n+            } else {\n+                return (more = hasMoreImpl());\n+            }\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n@@ -198,3 +255,9 @@\n-\n-        if (!hasMoreCalled) {\n-            hasMore();\n+        try {\n+            if (!hasMoreCalled) {\n+                hasMore();\n+            }\n+            hasMoreCalled = false;\n+            return nextImpl();\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n@@ -202,2 +265,0 @@\n-        hasMoreCalled = false;\n-        return nextImpl();\n@@ -210,18 +271,10 @@\n-        \/\/ when page size is supported, this\n-        \/\/ might generate an exception while attempting\n-        \/\/ to fetch the next batch to determine\n-        \/\/ whether there are any more elements\n-\n-        \/\/ test if the current set of entries has been processed\n-        if (posn == limit) {\n-            getNextBatch();\n-        }\n-\n-        \/\/ test if any unprocessed entries exist\n-        if (posn < limit) {\n-            return true;\n-        } else {\n-\n-            try {\n-                \/\/ try to process another referral\n-                return hasMoreReferrals();\n+        try {\n+            \/\/ when page size is supported, this\n+            \/\/ might generate an exception while attempting\n+            \/\/ to fetch the next batch to determine\n+            \/\/ whether there are any more elements\n+\n+            \/\/ test if the current set of entries has been processed\n+            if (posn == limit) {\n+                getNextBatch();\n+            }\n@@ -229,5 +282,4 @@\n-            } catch (LdapReferralException |\n-                     LimitExceededException |\n-                     PartialResultException e) {\n-                cleanup();\n-                throw e;\n+            \/\/ test if any unprocessed entries exist\n+            if (posn < limit) {\n+                return true;\n+            } else {\n@@ -235,5 +287,16 @@\n-            } catch (NamingException e) {\n-                cleanup();\n-                PartialResultException pre = new PartialResultException();\n-                pre.setRootCause(e);\n-                throw pre;\n+                try {\n+                    \/\/ try to process another referral\n+                    return hasMoreReferrals();\n+\n+                } catch (LdapReferralException |\n+                        LimitExceededException |\n+                        PartialResultException e) {\n+                    cleanup();\n+                    throw e;\n+\n+                } catch (NamingException e) {\n+                    cleanup();\n+                    PartialResultException pre = new PartialResultException();\n+                    pre.setRootCause(e);\n+                    throw pre;\n+                }\n@@ -241,0 +304,3 @@\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n@@ -253,0 +319,3 @@\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n@@ -257,3 +326,4 @@\n-        if (posn == limit) {\n-            getNextBatch();  \/\/ updates posn and limit\n-        }\n+        try {\n+            if (posn == limit) {\n+                getNextBatch();  \/\/ updates posn and limit\n+            }\n@@ -261,4 +331,4 @@\n-        if (posn >= limit) {\n-            cleanup();\n-            throw new NoSuchElementException(\"invalid enumeration handle\");\n-        }\n+            if (posn >= limit) {\n+                cleanup();\n+                throw new NoSuchElementException(\"invalid enumeration handle\");\n+            }\n@@ -266,1 +336,1 @@\n-        LdapEntry result = entries.elementAt(posn++);\n+            LdapEntry result = entries.elementAt(posn++);\n@@ -268,2 +338,6 @@\n-        \/\/ gets and outputs DN from the entry\n-        return createItem(result.DN, result.attributes, result.respCtls);\n+            \/\/ gets and outputs DN from the entry\n+            return createItem(result.DN, result.attributes, result.respCtls);\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n+        }\n@@ -281,0 +355,1 @@\n+        \/\/ No fences - method clearly does not access cleanable state\n@@ -292,4 +367,9 @@\n-        if (refEx != null) {\n-            refEx = refEx.appendUnprocessedReferrals(ex);\n-        } else {\n-            refEx = ex.appendUnprocessedReferrals(refEx);\n+        try {\n+            if (refEx != null) {\n+                refEx = refEx.appendUnprocessedReferrals(ex);\n+            } else {\n+                refEx = ex.appendUnprocessedReferrals(refEx);\n+            }\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n@@ -301,0 +381,1 @@\n+        \/\/ No fences - method clearly does not access cleanable state\n@@ -312,0 +393,3 @@\n+        try {\n+            if ((refEx != null) && !(errEx instanceof LimitExceededException) &&\n+                (refEx.hasMoreReferrals() || refEx.hasMoreReferralExceptions())) {\n@@ -313,9 +397,3 @@\n-        if ((refEx != null) && !(errEx instanceof LimitExceededException) &&\n-            (refEx.hasMoreReferrals() || refEx.hasMoreReferralExceptions())) {\n-\n-            if (homeCtx.handleReferrals == LdapClient.LDAP_REF_THROW) {\n-                throw (NamingException)(refEx.fillInStackTrace());\n-            }\n-\n-            \/\/ process the referrals sequentially\n-            while (true) {\n+                if (enumCtx.homeCtx.handleReferrals == LdapClient.LDAP_REF_THROW) {\n+                    throw (NamingException)(refEx.fillInStackTrace());\n+                }\n@@ -323,3 +401,2 @@\n-                LdapReferralContext refCtx =\n-                    (LdapReferralContext)refEx.getReferralContext(\n-                    homeCtx.envprops, homeCtx.reqCtls);\n+                \/\/ process the referrals sequentially\n+                while (true) {\n@@ -327,1 +404,3 @@\n-                try {\n+                    LdapReferralContext refCtx =\n+                        (LdapReferralContext)refEx.getReferralContext(\n+                        enumCtx.homeCtx.envprops, enumCtx.homeCtx.reqCtls);\n@@ -329,2 +408,1 @@\n-                    update(getReferredResults(refCtx));\n-                    break;\n+                    try {\n@@ -332,6 +410,1 @@\n-                } catch (LdapReferralException re) {\n-\n-                    \/\/ record a previous exception and quit if any limit is reached\n-                    var namingException = re.getNamingException();\n-                    if (namingException instanceof LimitExceededException) {\n-                        errEx = namingException;\n+                        update(getReferredResults(refCtx));\n@@ -339,5 +412,0 @@\n-                    } else if (errEx == null) {\n-                        errEx = namingException;\n-                    }\n-                    refEx = re;\n-                    continue;\n@@ -345,3 +413,16 @@\n-                } finally {\n-                    \/\/ Make sure we close referral context\n-                    refCtx.close();\n+                    } catch (LdapReferralException re) {\n+                        \/\/ record a previous exception and quit if any limit is reached\n+                        var namingException = re.getNamingException();\n+                        if (namingException instanceof LimitExceededException) {\n+                            errEx = namingException;\n+                            break;\n+                        } else if (errEx == null) {\n+                            errEx = namingException;\n+                        }\n+                        refEx = re;\n+                        continue;\n+\n+                    } finally {\n+                        \/\/ Make sure we close referral context\n+                        refCtx.close();\n+                    }\n@@ -349,2 +430,1 @@\n-            }\n-            return hasMoreImpl();\n+                return hasMoreImpl();\n@@ -352,2 +432,2 @@\n-        } else {\n-            cleanup();\n+            } else {\n+                cleanup();\n@@ -355,2 +435,4 @@\n-            if (errEx != null) {\n-                throw errEx;\n+                if (errEx != null) {\n+                    throw errEx;\n+                }\n+                return (false);\n@@ -358,1 +440,3 @@\n-            return (false);\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n@@ -367,22 +451,29 @@\n-        \/\/ Cleanup previous context first\n-        homeCtx.decEnumCount();\n-\n-        \/\/ New enum will have already incremented enum count and recorded clnt\n-        homeCtx = ne.homeCtx;\n-        enumClnt = ne.enumClnt;\n-\n-        \/\/ Do this to prevent referral enumeration (ne) from decrementing\n-        \/\/ enum count because we'll be doing that here from this\n-        \/\/ enumeration.\n-        ne.homeCtx = null;\n-\n-        \/\/ Record rest of information from new enum\n-        posn = ne.posn;\n-        limit = ne.limit;\n-        res = ne.res;\n-        entries = ne.entries;\n-        refEx = ne.refEx;\n-        listArg = ne.listArg;\n-        \/\/ record a previous exception and quit if any limit is reached\n-        if (errEx == null || ne.errEx instanceof LimitExceededException) {\n-            errEx = ne.errEx;\n+        try {\n+            \/\/ Cleanup previous context first\n+            getHomeCtx().decEnumCount();\n+\n+            \/\/ New enum will have already incremented enum count and recorded clnt\n+            enumCtx.homeCtx = ne.enumCtx.homeCtx;\n+            enumCtx.enumClnt = ne.enumCtx.enumClnt;\n+\n+            \/\/ 'this' and 'ne' now both refer to ne's homeCtx. 'this' will\n+            \/\/ decrement homeCtx's enum count later (via cleanup() or Cleaner).\n+            \/\/ Clear ne's reference to homeCtx so ne's Cleaner doesn't\n+            \/\/ *also* decrement the count.\n+            ne.enumCtx.homeCtx = null;\n+\n+            \/\/ Record rest of information from new enum\n+            posn = ne.posn;\n+            limit = ne.limit;\n+            enumCtx.res = ne.enumCtx.res;\n+            entries = ne.entries;\n+            refEx = ne.refEx;\n+            listArg = ne.listArg;\n+            \/\/ record a previous exception and quit if any limit is reached\n+            if (errEx == null || ne.errEx instanceof LimitExceededException) {\n+                errEx = ne.errEx;\n+            }\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(ne);\n+            Reference.reachabilityFence(this);\n@@ -392,5 +483,0 @@\n-    @SuppressWarnings(\"removal\")\n-    protected final void finalize() {\n-        cleanup();\n-    }\n-\n@@ -398,12 +484,2 @@\n-        if (cleaned) return; \/\/ been there; done that\n-\n-        if(enumClnt != null) {\n-            enumClnt.clearSearchReply(res, homeCtx.reqCtls);\n-        }\n-\n-        enumClnt = null;\n-        cleaned = true;\n-        if (homeCtx != null) {\n-            homeCtx.decEnumCount();\n-            homeCtx = null;\n-        }\n+        \/\/ Run the cleaning action (if it has not run already)\n+        cleanable.clean();\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/AbstractLdapNamingEnumeration.java","additions":246,"deletions":170,"binary":false,"changes":416,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.lang.ref.Reference;\n@@ -50,0 +51,4 @@\n+        try {\n+            Object obj = null;\n+            String atom = getAtom(dn);\n+            LdapCtx homeCtx = getHomeCtx();\n@@ -51,11 +56,8 @@\n-        Object obj = null;\n-        String atom = getAtom(dn);\n-\n-        if (attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME]) != null) {\n-            \/\/ serialized object or object reference\n-            obj = Obj.decodeObject(attrs);\n-        }\n-        if (obj == null) {\n-            \/\/ DirContext object\n-            obj = new LdapCtx(homeCtx, dn);\n-        }\n+            if (attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME]) != null) {\n+                \/\/ serialized object or object reference\n+                obj = Obj.decodeObject(attrs);\n+            }\n+            if (obj == null) {\n+                \/\/ DirContext object\n+                obj = new LdapCtx(homeCtx, dn);\n+            }\n@@ -63,2 +65,2 @@\n-        CompositeName cn = new CompositeName();\n-        cn.add(atom);\n+            CompositeName cn = new CompositeName();\n+            cn.add(atom);\n@@ -66,3 +68,3 @@\n-        try {\n-            obj = NamingManagerHelper.getDirObjectInstance(obj, cn, homeCtx,\n-                    homeCtx.envprops, attrs, ObjectFactoriesFilter::checkLdapFilter);\n+            try {\n+                obj = NamingManagerHelper.getDirObjectInstance(obj, cn, homeCtx,\n+                        homeCtx.envprops, attrs, ObjectFactoriesFilter::checkLdapFilter);\n@@ -70,2 +72,2 @@\n-        } catch (NamingException e) {\n-            throw e;\n+            } catch (NamingException e) {\n+                throw e;\n@@ -73,7 +75,7 @@\n-        } catch (Exception e) {\n-            NamingException ne =\n-                new NamingException(\n-                        \"problem generating object using object factory\");\n-            ne.setRootCause(e);\n-            throw ne;\n-        }\n+            } catch (Exception e) {\n+                NamingException ne =\n+                    new NamingException(\n+                            \"problem generating object using object factory\");\n+                ne.setRootCause(e);\n+                throw ne;\n+            }\n@@ -81,6 +83,12 @@\n-        Binding binding;\n-        if (respCtls != null) {\n-           binding = new BindingWithControls(cn.toString(), obj,\n-                                homeCtx.convertControls(respCtls));\n-        } else {\n-            binding = new Binding(cn.toString(), obj);\n+            Binding binding;\n+            if (respCtls != null) {\n+                binding = new BindingWithControls(cn.toString(), obj,\n+                                     homeCtx.convertControls(respCtls));\n+            } else {\n+                binding = new Binding(cn.toString(), obj);\n+            }\n+            binding.setNameInNamespace(dn);\n+            return binding;\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n@@ -88,2 +96,0 @@\n-        binding.setNameInNamespace(dn);\n-        return binding;\n@@ -95,2 +101,7 @@\n-        \/\/ repeat the original operation at the new context\n-        return (AbstractLdapNamingEnumeration<? extends NameClassPair>)refCtx.listBindings(listArg);\n+        try {\n+            \/\/ repeat the original operation at the new context\n+            return (AbstractLdapNamingEnumeration<? extends NameClassPair>) refCtx.listBindings(listArg);\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n+        }\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapBindingEnumeration.java","additions":47,"deletions":36,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-\n+import java.lang.ref.Reference;\n@@ -49,0 +49,4 @@\n+        try {\n+            LdapCtx homeCtx = getHomeCtx();\n+            Attribute attr;\n+            String className = null;\n@@ -50,11 +54,8 @@\n-        Attribute attr;\n-        String className = null;\n-\n-        \/\/ use the Java classname if present\n-        if ((attr = attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME])) != null) {\n-            className = (String)attr.get();\n-        } else {\n-            className = defaultClassName;\n-        }\n-        CompositeName cn = new CompositeName();\n-        cn.add(getAtom(dn));\n+            \/\/ use the Java classname if present\n+            if ((attr = attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME])) != null) {\n+                className = (String) attr.get();\n+            } else {\n+                className = defaultClassName;\n+            }\n+            CompositeName cn = new CompositeName();\n+            cn.add(getAtom(dn));\n@@ -62,3 +63,3 @@\n-        NameClassPair ncp;\n-        if (respCtls != null) {\n-            ncp = new NameClassPairWithControls(\n+            NameClassPair ncp;\n+            if (respCtls != null) {\n+                ncp = new NameClassPairWithControls(\n@@ -67,2 +68,8 @@\n-        } else {\n-            ncp = new NameClassPair(cn.toString(), className);\n+            } else {\n+                ncp = new NameClassPair(cn.toString(), className);\n+            }\n+            ncp.setNameInNamespace(dn);\n+            return ncp;\n+        }  finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n@@ -70,2 +77,0 @@\n-        ncp.setNameInNamespace(dn);\n-        return ncp;\n@@ -77,2 +82,7 @@\n-        \/\/ repeat the original operation at the new context\n-        return (AbstractLdapNamingEnumeration<? extends NameClassPair>)refCtx.list(listArg);\n+        try {\n+            \/\/ repeat the original operation at the new context\n+            return (AbstractLdapNamingEnumeration<? extends NameClassPair>)refCtx.list(listArg);\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n+        }\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapNamingEnumeration.java","additions":32,"deletions":22,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.lang.ref.Reference;\n@@ -55,0 +56,4 @@\n+        \/\/ No reachabilityFence here for now.\n+        \/\/ super() call (aka AbstrctLdapNamingEnumeration ctor) keeps 'this'\n+        \/\/ reachable until end of Cleaner registration. Code after that\n+        \/\/ clearly does not touch cleanable state.\n@@ -61,0 +66,3 @@\n+        try {\n+            LdapCtx homeCtx = getHomeCtx();\n+            Object obj = null;\n@@ -62,8 +70,3 @@\n-        Object obj = null;\n-\n-        String relStart;         \/\/ name relative to starting search context\n-        String relHome;          \/\/ name relative to homeCtx.currentDN\n-        boolean relative = true; \/\/ whether relative to currentDN\n-\n-        \/\/ need to strip off all but lowest component of dn\n-        \/\/ so that is relative to current context (currentDN)\n+            String relStart;         \/\/ name relative to starting search context\n+            String relHome;          \/\/ name relative to homeCtx.currentDN\n+            boolean relative = true; \/\/ whether relative to currentDN\n@@ -71,4 +74,2 @@\n-        try {\n-            Name parsed = new LdapName(dn);\n-            \/\/ System.err.println(\"dn string: \" + dn);\n-            \/\/ System.err.println(\"dn name: \" + parsed);\n+            \/\/ need to strip off all but lowest component of dn\n+            \/\/ so that is relative to current context (currentDN)\n@@ -76,4 +77,16 @@\n-            if (startName != null && parsed.startsWith(startName)) {\n-                relStart = parsed.getSuffix(startName.size()).toString();\n-                relHome = parsed.getSuffix(homeCtx.currentParsedDN.size()).toString();\n-            } else {\n+            try {\n+                Name parsed = new LdapName(dn);\n+                \/\/ System.err.println(\"dn string: \" + dn);\n+                \/\/ System.err.println(\"dn name: \" + parsed);\n+\n+                if (startName != null && parsed.startsWith(startName)) {\n+                    relStart = parsed.getSuffix(startName.size()).toString();\n+                    relHome = parsed.getSuffix(homeCtx.currentParsedDN.size()).toString();\n+                } else {\n+                    relative = false;\n+                    relHome = relStart =\n+                        LdapURL.toUrlString(homeCtx.hostname, homeCtx.port_number,\n+                        dn, homeCtx.hasLdapsScheme);\n+                }\n+            } catch (NamingException e) {\n+                \/\/ could not parse name\n@@ -85,7 +98,0 @@\n-        } catch (NamingException e) {\n-            \/\/ could not parse name\n-            relative = false;\n-            relHome = relStart =\n-                LdapURL.toUrlString(homeCtx.hostname, homeCtx.port_number,\n-                dn, homeCtx.hasLdapsScheme);\n-        }\n@@ -93,5 +99,5 @@\n-        \/\/ Name relative to search context\n-        CompositeName cn = new CompositeName();\n-        if (!relStart.isEmpty()) {\n-            cn.add(relStart);\n-        }\n+            \/\/ Name relative to search context\n+            CompositeName cn = new CompositeName();\n+            if (!relStart.isEmpty()) {\n+                cn.add(relStart);\n+            }\n@@ -99,7 +105,7 @@\n-        \/\/ Name relative to homeCtx\n-        CompositeName rcn = new CompositeName();\n-        if (!relHome.isEmpty()) {\n-            rcn.add(relHome);\n-        }\n-        \/\/System.err.println(\"relStart: \" + cn);\n-        \/\/System.err.println(\"relHome: \" + rcn);\n+            \/\/ Name relative to homeCtx\n+            CompositeName rcn = new CompositeName();\n+            if (!relHome.isEmpty()) {\n+                rcn.add(relHome);\n+            }\n+            \/\/System.err.println(\"relStart: \" + cn);\n+            \/\/System.err.println(\"relHome: \" + rcn);\n@@ -107,2 +113,2 @@\n-        \/\/ Fix attributes to be able to get schema\n-        homeCtx.setParents(attrs, rcn);\n+            \/\/ Fix attributes to be able to get schema\n+            homeCtx.setParents(attrs, rcn);\n@@ -110,2 +116,2 @@\n-        \/\/ only generate object when requested\n-        if (searchArgs.cons.getReturningObjFlag()) {\n+            \/\/ only generate object when requested\n+            if (searchArgs.cons.getReturningObjFlag()) {\n@@ -113,8 +119,8 @@\n-            if (attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME]) != null) {\n-                \/\/ Entry contains Java-object attributes (ser\/ref object)\n-                \/\/ serialized object or object reference\n-                obj = Obj.decodeObject(attrs);\n-            }\n-            if (obj == null) {\n-                obj = new LdapCtx(homeCtx, dn);\n-            }\n+                if (attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME]) != null) {\n+                    \/\/ Entry contains Java-object attributes (ser\/ref object)\n+                    \/\/ serialized object or object reference\n+                    obj = Obj.decodeObject(attrs);\n+                }\n+                if (obj == null) {\n+                    obj = new LdapCtx(homeCtx, dn);\n+                }\n@@ -122,3 +128,3 @@\n-            \/\/ Call getObjectInstance before removing unrequested attributes\n-            try {\n-                \/\/ rcn is either relative to homeCtx or a fully qualified DN\n+                \/\/ Call getObjectInstance before removing unrequested attributes\n+                try {\n+                    \/\/ rcn is either relative to homeCtx or a fully qualified DN\n@@ -128,9 +134,9 @@\n-            } catch (NamingException e) {\n-                throw e;\n-            } catch (Exception e) {\n-                NamingException ne =\n-                    new NamingException(\n-                            \"problem generating object using object factory\");\n-                ne.setRootCause(e);\n-                throw ne;\n-            }\n+                } catch (NamingException e) {\n+                    throw e;\n+                } catch (Exception e) {\n+                    NamingException ne =\n+                        new NamingException(\n+                                \"problem generating object using object factory\");\n+                    ne.setRootCause(e);\n+                    throw ne;\n+                }\n@@ -138,3 +144,3 @@\n-            \/\/ remove Java attributes from result, if necessary\n-            \/\/ Even if CLASSNAME attr not there, there might be some\n-            \/\/ residual attributes\n+                \/\/ remove Java attributes from result, if necessary\n+                \/\/ Even if CLASSNAME attr not there, there might be some\n+                \/\/ residual attributes\n@@ -142,11 +148,12 @@\n-            String[] reqAttrs;\n-            if ((reqAttrs = searchArgs.reqAttrs) != null) {\n-                \/\/ create an attribute set for those requested\n-                Attributes rattrs = new BasicAttributes(true); \/\/ ignore case\n-                for (int i = 0; i < reqAttrs.length; i++) {\n-                    rattrs.put(reqAttrs[i], null);\n-                }\n-                for (int i = 0; i < Obj.JAVA_ATTRIBUTES.length; i++) {\n-                    \/\/ Remove Java-object attributes if not requested\n-                    if (rattrs.get(Obj.JAVA_ATTRIBUTES[i]) == null) {\n-                        attrs.remove(Obj.JAVA_ATTRIBUTES[i]);\n+                String[] reqAttrs;\n+                if ((reqAttrs = searchArgs.reqAttrs) != null) {\n+                    \/\/ create an attribute set for those requested\n+                    Attributes rattrs = new BasicAttributes(true); \/\/ ignore case\n+                    for (int i = 0; i < reqAttrs.length; i++) {\n+                        rattrs.put(reqAttrs[i], null);\n+                    }\n+                    for (int i = 0; i < Obj.JAVA_ATTRIBUTES.length; i++) {\n+                        \/\/ Remove Java-object attributes if not requested\n+                        if (rattrs.get(Obj.JAVA_ATTRIBUTES[i]) == null) {\n+                            attrs.remove(Obj.JAVA_ATTRIBUTES[i]);\n+                        }\n@@ -155,1 +162,0 @@\n-            }\n@@ -157,1 +163,1 @@\n-        }\n+            }\n@@ -159,15 +165,21 @@\n-        \/*\n-         * name in search result is either the stringified composite name\n-         * relative to the search context that can be passed directly to\n-         * methods of the search context, or the fully qualified DN\n-         * which can be used with the initial context.\n-         *\/\n-        SearchResult sr;\n-        if (respCtls != null) {\n-            sr = new SearchResultWithControls(\n-                (relative ? cn.toString() : relStart), obj, attrs,\n-                relative, homeCtx.convertControls(respCtls));\n-        } else {\n-            sr = new SearchResult(\n-                (relative ? cn.toString() : relStart),\n-                obj, attrs, relative);\n+            \/*\n+             * name in search result is either the stringified composite name\n+             * relative to the search context that can be passed directly to\n+             * methods of the search context, or the fully qualified DN\n+             * which can be used with the initial context.\n+             *\/\n+            SearchResult sr;\n+            if (respCtls != null) {\n+                sr = new SearchResultWithControls(\n+                    (relative ? cn.toString() : relStart), obj, attrs,\n+                    relative, homeCtx.convertControls(respCtls));\n+            } else {\n+                sr = new SearchResult(\n+                    (relative ? cn.toString() : relStart),\n+                    obj, attrs, relative);\n+            }\n+            sr.setNameInNamespace(dn);\n+            return sr;\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n@@ -175,2 +187,0 @@\n-        sr.setNameInNamespace(dn);\n-        return sr;\n@@ -185,0 +195,2 @@\n+        \/\/ No reachabilityFence here for now; rely on fence in the super call.\n+        \/\/ Other code in this method clearly doesn't access cleanable state.\n@@ -190,3 +202,8 @@\n-        \/\/ repeat the original operation at the new context\n-        return (AbstractLdapNamingEnumeration<? extends NameClassPair>)refCtx.search(\n-                searchArgs.name, searchArgs.filter, searchArgs.cons);\n+        try {\n+            \/\/ repeat the original operation at the new context\n+            return (AbstractLdapNamingEnumeration<? extends NameClassPair>) refCtx.search(\n+                    searchArgs.name, searchArgs.filter, searchArgs.cons);\n+        } finally {\n+            \/\/ Ensure Cleaner does not run until after this method completes\n+            Reference.reachabilityFence(this);\n+        }\n@@ -202,0 +219,5 @@\n+        \/\/ No reachabilityFence here for now.\n+        \/\/ super.update() (aka AbstractLdapNamingEnumeration.update()) already\n+        \/\/ keeps 'this' and 'ne' reachable throughout that method call.\n+        \/\/ After that, we're clearly not accessing cleanable state from 'this'\n+        \/\/ or 'ne'.\n@@ -206,0 +228,1 @@\n+        \/\/ No reachabilityFence - clearly doesn't access cleanable state\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapSearchEnumeration.java","additions":119,"deletions":96,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8283660\n+ * @summary Verify the AbstractLdapNamingEnumeration Cleaner performs cleanup correctly\n+ * @modules java.naming\/com.sun.jndi.ldap:+open java.base\/java.lang.ref:open\n+ * @library \/test\/lib ..\/lib\/ \/javax\/naming\/module\/src\/test\/test\/\n+ * @build LDAPServer LDAPTestUtils jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -Xbootclasspath\/a:.\n+ *      -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+WhiteBoxAPI\n+ *      LdapEnumeration\n+\n+ *\/\n+\n+import javax.naming.NamingEnumeration;\n+import javax.naming.directory.Attribute;\n+import javax.naming.directory.Attributes;\n+import javax.naming.directory.BasicAttribute;\n+import javax.naming.directory.BasicAttributes;\n+import javax.naming.directory.DirContext;\n+import javax.naming.directory.InitialDirContext;\n+import javax.naming.directory.SearchControls;\n+import javax.naming.directory.SearchResult;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.SocketAddress;\n+import java.util.Hashtable;\n+import java.util.WeakHashMap;\n+\n+import jdk.test.lib.net.URIBuilder;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * This test is a copy of com\/sun\/jndi\/ldap\/blits\/AddTests\/AddNewEntry.java,\n+ * altered to confirm correct operation of the NamingEnumeration<SearchResult>\n+ * cleaning action.\n+ *\/\n+public class LdapEnumeration {\n+    static WeakHashMap whm = new WeakHashMap();\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Create unbound server socket\n+        ServerSocket serverSocket = new ServerSocket();\n+\n+        \/\/ Bind it to the loopback address\n+        SocketAddress sockAddr = new InetSocketAddress(\n+                InetAddress.getLoopbackAddress(), 0);\n+        serverSocket.bind(sockAddr);\n+\n+        \/\/ Construct the provider URL for LDAPTestUtils\n+        String providerURL = URIBuilder.newBuilder()\n+                .scheme(\"ldap\")\n+                .loopback()\n+                .port(serverSocket.getLocalPort())\n+                .buildUnchecked().toString();\n+\n+        Hashtable<Object, Object> env;\n+\n+        \/\/ initialize test\n+        env = LDAPTestUtils.initEnv(serverSocket, providerURL,\n+                         LdapEnumeration.class.getName(), args, true);\n+\n+        \/* Build attribute set *\/\n+        String[] ids = { \"objectClass\", \"sn\", \"cn\", \"telephoneNumber\", \"mail\",\n+                \"description\", \"uid\" };\n+        Attribute objectClass = new BasicAttribute(ids[0]);\n+        objectClass.add(\"top\");\n+        objectClass.add(\"person\");\n+        objectClass.add(\"organizationalPerson\");\n+        objectClass.add(\"inetOrgPerson\");\n+\n+        Attribute sn = new BasicAttribute(ids[1], \"Powers\");\n+        Attribute cn = new BasicAttribute(ids[2],\n+                \"Austin \\\\\\\"Danger\\\\\\\" Powers\");\n+        Attribute telephoneNumber = new BasicAttribute(ids[3], \"+44 582 10101\");\n+        Attribute mail = new BasicAttribute(ids[4], \"secret_agent_man@imc.org\");\n+        Attribute description = new BasicAttribute(ids[5], \"Yea Baby!!\");\n+        description.add(\"Behave!\");\n+        Attribute uid = new BasicAttribute(ids[6], \"secret_agent_man\");\n+\n+        Attributes attrs = new BasicAttributes();\n+        attrs.put(objectClass);\n+        attrs.put(sn);\n+        attrs.put(cn);\n+        attrs.put(telephoneNumber);\n+        attrs.put(mail);\n+        attrs.put(description);\n+        attrs.put(uid);\n+\n+        DirContext ctx = null;\n+        String[] bases = new String[] { (String) env.get(\"client\"),\n+                (String) env.get(\"vendor\"), \"Add\" };\n+        String baseDN = LDAPTestUtils.buildDN(bases, (String) env.get(\"root\"));\n+        String entryDN = \"cn=Austin Powers,\" + baseDN;\n+        String expect = \"\"; \/\/ relative name\n+\n+        try {\n+            \/\/ connect to server\n+            ctx = new InitialDirContext(env);\n+\n+            \/\/ add entry\n+            ctx.createSubcontext(entryDN, attrs);\n+\n+            \/\/ specify base search\n+            SearchControls constraints = new SearchControls();\n+            constraints.setSearchScope(SearchControls.OBJECT_SCOPE);\n+\n+            NamingEnumeration<SearchResult> results = ctx\n+                    .search(entryDN, \"(objectclass=*)\", constraints);\n+\n+            if (!\"LdapSearchEnumeration\".equals(results.getClass().getSimpleName())) {\n+                throw new RuntimeException(\"Unexpected results class: \" + results.getClass());\n+            }\n+\n+            whm.put(results, null);\n+            results = null;\n+\n+            \/\/ Perform GC and wait for reference processing\n+            WhiteBox wb = WhiteBox.getWhiteBox();\n+            wb.fullGC();\n+            wb.waitForReferenceProcessing();\n+\n+            \/\/ If EnumCtx mistakenly holds a reference to enclosing 'results',\n+            \/\/ it won't be cleared from the map\n+            if (whm.size() != 0) {\n+                throw new RuntimeException(\"NamingEnumeration is still strongly reachable\");\n+            }\n+        } finally {\n+            LDAPTestUtils.cleanupSubcontext(ctx, entryDN);\n+            LDAPTestUtils.cleanup(ctx);\n+        }\n+    }\n+    \/**\n+     * Get an object from a named field.\n+     *\/\n+    static Object getField(Class<?> clazz, String fieldName, Object instance) {\n+        try {\n+            Field field = clazz.getDeclaredField(fieldName);\n+            field.setAccessible(true);\n+            return field.get(instance);\n+        } catch (NoSuchFieldException | IllegalAccessException ex) {\n+            throw new RuntimeException(\"field unknown or not accessible\", ex);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/CleanerTests\/LdapEnumeration.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-# Capture file for AddNewEntry.java\n+# Capture file for LdapEnumeration.java\n@@ -28,1 +28,1 @@\n-#       running the AddNewEntry application program against a real LDAP\n+#       running the LdapEnumeration application program against a real LDAP\n@@ -136,0 +136,6 @@\n+\n+\n+0000: 30 22 02 01 05 42 00 A0   1B 30 19 04 17 32 2E 31  0\"...B...0...2.1\n+0010: 36 2E 38 34 30 2E 31 2E   31 31 33 37 33 30 2E 33  6.840.1.113730.3\n+0020: 2E 34 2E 32                                        .4.2\n+\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/CleanerTests\/LdapEnumeration.ldap","additions":9,"deletions":3,"binary":false,"changes":12,"previous_filename":"test\/jdk\/com\/sun\/jndi\/ldap\/blits\/AddTests\/AddNewEntry.ldap","status":"copied"}]}