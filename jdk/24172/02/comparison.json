{"files":[{"patch":"@@ -686,4 +686,3 @@\n-class CollectCLDClosure : public CLDClosure {\n-  GrowableArray<ClassLoaderData*> _loaded_cld;\n-  GrowableArray<OopHandle> _loaded_cld_handles; \/\/ keep the CLDs alive\n-  Thread* _current_thread;\n+class CollectClassesForLinking : public KlassClosure {\n+  GrowableArray<OopHandle> _mirrors;\n+\n@@ -691,4 +690,3 @@\n-  CollectCLDClosure(Thread* thread) : _current_thread(thread) {}\n-  ~CollectCLDClosure() {\n-    for (int i = 0; i < _loaded_cld_handles.length(); i++) {\n-      _loaded_cld_handles.at(i).release(Universe::vm_global());\n+  ~CollectClassesForLinking() {\n+    for (int i = 0; i < _mirrors.length(); i++) {\n+      _mirrors.at(i).release(Universe::vm_global());\n@@ -697,0 +695,1 @@\n+\n@@ -699,2 +698,0 @@\n-    _loaded_cld.append(cld);\n-    _loaded_cld_handles.append(OopHandle(Universe::vm_global(), cld->holder()));\n@@ -703,2 +700,7 @@\n-  int nof_cld() const                { return _loaded_cld.length(); }\n-  ClassLoaderData* cld_at(int index) { return _loaded_cld.at(index); }\n+  void do_klass(Klass* k) {\n+    if (k->is_instance_klass()) {\n+      _mirrors.append(OopHandle(Universe::vm_global(), k->java_mirror()));\n+    }\n+  }\n+\n+  const GrowableArray<OopHandle>* mirrors() const { return &_mirrors; }\n@@ -744,10 +746,0 @@\n-  \/\/ Collect all loaded ClassLoaderData.\n-  CollectCLDClosure collect_cld(THREAD);\n-  {\n-    \/\/ ClassLoaderDataGraph::loaded_cld_do requires ClassLoaderDataGraph_lock.\n-    \/\/ We cannot link the classes while holding this lock (or else we may run into deadlock).\n-    \/\/ Therefore, we need to first collect all the CLDs, and then link their classes after\n-    \/\/ releasing the lock.\n-    MutexLocker lock(ClassLoaderDataGraph_lock);\n-    ClassLoaderDataGraph::loaded_cld_do(&collect_cld);\n-  }\n@@ -756,0 +748,11 @@\n+    CollectClassesForLinking collect_classes;\n+    {\n+      \/\/ ClassLoaderDataGraph::loaded_classes_do_keepalive() requires ClassLoaderDataGraph_lock.\n+      \/\/ We cannot link the classes while holding this lock (or else we may run into deadlock).\n+      \/\/ Therefore, we need to first collect all the classes, keeping them alive by\n+      \/\/ holding onto their java_mirrors in global OopHandles. We then link the classes after\n+      \/\/ releasing the lock.\n+      MutexLocker lock(ClassLoaderDataGraph_lock);\n+      ClassLoaderDataGraph::loaded_classes_do_keepalive(&collect_classes);\n+    }\n+\n@@ -757,9 +760,6 @@\n-    for (int i = 0; i < collect_cld.nof_cld(); i++) {\n-      ClassLoaderData* cld = collect_cld.cld_at(i);\n-      for (Klass* klass = cld->klasses(); klass != nullptr; klass = klass->next_link()) {\n-        if (klass->is_instance_klass()) {\n-          InstanceKlass* ik = InstanceKlass::cast(klass);\n-          if (may_be_eagerly_linked(ik)) {\n-            has_linked |= link_class_for_cds(ik, CHECK);\n-          }\n-        }\n+    const GrowableArray<OopHandle>* mirrors = collect_classes.mirrors();\n+    for (int i = 0; i < mirrors->length(); i++) {\n+      OopHandle mirror = mirrors->at(i);\n+      InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(mirror.resolve()));\n+      if (may_be_eagerly_linked(ik)) {\n+        has_linked |= link_class_for_cds(ik, CHECK);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"}]}