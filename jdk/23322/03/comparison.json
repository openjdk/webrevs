{"files":[{"patch":"@@ -427,5 +427,0 @@\n-  \/\/ If class_name is already loaded, just return the superclass or superinterface.\n-  \/\/ Make sure there's a placeholder for the class_name before resolving.\n-  \/\/ This is used as a claim that this thread is currently loading superclass\/classloader\n-  \/\/ and for ClassCircularity checks.\n-\n@@ -433,1 +428,16 @@\n-  Dictionary* dictionary = loader_data->dictionary();\n+\n+  if (is_superclass) {\n+    InstanceKlass* klassk = loader_data->dictionary()->find_class(THREAD, class_name);\n+    if (klassk != nullptr) {\n+      \/\/ We can come here for two reasons:\n+      \/\/ (a) RedefineClasses -- the class is already loaded\n+      \/\/ (b) Rarely, the class might have been loaded by a parallel thread\n+      \/\/ We can do a quick check against the already assigned superclass's name and loader.\n+      InstanceKlass* superk = klassk->java_super();\n+      if (superk != nullptr &&\n+          superk->name() == next_name &&\n+          superk->class_loader() == class_loader()) {\n+        return superk;\n+      }\n+    }\n+  }\n@@ -439,16 +449,6 @@\n-    InstanceKlass* klassk = dictionary->find_class(THREAD, class_name);\n-    InstanceKlass* quicksuperk;\n-    \/\/ To support parallel loading: if class is done loading, just return the superclass\n-    \/\/ if the next_name matches class->super()->name() and if the class loaders match.\n-    if (klassk != nullptr && is_superclass &&\n-       ((quicksuperk = klassk->java_super()) != nullptr) &&\n-       ((quicksuperk->name() == next_name) &&\n-         (quicksuperk->class_loader() == class_loader()))) {\n-      return quicksuperk;\n-    } else {\n-      \/\/ Must check ClassCircularity before checking if superclass is already loaded.\n-      PlaceholderEntry* probe = PlaceholderTable::get_entry(class_name, loader_data);\n-      if (probe && probe->check_seen_thread(THREAD, PlaceholderTable::DETECT_CIRCULARITY)) {\n-          log_circularity_error(class_name, probe);\n-          throw_circularity_error = true;\n-      }\n+\n+    \/\/ Must check ClassCircularity before resolving next_name (superclass or interface).\n+    PlaceholderEntry* probe = PlaceholderTable::get_entry(class_name, loader_data);\n+    if (probe != nullptr && probe->check_seen_thread(THREAD, PlaceholderTable::DETECT_CIRCULARITY)) {\n+        log_circularity_error(class_name, probe);\n+        throw_circularity_error = true;\n@@ -457,0 +457,3 @@\n+    \/\/ Make sure there's a placeholder for the class_name before resolving.\n+    \/\/ This is used as a claim that this thread is currently loading superclass\/classloader\n+    \/\/ and for ClassCircularity checks.\n@@ -504,2 +507,1 @@\n-  \/\/ This passes true to is_superclass even though it might not be the super class in order to perform the\n-  \/\/ optimization anyway.\n+  \/\/ This passes false to is_superclass to skip doing the unlikely optimization.\n@@ -509,1 +511,1 @@\n-                                                                       true,\n+                                                                       false,\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":27,"deletions":25,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}