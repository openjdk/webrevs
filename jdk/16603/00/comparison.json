{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -62,3 +63,10 @@\n-  \/\/ check if locked\n-  __ testptr(result, markWord::unlocked_value);\n-  __ jcc(Assembler::zero, slowCase);\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ check if monitor\n+    __ testptr(result, markWord::monitor_value);\n+    __ jcc(Assembler::notZero, slowCase);\n+  } else {\n+    \/\/ check if locked\n+    __ testptr(result, markWord::unlocked_value);\n+    __ jcc(Assembler::zero, slowCase);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4547,1 +4547,1 @@\n-  \/\/ Test the header to see if it is unlocked.\n+  \/\/ Test the header to see if it is safe to read w.r.t. locking.\n@@ -4550,3 +4550,4 @@\n-  Node *unlocked_val   = _gvn.MakeConX(markWord::unlocked_value);\n-  Node *chk_unlocked   = _gvn.transform(new CmpXNode( lmasked_header, unlocked_val));\n-  Node *test_unlocked  = _gvn.transform(new BoolNode( chk_unlocked, BoolTest::ne));\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n+    Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n+    Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n@@ -4554,1 +4555,8 @@\n-  generate_slow_guard(test_unlocked, slow_region);\n+    generate_slow_guard(test_monitor, slow_region);\n+  } else {\n+    Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n+    Node *chk_unlocked      = _gvn.transform(new CmpXNode( lmasked_header, unlocked_val));\n+    Node *test_not_unlocked = _gvn.transform(new BoolNode( chk_unlocked, BoolTest::ne));\n+\n+    generate_slow_guard(test_not_unlocked, slow_region);\n+  }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -516,2 +516,1 @@\n-        if (mark.is_neutral()) {\n-          assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n+        while (mark.is_unlocked()) {\n@@ -519,2 +518,4 @@\n-          markWord locked_mark = mark.set_fast_locked();\n-          markWord old_mark = obj()->cas_set_mark(locked_mark, mark);\n+          assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n+          const markWord new_mark = mark.set_fast_locked();\n+          const markWord old_mark = mark;\n+          mark = obj()->cas_set_mark(new_mark, old_mark);\n@@ -575,13 +576,7 @@\n-      if (mark.is_fast_locked()) {\n-        markWord unlocked_mark = mark.set_unlocked();\n-        markWord old_mark = object->cas_set_mark(unlocked_mark, mark);\n-        if (old_mark != mark) {\n-          \/\/ Another thread won the CAS, it must have inflated the monitor.\n-          \/\/ It can only have installed an anonymously locked monitor at this point.\n-          \/\/ Fetch that monitor, set owner correctly to this thread, and\n-          \/\/ exit it (allowing waiting threads to enter).\n-          assert(old_mark.has_monitor(), \"must have monitor\");\n-          ObjectMonitor* monitor = old_mark.monitor();\n-          assert(monitor->is_owner_anonymous(), \"must be anonymous owner\");\n-          monitor->set_owner_from_anonymous(current);\n-          monitor->exit(current);\n+      while (mark.is_fast_locked()) {\n+        const markWord new_mark = mark.set_unlocked();\n+        const markWord old_mark = mark;\n+        mark = object->cas_set_mark(new_mark, old_mark);\n+        if (old_mark == mark) {\n+          current->lock_stack().remove(object);\n+          return;\n@@ -589,3 +584,0 @@\n-        LockStack& lock_stack = current->lock_stack();\n-        lock_stack.remove(object);\n-        return;\n@@ -923,1 +915,1 @@\n-    if (mark.is_neutral()) {               \/\/ if this is a normal header\n+    if (mark.is_neutral() || (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked())) {\n@@ -935,0 +927,4 @@\n+      if (LockingMode == LM_LIGHTWEIGHT) {\n+        \/\/ CAS failed, retry\n+        continue;\n+      }\n@@ -966,7 +962,0 @@\n-    } else if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked() && is_lock_owned(current, obj)) {\n-      \/\/ This is a fast-lock owned by the calling thread so use the\n-      \/\/ markWord from the object.\n-      hash = mark.hash();\n-      if (hash != 0) {                  \/\/ if it has a hash, just return it\n-        return hash;\n-      }\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":17,"deletions":28,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+        static long LockingMode = wb.getIntVMFlag(\"LockingMode\");\n+        static long LM_LIGHTWEIGHT = 2;\n@@ -64,1 +66,1 @@\n-        public static void main(String args[]) {\n+        public static void main(String args[]) throws Exception {\n@@ -67,3 +69,9 @@\n-                \/\/ HotSpot implementation detail: asking for the hash code\n-                \/\/ when the object is locked causes monitor inflation.\n-                if (obj.hashCode() == 0xBAD) System.out.println(\"!\");\n+                if (LockingMode != LM_LIGHTWEIGHT) {\n+                    \/\/ HotSpot implementation detail: asking for the hash code\n+                    \/\/ when the object is locked causes monitor inflation.\n+                    if (obj.hashCode() == 0xBAD) System.out.println(\"!\");\n+                } else {\n+                    \/\/ Lightweight locking mode does not inflate for hash codes\n+                    \/\/ wait on the lock instead to causes monitor inflation.\n+                    obj.wait(1);\n+                }\n","filename":"test\/hotspot\/jtreg\/runtime\/whitebox\/TestWBDeflateIdleMonitors.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"}]}