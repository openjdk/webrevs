{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -62,3 +63,10 @@\n-  \/\/ check if locked\n-  __ testptr(result, markWord::unlocked_value);\n-  __ jcc(Assembler::zero, slowCase);\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ check if monitor\n+    __ testptr(result, markWord::monitor_value);\n+    __ jcc(Assembler::notZero, slowCase);\n+  } else {\n+    \/\/ check if locked\n+    __ testptr(result, markWord::unlocked_value);\n+    __ jcc(Assembler::zero, slowCase);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4549,1 +4549,1 @@\n-  \/\/ Test the header to see if it is unlocked.\n+  \/\/ Test the header to see if it is safe to read w.r.t. locking.\n@@ -4552,3 +4552,4 @@\n-  Node *unlocked_val   = _gvn.MakeConX(markWord::unlocked_value);\n-  Node *chk_unlocked   = _gvn.transform(new CmpXNode( lmasked_header, unlocked_val));\n-  Node *test_unlocked  = _gvn.transform(new BoolNode( chk_unlocked, BoolTest::ne));\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n+    Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n+    Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n@@ -4556,1 +4557,8 @@\n-  generate_slow_guard(test_unlocked, slow_region);\n+    generate_slow_guard(test_monitor, slow_region);\n+  } else {\n+    Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n+    Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n+    Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n+\n+    generate_slow_guard(test_not_unlocked, slow_region);\n+  }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -477,2 +477,2 @@\n-        if (mark.is_neutral()) {\n-          assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n+        while (mark.is_neutral()) {\n+          \/\/ Retry until a lock state change has been observed.  cas_set_mark() may collide with non lock bits modifications.\n@@ -480,2 +480,3 @@\n-          markWord locked_mark = mark.set_fast_locked();\n-          markWord old_mark = obj()->cas_set_mark(locked_mark, mark);\n+          assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n+          const markWord locked_mark = mark.set_fast_locked();\n+          const markWord old_mark = obj()->cas_set_mark(locked_mark, mark);\n@@ -487,0 +488,1 @@\n+          mark = old_mark;\n@@ -536,13 +538,7 @@\n-      if (mark.is_fast_locked()) {\n-        markWord unlocked_mark = mark.set_unlocked();\n-        markWord old_mark = object->cas_set_mark(unlocked_mark, mark);\n-        if (old_mark != mark) {\n-          \/\/ Another thread won the CAS, it must have inflated the monitor.\n-          \/\/ It can only have installed an anonymously locked monitor at this point.\n-          \/\/ Fetch that monitor, set owner correctly to this thread, and\n-          \/\/ exit it (allowing waiting threads to enter).\n-          assert(old_mark.has_monitor(), \"must have monitor\");\n-          ObjectMonitor* monitor = old_mark.monitor();\n-          assert(monitor->is_owner_anonymous(), \"must be anonymous owner\");\n-          monitor->set_owner_from_anonymous(current);\n-          monitor->exit(current);\n+      while (mark.is_fast_locked()) {\n+        \/\/ Retry until a lock state change has been observed.  cas_set_mark() may collide with non lock bits modifications.\n+        const markWord unlocked_mark = mark.set_fast_locked();\n+        const markWord old_mark = object->cas_set_mark(unlocked_mark, mark);\n+        if (old_mark == mark) {\n+          current->lock_stack().remove(object);\n+          return;\n@@ -550,3 +546,1 @@\n-        LockStack& lock_stack = current->lock_stack();\n-        lock_stack.remove(object);\n-        return;\n+        mark = old_mark;\n@@ -866,7 +860,0 @@\n-\/\/ Can be called from non JavaThreads (e.g., VMThread) for FastHashCode\n-\/\/ calculations as part of JVM\/TI tagging.\n-static bool is_lock_owned(Thread* thread, oop obj) {\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only call this with new lightweight locking enabled\");\n-  return thread->is_Java_thread() ? JavaThread::cast(thread)->lock_stack().contains(obj) : false;\n-}\n-\n@@ -884,1 +871,1 @@\n-    if (mark.is_neutral()) {               \/\/ if this is a normal header\n+    if (mark.is_neutral() || (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked())) {\n@@ -896,0 +883,4 @@\n+      if (LockingMode == LM_LIGHTWEIGHT) {\n+        \/\/ CAS failed, retry\n+        continue;\n+      }\n@@ -927,7 +918,0 @@\n-    } else if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked() && is_lock_owned(current, obj)) {\n-      \/\/ This is a fast-lock owned by the calling thread so use the\n-      \/\/ markWord from the object.\n-      hash = mark.hash();\n-      if (hash != 0) {                  \/\/ if it has a hash, just return it\n-        return hash;\n-      }\n@@ -1264,0 +1248,7 @@\n+\/\/ Can be called from non JavaThreads (e.g., VMThread) for FastHashCode\n+\/\/ calculations as part of JVM\/TI tagging.\n+static bool is_lock_owned(Thread* thread, oop obj) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only call this with new lightweight locking enabled\");\n+  return thread->is_Java_thread() ? JavaThread::cast(thread)->lock_stack().contains(obj) : false;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":26,"deletions":35,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        public static void main(String args[]) {\n+        public static void main(String args[]) throws Exception {\n@@ -67,3 +67,2 @@\n-                \/\/ HotSpot implementation detail: asking for the hash code\n-                \/\/ when the object is locked causes monitor inflation.\n-                if (obj.hashCode() == 0xBAD) System.out.println(\"!\");\n+                \/\/ The current implementation of notify-wait requires inflation.\n+                obj.wait(1);\n","filename":"test\/hotspot\/jtreg\/runtime\/whitebox\/TestWBDeflateIdleMonitors.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}