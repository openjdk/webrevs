{"files":[{"patch":"@@ -287,1 +287,1 @@\n-    ################################################################################\n+    ############################################################################\n@@ -316,1 +316,1 @@\n-    ################################################################################\n+    ############################################################################\n","filename":"make\/Bundles.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-     $(BUILDTOOLS_OUTPUTDIR)\/gensrc\/java.compiler.interim\/javax\/tools\/ToolProvider.java\n+    $(BUILDTOOLS_OUTPUTDIR)\/gensrc\/java.compiler.interim\/javax\/tools\/ToolProvider.java\n","filename":"make\/CompileInterimLangtools.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,6 +78,6 @@\n-       $(patsubst $(TOPDIR)\/src\/%, $(JDK_OUTPUTDIR)\/modules\/%, \\\n-         $(subst \/share\/classes,, \\\n-            $(subst _zh_TW,_zh_HK, $(filter %_zh_TW.properties, $1)) \\\n-         ) \\\n-       ), \\\n-       .properties \\\n+        $(patsubst $(TOPDIR)\/src\/%, $(JDK_OUTPUTDIR)\/modules\/%, \\\n+            $(subst \/share\/classes,, \\\n+                $(subst _zh_TW,_zh_HK, $(filter %_zh_TW.properties, $1)) \\\n+            ) \\\n+        ), \\\n+        .properties \\\n","filename":"make\/CompileJavaModules.gmk","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,2 +55,1 @@\n-        build\/tools\/depend \\\n-        , \\\n+        build\/tools\/depend, \\\n@@ -69,1 +68,1 @@\n-$(eval $(call SetupCopyFiles,COPY_NIMBUS_TEMPLATES, \\\n+$(eval $(call SetupCopyFiles, COPY_NIMBUS_TEMPLATES, \\\n@@ -72,1 +71,2 @@\n-    FILES := $(wildcard $(TOPDIR)\/src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/*.template)))\n+    FILES := $(wildcard $(TOPDIR)\/src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/*.template), \\\n+))\n@@ -76,1 +76,1 @@\n-$(eval $(call SetupCopyFiles,COPY_CLDRCONVERTER_PROPERTIES, \\\n+$(eval $(call SetupCopyFiles, COPY_CLDRCONVERTER_PROPERTIES, \\\n@@ -79,1 +79,2 @@\n-    FILES := $(wildcard $(TOPDIR)\/make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/*.properties)))\n+    FILES := $(wildcard $(TOPDIR)\/make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/*.properties), \\\n+))\n","filename":"make\/CompileToolsJdk.gmk","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-##########################################################################################\n+################################################################################\n@@ -44,1 +44,1 @@\n-$(eval $(call SetupCopyFiles,COPY_INTERIM_TZDB, \\\n+$(eval $(call SetupCopyFiles, COPY_INTERIM_TZDB, \\\n@@ -48,1 +48,2 @@\n-    MACRO := tzdb_copyfiles))\n+    MACRO := tzdb_copyfiles, \\\n+))\n@@ -50,1 +51,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/CopyInterimTZDB.gmk","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,0 +232,12 @@\n+\n+  JMOD_TARGET_OS := $(OPENJDK_BUILD_OS)\n+  ifeq ($(JMOD_TARGET_OS), macosx)\n+    JMOD_TARGET_OS := macos\n+  endif\n+\n+  JMOD_TARGET_CPU := $(OPENJDK_BUILD_CPU)\n+  ifeq ($(JMOD_TARGET_CPU), x86_64)\n+    JMOD_TARGET_CPU := amd64\n+  endif\n+\n+  JMOD_TARGET_PLATFORM := $(JMOD_TARGET_OS)-$(JMOD_TARGET_CPU)\n@@ -234,0 +246,1 @@\n+  JMOD_TARGET_PLATFORM := $(OPENJDK_MODULE_TARGET_PLATFORM)\n@@ -245,1 +258,1 @@\n-        --target-platform '$(OPENJDK_MODULE_TARGET_PLATFORM)' \\\n+        --target-platform '$(JMOD_TARGET_PLATFORM)' \\\n","filename":"make\/CreateJmods.gmk","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-  ifneq ($$($1_GROUPS),)\n+  ifneq ($$($1_GROUPS), )\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-_:=\n+_ :=\n@@ -111,1 +111,1 @@\n-\t$(if $(all_confs), $(info Available configurations in $(build_dir):) $(foreach var,$(all_confs),$(info * $(var))),\\\n+\t$(if $(all_confs), $(info Available configurations in $(build_dir):) $(foreach var,$(all_confs),$(info * $(var))), \\\n","filename":"make\/Global.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -137,2 +137,2 @@\n-  $1_$2_DUMP_EXTRA_ARG := $(if $(filter _nocoops, $2),-XX:-UseCompressedOops,)\n-  $1_$2_DUMP_TYPE      := $(if $(filter _nocoops, $2),-NOCOOPS,)\n+  $1_$2_DUMP_EXTRA_ARG := $(if $(filter _nocoops, $2), -XX:-UseCompressedOops, )\n+  $1_$2_DUMP_TYPE      := $(if $(filter _nocoops, $2), -NOCOOPS, )\n@@ -141,1 +141,1 @@\n-  $1_$2_CDS_DUMP_FLAGS := $(CDS_DUMP_FLAGS) $(if $(filter g1gc, $(JVM_FEATURES_$1)),-XX:+UseG1GC)\n+  $1_$2_CDS_DUMP_FLAGS := $(CDS_DUMP_FLAGS) $(if $(filter g1gc, $(JVM_FEATURES_$1)), -XX:+UseG1GC)\n@@ -238,1 +238,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_GCOV_GCNO, \\\n+  $(eval $(call SetupCopyFiles, COPY_GCOV_GCNO, \\\n","filename":"make\/Images.gmk","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-ifeq ($(HAS_SPEC),)\n+ifeq ($(HAS_SPEC), )\n@@ -171,1 +171,1 @@\n-        ifneq ($(findstring $(LOG_LEVEL),info debug trace),)\n+        ifneq ($(findstring $(LOG_LEVEL), info debug trace), )\n","filename":"make\/Init.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-ifeq ($(HAS_SPEC),)\n+ifeq ($(HAS_SPEC), )\n@@ -77,1 +77,1 @@\n-    build_dir=$(CUSTOM_ROOT)\/build\n+    build_dir = $(CUSTOM_ROOT)\/build\n@@ -79,1 +79,1 @@\n-    build_dir=$(topdir)\/build\n+    build_dir = $(topdir)\/build\n@@ -81,1 +81,1 @@\n-  all_spec_files=$(wildcard $(build_dir)\/*\/spec.gmk)\n+  all_spec_files = $(wildcard $(build_dir)\/*\/spec.gmk)\n@@ -83,1 +83,1 @@\n-  all_confs=$(patsubst %\/spec.gmk, %, $(patsubst $(build_dir)\/%, %, $(all_spec_files)))\n+  all_confs = $(patsubst %\/spec.gmk, %, $(patsubst $(build_dir)\/%, %, $(all_spec_files)))\n@@ -131,1 +131,1 @@\n-    else ifneq ($$(filter-out auto fail ignore, $$(CONF_CHECK)),)\n+    else ifneq ($$(filter-out auto fail ignore, $$(CONF_CHECK)), )\n@@ -150,1 +150,1 @@\n-      ifeq ($$(wildcard $$(SPEC)),)\n+      ifeq ($$(wildcard $$(SPEC)), )\n@@ -154,1 +154,1 @@\n-      ifeq ($$(filter \/%, $$(SPEC)),)\n+      ifeq ($$(filter \/%, $$(SPEC)), )\n@@ -165,1 +165,1 @@\n-      ifeq ($$(all_spec_files),)\n+      ifeq ($$(all_spec_files), )\n@@ -183,1 +183,1 @@\n-        ifeq ($$(matching_conf),)\n+        ifeq ($$(matching_conf), )\n@@ -200,1 +200,1 @@\n-        ifeq ($$(CONF),)\n+        ifeq ($$(CONF), )\n@@ -205,1 +205,1 @@\n-          ifeq ($$(patsubst !%,,$$(CONF)),)\n+          ifeq ($$(patsubst !%,,$$(CONF)), )\n@@ -208,1 +208,1 @@\n-               $$(if $$(findstring $$(subst !,,$$(CONF)), $$(var)), ,$$(var))))\n+                $$(if $$(findstring $$(subst !,,$$(CONF)), $$(var)), ,$$(var))))\n@@ -218,1 +218,1 @@\n-            ifeq ($$(MAKE_RESTARTS),)\n+            ifeq ($$(MAKE_RESTARTS), )\n@@ -223,1 +223,1 @@\n-        ifeq ($$(matching_confs),)\n+        ifeq ($$(matching_confs), )\n@@ -231,1 +231,1 @@\n-          ifeq ($$(MAKE_RESTARTS),)\n+          ifeq ($$(MAKE_RESTARTS), )\n@@ -233,1 +233,1 @@\n-              ifneq ($$(findstring $$(LOG_LEVEL), info debug trace),)\n+              ifneq ($$(findstring $$(LOG_LEVEL), info debug trace), )\n@@ -275,1 +275,1 @@\n-    ifeq ($$(MAKE_RESTARTS),)\n+    ifeq ($$(MAKE_RESTARTS), )\n@@ -319,1 +319,1 @@\n-    topdir=$(CUSTOM_ROOT)\n+    topdir = $(CUSTOM_ROOT)\n@@ -321,1 +321,1 @@\n-    topdir=$(TOPDIR)\n+    topdir = $(TOPDIR)\n@@ -352,1 +352,1 @@\n-            $$(eval COMPARE_BUILD_PATCH=$$(strip $$(patsubst PATCH=%, %, $$(part)))) \\\n+            $$(eval COMPARE_BUILD_PATCH = $$(strip $$(patsubst PATCH=%, %, $$(part)))) \\\n@@ -355,1 +355,1 @@\n-            $$(eval COMPARE_BUILD_CONF=$$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(part))))) \\\n@@ -358,1 +358,1 @@\n-            $$(eval COMPARE_BUILD_MAKE=$$(strip $$(subst +, , $$(patsubst MAKE=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_MAKE = $$(strip $$(subst +, , $$(patsubst MAKE=%, %, $$(part))))) \\\n@@ -361,1 +361,1 @@\n-            $$(eval COMPARE_BUILD_COMP_OPTS=$$(strip $$(subst +, , $$(patsubst COMP_OPTS=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_COMP_OPTS = $$(strip $$(subst +, , $$(patsubst COMP_OPTS=%, %, $$(part))))) \\\n@@ -364,1 +364,1 @@\n-            $$(eval COMPARE_BUILD_COMP_DIR=$$(strip $$(subst +, , $$(patsubst COMP_DIR=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_COMP_DIR = $$(strip $$(subst +, , $$(patsubst COMP_DIR=%, %, $$(part))))) \\\n@@ -367,1 +367,1 @@\n-            $$(eval COMPARE_BUILD_FAIL=$$(strip $$(subst +, , $$(patsubst FAIL=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_FAIL = $$(strip $$(subst +, , $$(patsubst FAIL=%, %, $$(part))))) \\\n@@ -370,1 +370,1 @@\n-            $$(eval COMPARE_BUILD_NODRYRUN=$$(strip $$(subst +, , $$(patsubst NODRYRUN=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_NODRYRUN = $$(strip $$(subst +, , $$(patsubst NODRYRUN=%, %, $$(part))))) \\\n@@ -376,1 +376,1 @@\n-          COMPARE_BUILD_PATCH=$$(strip $$(patsubst PATCH=%, %, $$(COMPARE_BUILD)))\n+          COMPARE_BUILD_PATCH = $$(strip $$(patsubst PATCH=%, %, $$(COMPARE_BUILD)))\n@@ -378,1 +378,1 @@\n-          COMPARE_BUILD_CONF=$$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(COMPARE_BUILD))))\n+          COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(COMPARE_BUILD))))\n@@ -381,1 +381,1 @@\n-          COMPARE_BUILD_CONF=$$(strip $$(subst +, , $$(COMPARE_BUILD)))\n+          COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(COMPARE_BUILD)))\n@@ -384,1 +384,1 @@\n-          COMPARE_BUILD_PATCH=$$(strip $$(COMPARE_BUILD))\n+          COMPARE_BUILD_PATCH = $$(strip $$(COMPARE_BUILD))\n@@ -534,1 +534,1 @@\n-\t  sleep 5\\\n+\t  sleep 5 \\\n@@ -547,1 +547,1 @@\n-  BUILDTIMESDIR=$(OUTPUTDIR)\/make-support\/build-times\n+  BUILDTIMESDIR = $(OUTPUTDIR)\/make-support\/build-times\n@@ -608,1 +608,1 @@\n-  ifneq ($$(findstring $1, $$(LOG)),)\n+  ifneq ($$(findstring $1, $$(LOG)), )\n@@ -623,1 +623,1 @@\n-  ifneq ($$(findstring $1=, $$(LOG)),)\n+  ifneq ($$(findstring $1=, $$(LOG)), )\n@@ -676,1 +676,1 @@\n-  ifeq ($$(LOG_LEVEL),)\n+  ifeq ($$(LOG_LEVEL), )\n","filename":"make\/InitSupport.gmk","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,3 @@\n-\t$(JLINK_TOOL) \\\n+\t$(call MakeDir, $(INTERIM_IMAGE_DIR))\n+\t$(call ExecuteWithLog, $(INTERIM_IMAGE_DIR)\/jlink, \\\n+\t    $(JLINK_TOOL) \\\n@@ -52,1 +54,1 @@\n-\t    --add-modules $(INTERIM_MODULES_LIST)\n+\t    --add-modules $(INTERIM_MODULES_LIST))\n","filename":"make\/InterimImage.gmk","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-    FILES := META-INF\/services\/java.nio.file.spi.FileSystemProvider))\n+    FILES := META-INF\/services\/java.nio.file.spi.FileSystemProvider, \\\n+))\n","filename":"make\/JrtfsJar.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-ifeq ($(wildcard $(SPEC)),)\n+ifeq ($(wildcard $(SPEC)), )\n@@ -1417,1 +1417,1 @@\n-\t$(if $(filter $(CONF_NAME),$(notdir $(OUTPUTDIR))), \\\n+\t$(if $(filter $(CONF_NAME), $(notdir $(OUTPUTDIR))), \\\n","filename":"make\/Main.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    ifeq ($(NO_RECIPES),)\n+    ifeq ($(NO_RECIPES), )\n@@ -200,2 +200,2 @@\n-  $(foreach i,2 3 4 5 6 7 8, $(if $(strip $($i)),$(strip $1)_$(strip $($i)))$(NEWLINE))\n-  $(if $(9),$(error Internal makefile error: Too many arguments to \\\n+  $(foreach i, 2 3 4 5 6 7 8, $(if $(strip $($i)),$(strip $1)_$(strip $($i)))$(NEWLINE))\n+  $(if $(9), $(error Internal makefile error: Too many arguments to \\\n","filename":"make\/MainSupport.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -107,1 +107,2 @@\n-      -timeoutHandlerTimeout:$(JTREG_FAILURE_HANDLER_TIMEOUT)\n+      -timeoutHandlerTimeout:$(JTREG_FAILURE_HANDLER_TIMEOUT) \\\n+      #\n@@ -503,1 +504,1 @@\n-    $1_GTEST_REPEAT :=--gtest_repeat=$$(GTEST_REPEAT)\n+    $1_GTEST_REPEAT := --gtest_repeat=$$(GTEST_REPEAT)\n","filename":"make\/RunTests.gmk","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-ifeq ($(filter \/%, $(lastword $(MAKEFILE_LIST))),)\n+ifeq ($(filter \/%, $(lastword $(MAKEFILE_LIST))), )\n@@ -70,1 +70,1 @@\n-      $1:=$2\n+      $1 := $2\n@@ -166,1 +166,1 @@\n-  OPENJDK_TARGET_OS_TYPE:=unix\n+  OPENJDK_TARGET_OS_TYPE := unix\n","filename":"make\/RunTestsPrebuilt.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,3 +73,3 @@\n-X:=\n-SPACE:=$(X) $(X)\n-COMMA:=,\n+X :=\n+SPACE := $(X) $(X)\n+COMMA := ,\n","filename":"make\/RunTestsPrebuiltSpec.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    $(if $(wildcard $(TOPDIR)\/$(repo)\/$(SCM_DIR)),, \\\n+    $(if $(wildcard $(TOPDIR)\/$(repo)\/$(SCM_DIR)), , \\\n@@ -75,1 +75,1 @@\n-  ################################################################################\n+  ##############################################################################\n","filename":"make\/SourceRevision.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  IMAGE_DEST_DIR=$(STATIC_LIBS_IMAGE_DIR)\/lib\n+  IMAGE_DEST_DIR = $(STATIC_LIBS_IMAGE_DIR)\/lib\n@@ -46,1 +46,1 @@\n-  IMAGE_DEST_DIR=$(STATIC_LIBS_GRAAL_IMAGE_DIR)\/lib\n+  IMAGE_DEST_DIR = $(STATIC_LIBS_GRAAL_IMAGE_DIR)\/lib\n","filename":"make\/StaticLibsImage.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-############################################################################\n+################################################################################\n","filename":"make\/TestImage.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/ToolsHotspot.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-##########################################################################################\n+################################################################################\n@@ -138,1 +138,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/ToolsJdk.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-##########################################################################################\n+################################################################################\n@@ -36,1 +36,1 @@\n-$(eval $(call SetupZipArchive,BUILD_SEC_BIN_ZIP, \\\n+$(eval $(call SetupZipArchive, BUILD_SEC_BIN_ZIP, \\\n@@ -63,1 +63,2 @@\n-    ZIP := $(IMAGES_OUTPUTDIR)\/sec-bin.zip))\n+    ZIP := $(IMAGES_OUTPUTDIR)\/sec-bin.zip, \\\n+))\n@@ -67,1 +68,1 @@\n-##########################################################################################\n+################################################################################\n@@ -73,1 +74,1 @@\n-  $(eval $(call SetupZipArchive,BUILD_SEC_WINDOWS_BIN_ZIP, \\\n+  $(eval $(call SetupZipArchive, BUILD_SEC_WINDOWS_BIN_ZIP, \\\n@@ -76,1 +77,2 @@\n-      ZIP := $(IMAGES_OUTPUTDIR)\/sec-windows-bin.zip))\n+      ZIP := $(IMAGES_OUTPUTDIR)\/sec-windows-bin.zip, \\\n+  ))\n@@ -87,1 +89,1 @@\n-  $(eval $(call SetupZipArchive,BUILD_JGSS_BIN_ZIP, \\\n+  $(eval $(call SetupZipArchive, BUILD_JGSS_BIN_ZIP, \\\n@@ -93,1 +95,2 @@\n-      ZIP := $(IMAGES_OUTPUTDIR)\/$(JGSS_ZIP_NAME)))\n+      ZIP := $(IMAGES_OUTPUTDIR)\/$(JGSS_ZIP_NAME), \\\n+  ))\n@@ -98,1 +101,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/ZipSecurity.gmk","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-SPEC:=@OUTPUTDIR@\/spec.gmk\n+SPEC := @OUTPUTDIR@\/spec.gmk\n","filename":"make\/autoconf\/Makefile.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-###############################################################################\n+################################################################################\n@@ -49,1 +49,1 @@\n-###############################################################################\n+################################################################################\n@@ -61,1 +61,1 @@\n-###############################################################################\n+################################################################################\n@@ -105,1 +105,1 @@\n-###############################################################################\n+################################################################################\n@@ -144,1 +144,1 @@\n-###############################################################################\n+################################################################################\n@@ -154,1 +154,1 @@\n-###############################################################################\n+################################################################################\n@@ -164,1 +164,1 @@\n-###############################################################################\n+################################################################################\n@@ -249,1 +249,1 @@\n-###############################################################################\n+################################################################################\n@@ -383,1 +383,1 @@\n-###############################################################################\n+################################################################################\n@@ -480,1 +480,1 @@\n-###############################################################################\n+################################################################################\n@@ -517,1 +517,1 @@\n-###############################################################################\n+################################################################################\n@@ -532,1 +532,1 @@\n-###############################################################################\n+################################################################################\n@@ -575,1 +575,1 @@\n-###############################################################################\n+################################################################################\n@@ -594,1 +594,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/basic.m4","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -31,1 +31,1 @@\n-###############################################################################\n+################################################################################\n@@ -62,1 +62,1 @@\n-###############################################################################\n+################################################################################\n@@ -119,1 +119,1 @@\n-###############################################################################\n+################################################################################\n@@ -132,1 +132,1 @@\n-   else\n+  else\n@@ -179,1 +179,1 @@\n-###############################################################################\n+################################################################################\n@@ -204,1 +204,1 @@\n-###############################################################################\n+################################################################################\n@@ -252,1 +252,1 @@\n-###############################################################################\n+################################################################################\n@@ -281,1 +281,1 @@\n-###############################################################################\n+################################################################################\n@@ -319,1 +319,1 @@\n-###############################################################################\n+################################################################################\n@@ -343,1 +343,1 @@\n-###############################################################################\n+################################################################################\n@@ -415,1 +415,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/basic_tools.m4","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-########################################################################\n+################################################################################\n@@ -52,1 +52,1 @@\n-########################################################################\n+################################################################################\n@@ -325,1 +325,1 @@\n-###############################################################################\n+################################################################################\n@@ -605,5 +605,6 @@\n-       if test \"x$with_build_jdk\" != x; then\n-         BUILD_JDK=$with_build_jdk\n-         BUILD_JDK_FOUND=maybe\n-         AC_MSG_NOTICE([Found potential Build JDK using configure arguments])\n-       fi])\n+      if test \"x$with_build_jdk\" != x; then\n+        BUILD_JDK=$with_build_jdk\n+        BUILD_JDK_FOUND=maybe\n+        AC_MSG_NOTICE([Found potential Build JDK using configure arguments])\n+      fi\n+    ])\n","filename":"make\/autoconf\/boot-jdk.m4","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-OLD_OUTPUTDIR:=@OUTPUTDIR@\n-OUTPUTDIR:=$(OLD_OUTPUTDIR)\/bootcycle-build\n+OLD_OUTPUTDIR := @OUTPUTDIR@\n+OUTPUTDIR := $(OLD_OUTPUTDIR)\/bootcycle-build\n@@ -40,1 +40,1 @@\n-JAVAC_SERVER_DIR:=$(patsubst $(OLD_OUTPUTDIR)%,$(OUTPUTDIR)%,$(JAVAC_SERVER_DIR))\n+JAVAC_SERVER_DIR := $(patsubst $(OLD_OUTPUTDIR)%,$(OUTPUTDIR)%,$(JAVAC_SERVER_DIR))\n@@ -51,1 +51,0 @@\n-\n","filename":"make\/autoconf\/bootcycle-spec.gmk.template","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/autoconf\/compare.sh.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -30,1 +30,1 @@\n-###############################################################################\n+################################################################################\n@@ -66,1 +66,1 @@\n-###############################################################################\n+################################################################################\n@@ -73,1 +73,1 @@\n-###############################################################################\n+################################################################################\n@@ -131,1 +131,1 @@\n-###############################################################################\n+################################################################################\n@@ -135,1 +135,1 @@\n-###############################################################################\n+################################################################################\n@@ -142,1 +142,1 @@\n-###############################################################################\n+################################################################################\n@@ -146,1 +146,1 @@\n-###############################################################################\n+################################################################################\n@@ -152,1 +152,1 @@\n-###############################################################################\n+################################################################################\n@@ -156,1 +156,1 @@\n-###############################################################################\n+################################################################################\n@@ -161,1 +161,1 @@\n-###############################################################################\n+################################################################################\n@@ -165,1 +165,1 @@\n-###############################################################################\n+################################################################################\n@@ -170,1 +170,1 @@\n-###############################################################################\n+################################################################################\n@@ -175,1 +175,1 @@\n-###############################################################################\n+################################################################################\n@@ -230,1 +230,1 @@\n-###############################################################################\n+################################################################################\n@@ -234,1 +234,1 @@\n-###############################################################################\n+################################################################################\n@@ -239,1 +239,1 @@\n-###############################################################################\n+################################################################################\n@@ -243,1 +243,1 @@\n-###############################################################################\n+################################################################################\n@@ -250,1 +250,1 @@\n-###############################################################################\n+################################################################################\n@@ -254,1 +254,1 @@\n-###############################################################################\n+################################################################################\n@@ -266,1 +266,1 @@\n-###############################################################################\n+################################################################################\n@@ -271,1 +271,1 @@\n-###############################################################################\n+################################################################################\n@@ -291,1 +291,1 @@\n-###############################################################################\n+################################################################################\n@@ -295,1 +295,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/configure.ac","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -238,3 +238,3 @@\n-      WARNINGS_ENABLE_ADDITIONAL=\"-Wpointer-arith -Wsign-compare \\\n-          -Wunused-function -Wundef -Wunused-value -Wreturn-type \\\n-          -Wtrampolines\"\n+      WARNINGS_ENABLE_ADDITIONAL=\"-Wpointer-arith -Wreturn-type -Wsign-compare \\\n+          -Wtrampolines -Wundef -Wunused-const-variable=1 -Wunused-function \\\n+          -Wunused-result -Wunused-value\"\n@@ -245,1 +245,3 @@\n-      DISABLED_WARNINGS=\"unused-parameter unused\"\n+      # These warnings will never be turned on, since they generate too many\n+      # false positives.\n+      DISABLED_WARNINGS=\"unused-parameter\"\n@@ -262,1 +264,3 @@\n-      DISABLED_WARNINGS=\"unknown-warning-option unused-parameter unused\"\n+      # These warnings will never be turned on, since they generate too many\n+      # false positives.\n+      DISABLED_WARNINGS=\"unknown-warning-option unused-parameter\"\n@@ -479,1 +483,1 @@\n-  ###############################################################################\n+  ##############################################################################\n@@ -513,1 +517,1 @@\n-  ###############################################################################\n+  ##############################################################################\n","filename":"make\/autoconf\/flags-cflags.m4","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -171,3 +171,3 @@\n-       test \"x${OPENJDK_$1_CPU}\" = xmipsel ||\n-       test \"x${OPENJDK_$1_CPU}\" = xmips64 ||\n-       test \"x${OPENJDK_$1_CPU}\" = xmips64el; then\n+        test \"x${OPENJDK_$1_CPU}\" = xmipsel ||\n+        test \"x${OPENJDK_$1_CPU}\" = xmips64 ||\n+        test \"x${OPENJDK_$1_CPU}\" = xmips64el; then\n","filename":"make\/autoconf\/flags-ldflags.m4","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-###############################################################################\n+################################################################################\n@@ -41,1 +41,1 @@\n-###############################################################################\n+################################################################################\n@@ -105,1 +105,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/hotspot.m4","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -84,1 +84,1 @@\n-###############################################################################\n+################################################################################\n@@ -238,2 +238,2 @@\n-         test \"x$OPENJDK_TARGET_OS\" != \"xbsd\" &&\n-         test \"x$OPENJDK_TARGET_OS\" != \"xaix\"; then\n+        test \"x$OPENJDK_TARGET_OS\" != \"xbsd\" &&\n+        test \"x$OPENJDK_TARGET_OS\" != \"xaix\"; then\n@@ -249,1 +249,1 @@\n-###############################################################################\n+################################################################################\n@@ -413,1 +413,1 @@\n-###############################################################################\n+################################################################################\n@@ -424,2 +424,2 @@\n-           test \"x$TOOLCHAIN_TYPE\" = \"xclang\" ||\n-           test \"x$TOOLCHAIN_TYPE\" = \"xmicrosoft\"; then\n+            test \"x$TOOLCHAIN_TYPE\" = \"xclang\" ||\n+            test \"x$TOOLCHAIN_TYPE\" = \"xmicrosoft\"; then\n@@ -434,1 +434,1 @@\n-           test \"x$TOOLCHAIN_TYPE\" = \"xclang\"; then\n+            test \"x$TOOLCHAIN_TYPE\" = \"xclang\"; then\n@@ -470,1 +470,1 @@\n-###############################################################################\n+################################################################################\n@@ -503,1 +503,1 @@\n-###############################################################################\n+################################################################################\n@@ -710,3 +710,2 @@\n-       [Set to disable to prevent any absolute paths from the build to end up in\n-        any of the build output. @<:@disabled in release builds, otherwise enabled@:>@])\n-      ])\n+      [Set to disable to prevent any absolute paths from the build to end up in\n+      any of the build output. @<:@disabled in release builds, otherwise enabled@:>@])])\n","filename":"make\/autoconf\/jdk-options.m4","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -96,1 +96,1 @@\n-       properties of MS Windows binaries.],\n+        properties of MS Windows binaries.],\n@@ -108,1 +108,1 @@\n-       and 'java.vm.vendor' system properties.],\n+        and 'java.vm.vendor' system properties.],\n","filename":"make\/autoconf\/jdk-version.m4","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -39,1 +39,1 @@\n-###############################################################################\n+################################################################################\n@@ -81,1 +81,1 @@\n-###############################################################################\n+################################################################################\n@@ -202,1 +202,1 @@\n-###############################################################################\n+################################################################################\n@@ -228,1 +228,1 @@\n-###############################################################################\n+################################################################################\n@@ -244,1 +244,1 @@\n-###############################################################################\n+################################################################################\n@@ -273,1 +273,1 @@\n-###############################################################################\n+################################################################################\n@@ -293,1 +293,1 @@\n-###############################################################################\n+################################################################################\n@@ -312,1 +312,1 @@\n-###############################################################################\n+################################################################################\n@@ -368,1 +368,1 @@\n-###############################################################################\n+################################################################################\n@@ -386,1 +386,1 @@\n-###############################################################################\n+################################################################################\n@@ -434,1 +434,1 @@\n-###############################################################################\n+################################################################################\n@@ -482,1 +482,1 @@\n-###############################################################################\n+################################################################################\n@@ -492,1 +492,1 @@\n-###############################################################################\n+################################################################################\n@@ -530,1 +530,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/jvm-features.m4","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-     [use libpng from build system or OpenJDK source (system, bundled) @<:@bundled@:>@])])\n+      [use libpng from build system or OpenJDK source (system, bundled) @<:@bundled@:>@])])\n","filename":"make\/autoconf\/lib-bundled.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,5 +76,5 @@\n-       The selected option applies to both build time and run time.\n-       The default behaviour can be platform dependent.\n-       If using 'system' and either the include files or libraries cannot be\n-       located automatically, then additionally specify both using\n-       --with-freetype-include and --with-freetype-lib.])])\n+      The selected option applies to both build time and run time.\n+      The default behaviour can be platform dependent.\n+      If using 'system' and either the include files or libraries cannot be\n+      located automatically, then additionally specify both using\n+      --with-freetype-include and --with-freetype-lib.])])\n@@ -98,2 +98,4 @@\n-  if (test \"x$with_freetype_include\" = \"x\" && test \"x$with_freetype_lib\" != \"x\") || \\\n-     (test \"x$with_freetype_include\" != \"x\" && test \"x$with_freetype_lib\" = \"x\"); then\n+  if (test \"x$with_freetype_include\" = \"x\" && \\\n+      test \"x$with_freetype_lib\" != \"x\") || \\\n+      (test \"x$with_freetype_include\" != \"x\" && \\\n+      test \"x$with_freetype_lib\" = \"x\"); then\n@@ -129,2 +131,2 @@\n-     (test \"x$OPENJDK_TARGET_OS\" = \"xwindows\" || \\\n-     test \"x$OPENJDK_TARGET_OS\" = \"xmacosx\"); then\n+      (test \"x$OPENJDK_TARGET_OS\" = \"xwindows\" || \\\n+      test \"x$OPENJDK_TARGET_OS\" = \"xmacosx\"); then\n","filename":"make\/autoconf\/lib-freetype.m4","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -166,2 +166,2 @@\n-     test -e $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a && \\\n-     test -e $BINUTILS_INSTALL_DIR\/lib\/libiberty.a; then\n+      test -e $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a && \\\n+      test -e $BINUTILS_INSTALL_DIR\/lib\/libiberty.a; then\n@@ -270,2 +270,4 @@\n-       test -e $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a && \\\n-       (test -e $BINUTILS_INSTALL_DIR\/lib\/libiberty.a || test -e $BINUTILS_INSTALL_DIR\/lib64\/libiberty.a || test -e $BINUTILS_INSTALL_DIR\/lib32\/libiberty.a); then\n+        test -e $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a && \\\n+        (test -e $BINUTILS_INSTALL_DIR\/lib\/libiberty.a || \\\n+        test -e $BINUTILS_INSTALL_DIR\/lib64\/libiberty.a || \\\n+        test -e $BINUTILS_INSTALL_DIR\/lib32\/libiberty.a); then\n","filename":"make\/autoconf\/lib-hsdis.m4","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-###############################################################################\n+################################################################################\n@@ -77,1 +77,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/lib-tests.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,6 +102,6 @@\n-         test \"x$OPENJDK_$1_CPU\" = xm68k ||\n-         test \"x$OPENJDK_$1_CPU\" = xmips ||\n-         test \"x$OPENJDK_$1_CPU\" = xmipsel ||\n-         test \"x$OPENJDK_$1_CPU\" = xppc ||\n-         test \"x$OPENJDK_$1_CPU\" = xsh ||\n-         test \"x$OPENJDK_$1_CPU\" = xriscv32); then\n+        test \"x$OPENJDK_$1_CPU\" = xm68k ||\n+        test \"x$OPENJDK_$1_CPU\" = xmips ||\n+        test \"x$OPENJDK_$1_CPU\" = xmipsel ||\n+        test \"x$OPENJDK_$1_CPU\" = xppc ||\n+        test \"x$OPENJDK_$1_CPU\" = xsh ||\n+        test \"x$OPENJDK_$1_CPU\" = xriscv32); then\n","filename":"make\/autoconf\/libraries.m4","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-       [build 32-bit or 64-bit binaries (for platforms that support it), e.g. --with-target-bits=32 @<:@guessed@:>@])])\n+      [build 32-bit or 64-bit binaries (for platforms that support it), e.g. --with-target-bits=32 @<:@guessed@:>@])])\n@@ -668,1 +668,1 @@\n-       [Suppress the error when configuring for a deprecated port @<:@no@:>@])])\n+      [Suppress the error when configuring for a deprecated port @<:@no@:>@])])\n@@ -681,1 +681,1 @@\n-  ###############################################################################\n+  ##############################################################################\n@@ -696,1 +696,1 @@\n-  ###############################################################################\n+  ##############################################################################\n@@ -742,1 +742,1 @@\n-  ###############################################################################\n+  ##############################################################################\n","filename":"make\/autoconf\/platform.m4","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-ifneq ($(COMPANY_NAME),)\n+ifneq ($(COMPANY_NAME), )\n@@ -291,1 +291,1 @@\n-ifneq ($(VENDOR_URL),)\n+ifneq ($(VENDOR_URL), )\n@@ -294,1 +294,1 @@\n-ifneq ($(VENDOR_URL_BUG),)\n+ifneq ($(VENDOR_URL_BUG), )\n@@ -297,1 +297,1 @@\n-ifneq ($(VENDOR_URL_VM_BUG),)\n+ifneq ($(VENDOR_URL_VM_BUG), )\n@@ -807,2 +807,0 @@\n-####################################################\n-#\n@@ -810,2 +808,0 @@\n-#\n-\n@@ -824,2 +820,0 @@\n-####################################################\n-#\n@@ -827,2 +821,0 @@\n-#\n-\n","filename":"make\/autoconf\/spec.gmk.template","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-########################################################################\n+################################################################################\n@@ -33,1 +33,1 @@\n-########################################################################\n+################################################################################\n","filename":"make\/autoconf\/toolchain.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-       pass to vcvarsall.bat (Windows only)])])\n+      pass to vcvarsall.bat (Windows only)])])\n","filename":"make\/autoconf\/toolchain_microsoft.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-###############################################################################\n+################################################################################\n@@ -103,1 +103,1 @@\n-###############################################################################\n+################################################################################\n@@ -124,1 +124,1 @@\n-###############################################################################\n+################################################################################\n@@ -140,1 +140,1 @@\n-###############################################################################\n+################################################################################\n@@ -156,1 +156,1 @@\n-###############################################################################\n+################################################################################\n@@ -168,1 +168,1 @@\n-###############################################################################\n+################################################################################\n@@ -180,1 +180,1 @@\n-###############################################################################\n+################################################################################\n@@ -207,1 +207,1 @@\n-###############################################################################\n+################################################################################\n@@ -234,1 +234,1 @@\n-###############################################################################\n+################################################################################\n@@ -262,1 +262,1 @@\n-###############################################################################\n+################################################################################\n@@ -276,1 +276,1 @@\n-###############################################################################\n+################################################################################\n@@ -297,1 +297,1 @@\n-###############################################################################\n+################################################################################\n@@ -307,1 +307,1 @@\n-###############################################################################\n+################################################################################\n@@ -317,1 +317,1 @@\n-###############################################################################\n+################################################################################\n@@ -332,1 +332,1 @@\n-###############################################################################\n+################################################################################\n@@ -474,1 +474,1 @@\n-###############################################################################\n+################################################################################\n@@ -578,1 +578,1 @@\n-###############################################################################\n+################################################################################\n@@ -813,1 +813,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/util.m4","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -39,1 +39,1 @@\n-###############################################################################\n+################################################################################\n@@ -52,1 +52,1 @@\n-###############################################################################\n+################################################################################\n@@ -121,1 +121,1 @@\n-##############################################################################\n+################################################################################\n@@ -139,1 +139,1 @@\n-###############################################################################\n+################################################################################\n@@ -173,1 +173,1 @@\n-###############################################################################\n+################################################################################\n@@ -292,1 +292,1 @@\n-###############################################################################\n+################################################################################\n@@ -372,1 +372,1 @@\n-###############################################################################\n+################################################################################\n@@ -439,1 +439,1 @@\n-###############################################################################\n+################################################################################\n@@ -455,1 +455,1 @@\n-###############################################################################\n+################################################################################\n@@ -465,1 +465,1 @@\n-###############################################################################\n+################################################################################\n@@ -476,1 +476,1 @@\n-###############################################################################\n+################################################################################\n@@ -488,1 +488,1 @@\n-###############################################################################\n+################################################################################\n@@ -500,1 +500,1 @@\n-###############################################################################\n+################################################################################\n@@ -513,1 +513,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/util_paths.m4","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n","filename":"make\/common\/CopyFiles.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n","filename":"make\/common\/Execute.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -290,1 +290,1 @@\n-    $(eval CacheFindFiles_NEW_DIRS := $$(filter-out $$(addsuffix \/%,\\\n+    $(eval CacheFindFiles_NEW_DIRS := $$(filter-out $$(addsuffix \/%, \\\n","filename":"make\/common\/FileUtils.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-   ) \\\n+  ) \\\n","filename":"make\/common\/FindTests.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -35,1 +35,1 @@\n-FALSE_FIND_PATTERN:=-name FILE_NAME_THAT_DOESNT_EXIST\n+FALSE_FIND_PATTERN := -name FILE_NAME_THAT_DOESNT_EXIST\n@@ -43,1 +43,1 @@\n-#   DEPENDENCIES:=List of dependencies for the jar target. If left empty,\n+#   DEPENDENCIES List of dependencies for the jar target. If left empty,\n@@ -47,12 +47,12 @@\n-#   SRCS:=List of directories in where to find files to add to archive\n-#   BIN:=Directory where to store build control files\n-#   SUFFIXES:=File suffixes to include in jar\n-#   INCLUDES:=List of directories\/packages in SRCS that should be included\n-#   EXCLUDES:=List of directories\/packages in SRCS that should be excluded\n-#   EXCLUDE_FILES:=List of files in SRCS that should be excluded\n-#   EXTRA_FILES:=List of files in SRCS that should be included regardless of suffix match.\n-#   JAR:=Jar file to create\n-#   MANIFEST:=Optional manifest file template.\n-#   JARMAIN:=Optional main class to add to manifest\n-#   JARINDEX:=true means generate the index in the jar file.\n-#   SKIP_METAINF:=Set to prevent contents of an META-INF directory to be automatically\n+#   SRCS List of directories in where to find files to add to archive\n+#   BIN Directory where to store build control files\n+#   SUFFIXES File suffixes to include in jar\n+#   INCLUDES List of directories\/packages in SRCS that should be included\n+#   EXCLUDES List of directories\/packages in SRCS that should be excluded\n+#   EXCLUDE_FILES List of files in SRCS that should be excluded\n+#   EXTRA_FILES List of files in SRCS that should be included regardless of suffix match.\n+#   JAR Jar file to create\n+#   MANIFEST Optional manifest file template.\n+#   JARMAIN Optional main class to add to manifest\n+#   JARINDEX true means generate the index in the jar file.\n+#   SKIP_METAINF Set to prevent contents of an META-INF directory to be automatically\n@@ -60,1 +60,1 @@\n-#   EXTRA_MANIFEST_ATTR:=Extra attribute to add to manifest.\n+#   EXTRA_MANIFEST_ATTR Extra attribute to add to manifest.\n@@ -62,1 +62,1 @@\n-#   JAR_CMD:=Optionally override the jar command to use when creating the archive.\n+#   JAR_CMD Optionally override the jar command to use when creating the archive.\n@@ -66,2 +66,2 @@\n-  $1_JARMAIN:=$(strip $$($1_JARMAIN))\n-  $1_JARNAME:=$$(notdir $$($1_JAR))\n+  $1_JARMAIN := $(strip $$($1_JARMAIN))\n+  $1_JARNAME := $$(notdir $$($1_JAR))\n@@ -70,3 +70,3 @@\n-  $1_MANIFEST_FILE:=$$($1_BIN)\/_the.$$($1_JARNAME)_manifest\n-  $1_DELETESS_FILE:=$$($1_BIN)\/_the.$$($1_JARNAME)_deletess\n-  $1_DELETES_FILE:=$$($1_BIN)\/_the.$$($1_JARNAME)_deletes\n+  $1_MANIFEST_FILE := $$($1_BIN)\/_the.$$($1_JARNAME)_manifest\n+  $1_DELETESS_FILE := $$($1_BIN)\/_the.$$($1_JARNAME)_deletess\n+  $1_DELETES_FILE := $$($1_BIN)\/_the.$$($1_JARNAME)_deletes\n@@ -75,1 +75,1 @@\n-  ifeq (,$$($1_SUFFIXES))\n+  ifeq ($$($1_SUFFIXES), )\n@@ -77,1 +77,1 @@\n-    $1_SUFFIXES:=.class\n+    $1_SUFFIXES := .class\n@@ -80,1 +80,1 @@\n-  $1_FIND_PATTERNS:=$(FALSE_FIND_PATTERN) $$(patsubst %,$(SPACE)-o$(SPACE)-name$(SPACE)$(DQUOTE)*%$(DQUOTE),$$($1_SUFFIXES))\n+  $1_FIND_PATTERNS := $(FALSE_FIND_PATTERN) $$(patsubst %,$(SPACE)-o$(SPACE)-name$(SPACE)$(DQUOTE)*%$(DQUOTE),$$($1_SUFFIXES))\n@@ -84,2 +84,2 @@\n-  ifneq (,$$($1_INCLUDES))\n-    $1_GREP_INCLUDE_PATTERNS:=$$(call EscapeDollar, \\\n+  ifneq ($$($1_INCLUDES), )\n+    $1_GREP_INCLUDE_PATTERNS := $$(call EscapeDollar, \\\n@@ -88,2 +88,2 @@\n-    ifeq ($$(word 20,$$($1_GREP_INCLUDE_PATTERNS)),)\n-      $1_GREP_INCLUDES:=| ( $(GREP) $$(patsubst %,$(SPACE)-e$(SPACE)$(DQUOTE)%$(DQUOTE),$$($1_GREP_INCLUDE_PATTERNS)) \\\n+    ifeq ($$(word 20, $$($1_GREP_INCLUDE_PATTERNS)), )\n+      $1_GREP_INCLUDES := | ( $(GREP) $$(patsubst %,$(SPACE)-e$(SPACE)$(DQUOTE)%$(DQUOTE),$$($1_GREP_INCLUDE_PATTERNS)) \\\n@@ -93,1 +93,1 @@\n-          $$(eval $$(call ListPathsSafely,$1_GREP_INCLUDE_PATTERNS, \\\n+          $$(eval $$(call ListPathsSafely, $1_GREP_INCLUDE_PATTERNS, \\\n@@ -95,1 +95,1 @@\n-      $1_GREP_INCLUDES:=| ( $(GREP) -f $$($1_BIN)\/_the.$$($1_JARNAME)_include \\\n+      $1_GREP_INCLUDES := | ( $(GREP) -f $$($1_BIN)\/_the.$$($1_JARNAME)_include \\\n@@ -99,3 +99,3 @@\n-  ifneq (,$$($1_EXCLUDES)$$($1_EXCLUDE_FILES))\n-    $1_GREP_EXCLUDE_PATTERNS:=$$(call EscapeDollar, \\\n-        $$(foreach src,$$($1_SRCS),$$(addprefix $$(src)\/, \\\n+  ifneq ($$($1_EXCLUDES)$$($1_EXCLUDE_FILES), )\n+    $1_GREP_EXCLUDE_PATTERNS := $$(call EscapeDollar, \\\n+        $$(foreach src, $$($1_SRCS), $$(addprefix $$(src)\/, \\\n@@ -104,2 +104,2 @@\n-    ifeq ($$(word 20,$$($1_GREP_EXCLUDE_PATTERNS)),)\n-      $1_GREP_EXCLUDES:=| ( $(GREP) -v $$(patsubst %,$(SPACE)-e$(SPACE)$(DQUOTE)%$(DQUOTE),$$($1_GREP_EXCLUDE_PATTERNS)) \\\n+    ifeq ($$(word 20, $$($1_GREP_EXCLUDE_PATTERNS)), )\n+      $1_GREP_EXCLUDES := | ( $(GREP) -v $$(patsubst %,$(SPACE)-e$(SPACE)$(DQUOTE)%$(DQUOTE),$$($1_GREP_EXCLUDE_PATTERNS)) \\\n@@ -109,1 +109,1 @@\n-          $$(eval $$(call ListPathsSafely,$1_GREP_EXCLUDE_PATTERNS, \\\n+          $$(eval $$(call ListPathsSafely, $1_GREP_EXCLUDE_PATTERNS, \\\n@@ -111,1 +111,1 @@\n-      $1_GREP_EXCLUDES:=| ( $(GREP) -v -f $$($1_BIN)\/_the.$$($1_JARNAME)_exclude \\\n+      $1_GREP_EXCLUDES := | ( $(GREP) -v -f $$($1_BIN)\/_the.$$($1_JARNAME)_exclude \\\n@@ -117,1 +117,1 @@\n-  ifneq (,$$($1_JARINDEX))\n+  ifneq ($$($1_JARINDEX), )\n@@ -130,4 +130,4 @@\n-    $1_DEPENDENCIES:=$$(filter $$(addprefix %,$$($1_SUFFIXES)), \\\n-        $$(call FindFiles,$$($1_SRCS)))\n-    ifneq (,$$($1_GREP_INCLUDE_PATTERNS))\n-      $1_DEPENDENCIES:=$$(filter $$(addsuffix %,$$($1_GREP_INCLUDE_PATTERNS)),$$($1_DEPENDENCIES))\n+    $1_DEPENDENCIES := $$(filter $$(addprefix %, $$($1_SUFFIXES)), \\\n+        $$(call FindFiles, $$($1_SRCS)))\n+    ifneq ($$($1_GREP_INCLUDE_PATTERNS), )\n+      $1_DEPENDENCIES := $$(filter $$(addsuffix %, $$($1_GREP_INCLUDE_PATTERNS)), $$($1_DEPENDENCIES))\n@@ -135,2 +135,2 @@\n-    ifneq (,$$($1_GREP_EXCLUDE_PATTERNS))\n-      $1_DEPENDENCIES:=$$(filter-out $$(addsuffix %,$$($1_GREP_EXCLUDE_PATTERNS)),$$($1_DEPENDENCIES))\n+    ifneq ($$($1_GREP_EXCLUDE_PATTERNS), )\n+      $1_DEPENDENCIES := $$(filter-out $$(addsuffix %, $$($1_GREP_EXCLUDE_PATTERNS)), $$($1_DEPENDENCIES))\n@@ -139,1 +139,1 @@\n-    $1_DEPENDENCIES+=$$(wildcard $$(foreach src, $$($1_SRCS), \\\n+    $1_DEPENDENCIES += $$(wildcard $$(foreach src, $$($1_SRCS), \\\n@@ -141,2 +141,2 @@\n-    ifeq (,$$($1_SKIP_METAINF))\n-      $1_DEPENDENCIES+=$$(call FindFiles,$$(wildcard $$(addsuffix \/META-INF,$$($1_SRCS))))\n+    ifeq ($$($1_SKIP_METAINF), )\n+      $1_DEPENDENCIES += $$(call FindFiles, $$(wildcard $$(addsuffix \/META-INF, $$($1_SRCS))))\n@@ -159,2 +159,2 @@\n-  $1_CAPTURE_EXTRA_FILES=\\\n-      $$(eval $1_EXTRA_FILES_RESOLVED:=$$(call DoubleDollar, \\\n+  $1_CAPTURE_EXTRA_FILES = \\\n+      $$(eval $1_EXTRA_FILES_RESOLVED := $$(call DoubleDollar, \\\n@@ -164,1 +164,1 @@\n-        $$(eval $$(call ListPathsSafely,$1_EXTRA_FILES_RESOLVED, \\\n+        $$(eval $$(call ListPathsSafely, $1_EXTRA_FILES_RESOLVED, \\\n@@ -166,1 +166,1 @@\n-        $(SED) $$(foreach src,$$($1_SRCS), -e 's|$$(src)\/|-C $$(src) |g') \\\n+        $(SED) $$(foreach src, $$($1_SRCS), -e 's|$$(src)\/|-C $$(src) |g') \\\n@@ -173,1 +173,1 @@\n-  $1_CAPTURE_CONTENTS=\\\n+  $1_CAPTURE_CONTENTS = \\\n@@ -175,1 +175,1 @@\n-      $$(foreach src,$$($1_SRCS), \\\n+      $$(foreach src, $$($1_SRCS), \\\n@@ -183,2 +183,2 @@\n-  ifeq (,$$($1_SKIP_METAINF))\n-    $1_CAPTURE_METAINF =$$(foreach src,$$($1_SRCS), \\\n+  ifeq ($$($1_SKIP_METAINF), )\n+    $1_CAPTURE_METAINF = $$(foreach src, $$($1_SRCS), \\\n@@ -191,1 +191,1 @@\n-  $1_CAPTURE_DELETES=$$(foreach src,$$($1_SRCS),($(FIND) $$(src) -name _the.package.deleted -newer $$@ \\\n+  $1_CAPTURE_DELETES = $$(foreach src, $$($1_SRCS), ($(FIND) $$(src) -name _the.package.deleted -newer $$@ \\\n@@ -195,1 +195,1 @@\n-  $1_UPDATE_CONTENTS=\\\n+  $1_UPDATE_CONTENTS = \\\n@@ -203,1 +203,1 @@\n-  $1_SCAPTURE_CONTENTS=\\\n+  $1_SCAPTURE_CONTENTS = \\\n@@ -205,1 +205,1 @@\n-      $$(foreach src,$$($1_SRCS), \\\n+      $$(foreach src, $$($1_SRCS), \\\n@@ -212,2 +212,2 @@\n-  ifeq (,$$($1_SKIP_METAINF))\n-    $1_SCAPTURE_METAINF=$$(foreach src,$$($1_SRCS), \\\n+  ifeq ($$($1_SKIP_METAINF), )\n+    $1_SCAPTURE_METAINF = $$(foreach src, $$($1_SRCS), \\\n@@ -218,1 +218,1 @@\n-  $1_SUPDATE_CONTENTS=\\\n+  $1_SUPDATE_CONTENTS = \\\n@@ -223,1 +223,1 @@\n-  $1_NAME:=$$(subst $$(OUTPUTDIR)\/,,$$($1_JAR))\n+  $1_NAME := $$(subst $$(OUTPUTDIR)\/,,$$($1_JAR))\n@@ -231,1 +231,1 @@\n-  ifneq (,$$($1_CHECK_COMPRESS_JAR))\n+  ifneq ($$($1_CHECK_COMPRESS_JAR), )\n","filename":"make\/common\/JarArchive.gmk","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -60,1 +60,1 @@\n-  $2_TARGET:=$2\n+  $2_TARGET := $2\n@@ -62,1 +62,1 @@\n-  $$(foreach i,$$($1_SRC),$$(eval $$(call remove_string,$$i,$2_TARGET)))\n+  $$(foreach i, $$($1_SRC), $$(eval $$(call remove_string,$$i,$2_TARGET)))\n@@ -101,1 +101,1 @@\n-  $2_TARGET:=$2\n+  $2_TARGET := $2\n@@ -103,1 +103,1 @@\n-  $$(foreach i,$$($1_SRC),$$(eval $$(call remove_string,$$i,$2_TARGET)))\n+  $$(foreach i, $$($1_SRC), $$(eval $$(call remove_string,$$i,$2_TARGET)))\n@@ -141,3 +141,3 @@\n-#   SMALL_JAVA:=set to false to run javac as a \"big\" java app\n-#   COMPILER:=bootjdk or interim, the latter is default\n-#   TARGET_RELEASE:=javac flags to set the targeted jdk release (-source\/-target or --release)\n+#   SMALL_JAVA set to false to run javac as a \"big\" java app\n+#   COMPILER bootjdk or interim, the latter is default\n+#   TARGET_RELEASE javac flags to set the targeted jdk release (-source\/-target or --release)\n@@ -145,4 +145,4 @@\n-#   JAVAC_FLAGS:=javac flags to append to the default ones.\n-#   JAVA_FLAGS:=flags to be appended to the java launching the compiler\n-#   DISABLED_WARNINGS:=list of Xlint warnings that should be disabled\n-#   SRC:=one or more directories to search for sources. The order of the source roots\n+#   JAVAC_FLAGS javac flags to append to the default ones.\n+#   JAVA_FLAGS flags to be appended to the java launching the compiler\n+#   DISABLED_WARNINGS list of Xlint warnings that should be disabled\n+#   SRC one or more directories to search for sources. The order of the source roots\n@@ -150,12 +150,12 @@\n-#   BIN:=store classes here\n-#   MODULE:=Name of module being compiled. If set, classes are put in BIN\/MODULE.\n-#   CLASSPATH:=a list of additional entries to set as classpath to javac\n-#   INCLUDES:=myapp.foo means will only compile java files in myapp.foo or any of its sub-packages.\n-#   EXCLUDES:=myapp.foo means will do not compile java files in myapp.foo or any of its sub-packages.\n-#   COPY:=.prp means copy all prp files to the corresponding package in BIN.\n-#   COPY_FILES:=myapp\/foo\/setting.txt means copy this file over to the package myapp\/foo\n-#   CLEAN:=.properties means copy and clean all properties file to the corresponding package in BIN.\n-#   CLEAN_FILES:=myapp\/foo\/setting.txt means clean this file over to the package myapp\/foo\n-#   SRCZIP:=Create a src.zip based on the found sources and copied files.\n-#   INCLUDE_FILES:=\"com\/sun\/SolarisFoobar.java\" means only compile this file!\n-#   EXCLUDE_FILES:=\"com\/sun\/SolarisFoobar.java\" means do not compile this particular file!\n+#   BIN store classes here\n+#   MODULE Name of module being compiled. If set, classes are put in BIN\/MODULE.\n+#   CLASSPATH a list of additional entries to set as classpath to javac\n+#   INCLUDES myapp.foo means will only compile java files in myapp.foo or any of its sub-packages.\n+#   EXCLUDES myapp.foo means will do not compile java files in myapp.foo or any of its sub-packages.\n+#   COPY .prp means copy all prp files to the corresponding package in BIN.\n+#   COPY_FILES myapp\/foo\/setting.txt means copy this file over to the package myapp\/foo\n+#   CLEAN .properties means copy and clean all properties file to the corresponding package in BIN.\n+#   CLEAN_FILES myapp\/foo\/setting.txt means clean this file over to the package myapp\/foo\n+#   SRCZIP Create a src.zip based on the found sources and copied files.\n+#   INCLUDE_FILES \"com\/sun\/SolarisFoobar.java\" means only compile this file!\n+#   EXCLUDE_FILES \"com\/sun\/SolarisFoobar.java\" means do not compile this particular file!\n@@ -163,1 +163,1 @@\n-#   EXTRA_FILES:=List of extra source files to include in compilation. Can be used to\n+#   EXTRA_FILES List of extra source files to include in compilation. Can be used to\n@@ -165,4 +165,4 @@\n-#   HEADERS:=path to directory where all generated c-headers are written.\n-#   DEPENDS:=Extra dependency\n-#   KEEP_DUPS:=Do not remove duplicate file names from different source roots.\n-#   FAIL_NO_SRC:=Set to false to not fail the build if no source files are found,\n+#   HEADERS path to directory where all generated c-headers are written.\n+#   DEPENDS Extra dependency\n+#   KEEP_DUPS Do not remove duplicate file names from different source roots.\n+#   FAIL_NO_SRC Set to false to not fail the build if no source files are found,\n@@ -170,1 +170,1 @@\n-#   CREATE_API_DIGEST:=Set to true to use a javac plugin to generate a public API\n+#   CREATE_API_DIGEST Set to true to use a javac plugin to generate a public API\n@@ -173,1 +173,1 @@\n-#   KEEP_ALL_TRANSLATIONS:=Set to true to skip translation filtering\n+#   KEEP_ALL_TRANSLATIONS Set to true to skip translation filtering\n@@ -178,1 +178,1 @@\n-  ifeq ($$($1_BIN),)\n+  ifeq ($$($1_BIN), )\n@@ -258,1 +258,1 @@\n-       $1_JAVAC_CMD := $$(JAVA_SMALL) $$($1_JAVA_FLAGS) $$($1_JAVAC)\n+        $1_JAVAC_CMD := $$(JAVA_SMALL) $$($1_JAVA_FLAGS) $$($1_JAVAC)\n@@ -260,1 +260,1 @@\n-       $1_JAVAC_CMD := $$(JAVA) $$($1_JAVA_FLAGS) $$($1_JAVAC)\n+        $1_JAVAC_CMD := $$(JAVA) $$($1_JAVA_FLAGS) $$($1_JAVAC)\n@@ -316,1 +316,1 @@\n-  $$(call MakeDir,$$($1_BIN))\n+  $$(call MakeDir, $$($1_BIN))\n@@ -372,1 +372,1 @@\n-    $1_ALL_COPIES := $$(filter $$(addsuffix \/META-INF%,$$($1_SRC)),$$($1_ALL_SRCS))\n+    $1_ALL_COPIES := $$(filter $$(addsuffix \/META-INF%, $$($1_SRC)), $$($1_ALL_SRCS))\n@@ -374,1 +374,1 @@\n-    ifneq (,$$($1_COPY)$$($1_COPY_FILES))\n+    ifneq ($$($1_COPY)$$($1_COPY_FILES), )\n@@ -376,1 +376,1 @@\n-      $1_ALL_COPIES += $$(filter $$(addprefix %,$$($1_COPY)),$$($1_ALL_SRCS))\n+      $1_ALL_COPIES += $$(filter $$(addprefix %, $$($1_COPY)), $$($1_ALL_SRCS))\n@@ -381,2 +381,2 @@\n-    ifneq (,$$($1_INCLUDE_PATTERN))\n-      $1_ALL_COPIES := $$(filter $$($1_INCLUDE_PATTERN),$$($1_ALL_COPIES))\n+    ifneq ($$($1_INCLUDE_PATTERN), )\n+      $1_ALL_COPIES := $$(filter $$($1_INCLUDE_PATTERN), $$($1_ALL_COPIES))\n@@ -384,2 +384,2 @@\n-    ifneq (,$$($1_EXCLUDE_PATTERN))\n-      $1_ALL_COPIES := $$(filter-out $$($1_EXCLUDE_PATTERN),$$($1_ALL_COPIES))\n+    ifneq ($$($1_EXCLUDE_PATTERN), )\n+      $1_ALL_COPIES := $$(filter-out $$($1_EXCLUDE_PATTERN), $$($1_ALL_COPIES))\n@@ -391,1 +391,1 @@\n-    ifneq (,$$($1_ALL_COPIES))\n+    ifneq ($$($1_ALL_COPIES), )\n@@ -393,2 +393,2 @@\n-      $1_ALL_COPY_TARGETS:=\n-          $$(foreach i,$$($1_ALL_COPIES),$$(eval $$(call add_file_to_copy,$1,$$i)))\n+      $1_ALL_COPY_TARGETS :=\n+          $$(foreach i, $$($1_ALL_COPIES), $$(eval $$(call add_file_to_copy,$1,$$i)))\n@@ -399,1 +399,1 @@\n-    ifneq (,$$($1_CLEAN)$$($1_CLEAN_FILES))\n+    ifneq ($$($1_CLEAN)$$($1_CLEAN_FILES), )\n@@ -401,1 +401,1 @@\n-      $1_ALL_CLEANS := $$(filter $$(addprefix %,$$($1_CLEAN)),$$($1_ALL_SRCS))\n+      $1_ALL_CLEANS := $$(filter $$(addprefix %, $$($1_CLEAN)), $$($1_ALL_SRCS))\n@@ -405,2 +405,2 @@\n-      ifneq (,$$($1_INCLUDE_PATTERN))\n-        $1_ALL_CLEANS := $$(filter $$($1_INCLUDE_PATTERN),$$($1_ALL_CLEANS))\n+      ifneq ($$($1_INCLUDE_PATTERN), )\n+        $1_ALL_CLEANS := $$(filter $$($1_INCLUDE_PATTERN), $$($1_ALL_CLEANS))\n@@ -408,2 +408,2 @@\n-      ifneq (,$$($1_EXCLUDE_PATTERN))\n-        $1_ALL_CLEANS := $$(filter-out $$($1_EXCLUDE_PATTERN),$$($1_ALL_CLEANS))\n+      ifneq ($$($1_EXCLUDE_PATTERN), )\n+        $1_ALL_CLEANS := $$(filter-out $$($1_EXCLUDE_PATTERN), $$($1_ALL_CLEANS))\n@@ -415,1 +415,1 @@\n-      ifneq (,$$($1_ALL_CLEANS))\n+      ifneq ($$($1_ALL_CLEANS), )\n@@ -417,2 +417,2 @@\n-        $1_ALL_COPY_CLEAN_TARGETS:=\n-            $$(foreach i,$$($1_ALL_CLEANS),$$(eval $$(call add_file_to_clean,$1,$$i)))\n+        $1_ALL_COPY_CLEAN_TARGETS :=\n+            $$(foreach i, $$($1_ALL_CLEANS), $$(eval $$(call add_file_to_clean,$1,$$i)))\n@@ -425,1 +425,1 @@\n-    $1_REWRITE_INTO_CLASSES:=$$(foreach i,$$($1_SRC),-e 's|$$i\/||g') -e 's|\/|.|g' -e 's|.java$$$$||g'\n+    $1_REWRITE_INTO_CLASSES := $$(foreach i, $$($1_SRC), -e 's|$$i\/||g') -e 's|\/|.|g' -e 's|.java$$$$||g'\n@@ -434,1 +434,1 @@\n-    ifneq (,$$($1_HEADERS))\n+    ifneq ($$($1_HEADERS), )\n@@ -506,1 +506,1 @@\n-    ifneq (,$$($1_JAR))\n+    ifneq ($$($1_JAR), )\n@@ -510,2 +510,2 @@\n-      ifeq (,$$($1_SUFFIXES))\n-        $1_SUFFIXES:=.class $$($1_CLEAN) $$($1_COPY)\n+      ifeq ($$($1_SUFFIXES), )\n+        $1_SUFFIXES := .class $$($1_CLEAN) $$($1_COPY)\n@@ -515,12 +515,12 @@\n-          DEPENDENCIES:=$$($1), \\\n-          SRCS:=$$($1_BIN)$$($1_MODULE_SUBDIR), \\\n-          SUFFIXES:=$$($1_SUFFIXES), \\\n-          EXCLUDE:=$$($1_EXCLUDES), \\\n-          INCLUDES:=$$($1_INCLUDES), \\\n-          EXTRA_FILES:=$$($1_ALL_COPY_TARGETS) $$($1_ALL_COPY_CLEAN_TARGETS), \\\n-          JAR:=$$($1_JAR), \\\n-          JARMAIN:=$$($1_JARMAIN), \\\n-          MANIFEST:=$$($1_MANIFEST), \\\n-          EXTRA_MANIFEST_ATTR:=$$($1_EXTRA_MANIFEST_ATTR), \\\n-          JARINDEX:=$$($1_JARINDEX), \\\n-          HEADERS:=$$($1_HEADERS), \\\n+          DEPENDENCIES := $$($1), \\\n+          SRCS := $$($1_BIN)$$($1_MODULE_SUBDIR), \\\n+          SUFFIXES := $$($1_SUFFIXES), \\\n+          EXCLUDE := $$($1_EXCLUDES), \\\n+          INCLUDES := $$($1_INCLUDES), \\\n+          EXTRA_FILES := $$($1_ALL_COPY_TARGETS) $$($1_ALL_COPY_CLEAN_TARGETS), \\\n+          JAR := $$($1_JAR), \\\n+          JARMAIN := $$($1_JARMAIN), \\\n+          MANIFEST := $$($1_MANIFEST), \\\n+          EXTRA_MANIFEST_ATTR := $$($1_EXTRA_MANIFEST_ATTR), \\\n+          JARINDEX := $$($1_JARINDEX), \\\n+          HEADERS := $$($1_HEADERS), \\\n@@ -534,1 +534,1 @@\n-    ifneq (,$$($1_SRCZIP))\n+    ifneq ($$($1_SRCZIP), )\n@@ -536,5 +536,5 @@\n-          SRC:=$$($1_SRC), \\\n-          ZIP:=$$($1_SRCZIP), \\\n-          INCLUDES:=$$($1_INCLUDES), \\\n-          EXCLUDES:=$$($1_EXCLUDES), \\\n-          EXCLUDE_FILES:=$$($1_EXCLUDE_FILES)))\n+          SRC := $$($1_SRC), \\\n+          ZIP := $$($1_SRCZIP), \\\n+          INCLUDES := $$($1_INCLUDES), \\\n+          EXCLUDES := $$($1_EXCLUDES), \\\n+          EXCLUDE_FILES := $$($1_EXCLUDE_FILES)))\n","filename":"make\/common\/JavaCompilation.gmk","additions":77,"deletions":77,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-  ifeq ($$(filter lib%, $$($1_$2_NAME)),)\n+  ifeq ($$(filter lib%, $$($1_$2_NAME)), )\n@@ -190,1 +190,1 @@\n-  ifeq ($$($1_$2_MODULE),)\n+  ifeq ($$($1_$2_MODULE), )\n@@ -199,1 +199,1 @@\n-     $1_$2_STATIC_LIBRARY := true\n+    $1_$2_STATIC_LIBRARY := true\n@@ -202,1 +202,1 @@\n-     $1_$2_STATIC_LIBRARY := true\n+    $1_$2_STATIC_LIBRARY := true\n","filename":"make\/common\/JdkNativeCompilation.gmk","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-################################################################\n+################################################################################\n@@ -31,1 +31,1 @@\n-################################################################\n+################################################################################\n@@ -36,1 +36,1 @@\n-ifeq ($(wildcard $(SPEC)),)\n+ifeq ($(wildcard $(SPEC)), )\n@@ -52,8 +52,8 @@\n-X:=\n-SPACE:=$(X) $(X)\n-COMMA:=,\n-DOLLAR:=$$\n-HASH:=\\#\n-LEFT_PAREN:=(\n-RIGHT_PAREN:=)\n-SQUOTE:='\n+X :=\n+SPACE := $(X) $(X)\n+COMMA := ,\n+DOLLAR := $$\n+HASH := \\#\n+LEFT_PAREN := (\n+RIGHT_PAREN := )\n+SQUOTE := '\n@@ -61,1 +61,1 @@\n-DQUOTE:=\"\n+DQUOTE := \"\n@@ -102,1 +102,1 @@\n-  ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)\n+  ifneq ($$(findstring $$(LOG_LEVEL), debug trace), )\n@@ -120,1 +120,1 @@\n-  ifneq ($$(findstring $$(LOG_LEVEL), info debug trace),)\n+  ifneq ($$(findstring $$(LOG_LEVEL), info debug trace), )\n@@ -127,1 +127,1 @@\n-  ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)\n+  ifneq ($$(findstring $$(LOG_LEVEL), debug trace), )\n@@ -134,1 +134,1 @@\n-  ifneq ($$(findstring $$(LOG_LEVEL), trace),)\n+  ifneq ($$(findstring $$(LOG_LEVEL), trace), )\n@@ -167,1 +167,1 @@\n-  $(if $($(MAX_PARAMS)),$(error Internal makefile error: \\\n+  $(if $($(MAX_PARAMS)), $(error Internal makefile error: \\\n@@ -170,1 +170,1 @@\n-  $(foreach i,$(PARAM_SEQUENCE), $(if $(strip $($i)),\\\n+  $(foreach i, $(PARAM_SEQUENCE), $(if $(strip $($i)), \\\n@@ -174,1 +174,1 @@\n-    $(info $0 $(strip $1) $(foreach i,$(PARAM_SEQUENCE), \\\n+    $(info $0 $(strip $1) $(foreach i, $(PARAM_SEQUENCE), \\\n@@ -249,2 +249,2 @@\n-    $(call WriteFile, $1_old:=$(call DoubleDollar,$(call EscapeHash,$($1))), \\\n-         $($1_filename)) \\\n+    $(call WriteFile, $1_old := $(call DoubleDollar,$(call EscapeHash,$($1))), \\\n+        $($1_filename)) \\\n@@ -263,1 +263,1 @@\n-          $(if $(call equals, $(strip $($1)), $(strip $($1_old))),,\\\n+          $(if $(call equals, $(strip $($1)), $(strip $($1_old))),, \\\n","filename":"make\/common\/MakeBase.gmk","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -70,1 +70,1 @@\n-  decompress_paths=$(SED) -f $(TOPDIR)\/make\/common\/support\/ListPathsSafely-uncompress.sed \\\n+  decompress_paths = $(SED) -f $(TOPDIR)\/make\/common\/support\/ListPathsSafely-uncompress.sed \\\n@@ -76,1 +76,1 @@\n-      $(if $(word $3,$($(strip $1))), \\\n+      $(if $(word $3, $($(strip $1))), \\\n@@ -78,1 +78,1 @@\n-              $(call compress_paths, $(wordlist $3,$4,$($(strip $1))))))\\n\" \\\n+              $(call compress_paths, $(wordlist $3, $4, $($(strip $1))))))\\n\" \\\n@@ -85,1 +85,1 @@\n-    ifneq (,$$(word 30001,$$($$(strip $1))))\n+    ifneq ($$(word 30001, $$($$(strip $1))), )\n","filename":"make\/common\/MakeIO.gmk","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -180,2 +180,2 @@\n-\t    ( $(PRINTF) \"DEPS_$(call GetModuleNameFromModuleInfo, $m) :=\" && \\\n-\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) '\\\n+\t    ( $(PRINTF) \"DEPS_$(call GetModuleNameFromModuleInfo, $m) := \" && \\\n+\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) ' \\\n@@ -194,2 +194,2 @@\n-\t      $(PRINTF) \"TRANSITIVE_MODULES_$(call GetModuleNameFromModuleInfo, $m) :=\" && \\\n-\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) '\\\n+\t      $(PRINTF) \"TRANSITIVE_MODULES_$(call GetModuleNameFromModuleInfo, $m) := \" && \\\n+\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) ' \\\n@@ -224,1 +224,1 @@\n-                 $(call FindDepsForModule, $n))))\n+                $(call FindDepsForModule, $n))))\n@@ -243,1 +243,1 @@\n-                 $(call FindIndirectExportsForModule, $n))))\n+                $(call FindIndirectExportsForModule, $n))))\n","filename":"make\/common\/Modules.gmk","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-      $$(eval $$(call CreateCompiledNativeFile,$1_$$(notdir $$(file)),\\\n+      $$(eval $$(call CreateCompiledNativeFile,$1_$$(notdir $$(file)), \\\n@@ -295,0 +295,1 @@\n+  $1_UNIQUE_NAME = $$($1_TYPE)_$$(subst \/,_,$$(patsubst $$(OUTPUTDIR)\/%\/,%,$$(dir $$($1_OBJECT_DIR))))_$$($1_NOSUFFIX)\n","filename":"make\/common\/NativeCompilation.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -95,1 +95,1 @@\n-        ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)\n+        ifneq ($$(findstring $$(LOG_LEVEL), debug trace), )\n","filename":"make\/common\/ProcessMarkdown.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -98,1 +98,1 @@\n-  $$(foreach file, $$($1_FILTERED_FILE_LIST),\\\n+  $$(foreach file, $$($1_FILTERED_FILE_LIST), \\\n@@ -115,3 +115,6 @@\n-        DISABLED_WARNINGS_gcc := format undef unused-function unused-value, \\\n-        DISABLED_WARNINGS_clang := undef format-nonliteral \\\n-            missing-field-initializers sometimes-uninitialized, \\\n+        DISABLED_WARNINGS_gcc := format undef unused-but-set-variable \\\n+            unused-const-variable unused-function unused-value \\\n+            unused-variable, \\\n+        DISABLED_WARNINGS_clang := format-nonliteral \\\n+            missing-field-initializers sometimes-uninitialized undef \\\n+            unused-but-set-variable unused-function unused-variable, \\\n@@ -122,1 +125,1 @@\n-        OPTIMIZATION := $$(if $$($1_OPTIMIZATION_$$(name)),$$($1_OPTIMIZATION_$$(name)),LOW), \\\n+        OPTIMIZATION := $$(if $$($1_OPTIMIZATION_$$(name)), $$($1_OPTIMIZATION_$$(name)), LOW), \\\n@@ -124,1 +127,1 @@\n-        STRIP_SYMBOLS := $$(if $$($1_STRIP_SYMBOLS_$$(name)),$$($1_STRIP_SYMBOLS_$$(name)),false), \\\n+        STRIP_SYMBOLS := $$(if $$($1_STRIP_SYMBOLS_$$(name)), $$($1_STRIP_SYMBOLS_$$(name)), false), \\\n","filename":"make\/common\/TestFilesCompilation.gmk","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -83,2 +83,2 @@\n-  ifneq ($$($1_SOURCE_FILES),)\n-    ifneq ($$($1_SOURCE_DIRS),)\n+  ifneq ($$($1_SOURCE_FILES), )\n+    ifneq ($$($1_SOURCE_DIRS), )\n@@ -87,1 +87,1 @@\n-    ifneq ($$($1_EXCLUDE_FILES)$$($1_INCLUDE_FILES),)\n+    ifneq ($$($1_EXCLUDE_FILES)$$($1_INCLUDE_FILES), )\n@@ -91,1 +91,1 @@\n-    ifeq ($$($1_SOURCE_DIRS),)\n+    ifeq ($$($1_SOURCE_DIRS), )\n@@ -97,1 +97,1 @@\n-    ifneq ($$($1_SOURCE_BASE_DIR),)\n+    ifneq ($$($1_SOURCE_BASE_DIR), )\n@@ -104,5 +104,5 @@\n-    $1_EXCLUDE_FILES:=$$(foreach i,$$($1_SOURCE_DIRS),$$(addprefix $$i\/,$$($1_EXCLUDE_FILES)))\n-    $1_INCLUDE_FILES:=$$(foreach i,$$($1_SOURCE_DIRS),$$(addprefix $$i\/,$$($1_INCLUDE_FILES)))\n-    $1_SOURCE_FILES := $$(filter-out $$($1_EXCLUDE_FILES),$$($1_SOURCE_FILES))\n-    ifneq (,$$(strip $$($1_INCLUDE_FILES)))\n-      $1_SOURCE_FILES := $$(filter $$($1_INCLUDE_FILES),$$($1_SOURCE_FILES))\n+    $1_EXCLUDE_FILES := $$(foreach i, $$($1_SOURCE_DIRS), $$(addprefix $$i\/, $$($1_EXCLUDE_FILES)))\n+    $1_INCLUDE_FILES := $$(foreach i, $$($1_SOURCE_DIRS), $$(addprefix $$i\/, $$($1_INCLUDE_FILES)))\n+    $1_SOURCE_FILES := $$(filter-out $$($1_EXCLUDE_FILES), $$($1_SOURCE_FILES))\n+    ifneq ($$(strip $$($1_INCLUDE_FILES)), )\n+      $1_SOURCE_FILES := $$(filter $$($1_INCLUDE_FILES), $$($1_SOURCE_FILES))\n@@ -110,1 +110,1 @@\n-    ifeq (,$$($1_SOURCE_FILES))\n+    ifeq ($$($1_SOURCE_FILES), )\n@@ -115,1 +115,1 @@\n-  ifneq ($$($1_REPLACEMENTS),)\n+  ifneq ($$($1_REPLACEMENTS), )\n@@ -117,1 +117,1 @@\n-    ifneq ($$(findstring \/,$$($1_REPLACEMENTS)),)\n+    ifneq ($$(findstring \/, $$($1_REPLACEMENTS)), )\n@@ -119,1 +119,1 @@\n-      ifneq ($$(findstring @,$$($1_REPLACEMENTS)),)\n+      ifneq ($$(findstring @, $$($1_REPLACEMENTS)), )\n@@ -121,1 +121,1 @@\n-        ifneq ($$(findstring |,$$($1_REPLACEMENTS)),)\n+        ifneq ($$(findstring |, $$($1_REPLACEMENTS)), )\n@@ -123,1 +123,1 @@\n-          ifneq ($$(findstring !,$$($1_REPLACEMENTS)),)\n+          ifneq ($$(findstring !, $$($1_REPLACEMENTS)), )\n@@ -164,1 +164,1 @@\n-  ifneq ($$($1_INCLUDES),)\n+  ifneq ($$($1_INCLUDES), )\n@@ -193,1 +193,1 @@\n-  ifneq ($$($1_OUTPUT_FILE),)\n+  ifneq ($$($1_OUTPUT_FILE), )\n@@ -202,1 +202,1 @@\n-    ifeq ($$($1_OUTPUT_DIR),)\n+    ifeq ($$($1_OUTPUT_DIR), )\n@@ -207,1 +207,1 @@\n-    ifeq ($$($1_SOURCE_BASE_DIR),)\n+    ifeq ($$($1_SOURCE_BASE_DIR), )\n","filename":"make\/common\/TextFileProcessing.gmk","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -39,1 +39,1 @@\n-      $(and $(findstring $(strip $1),$(strip $2)),\\\n+      $(and $(findstring $(strip $1),$(strip $2)), \\\n@@ -67,1 +67,1 @@\n-        $(eval SEQUENCE_COUNT :=) \\\n+        $(eval SEQUENCE_COUNT := ) \\\n@@ -228,1 +228,1 @@\n-        $(foreach v,$(strip $2),\\\n+        $(foreach v,$(strip $2), \\\n@@ -245,1 +245,1 @@\n-    $(strip $(if $1,$(patsubst $(firstword $1)%,%,\\\n+    $(strip $(if $1,$(patsubst $(firstword $1)%,%, \\\n@@ -273,1 +273,1 @@\n-         +\"$(ISO_8601_FORMAT_STRING)\" 2> \/dev\/null)\n+        +\"$(ISO_8601_FORMAT_STRING)\" 2> \/dev\/null)\n@@ -277,1 +277,1 @@\n-         +\"$(ISO_8601_FORMAT_STRING)\" 2> \/dev\/null)\n+        +\"$(ISO_8601_FORMAT_STRING)\" 2> \/dev\/null)\n","filename":"make\/common\/Utils.gmk","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -68,3 +68,3 @@\n-  ifneq ($$($1_INCLUDES)$$($1_INCLUDE_FILES),)\n-    $1_FIND_LIST := $$(wildcard $$(foreach s,$$($1_SRC_SLASH), \\\n-        $$(addprefix $$s,$$($1_INCLUDES) $$($1_INCLUDE_FILES))))\n+  ifneq ($$($1_INCLUDES)$$($1_INCLUDE_FILES), )\n+    $1_FIND_LIST := $$(wildcard $$(foreach s, $$($1_SRC_SLASH), \\\n+        $$(addprefix $$s, $$($1_INCLUDES) $$($1_INCLUDE_FILES))))\n@@ -79,1 +79,1 @@\n-    $1_ALL_SRCS := $$(call not-containing,_the.,$$(call ShellFindFiles,$$($1_FIND_LIST), , -L))\n+    $1_ALL_SRCS := $$(call not-containing, _the., $$(call ShellFindFiles, $$($1_FIND_LIST), , -L))\n@@ -81,1 +81,1 @@\n-    $1_ALL_SRCS := $$(call not-containing,_the.,$$(call FindFiles,$$($1_FIND_LIST)))\n+    $1_ALL_SRCS := $$(call not-containing, _the., $$(call FindFiles, $$($1_FIND_LIST)))\n@@ -85,1 +85,1 @@\n-  ifneq ($$($1_SUFFIXES),)\n+  ifneq ($$($1_SUFFIXES), )\n@@ -89,4 +89,4 @@\n-  ifneq ($$($1_INCLUDES),)\n-    ifneq ($$($1_SUFFIXES),)\n-      $1_ZIP_INCLUDES := $$(foreach s,$$($1_SUFFIXES), \\\n-          $$(addprefix -i$(SPACE)$(DQUOTE),$$(addsuffix \/*$$s$(DQUOTE),$$($1_INCLUDES))))\n+  ifneq ($$($1_INCLUDES), )\n+    ifneq ($$($1_SUFFIXES), )\n+      $1_ZIP_INCLUDES := $$(foreach s, $$($1_SUFFIXES), \\\n+          $$(addprefix -i$(SPACE)$(DQUOTE), $$(addsuffix \/*$$s$(DQUOTE), $$($1_INCLUDES))))\n@@ -94,1 +94,1 @@\n-      $1_ZIP_INCLUDES := $$(addprefix -i$(SPACE)$(DQUOTE),$$(addsuffix \/*$(DQUOTE),$$($1_INCLUDES)))\n+      $1_ZIP_INCLUDES := $$(addprefix -i$(SPACE)$(DQUOTE), $$(addsuffix \/*$(DQUOTE), $$($1_INCLUDES)))\n@@ -97,3 +97,3 @@\n-    ifneq ($$($1_SUFFIXES),)\n-      $1_ZIP_INCLUDES := $$(foreach s,$$($1_SUFFIXES), \\\n-          $$(addprefix -i$(SPACE)$(DQUOTE),*$$s$(DQUOTE)))\n+    ifneq ($$($1_SUFFIXES), )\n+      $1_ZIP_INCLUDES := $$(foreach s, $$($1_SUFFIXES), \\\n+          $$(addprefix -i$(SPACE)$(DQUOTE), *$$s$(DQUOTE)))\n@@ -102,2 +102,2 @@\n-  ifneq ($$($1_INCLUDE_FILES),)\n-    $1_ZIP_INCLUDES += $$(addprefix -i$(SPACE),$$($1_INCLUDE_FILES))\n+  ifneq ($$($1_INCLUDE_FILES), )\n+    $1_ZIP_INCLUDES += $$(addprefix -i$(SPACE), $$($1_INCLUDE_FILES))\n@@ -105,4 +105,4 @@\n-  ifneq ($$($1_EXCLUDES),)\n-    $1_ZIP_EXCLUDES := $$(addprefix -x$(SPACE)$(DQUOTE),$$(addsuffix \/*$(DQUOTE),$$($1_EXCLUDES)))\n-    $1_SRC_EXCLUDES := $$(foreach s,$$($1_SRC_SLASH),$$(addprefix $$s,$$(addsuffix \/%,$$($1_EXCLUDES))))\n-    $1_ALL_SRCS := $$(filter-out $$($1_SRC_EXCLUDES),$$($1_ALL_SRCS))\n+  ifneq ($$($1_EXCLUDES), )\n+    $1_ZIP_EXCLUDES := $$(addprefix -x$(SPACE)$(DQUOTE), $$(addsuffix \/*$(DQUOTE), $$($1_EXCLUDES)))\n+    $1_SRC_EXCLUDES := $$(foreach s, $$($1_SRC_SLASH), $$(addprefix $$s, $$(addsuffix \/%, $$($1_EXCLUDES))))\n+    $1_ALL_SRCS := $$(filter-out $$($1_SRC_EXCLUDES), $$($1_ALL_SRCS))\n@@ -110,1 +110,1 @@\n-  ifneq ($$($1_EXCLUDE_FILES),)\n+  ifneq ($$($1_EXCLUDE_FILES), )\n@@ -137,1 +137,1 @@\n-  $1_NAME:=$$(subst $$(OUTPUTDIR)\/,,$$($1_ZIP))\n+  $1_NAME := $$(subst $$(OUTPUTDIR)\/,,$$($1_ZIP))\n@@ -170,1 +170,1 @@\n-\t$$(foreach s,$$($1_SRC_SLASH), $$(call ExecuteWithLog, \\\n+\t$$(foreach s, $$($1_SRC_SLASH), $$(call ExecuteWithLog, \\\n","filename":"make\/common\/ZipArchive.gmk","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -138,1 +138,2 @@\n-      DISABLED_WARNINGS_gcc := unused-function, \\\n+      DISABLED_WARNINGS_gcc := unused-function unused-variable, \\\n+      DISABLED_WARNINGS_clang := unused-function, \\\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  $(call WriteFile,{ \\\n+  $(call WriteFile, { \\\n@@ -47,1 +47,1 @@\n-      \"command\": \"$(strip $(subst $(DQUOTE),\\$(DQUOTE),$(subst \\,\\\\,\\\n+      \"command\": \"$(strip $(subst $(DQUOTE),\\$(DQUOTE),$(subst \\,\\\\, \\\n@@ -347,1 +347,1 @@\n-\t\t$(ECHO) >> $$($1_RES_DEPS_FILE) ;\\\n+\t\t$(ECHO) >> $$($1_RES_DEPS_FILE) ; \\\n","filename":"make\/common\/native\/CompileFile.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-       endif # !STATIC_LIBRARY\n+      endif # !STATIC_LIBRARY\n","filename":"make\/common\/native\/DebugSymbols.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-  $1_LDFLAGS_FILE := $$(MAKESUPPORT_OUTPUTDIR)\/compile-commands\/$$($1_NAME)-ldflags.txt\n+  $1_LDFLAGS_FILE := $$(MAKESUPPORT_OUTPUTDIR)\/compile-commands\/$$($1_UNIQUE_NAME)-ldflags.txt\n","filename":"make\/common\/native\/Link.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-ifeq (,$(SKIP_ME))\n+ifeq ($(SKIP_ME), )\n","filename":"make\/devkit\/Makefile","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-##########################################################################################\n+################################################################################\n@@ -95,1 +95,1 @@\n-##########################################################################################\n+################################################################################\n@@ -226,1 +226,1 @@\n-##########################################################################################\n+################################################################################\n@@ -261,1 +261,1 @@\n-##########################################################################################\n+################################################################################\n@@ -288,1 +288,1 @@\n-##########################################################################################\n+################################################################################\n@@ -327,1 +327,1 @@\n-##########################################################################################\n+################################################################################\n@@ -347,1 +347,1 @@\n-##########################################################################################\n+################################################################################\n@@ -360,1 +360,1 @@\n-##########################################################################################\n+################################################################################\n@@ -365,1 +365,1 @@\n-##########################################################################################\n+################################################################################\n@@ -393,1 +393,1 @@\n-##########################################################################################\n+################################################################################\n@@ -427,1 +427,1 @@\n-##########################################################################################\n+################################################################################\n@@ -594,1 +594,1 @@\n-##########################################################################################\n+################################################################################\n@@ -609,1 +609,1 @@\n-##########################################################################################\n+################################################################################\n@@ -624,1 +624,1 @@\n-  ##########################################################################################\n+  ##############################################################################\n@@ -644,1 +644,1 @@\n-##########################################################################################\n+################################################################################\n@@ -659,1 +659,1 @@\n-##########################################################################################\n+################################################################################\n@@ -673,1 +673,1 @@\n-##########################################################################################\n+################################################################################\n@@ -689,1 +689,1 @@\n-##########################################################################################\n+################################################################################\n@@ -709,1 +709,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/devkit\/Tools.gmk","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-      FILES := $(filter %.lib, $(LIB_TARGETS))))\n+      FILES := $(filter %.lib, $(LIB_TARGETS)), \\\n+  ))\n","filename":"make\/hotspot\/CopyToExplodedJdk.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -207,5 +207,5 @@\n-         if (CUR_FN != FILENAME) { CUR_FN=FILENAME; NR_BASE=NR-1; need_lineno=1 } \\\n-         if (need_lineno && $$0 !~ \/\\\/\\\/\/) \\\n-           { print \"\\n\\n\\#line \" (NR-NR_BASE) \" \\\"\" FILENAME \"\\\"\"; need_lineno=0 }; \\\n-         print \\\n-       }'\n+        if (CUR_FN != FILENAME) { CUR_FN=FILENAME; NR_BASE=NR-1; need_lineno=1 } \\\n+        if (need_lineno && $$0 !~ \/\\\/\\\/\/) \\\n+          { print \"\\n\\n\\#line \" (NR-NR_BASE) \" \\\"\" FILENAME \"\\\"\"; need_lineno=0 }; \\\n+        print \\\n+      }'\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -60,3 +60,3 @@\n-    DISABLED_WARNINGS_gcc := undef unused-result format-nonliteral \\\n-        maybe-uninitialized zero-as-null-pointer-constant, \\\n-    DISABLED_WARNINGS_clang := undef unused-result format-nonliteral, \\\n+    DISABLED_WARNINGS_gcc := format-nonliteral maybe-uninitialized undef \\\n+        unused-result zero-as-null-pointer-constant, \\\n+    DISABLED_WARNINGS_clang := format-nonliteral undef unused-result, \\\n@@ -98,1 +98,1 @@\n-        $(addprefix -I,$(GTEST_TEST_SRC)), \\\n+        $(addprefix -I, $(GTEST_TEST_SRC)), \\\n@@ -103,0 +103,1 @@\n+    DISABLED_WARNINGS_gcc_test_metaspace_misc.cpp := unused-const-variable, \\\n","filename":"make\/hotspot\/lib\/CompileGtest.gmk","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -95,1 +95,2 @@\n-    shift-negative-value unknown-pragmas\n+    shift-negative-value unknown-pragmas unused-but-set-variable \\\n+    unused-local-typedefs unused-variable\n@@ -97,2 +98,3 @@\n-DISABLED_WARNINGS_clang := sometimes-uninitialized \\\n-    missing-braces delete-non-abstract-non-virtual-dtor unknown-pragmas\n+DISABLED_WARNINGS_clang := delete-non-abstract-non-virtual-dtor missing-braces \\\n+    sometimes-uninitialized unknown-pragmas unused-but-set-variable \\\n+    unused-function unused-local-typedef unused-private-field unused-variable\n@@ -180,0 +182,2 @@\n+    DISABLED_WARNINGS_gcc_bytecodeInterpreter.cpp := unused-label, \\\n+    DISABLED_WARNINGS_gcc_c1_Runtime1_aarch64.cpp := unused-const-variable, \\\n@@ -182,0 +186,1 @@\n+    DISABLED_WARNINGS_gcc_g1FreeIdSet.cpp := unused-const-variable, \\\n@@ -184,0 +189,4 @@\n+    DISABLED_WARNINGS_gcc_javaClasses.cpp := unused-const-variable, \\\n+    DISABLED_WARNINGS_gcc_jfrChunkWriter.cpp := unused-const-variable, \\\n+    DISABLED_WARNINGS_gcc_jfrMemorySizer.cpp := unused-const-variable, \\\n+    DISABLED_WARNINGS_gcc_jfrTraceIdKlassQueue.cpp := unused-const-variable, \\\n@@ -185,0 +194,1 @@\n+    DISABLED_WARNINGS_gcc_jvmFlag.cpp := unused-const-variable, \\\n@@ -186,0 +196,1 @@\n+    DISABLED_WARNINGS_gcc_macroAssembler_ppc_sha.cpp := unused-const-variable, \\\n@@ -188,0 +199,1 @@\n+    DISABLED_WARNINGS_gcc_stubGenerator_s390.cpp := unused-const-variable, \\\n@@ -189,0 +201,2 @@\n+    DISABLED_WARNINGS_gcc_templateInterpreterGenerator_x86.cpp := unused-const-variable, \\\n+    DISABLED_WARNINGS_gcc_xGlobals_ppc.cpp := unused-const-variable, \\\n@@ -271,1 +285,1 @@\n-          FILES :=$(BUILD_LIBJVM_IMPORT_LIBRARY), \\\n+          FILES := $(BUILD_LIBJVM_IMPORT_LIBRARY), \\\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -50,3 +50,4 @@\n-  JVM_EXCLUDE_FILES += templateInterpreter.cpp templateInterpreterGenerator.cpp \\\n-                       bcEscapeAnalyzer.cpp ciTypeFlow.cpp\n-  JVM_CFLAGS_FEATURES += -DZERO -DZERO_LIBARCH='\"$(OPENJDK_TARGET_CPU_LEGACY_LIB)\"' $(LIBFFI_CFLAGS)\n+  JVM_EXCLUDE_FILES += templateInterpreter.cpp \\\n+      templateInterpreterGenerator.cpp bcEscapeAnalyzer.cpp ciTypeFlow.cpp\n+  JVM_CFLAGS_FEATURES += -DZERO \\\n+      -DZERO_LIBARCH='\"$(OPENJDK_TARGET_CPU_LEGACY_LIB)\"' $(LIBFFI_CFLAGS)\n@@ -72,1 +73,2 @@\n-    # Override the default -g with a more liberal strip policy for the minimal JVM\n+    # Override the default -g with a more liberal strip policy for the\n+    # minimal JVM\n@@ -83,5 +85,8 @@\n-  JVM_EXCLUDE_FILES += jvmtiGetLoadedClasses.cpp jvmtiThreadState.cpp jvmtiExtensions.cpp \\\n-      jvmtiImpl.cpp jvmtiManageCapabilities.cpp jvmtiRawMonitor.cpp jvmtiUtil.cpp jvmtiTrace.cpp \\\n-      jvmtiCodeBlobEvents.cpp jvmtiEnv.cpp jvmtiRedefineClasses.cpp jvmtiEnvBase.cpp jvmtiEnvThreadState.cpp \\\n-      jvmtiTagMap.cpp jvmtiEventController.cpp evmCompat.cpp jvmtiEnter.xsl jvmtiExport.cpp \\\n-      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp jvmtiAgent.cpp jvmtiAgentList.cpp jfrJvmtiAgent.cpp\n+  JVM_EXCLUDE_FILES += jvmtiGetLoadedClasses.cpp jvmtiThreadState.cpp \\\n+      jvmtiExtensions.cpp jvmtiImpl.cpp jvmtiManageCapabilities.cpp \\\n+      jvmtiRawMonitor.cpp jvmtiUtil.cpp jvmtiTrace.cpp jvmtiCodeBlobEvents.cpp \\\n+      jvmtiEnv.cpp jvmtiRedefineClasses.cpp jvmtiEnvBase.cpp \\\n+      jvmtiEnvThreadState.cpp jvmtiTagMap.cpp jvmtiEventController.cpp \\\n+      evmCompat.cpp jvmtiEnter.xsl jvmtiExport.cpp \\\n+      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp jvmtiAgent.cpp \\\n+      jvmtiAgentList.cpp jfrJvmtiAgent.cpp\n@@ -169,2 +174,4 @@\n-    JVM_CFLAGS_FEATURES += -flto=auto -fuse-linker-plugin -fno-strict-aliasing -fno-fat-lto-objects\n-    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto=auto -fuse-linker-plugin -fno-strict-aliasing\n+    JVM_CFLAGS_FEATURES += -flto=auto -fuse-linker-plugin -fno-strict-aliasing \\\n+        -fno-fat-lto-objects\n+    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto=auto \\\n+        -fuse-linker-plugin -fno-strict-aliasing\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-  ifneq ($(DEBUG_LEVEL),slowdebug)\n+  ifneq ($(DEBUG_LEVEL), slowdebug)\n","filename":"make\/hotspot\/lib\/JvmOverrideFiles.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    $(if $(strip $1),$(wildcard $(SUPPORT_OUTPUTDIR)\/headers\/$(strip $1)))\n+    $(if $(strip $1), $(wildcard $(SUPPORT_OUTPUTDIR)\/headers\/$(strip $1)))\n@@ -115,1 +115,1 @@\n-    $1_CLASSPATH += $$(foreach src,$(JAVA_DIRS), \\\n+    $1_CLASSPATH += $$(foreach src, $(JAVA_DIRS), \\\n@@ -160,1 +160,1 @@\n-      $1_NATIVE_SRCS += $$(foreach src,$(NATIVE_DIRS), \\\n+      $1_NATIVE_SRCS += $$(foreach src, $(NATIVE_DIRS), \\\n@@ -191,1 +191,1 @@\n-    $1_MATCHING_MAKE_TARGETS += $$(foreach name,$$($1_PLAIN_MAKE_TARGETS), \\\n+    $1_MATCHING_MAKE_TARGETS += $$(foreach name, $$($1_PLAIN_MAKE_TARGETS), \\\n@@ -295,1 +295,1 @@\n-    $1_LINKED_RESOURCES += $$(foreach src,$(JAVA_DIRS), \\\n+    $1_LINKED_RESOURCES += $$(foreach src, $(JAVA_DIRS), \\\n@@ -320,1 +320,1 @@\n-    $1_LINKED_RESOURCES += $$(foreach src,$(NATIVE_DIRS), \\\n+    $1_LINKED_RESOURCES += $$(foreach src, $(NATIVE_DIRS), \\\n","filename":"make\/ide\/eclipse\/CreateWorkspace.gmk","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-ifeq ($(SPEC),)\n-  ifneq ($(words $(SPECS)),1)\n+ifeq ($(SPEC), )\n+  ifneq ($(words $(SPECS)), 1)\n@@ -42,1 +42,1 @@\n-  ifeq ($(MODULES),)\n+  ifeq ($(MODULES), )\n@@ -50,1 +50,1 @@\n-\t$(ECHO) \"MODULE_ROOTS=\\\"$(foreach mod, $(SEL_MODULES), $(call FindModuleSrcDirs,$(mod)))\\\"\" >> $(OUT)\n+\t$(ECHO) \"MODULE_ROOTS=\\\"$(foreach mod, $(SEL_MODULES), $(call FindModuleSrcDirs, $(mod)))\\\"\" >> $(OUT)\n","filename":"make\/ide\/idea\/jdk\/idea.gmk","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-  ################################################################################\n+  ##############################################################################\n","filename":"make\/ide\/visualstudio\/hotspot\/CreateVSProject.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-ifneq (,$(wildcard $(call GetIndexerFragment,notes)))\n+ifneq ($(wildcard $(call GetIndexerFragment,notes)), )\n@@ -69,1 +69,1 @@\n-ifneq ($(WORKSPACE_ROOT),$(TOPDIR))\n+ifneq ($(WORKSPACE_ROOT), $(TOPDIR))\n","filename":"make\/ide\/vscode\/hotspot\/CreateVSCodeProject.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -109,1 +109,2 @@\n-    private static final Pattern TAG_PATTERN = Pattern.compile(\"(?s)(.+ )?(?<chapter>[1-9][0-9]*)(?<section>[0-9.]*)( .*)?$\");\n+    \/\/ Note: Matches special cases like @jvms 6.5.checkcast\n+    private static final Pattern TAG_PATTERN = Pattern.compile(\"(?s)(.+ )?(?<chapter>[1-9][0-9]*)(?<section>[0-9a-z_.]*)( .*)?$\");\n","filename":"make\/jdk\/src\/classes\/build\/tools\/taglet\/JSpec.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-\t$(foreach f,$(POLICY_SRC_LIST),$(CAT) $(f) >> $@.tmp;)\n+\t$(foreach f, $(POLICY_SRC_LIST), $(CAT) $(f) >> $@.tmp;)\n@@ -159,1 +159,1 @@\n-\t$(foreach f,$(DEF_POLICY_SRC_LIST),$(CAT) $(f) >> $@.tmp;)\n+\t$(foreach f, $(DEF_POLICY_SRC_LIST), $(CAT) $(f) >> $@.tmp;)\n","filename":"make\/modules\/java.base\/Copy.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    DISABLED_WARNINGS_gcc_net_util_md.c := format-nonliteral, \\\n+    DISABLED_WARNINGS_gcc_net_util_md.c := format-nonliteral unused-variable, \\\n@@ -49,1 +49,3 @@\n-    DISABLED_WARNINGS_clang_net_util_md.c := format-nonliteral, \\\n+    DISABLED_WARNINGS_clang_net_util_md.c := format-nonliteral \\\n+        unused-variable, \\\n+    DISABLED_WARNINGS_clang_NetworkInterface.c := unused-function, \\\n@@ -59,1 +61,1 @@\n-    LIBS_aix := $(LIBDL),\\\n+    LIBS_aix := $(LIBDL), \\\n@@ -80,0 +82,2 @@\n+    DISABLED_WARNINGS_clang_Net.c := unused-function unused-variable, \\\n+    DISABLED_WARNINGS_clang_UnixNativeDispatcher.c := unused-variable, \\\n@@ -99,1 +103,2 @@\n-      DISABLED_WARNINGS_clang_KeystoreImpl.m := deprecated-declarations, \\\n+      DISABLED_WARNINGS_clang_KeystoreImpl.m := deprecated-declarations \\\n+          unused-but-set-variable unused-variable, \\\n@@ -119,0 +124,2 @@\n+      DISABLED_WARNINGS_gcc_jsig.c := unused-but-set-variable, \\\n+      DISABLED_WARNINGS_clang_jsig.c := unused-but-set-variable, \\\n@@ -172,0 +179,1 @@\n+      DISABLED_WARNINGS_gcc := implicit-function-declaration unused-variable, \\\n@@ -189,0 +197,1 @@\n+      DISABLED_WARNINGS_gcc := unused-variable, \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -282,7 +282,7 @@\n-$(eval $(call SetupGenBuffer,ByteBuffer,  $(X_BUF), type:=byte, BIN:=1))\n-$(eval $(call SetupGenBuffer,CharBuffer,  $(X_BUF), type:=char))\n-$(eval $(call SetupGenBuffer,ShortBuffer, $(X_BUF), type:=short))\n-$(eval $(call SetupGenBuffer,IntBuffer,   $(X_BUF), type:=int))\n-$(eval $(call SetupGenBuffer,LongBuffer,  $(X_BUF), type:=long))\n-$(eval $(call SetupGenBuffer,FloatBuffer, $(X_BUF), type:=float))\n-$(eval $(call SetupGenBuffer,DoubleBuffer,$(X_BUF), type:=double))\n+$(eval $(call SetupGenBuffer,ByteBuffer,  $(X_BUF), type := byte, BIN := 1))\n+$(eval $(call SetupGenBuffer,CharBuffer,  $(X_BUF), type := char))\n+$(eval $(call SetupGenBuffer,ShortBuffer, $(X_BUF), type := short))\n+$(eval $(call SetupGenBuffer,IntBuffer,   $(X_BUF), type := int))\n+$(eval $(call SetupGenBuffer,LongBuffer,  $(X_BUF), type := long))\n+$(eval $(call SetupGenBuffer,FloatBuffer, $(X_BUF), type := float))\n+$(eval $(call SetupGenBuffer,DoubleBuffer,$(X_BUF), type := double))\n@@ -294,14 +294,14 @@\n-$(eval $(call SetupGenBuffer,HeapByteBuffer,   $(HEAP_X_BUF), type:=byte))\n-$(eval $(call SetupGenBuffer,HeapByteBufferR,  $(HEAP_X_BUF), type:=byte, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapCharBuffer,   $(HEAP_X_BUF), type:=char))\n-$(eval $(call SetupGenBuffer,HeapCharBufferR,  $(HEAP_X_BUF), type:=char, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapShortBuffer,  $(HEAP_X_BUF), type:=short))\n-$(eval $(call SetupGenBuffer,HeapShortBufferR, $(HEAP_X_BUF), type:=short, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapIntBuffer,    $(HEAP_X_BUF), type:=int))\n-$(eval $(call SetupGenBuffer,HeapIntBufferR,   $(HEAP_X_BUF), type:=int, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapLongBuffer,   $(HEAP_X_BUF), type:=long))\n-$(eval $(call SetupGenBuffer,HeapLongBufferR,  $(HEAP_X_BUF), type:=long, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapFloatBuffer,  $(HEAP_X_BUF), type:=float))\n-$(eval $(call SetupGenBuffer,HeapFloatBufferR, $(HEAP_X_BUF), type:=float, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapDoubleBuffer, $(HEAP_X_BUF), type:=double))\n-$(eval $(call SetupGenBuffer,HeapDoubleBufferR,$(HEAP_X_BUF), type:=double, RW:=R))\n+$(eval $(call SetupGenBuffer,HeapByteBuffer,   $(HEAP_X_BUF), type := byte))\n+$(eval $(call SetupGenBuffer,HeapByteBufferR,  $(HEAP_X_BUF), type := byte, RW := R))\n+$(eval $(call SetupGenBuffer,HeapCharBuffer,   $(HEAP_X_BUF), type := char))\n+$(eval $(call SetupGenBuffer,HeapCharBufferR,  $(HEAP_X_BUF), type := char, RW := R))\n+$(eval $(call SetupGenBuffer,HeapShortBuffer,  $(HEAP_X_BUF), type := short))\n+$(eval $(call SetupGenBuffer,HeapShortBufferR, $(HEAP_X_BUF), type := short, RW := R))\n+$(eval $(call SetupGenBuffer,HeapIntBuffer,    $(HEAP_X_BUF), type := int))\n+$(eval $(call SetupGenBuffer,HeapIntBufferR,   $(HEAP_X_BUF), type := int, RW := R))\n+$(eval $(call SetupGenBuffer,HeapLongBuffer,   $(HEAP_X_BUF), type := long))\n+$(eval $(call SetupGenBuffer,HeapLongBufferR,  $(HEAP_X_BUF), type := long, RW := R))\n+$(eval $(call SetupGenBuffer,HeapFloatBuffer,  $(HEAP_X_BUF), type := float))\n+$(eval $(call SetupGenBuffer,HeapFloatBufferR, $(HEAP_X_BUF), type := float, RW := R))\n+$(eval $(call SetupGenBuffer,HeapDoubleBuffer, $(HEAP_X_BUF), type := double))\n+$(eval $(call SetupGenBuffer,HeapDoubleBufferR,$(HEAP_X_BUF), type := double, RW := R))\n@@ -313,2 +313,2 @@\n-$(eval $(call SetupGenBuffer,DirectByteBuffer, $(DIRECT_X_BUF), type:=byte, BIN:=1))\n-$(eval $(call SetupGenBuffer,DirectByteBufferR,$(DIRECT_X_BUF), type:=byte, BIN:=1, RW:=R))\n+$(eval $(call SetupGenBuffer,DirectByteBuffer, $(DIRECT_X_BUF), type := byte, BIN := 1))\n+$(eval $(call SetupGenBuffer,DirectByteBufferR,$(DIRECT_X_BUF), type := byte, BIN := 1, RW := R))\n@@ -318,12 +318,12 @@\n-$(eval $(call SetupGenBuffer,DirectCharBufferU,   $(DIRECT_X_BUF), type:=char, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectCharBufferRU,  $(DIRECT_X_BUF), type:=char, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectShortBufferU,  $(DIRECT_X_BUF), type:=short, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectShortBufferRU, $(DIRECT_X_BUF), type:=short, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectIntBufferU,    $(DIRECT_X_BUF), type:=int, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectIntBufferRU,   $(DIRECT_X_BUF), type:=int, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectLongBufferU,   $(DIRECT_X_BUF), type:=long, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectLongBufferRU,  $(DIRECT_X_BUF), type:=long, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferU,  $(DIRECT_X_BUF), type:=float, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferRU, $(DIRECT_X_BUF), type:=float, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferU, $(DIRECT_X_BUF), type:=double, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferRU,$(DIRECT_X_BUF), type:=double, RW:=R, BO:=U))\n+$(eval $(call SetupGenBuffer,DirectCharBufferU,   $(DIRECT_X_BUF), type := char, BO := U))\n+$(eval $(call SetupGenBuffer,DirectCharBufferRU,  $(DIRECT_X_BUF), type := char, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectShortBufferU,  $(DIRECT_X_BUF), type := short, BO := U))\n+$(eval $(call SetupGenBuffer,DirectShortBufferRU, $(DIRECT_X_BUF), type := short, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectIntBufferU,    $(DIRECT_X_BUF), type := int, BO := U))\n+$(eval $(call SetupGenBuffer,DirectIntBufferRU,   $(DIRECT_X_BUF), type := int, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectLongBufferU,   $(DIRECT_X_BUF), type := long, BO := U))\n+$(eval $(call SetupGenBuffer,DirectLongBufferRU,  $(DIRECT_X_BUF), type := long, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectFloatBufferU,  $(DIRECT_X_BUF), type := float, BO := U))\n+$(eval $(call SetupGenBuffer,DirectFloatBufferRU, $(DIRECT_X_BUF), type := float, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectDoubleBufferU, $(DIRECT_X_BUF), type := double, BO := U))\n+$(eval $(call SetupGenBuffer,DirectDoubleBufferRU,$(DIRECT_X_BUF), type := double, RW := R, BO := U))\n@@ -333,12 +333,12 @@\n-$(eval $(call SetupGenBuffer,DirectCharBufferS,   $(DIRECT_X_BUF), type:=char, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectCharBufferRS,  $(DIRECT_X_BUF), type:=char, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectShortBufferS,  $(DIRECT_X_BUF), type:=short, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectShortBufferRS, $(DIRECT_X_BUF), type:=short, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectIntBufferS,    $(DIRECT_X_BUF), type:=int, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectIntBufferRS,   $(DIRECT_X_BUF), type:=int, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectLongBufferS,   $(DIRECT_X_BUF), type:=long, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectLongBufferRS,  $(DIRECT_X_BUF), type:=long, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferS,  $(DIRECT_X_BUF), type:=float, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferRS, $(DIRECT_X_BUF), type:=float, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferS, $(DIRECT_X_BUF), type:=double, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferRS,$(DIRECT_X_BUF), type:=double, RW:=R, BO:=S))\n+$(eval $(call SetupGenBuffer,DirectCharBufferS,   $(DIRECT_X_BUF), type := char, BO := S))\n+$(eval $(call SetupGenBuffer,DirectCharBufferRS,  $(DIRECT_X_BUF), type := char, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectShortBufferS,  $(DIRECT_X_BUF), type := short, BO := S))\n+$(eval $(call SetupGenBuffer,DirectShortBufferRS, $(DIRECT_X_BUF), type := short, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectIntBufferS,    $(DIRECT_X_BUF), type := int, BO := S))\n+$(eval $(call SetupGenBuffer,DirectIntBufferRS,   $(DIRECT_X_BUF), type := int, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectLongBufferS,   $(DIRECT_X_BUF), type := long, BO := S))\n+$(eval $(call SetupGenBuffer,DirectLongBufferRS,  $(DIRECT_X_BUF), type := long, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectFloatBufferS,  $(DIRECT_X_BUF), type := float, BO := S))\n+$(eval $(call SetupGenBuffer,DirectFloatBufferRS, $(DIRECT_X_BUF), type := float, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectDoubleBufferS, $(DIRECT_X_BUF), type := double, BO := S))\n+$(eval $(call SetupGenBuffer,DirectDoubleBufferRS,$(DIRECT_X_BUF), type := double, RW := R, BO := S))\n@@ -350,12 +350,12 @@\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferB,   $(BYTE_X_BUF), type:=char, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferRB,  $(BYTE_X_BUF), type:=char, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferB,  $(BYTE_X_BUF), type:=short, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferRB, $(BYTE_X_BUF), type:=short, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferB,    $(BYTE_X_BUF), type:=int, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferRB,   $(BYTE_X_BUF), type:=int, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferB,   $(BYTE_X_BUF), type:=long, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferRB,  $(BYTE_X_BUF), type:=long, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferB,  $(BYTE_X_BUF), type:=float, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferRB, $(BYTE_X_BUF), type:=float, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferB, $(BYTE_X_BUF), type:=double, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferRB,$(BYTE_X_BUF), type:=double, RW:=R, BO:=B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferB,   $(BYTE_X_BUF), type := char, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferRB,  $(BYTE_X_BUF), type := char, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferB,  $(BYTE_X_BUF), type := short, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferRB, $(BYTE_X_BUF), type := short, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferB,    $(BYTE_X_BUF), type := int, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferRB,   $(BYTE_X_BUF), type := int, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferB,   $(BYTE_X_BUF), type := long, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferRB,  $(BYTE_X_BUF), type := long, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferB,  $(BYTE_X_BUF), type := float, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferRB, $(BYTE_X_BUF), type := float, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferB, $(BYTE_X_BUF), type := double, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferRB,$(BYTE_X_BUF), type := double, RW := R, BO := B))\n@@ -365,12 +365,12 @@\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferL,   $(BYTE_X_BUF), type:=char, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferRL,  $(BYTE_X_BUF), type:=char, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferL,  $(BYTE_X_BUF), type:=short, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferRL, $(BYTE_X_BUF), type:=short, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferL,    $(BYTE_X_BUF), type:=int, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferRL,   $(BYTE_X_BUF), type:=int, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferL,   $(BYTE_X_BUF), type:=long, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferRL,  $(BYTE_X_BUF), type:=long, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferL,  $(BYTE_X_BUF), type:=float, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferRL, $(BYTE_X_BUF), type:=float, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferL, $(BYTE_X_BUF), type:=double, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferRL,$(BYTE_X_BUF), type:=double, RW:=R, BO:=L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferL,   $(BYTE_X_BUF), type := char, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferRL,  $(BYTE_X_BUF), type := char, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferL,  $(BYTE_X_BUF), type := short, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferRL, $(BYTE_X_BUF), type := short, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferL,    $(BYTE_X_BUF), type := int, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferRL,   $(BYTE_X_BUF), type := int, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferL,   $(BYTE_X_BUF), type := long, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferRL,  $(BYTE_X_BUF), type := long, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferL,  $(BYTE_X_BUF), type := float, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferRL, $(BYTE_X_BUF), type := float, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferL, $(BYTE_X_BUF), type := double, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferRL,$(BYTE_X_BUF), type := double, RW := R, BO := L))\n","filename":"make\/modules\/java.base\/gensrc\/GensrcBuffer.gmk","additions":71,"deletions":71,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-GENSRC_EXCEPTIONS += $(foreach D,$(GENSRC_EXCEPTIONS_SRC_DIRS),$(GENSRC_EXCEPTIONS_DST)\/_the.$(D).marker)\n+GENSRC_EXCEPTIONS += $(foreach D, $(GENSRC_EXCEPTIONS_SRC_DIRS), $(GENSRC_EXCEPTIONS_DST)\/_the.$(D).marker)\n","filename":"make\/modules\/java.base\/gensrc\/GensrcExceptions.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  ifeq ($(OPENJDK_TARGET_CPU),aarch64)\n+  ifeq ($(OPENJDK_TARGET_CPU), aarch64)\n","filename":"make\/modules\/java.base\/gensrc\/GensrcMisc.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-############################################################################\n+################################################################################\n","filename":"make\/modules\/java.base\/gensrc\/GensrcModuleLoaderMap.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+    DISABLED_WARNINGS_gcc_check_code.c := unused-variable, \\\n+    DISABLED_WARNINGS_clang_check_code.c := unused-variable, \\\n@@ -61,0 +63,1 @@\n+    DISABLED_WARNINGS_clang_TimeZone_md.c := unused-variable, \\\n@@ -63,1 +66,1 @@\n-    LIBS_aix := $(LIBDL) $(LIBM),\\\n+    LIBS_aix := $(LIBDL) $(LIBM), \\\n@@ -95,0 +98,1 @@\n+    DISABLED_WARNINGS_clang_zip_util.c := unused-function, \\\n@@ -111,0 +115,6 @@\n+    DISABLED_WARNINGS_gcc_imageDecompressor.cpp := unused-variable, \\\n+    DISABLED_WARNINGS_gcc_imageFile.cpp := unused-const-variable \\\n+        unused-variable, \\\n+    DISABLED_WARNINGS_clang_imageDecompressor.cpp := unused-variable, \\\n+    DISABLED_WARNINGS_clang_imageFile.cpp := unused-private-field \\\n+        unused-variable, \\\n@@ -170,2 +180,4 @@\n-    DISABLED_WARNINGS_gcc := unused-function, \\\n-    DISABLED_WARNINGS_clang := format-nonliteral deprecated-non-prototype, \\\n+    DISABLED_WARNINGS_gcc := unused-function unused-variable, \\\n+    DISABLED_WARNINGS_clang := deprecated-non-prototype format-nonliteral \\\n+        unused-function, \\\n+    DISABLED_WARNINGS_clang_java_md_macosx.m := unused-variable, \\\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -67,2 +67,5 @@\n-      DISABLED_WARNINGS_gcc := undef, \\\n-      DISABLED_WARNINGS_clang := undef, \\\n+      DISABLED_WARNINGS_gcc := undef unused-variable, \\\n+      DISABLED_WARNINGS_clang := undef unused-variable, \\\n+      DISABLED_WARNINGS_clang_PLATFORM_API_MacOSX_MidiUtils.c := \\\n+          unused-but-set-variable, \\\n+      DISABLED_WARNINGS_clang_DirectAudioDevice.c := unused-function, \\\n","filename":"make\/modules\/java.desktop\/Lib.gmk","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+    DISABLED_WARNINGS_gcc := unused-but-set-variable unused-variable, \\\n@@ -115,0 +116,1 @@\n+    DISABLED_WARNINGS_clang := unused-but-set-variable unused-variable, \\\n@@ -128,1 +130,1 @@\n-    LIBS_aix := $(LIBDL),\\\n+    LIBS_aix := $(LIBDL), \\\n@@ -181,0 +183,2 @@\n+      DISABLED_WARNINGS_gcc := unused-variable, \\\n+      DISABLED_WARNINGS_clang := unused-variable, \\\n@@ -183,0 +187,2 @@\n+      DISABLED_WARNINGS_clang_X11Renderer.c := unused-function, \\\n+      DISABLED_WARNINGS_clang_X11SurfaceData.c := unused-function, \\\n@@ -237,1 +243,2 @@\n-      DISABLED_WARNINGS_gcc := int-to-pointer-cast, \\\n+      DISABLED_WARNINGS_gcc := int-to-pointer-cast unused-variable, \\\n+      DISABLED_WARNINGS_clang := unused-variable, \\\n@@ -247,0 +254,1 @@\n+      DISABLED_WARNINGS_gcc_X11Color.c := unused-but-set-variable, \\\n@@ -248,1 +256,2 @@\n-          pointer-to-int-cast, \\\n+          pointer-to-int-cast unused-but-set-variable, \\\n+      DISABLED_WARNINGS_gcc_X11TextRenderer_md.c := unused-but-set-variable, \\\n@@ -254,1 +263,2 @@\n-      DISABLED_WARNINGS_clang_gtk3_interface.c := parentheses, \\\n+      DISABLED_WARNINGS_clang_gtk3_interface.c := unused-function parentheses, \\\n+      DISABLED_WARNINGS_clang_GLXSurfaceData.c := unused-function, \\\n@@ -259,0 +269,1 @@\n+      DISABLED_WARNINGS_clang_XWindow.c := unused-function, \\\n@@ -263,1 +274,1 @@\n-      DISABLED_WARNINGS_clang_aix_gtk3_interface.c := parentheses \\\n+      DISABLED_WARNINGS_clang_aix_gtk3_interface.c := unused-function parentheses \\\n@@ -267,1 +278,1 @@\n-      DISABLED_WARNINGS_clang_aix_awt_InputMethod.c := sign-compare, \\\n+      DISABLED_WARNINGS_clang_aix_awt_InputMethod.c := unused-function sign-compare, \\\n@@ -311,3 +322,4 @@\n-      DISABLED_WARNINGS_clang := incomplete-implementation \\\n-          deprecated-declarations objc-method-access \\\n-          incompatible-pointer-types extra-tokens sign-compare undef, \\\n+      DISABLED_WARNINGS_clang := deprecated-declarations extra-tokens \\\n+          incompatible-pointer-types incomplete-implementation \\\n+          objc-method-access sign-compare undef unused-function \\\n+          unused-variable, \\\n","filename":"make\/modules\/java.desktop\/lib\/AwtLibraries.gmk","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+    DISABLED_WARNINGS_clang_mlib_ImageCreate.c := unused-function, \\\n@@ -87,2 +88,2 @@\n-    DISABLED_WARNINGS_gcc := format-nonliteral type-limits \\\n-        stringop-truncation, \\\n+    DISABLED_WARNINGS_gcc := format-nonliteral stringop-truncation type-limits \\\n+        unused-variable, \\\n@@ -103,1 +104,2 @@\n-      jpegdecoder.c\n+      jpegdecoder.c \\\n+      #\n@@ -121,1 +123,2 @@\n-    DISABLED_WARNINGS_gcc_imageioJPEG.c := clobbered array-bounds, \\\n+    DISABLED_WARNINGS_gcc_imageioJPEG.c := array-bounds clobbered \\\n+        unused-but-set-variable, \\\n@@ -124,0 +127,1 @@\n+    DISABLED_WARNINGS_clang_imageioJPEG.c := unused-but-set-variable, \\\n@@ -227,1 +231,2 @@\n-      DISABLED_WARNINGS_gcc_splashscreen_sys.c := type-limits unused-result, \\\n+      DISABLED_WARNINGS_gcc_splashscreen_sys.c := type-limits \\\n+          unused-but-set-variable unused-result unused-variable, \\\n@@ -231,1 +236,2 @@\n-      DISABLED_WARNINGS_clang_splashscreen_impl.c := sign-compare, \\\n+      DISABLED_WARNINGS_clang_splashscreen_impl.c := sign-compare \\\n+          unused-but-set-variable unused-function, \\\n@@ -234,1 +240,2 @@\n-      DISABLED_WARNINGS_clang_splashscreen_sys.m := deprecated-declarations, \\\n+      DISABLED_WARNINGS_clang_splashscreen_sys.m := deprecated-declarations \\\n+          unused-variable unused-but-set-variable, \\\n@@ -282,3 +289,3 @@\n-   LIBFONTMANAGER_EXTRA_SRC =\n-   LIBFONTMANAGER_LIBS += $(HARFBUZZ_LIBS)\n-   LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)\n+  LIBFONTMANAGER_EXTRA_SRC =\n+  LIBFONTMANAGER_LIBS += $(HARFBUZZ_LIBS)\n+  LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)\n@@ -286,1 +293,1 @@\n-   LIBFONTMANAGER_EXTRA_SRC = libharfbuzz\n+  LIBFONTMANAGER_EXTRA_SRC = libharfbuzz\n@@ -288,2 +295,2 @@\n-   ifeq ($(call isTargetOs, windows), false)\n-     HARFBUZZ_CFLAGS += -DGETPAGESIZE -DHAVE_MPROTECT -DHAVE_PTHREAD \\\n+  ifeq ($(call isTargetOs, windows), false)\n+    HARFBUZZ_CFLAGS += -DGETPAGESIZE -DHAVE_MPROTECT -DHAVE_PTHREAD \\\n@@ -292,9 +299,9 @@\n-   endif\n-   ifeq ($(call isTargetOs, linux macosx), true)\n-     HARFBUZZ_CFLAGS += -DHAVE_INTEL_ATOMIC_PRIMITIVES -DHB_NO_VISIBILITY\n-   endif\n-\n-   # hb-ft.cc is not presently needed, and requires freetype 2.4.2 or later.\n-   # hb-subset and hb-style APIs are not needed, excluded to cut on compilation\n-   # time.\n-   LIBFONTMANAGER_EXCLUDE_FILES += gsubgpos-context.cc hb-ft.cc hb-style.cc \\\n+  endif\n+  ifeq ($(call isTargetOs, linux macosx), true)\n+    HARFBUZZ_CFLAGS += -DHAVE_INTEL_ATOMIC_PRIMITIVES -DHB_NO_VISIBILITY\n+  endif\n+\n+  # hb-ft.cc is not presently needed, and requires freetype 2.4.2 or later.\n+  # hb-subset and hb-style APIs are not needed, excluded to cut on compilation\n+  # time.\n+  LIBFONTMANAGER_EXCLUDE_FILES += gsubgpos-context.cc hb-ft.cc hb-style.cc \\\n@@ -305,21 +312,22 @@\n-   # list of disabled warnings and the compilers for which it was specifically\n-   # added.\n-   # array-bounds         -> GCC 12 on Alpine Linux\n-   # parentheses          -> GCC 6\n-   # range-loop-analysis  -> clang on Xcode12\n-\n-   HARFBUZZ_DISABLED_WARNINGS_gcc := missing-field-initializers \\\n-       strict-aliasing unused-result array-bounds parentheses\n-   # noexcept-type required for GCC 7 builds. Not required for GCC 8+.\n-   # expansion-to-defined required for GCC 9 builds. Not required for GCC 10+.\n-   # maybe-uninitialized required for GCC 8 builds. Not required for GCC 9+.\n-   # calloc-transposed-args required for GCC 14 builds. (fixed upstream in\n-   #  Harfbuzz 032c931e1c0cfb20f18e5acb8ba005775242bd92)\n-   HARFBUZZ_DISABLED_WARNINGS_CXX_gcc := class-memaccess noexcept-type \\\n-       expansion-to-defined dangling-reference maybe-uninitialized \\\n-       calloc-transposed-args\n-   HARFBUZZ_DISABLED_WARNINGS_clang := missing-field-initializers \\\n-      range-loop-analysis\n-   HARFBUZZ_DISABLED_WARNINGS_microsoft := 4267 4244\n-\n-   LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)\n+  # list of disabled warnings and the compilers for which it was specifically\n+  # added.\n+  # array-bounds         -> GCC 12 on Alpine Linux\n+  # parentheses          -> GCC 6\n+  # range-loop-analysis  -> clang on Xcode12\n+\n+  HARFBUZZ_DISABLED_WARNINGS_gcc := missing-field-initializers \\\n+      strict-aliasing unused-result array-bounds parentheses \\\n+       unused-variable\n+  # noexcept-type required for GCC 7 builds. Not required for GCC 8+.\n+  # expansion-to-defined required for GCC 9 builds. Not required for GCC 10+.\n+  # maybe-uninitialized required for GCC 8 builds. Not required for GCC 9+.\n+  # calloc-transposed-args required for GCC 14 builds. (fixed upstream in\n+  #  Harfbuzz 032c931e1c0cfb20f18e5acb8ba005775242bd92)\n+  HARFBUZZ_DISABLED_WARNINGS_CXX_gcc := class-memaccess noexcept-type \\\n+      expansion-to-defined dangling-reference maybe-uninitialized \\\n+      calloc-transposed-args\n+  HARFBUZZ_DISABLED_WARNINGS_clang := missing-field-initializers \\\n+      range-loop-analysis unused-variable\n+  HARFBUZZ_DISABLED_WARNINGS_microsoft := 4267 4244\n+\n+  LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)\n@@ -387,1 +395,1 @@\n-    LDFLAGS_FILTER_OUT :=-Wl$(COMMA)-z$(COMMA)defs, \\\n+    LDFLAGS_FILTER_OUT := -Wl$(COMMA)-z$(COMMA)defs, \\\n","filename":"make\/modules\/java.desktop\/lib\/ClientLibraries.gmk","additions":52,"deletions":44,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+    DISABLED_WARNINGS_gcc_VMManagementImpl.c := unused-variable, \\\n+    DISABLED_WARNINGS_clang_VMManagementImpl.c := unused-variable, \\\n@@ -41,1 +43,1 @@\n-    LIBS_aix := -lperfstat,\\\n+    LIBS_aix := -lperfstat, \\\n","filename":"make\/modules\/java.management\/Lib.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-    DISABLED_WARNINGS_gcc := undef, \\\n-    DISABLED_WARNINGS_clang := undef, \\\n+    DISABLED_WARNINGS_gcc := undef unused-but-set-variable, \\\n+    DISABLED_WARNINGS_clang := undef unused-but-set-variable, \\\n","filename":"make\/modules\/java.security.jgss\/Lib.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-   ))\n+    ))\n","filename":"make\/modules\/jdk.accessibility\/Launcher.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+    DISABLED_WARNINGS_gcc_p11_md.c := unused-variable, \\\n+    DISABLED_WARNINGS_clang_p11_md.c := unused-variable, \\\n","filename":"make\/modules\/jdk.crypto.cryptoki\/Lib.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+    DISABLED_WARNINGS_gcc_LinuxDebuggerLocal.cpp := unused-variable, \\\n@@ -63,1 +64,1 @@\n-    DISABLED_WARNINGS_clang_ps_core.c := pointer-arith, \\\n+    DISABLED_WARNINGS_gcc_symtab.c := unused-but-set-variable, \\\n@@ -66,0 +67,2 @@\n+    DISABLED_WARNINGS_clang_MacosxDebuggerLocal.m := unused-variable, \\\n+    DISABLED_WARNINGS_clang_ps_core.c := pointer-arith, \\\n","filename":"make\/modules\/jdk.hotspot.agent\/Lib.gmk","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-$(eval $(call SetupVersionProperties, JAVADOC_VERSION,\\\n+$(eval $(call SetupVersionProperties, JAVADOC_VERSION, \\\n","filename":"make\/modules\/jdk.javadoc\/Gensrc.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-$(eval $(call SetupVersionProperties, JDEPS_VERSION,\\\n+$(eval $(call SetupVersionProperties, JDEPS_VERSION, \\\n","filename":"make\/modules\/jdk.jdeps\/Gensrc.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    DISABLED_WARNINGS_gcc_eventFilter.c := unused-variable, \\\n@@ -56,0 +57,3 @@\n+    DISABLED_WARNINGS_gcc_threadControl.c := unused-but-set-variable \\\n+        unused-variable, \\\n+    DISABLED_WARNINGS_gcc_utf_util.c := unused-but-set-variable, \\\n@@ -57,0 +61,1 @@\n+    DISABLED_WARNINGS_clang_eventFilter.c := unused-variable, \\\n@@ -60,0 +65,4 @@\n+    DISABLED_WARNINGS_clang_SDE.c := unused-function, \\\n+    DISABLED_WARNINGS_clang_threadControl.c := unused-but-set-variable \\\n+        unused-variable, \\\n+    DISABLED_WARNINGS_clang_utf_util.c := unused-but-set-variable, \\\n@@ -63,2 +72,2 @@\n-        java.base:libjava \\\n-        java.base:libjvm, \\\n+        java.base:libjava, \\\n+    JDK_LIBS := java.base:libjvm, \\\n","filename":"make\/modules\/jdk.jdwp.agent\/Lib.gmk","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-$(eval $(call SetupBuildLauncher, jimage,\\\n+$(eval $(call SetupBuildLauncher, jimage, \\\n@@ -41,1 +41,1 @@\n-$(eval $(call SetupBuildLauncher, jlink,\\\n+$(eval $(call SetupBuildLauncher, jlink, \\\n@@ -51,1 +51,1 @@\n-$(eval $(call SetupBuildLauncher, jmod,\\\n+$(eval $(call SetupBuildLauncher, jmod, \\\n","filename":"make\/modules\/jdk.jlink\/Launcher.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-    DISABLED_WARNINGS_clang_LinuxPackage.c := format-nonliteral, \\\n@@ -58,0 +57,2 @@\n+    DISABLED_WARNINGS_clang_LinuxPackage.c := format-nonliteral, \\\n+    DISABLED_WARNINGS_clang_Log.cpp := unused-const-variable, \\\n@@ -92,0 +93,1 @@\n+      DISABLED_WARNINGS_gcc_Log.cpp := unused-const-variable, \\\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+    DISABLED_WARNINGS_gcc_DiagnosticCommandImpl.c := unused-variable, \\\n+    DISABLED_WARNINGS_clang_DiagnosticCommandImpl.c := unused-variable, \\\n@@ -50,1 +52,1 @@\n-    LIBS_aix := -lperfstat,\\\n+    LIBS_aix := -lperfstat, \\\n","filename":"make\/modules\/jdk.management\/Lib.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-    EXCLUDE_FILES:= _the.BUILD_JDK_MICROBENCHMARK_batch \\\n+    EXCLUDE_FILES := _the.BUILD_JDK_MICROBENCHMARK_batch \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -66,1 +67,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -69,1 +71,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/native\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/native \\\n+    #\n@@ -73,1 +76,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jdi\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jdi \\\n+    #\n@@ -77,1 +81,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -82,1 +87,2 @@\n-    -I$(TOPDIR)\/test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\n+    -I$(TOPDIR)\/test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti \\\n+    #\n@@ -86,1 +92,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/locks\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/locks \\\n+    #\n@@ -93,1 +100,2 @@\n-    -I$(VM_TESTBASE_DIR)\/vm\/mlvm\/share\n+    -I$(VM_TESTBASE_DIR)\/vm\/mlvm\/share \\\n+    #\n@@ -97,1 +105,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -102,1 +111,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -107,1 +117,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -111,1 +122,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -114,1 +126,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/stress\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/stress\/jni \\\n+    #\n@@ -120,1 +133,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/agent_common\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/agent_common \\\n+    #\n@@ -127,1 +141,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/aod\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/aod \\\n+    #\n@@ -132,1 +147,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -143,1 +159,1 @@\n-JVMTI_COMMON_INCLUDES=-I$(TOPDIR)\/test\/lib\/jdk\/test\/lib\/jvmti\n+JVMTI_COMMON_INCLUDES = -I$(TOPDIR)\/test\/lib\/jdk\/test\/lib\/jvmti\n@@ -765,1 +781,1 @@\n-BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS_libgetclmdf006 :=$(NSK_JVMTI_AGENT_INCLUDES)\n+BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS_libgetclmdf006 := $(NSK_JVMTI_AGENT_INCLUDES)\n@@ -1562,1 +1578,1 @@\n-$(eval $(call SetupCopyFiles,COPY_HOTSPOT_JTREG_NATIVE, \\\n+$(eval $(call SetupCopyFiles, COPY_HOTSPOT_JTREG_NATIVE, \\\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":35,"deletions":19,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-    -I$(TOPDIR)\/src\/java.base\/$(OPENJDK_TARGET_OS)\/native\/libjli\n+    -I$(TOPDIR)\/src\/java.base\/$(OPENJDK_TARGET_OS)\/native\/libjli \\\n+    #\n@@ -157,1 +158,1 @@\n-$(eval $(call SetupCopyFiles,COPY_JDK_JTREG_NATIVE, \\\n+$(eval $(call SetupCopyFiles, COPY_JDK_JTREG_NATIVE, \\\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2337,1 +2337,1 @@\n-  int size = MIN2((UseSVE > 0) ? 256 : 16, (int)MaxVectorSize);\n+  int size = MIN2((UseSVE > 0) ? (int)FloatRegister::sve_vl_max : (int)FloatRegister::neon_vl, (int)MaxVectorSize);\n@@ -2376,1 +2376,1 @@\n-  if (UseSVE > 0 && 16 < len && len <= 256) {\n+  if (UseSVE > 0 && FloatRegister::neon_vl < len && len <= FloatRegister::sve_vl_max) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-    if (UseSVE == 0 && length_in_bytes > 16) {\n+    if (UseSVE == 0 && length_in_bytes > FloatRegister::neon_vl) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-    if (UseSVE == 0 && length_in_bytes > 16) {\n+    if (UseSVE == 0 && length_in_bytes > FloatRegister::neon_vl) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,2 +63,0 @@\n-  void poll_for_safepoint(relocInfo::relocType rtype, CodeEmitInfo* info = nullptr);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6416,0 +6416,3 @@\n+  if (!UseSVE || VM_Version::get_max_supported_sve_vector_length() == FloatRegister::sve_vl_min) {\n+    return;\n+  }\n@@ -6417,1 +6420,0 @@\n-  if (!UseSVE) return;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,1 +169,7 @@\n-    extra_save_slots_per_neon_register = slots_per_neon_register - save_slots_per_register\n+    extra_save_slots_per_neon_register = slots_per_neon_register - save_slots_per_register,\n+    neon_vl = 16,\n+    \/\/ VLmax: The maximum sve vector length is determined by the hardware\n+    \/\/ sve_vl_min <= VLmax <= sve_vl_max.\n+    sve_vl_min = 16,\n+    \/\/ Maximum supported vector length across all CPUs\n+    sve_vl_max = 256\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"register_aarch64.hpp\"\n@@ -47,0 +48,1 @@\n+int VM_Version::_max_supported_sve_vector_length;\n@@ -510,2 +512,3 @@\n-    } else if (MaxVectorSize < 16) {\n-      warning(\"SVE does not support vector length less than 16 bytes. Disabling SVE.\");\n+    } else if (MaxVectorSize < FloatRegister::sve_vl_min) {\n+      warning(\"SVE does not support vector length less than %d bytes. Disabling SVE.\",\n+              FloatRegister::sve_vl_min);\n@@ -513,14 +516,1 @@\n-    } else if ((MaxVectorSize % 16) == 0 && is_power_of_2(MaxVectorSize)) {\n-      int new_vl = set_and_get_current_sve_vector_length(MaxVectorSize);\n-      _initial_sve_vector_length = new_vl;\n-      \/\/ Update MaxVectorSize to the largest supported value.\n-      if (new_vl < 0) {\n-        vm_exit_during_initialization(\n-          err_msg(\"Current system does not support SVE vector length for MaxVectorSize: %d\",\n-                  (int)MaxVectorSize));\n-      } else if (new_vl != MaxVectorSize) {\n-        warning(\"Current system only supports max SVE vector length %d. Set MaxVectorSize to %d\",\n-                new_vl, new_vl);\n-      }\n-      MaxVectorSize = new_vl;\n-    } else {\n+    } else if (!((MaxVectorSize % FloatRegister::sve_vl_min) == 0 && is_power_of_2(MaxVectorSize))) {\n@@ -529,0 +519,19 @@\n+\n+    if (UseSVE > 0) {\n+      \/\/ Acquire the largest supported vector length of this machine\n+      _max_supported_sve_vector_length = set_and_get_current_sve_vector_length(FloatRegister::sve_vl_max);\n+\n+      if (MaxVectorSize != _max_supported_sve_vector_length) {\n+        int new_vl = set_and_get_current_sve_vector_length(MaxVectorSize);\n+        if (new_vl < 0) {\n+          vm_exit_during_initialization(\n+            err_msg(\"Current system does not support SVE vector length for MaxVectorSize: %d\",\n+                    (int)MaxVectorSize));\n+        } else if (new_vl != MaxVectorSize) {\n+          warning(\"Current system only supports max SVE vector length %d. Set MaxVectorSize to %d\",\n+                  new_vl, new_vl);\n+        }\n+        MaxVectorSize = new_vl;\n+      }\n+      _initial_sve_vector_length = MaxVectorSize;\n+    }\n@@ -533,1 +542,1 @@\n-    int max_vector_size = 16;\n+    int max_vector_size = FloatRegister::neon_vl;\n@@ -545,1 +554,1 @@\n-      FLAG_SET_DEFAULT(MaxVectorSize, 16);\n+      FLAG_SET_DEFAULT(MaxVectorSize, FloatRegister::neon_vl);\n@@ -549,1 +558,1 @@\n-  int inline_size = (UseSVE > 0 && MaxVectorSize >= 16) ? MaxVectorSize : 0;\n+  int inline_size = (UseSVE > 0 && MaxVectorSize >= FloatRegister::sve_vl_min) ? MaxVectorSize : 0;\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":28,"deletions":19,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  static int _max_supported_sve_vector_length;\n@@ -167,1 +168,2 @@\n-  static int get_initial_sve_vector_length()  { return _initial_sve_vector_length; };\n+  static int get_initial_sve_vector_length()        { return _initial_sve_vector_length; };\n+  static int get_max_supported_sve_vector_length()  { return _max_supported_sve_vector_length; };\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-void Assembler::add(Register d, RegisterOrConstant roc, Register s1) {\n+void Assembler::add(Register d, Register s, RegisterOrConstant roc) {\n@@ -299,1 +299,3 @@\n-    addi(d, s1, (int)c);\n+    addi(d, s, (int)c);\n+  } else {\n+    add(d, s, roc.as_register());\n@@ -301,1 +303,0 @@\n-  else add(d, roc.as_register(), s1);\n@@ -304,1 +305,1 @@\n-void Assembler::subf(Register d, RegisterOrConstant roc, Register s1) {\n+void Assembler::sub(Register d, Register s, RegisterOrConstant roc) {\n@@ -308,1 +309,13 @@\n-    addi(d, s1, (int)-c);\n+    addi(d, s, (int)-c);\n+  } else {\n+    sub(d, s, roc.as_register());\n+  }\n+}\n+\n+void Assembler::xorr(Register d, Register s, RegisterOrConstant roc) {\n+  if (roc.is_constant()) {\n+    intptr_t c = roc.as_constant();\n+    assert(is_uimm(c, 16), \"too big\");\n+    xori(d, s, (int)c);\n+  } else {\n+    xorr(d, s, roc.as_register());\n@@ -310,1 +323,0 @@\n-  else subf(d, roc.as_register(), s1);\n@@ -313,1 +325,1 @@\n-void Assembler::cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1) {\n+void Assembler::cmpw(ConditionRegister d, Register s, RegisterOrConstant roc) {\n@@ -317,1 +329,13 @@\n-    cmpdi(d, s1, (int)c);\n+    cmpwi(d, s, (int)c);\n+  } else {\n+    cmpw(d, s, roc.as_register());\n+  }\n+}\n+\n+void Assembler::cmpd(ConditionRegister d, Register s, RegisterOrConstant roc) {\n+  if (roc.is_constant()) {\n+    intptr_t c = roc.as_constant();\n+    assert(is_simm(c, 16), \"too big\");\n+    cmpdi(d, s, (int)c);\n+  } else {\n+    cmpd(d, s, roc.as_register());\n@@ -319,1 +343,0 @@\n-  else cmpd(d, roc.as_register(), s1);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.cpp","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2515,3 +2515,7 @@\n-  void add( Register d, RegisterOrConstant roc, Register s1);\n-  void subf(Register d, RegisterOrConstant roc, Register s1);\n-  void cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1);\n+  void add( Register d, Register s, RegisterOrConstant roc);\n+  void add( Register d, RegisterOrConstant roc, Register s) { add(d, s, roc); }\n+  void sub( Register d, Register s, RegisterOrConstant roc);\n+  void xorr(Register d, Register s, RegisterOrConstant roc);\n+  void xorr(Register d, RegisterOrConstant roc, Register s) { xorr(d, s, roc); }\n+  void cmpw(ConditionRegister d, Register s, RegisterOrConstant roc);\n+  void cmpd(ConditionRegister d, Register s, RegisterOrConstant roc);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2623,1 +2623,1 @@\n-                noreg, \/*check without ldarx first*\/true);\n+                noreg, nullptr, \/*check without ldarx first*\/true);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -672,1 +672,1 @@\n-                false, success_flag, true);\n+                false, success_flag, nullptr, true);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -338,1 +338,1 @@\n-      __ add(ref_base, ind_or_offs, ref_base);\n+      __ add(ref_base, ref_base, ind_or_offs);\n@@ -346,1 +346,1 @@\n-      __ subf(ref_base, ind_or_offs, ref_base);\n+      __ sub(ref_base, ref_base, ind_or_offs);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1623,1 +1623,1 @@\n-                                       Register compare_value, Register exchange_value,\n+                                       RegisterOrConstant compare_value, Register exchange_value,\n@@ -1637,1 +1637,1 @@\n-    assert_different_registers(tmp1, tmp2, dest_current_value, compare_value, exchange_value, addr_base);\n+    assert_different_registers(tmp1, tmp2, dest_current_value, compare_value.register_or_noreg(), exchange_value, addr_base);\n@@ -1698,1 +1698,1 @@\n-                                     Register compare_value, Register exchange_value,\n+                                     RegisterOrConstant compare_value, Register exchange_value,\n@@ -1700,2 +1700,2 @@\n-                                     int semantics, bool cmpxchgx_hint,\n-                                     Register int_flag_success, bool contention_hint, bool weak, int size) {\n+                                     int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                                     Label* failed_ext, bool contention_hint, bool weak, int size) {\n@@ -1703,1 +1703,2 @@\n-  Label failed;\n+  Label failed_int;\n+  Label& failed = (failed_ext != nullptr) ? *failed_ext : failed_int;\n@@ -1709,1 +1710,1 @@\n-  bool preset_result_reg = (int_flag_success != dest_current_value && int_flag_success != compare_value &&\n+  bool preset_result_reg = (int_flag_success != dest_current_value && int_flag_success != compare_value.register_or_noreg() &&\n@@ -1713,0 +1714,1 @@\n+  assert(int_flag_success == noreg || failed_ext == nullptr, \"cannot have both\");\n@@ -1738,1 +1740,1 @@\n-  if (!weak || use_result_reg) {\n+  if (!weak || use_result_reg || failed_ext) {\n@@ -1763,1 +1765,1 @@\n-  bind(failed);\n+  bind(failed_int);\n@@ -1790,4 +1792,5 @@\n-void MacroAssembler::cmpxchgd(ConditionRegister flag,\n-                              Register dest_current_value, RegisterOrConstant compare_value, Register exchange_value,\n-                              Register addr_base, int semantics, bool cmpxchgx_hint,\n-                              Register int_flag_success, Label* failed_ext, bool contention_hint, bool weak) {\n+void MacroAssembler::cmpxchgd(ConditionRegister flag, Register dest_current_value,\n+                              RegisterOrConstant compare_value, Register exchange_value,\n+                              Register addr_base,\n+                              int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                              Label* failed_ext, bool contention_hint, bool weak) {\n@@ -1813,1 +1816,1 @@\n-    cmpd(flag, compare_value, dest_current_value);\n+    cmpd(flag, dest_current_value, compare_value);\n@@ -1826,1 +1829,1 @@\n-  cmpd(flag, compare_value, dest_current_value);\n+  cmpd(flag, dest_current_value, compare_value);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -485,1 +485,1 @@\n-                         Register compare_value, Register exchange_value,\n+                         RegisterOrConstant compare_value, Register exchange_value,\n@@ -488,4 +488,5 @@\n-  void cmpxchg_generic(ConditionRegister flag,\n-                       Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                       Register tmp1, Register tmp2,\n-                       int semantics, bool cmpxchgx_hint, Register int_flag_success, bool contention_hint, bool weak, int size);\n+  void cmpxchg_generic(ConditionRegister flag, Register dest_current_value,\n+                       RegisterOrConstant compare_value, Register exchange_value,\n+                       Register addr_base, Register tmp1, Register tmp2,\n+                       int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                       Label* failed_ext, bool contention_hint, bool weak, int size);\n@@ -531,4 +532,5 @@\n-  void cmpxchgb(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                Register tmp1, Register tmp2, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgb(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base, Register tmp1, Register tmp2,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -536,1 +538,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 1);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 1);\n@@ -540,4 +542,5 @@\n-  void cmpxchgh(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                Register tmp1, Register tmp2, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgh(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base, Register tmp1, Register tmp2,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -545,1 +548,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 2);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 2);\n@@ -547,4 +550,5 @@\n-  void cmpxchgw(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgw(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -552,1 +556,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 4);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 4);\n@@ -554,4 +558,5 @@\n-  void cmpxchgd(ConditionRegister flag,\n-                Register dest_current_value, RegisterOrConstant compare_value, Register exchange_value,\n-                Register addr_base, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, Label* failed = nullptr, bool contention_hint = false, bool weak = false);\n+  void cmpxchgd(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":29,"deletions":24,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -7393,1 +7393,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7412,1 +7412,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7431,1 +7431,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7450,1 +7450,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7468,1 +7468,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7486,1 +7486,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7544,1 +7544,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7558,1 +7558,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7572,1 +7572,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7586,1 +7586,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7600,1 +7600,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7614,1 +7614,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7628,1 +7628,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7642,1 +7642,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7656,1 +7656,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7672,1 +7672,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7686,1 +7686,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7702,1 +7702,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7779,1 +7779,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7793,1 +7793,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7807,1 +7807,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7827,1 +7827,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7847,1 +7847,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7861,1 +7861,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7875,1 +7875,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7895,1 +7895,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7915,1 +7915,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7929,1 +7929,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7949,1 +7949,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7963,1 +7963,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-    __ cmpd(CCR0, R19_method, 0);\n+    __ cmpdi(CCR0, R19_method, 0);\n","filename":"src\/hotspot\/cpu\/ppc\/vtableStubs_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1838,0 +1838,1 @@\n+  INSN(vlseg4e8_v, 0b0000111, 0b000, 0b00000, 0b00, 0b0, g4);\n@@ -1840,0 +1841,1 @@\n+  INSN(vsseg3e8_v, 0b0100111, 0b000, 0b00000, 0b00, 0b0, g3);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-  void poll_for_safepoint(relocInfo::relocType rtype, CodeEmitInfo* info = nullptr);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -226,2 +226,0 @@\n-const int float_regs_as_doubles_size_in_slots = pd_nof_fpu_regs_frame_map * 2;\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_Runtime1_riscv.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,12 +149,0 @@\n-bool MacroAssembler::is_li64_at(address instr) {\n-  return is_lui_at(instr) && \/\/ lui\n-         is_addi_at(instr + instruction_size) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 2, 12) &&  \/\/ Slli Rd, Rs, 12\n-         is_addi_at(instr + instruction_size * 3) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 4, 12) &&  \/\/ Slli Rd, Rs, 12\n-         is_addi_at(instr + instruction_size * 5) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 6, 8) &&   \/\/ Slli Rd, Rs, 8\n-         is_addi_at(instr + instruction_size * 7) && \/\/ addi\n-         check_li64_data_dependency(instr);\n-}\n-\n@@ -912,1 +900,0 @@\n-  \/\/ use addiw to distinguish li32 to li64\n@@ -916,27 +903,0 @@\n-void MacroAssembler::li64(Register Rd, int64_t imm) {\n-  \/\/ Load upper 32 bits. upper = imm[63:32], but if imm[31] == 1 or\n-  \/\/ (imm[31:20] == 0x7ff && imm[19] == 1), upper = imm[63:32] + 1.\n-  int64_t lower = imm & 0xffffffff;\n-  lower -= ((lower << 44) >> 44);\n-  int64_t tmp_imm = ((uint64_t)(imm & 0xffffffff00000000)) + (uint64_t)lower;\n-  int32_t upper = (tmp_imm - (int32_t)lower) >> 32;\n-\n-  \/\/ Load upper 32 bits\n-  int64_t up = upper, lo = upper;\n-  lo = (lo << 52) >> 52;\n-  up -= lo;\n-  up = (int32_t)up;\n-  lui(Rd, up);\n-  addi(Rd, Rd, lo);\n-\n-  \/\/ Load the rest 32 bits.\n-  slli(Rd, Rd, 12);\n-  addi(Rd, Rd, (int32_t)lower >> 20);\n-  slli(Rd, Rd, 12);\n-  lower = ((int32_t)imm << 12) >> 20;\n-  addi(Rd, Rd, lower);\n-  slli(Rd, Rd, 8);\n-  lower = imm & 0xff;\n-  addi(Rd, Rd, lower);\n-}\n-\n@@ -1744,21 +1704,0 @@\n-static int patch_imm_in_li64(address branch, address target) {\n-  const int LI64_INSTRUCTIONS_NUM = 8;                                          \/\/ lui + addi + slli + addi + slli + addi + slli + addi\n-  int64_t lower = (intptr_t)target & 0xffffffff;\n-  lower = lower - ((lower << 44) >> 44);\n-  int64_t tmp_imm = ((uint64_t)((intptr_t)target & 0xffffffff00000000)) + (uint64_t)lower;\n-  int32_t upper =  (tmp_imm - (int32_t)lower) >> 32;\n-  int64_t tmp_upper = upper, tmp_lower = upper;\n-  tmp_lower = (tmp_lower << 52) >> 52;\n-  tmp_upper -= tmp_lower;\n-  tmp_upper >>= 12;\n-  \/\/ Load upper 32 bits. Upper = target[63:32], but if target[31] = 1 or (target[31:20] == 0x7ff && target[19] == 1),\n-  \/\/ upper = target[63:32] + 1.\n-  Assembler::patch(branch + 0,  31, 12, tmp_upper & 0xfffff);                       \/\/ Lui.\n-  Assembler::patch(branch + 4,  31, 20, tmp_lower & 0xfff);                         \/\/ Addi.\n-  \/\/ Load the rest 32 bits.\n-  Assembler::patch(branch + 12, 31, 20, ((int32_t)lower >> 20) & 0xfff);            \/\/ Addi.\n-  Assembler::patch(branch + 20, 31, 20, (((intptr_t)target << 44) >> 52) & 0xfff);  \/\/ Addi.\n-  Assembler::patch(branch + 28, 31, 20, (intptr_t)target & 0xff);                   \/\/ Addi.\n-  return LI64_INSTRUCTIONS_NUM * MacroAssembler::instruction_size;\n-}\n-\n@@ -1835,10 +1774,0 @@\n-static address get_target_of_li64(address insn_addr) {\n-  assert_cond(insn_addr != nullptr);\n-  intptr_t target_address = (((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr), 31, 12)) & 0xfffff) << 44; \/\/ Lui.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 4), 31, 20)) << 32;                 \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 12), 31, 20)) << 20;                \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 20), 31, 20)) << 8;                 \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 28), 31, 20));                      \/\/ Addi.\n-  return (address)target_address;\n-}\n-\n@@ -1867,2 +1796,0 @@\n-  } else if (MacroAssembler::is_li64_at(instruction_address)) {                 \/\/ li64\n-    return patch_imm_in_li64(instruction_address, target);\n@@ -1899,2 +1826,0 @@\n-  } else if (MacroAssembler::is_li64_at(insn_addr)) {             \/\/ li64\n-    return get_target_of_li64(insn_addr);\n@@ -3608,1 +3533,1 @@\n-         \"destination of far call not found in code cache\");\n+         \"destination of far jump not found in code cache\");\n@@ -3613,0 +3538,2 @@\n+  \/\/ We can use auipc + jr here because we know that the total size of\n+  \/\/ the code cache cannot exceed 2Gb.\n@@ -3614,2 +3541,4 @@\n-    int32_t offset;\n-    la(tmp, entry.target(), offset);\n+    int64_t distance = entry.target() - pc();\n+    int32_t offset = ((int32_t)distance << 20) >> 20;\n+    assert(is_valid_32bit_offset(distance), \"Far jump using wrong instructions.\");\n+    auipc(tmp, (int32_t)distance + 0x800);\n@@ -3630,2 +3559,5 @@\n-    assert(is_valid_32bit_offset(entry.target() - pc()), \"Far call using wrong instructions.\");\n-    call(entry.target(), tmp);\n+    int64_t distance = entry.target() - pc();\n+    int32_t offset = ((int32_t)distance << 20) >> 20;\n+    assert(is_valid_32bit_offset(distance), \"Far call using wrong instructions.\");\n+    auipc(tmp, (int32_t)distance + 0x800);\n+    jalr(tmp, offset);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":12,"deletions":80,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -816,1 +816,0 @@\n-  void li64(Register Rd, int64_t imm);\n@@ -1709,34 +1708,0 @@\n-  \/\/ the instruction sequence of li64 is as below:\n-  \/\/     lui\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  static bool check_li64_data_dependency(address instr) {\n-    address lui = instr;\n-    address addi1 = lui + instruction_size;\n-    address slli1 = addi1 + instruction_size;\n-    address addi2 = slli1 + instruction_size;\n-    address slli2 = addi2 + instruction_size;\n-    address addi3 = slli2 + instruction_size;\n-    address slli3 = addi3 + instruction_size;\n-    address addi4 = slli3 + instruction_size;\n-    return extract_rs1(addi1) == extract_rd(lui) &&\n-           extract_rs1(addi1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(slli2) &&\n-           extract_rs1(addi3) == extract_rd(slli2) &&\n-           extract_rs1(addi3) == extract_rd(addi3) &&\n-           extract_rs1(slli3) == extract_rd(addi3) &&\n-           extract_rs1(slli3) == extract_rd(slli3) &&\n-           extract_rs1(addi4) == extract_rd(slli3) &&\n-           extract_rs1(addi4) == extract_rd(addi4);\n-  }\n-\n@@ -1787,1 +1752,0 @@\n-  static bool is_li64_at(address instr);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -5325,0 +5325,273 @@\n+  \/**\n+   * vector registers:\n+   * input VectorRegister's:  intputV1-V4, for m2 they could be v2, v4, v6, for m1 they could be v2, v4, v6, v8\n+   * index VectorRegister's:  idxV1-V3, for m2 they could be v8, v10, v12, v14, for m1 they could be v10, v12, v14, v16\n+   * output VectorRegister's: outputV1-V4, for m2 they could be v16, v18, v20, v22, for m1 they could be v18, v20, v22\n+   *\n+   * NOTE: each field will occupy a single vector register group\n+   *\/\n+  void base64_vector_decode_round(Register src, Register dst, Register codec,\n+                    Register size, Register stepSrc, Register stepDst, Register failedIdx, Register minusOne,\n+                    VectorRegister inputV1, VectorRegister inputV2, VectorRegister inputV3, VectorRegister inputV4,\n+                    VectorRegister idxV1, VectorRegister idxV2, VectorRegister idxV3, VectorRegister idxV4,\n+                    VectorRegister outputV1, VectorRegister outputV2, VectorRegister outputV3,\n+                    Assembler::LMUL lmul) {\n+    \/\/ set vector register type\/len\n+    __ vsetvli(x0, size, Assembler::e8, lmul, Assembler::ma, Assembler::ta);\n+\n+    \/\/ segmented load src into v registers: mem(src) => vr(4)\n+    __ vlseg4e8_v(inputV1, src);\n+\n+    \/\/ src = src + register_group_len_bytes * 4\n+    __ add(src, src, stepSrc);\n+\n+    \/\/ decoding\n+    \/\/   1. indexed load: vr(4) => vr(4)\n+    __ vluxei8_v(idxV1, codec, inputV1);\n+    __ vluxei8_v(idxV2, codec, inputV2);\n+    __ vluxei8_v(idxV3, codec, inputV3);\n+    __ vluxei8_v(idxV4, codec, inputV4);\n+\n+    \/\/   2. check wrong data\n+    __ vor_vv(outputV1, idxV1, idxV2);\n+    __ vor_vv(outputV2, idxV3, idxV4);\n+    __ vor_vv(outputV1, outputV1, outputV2);\n+    __ vmseq_vi(v0, outputV1, -1);\n+    __ vfirst_m(failedIdx, v0);\n+    Label NoFailure;\n+    __ beq(failedIdx, minusOne, NoFailure);\n+    __ vsetvli(x0, failedIdx, Assembler::e8, lmul, Assembler::mu, Assembler::tu);\n+    __ slli(stepDst, failedIdx, 1);\n+    __ add(stepDst, failedIdx, stepDst);\n+    __ BIND(NoFailure);\n+\n+    \/\/   3. compute the decoded data: vr(4) => vr(3)\n+    __ vsll_vi(idxV1, idxV1, 2);\n+    __ vsrl_vi(outputV1, idxV2, 4);\n+    __ vor_vv(outputV1, outputV1, idxV1);\n+\n+    __ vsll_vi(idxV2, idxV2, 4);\n+    __ vsrl_vi(outputV2, idxV3, 2);\n+    __ vor_vv(outputV2, outputV2, idxV2);\n+\n+    __ vsll_vi(idxV3, idxV3, 6);\n+    __ vor_vv(outputV3, idxV4, idxV3);\n+\n+    \/\/ segmented store encoded data in v registers back to dst: vr(3) => mem(dst)\n+    __ vsseg3e8_v(outputV1, dst);\n+\n+    \/\/ dst = dst + register_group_len_bytes * 3\n+    __ add(dst, dst, stepDst);\n+  }\n+\n+  \/**\n+   * int j.u.Base64.Decoder.decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL, boolean isMIME)\n+   *\n+   *  Input arguments:\n+   *  c_rarg0   - src, source array\n+   *  c_rarg1   - sp, src start offset\n+   *  c_rarg2   - sl, src end offset\n+   *  c_rarg3   - dst, dest array\n+   *  c_rarg4   - dp, dst start offset\n+   *  c_rarg5   - isURL, Base64 or URL character set\n+   *  c_rarg6   - isMIME, Decoding MIME block\n+   *\/\n+  address generate_base64_decodeBlock() {\n+\n+    static const uint8_t fromBase64[256] = {\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u, 255u,  63u,\n+        52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+        15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u, 255u,\n+        255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+        41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    static const uint8_t fromBase64URL[256] = {\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u,\n+        52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+        15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,  63u,\n+        255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+        41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"decodeBlock\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    Register src    = c_rarg0;\n+    Register soff   = c_rarg1;\n+    Register send   = c_rarg2;\n+    Register dst    = c_rarg3;\n+    Register doff   = c_rarg4;\n+    Register isURL  = c_rarg5;\n+    Register isMIME = c_rarg6;\n+\n+    Register codec     = c_rarg7;\n+    Register dstBackup = x31;\n+    Register length    = x28;     \/\/ t3, total length of src data in bytes\n+\n+    Label ProcessData, Exit;\n+    Label ProcessScalar, ScalarLoop;\n+\n+    \/\/ passed in length (send - soff) is guaranteed to be > 4,\n+    \/\/ and in this intrinsic we only process data of length in multiple of 4,\n+    \/\/ it's not guaranteed to be multiple of 4 by java level, so do it explicitly\n+    __ sub(length, send, soff);\n+    __ andi(length, length, -4);\n+    \/\/ real src\/dst to process data\n+    __ add(src, src, soff);\n+    __ add(dst, dst, doff);\n+    \/\/ backup of dst, used to calculate the return value at exit\n+    __ mv(dstBackup, dst);\n+\n+    \/\/ load the codec base address\n+    __ la(codec, ExternalAddress((address) fromBase64));\n+    __ beqz(isURL, ProcessData);\n+    __ la(codec, ExternalAddress((address) fromBase64URL));\n+    __ BIND(ProcessData);\n+\n+    \/\/ vector version\n+    if (UseRVV) {\n+      \/\/ for MIME case, it has a default length limit of 76 which could be\n+      \/\/ different(smaller) from (send - soff), so in MIME case, we go through\n+      \/\/ the scalar code path directly.\n+      __ bnez(isMIME, ScalarLoop);\n+\n+      Label ProcessM1, ProcessM2;\n+\n+      Register failedIdx = soff;\n+      Register stepSrcM1 = send;\n+      Register stepSrcM2 = doff;\n+      Register stepDst   = isURL;\n+      Register size      = x29;   \/\/ t4\n+      Register minusOne  = x30;   \/\/ t5\n+\n+      __ mv(minusOne, -1);\n+      __ mv(size, MaxVectorSize * 2);\n+      __ mv(stepSrcM1, MaxVectorSize * 4);\n+      __ slli(stepSrcM2, stepSrcM1, 1);\n+      __ mv(stepDst, MaxVectorSize * 2 * 3);\n+\n+      __ blt(length, stepSrcM2, ProcessM1);\n+\n+\n+      \/\/ Assembler::m2\n+      __ BIND(ProcessM2);\n+      base64_vector_decode_round(src, dst, codec,\n+                    size, stepSrcM2, stepDst, failedIdx, minusOne,\n+                    v2, v4, v6, v8,      \/\/ inputs\n+                    v10, v12, v14, v16,  \/\/ indexes\n+                    v18, v20, v22,       \/\/ outputs\n+                    Assembler::m2);\n+      __ sub(length, length, stepSrcM2);\n+\n+      \/\/ error check\n+      __ bne(failedIdx, minusOne, Exit);\n+\n+      __ bge(length, stepSrcM2, ProcessM2);\n+\n+\n+      \/\/ Assembler::m1\n+      __ BIND(ProcessM1);\n+      __ blt(length, stepSrcM1, ProcessScalar);\n+\n+      __ srli(size, size, 1);\n+      __ srli(stepDst, stepDst, 1);\n+      base64_vector_decode_round(src, dst, codec,\n+                    size, stepSrcM1, stepDst, failedIdx, minusOne,\n+                    v1, v2, v3, v4,      \/\/ inputs\n+                    v5, v6, v7, v8,      \/\/ indexes\n+                    v9, v10, v11,        \/\/ outputs\n+                    Assembler::m1);\n+      __ sub(length, length, stepSrcM1);\n+\n+      \/\/ error check\n+      __ bne(failedIdx, minusOne, Exit);\n+\n+      __ BIND(ProcessScalar);\n+      __ beqz(length, Exit);\n+    }\n+\n+    \/\/ scalar version\n+    {\n+      Register byte0 = soff, byte1 = send, byte2 = doff, byte3 = isURL;\n+      Register combined32Bits = x29; \/\/ t5\n+\n+      \/\/ encoded:   [byte0[5:0] : byte1[5:0] : byte2[5:0]] : byte3[5:0]] =>\n+      \/\/ plain:     [byte0[5:0]+byte1[5:4] : byte1[3:0]+byte2[5:2] : byte2[1:0]+byte3[5:0]]\n+      __ BIND(ScalarLoop);\n+\n+      \/\/ load 4 bytes encoded src data\n+      __ lbu(byte0, Address(src, 0));\n+      __ lbu(byte1, Address(src, 1));\n+      __ lbu(byte2, Address(src, 2));\n+      __ lbu(byte3, Address(src, 3));\n+      __ addi(src, src, 4);\n+\n+      \/\/ get codec index and decode (ie. load from codec by index)\n+      __ add(byte0, codec, byte0);\n+      __ add(byte1, codec, byte1);\n+      __ lb(byte0, Address(byte0, 0));\n+      __ lb(byte1, Address(byte1, 0));\n+      __ add(byte2, codec, byte2);\n+      __ add(byte3, codec, byte3);\n+      __ lb(byte2, Address(byte2, 0));\n+      __ lb(byte3, Address(byte3, 0));\n+      __ slliw(byte0, byte0, 18);\n+      __ slliw(byte1, byte1, 12);\n+      __ orr(byte0, byte0, byte1);\n+      __ orr(byte0, byte0, byte3);\n+      __ slliw(byte2, byte2, 6);\n+      \/\/ For performance consideration, `combined32Bits` is constructed for 2 purposes at the same time,\n+      \/\/  1. error check below\n+      \/\/  2. decode below\n+      __ orr(combined32Bits, byte0, byte2);\n+\n+      \/\/ error check\n+      __ bltz(combined32Bits, Exit);\n+\n+      \/\/ store 3 bytes decoded data\n+      __ sraiw(byte0, combined32Bits, 16);\n+      __ sraiw(byte1, combined32Bits, 8);\n+      __ sb(byte0, Address(dst, 0));\n+      __ sb(byte1, Address(dst, 1));\n+      __ sb(combined32Bits, Address(dst, 2));\n+\n+      __ sub(length, length, 4);\n+      __ addi(dst, dst, 3);\n+      \/\/ loop back\n+      __ bnez(length, ScalarLoop);\n+    }\n+\n+    __ BIND(Exit);\n+    __ sub(c_rarg0, dst, dstBackup);\n+\n+    __ leave();\n+    __ ret();\n+\n+    return (address) start;\n+  }\n+\n@@ -5983,0 +6256,1 @@\n+      StubRoutines::_base64_decodeBlock = generate_base64_decodeBlock();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":274,"deletions":0,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -476,3 +476,3 @@\n-#ifdef STATIC_BUILD\n-    strcat(buf, \"\/lib\");\n-#endif\n+    if (is_vm_statically_linked()) {\n+      strcat(buf, \"\/lib\");\n+    }\n@@ -1096,3 +1096,4 @@\n-#ifdef STATIC_BUILD\n-  return os::get_default_process_handle();\n-#else\n+  if (is_vm_statically_linked()) {\n+    return os::get_default_process_handle();\n+  }\n+\n@@ -1102,1 +1103,0 @@\n-#endif \/\/ STATIC_BUILD\n@@ -1106,3 +1106,4 @@\n-#ifdef STATIC_BUILD\n-  return os::get_default_process_handle();\n-#else\n+  if (is_vm_statically_linked()) {\n+    return os::get_default_process_handle();\n+  }\n+\n@@ -1272,1 +1273,0 @@\n-#endif \/\/ STATIC_BUILD\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2119,1 +2119,1 @@\n-    assert(!target->can_be_statically_bound() || target == cha_monomorphic_target, \"\");\n+    assert(!target->can_be_statically_bound() || target->equals(cha_monomorphic_target), \"\");\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -271,1 +271,0 @@\n-  st->print_cr(\"- narrow_oop_base:                \" INTPTR_FORMAT, p2i(_narrow_oop_base));\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1647,24 +1647,0 @@\n-#ifndef PRODUCT\n-ResourceBitMap HeapShared::calculate_oopmap(MemRegion region) {\n-  size_t num_bits = region.byte_size() \/ (UseCompressedOops ? sizeof(narrowOop) : sizeof(oop));\n-  ResourceBitMap oopmap(num_bits);\n-\n-  HeapWord* p   = region.start();\n-  HeapWord* end = region.end();\n-  FindEmbeddedNonNullPointers finder((void*)p, &oopmap);\n-\n-  int num_objs = 0;\n-  while (p < end) {\n-    oop o = cast_to_oop(p);\n-    o->oop_iterate(&finder);\n-    p += o->size();\n-    ++ num_objs;\n-  }\n-\n-  log_info(cds, heap)(\"calculate_oopmap: objects = %6d, oop fields = %7d (nulls = %7d)\",\n-                      num_objs, finder.num_total_oops(), finder.num_null_oops());\n-  return oopmap;\n-}\n-\n-#endif \/\/ !PRODUCT\n-\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -374,3 +374,0 @@\n-#ifndef PRODUCT\n-  static ResourceBitMap calculate_oopmap(MemRegion region); \/\/ marks all the oop pointers\n-#endif\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -784,0 +784,16 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciMethod::equals\n+\/\/\n+\/\/ Returns true if the methods are the same, taking redefined methods\n+\/\/ into account.\n+bool ciMethod::equals(const ciMethod* m) const {\n+  if (this == m) return true;\n+  VM_ENTRY_MARK;\n+  Method* m1 = this->get_Method();\n+  Method* m2 = m->get_Method();\n+  if (m1->is_old()) m1 = m1->get_new_method();\n+  if (m2->is_old()) m2 = m2->get_new_method();\n+  return m1 == m2;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -369,0 +369,2 @@\n+  bool equals(const ciMethod* m) const;\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-\/\/ UTF8::as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, int buflen).\n+\/\/ UTF8::as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, size_t buflen).\n@@ -437,1 +437,1 @@\n-void HashtableTextDump::put_utf8(outputStream* st, const char* utf8_string, int utf8_length) {\n+void HashtableTextDump::put_utf8(outputStream* st, const char* utf8_string, size_t utf8_length) {\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-  static void put_utf8(outputStream* st, const char* utf8_string, int utf8_length);\n+  static void put_utf8(outputStream* st, const char* utf8_string, size_t utf8_length);\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -307,1 +307,2 @@\n-    char* expected = UNICODE::as_utf8(unicode, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    char* expected = UNICODE::as_utf8(unicode, utf8_len);\n@@ -349,1 +350,1 @@\n-  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, (int)strlen(utf8_str), false)) {\n+  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, strlen(utf8_str), false)) {\n@@ -557,1 +558,1 @@\n-  int result_length;\n+  size_t result_length;\n@@ -569,2 +570,2 @@\n-  assert(result_length >= length + 1, \"must not be shorter\");\n-  assert(result_length == (int)strlen(result) + 1, \"must match\");\n+  assert(result_length >= (size_t)length + 1, \"must not be shorter\");\n+  assert(result_length == strlen(result) + 1, \"must match\");\n@@ -585,2 +586,3 @@\n-    const char* base = UNICODE::as_utf8(position, length);\n-    Symbol* sym = SymbolTable::new_symbol(base, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    const char* base = UNICODE::as_utf8(position, utf8_len);\n+    Symbol* sym = SymbolTable::new_symbol(base, checked_cast<int>(utf8_len));\n@@ -601,2 +603,3 @@\n-    const char* base = UNICODE::as_utf8(position, length);\n-    return SymbolTable::probe(base, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    const char* base = UNICODE::as_utf8(position, utf8_len);\n+    return SymbolTable::probe(base, checked_cast<int>(utf8_len));\n@@ -606,1 +609,1 @@\n-int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {\n+size_t java_lang_String::utf8_length(oop java_string, typeArrayOop value) {\n@@ -620,1 +623,1 @@\n-int java_lang_String::utf8_length(oop java_string) {\n+size_t java_lang_String::utf8_length(oop java_string) {\n@@ -625,0 +628,19 @@\n+int java_lang_String::utf8_length_as_int(oop java_string) {\n+  typeArrayOop value = java_lang_String::value(java_string);\n+  return utf8_length_as_int(java_string, value);\n+}\n+\n+int java_lang_String::utf8_length_as_int(oop java_string, typeArrayOop value) {\n+  assert(value_equals(value, java_lang_String::value(java_string)),\n+         \"value must be same as java_lang_String::value(java_string)\");\n+  int length = java_lang_String::length(java_string, value);\n+  if (length == 0) {\n+    return 0;\n+  }\n+  if (!java_lang_String::is_latin1(java_string)) {\n+    return UNICODE::utf8_length_as_int(value->char_at_addr(0), length);\n+  } else {\n+    return UNICODE::utf8_length_as_int(value->byte_at_addr(0), length);\n+  }\n+}\n+\n@@ -626,1 +648,1 @@\n-  int length;\n+  size_t length;\n@@ -630,1 +652,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, int& length) {\n+char* java_lang_String::as_utf8_string(oop java_string, size_t& length) {\n@@ -632,0 +654,2 @@\n+  \/\/ `length` is used as the incoming number of characters to\n+  \/\/ convert, and then set as the number of bytes in the UTF8 sequence.\n@@ -645,1 +669,1 @@\n-char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, int buflen, int& utf8_len) {\n+char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, size_t buflen, size_t& utf8_len) {\n@@ -666,1 +690,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, size_t buflen) {\n@@ -680,1 +704,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, char* buf, size_t buflen) {\n@@ -686,0 +710,3 @@\n+  \/\/ `length` is used as the incoming number of characters to\n+  \/\/ convert, and then set as the number of bytes in the UTF8 sequence.\n+  size_t  length = static_cast<size_t>(len);\n@@ -691,1 +718,1 @@\n-    return UNICODE::as_utf8(position, len);\n+    return UNICODE::as_utf8(position, length);\n@@ -694,1 +721,1 @@\n-    return UNICODE::as_utf8(position, len);\n+    return UNICODE::as_utf8(position, length);\n@@ -698,1 +725,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, size_t buflen) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":46,"deletions":19,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -134,2 +134,5 @@\n-  static int utf8_length(oop java_string);\n-  static int utf8_length(oop java_string, typeArrayOop string_value);\n+  static size_t utf8_length(oop java_string);\n+  static size_t utf8_length(oop java_string, typeArrayOop string_value);\n+  \/\/ Legacy variants that truncate the length if needed\n+  static int    utf8_length_as_int(oop java_string);\n+  static int    utf8_length_as_int(oop java_string, typeArrayOop string_value);\n@@ -139,3 +142,4 @@\n-  static char*  as_utf8_string(oop java_string, int& length);\n-  static char*  as_utf8_string_full(oop java_string, char* buf, int buflen, int& length);\n-  static char*  as_utf8_string(oop java_string, char* buf, int buflen);\n+  \/\/ `length` is set to the length of the utf8 sequence.\n+  static char*  as_utf8_string(oop java_string, size_t& length);\n+  static char*  as_utf8_string_full(oop java_string, char* buf, size_t buflen, size_t& length);\n+  static char*  as_utf8_string(oop java_string, char* buf, size_t buflen);\n@@ -143,2 +147,2 @@\n-  static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);\n-  static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);\n+  static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, size_t buflen);\n+  static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -75,1 +75,3 @@\n-  char* module_name = java_lang_String::as_utf8_string(name_oop, len);\n+  size_t utf8_len;\n+  char* module_name = java_lang_String::as_utf8_string(name_oop, utf8_len);\n+  len = checked_cast<int>(utf8_len); \/\/ module names are < 64K\n@@ -87,1 +89,1 @@\n-  int len;\n+  size_t len;\n@@ -89,1 +91,1 @@\n-  return SymbolTable::new_symbol(str, len);\n+  return SymbolTable::new_symbol(str, checked_cast<int>(len));\n@@ -145,2 +147,4 @@\n-static const char* as_internal_package(oop package_string, char* buf, int buflen, int& utf8_len) {\n-  char* package_name = java_lang_String::as_utf8_string_full(package_string, buf, buflen, utf8_len);\n+static const char* as_internal_package(oop package_string, char* buf, size_t buflen, int& utf8_len) {\n+  size_t full_utf8_len;\n+  char* package_name = java_lang_String::as_utf8_string_full(package_string, buf, buflen, full_utf8_len);\n+  utf8_len = checked_cast<int>(full_utf8_len); \/\/ package names are < 64K\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -689,1 +689,1 @@\n-    int utf8_length = length;\n+    size_t utf8_length = length;\n@@ -700,1 +700,1 @@\n-    st->print(\"%d: \", utf8_length);\n+    st->print(\"%zu: \", utf8_length);\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -352,0 +352,1 @@\n+  assert(len >= 0, \"negative length %d suggests integer overflow in the caller\", len);\n@@ -464,1 +465,1 @@\n-  int utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n+  size_t utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n@@ -466,1 +467,1 @@\n-  if (utf8_length < (int) sizeof(stack_buf)) {\n+  if (utf8_length < sizeof(stack_buf)) {\n@@ -469,1 +470,1 @@\n-    return new_symbol(chars, utf8_length);\n+    return new_symbol(chars, checked_cast<int>(utf8_length));\n@@ -474,1 +475,1 @@\n-    return new_symbol(chars, utf8_length);\n+    return new_symbol(chars, checked_cast<int>(utf8_length));\n@@ -480,1 +481,1 @@\n-  int utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n+  size_t utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n@@ -482,1 +483,1 @@\n-  if (utf8_length < (int) sizeof(stack_buf)) {\n+  if (utf8_length < sizeof(stack_buf)) {\n@@ -485,1 +486,1 @@\n-    return lookup_only(chars, utf8_length, hash);\n+    return lookup_only(chars, checked_cast<int>(utf8_length), hash);\n@@ -490,1 +491,1 @@\n-    return lookup_only(chars, utf8_length, hash);\n+    return lookup_only(chars, checked_cast<int>(utf8_length), hash);\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -264,1 +264,2 @@\n-  if ((int)strlen(name) > Symbol::max_length()) {\n+  size_t name_len = strlen(name);\n+  if (name_len > static_cast<size_t>(Symbol::max_length())) {\n@@ -266,5 +267,18 @@\n-    \/\/ into the constant pool.\n-    Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n-                       \"Class name exceeds maximum length of %d: %s\",\n-                       Symbol::max_length(),\n-                       name);\n+    \/\/ into the constant pool. If necessary report an abridged name\n+    \/\/ in the exception message.\n+    if (name_len > static_cast<size_t>(MaxStringPrintSize)) {\n+      Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n+                         \"Class name exceeds maximum length of %d: %.*s ... (%zu characters omitted) ... %.*s\",\n+                         Symbol::max_length(),\n+                         MaxStringPrintSize \/ 2,\n+                         name,\n+                         name_len - 2 * (MaxStringPrintSize \/ 2), \/\/ allows for odd value\n+                         MaxStringPrintSize \/ 2,\n+                         name + name_len - MaxStringPrintSize \/ 2);\n+    }\n+    else {\n+      Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n+                         \"Class name exceeds maximum length of %d: %s\",\n+                         Symbol::max_length(),\n+                         name);\n+    }\n@@ -274,1 +288,2 @@\n-  assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false),\n+  assert(UTF8::is_legal_utf8((const unsigned char*)name,\n+                             static_cast<int>(name_len), false),\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-  const size_t min_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3); \/\/ Make sure we have enough space for VM internal code\n+  const size_t min_cache_size = CompilerConfig::min_code_cache_size(); \/\/ Make sure we have enough space for VM internal code\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-      int max_count = (ReservedCodeCacheSize - (CodeCacheMinimumUseSpace DEBUG_ONLY(* 3))) \/ (int)buffer_size;\n+      int max_count = (ReservedCodeCacheSize - (int)CompilerConfig::min_code_cache_size()) \/ (int)buffer_size;\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -478,2 +478,1 @@\n-  \/\/ Template Interpreter code is approximately 3X larger in debug builds.\n-  uint min_code_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3);\n+  size_t min_code_cache_size = CompilerConfig::min_code_cache_size();\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -151,0 +151,2 @@\n+  inline static size_t min_code_cache_size();\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,6 @@\n+#ifdef COMPILER1\n+#include \"c1\/c1_Compiler.hpp\"\n+#endif\n+#ifdef COMPILER2\n+#include \"opto\/c2compiler.hpp\"\n+#endif\n@@ -135,0 +141,9 @@\n+inline size_t CompilerConfig::min_code_cache_size() {\n+  size_t min_code_cache_size = CodeCacheMinimumUseSpace;\n+  \/\/ Template Interpreter code is approximately 3X larger in debug builds.\n+  DEBUG_ONLY(min_code_cache_size *= 3);\n+  COMPILER1_PRESENT(min_code_cache_size += Compiler::code_buffer_size());\n+  COMPILER2_PRESENT(min_code_cache_size += C2Compiler::initial_code_buffer_size());\n+  return min_code_cache_size;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.inline.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -788,7 +789,7 @@\n-#ifdef STATIC_BUILD\n-  char* p = strrchr(buf, '\/');\n-  *p = '\\0';\n-  strcat(p, \"\/lib\/\");\n-  lib_offset = jvm_offset = (int)strlen(buf);\n-#else\n-  {\n+\n+  if (is_vm_statically_linked()) {\n+    char* p = strrchr(buf, '\/');\n+    *p = '\\0';\n+    strcat(p, \"\/lib\/\");\n+    lib_offset = jvm_offset = (int)strlen(buf);\n+  } else {\n@@ -808,1 +809,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n@@ -45,0 +47,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -51,0 +54,1 @@\n+PartialArrayStateAllocator*    PSPromotionManager::_partial_array_state_allocator = nullptr;\n@@ -65,0 +69,4 @@\n+  assert(_partial_array_state_allocator == nullptr, \"Attempt to initialize twice\");\n+  _partial_array_state_allocator\n+    = new PartialArrayStateAllocator(ParallelGCThreads);\n+\n@@ -70,0 +78,1 @@\n+    _manager_array[i]._partial_array_state_allocator_index = i;\n@@ -127,0 +136,4 @@\n+  \/\/ All PartialArrayStates have been returned to the allocator, since the\n+  \/\/ claimed_stack_depths are all empty.  Leave them there for use by future\n+  \/\/ collections.\n+\n@@ -175,1 +188,4 @@\n-PSPromotionManager::PSPromotionManager() {\n+\/\/ Most members are initialized either by initialize() or reset().\n+PSPromotionManager::PSPromotionManager()\n+  : _partial_array_stepper(ParallelGCThreads, ParGCArrayScanChunk)\n+{\n@@ -185,1 +201,3 @@\n-  _array_chunk_size = ParGCArrayScanChunk;\n+  \/\/ Initialize to a bad value; fixed by initialize().\n+  _partial_array_state_allocator_index = UINT_MAX;\n+\n@@ -187,1 +205,1 @@\n-  _min_array_size_for_chunking = 3 * _array_chunk_size \/ 2;\n+  _min_array_size_for_chunking = (3 * ParGCArrayScanChunk \/ 2);\n@@ -280,7 +298,1 @@\n-void PSPromotionManager::process_array_chunk(PartialArrayScanTask task) {\n-  assert(PSChunkLargeArrays, \"invariant\");\n-\n-  oop old = task.to_source_array();\n-  assert(old->is_objArray(), \"invariant\");\n-  assert(old->is_forwarded(), \"invariant\");\n-\n+void PSPromotionManager::process_array_chunk(PartialArrayState* state) {\n@@ -289,11 +301,15 @@\n-  oop const obj = old->forwardee();\n-\n-  int start;\n-  int const end = arrayOop(old)->length();\n-  if (end > (int) _min_array_size_for_chunking) {\n-    \/\/ we'll chunk more\n-    start = end - _array_chunk_size;\n-    assert(start > 0, \"invariant\");\n-    arrayOop(old)->set_length(start);\n-    push_depth(ScannerTask(PartialArrayScanTask(old)));\n-    TASKQUEUE_STATS_ONLY(++_array_chunk_pushes);\n+  \/\/ Claim a chunk.  Push additional tasks before processing the claimed\n+  \/\/ chunk to allow other workers to steal while we're processing.\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n+  if (step._ncreate > 0) {\n+    state->add_references(step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push_depth(ScannerTask(state));\n+    }\n+    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n+  }\n+  int start = checked_cast<int>(step._index);\n+  int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n+  assert(start < end, \"invariant\");\n+  if (UseCompressedOops) {\n+    process_array_chunk_work<narrowOop>(state->destination(), start, end);\n@@ -301,4 +317,1 @@\n-    \/\/ this is the final chunk for this array\n-    start = 0;\n-    int const actual_length = arrayOop(obj)->length();\n-    arrayOop(old)->set_length(actual_length);\n+    process_array_chunk_work<oop>(state->destination(), start, end);\n@@ -306,0 +319,3 @@\n+  \/\/ Release reference to state, now that we're done with it.\n+  _partial_array_state_allocator->release(_partial_array_state_allocator_index, state);\n+}\n@@ -307,0 +323,22 @@\n+void PSPromotionManager::push_objArray(oop old_obj, oop new_obj) {\n+  assert(old_obj->is_objArray(), \"precondition\");\n+  assert(old_obj->is_forwarded(), \"precondition\");\n+  assert(old_obj->forwardee() == new_obj, \"precondition\");\n+  assert(new_obj->is_objArray(), \"precondition\");\n+\n+  size_t array_length = objArrayOop(new_obj)->length();\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n+\n+  if (step._ncreate > 0) {\n+    TASKQUEUE_STATS_ONLY(++_arrays_chunked);\n+    PartialArrayState* state =\n+      _partial_array_state_allocator->allocate(_partial_array_state_allocator_index,\n+                                               old_obj, new_obj,\n+                                               step._index,\n+                                               array_length,\n+                                               step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push_depth(ScannerTask(state));\n+    }\n+    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n+  }\n@@ -308,1 +346,1 @@\n-    process_array_chunk_work<narrowOop>(obj, start, end);\n+    process_array_chunk_work<narrowOop>(new_obj, 0, checked_cast<int>(step._index));\n@@ -310,1 +348,1 @@\n-    process_array_chunk_work<oop>(obj, start, end);\n+    process_array_chunk_work<oop>(new_obj, 0, checked_cast<int>(step._index));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":66,"deletions":28,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n@@ -52,0 +53,2 @@\n+class PartialArrayState;\n+class PartialArrayStateAllocator;\n@@ -88,1 +91,3 @@\n-  uint                                _array_chunk_size;\n+  static PartialArrayStateAllocator*  _partial_array_state_allocator;\n+  PartialArrayTaskStepper             _partial_array_stepper;\n+  uint                                _partial_array_state_allocator_index;\n@@ -104,1 +109,2 @@\n-  void process_array_chunk(PartialArrayScanTask task);\n+  void process_array_chunk(PartialArrayState* state);\n+  void push_objArray(oop old_obj, oop new_obj);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -279,3 +279,1 @@\n-      \/\/ we'll chunk it\n-      push_depth(ScannerTask(PartialArrayScanTask(o)));\n-      TASKQUEUE_STATS_ONLY(++_arrays_chunked; ++_array_chunk_pushes);\n+      push_objArray(o, new_obj);\n@@ -325,1 +323,1 @@\n-  if (task.is_partial_array_task()) {\n+  if (task.is_partial_array_state()) {\n@@ -327,1 +325,1 @@\n-    process_array_chunk(task.to_partial_array_task());\n+    process_array_chunk(task.to_partial_array_state());\n@@ -344,1 +342,1 @@\n-  if (task.is_partial_array_task()) {\n+  if (task.is_partial_array_state()) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -41,0 +42,21 @@\n+\/\/ GCLockerTimingDebugLogger tracks specific timing information for GC lock waits.\n+class GCLockerTimingDebugLogger : public StackObj {\n+  const char* _log_message;\n+  Ticks _start;\n+\n+public:\n+  GCLockerTimingDebugLogger(const char* log_message) : _log_message(log_message) {\n+    assert(_log_message != nullptr, \"GC locker debug message must be set.\");\n+    _start = Ticks::now();\n+  }\n+\n+  ~GCLockerTimingDebugLogger() {\n+    Log(gc, jni) log;\n+    if (log.is_debug()) {\n+      ResourceMark rm; \/\/ JavaThread::name() allocates to convert to UTF8\n+      const Tickspan elapsed_time = Ticks::now() - _start;\n+      log.debug(\"%s Resumed after \" UINT64_FORMAT \"ms. Thread \\\"%s\\\".\", _log_message, elapsed_time.milliseconds(), Thread::current()->name());\n+    }\n+  }\n+};\n+\n@@ -113,5 +135,5 @@\n-  }\n-\n-  \/\/ Wait for _needs_gc  to be cleared\n-  while (needs_gc()) {\n-    ml.wait();\n+    GCLockerTimingDebugLogger logger(\"Thread stalled by JNI critical section.\");\n+    \/\/ Wait for _needs_gc to be cleared\n+    while (needs_gc()) {\n+      ml.wait();\n+    }\n@@ -130,10 +152,14 @@\n-  while (needs_gc()) {\n-    \/\/ There's at least one thread that has not left the critical region (CR)\n-    \/\/ completely. When that last thread (no new threads can enter CR due to the\n-    \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n-    \/\/ to false and wakes up all blocked threads.\n-    \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n-    \/\/ in the code, but it's too strong; it's possible that the last thread\n-    \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n-    \/\/ a GCCause::_gc_locker GC.\n-    ml.wait();\n+  if (needs_gc()) {\n+    log_debug_jni(\"Blocking thread as there is a pending GC request\");\n+    GCLockerTimingDebugLogger logger(\"Thread blocked to enter critical region.\");\n+    while (needs_gc()) {\n+      \/\/ There's at least one thread that has not left the critical region (CR)\n+      \/\/ completely. When that last thread (no new threads can enter CR due to the\n+      \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n+      \/\/ to false and wakes up all blocked threads.\n+      \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n+      \/\/ in the code, but it's too strong; it's possible that the last thread\n+      \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n+      \/\/ a GCCause::_gc_locker GC.\n+      ml.wait();\n+    }\n@@ -151,0 +177,1 @@\n+  log_debug_jni(\"Thread exiting critical region.\");\n@@ -164,1 +191,1 @@\n-      log_debug_jni(\"Performing GC after exiting critical section.\");\n+      log_debug_jni(\"Last thread exiting. Performing GC after exiting critical section.\");\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":43,"deletions":16,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -112,1 +113,1 @@\n-class PartialArrayStateAllocator {\n+class PartialArrayStateAllocator : public CHeapObj<mtGC> {\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -576,14 +576,0 @@\n-\/\/ Wrapper over an oop that is a partially scanned array.\n-\/\/ Can be converted to a ScannerTask for placement in associated task queues.\n-\/\/ Refers to the partially copied source array oop.\n-\/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n-class PartialArrayScanTask {\n-  oop _src;\n-\n-public:\n-  explicit PartialArrayScanTask(oop src_array) : _src(src_array) {}\n-  \/\/ Trivially copyable.\n-\n-  oop to_source_array() const { return _src; }\n-};\n-\n@@ -630,4 +616,0 @@\n-  \/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n-  explicit ScannerTask(PartialArrayScanTask t) :\n-    _p(encode(t.to_source_array(), PartialArrayTag)) {}\n-\n@@ -649,5 +631,0 @@\n-  \/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n-  bool is_partial_array_task() const {\n-    return (raw_value() & PartialArrayTag) != 0;\n-  }\n-\n@@ -666,5 +643,0 @@\n-  \/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n-  PartialArrayScanTask to_partial_array_task() const {\n-    return PartialArrayScanTask(cast_to_oop(decode(PartialArrayTag)));\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -183,0 +183,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsStaticallyLinked(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,1 +295,1 @@\n-    const size_t length = static_cast<size_t>(java_lang_String::utf8_length(string, value)) + 1;\n+    const size_t length = java_lang_String::utf8_length(string, value) + 1;\n@@ -298,1 +298,1 @@\n-    java_lang_String::as_utf8_string(string, value, str, static_cast<int>(length));\n+    java_lang_String::as_utf8_string(string, value, str, length);\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -505,1 +505,1 @@\n-static char* allocate_string(bool c_heap, int length, Thread* thread) {\n+static char* allocate_string(bool c_heap, size_t length, Thread* thread) {\n@@ -514,1 +514,1 @@\n-    const int length = java_lang_String::utf8_length(string, value);\n+    const size_t length = java_lang_String::utf8_length(string, value);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-jboolean JNICALL jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size);\n+void JNICALL jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,4 @@\n-  return name != nullptr ? java_lang_String::as_utf8_string(name, length) : nullptr;\n+  size_t utf8_len;\n+  const char* ret = name != nullptr ? java_lang_String::as_utf8_string(name, utf8_len) : nullptr;\n+  length = checked_cast<int>(utf8_len); \/\/ Thread names should be short\n+  return ret;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadState.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -29,2 +29,1 @@\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/klass.hpp\"\n@@ -203,1 +202,1 @@\n-  return mark((uintptr_t)sym->identity_hash(), sym, leakp);\n+  return mark(sym->identity_hash(), sym, leakp);\n@@ -239,35 +238,8 @@\n-* hidden classes symbol is the external name +\n-* the address of its InstanceKlass slash appended:\n-*   java.lang.invoke.LambdaForm$BMH\/22626602\n-*\n-* caller needs ResourceMark\n-*\/\n-\n-uintptr_t JfrSymbolTable::hidden_klass_name_hash(const InstanceKlass* ik) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != nullptr, \"invariant\");\n-  return (uintptr_t)mirror->identity_hash();\n-}\n-\n-static const char* create_hidden_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  assert(hash != 0, \"invariant\");\n-  char* hidden_symbol = nullptr;\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != nullptr, \"invariant\");\n-  char hash_buf[40];\n-  os::snprintf_checked(hash_buf, sizeof(hash_buf), \"\/\" UINTX_FORMAT, hash);\n-  const size_t hash_len = strlen(hash_buf);\n-  const size_t result_len = ik->name()->utf8_length();\n-  hidden_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n-  ik->name()->as_klass_external_name(hidden_symbol, (int)result_len + 1);\n-  assert(strlen(hidden_symbol) == result_len, \"invariant\");\n-  strcpy(hidden_symbol + result_len, hash_buf);\n-  assert(strlen(hidden_symbol) == result_len + hash_len, \"invariant\");\n-  return hidden_symbol;\n-}\n-\n-bool JfrSymbolTable::is_hidden_klass(const Klass* k) {\n+ * The hidden class symbol is the external name with the\n+ * address of its Klass slash appended.\n+ *\n+ * \"java.lang.invoke.LambdaForm$DMH\/0x0000000037144c00\"\n+ *\n+ * Caller needs ResourceMark.\n+ *\/\n+traceid JfrSymbolTable::mark_hidden_klass_name(const Klass* k, bool leakp) {\n@@ -275,9 +247,3 @@\n-  return k->is_instance_klass() && ((const InstanceKlass*)k)->is_hidden();\n-}\n-\n-traceid JfrSymbolTable::mark_hidden_klass_name(const InstanceKlass* ik, bool leakp) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const uintptr_t hash = hidden_klass_name_hash(ik);\n-  const char* const hidden_symbol = create_hidden_klass_symbol(ik, hash);\n-  return mark(hash, hidden_symbol, leakp);\n+  assert(k->is_hidden(), \"invariant\");\n+  const uintptr_t hash = k->name()->identity_hash();\n+  return mark(hash, k->external_name(), leakp);\n@@ -289,3 +255,2 @@\n-  if (is_hidden_klass(k)) {\n-    assert(k->is_instance_klass(), \"invariant\");\n-    symbol_id = mark_hidden_klass_name((const InstanceKlass*)k, leakp);\n+  if (k->is_hidden()) {\n+    symbol_id = mark_hidden_klass_name(k, leakp);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.cpp","additions":17,"deletions":52,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,1 @@\n+  traceid mark_hidden_klass_name(const Klass* k, bool leakp);\n@@ -109,4 +110,0 @@\n-  traceid mark_hidden_klass_name(const InstanceKlass* k, bool leakp);\n-  bool is_hidden_klass(const Klass* k);\n-  uintptr_t hidden_klass_name_hash(const InstanceKlass* ik);\n-\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size, bool is_class) {\n+void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size) {\n@@ -135,1 +135,2 @@\n-  if (Metaspace::using_class_space() && is_class) {\n+  const bool is_class = Metaspace::using_class_space() && Metaspace::is_in_class_space(ptr);\n+  if (is_class) {\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-  void deallocate(MetaWord* ptr, size_t word_size, bool is_class);\n+  void deallocate(MetaWord* ptr, size_t word_size);\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-      loader_data->metaspace_non_null()->deallocate((MetaWord*)data, size, false);\n+      loader_data->metaspace_non_null()->deallocate((MetaWord*)data, size);\n@@ -71,1 +71,0 @@\n-      bool is_klass = md->is_klass();\n@@ -79,1 +78,1 @@\n-      loader_data->metaspace_non_null()->deallocate((MetaWord*)md, size, is_klass);\n+      loader_data->metaspace_non_null()->deallocate((MetaWord*)md, size);\n","filename":"src\/hotspot\/share\/memory\/metadataFactory.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -541,0 +541,2 @@\n+const void* Metaspace::_class_space_start = nullptr;\n+const void* Metaspace::_class_space_end = nullptr;\n@@ -573,0 +575,2 @@\n+  _class_space_start = rs.base();\n+  _class_space_end = rs.end();\n@@ -982,6 +986,0 @@\n-bool Metaspace::contains(const void* ptr) {\n-  if (MetaspaceShared::is_in_shared_metaspace(ptr)) {\n-    return true;\n-  }\n-  return contains_non_shared(ptr);\n-}\n@@ -989,4 +987,5 @@\n-bool Metaspace::contains_non_shared(const void* ptr) {\n-  if (using_class_space() && VirtualSpaceList::vslist_class()->contains((MetaWord*)ptr)) {\n-     return true;\n-  }\n+\/\/ Returns true if pointer points into one of the metaspace regions, or\n+\/\/ into the class space.\n+bool Metaspace::is_in_shared_metaspace(const void* ptr) {\n+  return MetaspaceShared::is_in_shared_metaspace(ptr);\n+}\n@@ -994,0 +993,2 @@\n+\/\/ Returns true if pointer points into one of the non-class-space metaspace regions.\n+bool Metaspace::is_in_nonclass_metaspace(const void* ptr) {\n@@ -996,0 +997,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,4 @@\n+  \/\/ For quick pointer testing: extent of class space; nullptr if no class space.\n+  static const void* _class_space_start;\n+  static const void* _class_space_end;\n+\n@@ -116,2 +120,26 @@\n-  static bool contains(const void* ptr);\n-  static bool contains_non_shared(const void* ptr);\n+  \/\/ Returns true if the pointer points into class space, non-class metaspace, or the\n+  \/\/ metadata portion of the CDS archive.\n+  static bool contains(const void* ptr) {\n+    return is_in_shared_metaspace(ptr) || \/\/ in cds\n+           is_in_class_space(ptr) ||      \/\/ in class space\n+           is_in_nonclass_metaspace(ptr); \/\/ in one of the non-class regions?\n+  }\n+\n+  \/\/ Returns true if the pointer points into class space or into non-class metaspace\n+  static bool contains_non_shared(const void* ptr) {\n+    return is_in_class_space(ptr) ||      \/\/ in class space\n+           is_in_nonclass_metaspace(ptr); \/\/ in one of the non-class regions?\n+  }\n+\n+  \/\/ Returns true if pointer points into the CDS klass region.\n+  static bool is_in_shared_metaspace(const void* ptr);\n+\n+  \/\/ Returns true if pointer points into one of the non-class-space metaspace regions.\n+  static bool is_in_nonclass_metaspace(const void* ptr);\n+\n+  \/\/ Returns true if pointer points into class space, false if it doesn't or if\n+  \/\/ there is no class space. Class space is a contiguous region, which is why\n+  \/\/ two address comparisons are enough.\n+  static inline bool is_in_class_space(const void* ptr) {\n+    return ptr < _class_space_end && ptr >= _class_space_start;\n+  }\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include <limits>\n@@ -44,8 +45,1 @@\n-  struct StackIndex {\n-    friend NativeCallStackStorage;\n-    int32_t _stack_index;\n-  public:\n-    static constexpr const int32_t invalid = -1;\n-    static bool equals(const StackIndex& a, const StackIndex& b) {\n-      return a._stack_index == b._stack_index;\n-    }\n+  using StackIndex = int;\n@@ -53,4 +47,11 @@\n-    bool is_invalid() {\n-      return _stack_index == invalid;\n-    }\n-  };\n+private:\n+  constexpr static const StackIndex invalid = std::numeric_limits<StackIndex>::max() - 1;\n+\n+public:\n+  static bool equals(const StackIndex a, const StackIndex b) {\n+    return a == b;\n+  }\n+\n+  static bool is_invalid(StackIndex a) {\n+    return a == invalid;\n+  }\n@@ -86,1 +87,1 @@\n-      return StackIndex{StackIndex::invalid};\n+      return invalid;\n@@ -92,1 +93,1 @@\n-    if (si._stack_index == -1) {\n+    if (is_invalid(si)) {\n@@ -95,1 +96,1 @@\n-    return _stacks.at(si._stack_index);\n+    return _stacks.at(si);\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-             NativeCallStackStorage::StackIndex::equals(a.stack_idx, b.stack_idx);\n+             NativeCallStackStorage::equals(a.stack_idx, b.stack_idx);\n@@ -115,1 +115,1 @@\n-    const NativeCallStackStorage::StackIndex stack() const {\n+    NativeCallStackStorage::StackIndex stack() const {\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-    f.print_value_on(_st, nullptr);\n+    f.print_value_on(_st);\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  int quoted_length = UTF8::quoted_ascii_length(ptr, utf8_length());\n+  size_t quoted_length = UTF8::quoted_ascii_length(ptr, utf8_length());\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -318,1 +318,3 @@\n-      double min_freq = MAX2(MinInlineFrequencyRatio, 1.0 \/ CompilationPolicy::min_invocations());\n+      \/\/ avoid division by 0, set divisor to at least 1\n+      int cp_min_inv = MAX2(1, CompilationPolicy::min_invocations());\n+      double min_freq = MAX2(MinInlineFrequencyRatio, 1.0 \/ cp_min_inv);\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1312,13 +1312,0 @@\n-Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {\n-  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n-  register_new_node(castii, ctrl);\n-  for (DUIterator_Fast imax, i = incr->fast_outs(imax); i < imax; i++) {\n-    Node* n = incr->fast_out(i);\n-    if (n->is_Phi() && n->in(0) == loop) {\n-      int nrep = n->replace_edge(incr, castii, &_igvn);\n-      return castii;\n-    }\n-  }\n-  return nullptr;\n-}\n-\n@@ -1683,3 +1670,0 @@\n-  \/\/ CastII for the main loop:\n-  Node* castii = cast_incr_before_loop(pre_incr, min_taken, main_head);\n-  assert(castii != nullptr, \"no castII inserted\");\n@@ -1687,1 +1671,1 @@\n-  copy_assertion_predicates_to_main_loop(pre_head, castii, stride, outer_loop, outer_main_head, dd_main_head,\n+  copy_assertion_predicates_to_main_loop(pre_head, pre_incr, stride, outer_loop, outer_main_head, dd_main_head,\n@@ -1690,1 +1674,1 @@\n-  copy_assertion_predicates_to_post_loop(outer_main_head, post_head, post_incr, stride);\n+  copy_assertion_predicates_to_post_loop(outer_main_head, post_head, stride);\n@@ -1815,1 +1799,1 @@\n-  copy_assertion_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n+  copy_assertion_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, main_head->stride());\n@@ -1918,4 +1902,0 @@\n-  \/\/ CastII for the new post loop:\n-  incr = cast_incr_before_loop(zer_opaq->in(1), zer_taken, post_head);\n-  assert(incr != nullptr, \"no castII inserted\");\n-\n@@ -1937,6 +1917,0 @@\n-  if (init->is_CastII()) {\n-    \/\/ skip over the cast added by PhaseIdealLoop::cast_incr_before_loop() when pre\/post\/main loops are created because\n-    \/\/ it can get in the way of type propagation\n-    assert(init->as_CastII()->carry_dependency() && loop_head->skip_assertion_predicates_with_halt() == init->in(0), \"casted iv phi from pre loop expected\");\n-    init = init->in(1);\n-  }\n@@ -1991,1 +1965,3 @@\n-                                                            Node* init, Node* stride) {\n+                                                            Node* stride) {\n+  Node* opaq = post_loop_head->is_canonical_loop_entry();\n+  Node* init = opaq->in(1);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":6,"deletions":30,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -941,2 +941,0 @@\n-  Node* cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop);\n-\n@@ -963,1 +961,1 @@\n-  void copy_assertion_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init,\n+  void copy_assertion_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head,\n@@ -1537,0 +1535,2 @@\n+  bool split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1092,0 +1092,19 @@\n+\/\/ Split some nodes that take a counted loop phi as input at a counted\n+\/\/ loop can cause vectorization of some expressions to fail\n+bool PhaseIdealLoop::split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk) {\n+  if (!n_blk->is_CountedLoop()) {\n+    return false;\n+  }\n+\n+  int opcode = n->Opcode();\n+\n+  if (opcode != Op_AndI &&\n+      opcode != Op_MulI &&\n+      opcode != Op_RotateRight &&\n+      opcode != Op_RShiftI) {\n+    return false;\n+  }\n+\n+  return n->in(1) == n_blk->as_BaseCountedLoop()->phi();\n+}\n+\n@@ -1178,0 +1197,4 @@\n+  if (split_thru_phi_could_prevent_vectorization(n, n_blk)) {\n+    return n;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1626,17 +1626,0 @@\n-  \/\/ Change ((x & m) u<= m) or ((m & x) u<= m) to always true\n-  \/\/ Same with ((x & m) u< m+1) and ((m & x) u< m+1)\n-  if (cop == Op_CmpU &&\n-      cmp1_op == Op_AndI) {\n-    Node* bound = nullptr;\n-    if (_test._test == BoolTest::le) {\n-      bound = cmp2;\n-    } else if (_test._test == BoolTest::lt &&\n-               cmp2->Opcode() == Op_AddI &&\n-               cmp2->in(2)->find_int_con(0) == 1) {\n-      bound = cmp2->in(1);\n-    }\n-    if (cmp1->in(2) == bound || cmp1->in(1) == bound) {\n-      return ConINode::make(1);\n-    }\n-  }\n-\n@@ -1644,1 +1627,1 @@\n-  \/\/ This is the off-by-one variant of the above\n+  \/\/ This is the off-by-one variant of ((x & m) u<= m)\n@@ -1830,0 +1813,25 @@\n+\/\/ Change ((x & m) u<= m) or ((m & x) u<= m) to always true\n+\/\/ Same with ((x & m) u< m+1) and ((m & x) u< m+1)\n+const Type* BoolNode::Value_cmpu_and_mask(PhaseValues* phase) const {\n+  Node* cmp = in(1);\n+  if (cmp != nullptr && cmp->Opcode() == Op_CmpU) {\n+    Node* cmp1 = cmp->in(1);\n+    Node* cmp2 = cmp->in(2);\n+\n+    if (cmp1->Opcode() == Op_AndI) {\n+      Node* bound = nullptr;\n+      if (_test._test == BoolTest::le) {\n+        bound = cmp2;\n+      } else if (_test._test == BoolTest::lt && cmp2->Opcode() == Op_AddI && cmp2->in(2)->find_int_con(0) == 1) {\n+        bound = cmp2->in(1);\n+      }\n+\n+      if (cmp1->in(2) == bound || cmp1->in(1) == bound) {\n+        return TypeInt::ONE;\n+      }\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n@@ -1833,0 +1841,5 @@\n+  const Type* t = Value_cmpu_and_mask(phase);\n+  if (t != nullptr) {\n+    return t;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":32,"deletions":19,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -350,0 +350,1 @@\n+  const Type* Value_cmpu_and_mask(PhaseValues* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2226,1 +2226,1 @@\n-  jsize ret = java_lang_String::utf8_length(java_string);\n+  jsize ret = java_lang_String::utf8_length_as_int(java_string);\n@@ -2239,1 +2239,2 @@\n-    \/* JNI Specification states return null on OOM *\/\n+    \/\/ JNI Specification states return null on OOM.\n+    \/\/ The resulting sequence doesn't have to be NUL-terminated but we do.\n@@ -2242,1 +2243,1 @@\n-      java_lang_String::as_utf8_string(java_string, s_value, result, (int) length + 1);\n+      java_lang_String::as_utf8_string(java_string, s_value, result, length + 1);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3451,0 +3451,4 @@\n+JVM_ENTRY_NO_ENV(jboolean, JVM_IsStaticallyLinked(void))\n+  return is_vm_statically_linked() ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1324,1 +1324,1 @@\n-      int utf8_length = 0;\n+      size_t utf8_length = 0;\n@@ -2537,0 +2537,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2549,0 +2550,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2561,0 +2563,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2573,0 +2576,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -985,2 +985,0 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2585,1 +2585,1 @@\n-      current_frame->print_value_on(&st, nullptr);\n+      current_frame->print_value_on(&st);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -880,1 +880,1 @@\n-    f.print_value_on(&ls, nullptr);\n+    f.print_value_on(&ls);\n@@ -889,1 +889,1 @@\n-    DEBUG_ONLY(hf.print_value_on(&ls, nullptr);)\n+    DEBUG_ONLY(hf.print_value_on(&ls);)\n@@ -2030,1 +2030,1 @@\n-    heap_frame.print_value_on(&ls, nullptr);\n+    heap_frame.print_value_on(&ls);\n@@ -2127,1 +2127,1 @@\n-    hf.print_value_on(&ls, nullptr);\n+    hf.print_value_on(&ls);\n@@ -2397,1 +2397,1 @@\n-    _cont.last_frame().print_value_on(&ls, nullptr);\n+    _cont.last_frame().print_value_on(&ls);\n@@ -2409,1 +2409,1 @@\n-    f.print_value_on(&ls, nullptr);\n+    f.print_value_on(&ls);\n@@ -2470,1 +2470,1 @@\n-    frame(sp).print_value_on(&ls, nullptr);\n+    frame(sp).print_value_on(&ls);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -514,1 +514,1 @@\n-void frame::print_value_on(outputStream* st, JavaThread *thread) const {\n+void frame::print_value_on(outputStream* st) const {\n@@ -553,1 +553,1 @@\n-  print_value_on(st,nullptr);\n+  print_value_on(st);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -436,2 +436,2 @@\n-  void print_value() const { print_value_on(tty,nullptr); }\n-  void print_value_on(outputStream* st, JavaThread *thread) const;\n+  void print_value() const { print_value_on(tty); }\n+  void print_value_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,3 @@\n+\/\/ This is defined in linkType.cpp due to linking restraints\n+extern bool is_vm_statically_linked();\n+\n","filename":"src\/hotspot\/share\/runtime\/java.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1909,1 +1909,1 @@\n-    fst.current()->print_value_on(tty, this);\n+    fst.current()->print_value_on(tty);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/java.hpp\"\n+\n+\/\/ This is in a separate file since it will need to be compiled to two different\n+\/\/ object files, depending on if we are going to build a static or a dynamic\n+\/\/ library.\n+\n+bool is_vm_statically_linked(void) {\n+#ifdef STATIC_BUILD\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n","filename":"src\/hotspot\/share\/runtime\/linkType.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -270,1 +270,1 @@\n-  MUTEX_DEFN(JvmtiThreadState_lock           , PaddedMutex  , safepoint);   \/\/ Used by JvmtiThreadState\/JvmtiEventController\n+  MUTEX_DEFN(JvmtiVTMSTransition_lock        , PaddedMonitor, safepoint);   \/\/ used for Virtual Thread Mount State transition management\n@@ -357,1 +357,1 @@\n-  MUTEX_DEFL(JvmtiVTMSTransition_lock        , PaddedMonitor, JvmtiThreadState_lock); \/\/ used for Virtual Thread Mount State transition management\n+  MUTEX_DEFL(JvmtiThreadState_lock          , PaddedMutex  , JvmtiVTMSTransition_lock);   \/\/ Used by JvmtiThreadState\/JvmtiEventController\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1019,1 +1019,1 @@\n-                        bool print_ascii, int bytes_per_line, const_address logical_start) {\n+                        bool print_ascii, int bytes_per_line, const_address logical_start, const_address highlight_address) {\n@@ -1024,0 +1024,3 @@\n+  assert(highlight_address == nullptr || (highlight_address >= start && highlight_address < end),\n+         \"address %p to highlight not in range %p - %p\", highlight_address, start, end);\n+\n@@ -1040,1 +1043,5 @@\n-      st->print(PTR_FORMAT \":   \", p2i(logical_p));\n+      \/\/ highlight start of line if address of interest is located in the line\n+      const bool should_highlight = (highlight_address >= p && highlight_address < p + bytes_per_line);\n+      const char* const prefix =\n+        (highlight_address != nullptr) ? (should_highlight ? \"=>\" : \"  \") : \"\";\n+      st->print(\"%s\" PTR_FORMAT \":   \", prefix, p2i(logical_p));\n@@ -1085,1 +1092,1 @@\n-  print_hex_dump(st, pc - 256, pc + 256, unitsize, \/* print_ascii=*\/false);\n+  print_hex_dump(st, pc - 256, pc + 256, unitsize, \/* print_ascii=*\/false, pc);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -860,3 +860,3 @@\n-                             int bytes_per_line, const_address logical_start);\n-  static void print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize, bool print_ascii = true) {\n-    print_hex_dump(st, start, end, unitsize, print_ascii, \/*bytes_per_line=*\/16, \/*logical_start=*\/start);\n+                             int bytes_per_line, const_address logical_start, const_address highlight_address = nullptr);\n+  static void print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize, bool print_ascii = true, const_address highlight_address = nullptr) {\n+    print_hex_dump(st, start, end, unitsize, print_ascii, \/*bytes_per_line=*\/16, \/*logical_start=*\/start, highlight_address);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -625,1 +625,1 @@\n-  if (WizardMode) _fr.print_value_on(output, nullptr);\n+  if (WizardMode) _fr.print_value_on(output);\n@@ -740,1 +740,1 @@\n-  _fr.print_value_on(output, nullptr);\n+  _fr.print_value_on(output);\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    const int length = java_lang_String::utf8_length(string, value);\n+    const size_t length = java_lang_String::utf8_length(string, value);\n","filename":"src\/hotspot\/share\/services\/finalizerService.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,1 +101,7 @@\n-\/\/ Count bytes of the form 10xxxxxx and deduct this count\n+\/\/ The number of unicode characters in a utf8 sequence can be easily\n+\/\/ determined by noting that bytes of the form 10xxxxxx are part of\n+\/\/ a 2 or 3-byte multi-byte sequence, all others are either characters\n+\/\/ themselves or else the start of a multi-byte character.\n+\n+\/\/ Calculate the unicode length of a utf8 string of known size\n+\/\/ by counting bytes of the form 10xxxxxx and deducting this count\n@@ -104,2 +110,2 @@\n-int UTF8::unicode_length(const char* str, int len, bool& is_latin1, bool& has_multibyte) {\n-  int num_chars = len;\n+int UTF8::unicode_length(const char* str, size_t len, bool& is_latin1, bool& has_multibyte) {\n+  size_t num_chars = len;\n@@ -109,1 +115,1 @@\n-  for (int i = 0; i < len; i++) {\n+  for (size_t i = 0; i < len; i++) {\n@@ -121,1 +127,1 @@\n-  return num_chars;\n+  return checked_cast<int>(num_chars);\n@@ -124,3 +130,3 @@\n-\/\/ Count bytes of the utf8 string except those in form\n-\/\/ 10xxxxxx which only appear in multibyte characters.\n-\/\/ The utf8 string must be in legal form and has been\n+\/\/ Calculate the unicode length of a nul-terminated utf8 string\n+\/\/ by counting bytes of the utf8 string except those in the form\n+\/\/ 10xxxxxx. The utf8 string must be in legal form and has been\n@@ -198,1 +204,1 @@\n-int UTF8::quoted_ascii_length(const char* utf8_str, int utf8_length) {\n+size_t UTF8::quoted_ascii_length(const char* utf8_str, size_t utf8_length) {\n@@ -201,1 +207,1 @@\n-  int result = 0;\n+  size_t result = 0;\n@@ -215,1 +221,1 @@\n-void UTF8::as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, int buflen) {\n+void UTF8::as_quoted_ascii(const char* utf8_str, size_t utf8_length, char* buf, size_t buflen) {\n@@ -251,1 +257,1 @@\n-  int length = ptr - quoted_ascii_str;\n+  size_t length = ptr - quoted_ascii_str;\n@@ -333,1 +339,1 @@\n-bool UTF8::is_legal_utf8(const unsigned char* buffer, int length,\n+bool UTF8::is_legal_utf8(const unsigned char* buffer, size_t length,\n@@ -335,3 +341,3 @@\n-  int i = 0;\n-  int count = length >> 2;\n-  for (int k=0; k<count; k++) {\n+  size_t i = 0;\n+  size_t count = length >> 2;\n+  for (size_t k = 0; k < count; k++) {\n@@ -408,1 +414,1 @@\n-void UTF8::truncate_to_legal_utf8(unsigned char* buffer, int length) {\n+void UTF8::truncate_to_legal_utf8(unsigned char* buffer, size_t length) {\n@@ -436,1 +442,1 @@\n-  for (int index = length - 2; index > 0; index--) {\n+  for (size_t index = length - 2; index > 0; index--) {\n@@ -444,1 +450,1 @@\n-        if ((index - 3) >= 0 &&\n+        if (index >= 3 &&\n@@ -473,1 +479,1 @@\n-int UNICODE::utf8_size(jchar c) {\n+size_t UNICODE::utf8_size(jchar c) {\n@@ -484,1 +490,1 @@\n-int UNICODE::utf8_size(jbyte c) {\n+size_t UNICODE::utf8_size(jbyte c) {\n@@ -497,1 +503,10 @@\n-int UNICODE::utf8_length(const T* base, int length) {\n+size_t UNICODE::utf8_length(const T* base, int length) {\n+  size_t result = 0;\n+  for (int index = 0; index < length; index++) {\n+    result += utf8_size(base[index]);\n+  }\n+  return result;\n+}\n+\n+template<typename T>\n+int UNICODE::utf8_length_as_int(const T* base, int length) {\n@@ -501,1 +516,4 @@\n-    int sz = utf8_size(c);\n+    size_t sz = utf8_size(c);\n+    \/\/ If the length is > INT_MAX-1 we truncate at a completed\n+    \/\/ modified-UTF8 encoding. This allows for +1 to be added\n+    \/\/ by the caller for NUL-termination, without overflow.\n@@ -511,2 +529,3 @@\n-char* UNICODE::as_utf8(const T* base, int& length) {\n-  int utf8_len = utf8_length(base, length);\n+char* UNICODE::as_utf8(const T* base, size_t& length) {\n+  \/\/ Incoming length must be <= INT_MAX\n+  size_t utf8_len = utf8_length(base, static_cast<int>(length));\n@@ -514,3 +533,3 @@\n-  char* result = as_utf8(base, length, (char*) buf, utf8_len + 1);\n-  assert((int) strlen(result) == utf8_len, \"length prediction must be correct\");\n-  \/\/ Set string length to uft8 length\n+  char* result = as_utf8(base, static_cast<int>(length), (char*) buf, utf8_len + 1);\n+  assert(strlen(result) == utf8_len, \"length prediction must be correct\");\n+  \/\/ Set outgoing string length to uft8 length\n@@ -521,1 +540,1 @@\n-char* UNICODE::as_utf8(const jchar* base, int length, char* buf, int buflen) {\n+char* UNICODE::as_utf8(const jchar* base, int length, char* buf, size_t buflen) {\n@@ -526,2 +545,3 @@\n-    buflen -= utf8_size(c);\n-    if (buflen <= 0) break; \/\/ string is truncated\n+    size_t sz = utf8_size(c);\n+    if (sz >= buflen) break; \/\/ string is truncated\n+    buflen -= sz;\n@@ -534,1 +554,1 @@\n-char* UNICODE::as_utf8(const jbyte* base, int length, char* buf, int buflen) {\n+char* UNICODE::as_utf8(const jbyte* base, int length, char* buf, size_t buflen) {\n@@ -539,1 +559,2 @@\n-    int sz = utf8_size(c);\n+    size_t sz = utf8_size(c);\n+    if (sz >= buflen) break; \/\/ string is truncated\n@@ -541,1 +562,0 @@\n-    if (buflen <= 0) break; \/\/ string is truncated\n@@ -546,0 +566,1 @@\n+      assert(sz == 2, \"must be!\");\n@@ -564,2 +585,2 @@\n-int UNICODE::quoted_ascii_length(const T* base, int length) {\n-  int result = 0;\n+size_t UNICODE::quoted_ascii_length(const T* base, int length) {\n+  size_t result = 0;\n@@ -579,1 +600,1 @@\n-void UNICODE::as_quoted_ascii(const T* base, int length, char* buf, int buflen) {\n+void UNICODE::as_quoted_ascii(const T* base, int length, char* buf, size_t buflen) {\n@@ -597,8 +618,10 @@\n-template int UNICODE::utf8_length(const jbyte* base, int length);\n-template int UNICODE::utf8_length(const jchar* base, int length);\n-template char* UNICODE::as_utf8(const jbyte* base, int& length);\n-template char* UNICODE::as_utf8(const jchar* base, int& length);\n-template int UNICODE::quoted_ascii_length<jbyte>(const jbyte* base, int length);\n-template int UNICODE::quoted_ascii_length<jchar>(const jchar* base, int length);\n-template void UNICODE::as_quoted_ascii<jbyte>(const jbyte* base, int length, char* buf, int buflen);\n-template void UNICODE::as_quoted_ascii<jchar>(const jchar* base, int length, char* buf, int buflen);\n+template size_t UNICODE::utf8_length(const jbyte* base, int length);\n+template size_t UNICODE::utf8_length(const jchar* base, int length);\n+template int UNICODE::utf8_length_as_int(const jbyte* base, int length);\n+template int UNICODE::utf8_length_as_int(const jchar* base, int length);\n+template char* UNICODE::as_utf8(const jbyte* base, size_t& length);\n+template char* UNICODE::as_utf8(const jchar* base, size_t& length);\n+template size_t UNICODE::quoted_ascii_length<jbyte>(const jbyte* base, int length);\n+template size_t UNICODE::quoted_ascii_length<jchar>(const jchar* base, int length);\n+template void UNICODE::as_quoted_ascii<jbyte>(const jbyte* base, int length, char* buf, size_t buflen);\n+template void UNICODE::as_quoted_ascii<jchar>(const jchar* base, int length, char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/utilities\/utf8.cpp","additions":68,"deletions":45,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -32,0 +32,39 @@\n+\/**\n+\n+String handling within Java and the VM requires a bit of explanation.\n+\n+Logically a java.lang.String is a sequence of 16-bit Unicode characters\n+encoded in UTF-16. In the past a String contained a Java char[] and so\n+could theoretically contain INT_MAX 16-bit characters. Then came JEP 254:\n+Compact Strings.\n+\n+With Compact Strings the Java char[] becomes a Java byte[], and that byte[]\n+contains either latin-1 characters all of which fit in 8-bits, or else each\n+pair of bytes represents a UTF-16 character. Consequently the maximum length\n+in characters of a latin-1 string is INT_MAX, whilst for non-latin-1 it is INT_MAX\/2.\n+\n+In the code below if we have latin-1 content then we treat the String's data\n+array as a jbyte[], else a jchar[]. The lengths of these arrays are specified\n+as an int value, with a nominal maximum of INT_MAX.\n+\n+The modified UTF-8 encoding specified for the VM, nominally encodes characters\n+in 1, 2, 3 or 6 bytes. The 6-byte representation is actually two 3-byte representations\n+for two UTF-16 characters forming a surrogate pair. If we are dealing with\n+a latin-1 string then each character will be encoded as either 1 or 2 bytes and so the\n+maximum UTF8 length is 2*INT_MAX. This can't be stored in an int so utf8 buffers must\n+use a size_t length. For non-latin-1 strings each UTF-16 character will encode as either\n+2 or 3 bytes, so the maximum UTF8 length in that case is 3 * INT_MAX\/2 i.e. 1.5*INT_MAX.\n+\n+The \"quoted ascii\" form of a unicode string is at worst 6 times longer than its\n+regular form, and so these lengths must always be size_t - though if we know we only\n+ever do this to symbols (or small symbol combinations) then we could use int.\n+\n+There is an additional assumption\/expectation that our UTF8 API's are never dealing with\n+invalid UTF8, and more generally that all UTF8 sequences could form valid Strings.\n+Consequently the Unicode length of a UTF8 sequence is assumed to always be representable\n+by an int. However, there are API's, such as JNI NewStringUTF, that do deal with such input\n+and could potentially have an unrepresentable string. The long standing position with JNI\n+is that the user must supply valid input so we do not try to account for these cases.\n+\n+*\/\n+\n@@ -44,1 +83,1 @@\n-  static int unicode_length(const char* utf8_str, int len) {\n+  static int unicode_length(const char* utf8_str, size_t len) {\n@@ -48,1 +87,1 @@\n-  static int unicode_length(const char* utf8_str, int len, bool& is_latin1, bool& has_multibyte);\n+  static int unicode_length(const char* utf8_str, size_t len, bool& is_latin1, bool& has_multibyte);\n@@ -54,1 +93,1 @@\n-  static int quoted_ascii_length(const char* utf8_str, int utf8_length);\n+  static size_t quoted_ascii_length(const char* utf8_str, size_t utf8_length);\n@@ -57,1 +96,1 @@\n-  static void as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, int buflen);\n+  static void as_quoted_ascii(const char* utf8_str, size_t utf8_length, char* buf, size_t buflen);\n@@ -85,1 +124,1 @@\n-  static bool   equal(const jbyte* base1, int length1, const jbyte* base2,int length2);\n+  static bool   equal(const jbyte* base1, int length1, const jbyte* base2, int length2);\n@@ -89,1 +128,1 @@\n-  static bool   is_legal_utf8(const unsigned char* buffer, int length,\n+  static bool   is_legal_utf8(const unsigned char* buffer, size_t length,\n@@ -91,1 +130,1 @@\n-  static void   truncate_to_legal_utf8(unsigned char* buffer, int length);\n+  static void   truncate_to_legal_utf8(unsigned char* buffer, size_t length);\n@@ -102,0 +141,6 @@\n+\n+  \/\/ returns the utf8 size of a unicode character\n+  \/\/ uses size_t for convenience in overflow checks\n+  static size_t utf8_size(jchar c);\n+  static size_t utf8_size(jbyte c);\n+\n@@ -109,4 +154,0 @@\n-  \/\/ returns the utf8 size of a unicode character\n-  static int utf8_size(jchar c);\n-  static int utf8_size(jbyte c);\n-\n@@ -114,1 +155,4 @@\n-  template<typename T> static int utf8_length(const T* base, int length);\n+  template<typename T> static size_t utf8_length(const T* base, int length);\n+\n+  \/\/ returns the utf8 length of a unicode string as an int - truncated if needed\n+  template<typename T> static int utf8_length_as_int(const T* base, int length);\n@@ -121,4 +165,4 @@\n-  \/\/ parameter is set to the length of the result utf8 string.\n-  template<typename T> static char* as_utf8(const T* base, int& length);\n-  static char* as_utf8(const jchar* base, int length, char* buf, int buflen);\n-  static char* as_utf8(const jbyte* base, int length, char* buf, int buflen);\n+  \/\/ parameter is set to the length of the resulting utf8 string.\n+  template<typename T> static char* as_utf8(const T* base, size_t& length);\n+  static char* as_utf8(const jchar* base, int length, char* buf, size_t buflen);\n+  static char* as_utf8(const jbyte* base, int length, char* buf, size_t buflen);\n@@ -127,1 +171,1 @@\n-  template<typename T> static int quoted_ascii_length(const T* base, int length);\n+  template<typename T> static size_t quoted_ascii_length(const T* base, int length);\n@@ -130,1 +174,1 @@\n-  template<typename T> static void as_quoted_ascii(const T* base, int length, char* buf, int buflen);\n+  template<typename T> static void as_quoted_ascii(const T* base, int length, char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/utilities\/utf8.hpp","additions":62,"deletions":18,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -125,1 +125,0 @@\n-        boolean adjustmentDone = false;\n@@ -127,0 +126,1 @@\n+        int lowestLimit = hostCpus;\n@@ -129,1 +129,2 @@\n-        while (limit == hostCpus && ((workingPath = workingPath.getParent()) != null)) {\n+        String lowestPath = origCgroupPath;\n+        while ((workingPath = workingPath.getParent()) != null) {\n@@ -132,1 +133,4 @@\n-            adjustmentDone = true;\n+            if (limit < lowestLimit) {\n+                lowestLimit = limit;\n+                lowestPath = workingPath.toString();\n+            }\n@@ -134,1 +138,1 @@\n-        if (adjustmentDone && limit == hostCpus) {\n+        if (lowestLimit == hostCpus) {\n@@ -137,0 +141,3 @@\n+        } else {\n+            \/\/ Adjust controller to lowest observed limit path\n+            cpu.setPath(lowestPath);\n@@ -147,1 +154,0 @@\n-        boolean adjustmentDone = false;\n@@ -149,1 +155,3 @@\n-        while (limit < 0 && ((workingPath = workingPath.getParent()) != null)) {\n+        long lowestLimit = limit < 0 ? physicalMemory : limit;\n+        String lowestPath = origCgroupPath;\n+        while ((workingPath = workingPath.getParent()) != null) {\n@@ -152,1 +160,4 @@\n-            adjustmentDone = true;\n+            if (limit > 0 && limit < lowestLimit) {\n+                lowestLimit = limit;\n+                lowestPath = workingPath.toString();\n+            }\n@@ -154,1 +165,4 @@\n-        if (adjustmentDone && limit < 0) {\n+        if (lowestLimit < physicalMemory) {\n+            \/\/ Found a lower limit, adjust controller to that path\n+            memory.setPath(lowestPath);\n+        } else {\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupUtil.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -431,3 +431,3 @@\n-#ifdef STATIC_BUILD\n-    return JNI_TRUE;\n-#else\n+    if (JLI_IsStaticallyLinked()) {\n+        return JNI_TRUE;\n+    }\n@@ -441,1 +441,0 @@\n-#endif\n@@ -454,10 +453,11 @@\n-#ifdef STATIC_BUILD\n-        char jvm_cfg[MAXPATHLEN];\n-        JLI_Snprintf(jvm_cfg, sizeof(jvm_cfg), \"%s\/lib\/jvm.cfg\", path);\n-        if (access(jvm_cfg, F_OK) == 0) {\n-            return JNI_TRUE;\n-        }\n-#else\n-        JLI_Snprintf(libjava, sizeof(libjava), \"%s\/lib\/\" JAVA_DLL, path);\n-        if (access(libjava, F_OK) == 0) {\n-            return JNI_TRUE;\n+        if (JLI_IsStaticallyLinked()) {\n+            char jvm_cfg[MAXPATHLEN];\n+            JLI_Snprintf(jvm_cfg, sizeof(jvm_cfg), \"%s\/lib\/jvm.cfg\", path);\n+            if (access(jvm_cfg, F_OK) == 0) {\n+                return JNI_TRUE;\n+            }\n+        } else {\n+            JLI_Snprintf(libjava, sizeof(libjava), \"%s\/lib\/\" JAVA_DLL, path);\n+            if (access(libjava, F_OK) == 0) {\n+                return JNI_TRUE;\n+            }\n@@ -465,1 +465,0 @@\n-#endif\n@@ -484,15 +483,17 @@\n-#ifdef STATIC_BUILD\n-    char jvm_cfg[MAXPATHLEN];\n-    char *p = NULL;\n-    strncpy(jvm_cfg, selfInfo.dli_fname, MAXPATHLEN);\n-    p = strrchr(jvm_cfg, '\/'); *p = '\\0';\n-    p = strrchr(jvm_cfg, '\/');\n-    if (strcmp(p, \"\/.\") == 0) {\n-      *p = '\\0';\n-      p = strrchr(jvm_cfg, '\/'); *p = '\\0';\n-    }\n-    else *p = '\\0';\n-    strncpy(path, jvm_cfg, pathsize);\n-    strncat(jvm_cfg, \"\/lib\/jvm.cfg\", MAXPATHLEN);\n-    if (access(jvm_cfg, F_OK) == 0) {\n-      return JNI_TRUE;\n+    if (JLI_IsStaticallyLinked()) {\n+        char jvm_cfg[MAXPATHLEN];\n+        char *p = NULL;\n+        strncpy(jvm_cfg, selfInfo.dli_fname, MAXPATHLEN);\n+        p = strrchr(jvm_cfg, '\/'); *p = '\\0';\n+        p = strrchr(jvm_cfg, '\/');\n+        if (strcmp(p, \"\/.\") == 0) {\n+            *p = '\\0';\n+            p = strrchr(jvm_cfg, '\/'); *p = '\\0';\n+        } else {\n+          *p = '\\0';\n+        }\n+        strncpy(path, jvm_cfg, pathsize);\n+        strncat(jvm_cfg, \"\/lib\/jvm.cfg\", MAXPATHLEN);\n+        if (access(jvm_cfg, F_OK) == 0) {\n+           return JNI_TRUE;\n+        }\n@@ -500,1 +501,0 @@\n-#endif\n@@ -552,5 +552,6 @@\n-#ifndef STATIC_BUILD\n-    libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);\n-#else\n-    libjvm = dlopen(NULL, RTLD_FIRST);\n-#endif\n+    if (!JLI_IsStaticallyLinked()) {\n+        libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);\n+    } else {\n+        libjvm = dlopen(NULL, RTLD_FIRST);\n+    }\n+\n@@ -606,2 +607,0 @@\n-\n-#ifdef STATIC_BUILD\n@@ -609,5 +608,6 @@\n-        fptr = (void *)&SetExecname;\n-#else\n-        int (*fptr)();\n-        fptr = (int (*)())dlsym(RTLD_DEFAULT, \"main\");\n-#endif\n+\n+        if (JLI_IsStaticallyLinked()) {\n+            fptr = (void *)&SetExecname;\n+        } else {\n+            fptr = dlsym(RTLD_DEFAULT, \"main\");\n+        }\n","filename":"src\/java.base\/macosx\/native\/libjli\/java_md_macosx.m","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2120,0 +2120,5 @@\n+     * <p> If a file with the generated name cannot be created by the\n+     * underlying platform, then an {@code IOException} will be thrown.\n+     * This could occur for example if the supplied prefix or suffix contains\n+     * one or more characters not supported by the underlying file system.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/io\/File.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -105,1 +105,3 @@\n-         * Different types of constant values may share the same type of entry.\n+         * Different types of constant values may share the same type of entry\n+         * because they have the same {@linkplain TypeKind##computational-type\n+         * computational type}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationValue.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-        if (opcode.kind() != Opcode.Kind.BRANCH || opcode.primaryTypeKind() == TypeKind.VoidType) {\n+        if (opcode.kind() != Opcode.Kind.BRANCH || opcode.primaryTypeKind() == TypeKind.VOID) {\n@@ -315,1 +315,1 @@\n-        if (opcode.kind() != Opcode.Kind.BRANCH || opcode.primaryTypeKind() == TypeKind.VoidType) {\n+        if (opcode.kind() != Opcode.Kind.BRANCH || opcode.primaryTypeKind() == TypeKind.VOID) {\n@@ -553,1 +553,2 @@\n-     * @throws IllegalArgumentException for conversions of {@code VoidType} or {@code ReferenceType}\n+     * @throws IllegalArgumentException for conversions of {@link TypeKind#VOID void} or\n+     *         {@link TypeKind#REFERENCE reference}\n@@ -557,73 +558,47 @@\n-        return switch (fromType) {\n-            case IntType, ByteType, CharType, ShortType, BooleanType ->\n-                    switch (toType) {\n-                        case IntType -> this;\n-                        case LongType -> i2l();\n-                        case DoubleType -> i2d();\n-                        case FloatType -> i2f();\n-                        case ByteType -> i2b();\n-                        case CharType -> i2c();\n-                        case ShortType -> i2s();\n-                        case BooleanType -> iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case LongType ->\n-                    switch (toType) {\n-                        case IntType -> l2i();\n-                        case LongType -> this;\n-                        case DoubleType -> l2d();\n-                        case FloatType -> l2f();\n-                        case ByteType -> l2i().i2b();\n-                        case CharType -> l2i().i2c();\n-                        case ShortType -> l2i().i2s();\n-                        case BooleanType -> l2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case DoubleType ->\n-                    switch (toType) {\n-                        case IntType -> d2i();\n-                        case LongType -> d2l();\n-                        case DoubleType -> this;\n-                        case FloatType -> d2f();\n-                        case ByteType -> d2i().i2b();\n-                        case CharType -> d2i().i2c();\n-                        case ShortType -> d2i().i2s();\n-                        case BooleanType -> d2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case FloatType ->\n-                    switch (toType) {\n-                        case IntType -> f2i();\n-                        case LongType -> f2l();\n-                        case DoubleType -> f2d();\n-                        case FloatType -> this;\n-                        case ByteType -> f2i().i2b();\n-                        case CharType -> f2i().i2c();\n-                        case ShortType -> f2i().i2s();\n-                        case BooleanType -> f2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case VoidType, ReferenceType ->\n-                throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-        };\n-    }\n-\n-    \/**\n-     * Generate an instruction pushing a constant onto the operand stack\n-     * @see Opcode.Kind#CONSTANT\n-     * @param opcode the constant instruction opcode\n-     * @param value the constant value\n-     * @return this builder\n-     * @since 23\n-     *\/\n-    default CodeBuilder loadConstant(Opcode opcode, ConstantDesc value) {\n-        BytecodeHelpers.validateValue(opcode, value);\n-        return with(switch (opcode) {\n-            case SIPUSH, BIPUSH -> ConstantInstruction.ofArgument(opcode, ((Number)value).intValue());\n-            case LDC, LDC_W, LDC2_W -> ConstantInstruction.ofLoad(opcode, BytecodeHelpers.constantEntry(constantPool(), value));\n-            default -> ConstantInstruction.ofIntrinsic(opcode);\n-        });\n+        var computationalFrom = fromType.asLoadable();\n+        var computationalTo = toType.asLoadable();\n+        if (computationalFrom != computationalTo) {\n+            switch (computationalTo) {\n+                case INT -> {\n+                    switch (computationalFrom) {\n+                        case FLOAT -> f2i();\n+                        case LONG -> l2i();\n+                        case DOUBLE -> d2i();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+                case FLOAT -> {\n+                    switch (computationalFrom) {\n+                        case INT -> i2f();\n+                        case LONG -> l2f();\n+                        case DOUBLE -> d2f();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+                case LONG -> {\n+                    switch (computationalFrom) {\n+                        case INT -> i2l();\n+                        case FLOAT -> f2l();\n+                        case DOUBLE -> d2l();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+                case DOUBLE -> {\n+                    switch (computationalFrom) {\n+                        case INT -> i2d();\n+                        case FLOAT -> f2d();\n+                        case LONG -> l2d();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+            }\n+        }\n+        if (computationalTo == TypeKind.INT && toType != TypeKind.INT) {\n+            switch (toType) {\n+                case BOOLEAN -> iconst_1().iand();\n+                case BYTE -> i2b();\n+                case CHAR -> i2c();\n+                case SHORT -> i2s();\n+            }\n+        }\n+        return this;\n@@ -642,26 +617,28 @@\n-        if (value instanceof Integer iVal)\n-            return switch (iVal) {\n-                case -1 -> iconst_m1();\n-                case  0 -> iconst_0();\n-                case  1 -> iconst_1();\n-                case  2 -> iconst_2();\n-                case  3 -> iconst_3();\n-                case  4 -> iconst_4();\n-                case  5 -> iconst_5();\n-                default -> (iVal >= Byte.MIN_VALUE && iVal <= Byte.MAX_VALUE) ? bipush(iVal)\n-                         : (iVal >= Short.MIN_VALUE && iVal <= Short.MAX_VALUE) ? sipush(iVal)\n-                         : ldc(constantPool().intEntry(iVal));\n-            };\n-        if (value instanceof Long lVal)\n-            return lVal == 0l ? lconst_0()\n-                 : lVal == 1l ? lconst_1()\n-                 : ldc(constantPool().longEntry(lVal));\n-        if (value instanceof Float fVal)\n-            return Float.floatToRawIntBits(fVal) == 0 ? fconst_0()\n-                 : fVal == 1.0f ? fconst_1()\n-                 : fVal == 2.0f ? fconst_2()\n-                 : ldc(constantPool().floatEntry(fVal));\n-        if (value instanceof Double dVal)\n-            return Double.doubleToRawLongBits(dVal) == 0l ? dconst_0()\n-                 : dVal == 1.0d ? dconst_1()\n-                 : ldc(constantPool().doubleEntry(dVal));\n+        if (value instanceof Number) {\n+            if (value instanceof Integer iVal)\n+                return switch (iVal) {\n+                    case -1 -> iconst_m1();\n+                    case 0 -> iconst_0();\n+                    case 1 -> iconst_1();\n+                    case 2 -> iconst_2();\n+                    case 3 -> iconst_3();\n+                    case 4 -> iconst_4();\n+                    case 5 -> iconst_5();\n+                    default -> (iVal >= Byte.MIN_VALUE && iVal <= Byte.MAX_VALUE) ? bipush(iVal)\n+                            : (iVal >= Short.MIN_VALUE && iVal <= Short.MAX_VALUE) ? sipush(iVal)\n+                            : ldc(constantPool().intEntry(iVal));\n+                };\n+            if (value instanceof Long lVal)\n+                return lVal == 0L ? lconst_0()\n+                        : lVal == 1L ? lconst_1()\n+                        : ldc(constantPool().longEntry(lVal));\n+            if (value instanceof Float fVal)\n+                return Float.floatToRawIntBits(fVal) == 0 ? fconst_0()\n+                        : fVal == 1.0f ? fconst_1()\n+                        : fVal == 2.0f ? fconst_2()\n+                        : ldc(constantPool().floatEntry(fVal));\n+            if (value instanceof Double dVal)\n+                return Double.doubleToRawLongBits(dVal) == 0L ? dconst_0()\n+                        : dVal == 1.0d ? dconst_1()\n+                        : ldc(constantPool().doubleEntry(dVal));\n+        }\n@@ -843,1 +820,1 @@\n-        return arrayLoad(TypeKind.ReferenceType);\n+        return arrayLoad(TypeKind.REFERENCE);\n@@ -851,1 +828,1 @@\n-        return arrayStore(TypeKind.ReferenceType);\n+        return arrayStore(TypeKind.REFERENCE);\n@@ -864,1 +841,1 @@\n-        return loadLocal(TypeKind.ReferenceType, slot);\n+        return loadLocal(TypeKind.REFERENCE, slot);\n@@ -891,1 +868,1 @@\n-        return return_(TypeKind.ReferenceType);\n+        return return_(TypeKind.REFERENCE);\n@@ -912,1 +889,1 @@\n-        return storeLocal(TypeKind.ReferenceType, slot);\n+        return storeLocal(TypeKind.REFERENCE, slot);\n@@ -928,1 +905,1 @@\n-        return arrayLoad(TypeKind.ByteType);\n+        return arrayLoad(TypeKind.BYTE);\n@@ -936,1 +913,1 @@\n-        return arrayStore(TypeKind.ByteType);\n+        return arrayStore(TypeKind.BYTE);\n@@ -940,2 +917,2 @@\n-     * Generate an instruction pushing a byte onto the operand stack\n-     * @param b the byte\n+     * Generate an instruction pushing an int in the range of byte onto the operand stack.\n+     * @param b the int in the range of byte\n@@ -945,1 +922,1 @@\n-        return loadConstant(Opcode.BIPUSH, b);\n+        return with(ConstantInstruction.ofArgument(Opcode.BIPUSH, b));\n@@ -953,1 +930,1 @@\n-        return arrayLoad(TypeKind.CharType);\n+        return arrayLoad(TypeKind.CHAR);\n@@ -961,1 +938,1 @@\n-        return arrayStore(TypeKind.CharType);\n+        return arrayStore(TypeKind.CHAR);\n@@ -1020,1 +997,1 @@\n-        return arrayLoad(TypeKind.DoubleType);\n+        return arrayLoad(TypeKind.DOUBLE);\n@@ -1028,1 +1005,1 @@\n-        return arrayStore(TypeKind.DoubleType);\n+        return arrayStore(TypeKind.DOUBLE);\n@@ -1081,1 +1058,1 @@\n-        return loadLocal(TypeKind.DoubleType, slot);\n+        return loadLocal(TypeKind.DOUBLE, slot);\n@@ -1113,1 +1090,1 @@\n-        return return_(TypeKind.DoubleType);\n+        return return_(TypeKind.DOUBLE);\n@@ -1126,1 +1103,1 @@\n-        return storeLocal(TypeKind.DoubleType, slot);\n+        return storeLocal(TypeKind.DOUBLE, slot);\n@@ -1224,1 +1201,1 @@\n-        return arrayLoad(TypeKind.FloatType);\n+        return arrayLoad(TypeKind.FLOAT);\n@@ -1232,1 +1209,1 @@\n-        return arrayStore(TypeKind.FloatType);\n+        return arrayStore(TypeKind.FLOAT);\n@@ -1293,1 +1270,1 @@\n-        return loadLocal(TypeKind.FloatType, slot);\n+        return loadLocal(TypeKind.FLOAT, slot);\n@@ -1325,1 +1302,1 @@\n-        return return_(TypeKind.FloatType);\n+        return return_(TypeKind.FLOAT);\n@@ -1338,1 +1315,1 @@\n-        return storeLocal(TypeKind.FloatType, slot);\n+        return storeLocal(TypeKind.FLOAT, slot);\n@@ -1479,1 +1456,1 @@\n-        return arrayLoad(TypeKind.IntType);\n+        return arrayLoad(TypeKind.INT);\n@@ -1495,1 +1472,1 @@\n-        return arrayStore(TypeKind.IntType);\n+        return arrayStore(TypeKind.INT);\n@@ -1726,1 +1703,1 @@\n-        return loadLocal(TypeKind.IntType, slot);\n+        return loadLocal(TypeKind.INT, slot);\n@@ -1955,1 +1932,1 @@\n-        return return_(TypeKind.IntType);\n+        return return_(TypeKind.INT);\n@@ -1984,1 +1961,1 @@\n-        return storeLocal(TypeKind.IntType, slot);\n+        return storeLocal(TypeKind.INT, slot);\n@@ -2058,1 +2035,1 @@\n-        return arrayLoad(TypeKind.LongType);\n+        return arrayLoad(TypeKind.LONG);\n@@ -2074,1 +2051,1 @@\n-        return arrayStore(TypeKind.LongType);\n+        return arrayStore(TypeKind.LONG);\n@@ -2125,4 +2102,1 @@\n-        return with(ConstantInstruction.ofLoad(\n-                entry.typeKind().slotSize() == 2 ? Opcode.LDC2_W\n-                : entry.index() > 0xff ? Opcode.LDC_W\n-                : Opcode.LDC, entry));\n+        return with(ConstantInstruction.ofLoad(BytecodeHelpers.ldcOpcode(entry), entry));\n@@ -2149,1 +2123,1 @@\n-        return loadLocal(TypeKind.LongType, slot);\n+        return loadLocal(TypeKind.LONG, slot);\n@@ -2189,1 +2163,1 @@\n-        return return_(TypeKind.LongType);\n+        return return_(TypeKind.LONG);\n@@ -2218,1 +2192,1 @@\n-        return storeLocal(TypeKind.LongType, slot);\n+        return storeLocal(TypeKind.LONG, slot);\n@@ -2388,1 +2362,1 @@\n-        return return_(TypeKind.VoidType);\n+        return return_(TypeKind.VOID);\n@@ -2396,1 +2370,1 @@\n-        return arrayLoad(TypeKind.ShortType);\n+        return arrayLoad(TypeKind.SHORT);\n@@ -2404,1 +2378,1 @@\n-        return arrayStore(TypeKind.ShortType);\n+        return arrayStore(TypeKind.SHORT);\n@@ -2408,2 +2382,2 @@\n-     * Generate an instruction pushing a short onto the operand stack\n-     * @param s the short\n+     * Generate an instruction pushing an int in the range of short onto the operand stack.\n+     * @param s the int in the range of short\n@@ -2413,1 +2387,1 @@\n-        return loadConstant(Opcode.SIPUSH, s);\n+        return with(ConstantInstruction.ofArgument(Opcode.SIPUSH, s));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":118,"deletions":144,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    ACONST_NULL(ClassFile.ACONST_NULL, 1, Kind.CONSTANT, TypeKind.ReferenceType, 0, ConstantDescs.NULL),\n+    ACONST_NULL(ClassFile.ACONST_NULL, 1, Kind.CONSTANT, TypeKind.REFERENCE, 0, ConstantDescs.NULL),\n@@ -51,1 +51,1 @@\n-    ICONST_M1(ClassFile.ICONST_M1, 1, Kind.CONSTANT, TypeKind.IntType, 0, -1),\n+    ICONST_M1(ClassFile.ICONST_M1, 1, Kind.CONSTANT, TypeKind.INT, 0, -1),\n@@ -54,1 +54,1 @@\n-    ICONST_0(ClassFile.ICONST_0, 1, Kind.CONSTANT, TypeKind.IntType, 0, 0),\n+    ICONST_0(ClassFile.ICONST_0, 1, Kind.CONSTANT, TypeKind.INT, 0, 0),\n@@ -57,1 +57,1 @@\n-    ICONST_1(ClassFile.ICONST_1, 1, Kind.CONSTANT, TypeKind.IntType, 0, 1),\n+    ICONST_1(ClassFile.ICONST_1, 1, Kind.CONSTANT, TypeKind.INT, 0, 1),\n@@ -60,1 +60,1 @@\n-    ICONST_2(ClassFile.ICONST_2, 1, Kind.CONSTANT, TypeKind.IntType, 0, 2),\n+    ICONST_2(ClassFile.ICONST_2, 1, Kind.CONSTANT, TypeKind.INT, 0, 2),\n@@ -63,1 +63,1 @@\n-    ICONST_3(ClassFile.ICONST_3, 1, Kind.CONSTANT, TypeKind.IntType, 0, 3),\n+    ICONST_3(ClassFile.ICONST_3, 1, Kind.CONSTANT, TypeKind.INT, 0, 3),\n@@ -66,1 +66,1 @@\n-    ICONST_4(ClassFile.ICONST_4, 1, Kind.CONSTANT, TypeKind.IntType, 0, 4),\n+    ICONST_4(ClassFile.ICONST_4, 1, Kind.CONSTANT, TypeKind.INT, 0, 4),\n@@ -69,1 +69,1 @@\n-    ICONST_5(ClassFile.ICONST_5, 1, Kind.CONSTANT, TypeKind.IntType, 0, 5),\n+    ICONST_5(ClassFile.ICONST_5, 1, Kind.CONSTANT, TypeKind.INT, 0, 5),\n@@ -72,1 +72,1 @@\n-    LCONST_0(ClassFile.LCONST_0, 1, Kind.CONSTANT, TypeKind.LongType, 0, 0L),\n+    LCONST_0(ClassFile.LCONST_0, 1, Kind.CONSTANT, TypeKind.LONG, 0, 0L),\n@@ -75,1 +75,1 @@\n-    LCONST_1(ClassFile.LCONST_1, 1, Kind.CONSTANT, TypeKind.LongType, 0, 1L),\n+    LCONST_1(ClassFile.LCONST_1, 1, Kind.CONSTANT, TypeKind.LONG, 0, 1L),\n@@ -78,1 +78,1 @@\n-    FCONST_0(ClassFile.FCONST_0, 1, Kind.CONSTANT, TypeKind.FloatType, 0, 0.0f),\n+    FCONST_0(ClassFile.FCONST_0, 1, Kind.CONSTANT, TypeKind.FLOAT, 0, 0.0f),\n@@ -81,1 +81,1 @@\n-    FCONST_1(ClassFile.FCONST_1, 1, Kind.CONSTANT, TypeKind.FloatType, 0, 1.0f),\n+    FCONST_1(ClassFile.FCONST_1, 1, Kind.CONSTANT, TypeKind.FLOAT, 0, 1.0f),\n@@ -84,1 +84,1 @@\n-    FCONST_2(ClassFile.FCONST_2, 1, Kind.CONSTANT, TypeKind.FloatType, 0, 2.0f),\n+    FCONST_2(ClassFile.FCONST_2, 1, Kind.CONSTANT, TypeKind.FLOAT, 0, 2.0f),\n@@ -87,1 +87,1 @@\n-    DCONST_0(ClassFile.DCONST_0, 1, Kind.CONSTANT, TypeKind.DoubleType, 0, 0.0d),\n+    DCONST_0(ClassFile.DCONST_0, 1, Kind.CONSTANT, TypeKind.DOUBLE, 0, 0.0d),\n@@ -90,1 +90,1 @@\n-    DCONST_1(ClassFile.DCONST_1, 1, Kind.CONSTANT, TypeKind.DoubleType, 0, 1.0d),\n+    DCONST_1(ClassFile.DCONST_1, 1, Kind.CONSTANT, TypeKind.DOUBLE, 0, 1.0d),\n@@ -93,1 +93,1 @@\n-    BIPUSH(ClassFile.BIPUSH, 2, Kind.CONSTANT, TypeKind.ByteType),\n+    BIPUSH(ClassFile.BIPUSH, 2, Kind.CONSTANT, TypeKind.BYTE),\n@@ -96,1 +96,1 @@\n-    SIPUSH(ClassFile.SIPUSH, 3, Kind.CONSTANT, TypeKind.ShortType),\n+    SIPUSH(ClassFile.SIPUSH, 3, Kind.CONSTANT, TypeKind.SHORT),\n@@ -108,1 +108,1 @@\n-    ILOAD(ClassFile.ILOAD, 2, Kind.LOAD, TypeKind.IntType, -1),\n+    ILOAD(ClassFile.ILOAD, 2, Kind.LOAD, TypeKind.INT, -1),\n@@ -111,1 +111,1 @@\n-    LLOAD(ClassFile.LLOAD, 2, Kind.LOAD, TypeKind.LongType, -1),\n+    LLOAD(ClassFile.LLOAD, 2, Kind.LOAD, TypeKind.LONG, -1),\n@@ -114,1 +114,1 @@\n-    FLOAD(ClassFile.FLOAD, 2, Kind.LOAD, TypeKind.FloatType, -1),\n+    FLOAD(ClassFile.FLOAD, 2, Kind.LOAD, TypeKind.FLOAT, -1),\n@@ -117,1 +117,1 @@\n-    DLOAD(ClassFile.DLOAD, 2, Kind.LOAD, TypeKind.DoubleType, -1),\n+    DLOAD(ClassFile.DLOAD, 2, Kind.LOAD, TypeKind.DOUBLE, -1),\n@@ -120,1 +120,1 @@\n-    ALOAD(ClassFile.ALOAD, 2, Kind.LOAD, TypeKind.ReferenceType, -1),\n+    ALOAD(ClassFile.ALOAD, 2, Kind.LOAD, TypeKind.REFERENCE, -1),\n@@ -123,1 +123,1 @@\n-    ILOAD_0(ClassFile.ILOAD_0, 1, Kind.LOAD, TypeKind.IntType, 0),\n+    ILOAD_0(ClassFile.ILOAD_0, 1, Kind.LOAD, TypeKind.INT, 0),\n@@ -126,1 +126,1 @@\n-    ILOAD_1(ClassFile.ILOAD_1, 1, Kind.LOAD, TypeKind.IntType, 1),\n+    ILOAD_1(ClassFile.ILOAD_1, 1, Kind.LOAD, TypeKind.INT, 1),\n@@ -129,1 +129,1 @@\n-    ILOAD_2(ClassFile.ILOAD_2, 1, Kind.LOAD, TypeKind.IntType, 2),\n+    ILOAD_2(ClassFile.ILOAD_2, 1, Kind.LOAD, TypeKind.INT, 2),\n@@ -132,1 +132,1 @@\n-    ILOAD_3(ClassFile.ILOAD_3, 1, Kind.LOAD, TypeKind.IntType, 3),\n+    ILOAD_3(ClassFile.ILOAD_3, 1, Kind.LOAD, TypeKind.INT, 3),\n@@ -135,1 +135,1 @@\n-    LLOAD_0(ClassFile.LLOAD_0, 1, Kind.LOAD, TypeKind.LongType, 0),\n+    LLOAD_0(ClassFile.LLOAD_0, 1, Kind.LOAD, TypeKind.LONG, 0),\n@@ -138,1 +138,1 @@\n-    LLOAD_1(ClassFile.LLOAD_1, 1, Kind.LOAD, TypeKind.LongType, 1),\n+    LLOAD_1(ClassFile.LLOAD_1, 1, Kind.LOAD, TypeKind.LONG, 1),\n@@ -141,1 +141,1 @@\n-    LLOAD_2(ClassFile.LLOAD_2, 1, Kind.LOAD, TypeKind.LongType, 2),\n+    LLOAD_2(ClassFile.LLOAD_2, 1, Kind.LOAD, TypeKind.LONG, 2),\n@@ -144,1 +144,1 @@\n-    LLOAD_3(ClassFile.LLOAD_3, 1, Kind.LOAD, TypeKind.LongType, 3),\n+    LLOAD_3(ClassFile.LLOAD_3, 1, Kind.LOAD, TypeKind.LONG, 3),\n@@ -147,1 +147,1 @@\n-    FLOAD_0(ClassFile.FLOAD_0, 1, Kind.LOAD, TypeKind.FloatType, 0),\n+    FLOAD_0(ClassFile.FLOAD_0, 1, Kind.LOAD, TypeKind.FLOAT, 0),\n@@ -150,1 +150,1 @@\n-    FLOAD_1(ClassFile.FLOAD_1, 1, Kind.LOAD, TypeKind.FloatType, 1),\n+    FLOAD_1(ClassFile.FLOAD_1, 1, Kind.LOAD, TypeKind.FLOAT, 1),\n@@ -153,1 +153,1 @@\n-    FLOAD_2(ClassFile.FLOAD_2, 1, Kind.LOAD, TypeKind.FloatType, 2),\n+    FLOAD_2(ClassFile.FLOAD_2, 1, Kind.LOAD, TypeKind.FLOAT, 2),\n@@ -156,1 +156,1 @@\n-    FLOAD_3(ClassFile.FLOAD_3, 1, Kind.LOAD, TypeKind.FloatType, 3),\n+    FLOAD_3(ClassFile.FLOAD_3, 1, Kind.LOAD, TypeKind.FLOAT, 3),\n@@ -159,1 +159,1 @@\n-    DLOAD_0(ClassFile.DLOAD_0, 1, Kind.LOAD, TypeKind.DoubleType, 0),\n+    DLOAD_0(ClassFile.DLOAD_0, 1, Kind.LOAD, TypeKind.DOUBLE, 0),\n@@ -162,1 +162,1 @@\n-    DLOAD_1(ClassFile.DLOAD_1, 1, Kind.LOAD, TypeKind.DoubleType, 1),\n+    DLOAD_1(ClassFile.DLOAD_1, 1, Kind.LOAD, TypeKind.DOUBLE, 1),\n@@ -165,1 +165,1 @@\n-    DLOAD_2(ClassFile.DLOAD_2, 1, Kind.LOAD, TypeKind.DoubleType, 2),\n+    DLOAD_2(ClassFile.DLOAD_2, 1, Kind.LOAD, TypeKind.DOUBLE, 2),\n@@ -168,1 +168,1 @@\n-    DLOAD_3(ClassFile.DLOAD_3, 1, Kind.LOAD, TypeKind.DoubleType, 3),\n+    DLOAD_3(ClassFile.DLOAD_3, 1, Kind.LOAD, TypeKind.DOUBLE, 3),\n@@ -171,1 +171,1 @@\n-    ALOAD_0(ClassFile.ALOAD_0, 1, Kind.LOAD, TypeKind.ReferenceType, 0),\n+    ALOAD_0(ClassFile.ALOAD_0, 1, Kind.LOAD, TypeKind.REFERENCE, 0),\n@@ -174,1 +174,1 @@\n-    ALOAD_1(ClassFile.ALOAD_1, 1, Kind.LOAD, TypeKind.ReferenceType, 1),\n+    ALOAD_1(ClassFile.ALOAD_1, 1, Kind.LOAD, TypeKind.REFERENCE, 1),\n@@ -177,1 +177,1 @@\n-    ALOAD_2(ClassFile.ALOAD_2, 1, Kind.LOAD, TypeKind.ReferenceType, 2),\n+    ALOAD_2(ClassFile.ALOAD_2, 1, Kind.LOAD, TypeKind.REFERENCE, 2),\n@@ -180,1 +180,1 @@\n-    ALOAD_3(ClassFile.ALOAD_3, 1, Kind.LOAD, TypeKind.ReferenceType, 3),\n+    ALOAD_3(ClassFile.ALOAD_3, 1, Kind.LOAD, TypeKind.REFERENCE, 3),\n@@ -183,1 +183,1 @@\n-    IALOAD(ClassFile.IALOAD, 1, Kind.ARRAY_LOAD, TypeKind.IntType),\n+    IALOAD(ClassFile.IALOAD, 1, Kind.ARRAY_LOAD, TypeKind.INT),\n@@ -186,1 +186,1 @@\n-    LALOAD(ClassFile.LALOAD, 1, Kind.ARRAY_LOAD, TypeKind.LongType),\n+    LALOAD(ClassFile.LALOAD, 1, Kind.ARRAY_LOAD, TypeKind.LONG),\n@@ -189,1 +189,1 @@\n-    FALOAD(ClassFile.FALOAD, 1, Kind.ARRAY_LOAD, TypeKind.FloatType),\n+    FALOAD(ClassFile.FALOAD, 1, Kind.ARRAY_LOAD, TypeKind.FLOAT),\n@@ -192,1 +192,1 @@\n-    DALOAD(ClassFile.DALOAD, 1, Kind.ARRAY_LOAD, TypeKind.DoubleType),\n+    DALOAD(ClassFile.DALOAD, 1, Kind.ARRAY_LOAD, TypeKind.DOUBLE),\n@@ -195,1 +195,1 @@\n-    AALOAD(ClassFile.AALOAD, 1, Kind.ARRAY_LOAD, TypeKind.ReferenceType),\n+    AALOAD(ClassFile.AALOAD, 1, Kind.ARRAY_LOAD, TypeKind.REFERENCE),\n@@ -197,2 +197,2 @@\n-    \/** Load byte from array *\/\n-    BALOAD(ClassFile.BALOAD, 1, Kind.ARRAY_LOAD, TypeKind.ByteType),\n+    \/** Load byte or boolean from array *\/\n+    BALOAD(ClassFile.BALOAD, 1, Kind.ARRAY_LOAD, TypeKind.BYTE),\n@@ -201,1 +201,1 @@\n-    CALOAD(ClassFile.CALOAD, 1, Kind.ARRAY_LOAD, TypeKind.CharType),\n+    CALOAD(ClassFile.CALOAD, 1, Kind.ARRAY_LOAD, TypeKind.CHAR),\n@@ -204,1 +204,1 @@\n-    SALOAD(ClassFile.SALOAD, 1, Kind.ARRAY_LOAD, TypeKind.ShortType),\n+    SALOAD(ClassFile.SALOAD, 1, Kind.ARRAY_LOAD, TypeKind.SHORT),\n@@ -207,1 +207,1 @@\n-    ISTORE(ClassFile.ISTORE, 2, Kind.STORE, TypeKind.IntType, -1),\n+    ISTORE(ClassFile.ISTORE, 2, Kind.STORE, TypeKind.INT, -1),\n@@ -210,1 +210,1 @@\n-    LSTORE(ClassFile.LSTORE, 2, Kind.STORE, TypeKind.LongType, -1),\n+    LSTORE(ClassFile.LSTORE, 2, Kind.STORE, TypeKind.LONG, -1),\n@@ -213,1 +213,1 @@\n-    FSTORE(ClassFile.FSTORE, 2, Kind.STORE, TypeKind.FloatType, -1),\n+    FSTORE(ClassFile.FSTORE, 2, Kind.STORE, TypeKind.FLOAT, -1),\n@@ -216,1 +216,1 @@\n-    DSTORE(ClassFile.DSTORE, 2, Kind.STORE, TypeKind.DoubleType, -1),\n+    DSTORE(ClassFile.DSTORE, 2, Kind.STORE, TypeKind.DOUBLE, -1),\n@@ -219,1 +219,1 @@\n-    ASTORE(ClassFile.ASTORE, 2, Kind.STORE, TypeKind.ReferenceType, -1),\n+    ASTORE(ClassFile.ASTORE, 2, Kind.STORE, TypeKind.REFERENCE, -1),\n@@ -222,1 +222,1 @@\n-    ISTORE_0(ClassFile.ISTORE_0, 1, Kind.STORE, TypeKind.IntType, 0),\n+    ISTORE_0(ClassFile.ISTORE_0, 1, Kind.STORE, TypeKind.INT, 0),\n@@ -225,1 +225,1 @@\n-    ISTORE_1(ClassFile.ISTORE_1, 1, Kind.STORE, TypeKind.IntType, 1),\n+    ISTORE_1(ClassFile.ISTORE_1, 1, Kind.STORE, TypeKind.INT, 1),\n@@ -228,1 +228,1 @@\n-    ISTORE_2(ClassFile.ISTORE_2, 1, Kind.STORE, TypeKind.IntType, 2),\n+    ISTORE_2(ClassFile.ISTORE_2, 1, Kind.STORE, TypeKind.INT, 2),\n@@ -231,1 +231,1 @@\n-    ISTORE_3(ClassFile.ISTORE_3, 1, Kind.STORE, TypeKind.IntType, 3),\n+    ISTORE_3(ClassFile.ISTORE_3, 1, Kind.STORE, TypeKind.INT, 3),\n@@ -234,1 +234,1 @@\n-    LSTORE_0(ClassFile.LSTORE_0, 1, Kind.STORE, TypeKind.LongType, 0),\n+    LSTORE_0(ClassFile.LSTORE_0, 1, Kind.STORE, TypeKind.LONG, 0),\n@@ -237,1 +237,1 @@\n-    LSTORE_1(ClassFile.LSTORE_1, 1, Kind.STORE, TypeKind.LongType, 1),\n+    LSTORE_1(ClassFile.LSTORE_1, 1, Kind.STORE, TypeKind.LONG, 1),\n@@ -240,1 +240,1 @@\n-    LSTORE_2(ClassFile.LSTORE_2, 1, Kind.STORE, TypeKind.LongType, 2),\n+    LSTORE_2(ClassFile.LSTORE_2, 1, Kind.STORE, TypeKind.LONG, 2),\n@@ -243,1 +243,1 @@\n-    LSTORE_3(ClassFile.LSTORE_3, 1, Kind.STORE, TypeKind.LongType, 3),\n+    LSTORE_3(ClassFile.LSTORE_3, 1, Kind.STORE, TypeKind.LONG, 3),\n@@ -246,1 +246,1 @@\n-    FSTORE_0(ClassFile.FSTORE_0, 1, Kind.STORE, TypeKind.FloatType, 0),\n+    FSTORE_0(ClassFile.FSTORE_0, 1, Kind.STORE, TypeKind.FLOAT, 0),\n@@ -249,1 +249,1 @@\n-    FSTORE_1(ClassFile.FSTORE_1, 1, Kind.STORE, TypeKind.FloatType, 1),\n+    FSTORE_1(ClassFile.FSTORE_1, 1, Kind.STORE, TypeKind.FLOAT, 1),\n@@ -252,1 +252,1 @@\n-    FSTORE_2(ClassFile.FSTORE_2, 1, Kind.STORE, TypeKind.FloatType, 2),\n+    FSTORE_2(ClassFile.FSTORE_2, 1, Kind.STORE, TypeKind.FLOAT, 2),\n@@ -255,1 +255,1 @@\n-    FSTORE_3(ClassFile.FSTORE_3, 1, Kind.STORE, TypeKind.FloatType, 3),\n+    FSTORE_3(ClassFile.FSTORE_3, 1, Kind.STORE, TypeKind.FLOAT, 3),\n@@ -258,1 +258,1 @@\n-    DSTORE_0(ClassFile.DSTORE_0, 1, Kind.STORE, TypeKind.DoubleType, 0),\n+    DSTORE_0(ClassFile.DSTORE_0, 1, Kind.STORE, TypeKind.DOUBLE, 0),\n@@ -261,1 +261,1 @@\n-    DSTORE_1(ClassFile.DSTORE_1, 1, Kind.STORE, TypeKind.DoubleType, 1),\n+    DSTORE_1(ClassFile.DSTORE_1, 1, Kind.STORE, TypeKind.DOUBLE, 1),\n@@ -264,1 +264,1 @@\n-    DSTORE_2(ClassFile.DSTORE_2, 1, Kind.STORE, TypeKind.DoubleType, 2),\n+    DSTORE_2(ClassFile.DSTORE_2, 1, Kind.STORE, TypeKind.DOUBLE, 2),\n@@ -267,1 +267,1 @@\n-    DSTORE_3(ClassFile.DSTORE_3, 1, Kind.STORE, TypeKind.DoubleType, 3),\n+    DSTORE_3(ClassFile.DSTORE_3, 1, Kind.STORE, TypeKind.DOUBLE, 3),\n@@ -270,1 +270,1 @@\n-    ASTORE_0(ClassFile.ASTORE_0, 1, Kind.STORE, TypeKind.ReferenceType, 0),\n+    ASTORE_0(ClassFile.ASTORE_0, 1, Kind.STORE, TypeKind.REFERENCE, 0),\n@@ -273,1 +273,1 @@\n-    ASTORE_1(ClassFile.ASTORE_1, 1, Kind.STORE, TypeKind.ReferenceType, 1),\n+    ASTORE_1(ClassFile.ASTORE_1, 1, Kind.STORE, TypeKind.REFERENCE, 1),\n@@ -276,1 +276,1 @@\n-    ASTORE_2(ClassFile.ASTORE_2, 1, Kind.STORE, TypeKind.ReferenceType, 2),\n+    ASTORE_2(ClassFile.ASTORE_2, 1, Kind.STORE, TypeKind.REFERENCE, 2),\n@@ -279,1 +279,1 @@\n-    ASTORE_3(ClassFile.ASTORE_3, 1, Kind.STORE, TypeKind.ReferenceType, 3),\n+    ASTORE_3(ClassFile.ASTORE_3, 1, Kind.STORE, TypeKind.REFERENCE, 3),\n@@ -282,1 +282,1 @@\n-    IASTORE(ClassFile.IASTORE, 1, Kind.ARRAY_STORE, TypeKind.IntType),\n+    IASTORE(ClassFile.IASTORE, 1, Kind.ARRAY_STORE, TypeKind.INT),\n@@ -285,1 +285,1 @@\n-    LASTORE(ClassFile.LASTORE, 1, Kind.ARRAY_STORE, TypeKind.LongType),\n+    LASTORE(ClassFile.LASTORE, 1, Kind.ARRAY_STORE, TypeKind.LONG),\n@@ -288,1 +288,1 @@\n-    FASTORE(ClassFile.FASTORE, 1, Kind.ARRAY_STORE, TypeKind.FloatType),\n+    FASTORE(ClassFile.FASTORE, 1, Kind.ARRAY_STORE, TypeKind.FLOAT),\n@@ -291,1 +291,1 @@\n-    DASTORE(ClassFile.DASTORE, 1, Kind.ARRAY_STORE, TypeKind.DoubleType),\n+    DASTORE(ClassFile.DASTORE, 1, Kind.ARRAY_STORE, TypeKind.DOUBLE),\n@@ -294,1 +294,1 @@\n-    AASTORE(ClassFile.AASTORE, 1, Kind.ARRAY_STORE, TypeKind.ReferenceType),\n+    AASTORE(ClassFile.AASTORE, 1, Kind.ARRAY_STORE, TypeKind.REFERENCE),\n@@ -296,2 +296,2 @@\n-    \/** Store into byte array *\/\n-    BASTORE(ClassFile.BASTORE, 1, Kind.ARRAY_STORE, TypeKind.ByteType),\n+    \/** Store into byte or boolean array *\/\n+    BASTORE(ClassFile.BASTORE, 1, Kind.ARRAY_STORE, TypeKind.BYTE),\n@@ -300,1 +300,1 @@\n-    CASTORE(ClassFile.CASTORE, 1, Kind.ARRAY_STORE, TypeKind.CharType),\n+    CASTORE(ClassFile.CASTORE, 1, Kind.ARRAY_STORE, TypeKind.CHAR),\n@@ -303,1 +303,1 @@\n-    SASTORE(ClassFile.SASTORE, 1, Kind.ARRAY_STORE, TypeKind.ShortType),\n+    SASTORE(ClassFile.SASTORE, 1, Kind.ARRAY_STORE, TypeKind.SHORT),\n@@ -333,1 +333,1 @@\n-    IADD(ClassFile.IADD, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IADD(ClassFile.IADD, 1, Kind.OPERATOR, TypeKind.INT),\n@@ -336,1 +336,1 @@\n-    LADD(ClassFile.LADD, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LADD(ClassFile.LADD, 1, Kind.OPERATOR, TypeKind.LONG),\n@@ -339,1 +339,1 @@\n-    FADD(ClassFile.FADD, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FADD(ClassFile.FADD, 1, Kind.OPERATOR, TypeKind.FLOAT),\n@@ -342,1 +342,1 @@\n-    DADD(ClassFile.DADD, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DADD(ClassFile.DADD, 1, Kind.OPERATOR, TypeKind.DOUBLE),\n@@ -345,1 +345,1 @@\n-    ISUB(ClassFile.ISUB, 1, Kind.OPERATOR, TypeKind.IntType),\n+    ISUB(ClassFile.ISUB, 1, Kind.OPERATOR, TypeKind.INT),\n@@ -348,1 +348,1 @@\n-    LSUB(ClassFile.LSUB, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LSUB(ClassFile.LSUB, 1, Kind.OPERATOR, TypeKind.LONG),\n@@ -351,1 +351,1 @@\n-    FSUB(ClassFile.FSUB, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FSUB(ClassFile.FSUB, 1, Kind.OPERATOR, TypeKind.FLOAT),\n@@ -354,1 +354,1 @@\n-    DSUB(ClassFile.DSUB, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DSUB(ClassFile.DSUB, 1, Kind.OPERATOR, TypeKind.DOUBLE),\n@@ -357,1 +357,1 @@\n-    IMUL(ClassFile.IMUL, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IMUL(ClassFile.IMUL, 1, Kind.OPERATOR, TypeKind.INT),\n@@ -360,1 +360,1 @@\n-    LMUL(ClassFile.LMUL, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LMUL(ClassFile.LMUL, 1, Kind.OPERATOR, TypeKind.LONG),\n@@ -363,1 +363,1 @@\n-    FMUL(ClassFile.FMUL, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FMUL(ClassFile.FMUL, 1, Kind.OPERATOR, TypeKind.FLOAT),\n@@ -366,1 +366,1 @@\n-    DMUL(ClassFile.DMUL, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DMUL(ClassFile.DMUL, 1, Kind.OPERATOR, TypeKind.DOUBLE),\n@@ -369,1 +369,1 @@\n-    IDIV(ClassFile.IDIV, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IDIV(ClassFile.IDIV, 1, Kind.OPERATOR, TypeKind.INT),\n@@ -372,1 +372,1 @@\n-    LDIV(ClassFile.LDIV, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LDIV(ClassFile.LDIV, 1, Kind.OPERATOR, TypeKind.LONG),\n@@ -375,1 +375,1 @@\n-    FDIV(ClassFile.FDIV, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FDIV(ClassFile.FDIV, 1, Kind.OPERATOR, TypeKind.FLOAT),\n@@ -378,1 +378,1 @@\n-    DDIV(ClassFile.DDIV, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DDIV(ClassFile.DDIV, 1, Kind.OPERATOR, TypeKind.DOUBLE),\n@@ -381,1 +381,1 @@\n-    IREM(ClassFile.IREM, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IREM(ClassFile.IREM, 1, Kind.OPERATOR, TypeKind.INT),\n@@ -384,1 +384,1 @@\n-    LREM(ClassFile.LREM, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LREM(ClassFile.LREM, 1, Kind.OPERATOR, TypeKind.LONG),\n@@ -387,1 +387,1 @@\n-    FREM(ClassFile.FREM, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FREM(ClassFile.FREM, 1, Kind.OPERATOR, TypeKind.FLOAT),\n@@ -390,1 +390,1 @@\n-    DREM(ClassFile.DREM, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DREM(ClassFile.DREM, 1, Kind.OPERATOR, TypeKind.DOUBLE),\n@@ -393,1 +393,1 @@\n-    INEG(ClassFile.INEG, 1, Kind.OPERATOR, TypeKind.IntType),\n+    INEG(ClassFile.INEG, 1, Kind.OPERATOR, TypeKind.INT),\n@@ -396,1 +396,1 @@\n-    LNEG(ClassFile.LNEG, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LNEG(ClassFile.LNEG, 1, Kind.OPERATOR, TypeKind.LONG),\n@@ -399,1 +399,1 @@\n-    FNEG(ClassFile.FNEG, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FNEG(ClassFile.FNEG, 1, Kind.OPERATOR, TypeKind.FLOAT),\n@@ -402,1 +402,1 @@\n-    DNEG(ClassFile.DNEG, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DNEG(ClassFile.DNEG, 1, Kind.OPERATOR, TypeKind.DOUBLE),\n@@ -405,1 +405,1 @@\n-    ISHL(ClassFile.ISHL, 1, Kind.OPERATOR, TypeKind.IntType),\n+    ISHL(ClassFile.ISHL, 1, Kind.OPERATOR, TypeKind.INT),\n@@ -408,1 +408,1 @@\n-    LSHL(ClassFile.LSHL, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LSHL(ClassFile.LSHL, 1, Kind.OPERATOR, TypeKind.LONG),\n@@ -411,1 +411,1 @@\n-    ISHR(ClassFile.ISHR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    ISHR(ClassFile.ISHR, 1, Kind.OPERATOR, TypeKind.INT),\n@@ -414,1 +414,1 @@\n-    LSHR(ClassFile.LSHR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LSHR(ClassFile.LSHR, 1, Kind.OPERATOR, TypeKind.LONG),\n@@ -417,1 +417,1 @@\n-    IUSHR(ClassFile.IUSHR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IUSHR(ClassFile.IUSHR, 1, Kind.OPERATOR, TypeKind.INT),\n@@ -420,1 +420,1 @@\n-    LUSHR(ClassFile.LUSHR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LUSHR(ClassFile.LUSHR, 1, Kind.OPERATOR, TypeKind.LONG),\n@@ -423,1 +423,1 @@\n-    IAND(ClassFile.IAND, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IAND(ClassFile.IAND, 1, Kind.OPERATOR, TypeKind.INT),\n@@ -426,1 +426,1 @@\n-    LAND(ClassFile.LAND, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LAND(ClassFile.LAND, 1, Kind.OPERATOR, TypeKind.LONG),\n@@ -429,1 +429,1 @@\n-    IOR(ClassFile.IOR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IOR(ClassFile.IOR, 1, Kind.OPERATOR, TypeKind.INT),\n@@ -432,1 +432,1 @@\n-    LOR(ClassFile.LOR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LOR(ClassFile.LOR, 1, Kind.OPERATOR, TypeKind.LONG),\n@@ -435,1 +435,1 @@\n-    IXOR(ClassFile.IXOR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IXOR(ClassFile.IXOR, 1, Kind.OPERATOR, TypeKind.INT),\n@@ -438,1 +438,1 @@\n-    LXOR(ClassFile.LXOR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LXOR(ClassFile.LXOR, 1, Kind.OPERATOR, TypeKind.LONG),\n@@ -441,1 +441,1 @@\n-    IINC(ClassFile.IINC, 3, Kind.INCREMENT, TypeKind.IntType, -1),\n+    IINC(ClassFile.IINC, 3, Kind.INCREMENT, TypeKind.INT, -1),\n@@ -444,1 +444,1 @@\n-    I2L(ClassFile.I2L, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.LongType),\n+    I2L(ClassFile.I2L, 1, Kind.CONVERT, TypeKind.INT, TypeKind.LONG),\n@@ -447,1 +447,1 @@\n-    I2F(ClassFile.I2F, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.FloatType),\n+    I2F(ClassFile.I2F, 1, Kind.CONVERT, TypeKind.INT, TypeKind.FLOAT),\n@@ -450,1 +450,1 @@\n-    I2D(ClassFile.I2D, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.DoubleType),\n+    I2D(ClassFile.I2D, 1, Kind.CONVERT, TypeKind.INT, TypeKind.DOUBLE),\n@@ -453,1 +453,1 @@\n-    L2I(ClassFile.L2I, 1, Kind.CONVERT, TypeKind.LongType, TypeKind.IntType),\n+    L2I(ClassFile.L2I, 1, Kind.CONVERT, TypeKind.LONG, TypeKind.INT),\n@@ -456,1 +456,1 @@\n-    L2F(ClassFile.L2F, 1, Kind.CONVERT, TypeKind.LongType, TypeKind.FloatType),\n+    L2F(ClassFile.L2F, 1, Kind.CONVERT, TypeKind.LONG, TypeKind.FLOAT),\n@@ -459,1 +459,1 @@\n-    L2D(ClassFile.L2D, 1, Kind.CONVERT, TypeKind.LongType, TypeKind.DoubleType),\n+    L2D(ClassFile.L2D, 1, Kind.CONVERT, TypeKind.LONG, TypeKind.DOUBLE),\n@@ -462,1 +462,1 @@\n-    F2I(ClassFile.F2I, 1, Kind.CONVERT, TypeKind.FloatType, TypeKind.IntType),\n+    F2I(ClassFile.F2I, 1, Kind.CONVERT, TypeKind.FLOAT, TypeKind.INT),\n@@ -465,1 +465,1 @@\n-    F2L(ClassFile.F2L, 1, Kind.CONVERT, TypeKind.FloatType, TypeKind.LongType),\n+    F2L(ClassFile.F2L, 1, Kind.CONVERT, TypeKind.FLOAT, TypeKind.LONG),\n@@ -468,1 +468,1 @@\n-    F2D(ClassFile.F2D, 1, Kind.CONVERT, TypeKind.FloatType, TypeKind.DoubleType),\n+    F2D(ClassFile.F2D, 1, Kind.CONVERT, TypeKind.FLOAT, TypeKind.DOUBLE),\n@@ -471,1 +471,1 @@\n-    D2I(ClassFile.D2I, 1, Kind.CONVERT, TypeKind.DoubleType, TypeKind.IntType),\n+    D2I(ClassFile.D2I, 1, Kind.CONVERT, TypeKind.DOUBLE, TypeKind.INT),\n@@ -474,1 +474,1 @@\n-    D2L(ClassFile.D2L, 1, Kind.CONVERT, TypeKind.DoubleType, TypeKind.LongType),\n+    D2L(ClassFile.D2L, 1, Kind.CONVERT, TypeKind.DOUBLE, TypeKind.LONG),\n@@ -477,1 +477,1 @@\n-    D2F(ClassFile.D2F, 1, Kind.CONVERT, TypeKind.DoubleType, TypeKind.FloatType),\n+    D2F(ClassFile.D2F, 1, Kind.CONVERT, TypeKind.DOUBLE, TypeKind.FLOAT),\n@@ -480,1 +480,1 @@\n-    I2B(ClassFile.I2B, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.ByteType),\n+    I2B(ClassFile.I2B, 1, Kind.CONVERT, TypeKind.INT, TypeKind.BYTE),\n@@ -483,1 +483,1 @@\n-    I2C(ClassFile.I2C, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.CharType),\n+    I2C(ClassFile.I2C, 1, Kind.CONVERT, TypeKind.INT, TypeKind.CHAR),\n@@ -486,1 +486,1 @@\n-    I2S(ClassFile.I2S, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.ShortType),\n+    I2S(ClassFile.I2S, 1, Kind.CONVERT, TypeKind.INT, TypeKind.SHORT),\n@@ -489,1 +489,1 @@\n-    LCMP(ClassFile.LCMP, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LCMP(ClassFile.LCMP, 1, Kind.OPERATOR, TypeKind.LONG),\n@@ -492,1 +492,1 @@\n-    FCMPL(ClassFile.FCMPL, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FCMPL(ClassFile.FCMPL, 1, Kind.OPERATOR, TypeKind.FLOAT),\n@@ -495,1 +495,1 @@\n-    FCMPG(ClassFile.FCMPG, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FCMPG(ClassFile.FCMPG, 1, Kind.OPERATOR, TypeKind.FLOAT),\n@@ -498,1 +498,1 @@\n-    DCMPL(ClassFile.DCMPL, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DCMPL(ClassFile.DCMPL, 1, Kind.OPERATOR, TypeKind.DOUBLE),\n@@ -501,1 +501,1 @@\n-    DCMPG(ClassFile.DCMPG, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DCMPG(ClassFile.DCMPG, 1, Kind.OPERATOR, TypeKind.DOUBLE),\n@@ -504,1 +504,1 @@\n-    IFEQ(ClassFile.IFEQ, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFEQ(ClassFile.IFEQ, 3, Kind.BRANCH, TypeKind.INT),\n@@ -507,1 +507,1 @@\n-    IFNE(ClassFile.IFNE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFNE(ClassFile.IFNE, 3, Kind.BRANCH, TypeKind.INT),\n@@ -510,1 +510,1 @@\n-    IFLT(ClassFile.IFLT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFLT(ClassFile.IFLT, 3, Kind.BRANCH, TypeKind.INT),\n@@ -513,1 +513,1 @@\n-    IFGE(ClassFile.IFGE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFGE(ClassFile.IFGE, 3, Kind.BRANCH, TypeKind.INT),\n@@ -516,1 +516,1 @@\n-    IFGT(ClassFile.IFGT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFGT(ClassFile.IFGT, 3, Kind.BRANCH, TypeKind.INT),\n@@ -519,1 +519,1 @@\n-    IFLE(ClassFile.IFLE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFLE(ClassFile.IFLE, 3, Kind.BRANCH, TypeKind.INT),\n@@ -522,1 +522,1 @@\n-    IF_ICMPEQ(ClassFile.IF_ICMPEQ, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPEQ(ClassFile.IF_ICMPEQ, 3, Kind.BRANCH, TypeKind.INT),\n@@ -525,1 +525,1 @@\n-    IF_ICMPNE(ClassFile.IF_ICMPNE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPNE(ClassFile.IF_ICMPNE, 3, Kind.BRANCH, TypeKind.INT),\n@@ -528,1 +528,1 @@\n-    IF_ICMPLT(ClassFile.IF_ICMPLT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPLT(ClassFile.IF_ICMPLT, 3, Kind.BRANCH, TypeKind.INT),\n@@ -531,1 +531,1 @@\n-    IF_ICMPGE(ClassFile.IF_ICMPGE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPGE(ClassFile.IF_ICMPGE, 3, Kind.BRANCH, TypeKind.INT),\n@@ -534,1 +534,1 @@\n-    IF_ICMPGT(ClassFile.IF_ICMPGT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPGT(ClassFile.IF_ICMPGT, 3, Kind.BRANCH, TypeKind.INT),\n@@ -537,1 +537,1 @@\n-    IF_ICMPLE(ClassFile.IF_ICMPLE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPLE(ClassFile.IF_ICMPLE, 3, Kind.BRANCH, TypeKind.INT),\n@@ -540,1 +540,1 @@\n-    IF_ACMPEQ(ClassFile.IF_ACMPEQ, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    IF_ACMPEQ(ClassFile.IF_ACMPEQ, 3, Kind.BRANCH, TypeKind.REFERENCE),\n@@ -543,1 +543,1 @@\n-    IF_ACMPNE(ClassFile.IF_ACMPNE, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    IF_ACMPNE(ClassFile.IF_ACMPNE, 3, Kind.BRANCH, TypeKind.REFERENCE),\n@@ -546,1 +546,1 @@\n-    GOTO(ClassFile.GOTO, 3, Kind.BRANCH, TypeKind.VoidType),\n+    GOTO(ClassFile.GOTO, 3, Kind.BRANCH, TypeKind.VOID),\n@@ -567,1 +567,1 @@\n-    IRETURN(ClassFile.IRETURN, 1, Kind.RETURN, TypeKind.IntType),\n+    IRETURN(ClassFile.IRETURN, 1, Kind.RETURN, TypeKind.INT),\n@@ -570,1 +570,1 @@\n-    LRETURN(ClassFile.LRETURN, 1, Kind.RETURN, TypeKind.LongType),\n+    LRETURN(ClassFile.LRETURN, 1, Kind.RETURN, TypeKind.LONG),\n@@ -573,1 +573,1 @@\n-    FRETURN(ClassFile.FRETURN, 1, Kind.RETURN, TypeKind.FloatType),\n+    FRETURN(ClassFile.FRETURN, 1, Kind.RETURN, TypeKind.FLOAT),\n@@ -576,1 +576,1 @@\n-    DRETURN(ClassFile.DRETURN, 1, Kind.RETURN, TypeKind.DoubleType),\n+    DRETURN(ClassFile.DRETURN, 1, Kind.RETURN, TypeKind.DOUBLE),\n@@ -579,1 +579,1 @@\n-    ARETURN(ClassFile.ARETURN, 1, Kind.RETURN, TypeKind.ReferenceType),\n+    ARETURN(ClassFile.ARETURN, 1, Kind.RETURN, TypeKind.REFERENCE),\n@@ -582,1 +582,1 @@\n-    RETURN(ClassFile.RETURN, 1, Kind.RETURN, TypeKind.VoidType),\n+    RETURN(ClassFile.RETURN, 1, Kind.RETURN, TypeKind.VOID),\n@@ -624,1 +624,1 @@\n-    ARRAYLENGTH(ClassFile.ARRAYLENGTH, 1, Kind.OPERATOR, TypeKind.IntType),\n+    ARRAYLENGTH(ClassFile.ARRAYLENGTH, 1, Kind.OPERATOR, TypeKind.INT),\n@@ -645,1 +645,1 @@\n-    IFNULL(ClassFile.IFNULL, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    IFNULL(ClassFile.IFNULL, 3, Kind.BRANCH, TypeKind.REFERENCE),\n@@ -648,1 +648,1 @@\n-    IFNONNULL(ClassFile.IFNONNULL, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    IFNONNULL(ClassFile.IFNONNULL, 3, Kind.BRANCH, TypeKind.REFERENCE),\n@@ -651,1 +651,1 @@\n-    GOTO_W(ClassFile.GOTO_W, 5, Kind.BRANCH, TypeKind.VoidType),\n+    GOTO_W(ClassFile.GOTO_W, 5, Kind.BRANCH, TypeKind.VOID),\n@@ -660,1 +660,1 @@\n-    ILOAD_W((ClassFile.WIDE << 8) | ClassFile.ILOAD, 4, Kind.LOAD, TypeKind.IntType, -1),\n+    ILOAD_W((ClassFile.WIDE << 8) | ClassFile.ILOAD, 4, Kind.LOAD, TypeKind.INT, -1),\n@@ -663,1 +663,1 @@\n-    LLOAD_W((ClassFile.WIDE << 8) | ClassFile.LLOAD, 4, Kind.LOAD, TypeKind.LongType, -1),\n+    LLOAD_W((ClassFile.WIDE << 8) | ClassFile.LLOAD, 4, Kind.LOAD, TypeKind.LONG, -1),\n@@ -666,1 +666,1 @@\n-    FLOAD_W((ClassFile.WIDE << 8) | ClassFile.FLOAD, 4, Kind.LOAD, TypeKind.FloatType, -1),\n+    FLOAD_W((ClassFile.WIDE << 8) | ClassFile.FLOAD, 4, Kind.LOAD, TypeKind.FLOAT, -1),\n@@ -669,1 +669,1 @@\n-    DLOAD_W((ClassFile.WIDE << 8) | ClassFile.DLOAD, 4, Kind.LOAD, TypeKind.DoubleType, -1),\n+    DLOAD_W((ClassFile.WIDE << 8) | ClassFile.DLOAD, 4, Kind.LOAD, TypeKind.DOUBLE, -1),\n@@ -672,1 +672,1 @@\n-    ALOAD_W((ClassFile.WIDE << 8) | ClassFile.ALOAD, 4, Kind.LOAD, TypeKind.ReferenceType, -1),\n+    ALOAD_W((ClassFile.WIDE << 8) | ClassFile.ALOAD, 4, Kind.LOAD, TypeKind.REFERENCE, -1),\n@@ -675,1 +675,1 @@\n-    ISTORE_W((ClassFile.WIDE << 8) | ClassFile.ISTORE, 4, Kind.STORE, TypeKind.IntType, -1),\n+    ISTORE_W((ClassFile.WIDE << 8) | ClassFile.ISTORE, 4, Kind.STORE, TypeKind.INT, -1),\n@@ -678,1 +678,1 @@\n-    LSTORE_W((ClassFile.WIDE << 8) | ClassFile.LSTORE, 4, Kind.STORE, TypeKind.LongType, -1),\n+    LSTORE_W((ClassFile.WIDE << 8) | ClassFile.LSTORE, 4, Kind.STORE, TypeKind.LONG, -1),\n@@ -681,1 +681,1 @@\n-    FSTORE_W((ClassFile.WIDE << 8) | ClassFile.FSTORE, 4, Kind.STORE, TypeKind.FloatType, -1),\n+    FSTORE_W((ClassFile.WIDE << 8) | ClassFile.FSTORE, 4, Kind.STORE, TypeKind.FLOAT, -1),\n@@ -684,1 +684,1 @@\n-    DSTORE_W((ClassFile.WIDE << 8) | ClassFile.DSTORE, 4, Kind.STORE, TypeKind.DoubleType, -1),\n+    DSTORE_W((ClassFile.WIDE << 8) | ClassFile.DSTORE, 4, Kind.STORE, TypeKind.DOUBLE, -1),\n@@ -687,1 +687,1 @@\n-    ASTORE_W((ClassFile.WIDE << 8) | ClassFile.ASTORE, 4, Kind.STORE, TypeKind.ReferenceType, -1),\n+    ASTORE_W((ClassFile.WIDE << 8) | ClassFile.ASTORE, 4, Kind.STORE, TypeKind.REFERENCE, -1),\n@@ -696,1 +696,1 @@\n-    IINC_W((ClassFile.WIDE << 8) | ClassFile.IINC, 6, Kind.INCREMENT, TypeKind.IntType, -1);\n+    IINC_W((ClassFile.WIDE << 8) | ClassFile.IINC, 6, Kind.INCREMENT, TypeKind.INT, -1);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Opcode.java","additions":178,"deletions":178,"binary":false,"changes":356,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.lang.classfile.instruction.DiscontinuedInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n@@ -30,0 +33,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -32,1 +36,7 @@\n- * Describes the types that can be part of a field or method descriptor.\n+ * Describes the data types Java Virtual Machine operates on.\n+ * This omits {@code returnAddress} (JVMS {@jvms 2.3.3}),\n+ * which is only used by discontinued {@link\n+ * DiscontinuedInstruction.JsrInstruction jsr} and {@link\n+ * DiscontinuedInstruction.RetInstruction ret} instructions,\n+ * and includes {@link #VOID void} (JVMS {@jvms 4.3.3}), which\n+ * appears as a method return type.\n@@ -34,0 +44,12 @@\n+ * <h2 id=\"computational-type\">Computational Type<\/h2>\n+ * In the {@code class} file format, local variables (JVMS {@jvms 2.6.1}),\n+ * and the operand stack (JVMS {@jvms 2.6.2}) of the Java Virtual Machine,\n+ * {@link #BOOLEAN boolean}, {@link #BYTE byte}, {@link #CHAR char},\n+ * {@link #SHORT short} types do not exist and are {@linkplain\n+ * #asLoadable() represented} by the {@link #INT int} computational type.\n+ * {@link #INT int}, {@link #FLOAT float}, {@link #REFERENCE reference},\n+ * {@code returnAddress}, {@link #LONG long}, and {@link #DOUBLE doule}\n+ * are the computational types of the Java Virtual Machine.\n+ *\n+ * @jvms 2.2 Data Types\n+ * @jvms 2.11.1 Types and the Java Virtual Machine\n@@ -38,20 +60,67 @@\n-    \/** the primitive type byte *\/\n-    ByteType(\"byte\", \"B\", 8),\n-    \/** the primitive type short *\/\n-    ShortType(\"short\", \"S\", 9),\n-    \/** the primitive type int *\/\n-    IntType(\"int\", \"I\", 10),\n-    \/** the primitive type float *\/\n-    FloatType(\"float\", \"F\", 6),\n-    \/** the primitive type long *\/\n-    LongType(\"long\", \"J\", 11),\n-    \/** the primitive type double *\/\n-    DoubleType(\"double\", \"D\", 7),\n-    \/** a reference type *\/\n-    ReferenceType(\"reference type\", \"L\", -1),\n-    \/** the primitive type char *\/\n-    CharType(\"char\", \"C\", 5),\n-    \/** the primitive type boolean *\/\n-    BooleanType(\"boolean\", \"Z\", 4),\n-    \/** void *\/\n-    VoidType(\"void\", \"V\", -1);\n+    \/\/ Elements are grouped so frequently used switch ranges such as\n+    \/\/ primitives (boolean - double) and computational (int - void) are together.\n+    \/\/ This also follows the order of typed opcodes\n+    \/\/ Begin primitive types\n+    \/**\n+     * The primitive type {@code boolean}. Its {@linkplain ##computational-type\n+     * computational type} is {@link #INT int}. {@code 0} represents {@code false},\n+     * and {@code 1} represents {@code true}. It is zero-extended to an {@code int}\n+     * when loaded onto the operand stack and narrowed by taking the bitwise AND\n+     * with {@code 1} when stored.\n+     *\n+     * @jvms 2.3.4 The {@code boolean} Type\n+     *\/\n+    BOOLEAN(1, 4),\n+    \/**\n+     * The primitive type {@code byte}. Its {@linkplain ##computational-type\n+     * computational type} is {@link #INT int}. It is sign-extended to an\n+     * {@code int} when loaded onto the operand stack and truncated when\n+     * stored.\n+     *\/\n+    BYTE(1, 8),\n+    \/**\n+     * The primitive type {@code char}. Its {@linkplain ##computational-type\n+     * computational type} is {@link #INT int}. It is zero-extended to an\n+     * {@code int} when loaded onto the operand stack and truncated when\n+     * stored.\n+     *\/\n+    CHAR(1, 5),\n+    \/**\n+     * The primitive type {@code short}. Its {@linkplain ##computational-type\n+     * computational type} is {@link #INT int}. It is sign-extended to an\n+     * {@code int} when loaded onto the operand stack and truncated when\n+     * stored.\n+     *\/\n+    SHORT(1, 9),\n+    \/\/ Begin computational types\n+    \/**\n+     * The primitive type {@code int}.\n+     *\/\n+    INT(1, 10),\n+    \/**\n+     * The primitive type {@code long}. It is of {@linkplain #slotSize() category} 2.\n+     *\/\n+    LONG(2, 11),\n+    \/**\n+     * The primitive type {@code float}.\n+     *\/\n+    FLOAT(1, 6),\n+    \/**\n+     * The primitive type {@code double}. It is of {@linkplain #slotSize() category} 2.\n+     *\/\n+    DOUBLE(2, 7),\n+    \/\/ End primitive types\n+    \/**\n+     * A reference type.\n+     * @jvms 2.4 Reference Types and Values\n+     *\/\n+    REFERENCE(1, -1),\n+    \/**\n+     * The {@code void} type, for absence of a value. While this is not a data type,\n+     * this can be a method return type indicating no change in {@linkplain #slotSize()\n+     * operand stack depth}.\n+     *\n+     * @jvms 4.3.3 Method Descriptors\n+     *\/\n+    VOID(0, -1);\n+    \/\/ End computational types\n@@ -59,2 +128,2 @@\n-    private final String name;\n-    private final String descriptor;\n+    private @Stable ClassDesc upperBound;\n+    private final int slots;\n@@ -63,2 +132,4 @@\n-    \/** {@return the human-readable name corresponding to this type} *\/\n-    public String typeName() { return name; }\n+    TypeKind(int slots, int newarrayCode) {\n+        this.slots = slots;\n+        this.newarrayCode = newarrayCode;\n+    }\n@@ -66,2 +137,27 @@\n-    \/** {@return the field descriptor character corresponding to this type} *\/\n-    public String descriptor() { return descriptor; }\n+    \/**\n+     * {@return the most specific upper bound field descriptor that can store any value\n+     * of this type} This is the primitive class descriptor for primitive types and\n+     * {@link #VOID void} and {@link ConstantDescs#CD_Object Object} descriptor for\n+     * {@link #REFERENCE reference}.\n+     *\/\n+    public ClassDesc upperBound() {\n+        var upper = this.upperBound;\n+        if (upper == null)\n+            return this.upperBound = fetchUpperBound();\n+        return upper;\n+    }\n+\n+    private ClassDesc fetchUpperBound() {\n+        return switch (this) {\n+            case BOOLEAN -> ConstantDescs.CD_boolean;\n+            case BYTE -> ConstantDescs.CD_byte;\n+            case CHAR -> ConstantDescs.CD_char;\n+            case SHORT -> ConstantDescs.CD_short;\n+            case INT -> ConstantDescs.CD_int;\n+            case FLOAT -> ConstantDescs.CD_float;\n+            case LONG -> ConstantDescs.CD_long;\n+            case DOUBLE -> ConstantDescs.CD_double;\n+            case REFERENCE -> ConstantDescs.CD_Object;\n+            case VOID -> ConstantDescs.CD_void;\n+        };\n+    }\n@@ -70,1 +166,2 @@\n-     * {@return the code used by the {@code newarray} opcode corresponding to this type}\n+     * {@return the code used by the {@link Opcode#NEWARRAY newarray} instruction to create an array\n+     * of this component type, or {@code -1} if this type is not supported by {@code newarray}}\n@@ -72,0 +169,1 @@\n+     * @jvms 6.5.newarray <i>newarray<\/i>\n@@ -78,1 +176,6 @@\n-     * {@return the number of local variable slots consumed by this type}\n+     * {@return the number of local variable index or operand stack depth consumed by this type}\n+     * This is also the category of this type for instructions operating on the operand stack without\n+     * regard to type (JVMS {@jvms 2.11.1}), such as {@link Opcode#POP pop} versus {@link Opcode#POP2\n+     * pop2}.\n+     * @jvms 2.6.1 Local Variables\n+     * @jvms 2.6.2 Operand Stacks\n@@ -81,5 +184,1 @@\n-        return switch (this) {\n-            case VoidType -> 0;\n-            case LongType, DoubleType -> 2;\n-            default -> 1;\n-        };\n+        return this.slots;\n@@ -89,3 +188,2 @@\n-     * Erase this type kind to the type which will be used for xLOAD, xSTORE,\n-     * and xRETURN bytecodes\n-     * @return the erased type kind\n+     * {@return the {@linkplain ##computational-type computational type} for this type, or {@link #VOID void}\n+     * for {@code void}}\n@@ -94,10 +192,1 @@\n-        return switch (this) {\n-            case BooleanType, ByteType, CharType, ShortType -> TypeKind.IntType;\n-            default -> this;\n-        };\n-    }\n-\n-    TypeKind(String name, String descriptor, int newarrayCode) {\n-        this.name = name;\n-        this.descriptor = descriptor;\n-        this.newarrayCode = newarrayCode;\n+        return ordinal() < 4 ? INT : this;\n@@ -107,2 +196,2 @@\n-     * {@return the type kind associated with the array type described by the\n-     * array code used as an operand to {@code newarray}}\n+     * {@return the component type described by the array code used as an operand to {@link Opcode#NEWARRAY\n+     * newarray}}\n@@ -112,0 +201,1 @@\n+     * @jvms 6.5.newarray <i>newarray<\/i>\n@@ -115,8 +205,8 @@\n-            case 4 -> TypeKind.BooleanType;\n-            case 5 -> TypeKind.CharType;\n-            case 6 -> TypeKind.FloatType;\n-            case 7 -> TypeKind.DoubleType;\n-            case 8 -> TypeKind.ByteType;\n-            case 9 -> TypeKind.ShortType;\n-            case 10 -> TypeKind.IntType;\n-            case 11 -> TypeKind.LongType;\n+            case 4 -> BOOLEAN;\n+            case 5 -> CHAR;\n+            case 6 -> FLOAT;\n+            case 7 -> DOUBLE;\n+            case 8 -> BYTE;\n+            case 9 -> SHORT;\n+            case 10 -> INT;\n+            case 11 -> LONG;\n@@ -128,1 +218,1 @@\n-     * {@return the type kind associated with the specified field descriptor}\n+     * {@return the type associated with the specified field descriptor}\n@@ -137,10 +227,10 @@\n-            case '[', 'L' -> TypeKind.ReferenceType;\n-            case 'B' -> TypeKind.ByteType;\n-            case 'C' -> TypeKind.CharType;\n-            case 'Z' -> TypeKind.BooleanType;\n-            case 'S' -> TypeKind.ShortType;\n-            case 'I' -> TypeKind.IntType;\n-            case 'F' -> TypeKind.FloatType;\n-            case 'J' -> TypeKind.LongType;\n-            case 'D' -> TypeKind.DoubleType;\n-            case 'V' -> TypeKind.VoidType;\n+            case '[', 'L' -> REFERENCE;\n+            case 'B' -> BYTE;\n+            case 'C' -> CHAR;\n+            case 'Z' -> BOOLEAN;\n+            case 'S' -> SHORT;\n+            case 'I' -> INT;\n+            case 'F' -> FLOAT;\n+            case 'J' -> LONG;\n+            case 'D' -> DOUBLE;\n+            case 'V' -> VOID;\n@@ -152,1 +242,1 @@\n-     * {@return the type kind associated with the specified field descriptor}\n+     * {@return the type associated with the specified field descriptor}\n@@ -158,1 +248,1 @@\n-                : TypeKind.ReferenceType;\n+                : REFERENCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeKind.java","additions":160,"deletions":70,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,1 +184,1 @@\n-                                                    storeStack.push(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n+                                                    storeStack.push(StoreInstruction.of(TypeKind.REFERENCE, slot++));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/snippet-files\/PackageSnippets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        return TypeKind.DoubleType;\n+        return TypeKind.DOUBLE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/DoubleEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        return TypeKind.FloatType;\n+        return TypeKind.FLOAT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/FloatEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        return TypeKind.IntType;\n+        return TypeKind.INT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/IntegerEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-        return TypeKind.ReferenceType;\n+        return TypeKind.REFERENCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/LoadableConstantEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        return TypeKind.LongType;\n+        return TypeKind.LONG;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/LongEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,3 @@\n-     * {@return the component type of the array}\n+     * {@return the component type of the array} The {@link TypeKind#BYTE byte}\n+     * type load instruction {@link Opcode#BALOAD baload} also operates on\n+     * {@link TypeKind#BOOLEAN boolean} arrays.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ArrayLoadInstruction.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,3 @@\n-     * {@return the component type of the array}\n+     * {@return the component type of the array} The {@link TypeKind#BYTE byte}\n+     * type store instruction {@link Opcode#BASTORE bastore} also operates on\n+     * {@link TypeKind#BOOLEAN boolean} arrays.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ArrayStoreInstruction.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n@@ -147,2 +148,2 @@\n-     * @param op the opcode for the specific type of intrinsic constant instruction,\n-     *           which must be of kind {@link Opcode.Kind#CONSTANT}\n+     * @param op the opcode for the specific type of argument constant instruction,\n+     *           which must be {@link Opcode#BIPUSH} or {@link Opcode#SIPUSH}\n@@ -151,1 +152,2 @@\n-     *                                  or {@link Opcode#SIPUSH}\n+     *         or {@link Opcode#SIPUSH}, or if the constant value is out of range\n+     *         for the opcode\n@@ -154,2 +156,5 @@\n-        Util.checkKind(op, Opcode.Kind.CONSTANT);\n-        if (op != Opcode.BIPUSH && op != Opcode.SIPUSH)\n+        if (op == Opcode.BIPUSH) {\n+            BytecodeHelpers.validateBipush(value);\n+        } else if (op == Opcode.SIPUSH) {\n+            BytecodeHelpers.validateSipush(value);\n+        } else {\n@@ -157,0 +162,1 @@\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ConstantInstruction.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            throw new IllegalArgumentException(\"Illegal component type: \" + typeKind.typeName());\n+            throw new IllegalArgumentException(\"Illegal component type for primitive array: \" + typeKind.name());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewPrimitiveArrayInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,1 @@\n-                                                    storeStack.push(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n+                                                    storeStack.push(StoreInstruction.of(TypeKind.REFERENCE, slot++));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/snippet-files\/PackageSnippets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -577,1 +577,3 @@\n-     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}.\n+     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}. Moreover,\n+     * the value of {@code b} must be such that the computation for {@code offset} does not overflow,\n+     * or the returned method handle throws {@link ArithmeticException}.\n@@ -667,3 +669,4 @@\n-     * {@code P} and {@code P'} are derived, where P contains all the path elements from\n-     * 0 to {@code k - 1} and {@code P'} contains all the path elements from {@code k + 1}\n-     * to {@code m} (if any). Then, the returned var handle is computed as follows:\n+     * {@code P} and {@code Q} are derived, where P contains all the path elements from\n+     * 0 to {@code k - 1} and {@code Q} contains all the path elements from {@code k + 1}\n+     * to {@code m} ({@code Q} could be an empty layout path if {@code k == m}).\n+     * Then, the returned var handle is computed as follows:\n@@ -674,1 +677,1 @@\n-     * VarHandle targetHandle = target.varHandle(P);\n+     * VarHandle targetHandle = target.varHandle(Q);\n@@ -947,1 +950,1 @@\n-         *    <li>if {@code F < 0}, then {@code B = ceilDiv(-(S + 1), -F)}<\/li>\n+         *    <li>if {@code F < 0}, then {@code B = ceilDiv(S + 1, -F)}<\/li>\n@@ -975,2 +978,2 @@\n-         * {@return a path element that dereferences an address layout as its\n-         * {@linkplain AddressLayout#targetLayout() target layout} (where set)}\n+         * {@return a path element that selects the {@linkplain AddressLayout#targetLayout() target layout} of\n+         * an address layout (where set)}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n- *       ptr = z.reinterpret(16, arena, null);                       \/\/ size = 4, scope = arena.scope()\n+ *       ptr = z.reinterpret(16, arena, null);                       \/\/ size = 16, scope = arena.scope()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -371,3 +371,3 @@\n-            case BooleanType -> emitReferenceCast(cob, Boolean.class, null);\n-            case CharType -> emitReferenceCast(cob, Character.class, null);\n-            case ByteType, DoubleType, FloatType, IntType, LongType, ShortType ->\n+            case BOOLEAN -> emitReferenceCast(cob, Boolean.class, null);\n+            case CHAR -> emitReferenceCast(cob, Character.class, null);\n+            case BYTE, DOUBLE, FLOAT, INT, LONG, SHORT ->\n@@ -446,1 +446,1 @@\n-            emitStoreInsn(cob, TypeKind.ReferenceType, writeBack.index());\n+            emitStoreInsn(cob, TypeKind.REFERENCE, writeBack.index());\n@@ -904,1 +904,1 @@\n-        emitStoreInsn(cob, TypeKind.ReferenceType, receiver.index());  \/\/ store the MH in the receiver slot\n+        emitStoreInsn(cob, TypeKind.REFERENCE, receiver.index());  \/\/ store the MH in the receiver slot\n@@ -916,1 +916,1 @@\n-        emitStoreInsn(cob, TypeKind.ReferenceType, receiver.index());  \/\/ store the MH in the receiver slot\n+        emitStoreInsn(cob, TypeKind.REFERENCE, receiver.index());  \/\/ store the MH in the receiver slot\n@@ -1154,1 +1154,1 @@\n-        emitStoreInsn(cob, TypeKind.ReferenceType, casesLocal);\n+        emitStoreInsn(cob, TypeKind.REFERENCE, casesLocal);\n@@ -1175,1 +1175,1 @@\n-            emitLoadInsn(cob, TypeKind.ReferenceType, casesLocal);\n+            emitLoadInsn(cob, TypeKind.REFERENCE, casesLocal);\n@@ -1314,1 +1314,1 @@\n-        emitStoreInsn(cob, TypeKind.ReferenceType, clauseDataIndex);\n+        emitStoreInsn(cob, TypeKind.REFERENCE, clauseDataIndex);\n@@ -1401,1 +1401,1 @@\n-        emitLoadInsn(cob, TypeKind.ReferenceType, clauseDataSlot);\n+        emitLoadInsn(cob, TypeKind.REFERENCE, clauseDataSlot);\n@@ -1500,1 +1500,1 @@\n-        if (from != to && from != TypeKind.BooleanType) try {\n+        if (from != to && from != TypeKind.BOOLEAN) try {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -141,6 +141,6 @@\n-        L_TYPE('L', Object.class, Wrapper.OBJECT, TypeKind.ReferenceType), \/\/ all reference types\n-        I_TYPE('I', int.class,    Wrapper.INT,    TypeKind.IntType),\n-        J_TYPE('J', long.class,   Wrapper.LONG,   TypeKind.LongType),\n-        F_TYPE('F', float.class,  Wrapper.FLOAT,  TypeKind.FloatType),\n-        D_TYPE('D', double.class, Wrapper.DOUBLE, TypeKind.DoubleType),  \/\/ all primitive types\n-        V_TYPE('V', void.class,   Wrapper.VOID,   TypeKind.VoidType);    \/\/ not valid in all contexts\n+        L_TYPE('L', Object.class, Wrapper.OBJECT, TypeKind.REFERENCE), \/\/ all reference types\n+        I_TYPE('I', int.class,    Wrapper.INT,    TypeKind.INT),\n+        J_TYPE('J', long.class,   Wrapper.LONG,   TypeKind.LONG),\n+        F_TYPE('F', float.class,  Wrapper.FLOAT,  TypeKind.FLOAT),\n+        D_TYPE('D', double.class, Wrapper.DOUBLE, TypeKind.DOUBLE),  \/\/ all primitive types\n+        V_TYPE('V', void.class,   Wrapper.VOID,   TypeKind.VOID);    \/\/ not valid in all contexts\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,2 +52,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -1422,5 +1420,5 @@\n-                        lengthSlot    = cb.allocateLocal(TypeKind.IntType),\n-                        coderSlot     = cb.allocateLocal(TypeKind.ByteType),\n-                        bufSlot       = cb.allocateLocal(TypeKind.ReferenceType),\n-                        constantsSlot = cb.allocateLocal(TypeKind.ReferenceType),\n-                        suffixSlot    = cb.allocateLocal(TypeKind.ReferenceType);\n+                        lengthSlot    = cb.allocateLocal(TypeKind.INT),\n+                        coderSlot     = cb.allocateLocal(TypeKind.BYTE),\n+                        bufSlot       = cb.allocateLocal(TypeKind.REFERENCE),\n+                        constantsSlot = cb.allocateLocal(TypeKind.REFERENCE),\n+                        suffixSlot    = cb.allocateLocal(TypeKind.REFERENCE);\n@@ -1450,1 +1448,1 @@\n-                            stringSlots[i] = cb.allocateLocal(TypeKind.ReferenceType);\n+                            stringSlots[i] = cb.allocateLocal(TypeKind.REFERENCE);\n@@ -1467,1 +1465,1 @@\n-                                    cb.loadLocal(TypeKind.CharType, cb.parameterSlot(i));\n+                                    cb.loadLocal(TypeKind.CHAR, cb.parameterSlot(i));\n@@ -1534,1 +1532,1 @@\n-                            kind = TypeKind.ReferenceType;\n+                            kind = TypeKind.REFERENCE;\n@@ -1685,1 +1683,1 @@\n-                            kind = TypeKind.ReferenceType;\n+                            kind = TypeKind.REFERENCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -72,8 +72,8 @@\n-        if (type == Integer.class)   return TypeKind.IntType;\n-        if (type == Long.class)      return TypeKind.LongType;\n-        if (type == Boolean.class)   return TypeKind.BooleanType;\n-        if (type == Short.class)     return TypeKind.ShortType;\n-        if (type == Byte.class)      return TypeKind.ByteType;\n-        if (type == Character.class) return TypeKind.CharType;\n-        if (type == Float.class)     return TypeKind.FloatType;\n-        if (type == Double.class)    return TypeKind.DoubleType;\n+        if (type == Integer.class)   return TypeKind.INT;\n+        if (type == Long.class)      return TypeKind.LONG;\n+        if (type == Boolean.class)   return TypeKind.BOOLEAN;\n+        if (type == Short.class)     return TypeKind.SHORT;\n+        if (type == Byte.class)      return TypeKind.BYTE;\n+        if (type == Character.class) return TypeKind.CHAR;\n+        if (type == Float.class)     return TypeKind.FLOAT;\n+        if (type == Double.class)    return TypeKind.DOUBLE;\n@@ -97,8 +97,8 @@\n-            case BooleanType -> cob.invokestatic(BoxHolder.BOX_BOOLEAN);\n-            case ByteType    -> cob.invokestatic(BoxHolder.BOX_BYTE);\n-            case CharType    -> cob.invokestatic(BoxHolder.BOX_CHAR);\n-            case DoubleType  -> cob.invokestatic(BoxHolder.BOX_DOUBLE);\n-            case FloatType   -> cob.invokestatic(BoxHolder.BOX_FLOAT);\n-            case IntType     -> cob.invokestatic(BoxHolder.BOX_INT);\n-            case LongType    -> cob.invokestatic(BoxHolder.BOX_LONG);\n-            case ShortType   -> cob.invokestatic(BoxHolder.BOX_SHORT);\n+            case BOOLEAN -> cob.invokestatic(BoxHolder.BOX_BOOLEAN);\n+            case BYTE -> cob.invokestatic(BoxHolder.BOX_BYTE);\n+            case CHAR -> cob.invokestatic(BoxHolder.BOX_CHAR);\n+            case DOUBLE -> cob.invokestatic(BoxHolder.BOX_DOUBLE);\n+            case FLOAT -> cob.invokestatic(BoxHolder.BOX_FLOAT);\n+            case INT -> cob.invokestatic(BoxHolder.BOX_INT);\n+            case LONG -> cob.invokestatic(BoxHolder.BOX_LONG);\n+            case SHORT -> cob.invokestatic(BoxHolder.BOX_SHORT);\n@@ -110,8 +110,8 @@\n-            case BooleanType -> cob.invokevirtual(BoxHolder.UNBOX_BOOLEAN);\n-            case ByteType    -> cob.invokevirtual(BoxHolder.UNBOX_BYTE);\n-            case CharType    -> cob.invokevirtual(BoxHolder.UNBOX_CHAR);\n-            case DoubleType  -> cob.invokevirtual(BoxHolder.UNBOX_DOUBLE);\n-            case FloatType   -> cob.invokevirtual(BoxHolder.UNBOX_FLOAT);\n-            case IntType     -> cob.invokevirtual(BoxHolder.UNBOX_INT);\n-            case LongType    -> cob.invokevirtual(BoxHolder.UNBOX_LONG);\n-            case ShortType   -> cob.invokevirtual(BoxHolder.UNBOX_SHORT);\n+            case BOOLEAN -> cob.invokevirtual(BoxHolder.UNBOX_BOOLEAN);\n+            case BYTE -> cob.invokevirtual(BoxHolder.UNBOX_BYTE);\n+            case CHAR -> cob.invokevirtual(BoxHolder.UNBOX_CHAR);\n+            case DOUBLE -> cob.invokevirtual(BoxHolder.UNBOX_DOUBLE);\n+            case FLOAT -> cob.invokevirtual(BoxHolder.UNBOX_FLOAT);\n+            case INT -> cob.invokevirtual(BoxHolder.UNBOX_INT);\n+            case LONG -> cob.invokevirtual(BoxHolder.UNBOX_LONG);\n+            case SHORT -> cob.invokevirtual(BoxHolder.UNBOX_SHORT);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/TypeConvertingMethodAdapter.java","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -655,1 +655,0 @@\n-                val = getNumberValue(number, divisor);\n@@ -657,0 +656,3 @@\n+            roundedNumber = roundedNumber \/ divisor;\n+            decimalFormat.setDigitList(roundedNumber, isNegative, getMaximumFractionDigits());\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -663,2 +665,0 @@\n-                    roundedNumber = roundedNumber \/ divisor;\n-                    decimalFormat.setDigitList(roundedNumber, isNegative, getMaximumFractionDigits());\n@@ -737,1 +737,0 @@\n-                val = getNumberValue(number, divisor);\n@@ -739,0 +738,12 @@\n+            var noFraction = number % divisor == 0;\n+            if (noFraction) {\n+                number = number \/ divisor;\n+                decimalFormat.setDigitList(number, isNegative, 0);\n+            } else {\n+                \/\/ To avoid truncation of fractional part store\n+                \/\/ the value in double and follow double path instead of\n+                \/\/ long path\n+                double dNumber = (double) number \/ divisor;\n+                decimalFormat.setDigitList(dNumber, isNegative, getMaximumFractionDigits());\n+            }\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -744,18 +755,4 @@\n-                    if ((number % divisor == 0)) {\n-                        number = number \/ divisor;\n-                        decimalFormat.setDigitList(number, isNegative, 0);\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, true, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    } else {\n-                        \/\/ To avoid truncation of fractional part store\n-                        \/\/ the value in double and follow double path instead of\n-                        \/\/ long path\n-                        double dNumber = (double) number \/ divisor;\n-                        decimalFormat.setDigitList(dNumber, isNegative, getMaximumFractionDigits());\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, false, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    }\n+                    decimalFormat.subformatNumber(result, delegate,\n+                            isNegative, noFraction, getMaximumIntegerDigits(),\n+                            getMinimumIntegerDigits(), getMaximumFractionDigits(),\n+                            getMinimumFractionDigits());\n@@ -836,1 +833,0 @@\n-                val = getNumberValue(number.doubleValue(), divisor.doubleValue());\n@@ -838,0 +834,3 @@\n+            number = number.divide(new BigDecimal(divisor.toString()), getRoundingMode());\n+            decimalFormat.setDigitList(number, isNegative, getMaximumFractionDigits());\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -843,2 +842,0 @@\n-                    number = number.divide(new BigDecimal(divisor.toString()), getRoundingMode());\n-                    decimalFormat.setDigitList(number, isNegative, getMaximumFractionDigits());\n@@ -907,1 +904,0 @@\n-                val = getNumberValue(number.doubleValue(), divisor.doubleValue());\n@@ -909,0 +905,14 @@\n+            var noFraction = number.mod(new BigInteger(divisor.toString()))\n+                    .compareTo(BigInteger.ZERO) == 0;\n+            if (noFraction) {\n+                number = number.divide(new BigInteger(divisor.toString()));\n+                decimalFormat.setDigitList(number, isNegative, 0);\n+            } else {\n+                \/\/ To avoid truncation of fractional part store the value in\n+                \/\/ BigDecimal and follow BigDecimal path instead of\n+                \/\/ BigInteger path\n+                BigDecimal nDecimal = new BigDecimal(number)\n+                        .divide(new BigDecimal(divisor.toString()), getRoundingMode());\n+                decimalFormat.setDigitList(nDecimal, isNegative, getMaximumFractionDigits());\n+            }\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -914,21 +924,4 @@\n-                    if (number.mod(new BigInteger(divisor.toString()))\n-                            .compareTo(BigInteger.ZERO) == 0) {\n-                        number = number.divide(new BigInteger(divisor.toString()));\n-\n-                        decimalFormat.setDigitList(number, isNegative, 0);\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, true, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    } else {\n-                        \/\/ To avoid truncation of fractional part store the value in\n-                        \/\/ BigDecimal and follow BigDecimal path instead of\n-                        \/\/ BigInteger path\n-                        BigDecimal nDecimal = new BigDecimal(number)\n-                                .divide(new BigDecimal(divisor.toString()), getRoundingMode());\n-                        decimalFormat.setDigitList(nDecimal, isNegative, getMaximumFractionDigits());\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, false, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    }\n+                    decimalFormat.subformatNumber(result, delegate,\n+                        isNegative, noFraction, getMaximumIntegerDigits(),\n+                        getMinimumIntegerDigits(), getMaximumFractionDigits(),\n+                        getMinimumFractionDigits());\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":40,"deletions":47,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1802,0 +1802,8 @@\n+    \/**\n+     * {@return the {@code DigitList} used by this {@code DecimalFormat} instance}\n+     * Declared as package-private, intended for {@code CompactNumberFormat}.\n+     *\/\n+    DigitList getDigitList() {\n+        return digitList;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -695,1 +695,4 @@\n-     * does not necessarily equal the previously applied pattern.\n+     * does not necessarily equal the previously applied pattern. The order of\n+     * {@code FormatStyle} matching is not guaranteed. That is, a {@code\n+     * FormatStyle} produced may not be equivalent to the corresponding style passed,\n+     * in the instance that multiple styles are equivalent.\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1969,0 +1969,8 @@\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Prints the toString result to the given buf, avoiding extra string allocations.\n+     *\/\n+    void formatTo(StringBuilder buf) {\n@@ -1972,1 +1980,0 @@\n-        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1926,1 +1926,4 @@\n-        return dateTime.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var buf = new StringBuilder(29 + offsetStr.length());\n+        dateTime.formatTo(buf);\n+        return buf.append(offsetStr).toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetDateTime.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1401,1 +1401,4 @@\n-        return time.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var buf = new StringBuilder(18 + offsetStr.length());\n+        time.formatTo(buf);\n+        return buf.append(offsetStr).toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetTime.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2217,1 +2217,3 @@\n-        String str = dateTime.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var zoneStr = (String) null;\n+        int length = 29 + offsetStr.length();\n@@ -2219,1 +2221,2 @@\n-            str += '[' + zone.toString() + ']';\n+            zoneStr = zone.toString();\n+            length += zoneStr.length() + 2;\n@@ -2221,1 +2224,7 @@\n-        return str;\n+        var buf = new StringBuilder(length);\n+        dateTime.formatTo(buf);\n+        buf.append(offsetStr);\n+        if (zoneStr != null) {\n+            buf.append('[').append(zoneStr).append(']');\n+        }\n+        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -991,1 +991,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(baseloc, LOCALE_CREATOR);\n+            return LocaleCache.cache(baseloc);\n@@ -994,1 +994,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n+            return LocaleCache.cache(key);\n@@ -998,2 +998,9 @@\n-    private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n-            = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+    private static final class LocaleCache implements Function<Object, Locale> {\n+        private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n+                = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+\n+        private static final Function<Object, Locale> LOCALE_CREATOR = new LocaleCache();\n+\n+        public static Locale cache(Object key) {\n+            return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n+        }\n@@ -1001,1 +1008,0 @@\n-    private static final Function<Object, Locale> LOCALE_CREATOR = new Function<>() {\n@@ -1010,1 +1016,1 @@\n-    };\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -185,0 +185,5 @@\n+    \/**\n+     * Maximum delay is effectively 146 years\n+     *\/\n+    private static final long MAX_NANOS = (Long.MAX_VALUE >>> 1) - 1;\n+\n@@ -528,19 +533,1 @@\n-        return System.nanoTime() +\n-            ((delay < (Long.MAX_VALUE >> 1)) ? delay : overflowFree(delay));\n-    }\n-\n-    \/**\n-     * Constrains the values of all delays in the queue to be within\n-     * Long.MAX_VALUE of each other, to avoid overflow in compareTo.\n-     * This may occur if a task is eligible to be dequeued, but has\n-     * not yet been, while some other task is added with a delay of\n-     * Long.MAX_VALUE.\n-     *\/\n-    private long overflowFree(long delay) {\n-        Delayed head = (Delayed) super.getQueue().peek();\n-        if (head != null) {\n-            long headDelay = head.getDelay(NANOSECONDS);\n-            if (headDelay < 0 && (delay - headDelay < 0))\n-                delay = Long.MAX_VALUE + headDelay;\n-        }\n-        return delay;\n+        return System.nanoTime() + Math.min(delay, MAX_NANOS);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ScheduledThreadPoolExecutor.java","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -280,0 +280,34 @@\n+    \/**\n+     * Repeatedly invokes acquire, if its execution throws an Error or a Runtime Exception,\n+     * using an Unsafe.park-based backoff\n+     * @param node which to reacquire\n+     * @param arg the acquire argument\n+     *\/\n+    private final void reacquire(Node node, long arg) {\n+        try {\n+            acquire(node, arg, false, false, false, 0L);\n+        } catch (Error | RuntimeException firstEx) {\n+            \/\/ While we currently do not emit an JFR events in this situation, mainly\n+            \/\/ because the conditions under which this happens are such that it\n+            \/\/ cannot be presumed to be possible to actually allocate an event, and\n+            \/\/ using a preconstructed one would have limited value in serviceability.\n+            \/\/ Having said that, the following place would be the more appropriate\n+            \/\/ place to put such logic:\n+            \/\/     emit JFR event\n+\n+            for (long nanos = 1L;;) {\n+                U.park(false, nanos); \/\/ must use Unsafe park to sleep\n+                if (nanos < 1L << 30)            \/\/ max about 1 second\n+                    nanos <<= 1;\n+\n+                try {\n+                    acquire(node, arg, false, false, false, 0L);\n+                } catch (Error | RuntimeException ignored) {\n+                    continue;\n+                }\n+\n+                throw firstEx;\n+            }\n+        }\n+    }\n+\n@@ -1302,1 +1336,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1349,1 +1383,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1392,1 +1426,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1436,1 +1470,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1481,1 +1515,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedLongSynchronizer.java","additions":39,"deletions":5,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -659,0 +659,34 @@\n+    \/**\n+     * Repeatedly invokes acquire, if its execution throws an Error or a Runtime Exception,\n+     * using an Unsafe.park-based backoff\n+     * @param node which to reacquire\n+     * @param arg the acquire argument\n+     *\/\n+    private final void reacquire(Node node, int arg) {\n+        try {\n+            acquire(node, arg, false, false, false, 0L);\n+        } catch (Error | RuntimeException firstEx) {\n+            \/\/ While we currently do not emit an JFR events in this situation, mainly\n+            \/\/ because the conditions under which this happens are such that it\n+            \/\/ cannot be presumed to be possible to actually allocate an event, and\n+            \/\/ using a preconstructed one would have limited value in serviceability.\n+            \/\/ Having said that, the following place would be the more appropriate\n+            \/\/ place to put such logic:\n+            \/\/     emit JFR event\n+\n+            for (long nanos = 1L;;) {\n+                U.park(false, nanos); \/\/ must use Unsafe park to sleep\n+                if (nanos < 1L << 30)            \/\/ max about 1 second\n+                    nanos <<= 1;\n+\n+                try {\n+                    acquire(node, arg, false, false, false, 0L);\n+                } catch (Error | RuntimeException ignored) {\n+                    continue;\n+                }\n+\n+                throw firstEx;\n+            }\n+        }\n+    }\n+\n@@ -1681,1 +1715,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1728,1 +1762,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1771,1 +1805,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1815,1 +1849,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1860,1 +1894,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedSynchronizer.java","additions":39,"deletions":5,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1320,5 +1320,0 @@\n-        @Override\n-        public void writeTo(DirectCodeBuilder writer) {\n-            super.writeTo(writer);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1033,8 +1033,1 @@\n-    abstract static sealed class PrimitiveEntry<T extends ConstantDesc>\n-            extends AbstractPoolEntry {\n-        protected final T val;\n-\n-        public PrimitiveEntry(ConstantPool constantPool, int tag, int index, T val) {\n-            super(constantPool, tag, index, hash1(tag, val.hashCode()));\n-            this.val = val;\n-        }\n+    public static final class IntegerEntryImpl extends AbstractPoolEntry implements IntegerEntry {\n@@ -1042,16 +1035,1 @@\n-        public T value() {\n-            return val;\n-        }\n-\n-        public ConstantDesc constantValue() {\n-            return value();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"\" + tag() + value();\n-        }\n-    }\n-\n-    public static final class IntegerEntryImpl extends PrimitiveEntry<Integer>\n-            implements IntegerEntry {\n+        private final int val;\n@@ -1060,1 +1038,2 @@\n-            super(cpm, ClassFile.TAG_INTEGER, index, i);\n+            super(cpm, ClassFile.TAG_INTEGER, index, hash1(ClassFile.TAG_INTEGER, Integer.hashCode(i)));\n+            val = i;\n@@ -1076,1 +1055,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1089,1 +1073,1 @@\n-    public static final class FloatEntryImpl extends PrimitiveEntry<Float>\n+    public static final class FloatEntryImpl extends AbstractPoolEntry\n@@ -1092,0 +1076,2 @@\n+        private final float val;\n+\n@@ -1093,1 +1079,2 @@\n-            super(cpm, ClassFile.TAG_FLOAT, index, f);\n+            super(cpm, ClassFile.TAG_FLOAT, index, hash1(ClassFile.TAG_FLOAT, Float.hashCode(f)));\n+            val = f;\n@@ -1109,1 +1096,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1122,1 +1114,3 @@\n-    public static final class LongEntryImpl extends PrimitiveEntry<Long> implements LongEntry {\n+    public static final class LongEntryImpl extends AbstractPoolEntry implements LongEntry {\n+\n+        private final long val;\n@@ -1125,1 +1119,2 @@\n-            super(cpm, ClassFile.TAG_LONG, index, l);\n+            super(cpm, ClassFile.TAG_LONG, index, hash1(ClassFile.TAG_LONG, Long.hashCode(l)));\n+            val = l;\n@@ -1141,1 +1136,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1154,1 +1154,3 @@\n-    public static final class DoubleEntryImpl extends PrimitiveEntry<Double> implements DoubleEntry {\n+    public static final class DoubleEntryImpl extends AbstractPoolEntry implements DoubleEntry {\n+\n+        private final double val;\n@@ -1157,1 +1159,2 @@\n-            super(cpm, ClassFile.TAG_DOUBLE, index, d);\n+            super(cpm, ClassFile.TAG_DOUBLE, index, hash1(ClassFile.TAG_DOUBLE, Double.hashCode(d)));\n+            val = d;\n@@ -1173,1 +1176,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":43,"deletions":35,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-        writeIntBytes(1, x);\n+        reserveSpace(1);\n+        elems[offset++] = (byte) x;\n@@ -99,1 +100,6 @@\n-        writeIntBytes(2, x);\n+        reserveSpace(2);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 8);\n+        elems[offset + 1] = (byte) x;\n+        this.offset = offset + 2;\n@@ -104,1 +110,8 @@\n-        writeIntBytes(4, x);\n+        reserveSpace(4);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 24);\n+        elems[offset + 1] = (byte) (x >> 16);\n+        elems[offset + 2] = (byte) (x >> 8);\n+        elems[offset + 3] = (byte)  x;\n+        this.offset = offset + 4;\n@@ -114,1 +127,12 @@\n-        writeIntBytes(8, x);\n+        reserveSpace(8);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 56);\n+        elems[offset + 1] = (byte) (x >> 48);\n+        elems[offset + 2] = (byte) (x >> 40);\n+        elems[offset + 3] = (byte) (x >> 32);\n+        elems[offset + 4] = (byte) (x >> 24);\n+        elems[offset + 5] = (byte) (x >> 16);\n+        elems[offset + 6] = (byte) (x >> 8);\n+        elems[offset + 7] = (byte)  x;\n+        this.offset = offset + 8;\n@@ -156,6 +180,3 @@\n-        if (offset + freeBytes > elems.length) {\n-            int newsize = elems.length * 2;\n-            while (offset + freeBytes > newsize) {\n-                newsize *= 2;\n-            }\n-            elems = Arrays.copyOf(elems, newsize);\n+        int minCapacity = offset + freeBytes;\n+        if (minCapacity > elems.length) {\n+            grow(minCapacity);\n@@ -165,0 +186,8 @@\n+    private void grow(int minCapacity) {\n+        int newsize = elems.length * 2;\n+        while (minCapacity > newsize) {\n+            newsize *= 2;\n+        }\n+        elems = Arrays.copyOf(elems, newsize);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":39,"deletions":10,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -53,0 +54,4 @@\n+    public static IllegalArgumentException cannotConvertException(TypeKind from, TypeKind to) {\n+        return new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+    }\n+\n@@ -55,36 +60,57 @@\n-            case IntType, ShortType, ByteType, CharType, BooleanType -> switch (slot) {\n-                case 0 -> Opcode.ILOAD_0;\n-                case 1 -> Opcode.ILOAD_1;\n-                case 2 -> Opcode.ILOAD_2;\n-                case 3 -> Opcode.ILOAD_3;\n-                default -> (slot < 256) ? Opcode.ILOAD : Opcode.ILOAD_W;\n-            };\n-            case LongType -> switch (slot) {\n-                case 0 -> Opcode.LLOAD_0;\n-                case 1 -> Opcode.LLOAD_1;\n-                case 2 -> Opcode.LLOAD_2;\n-                case 3 -> Opcode.LLOAD_3;\n-                default -> (slot < 256) ? Opcode.LLOAD : Opcode.LLOAD_W;\n-            };\n-            case DoubleType -> switch (slot) {\n-                case 0 -> Opcode.DLOAD_0;\n-                case 1 -> Opcode.DLOAD_1;\n-                case 2 -> Opcode.DLOAD_2;\n-                case 3 -> Opcode.DLOAD_3;\n-                default -> (slot < 256) ? Opcode.DLOAD : Opcode.DLOAD_W;\n-            };\n-            case FloatType -> switch (slot) {\n-                case 0 -> Opcode.FLOAD_0;\n-                case 1 -> Opcode.FLOAD_1;\n-                case 2 -> Opcode.FLOAD_2;\n-                case 3 -> Opcode.FLOAD_3;\n-                default -> (slot < 256) ? Opcode.FLOAD : Opcode.FLOAD_W;\n-            };\n-            case ReferenceType -> switch (slot) {\n-                case 0 -> Opcode.ALOAD_0;\n-                case 1 -> Opcode.ALOAD_1;\n-                case 2 -> Opcode.ALOAD_2;\n-                case 3 -> Opcode.ALOAD_3;\n-                default -> (slot < 256) ? Opcode.ALOAD : Opcode.ALOAD_W;\n-            };\n-            case VoidType -> throw new IllegalArgumentException(\"void\");\n+            case INT, SHORT, BYTE, CHAR, BOOLEAN\n+                           -> iload(slot);\n+            case LONG      -> lload(slot);\n+            case DOUBLE    -> dload(slot);\n+            case FLOAT     -> fload(slot);\n+            case REFERENCE -> aload(slot);\n+            case VOID      -> throw new IllegalArgumentException(\"void\");\n+        };\n+    }\n+\n+    public static Opcode aload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.ALOAD_0;\n+            case 1 -> Opcode.ALOAD_1;\n+            case 2 -> Opcode.ALOAD_2;\n+            case 3 -> Opcode.ALOAD_3;\n+            default -> (slot < 256) ? Opcode.ALOAD : Opcode.ALOAD_W;\n+        };\n+    }\n+\n+    public static Opcode fload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.FLOAD_0;\n+            case 1 -> Opcode.FLOAD_1;\n+            case 2 -> Opcode.FLOAD_2;\n+            case 3 -> Opcode.FLOAD_3;\n+            default -> (slot < 256) ? Opcode.FLOAD : Opcode.FLOAD_W;\n+        };\n+    }\n+\n+    public static Opcode dload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.DLOAD_0;\n+            case 1 -> Opcode.DLOAD_1;\n+            case 2 -> Opcode.DLOAD_2;\n+            case 3 -> Opcode.DLOAD_3;\n+            default -> (slot < 256) ? Opcode.DLOAD : Opcode.DLOAD_W;\n+        };\n+    }\n+\n+    public static Opcode lload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.LLOAD_0;\n+            case 1 -> Opcode.LLOAD_1;\n+            case 2 -> Opcode.LLOAD_2;\n+            case 3 -> Opcode.LLOAD_3;\n+            default -> (slot < 256) ? Opcode.LLOAD : Opcode.LLOAD_W;\n+        };\n+    }\n+\n+    public static Opcode iload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.ILOAD_0;\n+            case 1 -> Opcode.ILOAD_1;\n+            case 2 -> Opcode.ILOAD_2;\n+            case 3 -> Opcode.ILOAD_3;\n+            default -> (slot < 256) ? Opcode.ILOAD : Opcode.ILOAD_W;\n@@ -96,36 +122,57 @@\n-            case IntType, ShortType, ByteType, CharType, BooleanType -> switch (slot) {\n-                case 0 -> Opcode.ISTORE_0;\n-                case 1 -> Opcode.ISTORE_1;\n-                case 2 -> Opcode.ISTORE_2;\n-                case 3 -> Opcode.ISTORE_3;\n-                default -> (slot < 256) ? Opcode.ISTORE : Opcode.ISTORE_W;\n-            };\n-            case LongType -> switch (slot) {\n-                case 0 -> Opcode.LSTORE_0;\n-                case 1 -> Opcode.LSTORE_1;\n-                case 2 -> Opcode.LSTORE_2;\n-                case 3 -> Opcode.LSTORE_3;\n-                default -> (slot < 256) ? Opcode.LSTORE : Opcode.LSTORE_W;\n-            };\n-            case DoubleType -> switch (slot) {\n-                case 0 -> Opcode.DSTORE_0;\n-                case 1 -> Opcode.DSTORE_1;\n-                case 2 -> Opcode.DSTORE_2;\n-                case 3 -> Opcode.DSTORE_3;\n-                default -> (slot < 256) ? Opcode.DSTORE : Opcode.DSTORE_W;\n-            };\n-            case FloatType -> switch (slot) {\n-                case 0 -> Opcode.FSTORE_0;\n-                case 1 -> Opcode.FSTORE_1;\n-                case 2 -> Opcode.FSTORE_2;\n-                case 3 -> Opcode.FSTORE_3;\n-                default -> (slot < 256) ? Opcode.FSTORE : Opcode.FSTORE_W;\n-            };\n-            case ReferenceType -> switch (slot) {\n-                case 0 -> Opcode.ASTORE_0;\n-                case 1 -> Opcode.ASTORE_1;\n-                case 2 -> Opcode.ASTORE_2;\n-                case 3 -> Opcode.ASTORE_3;\n-                default -> (slot < 256) ? Opcode.ASTORE : Opcode.ASTORE_W;\n-            };\n-            case VoidType -> throw new IllegalArgumentException(\"void\");\n+            case INT, SHORT, BYTE, CHAR, BOOLEAN\n+                           -> istore(slot);\n+            case LONG      -> lstore(slot);\n+            case DOUBLE    -> dstore(slot);\n+            case FLOAT     -> fstore(slot);\n+            case REFERENCE -> astore(slot);\n+            case VOID      -> throw new IllegalArgumentException(\"void\");\n+        };\n+    }\n+\n+    public static Opcode astore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.ASTORE_0;\n+            case 1 -> Opcode.ASTORE_1;\n+            case 2 -> Opcode.ASTORE_2;\n+            case 3 -> Opcode.ASTORE_3;\n+            default -> (slot < 256) ? Opcode.ASTORE : Opcode.ASTORE_W;\n+        };\n+    }\n+\n+    public static Opcode fstore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.FSTORE_0;\n+            case 1 -> Opcode.FSTORE_1;\n+            case 2 -> Opcode.FSTORE_2;\n+            case 3 -> Opcode.FSTORE_3;\n+            default -> (slot < 256) ? Opcode.FSTORE : Opcode.FSTORE_W;\n+        };\n+    }\n+\n+    public static Opcode dstore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.DSTORE_0;\n+            case 1 -> Opcode.DSTORE_1;\n+            case 2 -> Opcode.DSTORE_2;\n+            case 3 -> Opcode.DSTORE_3;\n+            default -> (slot < 256) ? Opcode.DSTORE : Opcode.DSTORE_W;\n+        };\n+    }\n+\n+    public static Opcode lstore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.LSTORE_0;\n+            case 1 -> Opcode.LSTORE_1;\n+            case 2 -> Opcode.LSTORE_2;\n+            case 3 -> Opcode.LSTORE_3;\n+            default -> (slot < 256) ? Opcode.LSTORE : Opcode.LSTORE_W;\n+        };\n+    }\n+\n+    public static Opcode istore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.ISTORE_0;\n+            case 1 -> Opcode.ISTORE_1;\n+            case 2 -> Opcode.ISTORE_2;\n+            case 3 -> Opcode.ISTORE_3;\n+            default -> (slot < 256) ? Opcode.ISTORE : Opcode.ISTORE_W;\n@@ -137,6 +184,6 @@\n-            case ByteType, ShortType, IntType, CharType, BooleanType -> Opcode.IRETURN;\n-            case FloatType -> Opcode.FRETURN;\n-            case LongType -> Opcode.LRETURN;\n-            case DoubleType -> Opcode.DRETURN;\n-            case ReferenceType -> Opcode.ARETURN;\n-            case VoidType -> Opcode.RETURN;\n+            case BYTE, SHORT, INT, CHAR, BOOLEAN -> Opcode.IRETURN;\n+            case FLOAT -> Opcode.FRETURN;\n+            case LONG -> Opcode.LRETURN;\n+            case DOUBLE -> Opcode.DRETURN;\n+            case REFERENCE -> Opcode.ARETURN;\n+            case VOID -> Opcode.RETURN;\n@@ -148,9 +195,9 @@\n-            case ByteType, BooleanType -> Opcode.BALOAD;\n-            case ShortType -> Opcode.SALOAD;\n-            case IntType -> Opcode.IALOAD;\n-            case FloatType -> Opcode.FALOAD;\n-            case LongType -> Opcode.LALOAD;\n-            case DoubleType -> Opcode.DALOAD;\n-            case ReferenceType -> Opcode.AALOAD;\n-            case CharType -> Opcode.CALOAD;\n-            case VoidType -> throw new IllegalArgumentException(\"void not an allowable array type\");\n+            case BYTE, BOOLEAN -> Opcode.BALOAD;\n+            case SHORT -> Opcode.SALOAD;\n+            case INT -> Opcode.IALOAD;\n+            case FLOAT -> Opcode.FALOAD;\n+            case LONG -> Opcode.LALOAD;\n+            case DOUBLE -> Opcode.DALOAD;\n+            case REFERENCE -> Opcode.AALOAD;\n+            case CHAR -> Opcode.CALOAD;\n+            case VOID -> throw new IllegalArgumentException(\"void not an allowable array type\");\n@@ -162,9 +209,9 @@\n-            case ByteType, BooleanType -> Opcode.BASTORE;\n-            case ShortType -> Opcode.SASTORE;\n-            case IntType -> Opcode.IASTORE;\n-            case FloatType -> Opcode.FASTORE;\n-            case LongType -> Opcode.LASTORE;\n-            case DoubleType -> Opcode.DASTORE;\n-            case ReferenceType -> Opcode.AASTORE;\n-            case CharType -> Opcode.CASTORE;\n-            case VoidType -> throw new IllegalArgumentException(\"void not an allowable array type\");\n+            case BYTE, BOOLEAN -> Opcode.BASTORE;\n+            case SHORT -> Opcode.SASTORE;\n+            case INT -> Opcode.IASTORE;\n+            case FLOAT -> Opcode.FASTORE;\n+            case LONG -> Opcode.LASTORE;\n+            case DOUBLE -> Opcode.DASTORE;\n+            case REFERENCE -> Opcode.AASTORE;\n+            case CHAR -> Opcode.CASTORE;\n+            case VOID -> throw new IllegalArgumentException(\"void not an allowable array type\");\n@@ -198,1 +245,1 @@\n-            case IntType ->\n+            case INT ->\n@@ -200,7 +247,7 @@\n-                        case LongType -> Opcode.I2L;\n-                        case FloatType -> Opcode.I2F;\n-                        case DoubleType -> Opcode.I2D;\n-                        case ByteType -> Opcode.I2B;\n-                        case CharType -> Opcode.I2C;\n-                        case ShortType -> Opcode.I2S;\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        case LONG -> Opcode.I2L;\n+                        case FLOAT -> Opcode.I2F;\n+                        case DOUBLE -> Opcode.I2D;\n+                        case BYTE -> Opcode.I2B;\n+                        case CHAR -> Opcode.I2C;\n+                        case SHORT -> Opcode.I2S;\n+                        default -> throw cannotConvertException(from, to);\n@@ -208,1 +255,1 @@\n-            case LongType ->\n+            case LONG ->\n@@ -210,4 +257,4 @@\n-                        case FloatType -> Opcode.L2F;\n-                        case DoubleType -> Opcode.L2D;\n-                        case IntType -> Opcode.L2I;\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        case FLOAT -> Opcode.L2F;\n+                        case DOUBLE -> Opcode.L2D;\n+                        case INT -> Opcode.L2I;\n+                        default -> throw cannotConvertException(from, to);\n@@ -215,1 +262,1 @@\n-            case DoubleType ->\n+            case DOUBLE ->\n@@ -217,4 +264,4 @@\n-                        case FloatType -> Opcode.D2F;\n-                        case LongType -> Opcode.D2L;\n-                        case IntType -> Opcode.D2I;\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        case FLOAT -> Opcode.D2F;\n+                        case LONG -> Opcode.D2L;\n+                        case INT -> Opcode.D2I;\n+                        default -> throw cannotConvertException(from, to);\n@@ -222,1 +269,1 @@\n-            case FloatType ->\n+            case FLOAT ->\n@@ -224,4 +271,4 @@\n-                        case LongType -> Opcode.F2L;\n-                        case DoubleType -> Opcode.F2D;\n-                        case IntType -> Opcode.F2I;\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        case LONG -> Opcode.F2L;\n+                        case DOUBLE -> Opcode.F2D;\n+                        case INT -> Opcode.F2I;\n+                        default -> throw cannotConvertException(from, to);\n@@ -229,1 +276,1 @@\n-            default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+            default -> throw cannotConvertException(from, to);\n@@ -233,9 +280,5 @@\n-    static void validateSIPUSH(ConstantDesc d) {\n-        if (d instanceof Integer iVal && Short.MIN_VALUE <= iVal && iVal <= Short.MAX_VALUE)\n-            return;\n-\n-        if (d instanceof Long lVal && Short.MIN_VALUE <= lVal && Short.MAX_VALUE <= lVal)\n-            return;\n-\n-        throw new IllegalArgumentException(\"SIPUSH: value must be within: Short.MIN_VALUE <= value <= Short.MAX_VALUE\"\n-                                           + \", found: \" + d);\n+    public static void validateSipush(int value) {\n+        if (value != (short) value)\n+            throw new IllegalArgumentException(\n+                    \"SIPUSH: value must be within: Short.MIN_VALUE <= value <= Short.MAX_VALUE, found: \"\n+                            .concat(Long.toString(value)));\n@@ -244,9 +287,5 @@\n-    static void validateBIPUSH(ConstantDesc d) {\n-        if (d instanceof Integer iVal && Byte.MIN_VALUE <= iVal && iVal <= Byte.MAX_VALUE)\n-            return;\n-\n-        if (d instanceof Long lVal && Byte.MIN_VALUE <= lVal && Byte.MAX_VALUE <= lVal)\n-            return;\n-\n-        throw new IllegalArgumentException(\"BIPUSH: value must be within: Byte.MIN_VALUE <= value <= Byte.MAX_VALUE\"\n-                                           + \", found: \" + d);\n+    public static void validateBipush(int value) {\n+        if (value != (byte) value)\n+            throw new IllegalArgumentException(\n+                    \"BIPUSH: value must be within: Byte.MIN_VALUE <= value <= Byte.MAX_VALUE, found: \"\n+                            .concat(Long.toString(value)));\n@@ -285,24 +324,4 @@\n-    public static void validateValue(Opcode opcode, ConstantDesc v) {\n-        switch (opcode) {\n-            case ACONST_NULL -> {\n-                if (v != null && v != ConstantDescs.NULL)\n-                    throw new IllegalArgumentException(\"value must be null or ConstantDescs.NULL with opcode ACONST_NULL\");\n-            }\n-            case SIPUSH ->\n-                    validateSIPUSH(v);\n-            case BIPUSH ->\n-                    validateBIPUSH(v);\n-            case LDC, LDC_W, LDC2_W -> {\n-                if (v == null)\n-                    throw new IllegalArgumentException(\"`null` must use ACONST_NULL\");\n-            }\n-            default -> {\n-                var exp = opcode.constantValue();\n-                if (exp == null)\n-                    throw new IllegalArgumentException(\"Can not use Opcode: \" + opcode + \" with constant()\");\n-                if (v == null || !(v.equals(exp) || (exp instanceof Long l && v.equals(l.intValue())))) {\n-                    var t = (exp instanceof Long) ? \"L\" : (exp instanceof Float) ? \"f\" : (exp instanceof Double) ? \"d\" : \"\";\n-                    throw new IllegalArgumentException(\"value must be \" + exp + t + \" with opcode \" + opcode.name());\n-                }\n-            }\n-        }\n+    public static Opcode ldcOpcode(LoadableConstantEntry entry) {\n+        return entry.typeKind().slotSize() == 2 ? Opcode.LDC2_W\n+                : entry.index() > 0xff ? Opcode.LDC_W\n+                : Opcode.LDC;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":181,"deletions":162,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -854,1 +854,1 @@\n-                                \"descriptor\", newa.typeKind().typeName()));\n+                                \"descriptor\", newa.typeKind().upperBound().displayName()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -261,2 +261,1 @@\n-                    cob.loadConstant(ldc.opcode(),\n-                            mapConstantValue(ldc.constantValue()));\n+                    cob.ldc(mapConstantValue(ldc.constantValue()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-                        shift(cob, ii.slot(), TypeKind.IntType),\n+                        shift(cob, ii.slot(), TypeKind.INT),\n@@ -76,1 +76,1 @@\n-                                        : TypeKind.ReferenceType),\n+                                        : TypeKind.REFERENCE),\n@@ -86,1 +86,1 @@\n-        if (tk == TypeKind.VoidType)  throw new IllegalArgumentException(\"Illegal local void type\");\n+        if (tk == TypeKind.VOID)  throw new IllegalArgumentException(\"Illegal local void type\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeLocalsShifterImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,1 @@\n-            if (type != TypeKind.VoidType) stack.push(type);\n+            if (type != TypeKind.VOID) stack.push(type);\n@@ -231,1 +231,1 @@\n-                pop(i.dimensions());push(TypeKind.ReferenceType);\n+                pop(i.dimensions());push(TypeKind.REFERENCE);\n@@ -234,1 +234,1 @@\n-                push(TypeKind.ReferenceType);\n+                push(TypeKind.REFERENCE);\n@@ -236,1 +236,1 @@\n-                pop(1);push(TypeKind.ReferenceType);\n+                pop(1);push(TypeKind.REFERENCE);\n@@ -239,1 +239,1 @@\n-                pop(1);push(TypeKind.ReferenceType);\n+                pop(1);push(TypeKind.REFERENCE);\n@@ -332,1 +332,1 @@\n-                        pop(1);push(TypeKind.ReferenceType);\n+                        pop(1);push(TypeKind.REFERENCE);\n@@ -335,1 +335,1 @@\n-                        pop(1);push(TypeKind.IntType);\n+                        pop(1);push(TypeKind.INT);\n@@ -340,1 +340,1 @@\n-                map.put(i.handler(), new Stack(new Item(TypeKind.ReferenceType, null), 1, 1));\n+                map.put(i.handler(), new Stack(new Item(TypeKind.REFERENCE, null), 1, 1));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeStackTrackerImpl.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -27,9 +28,0 @@\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.IdentityHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n@@ -46,1 +38,0 @@\n-import java.lang.classfile.instruction.SwitchCase;\n@@ -58,0 +49,1 @@\n+import java.lang.classfile.constantpool.MethodRefEntry;\n@@ -62,0 +54,12 @@\n+import java.lang.classfile.instruction.SwitchCase;\n+import java.lang.constant.ConstantDesc;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static java.lang.classfile.Opcode.*;\n@@ -63,8 +67,1 @@\n-import static java.lang.classfile.Opcode.GOTO;\n-import static java.lang.classfile.Opcode.GOTO_W;\n-import static java.lang.classfile.Opcode.IINC;\n-import static java.lang.classfile.Opcode.IINC_W;\n-import static java.lang.classfile.Opcode.JSR;\n-import static java.lang.classfile.Opcode.JSR_W;\n-import static java.lang.classfile.Opcode.LDC2_W;\n-import static java.lang.classfile.Opcode.LDC_W;\n+import static jdk.internal.classfile.impl.BytecodeHelpers.*;\n@@ -546,1 +543,1 @@\n-        writeBytecode(Opcode.LOOKUPSWITCH);\n+        writeBytecode(LOOKUPSWITCH);\n@@ -567,1 +564,1 @@\n-        writeBytecode(Opcode.TABLESWITCH);\n+        writeBytecode(TABLESWITCH);\n@@ -603,1 +600,1 @@\n-        writeBytecode(Opcode.INVOKEDYNAMIC);\n+        writeBytecode(INVOKEDYNAMIC);\n@@ -609,1 +606,1 @@\n-        writeBytecode(Opcode.NEW);\n+        writeBytecode(NEW);\n@@ -614,1 +611,1 @@\n-        writeBytecode(Opcode.NEWARRAY);\n+        writeBytecode(NEWARRAY);\n@@ -619,1 +616,1 @@\n-        writeBytecode(Opcode.ANEWARRAY);\n+        writeBytecode(ANEWARRAY);\n@@ -624,1 +621,1 @@\n-        writeBytecode(Opcode.MULTIANEWARRAY);\n+        writeBytecode(MULTIANEWARRAY);\n@@ -780,0 +777,745 @@\n+\n+    \/\/ Fast overrides to avoid intermediate instructions\n+    \/\/ These are helpful for direct class building\n+\n+    @Override\n+    public CodeBuilder return_(TypeKind tk) {\n+        writeBytecode(BytecodeHelpers.returnOpcode(tk));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder storeLocal(TypeKind tk, int slot) {\n+        writeLocalVar(BytecodeHelpers.storeOpcode(tk, slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder loadLocal(TypeKind tk, int slot) {\n+        writeLocalVar(BytecodeHelpers.loadOpcode(tk, slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invoke(Opcode opcode, MemberRefEntry ref) {\n+        if (opcode == INVOKEINTERFACE) {\n+            int slots = Util.parameterSlots(Util.methodTypeSymbol(ref.nameAndType())) + 1;\n+            writeInvokeInterface(opcode, (InterfaceMethodRefEntry) ref, slots);\n+        } else {\n+            writeInvokeNormal(opcode, ref);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fieldAccess(Opcode opcode, FieldRefEntry ref) {\n+        writeFieldAccess(opcode, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder arrayLoad(TypeKind tk) {\n+        writeBytecode(BytecodeHelpers.arrayLoadOpcode(tk));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder arrayStore(TypeKind tk) {\n+        writeBytecode(BytecodeHelpers.arrayStoreOpcode(tk));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder branch(Opcode op, Label target) {\n+        writeBranch(op, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder nop() {\n+        writeBytecode(NOP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder aconst_null() {\n+        writeBytecode(ACONST_NULL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder aload(int slot) {\n+        writeLocalVar(BytecodeHelpers.aload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder anewarray(ClassEntry entry) {\n+        writeNewReferenceArray(entry);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder arraylength() {\n+        writeBytecode(ARRAYLENGTH);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder astore(int slot) {\n+        writeLocalVar(BytecodeHelpers.astore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder athrow() {\n+        writeBytecode(ATHROW);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder bipush(int b) {\n+        BytecodeHelpers.validateBipush(b);\n+        writeArgumentConstant(BIPUSH, b);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder checkcast(ClassEntry type) {\n+        writeTypeCheck(CHECKCAST, type);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder d2f() {\n+        writeBytecode(D2F);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder d2i() {\n+        writeBytecode(D2I);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder d2l() {\n+        writeBytecode(D2L);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dadd() {\n+        writeBytecode(DADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dcmpg() {\n+        writeBytecode(DCMPG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dcmpl() {\n+        writeBytecode(DCMPL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dconst_0() {\n+        writeBytecode(DCONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dconst_1() {\n+        writeBytecode(DCONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ddiv() {\n+        writeBytecode(DDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dload(int slot) {\n+        writeLocalVar(BytecodeHelpers.dload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dmul() {\n+        writeBytecode(DMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dneg() {\n+        writeBytecode(DNEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder drem() {\n+        writeBytecode(DREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dstore(int slot) {\n+        writeLocalVar(BytecodeHelpers.dstore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dsub() {\n+        writeBytecode(DSUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup() {\n+        writeBytecode(DUP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup2() {\n+        writeBytecode(DUP2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup2_x1() {\n+        writeBytecode(DUP2_X1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup2_x2() {\n+        writeBytecode(DUP2_X2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup_x1() {\n+        writeBytecode(DUP_X1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup_x2() {\n+        writeBytecode(DUP_X2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder f2d() {\n+        writeBytecode(F2D);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder f2i() {\n+        writeBytecode(F2I);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder f2l() {\n+        writeBytecode(F2L);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fadd() {\n+        writeBytecode(FADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fcmpg() {\n+        writeBytecode(FCMPG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fcmpl() {\n+        writeBytecode(FCMPL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fconst_0() {\n+        writeBytecode(FCONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fconst_1() {\n+        writeBytecode(FCONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fconst_2() {\n+        writeBytecode(FCONST_2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fdiv() {\n+        writeBytecode(FDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fload(int slot) {\n+        writeLocalVar(BytecodeHelpers.fload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fmul() {\n+        writeBytecode(FMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fneg() {\n+        writeBytecode(FNEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder frem() {\n+        writeBytecode(FREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fstore(int slot) {\n+        writeLocalVar(BytecodeHelpers.fstore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fsub() {\n+        writeBytecode(FSUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2b() {\n+        writeBytecode(I2B);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2c() {\n+        writeBytecode(I2C);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2d() {\n+        writeBytecode(I2D);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2f() {\n+        writeBytecode(I2F);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2l() {\n+        writeBytecode(I2L);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2s() {\n+        writeBytecode(I2S);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iadd() {\n+        writeBytecode(IADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iand() {\n+        writeBytecode(IAND);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_0() {\n+        writeBytecode(ICONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_1() {\n+        writeBytecode(ICONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_2() {\n+        writeBytecode(ICONST_2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_3() {\n+        writeBytecode(ICONST_3);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_4() {\n+        writeBytecode(ICONST_4);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_5() {\n+        writeBytecode(ICONST_5);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_m1() {\n+        writeBytecode(ICONST_M1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder idiv() {\n+        writeBytecode(IDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iinc(int slot, int val) {\n+        writeIncrement(slot, val);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iload(int slot) {\n+        writeLocalVar(BytecodeHelpers.iload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder imul() {\n+        writeBytecode(IMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ineg() {\n+        writeBytecode(INEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder instanceOf(ClassEntry target) {\n+        writeTypeCheck(INSTANCEOF, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokedynamic(InvokeDynamicEntry ref) {\n+        writeInvokeDynamic(ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokeinterface(InterfaceMethodRefEntry ref) {\n+        writeInvokeInterface(INVOKEINTERFACE, ref, Util.parameterSlots(ref.typeSymbol()) + 1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokespecial(InterfaceMethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESPECIAL, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokespecial(MethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESPECIAL, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokestatic(InterfaceMethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESTATIC, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokestatic(MethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESTATIC, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokevirtual(MethodRefEntry ref) {\n+        writeInvokeNormal(INVOKEVIRTUAL, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ior() {\n+        writeBytecode(IOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder irem() {\n+        writeBytecode(IREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ishl() {\n+        writeBytecode(ISHL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ishr() {\n+        writeBytecode(ISHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder istore(int slot) {\n+        writeLocalVar(BytecodeHelpers.istore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder isub() {\n+        writeBytecode(ISUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iushr() {\n+        writeBytecode(IUSHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ixor() {\n+        writeBytecode(IXOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lookupswitch(Label defaultTarget, List<SwitchCase> cases) {\n+        writeLookupSwitch(defaultTarget, cases);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder l2d() {\n+        writeBytecode(L2D);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder l2f() {\n+        writeBytecode(L2F);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder l2i() {\n+        writeBytecode(L2I);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ladd() {\n+        writeBytecode(LADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder land() {\n+        writeBytecode(LAND);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lcmp() {\n+        writeBytecode(LCMP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lconst_0() {\n+        writeBytecode(LCONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lconst_1() {\n+        writeBytecode(LCONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ldc(LoadableConstantEntry entry) {\n+        writeLoadConstant(BytecodeHelpers.ldcOpcode(entry), entry);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ldiv() {\n+        writeBytecode(LDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lload(int slot) {\n+        writeLocalVar(BytecodeHelpers.lload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lmul() {\n+        writeBytecode(LMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lneg() {\n+        writeBytecode(LNEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lor() {\n+        writeBytecode(LOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lrem() {\n+        writeBytecode(LREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lshl() {\n+        writeBytecode(LSHL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lshr() {\n+        writeBytecode(LSHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lstore(int slot) {\n+        writeLocalVar(BytecodeHelpers.lstore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lsub() {\n+        writeBytecode(LSUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lushr() {\n+        writeBytecode(LUSHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lxor() {\n+        writeBytecode(LXOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder monitorenter() {\n+        writeBytecode(MONITORENTER);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder monitorexit() {\n+        writeBytecode(MONITOREXIT);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder multianewarray(ClassEntry array, int dims) {\n+        writeNewMultidimensionalArray(dims, array);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder new_(ClassEntry clazz) {\n+        writeNewObject(clazz);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder newarray(TypeKind typeKind) {\n+        int atype = typeKind.newarrayCode(); \/\/ implicit null check\n+        if (atype < 0)\n+            throw new IllegalArgumentException(\"Illegal component type: \".concat(typeKind.upperBound().displayName()));\n+        writeNewPrimitiveArray(atype);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder pop() {\n+        writeBytecode(POP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder pop2() {\n+        writeBytecode(POP2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder sipush(int s) {\n+        BytecodeHelpers.validateSipush(s);\n+        writeArgumentConstant(SIPUSH, s);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder swap() {\n+        writeBytecode(SWAP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder tableswitch(int low, int high, Label defaultTarget, List<SwitchCase> cases) {\n+        writeTableSwitch(low, high, defaultTarget, cases);\n+        return this;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":767,"deletions":25,"binary":false,"changes":792,"status":"modified"},{"patch":"@@ -269,2 +269,2 @@\n-    private <T extends ConstantDesc> PoolEntry findPrimitiveEntry(int tag, T val) {\n-        int hash = AbstractPoolEntry.hash1(tag, val.hashCode());\n+    private IntegerEntry findIntEntry(int val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_INTEGER, Integer.hashCode(val));\n@@ -274,4 +274,55 @@\n-            if (e.tag() == tag\n-                && e instanceof AbstractPoolEntry.PrimitiveEntry<?> ce\n-                && ce.value().equals(val))\n-                return e;\n+            if (e.tag() == TAG_INTEGER\n+                    && e instanceof AbstractPoolEntry.IntegerEntryImpl ce\n+                    && ce.intValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findIntEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private LongEntry findLongEntry(long val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_LONG, Long.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_LONG\n+                    && e instanceof AbstractPoolEntry.LongEntryImpl ce\n+                    && ce.longValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findLongEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private FloatEntry findFloatEntry(float val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_FLOAT, Float.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_FLOAT\n+                    && e instanceof AbstractPoolEntry.FloatEntryImpl ce\n+                    && ce.floatValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findFloatEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private DoubleEntry findDoubleEntry(double val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_DOUBLE, Double.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_DOUBLE\n+                    && e instanceof AbstractPoolEntry.DoubleEntryImpl ce\n+                    && ce.doubleValue() == val)\n+                return ce;\n@@ -281,1 +332,1 @@\n-            return findPrimitiveEntry(tag, val);\n+            return findDoubleEntry(val);\n@@ -545,1 +596,1 @@\n-        var e = (IntegerEntry) findPrimitiveEntry(TAG_INTEGER, value);\n+        var e = findIntEntry(value);\n@@ -551,1 +602,1 @@\n-        var e = (FloatEntry) findPrimitiveEntry(TAG_FLOAT, value);\n+        var e = findFloatEntry(value);\n@@ -557,1 +608,1 @@\n-        var e = (LongEntry) findPrimitiveEntry(TAG_LONG, value);\n+        var e = findLongEntry(value);\n@@ -563,1 +614,1 @@\n-        var e = (DoubleEntry) findPrimitiveEntry(TAG_DOUBLE, value);\n+        var e = findDoubleEntry(value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":62,"deletions":11,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -233,6 +233,6 @@\n-                    case BooleanType, ByteType, CharType, IntType, ShortType -> cve instanceof IntegerEntry;\n-                    case DoubleType -> cve instanceof DoubleEntry;\n-                    case FloatType -> cve instanceof FloatEntry;\n-                    case LongType -> cve instanceof LongEntry;\n-                    case ReferenceType -> type.equals(ConstantDescs.CD_String) && cve instanceof StringEntry;\n-                    case VoidType -> false;\n+                    case BOOLEAN, BYTE, CHAR, INT, SHORT -> cve instanceof IntegerEntry;\n+                    case DOUBLE -> cve instanceof DoubleEntry;\n+                    case FLOAT -> cve instanceof FloatEntry;\n+                    case LONG -> cve instanceof LongEntry;\n+                    case REFERENCE -> type.equals(ConstantDescs.CD_String) && cve instanceof StringEntry;\n+                    case VOID -> false;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.internal.util.Architecture;\n@@ -191,0 +192,4 @@\n+    \/\/ FILL_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n+    \/\/ Update the value for Aarch64 once 8338975 is fixed.\n+    private static final long FILL_NATIVE_THRESHOLD = 1L << (Architecture.isAARCH64() ? 10 : 5);\n+\n@@ -192,3 +197,41 @@\n-    public final MemorySegment fill(byte value){\n-        checkAccess(0, length, false);\n-        SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n+    @ForceInline\n+    public final MemorySegment fill(byte value) {\n+        checkReadOnly(false);\n+        if (length == 0) {\n+            \/\/ Implicit state check\n+            checkValidState();\n+        } else if (length < FILL_NATIVE_THRESHOLD) {\n+            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+\n+            \/\/ Handle smaller segments directly without transitioning to native code\n+            final long u = Byte.toUnsignedLong(value);\n+            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+\n+            int offset = 0;\n+            \/\/ 0...0X...X000\n+            final int limit = (int) (length & (FILL_NATIVE_THRESHOLD - 8));\n+            for (; offset < limit; offset += 8) {\n+                SCOPED_MEMORY_ACCESS.putLong(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, longValue);\n+            }\n+            int remaining = (int) length - limit;\n+            \/\/ 0...0X00\n+            if (remaining >= 4) {\n+                SCOPED_MEMORY_ACCESS.putInt(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (int) longValue);\n+                offset += 4;\n+                remaining -= 4;\n+            }\n+            \/\/ 0...00X0\n+            if (remaining >= 2) {\n+                SCOPED_MEMORY_ACCESS.putShort(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (short) longValue);\n+                offset += 2;\n+                remaining -= 2;\n+            }\n+            \/\/ 0...000X\n+            if (remaining == 1) {\n+                SCOPED_MEMORY_ACCESS.putByte(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, value);\n+            }\n+            \/\/ We have now fully handled 0...0X...XXXX\n+        } else {\n+            \/\/ Handle larger segments via native calls\n+            SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":46,"deletions":3,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    private static final MethodHandle MH_ADD;\n+    private static final MethodHandle MH_ADD_EXACT;\n@@ -84,1 +84,1 @@\n-            MH_ADD = lookup.findStatic(Long.class, \"sum\",\n+            MH_ADD_EXACT = lookup.findStatic(Math.class, \"addExact\",\n@@ -247,1 +247,1 @@\n-        MethodHandle mh = MethodHandles.insertArguments(MH_ADD, 0, offset);\n+        MethodHandle mh = MH_ADD_EXACT;\n@@ -250,3 +250,7 @@\n-            \/\/ (J, ...) -> J to (J, J, ...) -> J\n-            \/\/ i.e. new coord is prefixed. Last coord will correspond to innermost layout\n-            mh = MethodHandles.collectArguments(mh, 0, collector);\n+            \/\/ (J, J, ...) -> J to (J, J, J, ...) -> J\n+            \/\/ 1. the leading argument is the base offset (externally provided).\n+            \/\/ 2. index arguments are added. The last index correspond to the innermost layout.\n+            \/\/ 3. overflow can only occur at the outermost layer, due to the final addition with the base offset.\n+            \/\/ This is because the layout API ensures (by construction) that all offsets generated from layout paths\n+            \/\/ are always < Long.MAX_VALUE.\n+            mh = MethodHandles.collectArguments(mh, 1, collector);\n@@ -254,2 +258,1 @@\n-\n-        return mh;\n+        return MethodHandles.insertArguments(mh, 1, offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-                    int scopeLocal = cb.allocateLocal(ReferenceType);\n+                    int scopeLocal = cb.allocateLocal(REFERENCE);\n@@ -279,1 +279,1 @@\n-                    cb.storeLocal(ReferenceType, scopeLocal); \/\/ need to initialize all scope locals here in case an exception occurs\n+                    cb.storeLocal(REFERENCE, scopeLocal); \/\/ need to initialize all scope locals here in case an exception occurs\n@@ -295,2 +295,2 @@\n-        contextIdx = cb.allocateLocal(ReferenceType);\n-        cb.storeLocal(ReferenceType, contextIdx);\n+        contextIdx = cb.allocateLocal(REFERENCE);\n+        cb.storeLocal(REFERENCE, contextIdx);\n@@ -303,2 +303,2 @@\n-            returnBufferIdx = cb.allocateLocal(ReferenceType);\n-            cb.storeLocal(ReferenceType, returnBufferIdx);\n+            returnBufferIdx = cb.allocateLocal(REFERENCE);\n+            cb.storeLocal(REFERENCE, returnBufferIdx);\n@@ -327,1 +327,1 @@\n-                    cb.loadLocal(ReferenceType, returnBufferIdx);\n+                    cb.loadLocal(REFERENCE, returnBufferIdx);\n@@ -342,2 +342,2 @@\n-                    returnBufferIdx = cb.allocateLocal(ReferenceType);\n-                    cb.storeLocal(ReferenceType, returnBufferIdx);\n+                    returnBufferIdx = cb.allocateLocal(REFERENCE);\n+                    cb.storeLocal(REFERENCE, returnBufferIdx);\n@@ -358,1 +358,1 @@\n-            cb.loadLocal(ReferenceType, 0); \/\/ load target arg\n+            cb.loadLocal(REFERENCE, 0); \/\/ load target arg\n@@ -509,1 +509,1 @@\n-            cb.loadLocal(ReferenceType, scopeSlots[i]);\n+            cb.loadLocal(REFERENCE, scopeSlots[i]);\n@@ -518,1 +518,1 @@\n-        cb.storeLocal(ReferenceType, nextScopeLocal); \/\/ store off one to release later\n+        cb.storeLocal(REFERENCE, nextScopeLocal); \/\/ store off one to release later\n@@ -532,1 +532,1 @@\n-            cb.loadLocal(ReferenceType, scopeLocal);\n+            cb.loadLocal(REFERENCE, scopeLocal);\n@@ -534,1 +534,1 @@\n-                ifCb.loadLocal(ReferenceType, scopeLocal);\n+                ifCb.loadLocal(REFERENCE, scopeLocal);\n@@ -554,1 +554,1 @@\n-        cb.loadLocal(ReferenceType, contextIdx);\n+        cb.loadLocal(REFERENCE, contextIdx);\n@@ -562,1 +562,1 @@\n-        cb.loadLocal(ReferenceType, contextIdx);\n+        cb.loadLocal(REFERENCE, contextIdx);\n@@ -567,1 +567,1 @@\n-        cb.loadLocal(ReferenceType, contextIdx);\n+        cb.loadLocal(REFERENCE, contextIdx);\n@@ -588,1 +588,1 @@\n-            cb.loadLocal(ReferenceType, returnAllocatorIdx);\n+            cb.loadLocal(REFERENCE, returnAllocatorIdx);\n@@ -621,4 +621,4 @@\n-            int longValueIdx = cb.allocateLocal(LongType);\n-            cb.storeLocal(LongType, longValueIdx);\n-            int writeAddrIdx = cb.allocateLocal(ReferenceType);\n-            cb.storeLocal(ReferenceType, writeAddrIdx);\n+            int longValueIdx = cb.allocateLocal(LONG);\n+            cb.storeLocal(LONG, longValueIdx);\n+            int writeAddrIdx = cb.allocateLocal(REFERENCE);\n+            cb.storeLocal(REFERENCE, writeAddrIdx);\n@@ -651,1 +651,1 @@\n-                cb.loadLocal(LongType, longValueIdx);\n+                cb.loadLocal(LONG, longValueIdx);\n@@ -665,1 +665,1 @@\n-                cb.loadLocal(ReferenceType, writeAddrIdx);\n+                cb.loadLocal(REFERENCE, writeAddrIdx);\n@@ -697,1 +697,1 @@\n-                cb.loadLocal(ReferenceType, returnBufferIdx);\n+                cb.loadLocal(REFERENCE, returnBufferIdx);\n@@ -717,1 +717,1 @@\n-                cb.loadLocal(ReferenceType, returnBufferIdx);\n+                cb.loadLocal(REFERENCE, returnBufferIdx);\n@@ -817,2 +817,2 @@\n-            int readAddrIdx = cb.allocateLocal(ReferenceType);\n-            cb.storeLocal(ReferenceType, readAddrIdx);\n+            int readAddrIdx = cb.allocateLocal(REFERENCE);\n+            cb.storeLocal(REFERENCE, readAddrIdx);\n@@ -821,2 +821,2 @@\n-            int resultIdx = cb.allocateLocal(LongType);\n-            cb.storeLocal(LongType, resultIdx);\n+            int resultIdx = cb.allocateLocal(LONG);\n+            cb.storeLocal(LONG, resultIdx);\n@@ -851,1 +851,1 @@\n-                cb.loadLocal(ReferenceType, readAddrIdx);\n+                cb.loadLocal(REFERENCE, readAddrIdx);\n@@ -866,1 +866,1 @@\n-                cb.loadLocal(LongType, resultIdx);\n+                cb.loadLocal(LONG, resultIdx);\n@@ -868,1 +868,1 @@\n-                cb.storeLocal(LongType, resultIdx);\n+                cb.storeLocal(LONG, resultIdx);\n@@ -874,1 +874,1 @@\n-            cb.loadLocal(LongType, resultIdx);\n+            cb.loadLocal(LONG, resultIdx);\n@@ -900,2 +900,2 @@\n-        int storeIdx = cb.allocateLocal(ReferenceType);\n-        cb.storeLocal(ReferenceType, storeIdx);\n+        int storeIdx = cb.allocateLocal(REFERENCE);\n+        cb.storeLocal(REFERENCE, storeIdx);\n@@ -906,1 +906,1 @@\n-        cb.loadLocal(ReferenceType, storeIdx);\n+        cb.loadLocal(REFERENCE, storeIdx);\n@@ -985,5 +985,5 @@\n-            case BooleanType, ByteType, ShortType, CharType, IntType -> cb.iconst_0();\n-            case LongType -> cb.lconst_0();\n-            case FloatType -> cb.fconst_0();\n-            case DoubleType -> cb.dconst_0();\n-            case ReferenceType -> cb.aconst_null();\n+            case BOOLEAN, BYTE, SHORT, CHAR, INT -> cb.iconst_0();\n+            case LONG -> cb.lconst_0();\n+            case FLOAT -> cb.fconst_0();\n+            case DOUBLE -> cb.dconst_0();\n+            case REFERENCE -> cb.aconst_null();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":42,"deletions":42,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.io.InterruptedIOException;\n@@ -90,18 +89,0 @@\n-\n-        \/\/ This code has been uglified to protect against interrupts.\n-        \/\/ Even if a thread has been interrupted when loading resources,\n-        \/\/ the IO should not abort, so must carefully retry, failing only\n-        \/\/ if the retry leads to some other IO exception.\n-\n-        boolean isInterrupted = Thread.interrupted();\n-        int len;\n-        for (;;) {\n-            try {\n-                len = getContentLength();\n-                break;\n-            } catch (InterruptedIOException iioe) {\n-                Thread.interrupted();\n-                isInterrupted = true;\n-            }\n-        }\n-\n@@ -109,0 +90,1 @@\n+            int len = getContentLength();\n@@ -124,7 +106,1 @@\n-                int cc = 0;\n-                try {\n-                    cc = in.read(b, pos, bytesToRead);\n-                } catch (InterruptedIOException iioe) {\n-                    Thread.interrupted();\n-                    isInterrupted = true;\n-                }\n+                int cc = in.read(b, pos, bytesToRead);\n@@ -146,2 +122,0 @@\n-            } catch (InterruptedIOException iioe) {\n-                isInterrupted = true;\n@@ -149,4 +123,0 @@\n-\n-            if (isInterrupted) {\n-                Thread.currentThread().interrupt();\n-            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/Resource.java","additions":3,"deletions":33,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,0 @@\n-import java.util.zip.ZipEntry;\n@@ -442,1 +441,2 @@\n-            Loader loader;\n+            Loader loader = null;\n+            final URL[] loaderClassPathURLs;\n@@ -447,4 +447,1 @@\n-                URL[] urls = loader.getClassPath();\n-                if (urls != null) {\n-                    push(urls);\n-                }\n+                loaderClassPathURLs = loader.getClassPath();\n@@ -452,1 +449,8 @@\n-                \/\/ Silently ignore for now...\n+                \/\/ log the error and close the unusable loader (if any)\n+                if (DEBUG) {\n+                    System.err.println(\"Failed to construct a loader or construct its\" +\n+                            \" local classpath for \" + url + \", cause:\" + e);\n+                }\n+                if (loader != null) {\n+                    closeQuietly(loader);\n+                }\n@@ -455,3 +459,3 @@\n-                \/\/ Always silently ignore. The context, if there is one, that\n-                \/\/ this URLClassPath was given during construction will never\n-                \/\/ have permission to access the URL.\n+                \/\/ log the error and close the unusable loader (if any).\n+                \/\/ The context, if there is one, that this URLClassPath was\n+                \/\/ given during construction will never have permission to access the URL.\n@@ -461,0 +465,3 @@\n+                if (loader != null) {\n+                    closeQuietly(loader);\n+                }\n@@ -463,0 +470,3 @@\n+            if (loaderClassPathURLs != null) {\n+                push(loaderClassPathURLs);\n+            }\n@@ -470,0 +480,11 @@\n+    \/\/ closes the given loader and ignores any IOException that may occur during close\n+    private static void closeQuietly(final Loader loader) {\n+        try {\n+            loader.close();\n+        } catch (IOException ioe) {\n+            if (DEBUG) {\n+                System.err.println(\"ignoring exception \" + ioe + \" while closing loader \" + loader);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,1 +405,1 @@\n-                        char c = UNMAPPABLE_DECODING;\n+                        char c;\n@@ -455,1 +455,1 @@\n-                    char c =  UNMAPPABLE_DECODING;\n+                    char c;\n@@ -506,2 +506,2 @@\n-        private final int SS2 =  0x8E;\n-        private final int SS3 =  0x8F;\n+        private static final int SS2 = 0x8E;\n+        private static final int SS3 = 0x8F;\n@@ -559,1 +559,1 @@\n-        protected final int MAX_SINGLEBYTE = 0xff;\n+        protected static final int MAX_SINGLEBYTE = 0xff;\n@@ -662,1 +662,1 @@\n-                        return CoderResult.OVERFLOW;\n+                            return CoderResult.OVERFLOW;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/DoubleByte.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1142,1 +1142,3 @@\n-            NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.math.BigInteger;\n@@ -33,0 +32,1 @@\n+import java.util.Arrays;\n@@ -121,5 +121,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -224,5 +219,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -304,1 +294,1 @@\n-        } catch  (GeneralSecurityException gse) {\n+        } catch (GeneralSecurityException gse) {\n@@ -335,2 +325,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -354,2 +343,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -366,2 +354,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -378,6 +365,2 @@\n-            SessionId newId = new SessionId(true,\n-                hc.sslContext.getSecureRandom());\n-\n-            SecretKey resumptionMasterSecret =\n-                hc.handshakeSession.getResumptionMasterSecret();\n-            if (resumptionMasterSecret == null) {\n+            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n+            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n@@ -385,3 +368,2 @@\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"no resumption secret\");\n+                    SSLLogger.fine(\"No session ticket produced: \" +\n+                            \"session timeout is too long\");\n@@ -393,13 +375,11 @@\n-            \/\/ construct the PSK and handshake message\n-            BigInteger nonce = hc.handshakeSession.incrTicketNonceCounter();\n-            byte[] nonceArr = nonce.toByteArray();\n-            SecretKey psk = derivePreSharedKey(\n-                    hc.negotiatedCipherSuite.hashAlg,\n-                    resumptionMasterSecret, nonceArr);\n-\n-            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n-            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"session timeout\");\n+            \/\/ Send NewSessionTickets to the client based\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                int i = 0;\n+                NewSessionTicketMessage nstm;\n+                while (i < SSLConfiguration.serverNewSessionTicketCount) {\n+                    nstm = generateNST(hc, sessionCache);\n+                    if (nstm == null) {\n+                        break;\n+                    }\n+                    nstm.write(hc.handshakeOutput);\n+                    i++;\n@@ -408,1 +388,28 @@\n-                return null;\n+                hc.handshakeOutput.flush();\n+            }\n+            \/*\n+             * With large NST counts, a client that quickly closes after\n+             * TLS Finished completes can cause SocketExceptions such as:\n+             * Windows servers read-side throwing SocketException:\n+             *   \"An established connection was aborted by the software in\n+             *    your host machine\", which relates to error WSAECONNABORTED.\n+             * A SocketException caused by a \"broken pipe\" has been observed on\n+             * other systems.\n+             * These are very unlikely situations when client and server are on\n+             * different machines.\n+             *\n+             * RFC 8446 does not put requirements when an NST needs to be\n+             * sent, but it should be sent very soon after TLS Finished for\n+             * clients that will quickly resume to create more sessions.\n+             * TLS 1.3 is different from TLS 1.2, there is more data the client\n+             * should be aware of\n+             *\/\n+\n+            \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n+            \/\/\n+            \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n+            \/\/ of this post-handshake message will indicate the FINISHED\n+            \/\/ handshake status.  It is not needed to have a follow-on\n+            \/\/ SSLEngine.wrap() any longer.\n+            if (hc.conContext.needHandshakeFinishedStatus) {\n+                hc.conContext.needHandshakeFinishedStatus = false;\n@@ -411,1 +418,16 @@\n-            NewSessionTicketMessage nstm = null;\n+            \/\/ clean the post handshake context\n+            hc.conContext.finishPostHandshake();\n+\n+            \/\/ The message has been delivered.\n+            return null;\n+        }\n+\n+        private NewSessionTicketMessage generateNST(HandshakeContext hc,\n+            SSLSessionContextImpl sessionCache) throws IOException {\n+\n+            NewSessionTicketMessage nstm;\n+            SessionId newId = new SessionId(true,\n+                hc.sslContext.getSecureRandom());\n+\n+            \/\/ construct the PSK and handshake message\n+            byte[] nonce = hc.handshakeSession.incrTicketNonceCounter();\n@@ -414,2 +436,4 @@\n-                    new SSLSessionImpl(hc.handshakeSession, newId);\n-            sessionCopy.setPreSharedKey(psk);\n+                new SSLSessionImpl(hc.handshakeSession, newId);\n+            sessionCopy.setPreSharedKey(derivePreSharedKey(\n+                hc.negotiatedCipherSuite.hashAlg,\n+                hc.handshakeSession.getResumptionMasterSecret(), nonce));\n@@ -422,1 +446,1 @@\n-                        sessionTimeoutSeconds,\n+                        sessionCache.getSessionTimeout(),\n@@ -424,1 +448,1 @@\n-                        nonceArr,\n+                        nonce,\n@@ -431,2 +455,1 @@\n-                        SSLLogger.fine(\n-                            \"Produced NewSessionTicket stateless \" +\n+                        SSLLogger.fine(\"Produced NewSessionTicket stateless \" +\n@@ -436,0 +459,1 @@\n+                return nstm;\n@@ -441,3 +465,4 @@\n-                nstm = new T13NewSessionTicketMessage(hc, sessionTimeoutSeconds,\n-                        hc.sslContext.getSecureRandom(), nonceArr,\n-                        newId.getId());\n+                nstm = new T13NewSessionTicketMessage(hc,\n+                    sessionCache.getSessionTimeout(),\n+                    hc.sslContext.getSecureRandom(), nonce,\n+                    newId.getId());\n@@ -445,3 +470,2 @@\n-                    SSLLogger.fine(\n-                            \"Produced NewSessionTicket post-handshake message\",\n-                            nstm);\n+                    SSLLogger.fine(\"Produced NewSessionTicket \" +\n+                        \"post-handshake message\", nstm);\n@@ -456,0 +480,1 @@\n+                return nstm;\n@@ -458,15 +483,2 @@\n-            \/\/ Output the handshake message.\n-            if (nstm != null) {\n-                \/\/ should never be null\n-                nstm.write(hc.handshakeOutput);\n-                hc.handshakeOutput.flush();\n-\n-                \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n-                \/\/\n-                \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n-                \/\/ of this post-handshake message will indicate the FINISHED\n-                \/\/ handshake status.  It is not needed to have a follow-on\n-                \/\/ SSLEngine.wrap() any longer.\n-                if (hc.conContext.needHandshakeFinishedStatus) {\n-                    hc.conContext.needHandshakeFinishedStatus = false;\n-                }\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"No NewSessionTicket created\");\n@@ -475,4 +487,0 @@\n-            \/\/ clean the post handshake context\n-            hc.conContext.finishPostHandshake();\n-\n-            \/\/ The message has been delivered.\n@@ -500,2 +508,3 @@\n-            \/\/ Is this session resumable?\n-            if (!shc.handshakeSession.isRejoinable()) {\n+            \/\/ Are new tickets allowed?  If so, is this session resumable?\n+            if (SSLConfiguration.serverNewSessionTicketCount == 0 ||\n+                !shc.handshakeSession.isRejoinable()) {\n@@ -581,1 +590,0 @@\n-                sessionCache.remove(hc.handshakeSession.getSessionId());\n@@ -622,1 +630,6 @@\n-            sessionCache.put(sessionCopy);\n+            sessionCache.put(sessionCopy, sessionCopy.isPSK());\n+\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"MultiNST PSK (Server): \" +\n+                    Utilities.toHexString(Arrays.copyOf(nstm.ticket, 16)));\n+            }\n@@ -629,0 +642,1 @@\n+    \/* TLS 1.2 spec does not specify multiple NST behavior.*\/\n@@ -677,2 +691,1 @@\n-                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" +\n-                        nstm.toString());\n+                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" + nstm);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NewSessionTicket.java","additions":93,"deletions":80,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -702,1 +702,1 @@\n-            sessionCache.remove(chc.resumingSession.getSessionId());\n+            sessionCache.remove(chc.resumingSession.getSessionId(), true);\n@@ -707,0 +707,2 @@\n+                SSLLogger.fine(\n+                    \"MultiNST PSK (Client): \" + Utilities.toHexString(Arrays.copyOf(chc.pskIdentity, 16)));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,0 +124,5 @@\n+    \/\/ Number of NewSessionTickets that will be sent by the server.\n+    static final int serverNewSessionTicketCount;\n+    \/\/ Default for NewSessionTickets\n+    static final int SERVER_NST_DEFAULT = 1;\n+\n@@ -185,1 +190,1 @@\n-                \"jdk.tls.client.maxInboundCertificateChainLength\");\n+            \"jdk.tls.client.maxInboundCertificateChainLength\");\n@@ -194,0 +199,27 @@\n+\n+        \/*\n+         * jdk.tls.server.newSessionTicketCount system property\n+         * Sets the number of NewSessionTickets sent to a TLS 1.3 resumption\n+         * client.  The value must be between 0 and 10.  Default is defined by\n+         * SERVER_NST_DEFAULT.\n+         *\/\n+        Integer nstServerCount = GetIntegerAction.privilegedGetProperty(\n+            \"jdk.tls.server.newSessionTicketCount\");\n+        if (nstServerCount == null || nstServerCount < 0 ||\n+            nstServerCount > 10) {\n+            serverNewSessionTicketCount = SERVER_NST_DEFAULT;\n+            if (nstServerCount != null && SSLLogger.isOn &&\n+                SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount defaults to \" +\n+                        SERVER_NST_DEFAULT + \" as the property was not \" +\n+                        \"between 0 and 10\");\n+            }\n+        } else {\n+            serverNewSessionTicketCount = nstServerCount;\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount set to \" +\n+                        serverNewSessionTicketCount);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -419,5 +419,6 @@\n-        if ((conContext.handshakeContext == null) &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            conContext.handshakeContext == null &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineImpl.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+    private static final int DEFAULT_MAX_QUEUE_SIZE = 10;\n@@ -90,2 +91,0 @@\n-        sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n-        sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -93,0 +92,2 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -95,1 +96,1 @@\n-            \/\/ but doesn't necessarily has to be a true random number.\n+            \/\/ but doesn't necessarily have to be a true random number.\n@@ -98,0 +99,3 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryQueue(cacheLimit, timeout,\n+                DEFAULT_MAX_QUEUE_SIZE);\n@@ -280,0 +284,10 @@\n+        put(s, false);\n+    }\n+\n+    \/**\n+     * Put an entry in the cache\n+     * @param s SSLSessionImpl entry to be stored\n+     * @param canQueue True if multiple entries may exist under one\n+     *                 session entry.\n+     *\/\n+    void put(SSLSessionImpl s, boolean canQueue) {\n@@ -285,1 +299,1 @@\n-                getKey(s.getPeerHost(), s.getPeerPort()), s);\n+                getKey(s.getPeerHost(), s.getPeerPort()), s, canQueue);\n@@ -293,0 +307,3 @@\n+        remove(key, false);\n+    }\n+    void remove(SessionId key, boolean isClient) {\n@@ -296,1 +313,3 @@\n-            sessionHostPortCache.remove(\n+            \/\/ A client keeps the cache entry for queued NST resumption.\n+            if (!isClient) {\n+                sessionHostPortCache.remove(\n@@ -298,0 +317,1 @@\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import java.util.Enumeration;\n@@ -135,1 +134,5 @@\n-    private BigInteger ticketNonceCounter = BigInteger.ONE;\n+    private byte ticketNonceCounter = 1;\n+\n+    \/\/ This boolean is true when a new set of NewSessionTickets are needed after\n+    \/\/ the initial ones sent after the handshake.\n+    boolean updateNST = false;\n@@ -495,1 +498,1 @@\n-                buf.get(b, 0 , i);\n+                buf.get(b, 0, i);\n@@ -504,2 +507,7 @@\n-                this.pskIdentity = new byte[buf.get()];\n-                buf.get(pskIdentity);\n+                i = buf.get();\n+                if (i > 0) {\n+                    this.pskIdentity = new byte[buf.get()];\n+                    buf.get(pskIdentity);\n+                } else {\n+                    this.pskIdentity = null;\n+                }\n@@ -718,4 +726,2 @@\n-    BigInteger incrTicketNonceCounter() {\n-        BigInteger result = ticketNonceCounter;\n-        ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);\n-        return result;\n+    byte[] incrTicketNonceCounter() {\n+        return new byte[] {ticketNonceCounter++};\n@@ -725,1 +731,1 @@\n-        return (ticketNonceCounter.compareTo(BigInteger.ZERO) > 0);\n+        return (ticketNonceCounter > 0);\n@@ -784,0 +790,4 @@\n+    public boolean isPSK() {\n+        return (pskIdentity != null && pskIdentity.length > 0);\n+    }\n+\n@@ -1233,1 +1243,0 @@\n-    boolean updateNST;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1324,1 +1324,0 @@\n-                conContext.conSession.updateNST = false;\n@@ -1559,6 +1558,7 @@\n-        if (!conContext.sslConfig.isClientMode &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                conContext.handshakeContext == null &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            !conContext.sslConfig.isClientMode &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            conContext.handshakeContext == null &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n@@ -1568,0 +1568,1 @@\n+            conContext.conSession.updateNST = false;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import javax.net.ssl.SSLSession;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n@@ -29,1 +32,2 @@\n-import java.lang.ref.*;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -93,0 +97,9 @@\n+    \/**\n+     * Add V to the cache with the option to use a QueueCacheEntry if the\n+     * cache is configured for it.  If the cache is not configured for a queue,\n+     * V will silently add the entry directly.\n+     *\/\n+    public void put(K key, V value, boolean canQueue) {\n+        put(key, value);\n+    }\n+\n@@ -140,0 +153,5 @@\n+    public static <K,V> Cache<K,V> newSoftMemoryQueue(int size, int timeout,\n+        int maxQueueSize) {\n+        return new MemoryCache<>(true, size, timeout, maxQueueSize);\n+    }\n+\n@@ -251,3 +269,1 @@\n-    private static final float LOAD_FACTOR = 0.75f;\n-\n-    \/\/ XXXX\n+    \/\/ Debugging\n@@ -258,0 +274,1 @@\n+    final private int maxQueueSize;\n@@ -266,1 +283,1 @@\n-        this(soft, maxSize, 0);\n+        this(soft, maxSize, 0, 0);\n@@ -270,0 +287,4 @@\n+        this(soft, maxSize, lifetime, 0);\n+    }\n+\n+    public MemoryCache(boolean soft, int maxSize, int lifetime, int qSize) {\n@@ -271,0 +292,1 @@\n+        this.maxQueueSize = qSize;\n@@ -272,1 +294,1 @@\n-        if (soft)\n+        if (soft) {\n@@ -274,1 +296,1 @@\n-        else\n+        } else {\n@@ -276,2 +298,4 @@\n-\n-        cacheMap = new LinkedHashMap<>(1, LOAD_FACTOR, true);\n+        }\n+        \/\/ LinkedHashMap is needed for its access order.  0.75f load factor is\n+        \/\/ default.\n+        cacheMap = new LinkedHashMap<>(1, 0.75f, true);\n@@ -341,0 +365,4 @@\n+                \/\/ If this is a queue, check for some expired entries\n+                if (entry instanceof QueueCacheEntry<K,V> qe) {\n+                    qe.getQueue().removeIf(e -> !e.isValid(time));\n+                }\n@@ -370,1 +398,20 @@\n-    public synchronized void put(K key, V value) {\n+    public void put(K key, V value) {\n+        put(key, value, false);\n+    }\n+\n+    \/**\n+     * This puts an entry into the cacheMap.\n+     *\n+     * If canQueue is true, V will be added using a QueueCacheEntry which\n+     * is added to cacheMap.  If false, V is added to the cacheMap directly.\n+     * The caller must keep a consistent canQueue value, mixing them can\n+     * result in a queue being replaced with a single entry.\n+     *\n+     * This method is synchronized to avoid multiple QueueCacheEntry\n+     * overwriting the same key.\n+     *\n+     * @param key key to the cacheMap\n+     * @param value value to be stored\n+     * @param canQueue can the value be put into a QueueCacheEntry\n+     *\/\n+    public synchronized void put(K key, V value, boolean canQueue) {\n@@ -372,2 +419,2 @@\n-        long expirationTime = (lifetime == 0) ? 0 :\n-                                        System.currentTimeMillis() + lifetime;\n+        long expirationTime =\n+            (lifetime == 0) ? 0 : System.currentTimeMillis() + lifetime;\n@@ -378,4 +425,27 @@\n-        CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n-        if (oldEntry != null) {\n-            oldEntry.invalidate();\n-            return;\n+        if (maxQueueSize == 0 || !canQueue) {\n+            CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n+            if (oldEntry != null) {\n+                oldEntry.invalidate();\n+            }\n+        } else {\n+            CacheEntry<K, V> entry = cacheMap.get(key);\n+            switch (entry) {\n+                case QueueCacheEntry<K, V> qe -> {\n+                    qe.putValue(newEntry);\n+                    if (DEBUG) {\n+                        System.out.println(\"QueueCacheEntry= \" + qe);\n+                        final AtomicInteger i = new AtomicInteger(1);\n+                        qe.queue.stream().forEach(e ->\n+                            System.out.println(i.getAndIncrement() + \"= \" + e));\n+                    }\n+                }\n+                case null, default ->\n+                    cacheMap.put(key, new QueueCacheEntry<>(key, newEntry,\n+                        expirationTime, maxQueueSize));\n+            }\n+\n+            if (DEBUG) {\n+                System.out.println(\"Cache entry added: key=\" +\n+                    key.toString() + \", class=\" +\n+                    (entry != null ? entry.getClass().getName() : null));\n+            }\n@@ -404,2 +474,3 @@\n-        long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n-        if (!entry.isValid(time)) {\n+\n+        if (lifetime > 0 && !entry.isValid(System.currentTimeMillis())) {\n+            cacheMap.remove(key);\n@@ -409,1 +480,0 @@\n-            cacheMap.remove(key);\n@@ -412,0 +482,9 @@\n+\n+        \/\/ If the value is a queue, return a queue entry.\n+        if (entry instanceof QueueCacheEntry<K, V> qe) {\n+            V result = qe.getValue(lifetime);\n+            if (qe.isEmpty()) {\n+                removeImpl(key);\n+            }\n+            return result;\n+        }\n@@ -417,0 +496,4 @@\n+        removeImpl(key);\n+    }\n+\n+    private void removeImpl(Object key) {\n@@ -422,1 +505,0 @@\n-\n@@ -553,3 +635,2 @@\n-    private static class SoftCacheEntry<K,V>\n-            extends SoftReference<V>\n-            implements CacheEntry<K,V> {\n+    private static class SoftCacheEntry<K,V> extends SoftReference<V>\n+        implements CacheEntry<K,V> {\n@@ -592,0 +673,7 @@\n+\n+        @Override\n+        public String toString() {\n+            if (get() instanceof SSLSession se)\n+                return HexFormat.of().formatHex(se.getId());\n+            return super.toString();\n+        }\n@@ -594,1 +682,104 @@\n-}\n+    \/**\n+     * This CacheEntry<K,V> type allows multiple V entries to be stored in\n+     * one key in the cacheMap.\n+     *\n+     * This implementation is need for TLS clients that receive multiple\n+     * PSKs or NewSessionTickets for server resumption.\n+     *\/\n+    private static class QueueCacheEntry<K,V> implements CacheEntry<K,V> {\n+\n+        \/\/ Limit the number of queue entries.\n+        private final int MAXQUEUESIZE;\n+\n+        final boolean DEBUG = false;\n+        private K key;\n+        private long expirationTime;\n+        final Queue<CacheEntry<K,V>> queue = new ConcurrentLinkedQueue<>();\n+\n+        QueueCacheEntry(K key, CacheEntry<K,V> entry, long expirationTime,\n+            int maxSize) {\n+            this.key = key;\n+            this.expirationTime = expirationTime;\n+            this.MAXQUEUESIZE = maxSize;\n+            queue.add(entry);\n+        }\n+\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        public V getValue() {\n+            return getValue(0);\n+        }\n+\n+        public V getValue(long lifetime) {\n+            long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n+            do {\n+                var entry = queue.poll();\n+                if (entry == null) {\n+                    return null;\n+                }\n+                if (entry.isValid(time)) {\n+                    return entry.getValue();\n+                }\n+                entry.invalidate();\n+            } while (!queue.isEmpty());\n+\n+            return null;\n+        }\n+\n+        public long getExpirationTime() {\n+            return expirationTime;\n+        }\n+\n+        public void setExpirationTime(long time) {\n+            expirationTime = time;\n+        }\n+\n+        public void putValue(CacheEntry<K,V> entry) {\n+            if (DEBUG) {\n+                System.out.println(\"Added to queue (size=\" + queue.size() +\n+                    \"): \" + entry.getKey().toString() + \",  \" + entry);\n+            }\n+            \/\/ Update the cache entry's expiration time to the latest entry.\n+            \/\/ The getValue() calls will remove expired tickets.\n+            expirationTime = entry.getExpirationTime();\n+            \/\/ Limit the number of queue entries, removing the oldest.\n+            if (queue.size() >= MAXQUEUESIZE) {\n+                queue.remove();\n+            }\n+            queue.add(entry);\n+        }\n+\n+        public boolean isValid(long currentTime) {\n+            boolean valid = (currentTime <= expirationTime) && !queue.isEmpty();\n+            if (!valid) {\n+                invalidate();\n+            }\n+            return valid;\n+        }\n+\n+        public boolean isValid() {\n+            return isValid(System.currentTimeMillis());\n+        }\n+\n+        public void invalidate() {\n+            clear();\n+            key = null;\n+            expirationTime = -1;\n+        }\n+\n+        public void clear() {\n+            queue.forEach(CacheEntry::invalidate);\n+            queue.clear();\n+        }\n+\n+        public boolean isEmpty() {\n+            return queue.isEmpty();\n+        }\n+\n+        public Queue<CacheEntry<K,V>> getQueue() {\n+            return queue;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Cache.java","additions":216,"deletions":25,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.function.UnaryOperator;\n@@ -94,4 +93,0 @@\n-    \/\/ Interned BaseLocale cache\n-    private static final ReferencedKeySet<BaseLocale> CACHE =\n-            ReferencedKeySet.create(true, ReferencedKeySet.concurrentHashMapSupplier());\n-\n@@ -166,13 +161,3 @@\n-        return CACHE.intern(new BaseLocale(language, script, region, variant),\n-                \/\/ Avoid lambdas since this may be on the bootstrap path in many locales\n-                INTERNER);\n-    }\n-\n-    public static final UnaryOperator<BaseLocale> INTERNER = new UnaryOperator<>() {\n-        @Override\n-        public BaseLocale apply(BaseLocale b) {\n-            return new BaseLocale(\n-                    LocaleUtils.toLowerString(b.language).intern(),\n-                    LocaleUtils.toTitleString(b.script).intern(),\n-                    LocaleUtils.toUpperString(b.region).intern(),\n-                    b.variant.intern());\n+        class InterningCache { \/\/ TODO: StableValue\n+            private static final ReferencedKeySet<BaseLocale> CACHE =\n+                    ReferencedKeySet.create(true, ReferencedKeySet.concurrentHashMapSupplier());\n@@ -180,1 +165,6 @@\n-    };\n+        return InterningCache.CACHE.intern(new BaseLocale(\n+                language.intern(), \/\/ guaranteed to be lower-case\n+                LocaleUtils.toTitleString(script).intern(),\n+                region.intern(), \/\/ guaranteed to be upper-case\n+                variant.intern()));\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -116,0 +116,3 @@\n+\/\/ This is defined in link_type.c due to linking restraints\n+jboolean JLI_IsStaticallyLinked();\n+\n","filename":"src\/java.base\/share\/native\/libjli\/jli_util.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+\/\/ This is in a separate file since it will need to be compiled to two different\n+\/\/ object files, depending on if we are going to build a static or a dynamic\n+\/\/ library.\n+\n+jboolean JLI_IsStaticallyLinked(void) {\n+#ifdef STATIC_BUILD\n+  return JNI_TRUE;\n+#else\n+  return JNI_FALSE;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libjli\/link_type.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-    outputConsumedID = (*env)->GetFieldID(env, cls, \"outputConsumed\", \"I\");\n@@ -54,0 +53,1 @@\n+    outputConsumedID = (*env)->GetFieldID(env, cls, \"outputConsumed\", \"I\");\n","filename":"src\/java.base\/share\/native\/libzip\/Inflater.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -664,2 +664,0 @@\n-    char fn[32];\n-    char exePath[PATH_MAX];\n@@ -668,1 +666,0 @@\n-    int ret;\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.c","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-static char *isFileIdentical(char* buf, size_t size, char *pathname);\n-\n@@ -62,4 +60,0 @@\n-#if defined(_AIX)\n-static const char *ETC_ENVIRONMENT_FILE = \"\/etc\/environment\";\n-#endif\n-\n@@ -67,0 +61,1 @@\n+static char *isFileIdentical(char* buf, size_t size, char *pathname);\n@@ -359,0 +354,1 @@\n+static const char *ETC_ENVIRONMENT_FILE = \"\/etc\/environment\";\n","filename":"src\/java.base\/unix\/native\/libjava\/TimeZone_md.c","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -496,3 +496,0 @@\n-    char **mclr;\n-    int  mccr = 0;\n-    char *dsr;\n","filename":"src\/java.desktop\/aix\/native\/libawt_xawt\/awt\/awt_InputMethod.c","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1061,1 +1061,1 @@\n-                     \"ctrl shift RIGHT\", \"selectNextColumnExtendSelection\",\n+                     \"ctrl shift RIGHT\", \"selectLastColumnExtendSelection\",\n@@ -1069,1 +1069,1 @@\n-                      \"ctrl shift LEFT\", \"selectPreviousColumnExtendSelection\",\n+                      \"ctrl shift LEFT\", \"selectFirstColumnExtendSelection\",\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKLookAndFeel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -397,1 +397,4 @@\n-     * divider is contained in changes. Will create the\n+     * divider is contained in changes.\n+     * If a particular L&amp;F supports this Swing\n+     * \"SplitPane.supportsOneTouchButtons\" property\n+     * it will create the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSplitPaneDivider.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-    int i = 0;\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/CUPSfuncs.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-    int i, j, k, cmapsize, nfree, depth, bpp;\n+    int i, k, cmapsize, nfree, depth, bpp;\n@@ -881,1 +881,0 @@\n-    jobject cspaceL;\n@@ -1036,1 +1035,0 @@\n-        jlong pData;\n@@ -1236,5 +1234,4 @@\n-    int i, pixel;\n-    for (i = 0; i < num_colors; i++)\n-        pixel = alloc_col (awt_display, awtData->awt_cmap, red (rgbColors [i]),\n-                           green (rgbColors [i]), blue (rgbColors [i]), -1,\n-                           awtData);\n+    for (int i = 0; i < num_colors; i++)\n+        alloc_col (awt_display, awtData->awt_cmap, red (rgbColors [i]),\n+                   green (rgbColors [i]), blue (rgbColors [i]), -1,\n+                   awtData);\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/X11Color.c","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-    jboolean ret;\n@@ -137,1 +136,1 @@\n-    int i, pos, slen, nPaths, numDirs;\n+    int i, pos, slen, nPaths;\n@@ -536,1 +535,0 @@\n-    FcInitLoadConfigFuncType FcInitLoadConfig;\n@@ -546,1 +544,0 @@\n-    FcConfig *fontconfig;\n@@ -550,4 +547,1 @@\n-    FcStrList *strList;\n-    FcChar8 *str;\n-    int i, f, found, len=0;\n-    char **fontPath;\n+    int i, f, found;\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/fontpath.c","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-static Atom psAtom = 0;\n-static Atom fullNameAtom = 0;\n@@ -130,1 +128,0 @@\n-    JNIEnv *env;\n@@ -133,0 +130,1 @@\n+    JNIEnv *env;\n@@ -271,1 +269,1 @@\n-    unsigned char *srcRow, *dstRow, *dstByte;\n+    unsigned char *srcRow, *dstRow;\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11FontScaler_md.c","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -574,1 +574,0 @@\n-    jobject pointArray;\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11Renderer.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -885,1 +885,1 @@\n-        int x, y, w, h;\n+        int x, y;\n@@ -888,2 +888,0 @@\n-        w = pRasInfo->bounds.x2 - x;\n-        h = pRasInfo->bounds.y2 - y;\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11SurfaceData.c","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-    int scan, screen;\n+    int screen;\n@@ -239,2 +239,0 @@\n-    scan = theImage->bytes_per_line;\n-\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11TextRenderer_md.c","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,7 +119,1 @@\n-#ifndef STATIC_BUILD\n-    \/* Get address of this library and the directory containing it. *\/\n-    dladdr((void *)AWT_OnLoad, &dlinfo);\n-    realpath((char *)dlinfo.dli_fname, buf);\n-    len = strlen(buf);\n-    p = strrchr(buf, '\/');\n-#endif\n+\n@@ -132,1 +126,1 @@\n-        tk = LWAWT_PATH;\n+    tk = LWAWT_PATH;\n@@ -134,2 +128,1 @@\n-        tk = XAWT_PATH;\n-#endif\n+    tk = XAWT_PATH;\n@@ -137,1 +130,0 @@\n-#ifndef MACOSX\n@@ -143,4 +135,6 @@\n-#ifndef STATIC_BUILD\n-    \/* Calculate library name to load *\/\n-    strncpy(p, tk, MAXPATHLEN-len-1);\n-#endif\n+    if (!JVM_IsStaticallyLinked()) {\n+        \/* Get address of this library and the directory containing it. *\/\n+        dladdr((void *)AWT_OnLoad, &dlinfo);\n+        realpath((char *)dlinfo.dli_fname, buf);\n+        len = strlen(buf);\n+        p = strrchr(buf, '\/');\n@@ -148,6 +142,11 @@\n-#ifndef STATIC_BUILD\n-    jstring jbuf = JNU_NewStringPlatform(env, buf);\n-    CHECK_EXCEPTION_FATAL(env, \"Could not allocate library name\");\n-    JNU_CallStaticMethodByName(env, NULL, \"java\/lang\/System\", \"load\",\n-                               \"(Ljava\/lang\/String;)V\",\n-                               jbuf);\n+        \/* Calculate library name to load *\/\n+        strncpy(p, tk, MAXPATHLEN-len-1);\n+\n+        jstring jbuf = JNU_NewStringPlatform(env, buf);\n+        CHECK_EXCEPTION_FATAL(env, \"Could not allocate library name\");\n+        JNU_CallStaticMethodByName(env, NULL, \"java\/lang\/System\", \"load\",\n+                                   \"(Ljava\/lang\/String;)V\",\n+                                   jbuf);\n+\n+        awtHandle = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL);\n+    }\n@@ -155,2 +154,0 @@\n-    awtHandle = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL);\n-#endif\n","filename":"src\/java.desktop\/unix\/native\/libawt\/awt\/awt_LoadLibrary.c","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -307,1 +307,0 @@\n-    char errmsg[128];\n@@ -725,1 +724,0 @@\n-    int i;\n@@ -875,1 +873,0 @@\n-    int a, b, c;\n@@ -1157,1 +1154,1 @@\n-    int i, n;\n+    int i;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/awt_GraphicsEnv.c","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -796,2 +796,0 @@\n-    int                 count=0 ;\n-\n@@ -826,2 +824,0 @@\n-                count++;\n-\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/multiVis.c","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-    Atom type, atom, actual_type;\n+    Atom atom, actual_type;\n@@ -254,2 +254,0 @@\n-    XSizeHints sizeHints;\n-\n@@ -743,1 +741,0 @@\n-    int rc;\n@@ -747,1 +744,1 @@\n-    rc = pthread_create(&thr, &attr, SplashScreenThread, (void *) splash);\n+    pthread_create(&thr, &attr, SplashScreenThread, (void *) splash);\n","filename":"src\/java.desktop\/unix\/native\/libsplashscreen\/splashscreen_sys.c","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,0 @@\n- * <blockquote>\n@@ -133,1 +132,0 @@\n- * <\/blockquote>\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ManagementFactory.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import jdk.internal.net.http.common.Log;\n@@ -495,1 +496,1 @@\n-    private void removeFromPool(HttpConnection c) {\n+    private boolean removeFromPool(HttpConnection c) {\n@@ -498,1 +499,1 @@\n-            removeFromPool(c, plainPool);\n+            return removeFromPool(c, plainPool);\n@@ -501,1 +502,1 @@\n-            removeFromPool(c, sslPool);\n+            return removeFromPool(c, sslPool);\n@@ -527,1 +528,1 @@\n-    void cleanup(HttpConnection c, Throwable error) {\n+    void cleanup(HttpConnection c, long pendingData, Throwable error) {\n@@ -532,0 +533,1 @@\n+        boolean removed;\n@@ -533,1 +535,1 @@\n-            removeFromPool(c);\n+            removed = removeFromPool(c);\n@@ -538,1 +540,18 @@\n-        c.close();\n+        if (!removed && pendingData != 0) {\n+            \/\/ this should not happen; the cleanup may have consumed\n+            \/\/ some data that wasn't supposed to be consumed, so\n+            \/\/ the only thing we can do is log it and close the\n+            \/\/ connection.\n+            if (Log.errors()) {\n+                Log.logError(\"WARNING: CleanupTrigger triggered for\" +\n+                        \" a connection not found in the pool: closing {0}\", c.dbgString());\n+            }\n+            if (debug.on()) {\n+                debug.log(\"WARNING: CleanupTrigger triggered for\" +\n+                        \" a connection not found in the pool: closing %s\", c.dbgString());\n+            }\n+            Throwable cause = new IOException(\"Unexpected cleanup triggered for non pooled connection\", error);\n+            c.close(cause);\n+        } else {\n+            c.close();\n+        }\n@@ -552,0 +571,1 @@\n+        private volatile boolean dropped;\n@@ -559,1 +579,1 @@\n-        private void triggerCleanup(Throwable error) {\n+        private void triggerCleanup(long pendingData, Throwable error) {\n@@ -561,1 +581,4 @@\n-            cleanup(connection, error);\n+            if (debug.on()) {\n+                debug.log(\"Cleanup triggered for %s: pendingData:%s error:%s\", this, pendingData, error);\n+            }\n+            cleanup(connection, pendingData, error);\n@@ -569,0 +592,1 @@\n+            if (dropped || done) return;\n@@ -572,1 +596,1 @@\n-        public void onError(Throwable error) { triggerCleanup(error); }\n+        public void onError(Throwable error) { triggerCleanup(0, error); }\n@@ -574,1 +598,1 @@\n-        public void onComplete() { triggerCleanup(null); }\n+        public void onComplete() { triggerCleanup(0, null); }\n@@ -577,1 +601,1 @@\n-            triggerCleanup(new IOException(\"Data received while in pool\"));\n+            triggerCleanup(Utils.remaining(item), new IOException(\"Data received while in pool\"));\n@@ -589,0 +613,5 @@\n+\n+        @Override\n+        public void dropSubscription() {\n+            dropped = true;\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ConnectionPool.java","additions":41,"deletions":12,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.concurrent.ConcurrentLinkedQueue;\n@@ -560,1 +561,1 @@\n-        AtomicReference<ReadSubscription> pendingSubscription = new AtomicReference<>();\n+        ConcurrentLinkedQueue<ReadSubscription> pendingSubscriptions = new ConcurrentLinkedQueue<>();\n@@ -568,4 +569,2 @@\n-            ReadSubscription target = new ReadSubscription(subscriptionImpl, sub);\n-            ReadSubscription previous = pendingSubscription.getAndSet(target);\n-\n-            if (previous != null && previous != target) {\n+            ReadSubscription previous;\n+            while ((previous = pendingSubscriptions.poll()) != null) {\n@@ -576,0 +575,2 @@\n+                \/\/ make sure no data will be routed to the old subscriber.\n+                previous.stopReading();\n@@ -583,0 +584,2 @@\n+            ReadSubscription target = new ReadSubscription(subscriptionImpl, sub);\n+            pendingSubscriptions.offer(target);\n@@ -584,1 +587,1 @@\n-            if (debug.on()) debug.log(\"read publisher got subscriber\");\n+            if (debug.on()) debug.log(\"read publisher got new subscriber: \" + s);\n@@ -609,0 +612,1 @@\n+            private volatile boolean stopped;\n@@ -626,1 +630,2 @@\n-                if (!cancelled) {\n+                if (!cancelled && !stopped) {\n+                    \/\/ should be safe to not synchronize here.\n@@ -630,1 +635,1 @@\n-                        debug.log(\"subscription cancelled, ignoring request %d\", n);\n+                        debug.log(\"subscription stopped or cancelled, ignoring request %d\", n);\n@@ -664,0 +669,26 @@\n+\n+            \/**\n+             * Called when switching subscriber on the {@link InternalReadSubscription}.\n+             * This subscriber is the old subscriber. Demand on the internal\n+             * subscription will be reset and reading will be paused until the\n+             * new subscriber is subscribed.\n+             * This should ensure that no data is routed to this subscriber\n+             * until the new subscriber is subscribed.\n+             *\/\n+            synchronized void stopReading() {\n+                stopped = true;\n+                impl.demand.reset();\n+            }\n+\n+            synchronized boolean tryDecrementDemand() {\n+                if (stopped) return false;\n+                return impl.demand.tryDecrement();\n+            }\n+\n+            synchronized boolean isStopped() {\n+                return stopped;\n+            }\n+\n+            synchronized void increaseDemand(long n) {\n+                if (!stopped) impl.demand.increase(n);\n+            }\n@@ -838,1 +869,1 @@\n-                        if (demand.tryDecrement()) {\n+                        if (current.tryDecrementDemand()) {\n@@ -884,2 +915,4 @@\n-                                    demand.increase(1);\n-                                    resumeReadEvent();\n+                                    if (!current.isStopped()) {\n+                                        current.increaseDemand(1);\n+                                        resumeReadEvent();\n+                                    }\n@@ -925,4 +958,6 @@\n-                ReadSubscription pending = pendingSubscription.getAndSet(null);\n-                if (pending == null) return false;\n-                if (debug.on())\n-                    debug.log(\"handling pending subscription for %s\",\n+                ReadSubscription pending;\n+                boolean subscribed = false;\n+                while ((pending = pendingSubscriptions.poll()) != null) {\n+                    subscribed = true;\n+                    if (debug.on())\n+                        debug.log(\"handling pending subscription for %s\",\n@@ -930,15 +965,8 @@\n-                ReadSubscription current = subscription;\n-                if (current != null && current != pending && !completed) {\n-                    current.subscriber.dropSubscription();\n-                }\n-                if (debug.on()) debug.log(\"read demand reset to 0\");\n-                subscriptionImpl.demand.reset(); \/\/ subscriber will increase demand if it needs to.\n-                pending.errorRef.compareAndSet(null, errorRef.get());\n-                if (!readScheduler.isStopped()) {\n-                    subscription = pending;\n-                } else {\n-                    if (debug.on()) debug.log(\"socket tube is already stopped\");\n-                }\n-                if (debug.on()) debug.log(\"calling onSubscribe\");\n-                pending.signalOnSubscribe();\n-                if (completed) {\n+                    ReadSubscription current = subscription;\n+                    if (current != null && current != pending && !completed) {\n+                        debug.log(\"dropping pending subscription for current %s\",\n+                                current.subscriber);\n+                        current.subscriber.dropSubscription();\n+                    }\n+                    if (debug.on()) debug.log(\"read demand reset to 0\");\n+                    subscriptionImpl.demand.reset(); \/\/ subscriber will increase demand if it needs to.\n@@ -946,1 +974,11 @@\n-                    pending.signalCompletion();\n+                    if (!readScheduler.isStopped()) {\n+                        subscription = pending;\n+                    } else {\n+                        if (debug.on()) debug.log(\"socket tube is already stopped\");\n+                    }\n+                    if (debug.on()) debug.log(\"calling onSubscribe on \" + pending.subscriber);\n+                    pending.signalOnSubscribe();\n+                    if (completed) {\n+                        pending.errorRef.compareAndSet(null, errorRef.get());\n+                        pending.signalCompletion();\n+                    }\n@@ -948,1 +986,1 @@\n-                return true;\n+                return subscribed;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/SocketTube.java","additions":71,"deletions":33,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,0 +183,4 @@\n+            @Override\n+            public String toString() {\n+                return \"TubeSubscriberWrapper(\"+delegate.toString()+\")\";\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/FlowTube.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,691 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.net.http.hpack;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-\n-import static java.lang.String.format;\n-\n-\/**\n- * Huffman coding table.\n- *\n- * <p> Instances of this class are safe for use by multiple threads.\n- *\n- * @since 9\n- *\/\n-public final class NaiveHuffman {\n-\n-    \/\/ TODO: check if reset is done in both reader and writer\n-\n-    static final class Reader implements Huffman.Reader {\n-\n-        private Node curr; \/\/ position in the trie\n-        private int len;   \/\/ length of the path from the root to 'curr'\n-        private int p;     \/\/ byte probe\n-\n-        {\n-            reset();\n-        }\n-\n-        @Override\n-        public void read(ByteBuffer source,\n-                         Appendable destination,\n-                         boolean isLast) throws IOException {\n-            read(source, destination, true, isLast);\n-        }\n-\n-        \/\/ Takes 'isLast' rather than returns whether the reading is done or\n-        \/\/ not, for more informative exceptions.\n-        void read(ByteBuffer source,\n-                  Appendable destination,\n-                  boolean reportEOS, \/* reportEOS is exposed for tests *\/\n-                  boolean isLast) throws IOException {\n-            Node c = curr;\n-            int l = len;\n-            \/*\n-               Since ByteBuffer is itself stateful, its position is\n-               remembered here NOT as a part of Reader's state,\n-               but to set it back in the case of a failure\n-             *\/\n-            int pos = source.position();\n-\n-            while (source.hasRemaining()) {\n-                int d = source.get();\n-                for (; p != 0; p >>= 1) {\n-                    c = c.getChild(p & d);\n-                    l++;\n-                    if (c.isLeaf()) {\n-                        if (reportEOS && c.isEOSPath) {\n-                            throw new IOException(\"Encountered EOS\");\n-                        }\n-                        char ch;\n-                        try {\n-                            ch = c.getChar();\n-                        } catch (IllegalStateException e) {\n-                            source.position(pos); \/\/ do we need this?\n-                            throw new IOException(e);\n-                        }\n-                        try {\n-                            destination.append(ch);\n-                        } catch (IOException e) {\n-                            source.position(pos); \/\/ do we need this?\n-                            throw e;\n-                        }\n-                        c = INSTANCE.root;\n-                        l = 0;\n-                    }\n-                    curr = c;\n-                    len = l;\n-                }\n-                resetProbe();\n-                pos++;\n-            }\n-            if (!isLast) {\n-                return; \/\/ it's too early to jump to any conclusions, let's wait\n-            }\n-            if (c.isLeaf()) {\n-                return; \/\/ it's perfectly ok, no extra padding bits\n-            }\n-            if (c.isEOSPath && len <= 7) {\n-                return; \/\/ it's ok, some extra padding bits\n-            }\n-            if (c.isEOSPath) {\n-                throw new IOException(\n-                        \"Padding is too long (len=\" + len + \") \" +\n-                                \"or unexpected end of data\");\n-            }\n-            throw new IOException(\n-                    \"Not a EOS prefix padding or unexpected end of data\");\n-        }\n-\n-        @Override\n-        public void reset() {\n-            curr = INSTANCE.root;\n-            len = 0;\n-            resetProbe();\n-        }\n-\n-        private void resetProbe() {\n-            p = 0x80;\n-        }\n-    }\n-\n-    static final class Writer implements Huffman.Writer {\n-\n-        private int pos;       \/\/ position in 'source'\n-        private int avail = 8; \/\/ number of least significant bits available in 'curr'\n-        private int curr;      \/\/ next byte to put to the destination\n-        private int rem;       \/\/ number of least significant bits in 'code' yet to be processed\n-        private int code;      \/\/ current code being written\n-\n-        private CharSequence source;\n-        private int end;\n-\n-        @Override\n-        public Writer from(CharSequence input, int start, int end) {\n-            if (start < 0 || end < 0 || end > input.length() || start > end) {\n-                throw new IndexOutOfBoundsException(\n-                        String.format(\"input.length()=%s, start=%s, end=%s\",\n-                                      input.length(), start, end));\n-            }\n-            pos = start;\n-            this.end = end;\n-            this.source = input;\n-            return this;\n-        }\n-\n-        @Override\n-        public boolean write(ByteBuffer destination) {\n-            for (; pos < end; pos++) {\n-                if (rem == 0) {\n-                    Code desc = INSTANCE.codeOf(source.charAt(pos));\n-                    rem = desc.length;\n-                    code = desc.code;\n-                }\n-                while (rem > 0) {\n-                    if (rem < avail) {\n-                        curr |= (code << (avail - rem));\n-                        avail -= rem;\n-                        rem = 0;\n-                    } else {\n-                        int c = (curr | (code >>> (rem - avail)));\n-                        if (destination.hasRemaining()) {\n-                            destination.put((byte) c);\n-                        } else {\n-                            return false;\n-                        }\n-                        curr = c;\n-                        code <<= (32 - rem + avail);  \/\/ throw written bits off the cliff (is this Sparta?)\n-                        code >>>= (32 - rem + avail); \/\/ return to the position\n-                        rem -= avail;\n-                        curr = 0;\n-                        avail = 8;\n-                    }\n-                }\n-            }\n-\n-            if (avail < 8) { \/\/ have to pad\n-                if (destination.hasRemaining()) {\n-                    destination.put((byte) (curr | (INSTANCE.EOS.code >>> (INSTANCE.EOS.length - avail))));\n-                    avail = 8;\n-                } else {\n-                    return false;\n-                }\n-            }\n-\n-            return true;\n-        }\n-\n-        @Override\n-        public Writer reset() {\n-            source = null;\n-            end = -1;\n-            pos = -1;\n-            avail = 8;\n-            curr = 0;\n-            code = 0;\n-            return this;\n-        }\n-\n-        @Override\n-        public int lengthOf(CharSequence value, int start, int end) {\n-            return INSTANCE.lengthOf(value, start, end);\n-        }\n-    }\n-\n-    \/**\n-     * Shared instance.\n-     *\/\n-    public static final NaiveHuffman INSTANCE = new NaiveHuffman();\n-\n-    private final Code EOS = new Code(0x3fffffff, 30);\n-    private final Code[] codes = new Code[257];\n-    private final Node root = new Node() {\n-        @Override\n-        public String toString() { return \"root\"; }\n-    };\n-\n-    \/\/ TODO: consider builder and immutable trie\n-    private NaiveHuffman() {\n-        \/\/ @formatter:off\n-        addChar(0,   0x1ff8,     13);\n-        addChar(1,   0x7fffd8,   23);\n-        addChar(2,   0xfffffe2,  28);\n-        addChar(3,   0xfffffe3,  28);\n-        addChar(4,   0xfffffe4,  28);\n-        addChar(5,   0xfffffe5,  28);\n-        addChar(6,   0xfffffe6,  28);\n-        addChar(7,   0xfffffe7,  28);\n-        addChar(8,   0xfffffe8,  28);\n-        addChar(9,   0xffffea,   24);\n-        addChar(10,  0x3ffffffc, 30);\n-        addChar(11,  0xfffffe9,  28);\n-        addChar(12,  0xfffffea,  28);\n-        addChar(13,  0x3ffffffd, 30);\n-        addChar(14,  0xfffffeb,  28);\n-        addChar(15,  0xfffffec,  28);\n-        addChar(16,  0xfffffed,  28);\n-        addChar(17,  0xfffffee,  28);\n-        addChar(18,  0xfffffef,  28);\n-        addChar(19,  0xffffff0,  28);\n-        addChar(20,  0xffffff1,  28);\n-        addChar(21,  0xffffff2,  28);\n-        addChar(22,  0x3ffffffe, 30);\n-        addChar(23,  0xffffff3,  28);\n-        addChar(24,  0xffffff4,  28);\n-        addChar(25,  0xffffff5,  28);\n-        addChar(26,  0xffffff6,  28);\n-        addChar(27,  0xffffff7,  28);\n-        addChar(28,  0xffffff8,  28);\n-        addChar(29,  0xffffff9,  28);\n-        addChar(30,  0xffffffa,  28);\n-        addChar(31,  0xffffffb,  28);\n-        addChar(32,  0x14,        6);\n-        addChar(33,  0x3f8,      10);\n-        addChar(34,  0x3f9,      10);\n-        addChar(35,  0xffa,      12);\n-        addChar(36,  0x1ff9,     13);\n-        addChar(37,  0x15,        6);\n-        addChar(38,  0xf8,        8);\n-        addChar(39,  0x7fa,      11);\n-        addChar(40,  0x3fa,      10);\n-        addChar(41,  0x3fb,      10);\n-        addChar(42,  0xf9,        8);\n-        addChar(43,  0x7fb,      11);\n-        addChar(44,  0xfa,        8);\n-        addChar(45,  0x16,        6);\n-        addChar(46,  0x17,        6);\n-        addChar(47,  0x18,        6);\n-        addChar(48,  0x0,         5);\n-        addChar(49,  0x1,         5);\n-        addChar(50,  0x2,         5);\n-        addChar(51,  0x19,        6);\n-        addChar(52,  0x1a,        6);\n-        addChar(53,  0x1b,        6);\n-        addChar(54,  0x1c,        6);\n-        addChar(55,  0x1d,        6);\n-        addChar(56,  0x1e,        6);\n-        addChar(57,  0x1f,        6);\n-        addChar(58,  0x5c,        7);\n-        addChar(59,  0xfb,        8);\n-        addChar(60,  0x7ffc,     15);\n-        addChar(61,  0x20,        6);\n-        addChar(62,  0xffb,      12);\n-        addChar(63,  0x3fc,      10);\n-        addChar(64,  0x1ffa,     13);\n-        addChar(65,  0x21,        6);\n-        addChar(66,  0x5d,        7);\n-        addChar(67,  0x5e,        7);\n-        addChar(68,  0x5f,        7);\n-        addChar(69,  0x60,        7);\n-        addChar(70,  0x61,        7);\n-        addChar(71,  0x62,        7);\n-        addChar(72,  0x63,        7);\n-        addChar(73,  0x64,        7);\n-        addChar(74,  0x65,        7);\n-        addChar(75,  0x66,        7);\n-        addChar(76,  0x67,        7);\n-        addChar(77,  0x68,        7);\n-        addChar(78,  0x69,        7);\n-        addChar(79,  0x6a,        7);\n-        addChar(80,  0x6b,        7);\n-        addChar(81,  0x6c,        7);\n-        addChar(82,  0x6d,        7);\n-        addChar(83,  0x6e,        7);\n-        addChar(84,  0x6f,        7);\n-        addChar(85,  0x70,        7);\n-        addChar(86,  0x71,        7);\n-        addChar(87,  0x72,        7);\n-        addChar(88,  0xfc,        8);\n-        addChar(89,  0x73,        7);\n-        addChar(90,  0xfd,        8);\n-        addChar(91,  0x1ffb,     13);\n-        addChar(92,  0x7fff0,    19);\n-        addChar(93,  0x1ffc,     13);\n-        addChar(94,  0x3ffc,     14);\n-        addChar(95,  0x22,        6);\n-        addChar(96,  0x7ffd,     15);\n-        addChar(97,  0x3,         5);\n-        addChar(98,  0x23,        6);\n-        addChar(99,  0x4,         5);\n-        addChar(100, 0x24,        6);\n-        addChar(101, 0x5,         5);\n-        addChar(102, 0x25,        6);\n-        addChar(103, 0x26,        6);\n-        addChar(104, 0x27,        6);\n-        addChar(105, 0x6,         5);\n-        addChar(106, 0x74,        7);\n-        addChar(107, 0x75,        7);\n-        addChar(108, 0x28,        6);\n-        addChar(109, 0x29,        6);\n-        addChar(110, 0x2a,        6);\n-        addChar(111, 0x7,         5);\n-        addChar(112, 0x2b,        6);\n-        addChar(113, 0x76,        7);\n-        addChar(114, 0x2c,        6);\n-        addChar(115, 0x8,         5);\n-        addChar(116, 0x9,         5);\n-        addChar(117, 0x2d,        6);\n-        addChar(118, 0x77,        7);\n-        addChar(119, 0x78,        7);\n-        addChar(120, 0x79,        7);\n-        addChar(121, 0x7a,        7);\n-        addChar(122, 0x7b,        7);\n-        addChar(123, 0x7ffe,     15);\n-        addChar(124, 0x7fc,      11);\n-        addChar(125, 0x3ffd,     14);\n-        addChar(126, 0x1ffd,     13);\n-        addChar(127, 0xffffffc,  28);\n-        addChar(128, 0xfffe6,    20);\n-        addChar(129, 0x3fffd2,   22);\n-        addChar(130, 0xfffe7,    20);\n-        addChar(131, 0xfffe8,    20);\n-        addChar(132, 0x3fffd3,   22);\n-        addChar(133, 0x3fffd4,   22);\n-        addChar(134, 0x3fffd5,   22);\n-        addChar(135, 0x7fffd9,   23);\n-        addChar(136, 0x3fffd6,   22);\n-        addChar(137, 0x7fffda,   23);\n-        addChar(138, 0x7fffdb,   23);\n-        addChar(139, 0x7fffdc,   23);\n-        addChar(140, 0x7fffdd,   23);\n-        addChar(141, 0x7fffde,   23);\n-        addChar(142, 0xffffeb,   24);\n-        addChar(143, 0x7fffdf,   23);\n-        addChar(144, 0xffffec,   24);\n-        addChar(145, 0xffffed,   24);\n-        addChar(146, 0x3fffd7,   22);\n-        addChar(147, 0x7fffe0,   23);\n-        addChar(148, 0xffffee,   24);\n-        addChar(149, 0x7fffe1,   23);\n-        addChar(150, 0x7fffe2,   23);\n-        addChar(151, 0x7fffe3,   23);\n-        addChar(152, 0x7fffe4,   23);\n-        addChar(153, 0x1fffdc,   21);\n-        addChar(154, 0x3fffd8,   22);\n-        addChar(155, 0x7fffe5,   23);\n-        addChar(156, 0x3fffd9,   22);\n-        addChar(157, 0x7fffe6,   23);\n-        addChar(158, 0x7fffe7,   23);\n-        addChar(159, 0xffffef,   24);\n-        addChar(160, 0x3fffda,   22);\n-        addChar(161, 0x1fffdd,   21);\n-        addChar(162, 0xfffe9,    20);\n-        addChar(163, 0x3fffdb,   22);\n-        addChar(164, 0x3fffdc,   22);\n-        addChar(165, 0x7fffe8,   23);\n-        addChar(166, 0x7fffe9,   23);\n-        addChar(167, 0x1fffde,   21);\n-        addChar(168, 0x7fffea,   23);\n-        addChar(169, 0x3fffdd,   22);\n-        addChar(170, 0x3fffde,   22);\n-        addChar(171, 0xfffff0,   24);\n-        addChar(172, 0x1fffdf,   21);\n-        addChar(173, 0x3fffdf,   22);\n-        addChar(174, 0x7fffeb,   23);\n-        addChar(175, 0x7fffec,   23);\n-        addChar(176, 0x1fffe0,   21);\n-        addChar(177, 0x1fffe1,   21);\n-        addChar(178, 0x3fffe0,   22);\n-        addChar(179, 0x1fffe2,   21);\n-        addChar(180, 0x7fffed,   23);\n-        addChar(181, 0x3fffe1,   22);\n-        addChar(182, 0x7fffee,   23);\n-        addChar(183, 0x7fffef,   23);\n-        addChar(184, 0xfffea,    20);\n-        addChar(185, 0x3fffe2,   22);\n-        addChar(186, 0x3fffe3,   22);\n-        addChar(187, 0x3fffe4,   22);\n-        addChar(188, 0x7ffff0,   23);\n-        addChar(189, 0x3fffe5,   22);\n-        addChar(190, 0x3fffe6,   22);\n-        addChar(191, 0x7ffff1,   23);\n-        addChar(192, 0x3ffffe0,  26);\n-        addChar(193, 0x3ffffe1,  26);\n-        addChar(194, 0xfffeb,    20);\n-        addChar(195, 0x7fff1,    19);\n-        addChar(196, 0x3fffe7,   22);\n-        addChar(197, 0x7ffff2,   23);\n-        addChar(198, 0x3fffe8,   22);\n-        addChar(199, 0x1ffffec,  25);\n-        addChar(200, 0x3ffffe2,  26);\n-        addChar(201, 0x3ffffe3,  26);\n-        addChar(202, 0x3ffffe4,  26);\n-        addChar(203, 0x7ffffde,  27);\n-        addChar(204, 0x7ffffdf,  27);\n-        addChar(205, 0x3ffffe5,  26);\n-        addChar(206, 0xfffff1,   24);\n-        addChar(207, 0x1ffffed,  25);\n-        addChar(208, 0x7fff2,    19);\n-        addChar(209, 0x1fffe3,   21);\n-        addChar(210, 0x3ffffe6,  26);\n-        addChar(211, 0x7ffffe0,  27);\n-        addChar(212, 0x7ffffe1,  27);\n-        addChar(213, 0x3ffffe7,  26);\n-        addChar(214, 0x7ffffe2,  27);\n-        addChar(215, 0xfffff2,   24);\n-        addChar(216, 0x1fffe4,   21);\n-        addChar(217, 0x1fffe5,   21);\n-        addChar(218, 0x3ffffe8,  26);\n-        addChar(219, 0x3ffffe9,  26);\n-        addChar(220, 0xffffffd,  28);\n-        addChar(221, 0x7ffffe3,  27);\n-        addChar(222, 0x7ffffe4,  27);\n-        addChar(223, 0x7ffffe5,  27);\n-        addChar(224, 0xfffec,    20);\n-        addChar(225, 0xfffff3,   24);\n-        addChar(226, 0xfffed,    20);\n-        addChar(227, 0x1fffe6,   21);\n-        addChar(228, 0x3fffe9,   22);\n-        addChar(229, 0x1fffe7,   21);\n-        addChar(230, 0x1fffe8,   21);\n-        addChar(231, 0x7ffff3,   23);\n-        addChar(232, 0x3fffea,   22);\n-        addChar(233, 0x3fffeb,   22);\n-        addChar(234, 0x1ffffee,  25);\n-        addChar(235, 0x1ffffef,  25);\n-        addChar(236, 0xfffff4,   24);\n-        addChar(237, 0xfffff5,   24);\n-        addChar(238, 0x3ffffea,  26);\n-        addChar(239, 0x7ffff4,   23);\n-        addChar(240, 0x3ffffeb,  26);\n-        addChar(241, 0x7ffffe6,  27);\n-        addChar(242, 0x3ffffec,  26);\n-        addChar(243, 0x3ffffed,  26);\n-        addChar(244, 0x7ffffe7,  27);\n-        addChar(245, 0x7ffffe8,  27);\n-        addChar(246, 0x7ffffe9,  27);\n-        addChar(247, 0x7ffffea,  27);\n-        addChar(248, 0x7ffffeb,  27);\n-        addChar(249, 0xffffffe,  28);\n-        addChar(250, 0x7ffffec,  27);\n-        addChar(251, 0x7ffffed,  27);\n-        addChar(252, 0x7ffffee,  27);\n-        addChar(253, 0x7ffffef,  27);\n-        addChar(254, 0x7fffff0,  27);\n-        addChar(255, 0x3ffffee,  26);\n-        addEOS (256, EOS.code,   EOS.length);\n-        \/\/ @formatter:on\n-    }\n-\n-\n-    \/**\n-     * Calculates the number of bytes required to represent the given {@code\n-     * CharSequence} with the Huffman coding.\n-     *\n-     * @param value\n-     *         characters\n-     *\n-     * @return number of bytes\n-     *\n-     * @throws NullPointerException\n-     *         if the value is null\n-     *\/\n-    public int lengthOf(CharSequence value) {\n-        return lengthOf(value, 0, value.length());\n-    }\n-\n-    \/**\n-     * Calculates the number of bytes required to represent a subsequence of the\n-     * given {@code CharSequence} with the Huffman coding.\n-     *\n-     * @param value\n-     *         characters\n-     * @param start\n-     *         the start index, inclusive\n-     * @param end\n-     *         the end index, exclusive\n-     *\n-     * @return number of bytes\n-     *\n-     * @throws NullPointerException\n-     *         if the value is null\n-     * @throws IndexOutOfBoundsException\n-     *         if any invocation of {@code value.charAt(i)}, where\n-     *         {@code start <= i < end} would throw an IndexOutOfBoundsException\n-     *\/\n-    public int lengthOf(CharSequence value, int start, int end) {\n-        int len = 0;\n-        for (int i = start; i < end; i++) {\n-            char c = value.charAt(i);\n-            len += INSTANCE.codeOf(c).length;\n-        }\n-        \/\/ Integer division with ceiling, assumption:\n-        assert (len \/ 8 + (len % 8 != 0 ? 1 : 0)) == (len + 7) \/ 8 : len;\n-        return (len + 7) \/ 8;\n-    }\n-\n-    private void addChar(int c, int code, int bitLength) {\n-        addLeaf(c, code, bitLength, false);\n-        codes[c] = new Code(code, bitLength);\n-    }\n-\n-    private void addEOS(int c, int code, int bitLength) {\n-        addLeaf(c, code, bitLength, true);\n-        codes[c] = new Code(code, bitLength);\n-    }\n-\n-    private void addLeaf(int c, int code, int bitLength, boolean isEOS) {\n-        if (bitLength < 1) {\n-            throw new IllegalArgumentException(\"bitLength < 1\");\n-        }\n-        Node curr = root;\n-        for (int p = 1 << bitLength - 1; p != 0 && !curr.isLeaf(); p = p >> 1) {\n-            curr.isEOSPath |= isEOS; \/\/ If it's already true, it can't become false\n-            curr = curr.addChildIfAbsent(p & code);\n-        }\n-        curr.isEOSPath |= isEOS; \/\/ The last one needs to have this property as well\n-        if (curr.isLeaf()) {\n-            throw new IllegalStateException(\"Specified code is already taken\");\n-        }\n-        curr.setChar((char) c);\n-    }\n-\n-    private Code codeOf(char c) {\n-        if (c > 255) {\n-            throw new IllegalArgumentException(\"char=\" + ((int) c));\n-        }\n-        return codes[c];\n-    }\n-\n-    \/\/\n-    \/\/ For debugging\/testing purposes\n-    \/\/\n-    Node getRoot() {\n-        return root;\n-    }\n-\n-    \/\/\n-    \/\/ Guarantees:\n-    \/\/\n-    \/\/  if (isLeaf() == true) => getChar() is a legal call\n-    \/\/  if (isLeaf() == false) => getChild(i) is a legal call (though it can\n-    \/\/                                                           return null)\n-    \/\/\n-    static class Node {\n-\n-        Node left;\n-        Node right;\n-        boolean isEOSPath;\n-\n-        boolean charIsSet;\n-        char c;\n-\n-        Node getChild(int selector) {\n-            if (isLeaf()) {\n-                throw new IllegalStateException(\"This is a leaf node\");\n-            }\n-            Node result = selector == 0 ? left : right;\n-            if (result == null) {\n-                throw new IllegalStateException(format(\n-                        \"Node doesn't have a child (selector=%s)\", selector));\n-            }\n-            return result;\n-        }\n-\n-        boolean isLeaf() {\n-            return charIsSet;\n-        }\n-\n-        char getChar() {\n-            if (!isLeaf()) {\n-                throw new IllegalStateException(\"This node is not a leaf node\");\n-            }\n-            return c;\n-        }\n-\n-        void setChar(char c) {\n-            if (charIsSet) {\n-                throw new IllegalStateException(\n-                        \"This node has been taken already\");\n-            }\n-            if (left != null || right != null) {\n-                throw new IllegalStateException(\"The node cannot be made \"\n-                                                        + \"a leaf as it's already has a child\");\n-            }\n-            this.c = c;\n-            charIsSet = true;\n-        }\n-\n-        Node addChildIfAbsent(int i) {\n-            if (charIsSet) {\n-                throw new IllegalStateException(\"The node cannot have a child \"\n-                                                        + \"as it's already a leaf node\");\n-            }\n-            Node child;\n-            if (i == 0) {\n-                if ((child = left) == null) {\n-                    child = left = new Node();\n-                }\n-            } else {\n-                if ((child = right) == null) {\n-                    child = right = new Node();\n-                }\n-            }\n-            return child;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            if (isLeaf()) {\n-                if (isEOSPath) {\n-                    return \"EOS\";\n-                } else {\n-                    return format(\"char: (%3s) '%s'\", (int) c, c);\n-                }\n-            }\n-            return \"\/\\\\\";\n-        }\n-    }\n-\n-    \/\/ TODO: value-based class?\n-    \/\/ FIXME: can we re-use Node instead of this class?\n-    private static final class Code {\n-\n-        final int code;\n-        final int length;\n-\n-        private Code(int code, int length) {\n-            this.code = code;\n-            this.length = length;\n-        }\n-\n-        public int getCode() {\n-            return code;\n-        }\n-\n-        public int getLength() {\n-            return length;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            long p = 1 << length;\n-            return Long.toBinaryString(code + p).substring(1)\n-                    + \", length=\" + length;\n-        }\n-    }\n-}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/hpack\/NaiveHuffman.java","additions":0,"deletions":691,"binary":false,"changes":691,"status":"deleted"},{"patch":"@@ -2341,1 +2341,1 @@\n-        private ErrorType(Type originalType, TypeSymbol tsym,\n+        public ErrorType(Type originalType, TypeSymbol tsym,\n@@ -2396,4 +2396,0 @@\n-        public List<Type> allparams()            { return List.nil(); }\n-        @DefinedBy(Api.LANGUAGE_MODEL)\n-        public List<Type> getTypeArguments()     { return List.nil(); }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5084,0 +5084,8 @@\n+        } else if (clazztype.hasTag(ERROR)) {\n+            ErrorType parameterizedErroneous =\n+                    new ErrorType(clazztype.getOriginalType(),\n+                                  clazztype.tsym,\n+                                  clazztype.getMetadata());\n+\n+            parameterizedErroneous.typarams_field = actuals;\n+            owntype = parameterizedErroneous;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import com.sun.tools.javac.parser.VirtualParser.VirtualScanner;\n@@ -459,0 +460,4 @@\n+        return syntaxError(pos, errs, errorKey, false);\n+    }\n+\n+    private JCErroneous syntaxError(int pos, List<? extends JCTree> errs, Error errorKey, boolean noEofError) {\n@@ -461,1 +466,1 @@\n-        reportSyntaxError(err, errorKey);\n+        reportSyntaxError(err, errorKey, noEofError);\n@@ -488,0 +493,4 @@\n+        reportSyntaxError(diagPos, errorKey, false);\n+    }\n+\n+    private void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey, boolean noEofError) {\n@@ -490,1 +499,1 @@\n-            if (token.kind == EOF) {\n+            if (token.kind == EOF && !noEofError) {\n@@ -4095,0 +4104,7 @@\n+                } else if (isDefiniteStatementStartToken()) {\n+                    int startPos = token.pos;\n+                    List<JCStatement> statements = blockStatement();\n+                    defs.append(syntaxError(startPos,\n+                                            statements,\n+                                            Errors.StatementNotExpected,\n+                                            true));\n@@ -4327,0 +4343,3 @@\n+            } else if (Feature.IMPLICIT_CLASSES.allowedInSource(source) &&\n+                       (!preview.isPreview(Feature.IMPLICIT_CLASSES) || preview.isEnabled())) {\n+                error = Errors.ClassMethodOrFieldExpected;\n@@ -4909,0 +4928,6 @@\n+        } else if (token.kind == LPAREN && type.hasTag(IDENT)) {\n+            log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n+\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    false, true, false, dc));\n@@ -5022,0 +5047,1 @@\n+            boolean unclosedParameterList;\n@@ -5024,0 +5050,1 @@\n+                unclosedParameterList = token.pos == endPosTable.errorEndPos;\n@@ -5029,0 +5056,2 @@\n+            } else {\n+                unclosedParameterList = false;\n@@ -5042,0 +5071,1 @@\n+                    accept(SEMI);\n@@ -5044,0 +5074,1 @@\n+                    accept(SEMI, tk -> Errors.Expected2(LBRACE, SEMI));\n@@ -5045,1 +5076,0 @@\n-                accept(SEMI);\n@@ -5048,2 +5078,5 @@\n-                    skip(false, true, false, false);\n-                    if (token.kind == LBRACE) {\n+                    \/\/ look if there is a probable missing opening brace,\n+                    \/\/ and if yes, parse as a block\n+                    boolean parseAsBlock = openingBraceMissing(unclosedParameterList);\n+\n+                    if (parseAsBlock) {\n@@ -5066,0 +5099,78 @@\n+    \/**\n+     * After seeing a method header, and not seeing an opening left brace,\n+     * attempt to estimate if acting as if the left brace was present and\n+     * parsing the upcoming code will get better results than not parsing\n+     * the code as a block.\n+     *\n+     * The estimate is as follows:\n+     * - tokens are skipped until member, statement or identifier is found,\n+     * - then, if there is a left brace, parse as a block,\n+     * - otherwise, if the head was broken, do not parse as a block,\n+     * - otherwise, look at the next token and:\n+     *   - if it definitelly starts a statement, parse as a block,\n+     *   - otherwise, if it is a closing\/right brace, count opening and closing\n+     *     braces in the rest of the file, to see if imaginarily \"adding\" an opening\n+     *     brace would lead to a balanced count - if yes, parse as a block,\n+     *   - otherwise, speculatively parse the following code as a block, and if\n+     *     it contains statements that cannot be members, parse as a block,\n+     *   - otherwise, don't parse as a block.\n+     *\n+     * @param unclosedParameterList whether there was a serious problem in the\n+     *                              parameters list\n+     * @return true if and only if the following code should be parsed as a block.\n+     *\/\n+    private boolean openingBraceMissing(boolean unclosedParameterList) {\n+        skip(false, true, !unclosedParameterList, !unclosedParameterList);\n+\n+        if (token.kind == LBRACE) {\n+            return true;\n+        } else if (unclosedParameterList) {\n+            return false;\n+        } else {\n+            return switch (token.kind) {\n+                \/\/definitelly sees a statement:\n+                case CASE, DEFAULT, IF, FOR, WHILE, DO, TRY, SWITCH,\n+                    RETURN, THROW, BREAK, CONTINUE, ELSE, FINALLY,\n+                    CATCH, THIS, SUPER, NEW -> true;\n+                case RBRACE -> {\n+                    \/\/check if adding an opening brace would balance out\n+                    \/\/the opening and closing braces:\n+                    int braceBalance = 1;\n+                    VirtualScanner virtualScanner = new VirtualScanner(S);\n+\n+                    virtualScanner.nextToken();\n+\n+                    while (virtualScanner.token().kind != TokenKind.EOF) {\n+                        switch (virtualScanner.token().kind) {\n+                            case LBRACE -> braceBalance++;\n+                            case RBRACE -> braceBalance--;\n+                        }\n+                        virtualScanner.nextToken();\n+                    }\n+\n+                    yield braceBalance == 0;\n+                }\n+                default -> {\n+                    \/\/speculatively try to parse as a block, and check\n+                    \/\/if the result would suggest there is a block\n+                    \/\/e.g.: it contains a statement that is not\n+                    \/\/a member declaration\n+                    JavacParser speculative = new VirtualParser(this);\n+                    JCBlock speculativeResult =\n+                            speculative.block();\n+                    if (!speculativeResult.stats.isEmpty()) {\n+                        JCStatement last = speculativeResult.stats.last();\n+                        yield !speculativeResult.stats.stream().allMatch(s -> s.hasTag(VARDEF) ||\n+                                s.hasTag(CLASSDEF) ||\n+                                s.hasTag(BLOCK) ||\n+                                s == last) ||\n+                            !(last instanceof JCExpressionStatement exprStatement &&\n+                            exprStatement.expr.hasTag(ERRONEOUS));\n+                    } else {\n+                        yield false;\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":116,"deletions":5,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -1622,0 +1622,3 @@\n+compiler.err.class.method.or.field.expected=\\\n+    class, interface, annotation type, enum, record, method or field expected\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -481,1 +481,2 @@\n-    Recursively copy doc-file subdirectories\n+    Enables deep copying of 'doc-files' directories. Subdirectories and all\\n\\\n+    contents are recursively copied to the destination\n@@ -518,1 +519,1 @@\n-    Include footer text for each page\n+    This option is no longer supported and reports a warning\n@@ -556,1 +557,1 @@\n-    Exclude any doc-files subdirectories with given name.\\n\\\n+    Exclude any 'doc-files' subdirectories with given name.\\n\\\n@@ -617,1 +618,1 @@\n-    Generate warning about @serial tag\n+    Reports compile-time warnings for missing '@serial' tags\n@@ -632,1 +633,1 @@\n-    Specify single argument custom tags\n+    Specifies a custom tag with a single argument\n@@ -657,1 +658,2 @@\n-    Include file that help link links to\n+    Specifies a file containing the text that will be displayed when the\\n\\\n+    help link in the navigation bar is clicked\n@@ -694,1 +696,2 @@\n-    Allow JavaScript in options and comments\n+    Allow JavaScript in documentation comments, and options\\n\\\n+    whose value is html-code\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -681,1 +681,1 @@\n-         * the {@code --help-extended} option and its aliases.\n+         * the {@code --help-extra} option and its aliases.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    Specifies which members (fields, methods, etc.) will be\\n\\\n+    Specifies which members (fields, methods, or constructors) will be\\n\\\n@@ -90,1 +90,1 @@\n-    Specifies which module's packages will be documented. Possible\\n\\\n+    Specifies which module packages will be documented. Possible\\n\\\n@@ -100,1 +100,1 @@\n-    <value>\n+    (transitive|all)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-                    print(\" \" + instr.typeKind().typeName());\n+                    print(\" \" + instr.typeKind().upperBound().displayName());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/CodeWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"jvm.h\"\n@@ -124,1 +125,5 @@\n-#ifndef STATIC_BUILD\n+\n+    if (JVM_IsStaticallyLinked()) {\n+        return (dbgsysLoadLibrary(NULL, buf, sizeof(buf)));\n+    }\n+\n@@ -148,3 +153,0 @@\n-#else\n-    return (dbgsysLoadLibrary(NULL, buf, sizeof(buf)));\n-#endif\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/transport.c","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.Objects;\n@@ -88,4 +89,1 @@\n-                stream.close();\n-                currentChunk.release();\n-                stream = null;\n-                currentChunk = null;\n+                closeStream();\n@@ -100,1 +98,30 @@\n-    public void close() throws IOException {\n+    public int read(byte[] buf, int off, int len) throws IOException {\n+        Objects.checkFromIndexSize(off, len, buf.length);\n+        if (len == 0) {\n+            return 0;\n+        }\n+\n+        int totalRead = 0;\n+        while (len > 0) {\n+            if (stream == null) {\n+                closeChunk();\n+                if (!nextStream()) {\n+                    return totalRead > 0 ? totalRead : -1;\n+                }\n+            }\n+            int read = stream.read(buf, off, len);\n+            if (read > -1) {\n+                totalRead += read;\n+                len -= read;\n+                if (len == 0) {\n+                    return totalRead;\n+                }\n+                off += read;\n+            } else {\n+                closeStream();\n+            }\n+        }\n+        return totalRead;\n+    }\n+\n+    private void closeStream() throws IOException {\n@@ -105,1 +132,5 @@\n-        while (currentChunk != null) {\n+        closeChunk();\n+    }\n+\n+    private void closeChunk() {\n+        if (currentChunk != null) {\n@@ -108,0 +139,8 @@\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        closeStream();\n+        while (currentChunk != null) {\n+            closeChunk();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ChunkInputStream.java","additions":46,"deletions":7,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -565,1 +565,1 @@\n-        blockCodeBuilder.loadConstant(Opcode.LDC2_W, eventTypeId);\n+        blockCodeBuilder.loadConstant(eventTypeId);\n@@ -679,1 +679,1 @@\n-        blockCodeBuilder.loadConstant(Opcode.LDC2_W, eventTypeId);\n+        blockCodeBuilder.loadConstant(eventTypeId);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    public static final int MAX_LIMIT = 128; \/* 0 MAX means disabled *\/\n-\n+    public static final int MAX_LIMIT = 131072; \/* 0 MAX means disabled *\/\n+    private static final int PRECACHE_THRESHOLD = 128;\n@@ -134,1 +134,1 @@\n-        if (!preCache(s)) {\n+        if (s.length() <= PRECACHE_THRESHOLD && !preCache(s)) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/StringPool.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1565,1 +1565,1 @@\n-                   .newarray(TypeKind.ByteType);\n+                   .newarray(TypeKind.BYTE);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-                    return true;\n+                    return false;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/ExecutionControlForwarder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -73,0 +74,2 @@\n+    private static final int SHUTDOWN_TIMEOUT = 1; \/\/1 second\n+\n@@ -270,0 +273,14 @@\n+\n+        Process remoteProcess;\n+\n+        synchronized (this) {\n+            remoteProcess = this.process;\n+        }\n+\n+        if (remoteProcess != null) {\n+            try {\n+                remoteProcess.waitFor(SHUTDOWN_TIMEOUT, TimeUnit.SECONDS);\n+            } catch (InterruptedException ex) {\n+                debug(ex, \"waitFor remote\");\n+            }\n+        }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiDefaultExecutionControl.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+ *\n+ * @since 1.6\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/HotSpotDiagnosticMXBean.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-      FLAG_SET_ERGO(MaxNewSize, 80 * M);\n+      FLAG_SET_ERGO(MaxNewSize, 40 * M);\n@@ -162,0 +162,3 @@\n+\/\/ Tests require at least 128M of MaxHeap\n+\/\/ otherwise ergonomic is different and generation sizes might be changed.\n+\n@@ -166,0 +169,3 @@\n+  if (MaxHeapSize < 128 * M) {\n+      return;\n+  }\n@@ -178,0 +184,3 @@\n+  if (MaxHeapSize < 128 * M) {\n+    return;\n+  }\n@@ -190,2 +199,2 @@\n-  TestGenCollectorPolicy::SetNewSizeCmd setter_large(80 * M);\n-  TestGenCollectorPolicy::CheckYoungInitial checker_large(80 * M);\n+  TestGenCollectorPolicy::SetNewSizeCmd setter_large(40 * M);\n+  TestGenCollectorPolicy::CheckYoungInitial checker_large(40 * M);\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_collectorPolicy.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    cld->metaspace_non_null()->deallocate(p, sz, in_class_space);\n+    cld->metaspace_non_null()->deallocate(p, sz);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspace_misc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  EXPECT_TRUE(si.is_invalid());\n+  EXPECT_TRUE(NCSS::is_invalid(si));\n@@ -60,1 +60,1 @@\n-      EXPECT_FALSE(NCSS::StackIndex::equals(si_arr[i],si_arr[j]));\n+      EXPECT_FALSE(NCSS::equals(si_arr[i],si_arr[j]));\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_nativecallstackstorage.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -181,0 +181,10 @@\n+\/\/ version with a highlighted pc location\n+static void do_test_print_hex_dump_highlighted(const_address from, const_address to, int unitsize, int bytes_per_line,\n+                                   const_address logical_start, const char* expected, const_address highlight) {\n+  char buf[2048];\n+  buf[0] = '\\0';\n+  stringStream ss(buf, sizeof(buf));\n+  os::print_hex_dump(&ss, from, to, unitsize, \/* print_ascii=*\/true, bytes_per_line, logical_start, highlight);\n+  EXPECT_STREQ(buf, expected);\n+}\n+\n@@ -200,0 +210,18 @@\n+#define PAT_HL_1A \"=>\" ADDRESS1 \":   ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\\n\" \\\n+              \"  \" ADDRESS2 \":   ff ff e0 dc 23 00 6a 64 6b 2f 69 6e 74 65 72 6e 61 6c 2f 6c 6f 61 64 65 72 2f 4e 61 74 69 76 65   \" ASCII_1 \"\\n\" \\\n+              \"  \" ADDRESS3 \":   4c 69 62 72 61 72 69 65 73 00 00 00 00 00 00 00                                                   \" ASCII_2 \"\\n\"\n+\n+#define PAT_HL_1B \"  \" ADDRESS1 \":   ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\\n\" \\\n+              \"=>\" ADDRESS2 \":   ff ff e0 dc 23 00 6a 64 6b 2f 69 6e 74 65 72 6e 61 6c 2f 6c 6f 61 64 65 72 2f 4e 61 74 69 76 65   \" ASCII_1 \"\\n\" \\\n+              \"  \" ADDRESS3 \":   4c 69 62 72 61 72 69 65 73 00 00 00 00 00 00 00                                                   \" ASCII_2 \"\\n\"\n+\n+#ifdef VM_LITTLE_ENDIAN\n+#define PAT_HL_1C \"  \" ADDRESS1 \":   ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????\\n\" \\\n+              \"=>\" ADDRESS2 \":   ffff dce0 0023 646a 2f6b 6e69 6574 6e72 6c61 6c2f 616f 6564 2f72 614e 6974 6576   \" ASCII_1 \"\\n\" \\\n+              \"  \" ADDRESS3 \":   694c 7262 7261 6569 0073 0000 0000 0000                                           \" ASCII_2 \"\\n\"\n+#else\n+#define PAT_HL_1C \"  \" ADDRESS1 \":   ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????\\n\" \\\n+              \"=>\" ADDRESS2 \":   ffff e0dc 2300 6a64 6b2f 696e 7465 726e 616c 2f6c 6f61 6465 722f 4e61 7469 7665   \" ASCII_1 \"\\n\" \\\n+              \"  \" ADDRESS3 \":   4c69 6272 6172 6965 7300 0000 0000 0000                                           \" ASCII_2 \"\\n\"\n+#endif\n+\n@@ -255,0 +283,6 @@\n+  \/\/ print with highlighted address\n+  do_test_print_hex_dump_highlighted(from, to, 1, 32, logical_start, PAT_HL_1A, from+5);\n+  do_test_print_hex_dump_highlighted(from, to, 1, 32, logical_start, PAT_HL_1B, from+32);\n+  do_test_print_hex_dump_highlighted(from, to, 1, 32, logical_start, PAT_HL_1B, from+60);\n+  do_test_print_hex_dump_highlighted(from, to, 2, 32, logical_start, PAT_HL_1C, from+60);\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+\n+runtime\/interpreter\/LastJsrTest.java 8338924 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+compiler\/c2\/irTests\/TestIfMinMax.java 8339220 linux-s390x\n@@ -76,2 +77,0 @@\n-compiler\/startup\/StartupOutput.java 8326615 generic-x64\n-\n@@ -122,1 +121,1 @@\n-runtime\/interpreter\/LastJsrTest.java 8338924 linux-all\n+runtime\/exceptionMsgs\/NoClassDefFoundError\/NoClassDefFoundErrorTest.java 8339316 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.gvn;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Random;\n+\n+\/**\n+ * @test\n+ * @bug 8327381\n+ * @summary Refactor boolean node tautology transformations\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.TestBoolNodeGVN\n+ *\/\n+public class TestBoolNodeGVN {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+        testCorrectness();\n+    }\n+\n+    \/**\n+     * Test changing ((x & m) u<= m) or ((m & x) u<= m) to always true, same with ((x & m) u< m+1) and ((m & x) u< m+1)\n+     * The test is only applicable to x64, aarch64 and riscv64 for having <code>Integer.compareUnsigned<\/code>\n+     * intrinsified.\n+     *\/\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase1(int x, int m) {\n+        return !(Integer.compareUnsigned((x & m), m) > 0); \/\/ assert in inversions to generates the pattern looking for\n+    }\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase2(int x, int m) {\n+        return !(Integer.compareUnsigned((m & x), m) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase3(int x, int m) {\n+        return Integer.compareUnsigned((x & m), m + 1) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase4(int x, int m) {\n+        return Integer.compareUnsigned((m & x), m + 1) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase1(int x, int m) {\n+        return !(Integer.compareUnsigned((x & m), m - 1) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase2(int x, int m) {\n+        return !(Integer.compareUnsigned((m & x), m - 1) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase3(int x, int m) {\n+        return Integer.compareUnsigned((x & m), m + 2) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase4(int x, int m) {\n+        return Integer.compareUnsigned((m & x), m + 2) < 0;\n+    }\n+\n+    private static void testCorrectness() {\n+        int[] values = {\n+                0, 1, 5, 8, 16, 42, 100, new Random().nextInt(0, Integer.MAX_VALUE), Integer.MAX_VALUE\n+        };\n+\n+        for (int x : values) {\n+            for (int m : values) {\n+                if (!testShouldReplaceCpmUCase1(x, m) |\n+                    !testShouldReplaceCpmUCase2(x, m) |\n+                    !testShouldReplaceCpmUCase3(x, m) |\n+                    !testShouldReplaceCpmUCase4(x, m)) {\n+                    throw new RuntimeException(\"Bad result for x = \" + x + \" and m = \" + m + \", expected always true\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBoolNodeGVN.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,2 +190,11 @@\n-        \/\/ minimum size: CodeCacheMinimumUseSpace DEBUG_ONLY(* 3)\n-        long minSize = (Platform.isDebugBuild() ? 3 : 1) * minUseSpace;\n+        long nMethodSizeLimit = WHITE_BOX.getIntxVMFlag(\"NMethodSizeLimit\");\n+        long codeEntryAlignment = WHITE_BOX.getIntxVMFlag(\"CodeEntryAlignment\");\n+        long c1MinCodeCacheSize = 11 * nMethodSizeLimit \/ 10;\n+        long c2MinCodeCacheSize = 2048 \/* PhaseOutput::MAX_inst_size *\/ +\n+                                  128 \/* PhaseOutput::MAX_stubs_size *\/ +\n+                                  4 * 1024 \/* initial_const_capacity *\/ +\n+                                  2 * Math.max(64, codeEntryAlignment) \/* 2 * CodeSection::end_slop() *\/ +\n+                                  2 * 128 \/* sizeof(relocInfo) * PhaseOutput::MAX_locs_size *\/;\n+        \/\/ minimum size: CompilerConfig::min_code_cache_size =\n+        \/\/ CodeCacheMinimumUseSpace DEBUG_ONLY(* 3) + Compiler::code_buffer_size() + C2Compiler::initial_code_buffer_size())\n+        long minSize = minUseSpace * (Platform.isDebugBuild() ? 3 : 1) + c1MinCodeCacheSize + c2MinCodeCacheSize;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckSegmentedCodeCache.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-        beforeMatchingNameRegex(CMP_U, \"CmpU\");\n+        beforeMatchingNameRegex(CMP_U, \"CmpU\\\\b\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8056900\n+ * @bug 8056900 8338888\n@@ -31,1 +31,1 @@\n- * @run main\/native NoClassDefFoundErrorTest\n+ * @run main\/native\/othervm -Xlog:exceptions=info NoClassDefFoundErrorTest\n@@ -39,0 +39,1 @@\n+    \/\/ Use the specified name\n@@ -41,0 +42,5 @@\n+    \/\/ Use a name longer than a Java string - returns false\n+    \/\/ if native allocation failed.\n+    static native boolean tryCallDefineClass();\n+    static native boolean tryCallFindClass();\n+\n@@ -57,1 +63,1 @@\n-        \/\/ Test JVM_DefineClass() with long name.\n+        System.out.println(\"Test JVM_DefineClass() with long name\");\n@@ -67,1 +73,1 @@\n-        \/\/ Test JNI_DefineClass() with long name.\n+        System.out.println(\"Test JNI_DefineClass() with long name\");\n@@ -77,1 +83,1 @@\n-        \/\/ Test JNI_FindClass() with long name.\n+        System.out.println(\"Test JNI_FindClass() with long name\");\n@@ -80,1 +86,1 @@\n-            throw new RuntimeException(\"DefineClass did not throw expected NoClassDefFoundError\");\n+            throw new RuntimeException(\"FindClass did not throw expected NoClassDefFoundError\");\n@@ -87,1 +93,1 @@\n-        \/\/ Test JNI_FindClass() with null name.\n+        System.out.println(\"Test JNI_FindClass() with null name\");\n@@ -96,0 +102,26 @@\n+\n+        System.out.println(\"Test JNI_DefineClass() with giant name\");\n+        try {\n+            if (tryCallDefineClass()) {\n+                throw new RuntimeException(\"DefineClass did not throw expected NoClassDefFoundError\");\n+            } else {\n+                System.out.println(\"Test skipped due to native allocation failure\");\n+            }\n+        } catch (NoClassDefFoundError e) {\n+            if (!e.getMessage().contains(\"Class name exceeds maximum length of \")) {\n+                throw new RuntimeException(\"Wrong NoClassDefFoundError: \" + e.getMessage());\n+            }\n+        }\n+\n+        System.out.println(\"Test JNI_FindClass() with giant name\");\n+        try {\n+            if (tryCallFindClass()) {\n+                throw new RuntimeException(\"FindClass did not throw expected NoClassDefFoundError\");\n+            } else {\n+                System.out.println(\"Test skipped due to native allocation failure\");\n+            }\n+        } catch (NoClassDefFoundError e) {\n+            if (!e.getMessage().contains(\"Class name exceeds maximum length of \")) {\n+                throw new RuntimeException(\"Wrong NoClassDefFoundError: \" + e.getMessage());\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/NoClassDefFoundError\/NoClassDefFoundErrorTest.java","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,4 @@\n+#include <limits.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n@@ -45,0 +49,31 @@\n+static char* giant_string() {\n+    size_t len = ((size_t)INT_MAX) + 3;\n+    char* c_name = malloc(len * sizeof(char));\n+    if (c_name != NULL) {\n+        memset(c_name, 'Y', len - 1);\n+        c_name[len - 1] = '\\0';\n+    }\n+    return c_name;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NoClassDefFoundErrorTest_tryCallDefineClass(JNIEnv *env, jclass klass) {\n+    char* c_name = giant_string();\n+    if (c_name != NULL) {\n+        (*env)->DefineClass(env, c_name, NULL, NULL, 0);\n+        free(c_name);\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NoClassDefFoundErrorTest_tryCallFindClass(JNIEnv *env, jclass klass) {\n+    char* c_name = giant_string();\n+    if (c_name != NULL) {\n+        jclass cls = (*env)->FindClass(env, c_name);\n+        free(c_name);\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/NoClassDefFoundError\/libNoClassDefFoundErrorTest.c","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java 8005021,8332158 macosx-all,linux-x64\n+java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java 8005021 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+ * @library \/test\/lib\n+ * @build   jdk.test.lib.Platform\n@@ -33,3 +35,8 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.*;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+import jdk.test.lib.Platform;\n@@ -44,0 +51,3 @@\n+        if (Platform.isOnWayland()) {\n+            return;\n+        }\n","filename":"test\/jdk\/java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -122,0 +122,24 @@\n+    static final MemoryLayout A_VALUE = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"b\")\n+                    .withTargetLayout(ValueLayout.JAVA_INT)\n+    );\n+\n+    static final VarHandle a_value = A_VALUE.varHandle(\n+            PathElement.groupElement(\"b\"), PathElement.dereferenceElement());\n+\n+    @Test\n+    public void testDerefValue() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ init structs\n+            MemorySegment a = arena.allocate(A);\n+            MemorySegment b = arena.allocate(ValueLayout.JAVA_INT);\n+            \/\/ init struct fields\n+            a.set(ValueLayout.ADDRESS, 0, b);\n+            b.set(ValueLayout.JAVA_INT, 0, 42);\n+            \/\/ dereference\n+            int val = (int) a_value.get(a, 0L);\n+            assertEquals(val, 42);\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test MemorySegment::fill\n+ * @run junit TestFill\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestFill {\n+\n+    \/\/ Make sure negative values are treated as expected\n+    private static final byte VALUE = -71;\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testFill(int len) {\n+        int offset = 16;\n+        int expandedLen = offset + MAX_SIZE + offset;\n+\n+        \/\/ Make sure fill only affects the intended region XXXXXX\n+        \/\/\n+        \/\/ ................XXXXXX................\n+        \/\/ |    offset     | len |    offset     |\n+\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(expandedLen);\n+            var slice = segment.asSlice(offset, len);\n+            slice.fill(VALUE);\n+\n+            var expected = new byte[expandedLen];\n+            Arrays.fill(expected, offset, offset + len, VALUE);\n+\n+            \/\/ This checks the actual fill region as well as potential under and overflows\n+            assertArrayEquals(expected, segment.toArray(ValueLayout.JAVA_BYTE));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"values\")\n+    void testValues(int value) {\n+        int size = 0b1111;\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(size);\n+            segment.fill((byte) value);\n+            assertTrue(segment.elements(ValueLayout.JAVA_BYTE)\n+                    .map(s -> s.get(ValueLayout.JAVA_BYTE, 0))\n+                    .allMatch(v -> v == value), \"Failed to fill with value \" + value);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testReadOnly(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(10).asReadOnly();\n+            assertThrows(IllegalArgumentException.class, () -> segment.fill(VALUE));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testConfinement(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(10);\n+            AtomicReference<RuntimeException> ex = new AtomicReference<>();\n+            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n+                try {\n+                    segment.fill(VALUE);\n+                } catch (RuntimeException e) {\n+                    ex.set(e);\n+                }\n+            });\n+            future.join();\n+            assertInstanceOf(WrongThreadException.class, ex.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testScope(int len) {\n+        var arena = Arena.ofConfined();\n+        var segment = arena.allocate(len);\n+        arena.close();\n+        assertThrows(IllegalStateException.class, () -> segment.fill(VALUE));\n+    }\n+\n+    private static final int MAX_SIZE = 1 << 10;\n+\n+    private static Stream<Arguments> sizes() {\n+        return IntStream.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 23, 32, 63, 128, 256, 511, MAX_SIZE)\n+                .boxed()\n+                .map(Arguments::of);\n+    }\n+\n+    private static Stream<Arguments> values() {\n+        return IntStream.rangeClosed(Byte.MIN_VALUE, Byte.MAX_VALUE)\n+                .boxed()\n+                .map(Arguments::of);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestFill.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -335,0 +335,8 @@\n+    @Test(dataProvider = \"testLayouts\", expectedExceptions = ArithmeticException.class)\n+    public void testOffsetHandleOverflow(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                         long expectedByteOffset) throws Throwable {\n+        MethodHandle byteOffsetHandle = layout.byteOffsetHandle(pathElements);\n+        byteOffsetHandle = byteOffsetHandle.asSpreader(long[].class, indexes.length);\n+        byteOffsetHandle.invoke(Long.MAX_VALUE, indexes);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        for (int i = 0; i < 2000; i++) {\n+        for (int i = 0; i < 12000; i++) {\n","filename":"test\/jdk\/java\/lang\/String\/concat\/HiddenClassUnloading.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+\/*\n+ * @test\n+ * @bug 8338445\n+ * @summary verify that the jdk.internal.loader.URLClassPath closes the JarFile\n+ *          instances that it no longer uses for loading\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.util.JarUtils\n+ * @comment This test expects MalformedURLException for some specific URLs.\n+ *          We use othervm to prevent interference from other tests which\n+ *          might have installed custom URLStreamHandler(s)\n+ * @run junit\/othervm JarLoaderCloseTest\n+ *\/\n+public class JarLoaderCloseTest {\n+\n+    private static final String RESOURCE_NAME = \"foo-bar.txt\";\n+    private static final String RESOURCE_CONTENT = \"Hello world\";\n+    private static final Path TEST_SCRATCH_DIR = Path.of(\".\");\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        \/\/ create a file which will be added to the JAR file that gets tested\n+        Files.writeString(TEST_SCRATCH_DIR.resolve(RESOURCE_NAME), RESOURCE_CONTENT);\n+    }\n+\n+    \/*\n+     * Creates a JAR file with a manifest which has a Class-Path entry value with malformed URLs.\n+     * Then uses a URLClassLoader backed by the JAR file in its classpath, loads some resource,\n+     * closes the URLClassLoader and then expects that the underlying JAR file can be deleted\n+     * from the filesystem.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"C:\\\\foo\\\\bar\\\\hello\/world.jar lib2.jar\",\n+            \"C:\/hello\/world\/foo.jar\",\n+            \"lib4.jar C:\\\\bar\\\\foo\\\\world\/hello.jar\"\n+    })\n+    public void testMalformedClassPathEntry(final String classPathValue) throws Exception {\n+        final Manifest manifest = createManifestWithClassPath(classPathValue);\n+        final Path jar = Files.createTempFile(TEST_SCRATCH_DIR, \"8338445\", \".jar\");\n+        \/\/ create the JAR file with the given manifest and an arbitrary file\n+        JarUtils.createJarFile(jar, manifest, TEST_SCRATCH_DIR, Path.of(RESOURCE_NAME));\n+        System.out.println(\"created jar at \" + jar + \" with manifest:\");\n+        manifest.write(System.out);\n+        final URL[] urlClassPath = new URL[]{jar.toUri().toURL()};\n+        \/\/ Create a URLClassLoader backed by the JAR file and load a non-existent resource just to\n+        \/\/ exercise the URLClassPath code of loading the jar and parsing the Class-Path entry.\n+        \/\/ Then close the classloader. After the classloader is closed\n+        \/\/ issue a delete on the underlying JAR file on the filesystem. The delete is expected\n+        \/\/ to succeed.\n+        try (final URLClassLoader cl = new URLClassLoader(urlClassPath)) {\n+            try (final InputStream is = cl.getResourceAsStream(\"non-existent.txt\")) {\n+                assertNull(is, \"unexpectedly found a resource in classpath \"\n+                        + Arrays.toString(urlClassPath));\n+            }\n+        }\n+        \/\/ now delete the JAR file and verify the delete worked\n+        Files.delete(jar);\n+        assertFalse(Files.exists(jar), jar + \" exists even after being deleted\");\n+    }\n+\n+    \/*\n+     * Creates a JAR file with a manifest which has a Class-Path entry value with URLs\n+     * that are parsable but point to files that don't exist on the filesystem.\n+     * Then uses a URLClassLoader backed by the JAR file in its classpath, loads some resource,\n+     * closes the URLClassLoader and then expects that the underlying JAR file can be deleted\n+     * from the filesystem.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/home\/me\/hello\/world.jar lib9.jar\",\n+            \"lib10.jar\"\n+    })\n+    public void testParsableClassPathEntry(final String classPathValue) throws Exception {\n+        final Manifest manifest = createManifestWithClassPath(classPathValue);\n+        final Path jar = Files.createTempFile(TEST_SCRATCH_DIR, \"8338445\", \".jar\");\n+        \/\/ create the JAR file with the given manifest and an arbitrary file\n+        JarUtils.createJarFile(jar, manifest, TEST_SCRATCH_DIR, Path.of(RESOURCE_NAME));\n+        System.out.println(\"created jar at \" + jar + \" with manifest:\");\n+        manifest.write(System.out);\n+        final URL[] urlClassPath = new URL[]{jar.toUri().toURL()};\n+        \/\/ Create a URLClassLoader backed by the JAR file and load a resource\n+        \/\/ and verify the resource contents.\n+        \/\/ Then close the classloader. After the classloader is closed\n+        \/\/ issue a delete on the underlying JAR file on the filesystem. The delete is expected\n+        \/\/ to succeed.\n+        try (final URLClassLoader cl = new URLClassLoader(urlClassPath)) {\n+            try (final InputStream is = cl.getResourceAsStream(RESOURCE_NAME)) {\n+                assertNotNull(is, RESOURCE_NAME + \" not located by classloader in classpath \"\n+                        + Arrays.toString(urlClassPath));\n+                final String content = new String(is.readAllBytes(), US_ASCII);\n+                assertEquals(RESOURCE_CONTENT, content, \"unexpected content in \" + RESOURCE_NAME);\n+            }\n+        }\n+        \/\/ now delete the JAR file and verify the delete worked\n+        Files.delete(jar);\n+        assertFalse(Files.exists(jar), jar + \" exists even after being deleted\");\n+    }\n+\n+    private static Manifest createManifestWithClassPath(final String classPathValue) {\n+        final Manifest manifest = new Manifest();\n+        final Attributes mainAttributes = manifest.getMainAttributes();\n+        mainAttributes.putValue(\"Manifest-Version\", \"1.0\");\n+        mainAttributes.putValue(\"Class-Path\", classPathValue);\n+        return manifest;\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/URLClassLoader\/JarLoaderCloseTest.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -115,0 +116,1 @@\n+    static final AtomicInteger requestCount = new AtomicInteger();\n@@ -247,1 +249,1 @@\n-    public void testNoStalls(String uri, boolean sameClient)\n+    public void testNoStalls(String rootUri, boolean sameClient)\n@@ -249,0 +251,1 @@\n+        if (!FAILURES.isEmpty()) return;\n@@ -250,1 +253,1 @@\n-        out.printf(\"%ntestNoStalls(%s, %b)%n\", uri, sameClient);\n+        out.printf(\"%ntestNoStalls(%s, %b)%n\", rootUri, sameClient);\n@@ -255,0 +258,2 @@\n+            String uri = rootUri + \"\/\" + requestCount.incrementAndGet();\n+            out.printf(\"\\tsending request %s%n\", uri);\n@@ -334,0 +339,4 @@\n+        if (!FAILURES.isEmpty()) {\n+            out.printf(\"%s: skipping test - previous failure detected%n\", name);\n+            return;\n+        }\n@@ -344,1 +353,1 @@\n-    private <T,U> void testDependent(String uri, boolean sameClient,\n+    private <T,U> void testDependent(String rootUri, boolean sameClient,\n@@ -357,0 +366,2 @@\n+            String uri = rootUri + \"\/\" + requestCount.incrementAndGet();\n+            out.printf(\"\\tsending request %s%n\", uri);\n@@ -366,1 +377,7 @@\n-            assert subscriberType == SubscriberType.LAZZY || !responseCF.isDone();\n+            \/\/ The body of the main response can be received before the body\n+            \/\/ of the push promise handlers are received.\n+            \/\/ The body of the main response doesn't stall, so the cf of\n+            \/\/ the main response may be done here even for EAGER subscribers.\n+            \/\/ We cannot make any assumption on the state of the main response\n+            \/\/ cf here, so the only thing we can do is to call the finisher\n+            \/\/ which will wait for them all.\n","filename":"test\/jdk\/java\/net\/httpclient\/DependentPromiseActionsTest.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @bug 8087112\n+ * @bug 8087112 8336655 8338569\n","filename":"test\/jdk\/java\/net\/httpclient\/DigestEchoClient.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,0 +198,3 @@\n+        boolean proxyInClosed;  \/\/ only accessed from synchronized block\n+        boolean proxyOutClosed; \/\/ only accessed from synchronized block\n+\n@@ -597,3 +600,1 @@\n-                    closing = true;\n-                    serverSocket.close();\n-                    clientSocket.close();\n+                    closeClientIn();\n@@ -618,3 +619,1 @@\n-                    closing = true;\n-                    serverSocket.close();\n-                    clientSocket.close();\n+                    closeClientOut();\n@@ -644,0 +643,22 @@\n+        synchronized void closeClientIn() throws IOException {\n+            closing = true;\n+            proxyInClosed = true;\n+            clientSocket.shutdownInput();\n+            serverSocket.shutdownOutput();\n+            if (proxyOutClosed) {\n+                serverSocket.close();\n+                clientSocket.close();\n+            }\n+        }\n+\n+        synchronized void closeClientOut() throws IOException {\n+            closing = true;\n+            proxyOutClosed = true;\n+            serverSocket.shutdownInput();\n+            clientSocket.shutdownOutput();\n+            if (proxyInClosed) {\n+                serverSocket.close();\n+                clientSocket.close();\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/ProxyServer.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,1 @@\n-            if (client.awaitTermination(Duration.ofMillis(2000))) {\n+            if (client.awaitTermination(Duration.ofMillis(2500))) {\n@@ -215,0 +215,1 @@\n+                assertTrue(client.isTerminated());\n@@ -216,1 +217,5 @@\n-                throw new AssertionError(\"client still running\");\n+                client = null;\n+                var error = TRACKER.check(500);\n+                if (error != null) throw error;\n+                throw new AssertionError(\"client was still running, but exited after further delay: \"\n+                        + \"timeout should be adjusted\");\n@@ -218,1 +223,0 @@\n-            assertTrue(client.isTerminated());\n@@ -275,1 +279,1 @@\n-            if (client.awaitTermination(Duration.ofMillis(2000))) {\n+            if (client.awaitTermination(Duration.ofMillis(2500))) {\n@@ -277,0 +281,1 @@\n+                assertTrue(client.isTerminated());\n@@ -278,1 +283,5 @@\n-                throw new AssertionError(\"client still running\");\n+                client = null;\n+                var error = TRACKER.check(500);\n+                if (error != null) throw error;\n+                throw new AssertionError(\"client was still running, but exited after further delay: \"\n+                        + \"timeout should be adjusted\");\n@@ -280,1 +289,0 @@\n-            assertTrue(client.isTerminated());\n","filename":"test\/jdk\/java\/net\/httpclient\/ShutdownNow.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8087112 8178699\n+ * @bug 8087112 8178699 8338569\n@@ -57,0 +57,2 @@\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n@@ -575,2 +577,1 @@\n-        URI uri = new URI(target);\n-        HttpRequest request = HttpRequest.newBuilder().uri(uri).GET().build();\n+        AtomicInteger count = new AtomicInteger();\n@@ -579,0 +580,3 @@\n+            URI uri = new URI(target+\"?get-sync;count=\"+count.incrementAndGet());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder().uri(uri).GET().build();\n@@ -587,4 +591,1 @@\n-        request = HttpRequest.newBuilder()\n-                .uri(uri)\n-                .POST(BodyPublishers.ofFile(requestBody))\n-                .build();\n+\n@@ -593,0 +594,6 @@\n+            URI uri = new URI(target+\"?post-async;count=\"+count.incrementAndGet());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder()\n+                    .uri(uri)\n+                    .POST(BodyPublishers.ofFile(requestBody))\n+                    .build();\n@@ -613,1 +620,0 @@\n-        request = HttpRequest.newBuilder(uri).GET().build();\n@@ -615,0 +621,1 @@\n+        Set<String> inFlight = ConcurrentHashMap.newKeySet();\n@@ -616,0 +623,4 @@\n+            URI uri = new URI(target+\"?get-async;count=\"+count.incrementAndGet());\n+            inFlight.add(uri.getQuery());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder(uri).GET().build();\n@@ -618,0 +629,2 @@\n+                      inFlight.remove(uri.getQuery());\n+                      System.out.println(\"Got response for: \" + uri);\n@@ -633,0 +646,4 @@\n+            URI uri = new URI(target+\"?get-async-next;count=\"+count.incrementAndGet());\n+            inFlight.add(uri.getQuery());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder(uri).GET().build();\n@@ -635,0 +652,3 @@\n+                      inFlight.remove(uri.getQuery());\n+                      System.out.println(\"Got response for: \" + uri);\n+                      System.out.println(\"In flight: \" + inFlight);\n@@ -642,0 +662,2 @@\n+        System.out.println(\"Waiting: In flight: \" + inFlight);\n+        System.out.println(\"Queue size: \" + q.size());\n@@ -645,0 +667,2 @@\n+            System.out.println(\"Waiting: In flight: \" + inFlight);\n+            System.out.println(\"Queue size: \" + q.size());\n","filename":"test\/jdk\/java\/net\/httpclient\/SmokeTest.java","additions":33,"deletions":9,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8177552 8217721 8222756 8295372 8306116 8319990\n+ * @bug 8177552 8217721 8222756 8295372 8306116 8319990 8338690\n@@ -63,0 +63,3 @@\n+    private static final NumberFormat FORMAT_IT_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.ITALIAN, NumberFormat.Style.LONG);\n+\n@@ -92,0 +95,7 @@\n+\n+    private static final NumberFormat FORMAT_PL_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.of(\"pl\"), NumberFormat.Style.LONG);\n+\n+    private static final NumberFormat FORMAT_FR_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.FRENCH, NumberFormat.Style.LONG);\n+\n@@ -362,0 +372,6 @@\n+\n+            \/\/ 8338690\n+            {FORMAT_PL_LONG, 5_000, \"5 tysi\\u0119cy\"},\n+            {FORMAT_PL_LONG, 4_949, \"5 tysi\\u0119cy\"},\n+            {FORMAT_FR_LONG, 1_949, \"2 mille\"},\n+            {FORMAT_IT_LONG, 1_949, \"2 mila\"},\n@@ -469,0 +485,4 @@\n+                \/\/ 8338690\n+                {FORMAT_PL_LONG, \"5 tysi\\u0119cy\", 5_000L, Long.class},\n+                {FORMAT_FR_LONG, \"2 mille\", 2_000L, Long.class},\n+                {FORMAT_IT_LONG, \"2 mila\", 2_000L, Long.class},\n@@ -517,0 +537,4 @@\n+            \/\/ 8338690\n+            {FORMAT_PL_LONG, \"5 tysice\", 5L},\n+            {FORMAT_FR_LONG, \"2 millier\", 2L},\n+            {FORMAT_IT_LONG, \"2 mille\", 2L},\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestCompactNumber.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,4 +25,6 @@\n-   @bug 4028605 4109069 4234207 4401122\n-   @summary Make sure ZipInputStream\/InflaterInputStream.available() will\n-            return 0 after EOF has reached and 1 otherwise.\n-   *\/\n+ * @bug 4028605 4109069 4234207 4401122 8339154\n+ * @summary Verify that ZipInputStream, InflaterInputStream, ZipFileInputStream,\n+ *          ZipFileInflaterInputStream.available() return values according\n+ *          to their specification or long-standing behavior\n+ * @run junit Available\n+ *\/\n@@ -30,0 +32,5 @@\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -32,0 +39,3 @@\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -34,0 +44,3 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n@@ -36,6 +49,2 @@\n-    public static void main(String[] args) throws Exception {\n-        \/\/ 4028605 4109069 4234207\n-        test1();\n-        \/\/ test 4401122\n-        test2();\n-    }\n+    \/\/ ZIP file produced in this test\n+    private final Path zip = Path.of(\"available.jar\");\n@@ -43,2 +52,9 @@\n-    private static void test1() throws Exception {\n-        File f = new File(System.getProperty(\"test.src\", \".\"), \"input.jar\");\n+    \/**\n+     * Create the ZIP file used in this test, containing\n+     * one deflated and one stored entry.\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @BeforeEach\n+    public void setup() throws IOException {\n+        byte[] contents = \"contents\".repeat(10).getBytes(StandardCharsets.UTF_8);\n@@ -46,7 +62,4 @@\n-        \/\/ test ZipInputStream\n-        try (FileInputStream fis = new FileInputStream(f);\n-             ZipInputStream z = new ZipInputStream(fis))\n-        {\n-            z.getNextEntry();\n-            tryAvail(z);\n-        }\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+            \/\/ First entry uses DEFLATE method\n+            zo.putNextEntry(new ZipEntry(\"deflated.txt\"));\n+            zo.write(contents);\n@@ -54,3 +67,9 @@\n-        \/\/ test InflaterInputStream\n-        try (ZipFile zfile = new ZipFile(f)) {\n-            tryAvail(zfile.getInputStream(zfile.getEntry(\"Available.java\")));\n+            \/\/ Second entry uses STORED method\n+            ZipEntry stored = new ZipEntry(\"stored.txt\");\n+            stored.setMethod(ZipEntry.STORED);\n+            stored.setSize(contents.length);\n+            CRC32 crc32 = new CRC32();\n+            crc32.update(contents);\n+            stored.setCrc(crc32.getValue());\n+            zo.putNextEntry(stored);\n+            zo.write(contents);\n@@ -60,3 +79,32 @@\n-    static void tryAvail(InputStream in) throws Exception {\n-        byte[] buf = new byte[1024];\n-        int n;\n+    \/**\n+     * Delete the ZIP file created by this test\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Verify that ZipInputStream.available() returns 0 after EOF or\n+     * closeEntry, otherwise 1, as specified in the API description.\n+     * This tests 4028605 4109069 4234207\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @Test\n+    public void testZipInputStream() throws IOException {\n+        try (InputStream in = Files.newInputStream(zip)) {\n+            ZipInputStream z = new ZipInputStream(in);\n+            z.getNextEntry();\n+            assertEquals(1, z.available());\n+            z.read();\n+            assertEquals(1, z.available());\n+            z.transferTo(OutputStream.nullOutputStream());\n+            assertEquals(0, z.available(),\n+                    \"ZipInputStream.available() should return 0 after EOF\");\n+\n+            z.close();\n+            assertThrows(IOException.class, () -> z.available(),\n+                    \"Expected an IOException when calling available on a closed stream\");\n+        }\n@@ -64,3 +112,6 @@\n-        while ((n = in.read(buf)) != -1);\n-        if (in.available() != 0) {\n-            throw new Exception(\"available should return 0 after EOF\");\n+        try (InputStream in = Files.newInputStream(zip);\n+             ZipInputStream z = new ZipInputStream(in)) {\n+            z.getNextEntry();\n+            z.closeEntry();\n+            assertEquals(0, z.available(),\n+                    \"ZipInputStream.available() should return 0 after closeEntry\");\n@@ -70,5 +121,15 @@\n-    \/\/ To reproduce 4401122\n-    private static void test2() throws Exception {\n-        File f = new File(System.getProperty(\"test.src\", \".\"), \"input.jar\");\n-        try (ZipFile zf = new ZipFile(f)) {\n-            InputStream in = zf.getInputStream(zf.getEntry(\"Available.java\"));\n+    \/**\n+     * Verify that ZipFileInputStream|ZipFileInflaterInputStream.available()\n+     * return the number of remaining uncompressed bytes.\n+     *\n+     * This verifies unspecified, but long-standing behavior. See 4401122.\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = { \"stored.txt\", \"deflated.txt\" })\n+    public void testZipFileStreamsRemainingBytes(String entryName) throws IOException {\n+        try (ZipFile zfile = new ZipFile(zip.toFile())) {\n+            ZipEntry entry = zfile.getEntry(entryName);\n+            \/\/ Could be ZipFileInputStream or ZipFileInflaterInputStream\n+            InputStream in = zfile.getInputStream(entry);\n@@ -77,4 +138,7 @@\n-            in.read();\n-            if (in.available() != initialAvailable - 1)\n-                throw new RuntimeException(\"Available not decremented.\");\n-            for(int j=0; j<initialAvailable-1; j++)\n+\n+            \/\/ Initally, the number of remaining uncompressed bytes is the entry size\n+            assertEquals(entry.getSize(), initialAvailable);\n+\n+            \/\/ Read all bytes one by one\n+            for (int i = initialAvailable; i > 0; i--) {\n+                \/\/ Reading a single byte should decrement available by 1\n@@ -82,2 +146,7 @@\n-            if (in.available() != 0)\n-                throw new RuntimeException();\n+                assertEquals(i - 1, in.available(), \"Available not decremented\");\n+            }\n+\n+            \/\/ No remaining uncompressed bytes\n+            assertEquals(0, in.available());\n+\n+            \/\/ available() should still return 0 after close\n@@ -85,2 +154,1 @@\n-            if (in.available() != 0)\n-                throw new RuntimeException();\n+            assertEquals(0, in.available());\n@@ -89,1 +157,0 @@\n-\n","filename":"test\/jdk\/java\/util\/zip\/Available.java","additions":110,"deletions":43,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 4615343\n- * @summary Check that ZipError is thrown instead of InternalError when\n- * iterating entries of an invalid zip file\n- *\/\n-\n-import java.io.*;\n-import java.util.*;\n-import java.util.zip.*;\n-\n-public class TestZipError {\n-    public static void realMain(String[] args) throws Throwable {\n-        \/\/ Causing a ZipError is hard, especially on non-Windows systems.  See\n-        \/\/ comments below.\n-        String osName = System.getProperty(\"os.name\");\n-        if (!System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n-            return;\n-        }\n-\n-        String fileName = \"error4615343.zip\";\n-        File f = new File(fileName);\n-        f.delete();\n-        ZipOutputStream zos;\n-        ZipEntry ze;\n-\n-        \/\/ Create a zip file with two entries.\n-        zos = new ZipOutputStream(new FileOutputStream(f));\n-        ze = new ZipEntry(\"one\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"hello\".getBytes());\n-        zos.closeEntry();\n-        ze = new ZipEntry(\"two\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"world\".getBytes());\n-        zos.closeEntry();\n-        zos.close();\n-\n-        \/\/ Open the ZipFile.  This will read the zip file's central\n-        \/\/ directory into in-memory data structures.\n-        ZipFile zf = new ZipFile(fileName);\n-\n-        \/\/ Delete the file; of course this does not change the in-memory data\n-        \/\/ structures that represent the central directory!\n-        f.delete();\n-\n-        \/\/ Re-create zip file, with different entries than earlier.  However,\n-        \/\/ recall that we have in-memory information about the central\n-        \/\/ directory of the file at its previous state.\n-        zos = new ZipOutputStream(new FileOutputStream(f));\n-        ze = new ZipEntry(\"uno\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"hola\".getBytes());\n-        zos.closeEntry();\n-        zos.close();\n-\n-        \/\/ Iterate zip file's contents.  On Windows, this will result in a\n-        \/\/ ZipError, because the data in the file differs from the in-memory\n-        \/\/ central directory information we read earlier.\n-        Enumeration<? extends ZipEntry> entries = zf.entries();\n-        try {\n-            while (entries.hasMoreElements()) {\n-                ze = entries.nextElement();\n-                zf.getInputStream(ze).readAllBytes();\n-            }\n-            fail(\"Did not get expected exception\");\n-        } catch (ZipException e) {\n-            pass();\n-        } catch (InternalError e) {\n-            fail(\"Caught InternalError instead of expected ZipError\");\n-        } catch (Throwable t) {\n-            unexpected(t);\n-        } finally {\n-            zf.close();\n-            f.delete();\n-        }\n-    }\n-\n-    \/\/--------------------- Infrastructure ---------------------------\n-    static volatile int passed = 0, failed = 0;\n-    static void pass() {passed++;}\n-    static void fail() {failed++; Thread.dumpStack();}\n-    static void fail(String msg) {System.out.println(msg); fail();}\n-    static void unexpected(Throwable t) {failed++; t.printStackTrace();}\n-    static void check(boolean cond) {if (cond) pass(); else fail();}\n-    static void equal(Object x, Object y) {\n-        if (x == null ? y == null : x.equals(y)) pass();\n-        else fail(x + \" not equal to \" + y);}\n-    public static void main(String[] args) throws Throwable {\n-        try {realMain(args);} catch (Throwable t) {unexpected(t);}\n-        System.out.println(\"\\nPassed = \" + passed + \" failed = \" + failed);\n-        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n-}\n","filename":"test\/jdk\/java\/util\/zip\/TestZipError.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -42,1 +42,2 @@\n-        TLSBase.Client client1 = new TLSBase.Client(true, false);\n+        TLSBase.Client client = new TLSBase.Client(true, false);\n+        client.connect();\n@@ -44,2 +45,3 @@\n-        server.getSession(client1).getSessionContext();\n-        server.done();\n+        \/\/ Close must be called to gather all the exceptions thrown\n+        client.close();\n+        server.close();\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CertMsgCheck.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+        client1.connect();\n@@ -69,0 +70,1 @@\n+        client2.connect();\n@@ -76,1 +78,0 @@\n-        server.done();\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CheckSessionContext.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -32,1 +33,0 @@\n-import java.util.Arrays;\n@@ -35,0 +35,3 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n@@ -42,1 +45,1 @@\n- * Server.done() must be called or the server will never exit and hang the test.\n+ * Server.close() must be called so the server will exit and end threading.\n@@ -55,1 +58,1 @@\n-    static String pathToStores = \"..\/etc\";\n+    static String pathToStores = \"javax\/net\/ssl\/etc\";\n@@ -60,0 +63,3 @@\n+    static final String TESTROOT =\n+        System.getProperty(\"test.root\", \"..\/..\/..\/..\");\n+\n@@ -64,1 +70,1 @@\n-    String name;\n+    public String name;\n@@ -67,6 +73,4 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n+\n+        String keyFilename = TESTROOT +  \"\/\" + pathToStores + \"\/\" + keyStoreFile;\n+        String trustFilename = TESTROOT + \"\/\" + pathToStores + \"\/\" +\n+            trustStoreFile;\n@@ -81,5 +85,4 @@\n-        BufferedReader reader = new BufferedReader(\n-            new InputStreamReader(sock.getInputStream()));\n-        String s = reader.readLine();\n-        System.err.println(\"(read) \" + name + \": \" + s);\n-        return s.getBytes();\n+        BufferedInputStream is = new BufferedInputStream(sock.getInputStream());\n+        byte[] b = is.readNBytes(5);\n+        System.err.println(\"(read) \" + Thread.currentThread().getName() + \": \" + new String(b));\n+        return b;\n@@ -90,5 +93,2 @@\n-        PrintWriter out = new PrintWriter(\n-            new OutputStreamWriter(sock.getOutputStream()));\n-        out.println(new String(data));\n-        out.flush();\n-        System.err.println(\"(write)\" + name + \": \" + new String(data));\n+        sock.getOutputStream().write(data);\n+        System.err.println(\"(write)\" + Thread.currentThread().getName() + \": \" + new String(data));\n@@ -100,1 +100,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") +\n@@ -116,1 +116,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") +\n@@ -153,0 +153,5 @@\n+        ExecutorService threadPool = Executors.newFixedThreadPool(1,\n+            r -> {\n+                Thread t = Executors.defaultThreadFactory().newThread(r);\n+                return t;\n+            });\n@@ -163,0 +168,1 @@\n+                ssock.setReuseAddress(true);\n@@ -165,0 +171,1 @@\n+                System.out.println(\"Server Port: \" + serverPort);\n@@ -174,11 +181,2 @@\n-                        System.err.println(\"Server ready on port \" +\n-                            serverPort);\n-                        SSLSocket c = (SSLSocket)ssock.accept();\n-                        clientMap.put(c.getPort(), c);\n-                        try {\n-                            write(c, read(c));\n-                        } catch (Exception e) {\n-                            System.out.println(\"Caught \" + e.getMessage());\n-                            e.printStackTrace();\n-                            exceptionList.add(e);\n-                        }\n+                        SSLSocket sock = (SSLSocket)ssock.accept();\n+                        threadPool.submit(new ServerThread(sock));\n@@ -189,0 +187,2 @@\n+                } finally {\n+                    threadPool.close();\n@@ -194,3 +194,2 @@\n-        Server() {\n-            this(new ServerBuilder());\n-        }\n+        class ServerThread extends Thread {\n+            SSLSocket sock;\n@@ -198,42 +197,4 @@\n-        \/**\n-         * @param km - true for an empty key manager\n-         * @param tm - true for an empty trust manager\n-         *\/\n-        Server(boolean km, boolean tm) {\n-            super();\n-            name = \"server\";\n-            try {\n-                sslContext = SSLContext.getInstance(\"TLS\");\n-                sslContext.init(TLSBase.getKeyManager(km),\n-                    TLSBase.getTrustManager(tm), null);\n-                fac = sslContext.getServerSocketFactory();\n-                ssock = (SSLServerSocket) fac.createServerSocket(0);\n-                ssock.setNeedClientAuth(true);\n-                serverPort = ssock.getLocalPort();\n-            } catch (Exception e) {\n-                System.err.println(\"Failure during server initialization\");\n-                e.printStackTrace();\n-            }\n-\n-                \/\/ Thread to allow multiple clients to connect\n-                t = new Thread(() -> {\n-                    try {\n-                        while (true) {\n-                            System.err.println(\"Server ready on port \" +\n-                                serverPort);\n-                            SSLSocket c = (SSLSocket)ssock.accept();\n-                            clientMap.put(c.getPort(), c);\n-                            try {\n-                                write(c, read(c));\n-                            } catch (Exception e) {\n-                                System.out.println(\"Caught \" + e.getMessage());\n-                                e.printStackTrace();\n-                                exceptionList.add(e);\n-                            }\n-                        }\n-                    } catch (Exception ex) {\n-                        System.err.println(\"Server Down\");\n-                        ex.printStackTrace();\n-                    }\n-                });\n-                t.start();\n+            ServerThread(SSLSocket s) {\n+                this.sock = s;\n+                System.err.println(\"ServerThread(\"+sock.getPort()+\")\");\n+                clientMap.put(sock.getPort(), sock);\n@@ -242,17 +203,8 @@\n-        \/\/ Exit test to quit the test.  This must be called at the end of the\n-        \/\/ test or the test will never end.\n-        void done() {\n-            try {\n-                t.join(5000);\n-                ssock.close();\n-            } catch (Exception e) {\n-                System.err.println(e.getMessage());\n-                e.printStackTrace();\n-            }\n-        }\n-\n-        \/\/ Read from the client\n-        byte[] read(Client client) throws Exception {\n-            SSLSocket s = clientMap.get(Integer.valueOf(client.getPort()));\n-            if (s == null) {\n-                System.err.println(\"No socket found, port \" + client.getPort());\n+            public void run() {\n+                try {\n+                    write(sock, read(sock));\n+                } catch (Exception e) {\n+                    System.out.println(\"Caught \" + e.getMessage());\n+                    e.printStackTrace();\n+                    exceptionList.add(e);\n+                }\n@@ -260,1 +212,0 @@\n-            return read(s);\n@@ -263,3 +214,2 @@\n-        \/\/ Write to the client\n-        void write(Client client, byte[] data) throws Exception {\n-            write(clientMap.get(client.getPort()), data);\n+        Server() {\n+            this(new ServerBuilder());\n@@ -268,5 +218,7 @@\n-        \/\/ Server writes to the client, then reads from the client.\n-        \/\/ Return true if the read & write data match, false if not.\n-        boolean writeRead(Client client, String s) throws Exception{\n-            write(client, s.getBytes());\n-            return (Arrays.compare(s.getBytes(), client.read()) == 0);\n+        public SSLSession getSession(Client client) throws Exception {\n+            System.err.println(\"getSession(\"+client.getPort()+\")\");\n+            SSLSocket clientSocket = clientMap.get(client.getPort());\n+            if (clientSocket == null) {\n+                throw new Exception(\"Server can't find client socket\");\n+            }\n+            return clientSocket.getSession();\n@@ -275,4 +227,7 @@\n-        \/\/ Get the SSLSession from the server side socket\n-        SSLSession getSession(Client c) {\n-            SSLSocket s = clientMap.get(Integer.valueOf(c.getPort()));\n-            return s.getSession();\n+        void close(Client client) {\n+            try {\n+                System.err.println(\"close(\"+client.getPort()+\")\");\n+                clientMap.remove(client.getPort()).close();\n+            } catch (Exception e) {\n+                ;\n+            }\n@@ -280,5 +235,7 @@\n-\n-        \/\/ Close client socket\n-        void close(Client c) throws IOException {\n-            SSLSocket s = clientMap.get(Integer.valueOf(c.getPort()));\n-            s.close();\n+        void close() throws InterruptedException {\n+            clientMap.values().stream().forEach(s -> {\n+                try {\n+                    s.close();\n+                } catch (IOException e) {}\n+            });\n+            threadPool.awaitTermination(500, TimeUnit.MILLISECONDS);\n@@ -315,1 +272,1 @@\n-     * Client side will establish a connection from the constructor and wait.\n+     * Client side will establish a SSLContext instance.\n@@ -319,1 +276,1 @@\n-        SSLSocket sock;\n+        public SSLSocket socket;\n@@ -333,5 +290,0 @@\n-            connect();\n-        }\n-\n-        \/\/ Connect to server.  Maybe runnable in the future\n-        public SSLSocket connect() {\n@@ -341,7 +293,1 @@\n-                sock = (SSLSocket)sslContext.getSocketFactory().createSocket();\n-                sock.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), serverPort));\n-                System.err.println(\"Client connected using port \" +\n-                        sock.getLocalPort());\n-                name = \"client(\" + sock.toString() + \")\";\n-                write(\"Hello\");\n-                read();\n+                socket = createSocket();\n@@ -351,1 +297,0 @@\n-            return sock;\n@@ -354,3 +299,3 @@\n-        \/\/ Read from the client socket\n-        byte[] read() throws Exception {\n-            return read(sock);\n+        Client(Client cl) {\n+            sslContext = cl.sslContext;\n+            socket = createSocket();\n@@ -359,3 +304,7 @@\n-        \/\/ Write to the client socket\n-        void write(byte[] data) throws Exception {\n-            write(sock, data);\n+        public SSLSocket createSocket() {\n+            try {\n+                return (SSLSocket) sslContext.getSocketFactory().createSocket();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            return null;\n@@ -363,2 +312,12 @@\n-        void write(String s) throws Exception {\n-            write(sock, s.getBytes());\n+\n+        public SSLSocket connect() {\n+            try {\n+                socket.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), serverPort));\n+                System.err.println(\"Client (\" + Thread.currentThread().getName() + \") connected using port \" +\n+                    socket.getLocalPort() + \" to \" + socket.getPort());\n+                writeRead();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+                return null;\n+            }\n+            return socket;\n@@ -367,5 +326,9 @@\n-        \/\/ Client writes to the server, then reads from the server.\n-        \/\/ Return true if the read & write data match, false if not.\n-        boolean writeRead(Server server, String s) throws Exception {\n-            write(s.getBytes());\n-            return (Arrays.compare(s.getBytes(), server.read(this)) == 0);\n+        public SSLSession getSession() {\n+            return socket.getSession();\n+        }\n+        public void close() {\n+            try {\n+                socket.close();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n@@ -374,3 +337,2 @@\n-        \/\/ Get port from the socket\n-        int getPort() {\n-            return sock.getLocalPort();\n+        public int getPort() {\n+            return socket.getLocalPort();\n@@ -379,3 +341,8 @@\n-        \/\/ Close socket\n-        void close() throws IOException {\n-            sock.close();\n+        private SSLSocket writeRead() {\n+            try {\n+                write(socket, \"Hello\".getBytes(StandardCharsets.ISO_8859_1));\n+                read(socket);\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            return socket;\n@@ -383,0 +350,1 @@\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/TLSBase.java","additions":115,"deletions":147,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -0,0 +1,352 @@\n+\/*\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.Raster;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.imageio.ImageIO;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 8338103\n+ * @key headful\n+ * @summary Verifies that the OpenGL pipeline does not create artifacts\n+ * with swing components after window is zoomed to maximum size and then\n+ * resized back to normal. The test case simulates this operation using\n+ * a JButton. A file image of the component will be saved before and after\n+ * the window resize if the test fails. The test passes if both the button\n+ * images are the same.\n+ * @run main\/othervm -Dsun.java2d.opengl=true -Dsun.java2d.opengl.fbobject=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.opengl=true -Dsun.java2d.opengl.fbobject=true SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.opengl=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"windows\")\n+ * @run main\/othervm -Dsun.java2d.d3d=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.d3d=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"linux\")\n+ * @run main\/othervm -Dsun.java2d.xrender=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.xrender=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @run main\/othervm -Dsun.java2d.metal=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.metal=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+public class SwingButtonResizeTestWithOpenGL {\n+    private static Robot robot;\n+    private static CountDownLatch focusGainedLatch;\n+    private JFrame frame;\n+    private JButton button;\n+\n+    public SwingButtonResizeTestWithOpenGL() {\n+\n+        try {\n+            SwingUtilities.invokeAndWait(() -> createGUI());\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Problems creating GUI\");\n+        }\n+    }\n+\n+    private void createGUI() {\n+        frame = new JFrame(\"SwingButtonResizeTestWithOpenGL\");\n+        button = new JButton(\"Button A\");\n+        frame.setLocation(200, 200);\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        button.setPreferredSize(new Dimension(300, 300));\n+        button.addFocusListener(new FocusAdapter() {\n+            public void focusGained(FocusEvent fe) {\n+                focusGainedLatch.countDown();\n+            }\n+        });\n+        frame.getContentPane().setLayout(new FlowLayout());\n+        frame.getContentPane().add(button);\n+        frame.pack();\n+        frame.setVisible(true);\n+        frame.toFront();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        focusGainedLatch = new CountDownLatch(1);\n+        SwingButtonResizeTestWithOpenGL test =\n+                new SwingButtonResizeTestWithOpenGL();\n+        test.runTest();\n+    }\n+\n+    public void runTest() throws Exception {\n+        BufferedImage bimage1;\n+        BufferedImage bimage2;\n+\n+        try {\n+            robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.setAutoDelay(200);\n+\n+            if (focusGainedLatch.await(3, TimeUnit.SECONDS)) {\n+                System.out.println(\"Button focus gained...\");\n+            } else {\n+                System.out.println(\"Button focus not gained...\");\n+                throw new RuntimeException(\n+                        \"Can't gain focus on button even after waiting \" +\n+                        \"too long..\");\n+            }\n+\n+            System.out.println(\"Getting initial button image..image1\");\n+            bimage1 = getButtonImage();\n+\n+            \/\/ some platforms may not support maximize frame\n+            if (frame.getToolkit().isFrameStateSupported(\n+                    JFrame.MAXIMIZED_BOTH)) {\n+                robot.waitForIdle();\n+                \/\/ maximize frame from normal size\n+                frame.setExtendedState(JFrame.MAXIMIZED_BOTH);\n+                System.out.println(\"Frame is maximized\");\n+                robot.waitForIdle();\n+\n+                if (frame.getToolkit().isFrameStateSupported(JFrame.NORMAL)) {\n+                    System.out.println(\"Frame is back to normal\");\n+                    \/\/ resize from maximum size to normal\n+                    frame.setExtendedState(JFrame.NORMAL);\n+\n+                    \/\/ capture image of JButton after resize\n+                    System.out.println(\n+                            \"Getting image of JButton after resize..image2\");\n+                    bimage2 = getButtonImage();\n+\n+                    \/\/ compare button images from before and after frame resize\n+                    DiffImage di = new DiffImage(bimage1.getWidth(),\n+                                                 bimage1.getHeight());\n+                    System.out.println(\n+                            \"Taking the diff of two images, image1 and image2\");\n+                    if (!di.compare(bimage1, bimage2)) {\n+                        throw new RuntimeException(\n+                                \"Button renderings are different after window \"\n+                                + \"resize, num of Diff Pixels=\"\n+                                + di.getNumDiffPixels());\n+                    } else {\n+                        System.out.println(\"Test passed...\");\n+                    }\n+\n+                } else {\n+                    System.out.println(\n+                            \"Test skipped: JFrame.NORMAL resize is \" +\n+                            \"not supported\");\n+                }\n+\n+            } else {\n+                System.out.println(\n+                        \"Test skipped: JFrame.MAXIMIZED_BOTH resize is \" +\n+                        \"not supported\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> disposeFrame());\n+        }\n+    }\n+\n+    \/\/ Capture button rendering as a BufferedImage\n+    private BufferedImage getButtonImage() {\n+        try {\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            AtomicReference<Point> buttonLocRef = new AtomicReference<>();\n+            SwingUtilities.invokeAndWait(\n+                    () -> buttonLocRef.set(button.getLocationOnScreen()));\n+            Point buttonLoc = buttonLocRef.get();\n+            System.out.println(\"Button loc: \" + buttonLoc);\n+            return robot.createScreenCapture(\n+                    new Rectangle(buttonLoc.x, buttonLoc.y, button.getWidth(),\n+                                  button.getHeight()));\n+        } catch (Exception e) {\n+            throw new RuntimeException(\n+                    \"Problems capturing button image from Robot\", e);\n+        }\n+    }\n+\n+    private void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+    \/\/ Save BufferedImage to PNG file\n+    private void saveButtonImage(BufferedImage image, File file) {\n+        if (image != null) {\n+            try {\n+                System.out.println(\n+                        \"Saving button image to \" + file.getAbsolutePath());\n+                ImageIO.write(image, \"PNG\", file);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Could not write image file\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"BufferedImage was set to null\");\n+        }\n+    }\n+\n+    private class DiffImage extends BufferedImage {\n+\n+        public boolean diff = false;\n+        public int nDiff = -1;\n+\n+        Color bgColor;\n+\n+        int threshold = 0;\n+\n+        public DiffImage(int w, int h) {\n+            super(w, h, BufferedImage.TYPE_INT_ARGB);\n+            bgColor = Color.LIGHT_GRAY;\n+        }\n+\n+        public int getNumDiffPixels() {\n+            return nDiff;\n+        }\n+\n+        public boolean compare(BufferedImage img1, BufferedImage img2)\n+                throws IOException {\n+\n+            int minx1 = img1.getMinX();\n+            int minx2 = img2.getMinX();\n+            int miny1 = img1.getMinY();\n+            int miny2 = img2.getMinY();\n+\n+            int w1 = img1.getWidth();\n+            int w2 = img2.getWidth();\n+            int h1 = img1.getHeight();\n+            int h2 = img2.getHeight();\n+\n+            if ((minx1 != minx2) || (miny1 != miny2) || (w1 != w2)\n+                || (h1 != h2)) {\n+                \/\/ image sizes are different\n+                throw new RuntimeException(\n+                        \"img1: <\" + minx1 + \",\" + miny1 + \",\" + w1 + \"x\" + h1\n+                        + \">\" + \" img2: \" + minx2 + \",\" + miny2 + \",\" + w2 + \"x\"\n+                        + h2 + \">\" + \" are different sizes\");\n+            }\n+            \/\/ Get the actual data behind the images\n+            Raster ras1 = img1.getData();\n+            Raster ras2 = img2.getData();\n+\n+            ColorModel cm1 = img1.getColorModel();\n+            ColorModel cm2 = img2.getColorModel();\n+\n+            int r1, r2;  \/\/ red\n+            int g1, g2;  \/\/ green\n+            int b1, b2;  \/\/ blue\n+\n+            Object o1 = null;\n+            Object o2 = null;\n+            nDiff = 0;\n+            for (int x = minx1; x < (minx1 + w1); x++) {\n+                for (int y = miny1; y < (miny1 + h1); y++) {\n+                    \/\/ Causes rasters to allocate data\n+                    o1 = ras1.getDataElements(x, y, o1);\n+                    \/\/ and we reuse the data on every loop\n+                    o2 = ras2.getDataElements(x, y, o2);\n+\n+                    r1 = cm1.getRed(o1);\n+                    r2 = cm2.getRed(o2);\n+                    g1 = cm1.getGreen(o1);\n+                    g2 = cm2.getGreen(o2);\n+                    b1 = cm1.getBlue(o1);\n+                    b2 = cm2.getBlue(o2);\n+\n+                    int redAbs = Math.abs(r1 - r2);\n+                    int greenAbs = Math.abs(g1 - g2);\n+                    int blueAbs = Math.abs(b1 - b2);\n+                    if ((redAbs > threshold)\n+                        || (greenAbs > threshold)\n+                        || (blueAbs > threshold)) {\n+                        \/\/ pixel is different\n+                        setDiffPixel(x, y, redAbs, greenAbs, blueAbs);\n+                        nDiff++;\n+                    } else {\n+                        setSamePixel(x, y);\n+                    }\n+\n+                }\n+            }\n+            if (nDiff != 0) {\n+                ImageIO.write(this, \"png\",\n+                              new File(\"diffImage.png\"));\n+                saveButtonImage(img1, new File(\"image1.png\"));\n+                saveButtonImage(img2, new File(\"image2.png\"));\n+            }\n+            return nDiff == 0;\n+        }\n+\n+        void setDiffPixel(int x, int y, int r, int g, int b) {\n+            diff = true;\n+            setPixelValue(x, y, 255, r, g, b);\n+        }\n+\n+        void setSamePixel(int x, int y) {\n+            if (bgColor != null) {\n+                setPixelValue(x, y, 255, bgColor.getRed(),\n+                              bgColor.getGreen(),\n+                              bgColor.getBlue());\n+            } else {\n+                setPixelValue(x, y, 255, Color.black.getRed(),\n+                              Color.black.getGreen(), Color.black.getBlue());\n+            }\n+        }\n+\n+        void setPixelValue(int x, int y, int a, int r, int g, int b) {\n+            \/\/ setRGB uses BufferedImage.TYPE_INT_ARGB format\n+            int pixel =\n+                    ((a & 0xff) << 24) + ((r & 0xff) << 16) + ((g & 0xff) << 8)\n+                    + ((b & 0xff));\n+            setRGB(x, y, pixel);\n+        }\n+\n+    }\n+\n+}\n+\n+\n","filename":"test\/jdk\/javax\/swing\/JButton\/SwingButtonResizeTestWithOpenGL.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JTable;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+\/*\n+ * @test\n+ * @bug 8338041\n+ * @key headful\n+ * @summary Verify that Ctrl Shift RIGHT\/LEFT key extends columns till\n+ * Last\/First Columns in JTable\n+ * @requires (os.family == \"linux\")\n+ * @run main JTableCtrlShiftRightLeftKeyTest\n+ *\/\n+\n+public class JTableCtrlShiftRightLeftKeyTest {\n+    private static JFrame frame;\n+    private static JTable table;\n+    private static volatile Point tableLoc;\n+    private static volatile Rectangle cellRect;\n+    private static volatile int[] selectedColumnAfterKeyPress;\n+    private static Robot robot;\n+    private static final int SELECTED_COLUMN = 2;\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\");\n+        robot = new Robot();\n+        robot.setAutoDelay(50);\n+        try {\n+            SwingUtilities.invokeAndWait(JTableCtrlShiftRightLeftKeyTest::createAndShowUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                tableLoc = table.getLocationOnScreen();\n+                cellRect = table.getCellRect(0, SELECTED_COLUMN, true);\n+            });\n+\n+            robot.mouseMove(tableLoc.x + cellRect.x + cellRect.width \/ 2,\n+                    tableLoc.y + cellRect.y + cellRect.height \/ 2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            testCtrlShift(KeyEvent.VK_RIGHT, SELECTED_COLUMN,\n+                    table.getColumnCount() - 1, \"RIGHT\");\n+\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            testCtrlShift(KeyEvent.VK_LEFT, 0,\n+                    SELECTED_COLUMN, \"LEFT\");\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            System.out.println(\"Test Passed!\");\n+\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void testCtrlShift(int keySelected, int startCellCheck,\n+                                      int endCellCheck, String key) throws Exception {\n+        robot.keyPress(KeyEvent.VK_SHIFT);\n+        robot.keyPress(KeyEvent.VK_CONTROL);\n+        robot.keyPress(keySelected);\n+        robot.keyRelease(keySelected);\n+        robot.keyRelease(KeyEvent.VK_SHIFT);\n+        robot.keyRelease(KeyEvent.VK_CONTROL);\n+        robot.waitForIdle();\n+        robot.delay(100);\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            selectedColumnAfterKeyPress = table.getSelectedColumns();\n+        });\n+\n+        if (selectedColumnAfterKeyPress[0] != startCellCheck ||\n+                selectedColumnAfterKeyPress[selectedColumnAfterKeyPress.length - 1] !=\n+                        endCellCheck) {\n+            System.out.println(\"Selected Columns: \");\n+            for (int columnsSelected : selectedColumnAfterKeyPress) {\n+                System.out.println(columnsSelected);\n+            }\n+            String failureMsg = \"Test Failure. Failed to select cells for Ctrl\" +\n+                    \" Shift \" + key + \" selection\";\n+            throw new RuntimeException(failureMsg);\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frame = new JFrame(\"Test Ctrl Shift RIGHT\/LEFT Key Press\");\n+        table = new JTable(2, 5);\n+        table.setColumnSelectionAllowed(true);\n+        frame.getContentPane().add(table);\n+\n+        frame.setSize(200, 200);\n+        frame.setLocationRelativeTo(null);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/gtk\/JTableCtrlShiftRightLeftKeyTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -98,1 +98,1 @@\n-                    codeB.loadConstant(i.opcode(), val);\n+                    codeB.loadConstant(val);\n","filename":"test\/jdk\/jdk\/classfile\/AdaptCodeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,4 +88,4 @@\n-                                    builder.allocateLocal(TypeKind.ReferenceType);\n-                                    builder.allocateLocal(TypeKind.LongType);\n-                                    builder.allocateLocal(TypeKind.IntType);\n-                                    builder.allocateLocal(TypeKind.DoubleType);\n+                                    builder.allocateLocal(TypeKind.REFERENCE);\n+                                    builder.allocateLocal(TypeKind.LONG);\n+                                    builder.allocateLocal(TypeKind.INT);\n+                                    builder.allocateLocal(TypeKind.DOUBLE);\n@@ -327,1 +327,1 @@\n-                                                    storeStack.push(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n+                                                    storeStack.push(StoreInstruction.of(TypeKind.REFERENCE, slot++));\n","filename":"test\/jdk\/jdk\/classfile\/AdvancedTransformationsTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-                                assertEquals(nai.typeKind(), TypeKind.DoubleType);\n+                                assertEquals(nai.typeKind(), TypeKind.DOUBLE);\n","filename":"test\/jdk\/jdk\/classfile\/ArrayTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -262,3 +262,3 @@\n-                              int slot1 = xb.allocateLocal(TypeKind.IntType);\n-                              int slot2 = xb.allocateLocal(TypeKind.LongType);\n-                              int slot3 = xb.allocateLocal(TypeKind.IntType);\n+                              int slot1 = xb.allocateLocal(TypeKind.INT);\n+                              int slot2 = xb.allocateLocal(TypeKind.LONG);\n+                              int slot3 = xb.allocateLocal(TypeKind.INT);\n@@ -280,3 +280,3 @@\n-                                  int slot1 = bb.allocateLocal(TypeKind.IntType);\n-                                  int slot2 = bb.allocateLocal(TypeKind.LongType);\n-                                  int slot3 = bb.allocateLocal(TypeKind.IntType);\n+                                  int slot1 = bb.allocateLocal(TypeKind.INT);\n+                                  int slot2 = bb.allocateLocal(TypeKind.LONG);\n+                                  int slot3 = bb.allocateLocal(TypeKind.INT);\n@@ -288,1 +288,1 @@\n-                              int slot4 = xb.allocateLocal(TypeKind.IntType);\n+                              int slot4 = xb.allocateLocal(TypeKind.INT);\n@@ -302,3 +302,3 @@\n-                                                int slot1 = bb.allocateLocal(TypeKind.IntType);\n-                                                int slot2 = bb.allocateLocal(TypeKind.LongType);\n-                                                int slot3 = bb.allocateLocal(TypeKind.IntType);\n+                                                int slot1 = bb.allocateLocal(TypeKind.INT);\n+                                                int slot2 = bb.allocateLocal(TypeKind.LONG);\n+                                                int slot3 = bb.allocateLocal(TypeKind.INT);\n@@ -311,1 +311,1 @@\n-                                                int slot1 = bb.allocateLocal(TypeKind.IntType);\n+                                                int slot1 = bb.allocateLocal(TypeKind.INT);\n@@ -315,1 +315,1 @@\n-                              int slot4 = xb.allocateLocal(TypeKind.IntType);\n+                              int slot4 = xb.allocateLocal(TypeKind.INT);\n@@ -338,1 +338,1 @@\n-                var i = cob.allocateLocal(TypeKind.IntType);\n+                var i = cob.allocateLocal(TypeKind.INT);\n@@ -376,2 +376,2 @@\n-                    int d = cob.allocateLocal(TypeKind.IntType);\n-                    int e = cob.allocateLocal(TypeKind.IntType);\n+                    int d = cob.allocateLocal(TypeKind.INT);\n+                    int e = cob.allocateLocal(TypeKind.INT);\n","filename":"test\/jdk\/jdk\/classfile\/BuilderBlockTest.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-                            int stringSlot = xb.allocateLocal(TypeKind.ReferenceType);\n+                            int stringSlot = xb.allocateLocal(TypeKind.REFERENCE);\n@@ -221,1 +221,1 @@\n-                            int stringSlot = xb.allocateLocal(TypeKind.ReferenceType);\n+                            int stringSlot = xb.allocateLocal(TypeKind.REFERENCE);\n@@ -226,1 +226,1 @@\n-                                int intSlot = tb.allocateLocal(TypeKind.IntType);\n+                                int intSlot = tb.allocateLocal(TypeKind.INT);\n@@ -243,1 +243,1 @@\n-                                    int doubleSlot = tb.allocateLocal(TypeKind.DoubleType);\n+                                    int doubleSlot = tb.allocateLocal(TypeKind.DOUBLE);\n@@ -253,1 +253,1 @@\n-                                    int refSlot = tb.allocateLocal(TypeKind.ReferenceType);\n+                                    int refSlot = tb.allocateLocal(TypeKind.REFERENCE);\n@@ -284,1 +284,1 @@\n-                            int stringSlot = xb.allocateLocal(TypeKind.ReferenceType);\n+                            int stringSlot = xb.allocateLocal(TypeKind.REFERENCE);\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -67,3 +67,3 @@\n-                                  c0.loadConstant(LDC, \"string0\")\n-                                    .loadConstant(LDC, \"string131\")\n-                                    .loadConstant(LDC, \"string50\")\n+                                  c0.ldc(\"string0\")\n+                                    .ldc(\"string131\")\n+                                    .ldc(\"string50\")\n","filename":"test\/jdk\/jdk\/classfile\/LDCTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @summary Testing ClassFile constant instruction opcodes.\n+ * @summary Testing ClassFile constant instruction argument validation.\n@@ -29,4 +29,2 @@\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDesc;\n-import static java.lang.constant.ConstantDescs.CD_void;\n-import java.lang.constant.MethodTypeDesc;\n+import java.lang.classfile.instruction.ConstantInstruction;\n+import org.junit.jupiter.api.Test;\n@@ -34,5 +32,0 @@\n-import java.lang.reflect.AccessFlag;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.Opcode;\n-import org.junit.jupiter.api.*;\n-import static org.junit.jupiter.api.DynamicTest.dynamicTest;\n@@ -41,1 +34,0 @@\n-import java.util.stream.Stream;\n@@ -43,85 +35,15 @@\n-public class OpcodesValidationTest {\n-\n-    record Case(Opcode opcode, Object constant) {}\n-\n-    static Stream<Case> positiveCases() {\n-        return Stream.of(\n-            new Case(ACONST_NULL, null),\n-            new Case(SIPUSH, (int)Short.MIN_VALUE),\n-            new Case(SIPUSH, (int)Short.MAX_VALUE),\n-            new Case(BIPUSH, (int)Byte.MIN_VALUE),\n-            new Case(BIPUSH, (int)Byte.MAX_VALUE),\n-            new Case(ICONST_M1, -1),\n-            new Case(ICONST_0, 0),\n-            new Case(ICONST_1, 1),\n-            new Case(ICONST_2, 2),\n-            new Case(ICONST_3, 3),\n-            new Case(ICONST_4, 4),\n-            new Case(ICONST_5, 5),\n-            new Case(LCONST_0, 0l),\n-            new Case(LCONST_0, 0),\n-            new Case(LCONST_1, 1l),\n-            new Case(LCONST_1, 1),\n-            new Case(FCONST_0, 0.0f),\n-            new Case(FCONST_1, 1.0f),\n-            new Case(FCONST_2, 2.0f),\n-            new Case(DCONST_0, 0.0d),\n-            new Case(DCONST_1, 1.0d)\n-        );\n-    }\n-\n-    static Stream<Case> negativeCases() {\n-        return Stream.of(\n-            new Case(ACONST_NULL, 0),\n-            new Case(SIPUSH, (int)Short.MIN_VALUE - 1),\n-            new Case(SIPUSH, (int)Short.MAX_VALUE + 1),\n-            new Case(BIPUSH, (int)Byte.MIN_VALUE - 1),\n-            new Case(BIPUSH, (int)Byte.MAX_VALUE + 1),\n-            new Case(ICONST_M1, -1l),\n-            new Case(ICONST_0, 0l),\n-            new Case(ICONST_1, 1l),\n-            new Case(ICONST_2, 2l),\n-            new Case(ICONST_3, 3l),\n-            new Case(ICONST_4, 4l),\n-            new Case(ICONST_5, 5l),\n-            new Case(LCONST_0, null),\n-            new Case(LCONST_0, 1l),\n-            new Case(LCONST_1, 1.0d),\n-            new Case(LCONST_1, 0),\n-            new Case(FCONST_0, 0.0d),\n-            new Case(FCONST_1, 1.01f),\n-            new Case(FCONST_2, 2),\n-            new Case(DCONST_0, 0.0f),\n-            new Case(DCONST_1, 1.0f),\n-            new Case(DCONST_1, 1)\n-        );\n-    }\n-\n-    @TestFactory\n-    Stream<DynamicTest> testPositiveCases() {\n-        return positiveCases().map(c -> dynamicTest(c.toString(), () -> testPositiveCase(c.opcode, c.constant)));\n-    }\n-\n-    private void testPositiveCase(Opcode opcode, Object constant) {\n-        ClassFile.of().build(ClassDesc.of(\"MyClass\"),\n-                        cb -> cb.withFlags(AccessFlag.PUBLIC)\n-                                .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0,\n-                                      mb -> mb.withCode(\n-                                              codeb -> codeb.loadConstant(opcode, (ConstantDesc) constant))));\n-    }\n-\n-\n-    @TestFactory\n-    Stream<DynamicTest> testNegativeCases() {\n-        return negativeCases().map(c -> dynamicTest(\n-            c.toString(),\n-            () -> assertThrows(IllegalArgumentException.class, () -> testNegativeCase(c.opcode, c.constant))\n-        ));\n-    }\n-\n-    private void testNegativeCase(Opcode opcode, Object constant) {\n-        ClassFile.of().build(ClassDesc.of(\"MyClass\"),\n-                        cb -> cb.withFlags(AccessFlag.PUBLIC)\n-                                .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0,\n-                        mb -> mb .withCode(\n-                                codeb -> codeb.loadConstant(opcode, (ConstantDesc)constant))));\n+class OpcodesValidationTest {\n+\n+    @Test\n+    void testArgumentConstant() {\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, 0));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MIN_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MAX_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, 0));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MIN_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MAX_VALUE));\n+\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int)Short.MIN_VALUE - 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int)Short.MAX_VALUE + 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int)Byte.MIN_VALUE - 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int)Byte.MAX_VALUE + 1));\n","filename":"test\/jdk\/jdk\/classfile\/OpcodesValidationTest.java","additions":19,"deletions":97,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-                var stackTracker = CodeStackTracker.of(DoubleType, FloatType); \/\/initial stack tracker pre-set\n+                var stackTracker = CodeStackTracker.of(DOUBLE, FLOAT); \/\/initial stack tracker pre-set\n@@ -50,1 +50,1 @@\n-                    assertIterableEquals(stackTracker.stack().get(), List.of(DoubleType, FloatType));\n+                    assertIterableEquals(stackTracker.stack().get(), List.of(DOUBLE, FLOAT));\n@@ -52,1 +52,1 @@\n-                    assertIterableEquals(stackTracker.stack().get(), List.of(ReferenceType, DoubleType, FloatType));\n+                    assertIterableEquals(stackTracker.stack().get(), List.of(REFERENCE, DOUBLE, FLOAT));\n@@ -54,1 +54,1 @@\n-                    assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                    assertIterableEquals(stackTracker.stack().get(), List.of(LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -56,1 +56,1 @@\n-                        assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -58,1 +58,1 @@\n-                        assertIterableEquals(stackTracker.stack().get(), List.of(IntType, LongType, ReferenceType, DoubleType, FloatType));\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(INT, LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -60,1 +60,1 @@\n-                            assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                            assertIterableEquals(stackTracker.stack().get(), List.of(LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -62,1 +62,1 @@\n-                            assertIterableEquals(stackTracker.stack().get(), List.of(ReferenceType, LongType, ReferenceType, DoubleType, FloatType));\n+                            assertIterableEquals(stackTracker.stack().get(), List.of(REFERENCE, LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -66,1 +66,1 @@\n-                        assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -70,1 +70,1 @@\n-                        assertIterableEquals(stackTracker.stack().get(), List.of(ReferenceType));\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(REFERENCE));\n","filename":"test\/jdk\/jdk\/classfile\/StackTrackerTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,0 @@\n-import static java.lang.classfile.Opcode.INVOKESPECIAL;\n-import static java.lang.classfile.TypeKind.VoidType;\n","filename":"test\/jdk\/jdk\/classfile\/TempConstantPoolBuilderTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-import static java.lang.classfile.TypeKind.VoidType;\n","filename":"test\/jdk\/jdk\/classfile\/Utf8EntryTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -523,1 +523,1 @@\n-                        new ConstantPoolEntryRecord.CpClassRecord(\"[\" + cins.typeKind().descriptor()).hashCode() + 1;\n+                        new ConstantPoolEntryRecord.CpClassRecord(\"[\" + cins.typeKind().upperBound().descriptorString()).hashCode() + 1;\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/ClassRecord.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-                cb.loadConstant(im.opcode(), im.constantValue());\n+                cb.loadConstant(im.constantValue());\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/InstructionModelToCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -222,8 +222,8 @@\n-                        case ByteType -> cob.baload();\n-                        case ShortType -> cob.saload();\n-                        case IntType -> cob.iaload();\n-                        case FloatType -> cob.faload();\n-                        case LongType -> cob.laload();\n-                        case DoubleType -> cob.daload();\n-                        case ReferenceType -> cob.aaload();\n-                        case CharType -> cob.caload();\n+                        case BYTE -> cob.baload();\n+                        case SHORT -> cob.saload();\n+                        case INT -> cob.iaload();\n+                        case FLOAT -> cob.faload();\n+                        case LONG -> cob.laload();\n+                        case DOUBLE -> cob.daload();\n+                        case REFERENCE -> cob.aaload();\n+                        case CHAR -> cob.caload();\n@@ -235,8 +235,8 @@\n-                        case ByteType -> cob.bastore();\n-                        case ShortType -> cob.sastore();\n-                        case IntType -> cob.iastore();\n-                        case FloatType -> cob.fastore();\n-                        case LongType -> cob.lastore();\n-                        case DoubleType -> cob.dastore();\n-                        case ReferenceType -> cob.aastore();\n-                        case CharType -> cob.castore();\n+                        case BYTE -> cob.bastore();\n+                        case SHORT -> cob.sastore();\n+                        case INT -> cob.iastore();\n+                        case FLOAT -> cob.fastore();\n+                        case LONG -> cob.lastore();\n+                        case DOUBLE -> cob.dastore();\n+                        case REFERENCE -> cob.aastore();\n+                        case CHAR -> cob.castore();\n@@ -307,1 +307,1 @@\n-                        case DoubleType -> {\n+                        case DOUBLE -> {\n@@ -309,3 +309,3 @@\n-                                case FloatType -> cob.d2f();\n-                                case IntType -> cob.d2i();\n-                                case LongType -> cob.d2l();\n+                                case FLOAT -> cob.d2f();\n+                                case INT -> cob.d2i();\n+                                case LONG -> cob.d2l();\n@@ -315,1 +315,1 @@\n-                        case FloatType -> {\n+                        case FLOAT -> {\n@@ -317,3 +317,3 @@\n-                                case DoubleType -> cob.f2d();\n-                                case IntType -> cob.f2i();\n-                                case LongType -> cob.f2l();\n+                                case DOUBLE -> cob.f2d();\n+                                case INT -> cob.f2i();\n+                                case LONG -> cob.f2l();\n@@ -323,1 +323,1 @@\n-                        case IntType -> {\n+                        case INT -> {\n@@ -325,6 +325,6 @@\n-                                case ByteType -> cob.i2b();\n-                                case CharType -> cob.i2c();\n-                                case DoubleType -> cob.i2d();\n-                                case FloatType -> cob.i2f();\n-                                case LongType -> cob.i2l();\n-                                case ShortType -> cob.i2s();\n+                                case BYTE -> cob.i2b();\n+                                case CHAR -> cob.i2c();\n+                                case DOUBLE -> cob.i2d();\n+                                case FLOAT -> cob.i2f();\n+                                case LONG -> cob.i2l();\n+                                case SHORT -> cob.i2s();\n@@ -334,1 +334,1 @@\n-                        case LongType -> {\n+                        case LONG -> {\n@@ -336,3 +336,3 @@\n-                                case DoubleType -> cob.l2d();\n-                                case FloatType -> cob.l2f();\n-                                case IntType -> cob.l2i();\n+                                case DOUBLE -> cob.l2d();\n+                                case FLOAT -> cob.l2f();\n+                                case INT -> cob.l2i();\n@@ -413,5 +413,5 @@\n-                        case IntType -> cob.iload(i.slot());\n-                        case FloatType -> cob.fload(i.slot());\n-                        case LongType -> cob.lload(i.slot());\n-                        case DoubleType -> cob.dload(i.slot());\n-                        case ReferenceType -> cob.aload(i.slot());\n+                        case INT -> cob.iload(i.slot());\n+                        case FLOAT -> cob.fload(i.slot());\n+                        case LONG -> cob.lload(i.slot());\n+                        case DOUBLE -> cob.dload(i.slot());\n+                        case REFERENCE -> cob.aload(i.slot());\n@@ -423,5 +423,5 @@\n-                        case IntType -> cob.istore(i.slot());\n-                        case FloatType -> cob.fstore(i.slot());\n-                        case LongType -> cob.lstore(i.slot());\n-                        case DoubleType -> cob.dstore(i.slot());\n-                        case ReferenceType -> cob.astore(i.slot());\n+                        case INT -> cob.istore(i.slot());\n+                        case FLOAT -> cob.fstore(i.slot());\n+                        case LONG -> cob.lstore(i.slot());\n+                        case DOUBLE -> cob.dstore(i.slot());\n+                        case REFERENCE -> cob.astore(i.slot());\n@@ -518,6 +518,6 @@\n-                        case IntType -> cob.ireturn();\n-                        case FloatType -> cob.freturn();\n-                        case LongType -> cob.lreturn();\n-                        case DoubleType -> cob.dreturn();\n-                        case ReferenceType -> cob.areturn();\n-                        case VoidType -> cob.return_();\n+                        case INT -> cob.ireturn();\n+                        case FLOAT -> cob.freturn();\n+                        case LONG -> cob.lreturn();\n+                        case DOUBLE -> cob.dreturn();\n+                        case REFERENCE -> cob.areturn();\n+                        case VOID -> cob.return_();\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":51,"deletions":51,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -24,0 +24,3 @@\n+import jdk.test.lib.containers.systemd.SystemdRunOptions;\n+import jdk.test.lib.containers.systemd.SystemdTestUtils;\n+import jdk.test.whitebox.WhiteBox;\n@@ -29,0 +32,1 @@\n+ * @modules java.base\/jdk.internal.platform\n@@ -34,9 +38,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.NoSuchFileException;\n-\n-import jdk.test.lib.containers.systemd.SystemdRunOptions;\n-import jdk.test.lib.containers.systemd.SystemdTestUtils;\n-import jdk.test.lib.containers.systemd.SystemdTestUtils.ResultFiles;\n-import jdk.test.whitebox.WhiteBox;\n-\n-\n@@ -47,1 +42,1 @@\n-    private static final int GB = 1024 * 1024 * 1024;\n+    private static final String TEST_SLICE_NAME = SystemdMemoryAwarenessTest.class.getSimpleName() + \"JDK\";\n@@ -56,2 +51,6 @@\n-        \/\/ 1 GB memory\n-        opts.memoryLimit(String.format(\"%d\", 1 * GB));\n+\n+        \/\/ 1 GB memory, but the limit in the lower hierarchy is 512M\n+        opts.memoryLimit(\"1024M\");\n+        int expectedMemLimit = 512;\n+        \/\/ expected detected limit we test for, 512MB\n+        opts.sliceDMemoryLimit(String.format(\"%dM\", expectedMemLimit));\n@@ -66,3 +65,1 @@\n-        opts.sliceName(SystemdMemoryAwarenessTest.class.getSimpleName());\n-\n-        ResultFiles files = SystemdTestUtils.buildSystemdSlices(opts);\n+        opts.sliceName(TEST_SLICE_NAME);\n@@ -70,16 +67,7 @@\n-        try {\n-            SystemdTestUtils.systemdRunJava(opts)\n-                .shouldHaveExitValue(0)\n-                .shouldContain(\"Operating System Metrics:\")\n-                .shouldContain(\"Effective CPU Count: \" + coreLimit)\n-                .shouldContain(String.format(\"CPU Period: %dus\", HUNDRED_THOUSEND))\n-                .shouldContain(String.format(\"CPU Quota: %dus\", (HUNDRED_THOUSEND * coreLimit)))\n-                .shouldContain(\"Memory Limit: 1.00G\");\n-        } finally {\n-            try {\n-                Files.delete(files.memory());\n-                Files.delete(files.cpu());\n-            } catch (NoSuchFileException e) {\n-                \/\/ ignore\n-            }\n-        }\n+        SystemdTestUtils.buildAndRunSystemdJava(opts)\n+            .shouldHaveExitValue(0)\n+            .shouldContain(\"Operating System Metrics:\")\n+            .shouldContain(\"Effective CPU Count: \" + coreLimit)\n+            .shouldContain(String.format(\"CPU Period: %dus\", HUNDRED_THOUSEND))\n+            .shouldContain(String.format(\"CPU Quota: %dus\", (HUNDRED_THOUSEND * coreLimit)))\n+            .shouldContain(String.format(\"Memory Limit: %d.00M\", expectedMemLimit));\n","filename":"test\/jdk\/jdk\/internal\/platform\/systemd\/SystemdMemoryAwarenessTest.java","additions":19,"deletions":31,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Palantir Technologies, Inc. and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestChunkInputStreamBulkRead\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.api.consumer.TestChunkInputStreamBulkRead\n+ *\/\n+package jdk.jfr.api.consumer;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.jfr.Recording;\n+import jdk.test.lib.Asserts;\n+\n+public class TestChunkInputStreamBulkRead {\n+\n+    public static void main(String[] args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+            try (Recording s = new Recording()) {\n+                s.start();\n+                s.stop();\n+            }\n+            r.stop();\n+            try (InputStream stream = r.getStream(null, null);\n+                 ByteArrayOutputStream output = new ByteArrayOutputStream()) {\n+                long read = stream.transferTo(output);\n+                System.out.printf(\"Read %d bytes from JFR stream%n\", read);\n+                Asserts.assertEquals(r.getSize(), read);\n+\n+                byte[] actual = output.toByteArray();\n+                Asserts.assertEqualsByteArray(r.getStream(null, null).readAllBytes(), actual);\n+\n+                Path dumpFile = Paths.get(\"recording.jfr\").toAbsolutePath().normalize();\n+                r.dump(dumpFile);\n+                System.out.printf(\"Dumped recording to %s (%d bytes)%n\", dumpFile, Files.size(dumpFile));\n+                Asserts.assertEqualsByteArray(Files.readAllBytes(dumpFile), actual);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/TestChunkInputStreamBulkRead.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/**\n+ * @test\n+ * @summary Verify that duplicate longer strings doesn't take up unneccessary space\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.jvm.TestLongStringsInPool\n+ *\/\n+public class TestLongStringsInPool {\n+    private static class StringEvent extends Event {\n+        String message;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Create two recordings; first has only one large\n+        \/\/ string, second has several occurences of the same\n+        \/\/ string. With long strings (>128 chars) being pooled,\n+        \/\/ the two recording should be roughly the same size.\n+        final int numEvents = 10;\n+        final String longString = generateString();\n+        final int strLen = longString.length();\n+        final StringEvent event = new StringEvent();\n+        event.message = longString;\n+\n+        Recording firstRec = new Recording();\n+        firstRec.start();\n+        \/\/ commit events with empty message (both recordings\n+        \/\/ will have the same number of events)\n+        for (int i = 0; i < numEvents - 1; i++) {\n+            event.message = \"\";\n+            event.commit();\n+        }\n+        \/\/ commit 1 event with a long string\n+        event.message = longString;\n+        event.commit();\n+\n+        firstRec.stop();\n+        Path rec1 = Paths.get(\".\", \"rec1.jfr\");\n+        firstRec.dump(rec1);\n+        firstRec.close();\n+\n+\n+        Recording secondRec = new Recording();\n+        secondRec.start();\n+        \/\/ commit events with the same long string\n+        for (int i = 0; i < numEvents - 1; i++) {\n+          event.message = longString;\n+          event.commit();\n+        }\n+        \/\/ commit 1 event with a long string\n+        event.message = longString;\n+        event.commit();\n+\n+        secondRec.stop();\n+        Path rec2 = Paths.get(\".\", \"rec2.jfr\");\n+        secondRec.dump(rec2);\n+        secondRec.close();\n+\n+        \/\/ the files aren't exactly the same size, but rec2 should\n+        \/\/ not take up space for all strings if they're pooled correctly\n+        long maxAllowedDiff = (numEvents - 1) * strLen;\n+        long diff = Math.abs(Files.size(rec2) - Files.size(rec1));\n+\n+        Asserts.assertTrue(diff <= maxAllowedDiff, \"Size difference between recordings is too large: \"+ diff +\" > \" + maxAllowedDiff);\n+        Asserts.assertFalse(RecordingFile.readAllEvents(rec1).isEmpty(), \"No events found in recording 1\");\n+        Asserts.assertFalse(RecordingFile.readAllEvents(rec2).isEmpty(), \"No events found in recording 2\");\n+        Asserts.assertEquals(RecordingFile.readAllEvents(rec1).size(), RecordingFile.readAllEvents(rec2).size(), \"The recordings don't have the same number of events\");\n+    }\n+\n+    \/**\n+     * Generate a string of 256 chars length.\n+     * @return\n+     *\/\n+    private static String generateString() {\n+        final StringBuilder builder = new StringBuilder();\n+        for (int i = 0; i < 32; i++) {\n+            builder.append(\"abcdefgh\");\n+        }\n+        return builder.toString();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestLongStringsInPool.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.function.Supplier;\n@@ -42,0 +43,3 @@\n+    private static final String KO_OVERFLOW = \"Some records have not been disposed!\";\n+    private static final String KO_UNDERFLOW = \"Disposed more records than were added!\";\n+\n@@ -43,2 +47,1 @@\n-        TestDisposerRace test = new TestDisposerRace();\n-        test.run();\n+        new TestDisposerRace().run();\n@@ -48,0 +51,1 @@\n+            System.err.println(KO_OVERFLOW); \/\/ In case the next line fails to allocate due to OOME\n@@ -52,0 +56,4 @@\n+    interface ThrowingRunnable<E extends Exception> {\n+        void run() throws E;\n+    }\n+\n@@ -59,3 +67,4 @@\n-            SwingUtilities.invokeAndWait(Disposer::pollRemove);\n-            if (i % 10 == 0) {\n-                \/\/ Adding records will race with the diposer trying to remove them\n+            retryOnOOME(() -> SwingUtilities.invokeAndWait(Disposer::pollRemove));\n+\n+            \/\/ Adding records will race with the diposer trying to remove them\n+            if (i % 10 == 0)\n@@ -63,1 +72,0 @@\n-            }\n@@ -66,1 +74,1 @@\n-        Disposer.addObjectRecord(new Object(), new FinalDisposerRecord());\n+        retryOnOOME(() -> Disposer.addObjectRecord(new Object(), new FinalDisposerRecord()));\n@@ -75,1 +83,26 @@\n-            throw new RuntimeException(\"Disposed more records than were added\");\n+            throw new RuntimeException(KO_UNDERFLOW);\n+        }\n+    }\n+\n+    private static <T> T retryOnOOME(Supplier<T> allocator) {\n+        for(;;) {\n+            try {\n+                return allocator.get();\n+            } catch (OutOfMemoryError ignored1) {\n+                try {\n+                    Thread.sleep(1); \/\/ Give GC a little chance to run\n+                } catch (InterruptedException ignored2) {}\n+            }\n+        }\n+    }\n+\n+    private static <E extends Exception> void retryOnOOME(ThrowingRunnable<E> tr) throws E {\n+        for(;;) {\n+            try {\n+                tr.run();\n+                break;\n+            } catch (OutOfMemoryError ignored1) {\n+                try {\n+                    Thread.sleep(1); \/\/ Give GC a little chance to run\n+                } catch (InterruptedException ignored2) {}\n+            }\n@@ -82,1 +115,1 @@\n-        recordsCount.addAndGet(count);\n+        MyDisposerRecord disposerRecord = retryOnOOME(MyDisposerRecord::new);\n@@ -84,3 +117,5 @@\n-        MyDisposerRecord disposerRecord = new MyDisposerRecord();\n-        for (int i = 0; i < count; i++) {\n-            Disposer.addObjectRecord(new Object(), disposerRecord);\n+        while(count > 0) {\n+            recordsCount.incrementAndGet(); \/\/ pre-add to make sure it doesn't go negative\n+            var o = retryOnOOME(Object::new);\n+            retryOnOOME(() -> Disposer.addObjectRecord(o, disposerRecord));\n+            --count;\n@@ -109,1 +144,0 @@\n-        final List<Object> leak = new LinkedList<>();\n@@ -111,0 +145,1 @@\n+            final List<Object> leak = new LinkedList<>();\n","filename":"test\/jdk\/sun\/java2d\/Disposer\/TestDisposerRace.java","additions":48,"deletions":13,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies multiple PSKs are used by JSSE\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=1\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=3\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=10\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.2 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/**\n+ * This test verifies that multiple NSTs and PSKs are sent by a JSSE server.\n+ * Then JSSE client is able to store them all and resume the connection.  It\n+ * requires specific text in the TLS debugging to verify the success.\n+ *\/\n+\n+public class MultiNSTClient {\n+\n+    static HexFormat hex = HexFormat.of();\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> {\n+                sb.append(a);\n+                sb.append(\" \");\n+            });\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params\n+                );\n+\n+            boolean TLS13 = args[0].contains(\"1.3\");\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTClient\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            System.out.println(\"I'm here\");\n+            boolean pass = true;\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                for (int i = 0; i < 2; i++) {\n+                    String svr = serverPSK.getFirst();\n+                    String cli = clientPSK.getFirst();\n+                    if (svr.regionMatches(svr.length() - 16, cli, cli.length() - 16, 16)) {\n+                        System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                    } else {\n+                        System.out.println(\"entry \" + (i + 1) + \" server and client PSK didn't match:\");\n+                        System.out.println(\"  server: \" + svr);\n+                        System.out.println(\"  client: \" + cli);\n+                        pass = false;\n+                    }\n+                }\n+            } catch (RuntimeException e) {\n+                System.out.println(\"No MultiNST PSK found.\");\n+                pass = false;\n+            }\n+\n+            if (TLS13) {\n+                if (!pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            } else {\n+                if (pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Start connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        SSLSession initialSession = initial.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  getNewSession from original client\");\n+        TLSBase.Client resumClient = new TLSBase.Client(initial);\n+        SSLSession resumption = resumClient.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  Second getNewSession from original client\");\n+        TLSBase.Client resumClient2 = new TLSBase.Client(initial);\n+        resumption = resumClient2.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  New client connection\");\n+        TLSBase.Client newConnection = new TLSBase.Client();\n+        SSLSession newSession = newConnection.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(newSession.getId()));\n+        System.out.println(\"session = \" + newSession);\n+        if (initialSession.toString().equalsIgnoreCase(newSession.toString())) {\n+            throw new Exception(\"new session is the same as the initial.\");\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        resumClient.close();\n+        resumClient2.close();\n+        newConnection.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTClient.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies resumption fails with 0 NSTs and session creation off\n+ * @run main\/othervm MultiNSTNoSessionCreation -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=0\n+ * @run main\/othervm MultiNSTNoSessionCreation -Djdk.tls.client.protocols=TLSv1.2 -Djdk.tls.server.newSessionTicketCount=0\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * With no NSTs sent by the server, try to resume the session with\n+ * setEnabledSessionCreation(false).  The test should get an exception and\n+ * fail to connect.\n+ *\/\n+\n+public class MultiNSTNoSessionCreation {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> sb.append(a).append(\" \"));\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params);\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTNoSessionCreation\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            try {\n+                if (output.stderrContains(\n+                    \"(PROTOCOL_VERSION): New session creation is disabled\")) {\n+                    return;\n+                }\n+            } catch (RuntimeException e) {\n+                throw new Exception(\"Error collecting data\", e);\n+            }\n+            throw new Exception(\"Disabled creation msg not found\");\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Initial connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        initial.connect();\n+        System.out.println(\n+            \"------  Resume client w\/ setEnableSessionCreation set to false\");\n+        TLSBase.Client resumClient = new TLSBase.Client(initial);\n+        resumClient.socket.setEnableSessionCreation(false);\n+        resumClient.connect();\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        resumClient.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTNoSessionCreation.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies multiple PSKs are used by TLSv1.3\n+ * @run main\/othervm MultiNSTParallel 10 -Djdk.tls.client.protocols=TLSv1.3\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.ArrayList;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * This test verifies that parallel resumption connections successfully get\n+ * a PSK entry and not initiate a full handshake.\n+ *\n+ * Note:  THe first argument after 'MultiNSTParallel' is the ticket count\n+ * The test will set 'jdk.tls.server.NewSessionTicketCount` to that number and\n+ * will start the same number of resumption client attempts. The ticket count\n+ * must be the same or larger than resumption attempts otherwise the queue runs\n+ * empty and the test will fail.\n+ *\n+ * Because this test runs parallel connections, the thread order finish is not\n+ * guaranteed.  Each client NST id is checked with all server NSTs ids until\n+ * a match is found.  When a match is found, it is removed from the list to\n+ * verify no NST was used more than once.\n+ *\n+ * TLS 1.2 spec does not specify multiple NST behavior.\n+ *\/\n+\n+public class MultiNSTParallel {\n+\n+    static HexFormat hex = HexFormat.of();\n+    final static CountDownLatch wait = new CountDownLatch(1);\n+\n+    static class ClientThread extends Thread {\n+        TLSBase.Client client;\n+\n+        ClientThread(TLSBase.Client c) {\n+            client = c;\n+        }\n+\n+        public void run() {\n+            String name = Thread.currentThread().getName();\n+            SSLSession r;\n+            System.err.println(\"waiting \" + Thread.currentThread().getName());\n+            try {\n+                wait.await();\n+                r = new TLSBase.Client(client).connect().getSession();\n+            } catch (Exception e) {\n+                throw new RuntimeException(name + \": \" +e);\n+            }\n+            StringBuffer sb = new StringBuffer(100);\n+            sb.append(\"(\").append(name).append(\") id = \");\n+            sb.append(hex.formatHex(r.getId()));\n+            sb.append(\"\\n(\").append(name).append(\") session = \").append(r);\n+            if (!client.getSession().toString().equalsIgnoreCase(r.toString())) {\n+                throw new RuntimeException(\"(\" + name +\n+                    \") Resumed session did not match\");\n+            }\n+        }\n+    }\n+\n+    static boolean pass = true;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            int ticketCount = Integer.parseInt(args[0]);\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 1; i < args.length; i++) {\n+                sb.append(\" \").append(args[i]);\n+            }\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" +\n+                    \" -Djdk.tls.server.newSessionTicketCount=\" + ticketCount +\n+                    params);\n+\n+            boolean TLS13 = args[1].contains(\"1.3\");\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTParallel\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> sp = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> serverPSK = new ArrayList<>(sp.stream().toList());\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+\n+                \/\/ Must search all results as order is not guaranteed.\n+                clientPSK.stream().forEach(cli -> {\n+                    for (int i = 0; i < serverPSK.size(); i++) {\n+                        String svr = serverPSK.get(i);\n+                        if (svr.regionMatches(svr.length() - 16, cli,\n+                            cli.length() - 16, 16)) {\n+                            System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                            serverPSK.remove(i);\n+                            return;\n+                        }\n+                    }\n+                    System.out.println(\"client entry (\" + cli.substring(0, 16) +\n+                        \") not found in server list\");\n+                    pass = false;\n+                });\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Error looking at PSK results.\");\n+                throw new Exception(e);\n+            }\n+\n+            if (TLS13) {\n+                if (!pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            } else {\n+                if (pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        int ticketCount = Integer.parseInt(\n+            System.getProperty(\"jdk.tls.server.newSessionTicketCount\"));\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Start connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        SSLSession initialSession = initial.getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  getNewSession from original client\");\n+\n+        ArrayList<Thread> slist = new ArrayList<>(ticketCount);\n+\n+        System.out.println(\"tx \" + ticketCount);\n+        for (int i = 0; ticketCount > i; i++) {\n+            Thread t = new ClientThread(initial);\n+            t.setName(\"Iteration \" + i);\n+            slist.add(t);\n+            t.start();\n+        }\n+\n+        wait.countDown();\n+        for (Thread t : slist) {\n+            t.join(1000);\n+            System.err.println(\"released: \" + t.getName());\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTParallel.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies sequence of used NST entries from the cache queue.\n+ * @run main\/othervm MultiNSTSequence -Djdk.tls.server.newSessionTicketCount=2\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/**\n+ * This test verifies that multiple NSTs take the oldest PSK from the\n+ * QueueCacheEntry stored in the TLS Session Cache.\n+ *\n+ * Note: Beyond 9 iterations the PSK id verification code becomes complicated\n+ * with a QueueCacheEntry limit set to retain only the 10 newest entries.\n+ *\n+ * TLS 1.2 spec does not specify multiple NST behavior.\n+ *\/\n+\n+public class MultiNSTSequence {\n+\n+    static HexFormat hex = HexFormat.of();\n+    static final int ITERATIONS = 9;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> sb.append(a).append(\" \"));\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params\n+                              );\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTSequence\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            boolean pass = true;\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                int i;\n+                for (i = 0; i < ITERATIONS; i++) {\n+                    String svr = serverPSK.get(i);\n+                    String cli = clientPSK.get(i);\n+                    if (svr.regionMatches(svr.length() - 16, cli, cli.length() - 16, 16)) {\n+                        System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                    } else {\n+                        System.out.println(\"entry \" + (i + 1) + \" server and client PSK didn't match:\");\n+                        System.out.println(\"  server: \" + svr);\n+                        System.out.println(\"  client: \" + cli);\n+                        pass = false;\n+                    }\n+                }\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Server and Client PSK usage order is not\" +\n+                    \" the same.\");\n+                pass = false;\n+            }\n+\n+            if (!pass) {\n+                throw new Exception(\"Test failed: \" + params);\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Initial connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+\n+        SSLSession initialSession = initial.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  Resume client\");\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            SSLSession r = new TLSBase.Client(initial).connect().getSession();\n+            StringBuilder sb = new StringBuilder(100);\n+            sb.append(\"Iteration: \").append(i);\n+            sb.append(\"\\tid = \").append(hex.formatHex(r.getId()));\n+            sb.append(\"\\tsession = \").append(r);\n+            System.out.println(sb);\n+            if (!initialSession.toString().equalsIgnoreCase(r.toString())) {\n+                throw new Exception(\"Resumed session did not match\");\n+            }\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTSequence.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -31,0 +31,5 @@\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n@@ -38,0 +43,2 @@\n+import static org.testng.Assert.assertFalse;\n+import org.testng.annotations.BeforeMethod;\n@@ -39,1 +46,0 @@\n-@Test\n@@ -56,0 +62,1 @@\n+    @Test\n@@ -63,0 +70,1 @@\n+    @Test\n@@ -71,0 +79,1 @@\n+    @Test\n@@ -121,0 +130,45 @@\n+    @Test\n+    public void testRunShutdownHooks() throws IOException {\n+        Path temporary = Paths.get(\"temp\");\n+        Files.newOutputStream(temporary).close();\n+        assertEval(\"import java.io.*;\");\n+        assertEval(\"import java.nio.file.*;\");\n+        assertEval(\"\"\"\n+                        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+                            try {\n+                                Files.delete(Paths.get(\"$TEMPORARY\"));\n+                            } catch (IOException ex) {\n+                                \/\/ignored\n+                            }\n+                        }))\n+                        \"\"\".replace(\"$TEMPORARY\", temporary.toAbsolutePath()\n+                                                           .toString()\n+                                                           .replace(\"\\\\\", \"\\\\\\\\\")));\n+        getState().close();\n+        assertFalse(Files.exists(temporary));\n+    }\n+\n+    private Method currentTestMethod;\n+\n+    @BeforeMethod\n+    public void setUp(Method testMethod) {\n+        currentTestMethod = testMethod;\n+        super.setUp();\n+    }\n+\n+    @BeforeMethod\n+    public void setUp() {\n+    }\n+\n+    @Override\n+    public void setUp(Consumer<JShell.Builder> bc) {\n+        Consumer<JShell.Builder> augmentedBuilder = switch (currentTestMethod.getName()) {\n+            case \"testRunShutdownHooks\" -> builder -> {\n+                builder.executionEngine(Presets.TEST_STANDARD_EXECUTION);\n+                bc.accept(builder);\n+            };\n+            default -> bc;\n+        };\n+        super.setUp(augmentedBuilder);\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/ShutdownTest.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8338301\n+ * @summary Verify error recovery and reporting related to implicitly declared classes\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ErrorRecovery\n+*\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.JavaTask;\n+import toolbox.Task;\n+import toolbox.Task.OutputKind;\n+import toolbox.ToolBox;\n+\n+public class ErrorRecovery extends TestRunner {\n+\n+    private static final String SOURCE_VERSION = System.getProperty(\"java.specification.version\");\n+    private ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new ErrorRecovery().runTests();\n+    }\n+\n+    ErrorRecovery() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testMethodNoReturnType(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     main() {}\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> log = new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(OutputKind.DIRECT);\n+        List<String> expected = List.of(\n+            \"Test.java:1:1: compiler.err.invalid.meth.decl.ret.type.req\",\n+            \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+            \"- compiler.note.preview.recompile\",\n+            \"1 error\"\n+        );\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+    }\n+\n+    @Test\n+    public void testStatement(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     if (true) {int var = 0;}\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> log = new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"-XDshould-stop.at=FLOW\",\n+                     \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(OutputKind.DIRECT);\n+        List<String> expected = List.of(\n+            \"Test.java:1:1: compiler.err.statement.not.expected\",\n+            \"1 error\"\n+        );\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+    }\n+\n+    @Test\n+    public void testExtraSemi(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     class C {};\n+                     void main() {};\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+    }\n+\n+    @Test\n+    public void testVeryBroken(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     \"neither-of-class-method-file-statement\"\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> log;\n+        List<String> expected;\n+\n+        log = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\",\n+                        \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+        expected = List.of(\n+                \"Test.java:1:1: compiler.err.class.method.or.field.expected\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+\n+        log = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+        expected = List.of(\n+                \"Test.java:1:1: compiler.err.expected4: class, interface, enum, record\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+\n+        log = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\",\n+                         \"--release\", \"17\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+        expected = List.of(\n+                \"Test.java:1:1: compiler.err.expected4: class, interface, enum, record\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ErrorRecovery.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.class.method.or.field.expected\n+\/\/ options: --enable-preview --source ${jdk.version}\n+\n+\"neither-of-class-method-file-statement\"\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ClassMethodOrFieldExpected.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976 8324859\n@@ -2486,0 +2486,531 @@\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion1() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              return true;\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             return true;\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion2() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }                       \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion2: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion3() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion3: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion4() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          }\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion4: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion5() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test(String,\n+                      }\n+                      class T {}\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:38:compiler.err.expected\",\n+                             \"4:1:compiler.err.illegal.start.of.type\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test(String <error>, (ERROR: ) <error>);\n+                     }\n+                     class T {\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion6() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          private Object testMethod(final String arg1 final String arg2) {\n+                              return null;\n+                          }\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:48:compiler.err.expected3\",\n+                             \"3:66:compiler.err.expected\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         private Object testMethod(final String arg1);\n+                         final String arg2;\n+                         {\n+                             return null;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion7() throws IOException {\n+        \/\/after 'default' attribute value, only semicolon (';') is expected,\n+        \/\/not left brace ('{'):\n+        String code = \"\"\"\n+                      package tests;\n+                      public @interface A {\n+                          public String value() default \"\"\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:37:compiler.err.expected\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public @interface A {\n+                         \\n\\\n+                         public String value() default \"\";\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion10() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              String s = \"\";\n+                              return s.isEmpty();\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             String s = \"\";\n+                             return s.isEmpty();\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion11() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          String s = \"\"; \/\/field declaration\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         String s = \"\";\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion12() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              final String s = \"\";\n+                              return s.isEmpty();\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             final String s = \"\";\n+                             return s.isEmpty();\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion13() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          final String s = \"\"; \/\/field declaration?\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         final String s = \"\";\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion14() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              String s = \"\";\n+                              s.length();\n+                              if (true); \/\/force parse as block\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\",\n+                             \"7:5:compiler.err.illegal.start.of.expr\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             String s = \"\";\n+                             s.length();\n+                             if (true) ;\n+                             (ERROR: );\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":532,"deletions":1,"binary":false,"changes":533,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301580 8322159 8333107 8332230\n+ * @bug 8301580 8322159 8333107 8332230 8338678\n@@ -37,0 +37,5 @@\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n@@ -38,0 +43,1 @@\n+import java.util.IdentityHashMap;\n@@ -39,0 +45,1 @@\n+import java.util.Map;\n@@ -40,0 +47,7 @@\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.tools.Diagnostic;\n@@ -237,0 +251,76 @@\n+    @Test\n+    public void testParameterizedErroneousType() throws Exception {\n+        String code = \"\"\"\n+                      public class C {\n+                          Undefined1<Undefined2, Undefined3> variable1;\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .callback(task -> {\n+                    task.addTaskListener(new TaskListener() {\n+                        @Override\n+                        public void finished(TaskEvent e) {\n+                            Trees trees = Trees.instance(task);\n+\n+                            if (e.getKind() == TaskEvent.Kind.ANALYZE) {\n+                                new TreePathScanner<Void, Void>() {\n+                                    @Override\n+                                    public Void visitVariable(VariableTree tree, Void p) {\n+                                        VariableElement var = (VariableElement) trees.getElement(getCurrentPath());\n+\n+                                        trees.printMessage(Diagnostic.Kind.NOTE, type2String(var.asType()), tree, e.getCompilationUnit());\n+\n+                                        return super.visitVariable(tree, p);\n+                                    }\n+                                }.scan(e.getCompilationUnit(), null);\n+                            }\n+                        }\n+                        Map<Element, Integer> identityRename = new IdentityHashMap<>();\n+                        String type2String(TypeMirror type) {\n+                            StringBuilder result = new StringBuilder();\n+\n+                            result.append(type.getKind());\n+                            result.append(\":\");\n+                            result.append(type.toString());\n+\n+                            if (type.getKind() == TypeKind.DECLARED ||\n+                                type.getKind() == TypeKind.ERROR) {\n+                                DeclaredType dt = (DeclaredType) type;\n+                                Element el = task.getTypes().asElement(dt);\n+                                result.append(\":\");\n+                                result.append(el.toString());\n+                                if (!dt.getTypeArguments().isEmpty()) {\n+                                    result.append(dt.getTypeArguments()\n+                                                    .stream()\n+                                                    .map(tm -> type2String(tm))\n+                                                    .collect(Collectors.joining(\", \", \"<\", \">\")));\n+                                }\n+                            } else {\n+                                throw new AssertionError(type.getKind().name());\n+                            }\n+\n+                            return result.toString();\n+                        }\n+                    });\n+                })\n+                .run(Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"C.java:2:5: compiler.err.cant.resolve.location: kindname.class, Undefined1, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:16: compiler.err.cant.resolve.location: kindname.class, Undefined2, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:28: compiler.err.cant.resolve.location: kindname.class, Undefined3, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:40: compiler.note.proc.messager: ERROR:Undefined1<Undefined2,Undefined3>:Undefined1<ERROR:Undefined2:Undefined2, ERROR:Undefined3:Undefined3>\",\n+                \"3 errors\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":91,"deletions":1,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class TestFill {\n+\n+    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\n+            \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\n+            \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\n+            \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\",\n+            \"32\", \"128\", \"256\", \"384\", \"511\", \"512\"})\n+    public int ELEM_SIZE;\n+\n+    byte[] array;\n+    MemorySegment heapSegment;\n+    MemorySegment nativeSegment;\n+    MemorySegment unalignedSegment;\n+    ByteBuffer buffer;\n+\n+    @Setup\n+    public void setup() {\n+        array = new byte[ELEM_SIZE];\n+        heapSegment = MemorySegment.ofArray(array);\n+        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE, 8);\n+        unalignedSegment = Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n+        buffer = ByteBuffer.wrap(array);\n+    }\n+\n+    @Benchmark\n+    public void arrays_fill() {\n+        Arrays.fill(array, (byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void heap_segment_fill() {\n+        heapSegment.fill((byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void native_segment_fill() {\n+        nativeSegment.fill((byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void unaligned_segment_fill() {\n+        unalignedSegment.fill((byte) 0);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestFill.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.classfile.TypeKind;\n@@ -145,1 +144,1 @@\n-                      .withCode(codeb -> codeb.loadLocal(TypeKind.ReferenceType, 0)\n+                      .withCode(codeb -> codeb.loadLocal(REFERENCE, 0)\n@@ -147,1 +146,1 @@\n-                                              .return_(VoidType)\n+                                              .return_(VOID)\n@@ -193,1 +192,1 @@\n-                          mb -> mb.withCode(codeb -> codeb.loadLocal(ReferenceType, 0)\n+                          mb -> mb.withCode(codeb -> codeb.loadLocal(REFERENCE, 0)\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}