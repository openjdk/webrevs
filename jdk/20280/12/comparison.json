{"files":[{"patch":"@@ -150,0 +150,3 @@\n+JNIEXPORT jint JNICALL\n+JVM_HostActiveProcessorCount(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+JVM_ENTRY_NO_ENV(jint, JVM_HostActiveProcessorCount(void))\n+#ifdef LINUX\n+  return os::Linux::active_processor_count();\n+#endif\n+  return os::active_processor_count();\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+    @Override\n@@ -203,2 +204,3 @@\n-    private static native long getTotalMemorySize0();\n-    private static native long getTotalSwapSize0();\n+    public static native long getTotalMemorySize0();\n+    public static native long getTotalSwapSize0();\n+    public static native int getTotalCpuCount0();\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,0 +47,5 @@\n+    \/**\n+     * The controller path\n+     *\n+     * @return The path to the interface files for this controller.\n+     *\/\n@@ -49,0 +54,17 @@\n+    public void setPath(String cgroupPath);\n+\n+    public String getCgroupPath();\n+\n+    \/**\n+     * Some systems don't have the interface files at the leaf of the controller\n+     * path. That is, the hierarchy up to the root needs to get traversed looking\n+     * for a lower limit at any of the paths. This is not needed for OCI containers\n+     * which have the limits set at the leaf.\n+     *\n+     * @return {@code true} for any controller that needs adjusting, {@code false}\n+     *         otherwise.\n+     *\/\n+    public default boolean needsAdjustment() {\n+        return false;\n+    }\n+\n@@ -62,1 +84,3 @@\n-        if (controller == null) return null;\n+        if (controller == null) {\n+            return null;\n+        }\n@@ -125,1 +149,3 @@\n-        if (strval == null) return defaultRetval;\n+        if (strval == null) {\n+            return defaultRetval;\n+        }\n@@ -140,1 +166,3 @@\n-        if (strval == null) return defaultRetval;\n+        if (strval == null) {\n+            return defaultRetval;\n+        }\n@@ -162,1 +190,3 @@\n-        if (controller == null) return defaultRetval;\n+        if (controller == null) {\n+            return defaultRetval;\n+        }\n@@ -190,1 +220,3 @@\n-        if (range == null || EMPTY_STR.equals(range)) return null;\n+        if (range == null || EMPTY_STR.equals(range)) {\n+            return null;\n+        }\n@@ -238,1 +270,3 @@\n-        if (strval == null) return retval;\n+        if (strval == null) {\n+            return retval;\n+        }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemController.java","additions":40,"deletions":6,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+public interface CgroupSubsystemCpuController extends CgroupSubsystemController {\n+\n+    public long getCpuPeriod();\n+\n+    public long getCpuQuota();\n+\n+    public long getCpuShares();\n+\n+    public long getCpuNumPeriods();\n+\n+    public long getCpuNumThrottled();\n+\n+    public long getCpuThrottledTime();\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemCpuController.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -39,1 +39,0 @@\n-import java.util.Objects;\n@@ -114,3 +113,1 @@\n-            \/\/ For unified it doesn't matter which controller we pick.\n-            CgroupInfo anyController = infos.values().iterator().next();\n-            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance(Objects.requireNonNull(anyController));\n+            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance(infos);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+public interface CgroupSubsystemMemoryController extends CgroupSubsystemController {\n+\n+    public long getMemoryLimit(long physicalMemory);\n+\n+    public long getMemoryUsage();\n+\n+    public long getTcpMemoryUsage();\n+\n+    public long getMemoryAndSwapLimit(long hostMemory, long hostSwap);\n+\n+    public long getMemoryAndSwapUsage();\n+\n+    public long getMemorySoftLimit(long hostMemory);\n+\n+    public long getMemoryFailCount();\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemMemoryController.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -57,1 +57,1 @@\n-        if (x instanceof IOException)\n+        if (x instanceof IOException) {\n@@ -59,1 +59,2 @@\n-        if (x instanceof RuntimeException)\n+        }\n+        if (x instanceof RuntimeException) {\n@@ -61,1 +62,2 @@\n-        if (x instanceof Error)\n+        }\n+        if (x instanceof Error) {\n@@ -63,0 +65,1 @@\n+        }\n@@ -92,0 +95,78 @@\n+\n+    \/**\n+     * Calculate the processor count based on the host CPUs and set cpu quota.\n+     *\n+     * @param cpu      The cpu controller to read the quota values from.\n+     * @param hostCpus The physical host CPUs\n+     * @return The minimum of host CPUs and the configured cpu quota, never\n+     *         negative.\n+     *\/\n+    static int processorCount(CgroupSubsystemCpuController cpu, int hostCpus) {\n+        int limit = hostCpus;\n+        long quota = cpu.getCpuQuota();\n+        long period = cpu.getCpuPeriod();\n+        int quotaCount = 0;\n+\n+        if (quota > CgroupSubsystem.LONG_RETVAL_UNLIMITED && period > 0) {\n+            quotaCount = (int) Math.ceilDiv(quota, period);\n+        }\n+        if (quotaCount != 0) {\n+            limit = quotaCount;\n+        }\n+        return Math.min(hostCpus, limit);\n+    }\n+\n+    public static void adjustController(CgroupSubsystemCpuController cpu) {\n+        if (!cpu.needsAdjustment()) {\n+            return;\n+        }\n+        String origCgroupPath = cpu.getCgroupPath();\n+        Path workingPath = Path.of(origCgroupPath);\n+        int hostCpus = CgroupMetrics.getTotalCpuCount0();\n+        int lowestLimit = hostCpus;\n+\n+        int limit = CgroupUtil.processorCount(cpu, hostCpus);\n+        String lowestPath = origCgroupPath;\n+        while ((workingPath = workingPath.getParent()) != null) {\n+            cpu.setPath(workingPath.toString()); \/\/ adjust path\n+            limit = CgroupUtil.processorCount(cpu, hostCpus);\n+            if (limit < lowestLimit) {\n+                lowestLimit = limit;\n+                lowestPath = workingPath.toString();\n+            }\n+        }\n+        if (lowestLimit == hostCpus) {\n+            \/\/ No lower limit found adjust to original path\n+            cpu.setPath(origCgroupPath);\n+        } else {\n+            \/\/ Adjust controller to lowest observed limit path\n+            cpu.setPath(lowestPath);\n+        }\n+    }\n+\n+    public static void adjustController(CgroupSubsystemMemoryController memory) {\n+        if (!memory.needsAdjustment()) {\n+            return;\n+        }\n+        long physicalMemory = CgroupMetrics.getTotalMemorySize0();\n+        String origCgroupPath = memory.getCgroupPath();\n+        Path workingPath = Path.of(origCgroupPath);\n+        long limit = memory.getMemoryLimit(physicalMemory);\n+        long lowestLimit = limit < 0 ? physicalMemory : limit;\n+        String lowestPath = origCgroupPath;\n+        while ((workingPath = workingPath.getParent()) != null) {\n+            memory.setPath(workingPath.toString()); \/\/ adjust path\n+            limit = memory.getMemoryLimit(physicalMemory);\n+            if (limit > 0 && limit < lowestLimit) {\n+                lowestLimit = limit;\n+                lowestPath = workingPath.toString();\n+            }\n+        }\n+        if (lowestLimit < physicalMemory) {\n+            \/\/ Found a lower limit, adjust controller to that path\n+            memory.setPath(lowestPath);\n+        } else {\n+            \/\/ No lower limit found adjust to original path\n+            memory.setPath(origCgroupPath);\n+        }\n+    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupUtil.java","additions":84,"deletions":3,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemCpuController;\n+\n+public class CgroupV1CpuSubSystemController extends CgroupV1SubsystemController\n+        implements CgroupSubsystemCpuController {\n+\n+    public CgroupV1CpuSubSystemController(String root, String mountPoint) {\n+        super(root, mountPoint);\n+    }\n+\n+    @Override\n+    public long getCpuPeriod() {\n+        return CgroupV1Subsystem.getLongValue(this, \"cpu.cfs_period_us\");\n+    }\n+\n+    @Override\n+    public long getCpuQuota() {\n+        return CgroupV1Subsystem.getLongValue(this, \"cpu.cfs_quota_us\");\n+    }\n+\n+    @Override\n+    public long getCpuShares() {\n+        long retval = CgroupV1Subsystem.getLongValue(this, \"cpu.shares\");\n+        if (retval == 0 || retval == 1024) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        } else {\n+            return retval;\n+        }\n+    }\n+\n+    @Override\n+    public long getCpuNumPeriods() {\n+        return CgroupV1SubsystemController.getLongEntry(this, \"cpu.stat\", \"nr_periods\");\n+    }\n+\n+    @Override\n+    public long getCpuNumThrottled() {\n+        return CgroupV1SubsystemController.getLongEntry(this, \"cpu.stat\", \"nr_throttled\");\n+    }\n+\n+    @Override\n+    public long getCpuThrottledTime() {\n+        return CgroupV1SubsystemController.getLongEntry(this, \"cpu.stat\", \"throttled_time\");\n+    }\n+\n+    @Override\n+    public boolean needsAdjustment() {\n+        \/\/ Container frameworks have them equal; we skip adjustment for them\n+        return !getRoot().equals(getCgroupPath());\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1CpuSubSystemController.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -28,1 +28,5 @@\n-public class CgroupV1MemorySubSystemController extends CgroupV1SubsystemController {\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemMemoryController;\n+\n+public class CgroupV1MemorySubSystemController extends CgroupV1SubsystemController\n+        implements CgroupSubsystemMemoryController {\n@@ -30,1 +34,0 @@\n-    private boolean hierarchical;\n@@ -37,2 +40,2 @@\n-    boolean isHierarchical() {\n-        return hierarchical;\n+    private boolean isSwapEnabled() {\n+        return swapenabled;\n@@ -41,2 +44,4 @@\n-    void setHierarchical(boolean hierarchical) {\n-        this.hierarchical = hierarchical;\n+    private void setSwapEnabled() {\n+        long memswBytes = CgroupV1Subsystem.getLongValue(this, \"memory.memsw.limit_in_bytes\");\n+        long swappiness = CgroupV1Subsystem.getLongValue(this, \"memory.swappiness\");\n+        this.swapenabled = (memswBytes > 0 && swappiness > 0);\n@@ -45,2 +50,105 @@\n-    boolean isSwapEnabled() {\n-        return swapenabled;\n+    @Override\n+    public void setPath(String cgroupPath) {\n+        super.setPath(cgroupPath);\n+        setSwapEnabled();\n+    }\n+\n+    @Override\n+    public long getMemoryLimit(long physicalMemory) {\n+        long limit = CgroupV1Subsystem.getLongValue(this, \"memory.limit_in_bytes\");\n+        \/\/ Limits on cg v1 might return large numbers. Bound above by the\n+        \/\/ physical limit of the host. If so, treat it as unlimited.\n+        if (limit >= physicalMemory) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        return limit;\n+    }\n+\n+    @Override\n+    public long getMemoryUsage() {\n+        return CgroupV1Subsystem.getLongValue(this, \"memory.usage_in_bytes\");\n+    }\n+\n+    @Override\n+    public long getTcpMemoryUsage() {\n+        return CgroupV1Subsystem.getLongValue(this, \"memory.kmem.tcp.usage_in_bytes\");\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapLimit(long hostMemory, long hostSwap) {\n+        if (!isSwapEnabled()) {\n+            return getMemoryLimit(hostMemory);\n+        }\n+        long retval = CgroupV1Subsystem.getLongValue(this, \"memory.memsw.limit_in_bytes\");\n+        long upperBound = hostMemory + hostSwap;\n+        \/\/ The limit value for cg v1 might be a large number when there is no\n+        \/\/ limit. Ensure the limit doesn't exceed the physical bounds.\n+        if (retval >= upperBound) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        return retval;\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapUsage() {\n+        if (!isSwapEnabled()) {\n+            return getMemoryUsage();\n+        }\n+        return CgroupV1Subsystem.getLongValue(this, \"memory.memsw.usage_in_bytes\");\n+    }\n+\n+    @Override\n+    public long getMemorySoftLimit(long hostMemory) {\n+        long softLimit = CgroupV1Subsystem.getLongValue(this, \"memory.soft_limit_in_bytes\");\n+        if (softLimit >= hostMemory) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        return softLimit;\n+    }\n+\n+    @Override\n+    public long getMemoryFailCount() {\n+        return CgroupV1Subsystem.getLongValue(this, \"memory.failcnt\");\n+    }\n+\n+    public long getMemoryMaxUsage() {\n+        return CgroupV1Subsystem.getLongValue(this, \"memory.max_usage_in_bytes\");\n+    }\n+\n+    public long getMemoryAndSwapMaxUsage() {\n+        if (!isSwapEnabled()) {\n+            return getMemoryMaxUsage();\n+        }\n+        return CgroupV1Subsystem.getLongValue(this, \"memory.memsw.max_usage_in_bytes\");\n+    }\n+\n+    public long getMemoryAndSwapFailCount() {\n+        if (!isSwapEnabled()) {\n+            return getMemoryFailCount();\n+        }\n+        return CgroupV1Subsystem.getLongValue(this, \"memory.memsw.failcnt\");\n+    }\n+\n+    public long getKernelMemoryFailCount() {\n+        return CgroupV1Subsystem.getLongValue(this, \"memory.kmem.failcnt\");\n+    }\n+\n+    public long getKernelMemoryMaxUsage() {\n+        return CgroupV1Subsystem.getLongValue(this, \"memory.kmem.max_usage_in_bytes\");\n+    }\n+\n+    public long getKernelMemoryUsage() {\n+        return CgroupV1Subsystem.getLongValue(this, \"memory.kmem.usage_in_bytes\");\n+    }\n+\n+    public long getTcpMemoryFailCount() {\n+        return CgroupV1Subsystem.getLongValue(this, \"memory.kmem.tcp.failcnt\");\n+    }\n+\n+    public long getTcpMemoryMaxUsage() {\n+        return CgroupV1Subsystem.getLongValue(this, \"memory.kmem.tcp.max_usage_in_bytes\");\n+    }\n+\n+    public Boolean isMemoryOOMKillEnabled() {\n+        long val = CgroupV1SubsystemController.getLongEntry(this, \"memory.oom_control\", \"oom_kill_disable\");\n+        return (val == 0);\n@@ -49,2 +157,4 @@\n-    void setSwapEnabled(boolean swapenabled) {\n-        this.swapenabled = swapenabled;\n+    @Override\n+    public boolean needsAdjustment() {\n+        \/\/ Container frameworks have them equal; we skip adjustment for them\n+        return !getRoot().equals(getCgroupPath());\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1MemorySubSystemController.java","additions":120,"deletions":10,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.function.Supplier;\n@@ -31,0 +32,1 @@\n+import jdk.internal.platform.CgroupMetrics;\n@@ -33,0 +35,1 @@\n+import jdk.internal.platform.CgroupUtil;\n@@ -37,1 +40,1 @@\n-    private CgroupV1SubsystemController cpu;\n+    private CgroupV1CpuSubSystemController cpu;\n@@ -85,4 +88,1 @@\n-                    boolean isHierarchial = getHierarchical(controller);\n-                    controller.setHierarchical(isHierarchial);\n-                    boolean isSwapEnabled = getSwapEnabled(controller);\n-                    controller.setSwapEnabled(isSwapEnabled);\n+                    CgroupUtil.adjustController(controller);\n@@ -114,1 +114,1 @@\n-                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    CgroupV1CpuSubSystemController controller = new CgroupV1CpuSubSystemController(info.getMountRoot(), info.getMountPoint());\n@@ -116,0 +116,1 @@\n+                    CgroupUtil.adjustController(controller);\n@@ -152,12 +153,0 @@\n-    private static boolean getSwapEnabled(CgroupV1MemorySubSystemController controller) {\n-        long memswBytes = getLongValue(controller, \"memory.memsw.limit_in_bytes\");\n-        long swappiness = getLongValue(controller, \"memory.swappiness\");\n-        return (memswBytes > 0 && swappiness > 0);\n-     }\n-\n-\n-    private static boolean getHierarchical(CgroupV1MemorySubSystemController controller) {\n-        long hierarchical = getLongValue(controller, \"memory.use_hierarchy\");\n-        return hierarchical > 0;\n-    }\n-\n@@ -168,1 +157,1 @@\n-    private void setCpuController(CgroupV1SubsystemController cpu) {\n+    private void setCpuController(CgroupV1CpuSubSystemController cpu) {\n@@ -188,1 +177,1 @@\n-    private static long getLongValue(CgroupSubsystemController controller,\n+    static long getLongValue(CgroupSubsystemController controller,\n@@ -196,0 +185,18 @@\n+    \/**\n+     * Accounts for optional controllers. If the controller is null the provided\n+     * supplier will never be called.\n+     *\n+     * @param controller The controller to check for null\n+     * @param supplier The supplier using the controller\n+     * @return -1 (unlimited) when the controller is null, otherwise the supplier\n+     *         value.\n+     *\/\n+    private static long valueOrUnlimited(CgroupSubsystemController controller,\n+                                         Supplier<Long> supplier) {\n+        if (controller == null) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        return supplier.get();\n+    }\n+\n+    @Override\n@@ -205,0 +212,1 @@\n+    @Override\n@@ -209,0 +217,1 @@\n+    @Override\n@@ -223,0 +232,1 @@\n+    @Override\n@@ -227,0 +237,1 @@\n+    @Override\n@@ -237,0 +248,1 @@\n+    @Override\n@@ -238,1 +250,1 @@\n-        return getLongValue(cpu, \"cpu.cfs_period_us\");\n+        return valueOrUnlimited(cpu, () -> cpu.getCpuPeriod());\n@@ -241,0 +253,1 @@\n+    @Override\n@@ -242,1 +255,1 @@\n-        return getLongValue(cpu, \"cpu.cfs_quota_us\");\n+        return valueOrUnlimited(cpu, () -> cpu.getCpuQuota());\n@@ -245,0 +258,1 @@\n+    @Override\n@@ -246,5 +260,1 @@\n-        long retval = getLongValue(cpu, \"cpu.shares\");\n-        if (retval == 0 || retval == 1024)\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n-        else\n-            return retval;\n+        return valueOrUnlimited(cpu, () -> cpu.getCpuShares());\n@@ -253,0 +263,1 @@\n+    @Override\n@@ -254,1 +265,1 @@\n-        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"nr_periods\");\n+        return valueOrUnlimited(cpu, () -> cpu.getCpuNumPeriods());\n@@ -257,0 +268,1 @@\n+    @Override\n@@ -258,1 +270,1 @@\n-        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"nr_throttled\");\n+        return valueOrUnlimited(cpu, () -> cpu.getCpuNumThrottled());\n@@ -261,0 +273,1 @@\n+    @Override\n@@ -262,1 +275,1 @@\n-        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"throttled_time\");\n+        return valueOrUnlimited(cpu, () -> cpu.getCpuThrottledTime());\n@@ -265,0 +278,1 @@\n+    @Override\n@@ -274,0 +288,1 @@\n+    @Override\n@@ -278,0 +293,1 @@\n+    @Override\n@@ -282,0 +298,1 @@\n+    @Override\n@@ -286,0 +303,1 @@\n+    @Override\n@@ -290,0 +308,1 @@\n+    @Override\n@@ -294,0 +313,1 @@\n+    @Override\n@@ -304,1 +324,1 @@\n-\n+    @Override\n@@ -306,1 +326,1 @@\n-        return getLongValue(memory, \"memory.failcnt\");\n+        return valueOrUnlimited(memory, () -> memory.getMemoryFailCount());\n@@ -309,0 +329,1 @@\n+    @Override\n@@ -310,12 +331,2 @@\n-        long retval = getLongValue(memory, \"memory.limit_in_bytes\");\n-        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memory_limit\";\n-                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match);\n-            }\n-        }\n-        return CgroupV1SubsystemController.longValOrUnlimited(retval);\n+        Supplier<Long> limitSupplier = () -> memory.getMemoryLimit(CgroupMetrics.getTotalMemorySize0());\n+        return valueOrUnlimited(memory, limitSupplier);\n@@ -324,0 +335,1 @@\n+    @Override\n@@ -325,1 +337,1 @@\n-        return getLongValue(memory, \"memory.max_usage_in_bytes\");\n+        return valueOrUnlimited(memory, () -> memory.getMemoryMaxUsage());\n@@ -328,0 +340,1 @@\n+    @Override\n@@ -329,1 +342,1 @@\n-        return getLongValue(memory, \"memory.usage_in_bytes\");\n+        return valueOrUnlimited(memory, () -> memory.getMemoryUsage());\n@@ -332,2 +345,3 @@\n-    public long getKernelMemoryFailCount() {\n-        return getLongValue(memory, \"memory.kmem.failcnt\");\n+    @Override\n+    public long getTcpMemoryUsage() {\n+        return valueOrUnlimited(memory, () -> memory.getTcpMemoryUsage());\n@@ -336,2 +350,3 @@\n-    public long getKernelMemoryMaxUsage() {\n-        return getLongValue(memory, \"memory.kmem.max_usage_in_bytes\");\n+    @Override\n+    public long getMemoryAndSwapFailCount() {\n+        return valueOrUnlimited(memory, () -> memory.getMemoryAndSwapFailCount());\n@@ -340,2 +355,8 @@\n-    public long getKernelMemoryUsage() {\n-        return getLongValue(memory, \"memory.kmem.usage_in_bytes\");\n+    @Override\n+    public long getMemoryAndSwapLimit() {\n+        Supplier<Long> limitSupplier = () -> {\n+            long hostMem = CgroupMetrics.getTotalMemorySize0();\n+            long hostSwap = CgroupMetrics.getTotalSwapSize0();\n+            return memory.getMemoryAndSwapLimit(hostMem, hostSwap);\n+        };\n+        return valueOrUnlimited(memory, limitSupplier);\n@@ -344,2 +365,3 @@\n-    public long getTcpMemoryFailCount() {\n-        return getLongValue(memory, \"memory.kmem.tcp.failcnt\");\n+    @Override\n+    public long getMemoryAndSwapMaxUsage() {\n+        return valueOrUnlimited(memory, () -> memory.getMemoryAndSwapMaxUsage());\n@@ -348,2 +370,3 @@\n-    public long getTcpMemoryMaxUsage() {\n-        return getLongValue(memory, \"memory.kmem.tcp.max_usage_in_bytes\");\n+    @Override\n+    public long getMemoryAndSwapUsage() {\n+        return valueOrUnlimited(memory, () -> memory.getMemoryAndSwapUsage());\n@@ -352,2 +375,3 @@\n-    public long getTcpMemoryUsage() {\n-        return getLongValue(memory, \"memory.kmem.tcp.usage_in_bytes\");\n+    @Override\n+    public long getKernelMemoryFailCount() {\n+        return valueOrUnlimited(memory, () -> memory.getKernelMemoryFailCount());\n@@ -356,5 +380,3 @@\n-    public long getMemoryAndSwapFailCount() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryFailCount();\n-        }\n-        return getLongValue(memory, \"memory.memsw.failcnt\");\n+    @Override\n+    public long getKernelMemoryMaxUsage() {\n+        return valueOrUnlimited(memory, () -> memory.getKernelMemoryMaxUsage());\n@@ -363,16 +385,3 @@\n-    public long getMemoryAndSwapLimit() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryLimit();\n-        }\n-        long retval = getLongValue(memory, \"memory.memsw.limit_in_bytes\");\n-        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memsw_limit\";\n-                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match);\n-            }\n-        }\n-        return CgroupV1SubsystemController.longValOrUnlimited(retval);\n+    @Override\n+    public long getKernelMemoryUsage() {\n+        return valueOrUnlimited(memory, () -> memory.getKernelMemoryUsage());\n@@ -381,5 +390,3 @@\n-    public long getMemoryAndSwapMaxUsage() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryMaxUsage();\n-        }\n-        return getLongValue(memory, \"memory.memsw.max_usage_in_bytes\");\n+    @Override\n+    public long getTcpMemoryFailCount() {\n+        return valueOrUnlimited(memory, () -> memory.getTcpMemoryFailCount());\n@@ -388,5 +395,3 @@\n-    public long getMemoryAndSwapUsage() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryUsage();\n-        }\n-        return getLongValue(memory, \"memory.memsw.usage_in_bytes\");\n+    @Override\n+    public long getTcpMemoryMaxUsage() {\n+        return valueOrUnlimited(memory, () -> memory.getTcpMemoryMaxUsage());\n@@ -395,0 +400,1 @@\n+    @Override\n@@ -396,2 +402,1 @@\n-        long val = CgroupV1SubsystemController.getLongEntry(memory, \"memory.oom_control\", \"oom_kill_disable\");\n-        return (val == 0);\n+        return memory == null ? false : memory.isMemoryOOMKillEnabled();\n@@ -400,0 +405,1 @@\n+    @Override\n@@ -401,1 +407,1 @@\n-        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.soft_limit_in_bytes\"));\n+        return valueOrUnlimited(memory, () -> memory.getMemorySoftLimit(CgroupMetrics.getTotalMemorySize0()));\n@@ -407,0 +413,1 @@\n+    @Override\n@@ -412,0 +419,1 @@\n+    @Override\n@@ -421,0 +429,1 @@\n+    @Override\n@@ -425,0 +434,1 @@\n+    @Override\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":102,"deletions":92,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -36,3 +36,4 @@\n-    String root;\n-    String mountPoint;\n-    String path;\n+    private final String root;\n+    private final String mountPoint;\n+    private String path;\n+    private String cgroupPath;\n@@ -45,0 +46,1 @@\n+    @Override\n@@ -46,0 +48,1 @@\n+        this.cgroupPath = cgroupPath;\n@@ -71,0 +74,9 @@\n+    @Override\n+    public String getCgroupPath() {\n+        return cgroupPath;\n+    }\n+\n+    protected String getRoot() {\n+        return root;\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv2;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.internal.platform.CgroupSubsystemCpuController;\n+\n+public class CgroupV2CpuSubSystemController extends CgroupV2SubsystemController\n+        implements CgroupSubsystemCpuController {\n+\n+    private static final String ROOT_PATH = \"\/\";\n+    private static final int PER_CPU_SHARES = 1024;\n+\n+    public CgroupV2CpuSubSystemController(String mountPath, String cgroupPath) {\n+        super(mountPath, cgroupPath);\n+    }\n+\n+    @Override\n+    public long getCpuPeriod() {\n+        return getFromCpuMax(1 \/* $PERIOD index *\/);\n+    }\n+\n+    @Override\n+    public long getCpuQuota() {\n+        return getFromCpuMax(0 \/* $MAX index *\/);\n+    }\n+\n+    @Override\n+    public long getCpuShares() {\n+        long sharesRaw = CgroupV2Subsystem.getLongVal(this, \"cpu.weight\");\n+        if (sharesRaw == 100 || sharesRaw <= 0) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        int shares = (int)sharesRaw;\n+        \/\/ CPU shares (OCI) value needs to get translated into\n+        \/\/ a proper Cgroups v2 value. See:\n+        \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+        \/\/\n+        \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+        \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+        \/\/\n+        int x = 262142 * shares - 1;\n+        double frac = x\/9999.0;\n+        x = ((int)frac) + 2;\n+        if ( x <= PER_CPU_SHARES ) {\n+            return PER_CPU_SHARES; \/\/ mimic cgroups v1\n+        }\n+        int f = x\/PER_CPU_SHARES;\n+        int lower_multiple = f * PER_CPU_SHARES;\n+        int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+        int distance_lower = Math.max(lower_multiple, x) - Math.min(lower_multiple, x);\n+        int distance_upper = Math.max(upper_multiple, x) - Math.min(upper_multiple, x);\n+        x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+        return x;\n+    }\n+\n+    @Override\n+    public long getCpuNumPeriods() {\n+        return CgroupV2SubsystemController.getLongEntry(this, \"cpu.stat\", \"nr_periods\");\n+    }\n+\n+    @Override\n+    public long getCpuNumThrottled() {\n+        return CgroupV2SubsystemController.getLongEntry(this, \"cpu.stat\", \"nr_throttled\");\n+    }\n+\n+    @Override\n+    public long getCpuThrottledTime() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(this, \"cpu.stat\", \"throttled_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    private long getFromCpuMax(int tokenIdx) {\n+        String cpuMaxRaw = CgroupSubsystemController.getStringValue(this, \"cpu.max\");\n+        if (cpuMaxRaw == null) {\n+            \/\/ likely file not found\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        \/\/ $MAX $PERIOD\n+        String[] tokens = cpuMaxRaw.split(\"\\\\s+\");\n+        if (tokens.length != 2) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        String quota = tokens[tokenIdx];\n+        return CgroupSubsystem.limitFromString(quota);\n+    }\n+\n+    \/**\n+     * Implementations which use the cpu controller, but are cpuacct on cg v1\n+     *\/\n+\n+    public long getCpuUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(this, \"cpu.stat\", \"usage_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    public long getCpuUserUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(this, \"cpu.stat\", \"user_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    public long getCpuSystemUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(this, \"cpu.stat\", \"system_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public boolean needsAdjustment() {\n+        return !ROOT_PATH.equals(getCgroupPath());\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2CpuSubSystemController.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv2;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.internal.platform.CgroupSubsystemMemoryController;\n+\n+public class CgroupV2MemorySubSystemController extends CgroupV2SubsystemController implements CgroupSubsystemMemoryController {\n+\n+    private static final String ROOT_PATH = \"\/\";\n+    private static final long NO_SWAP = 0;\n+\n+    CgroupV2MemorySubSystemController(String mountPath, String cgroupPath) {\n+        super(mountPath, cgroupPath);\n+    }\n+\n+    @Override\n+    public long getMemoryLimit(long physicalMemory) {\n+        String strVal = CgroupSubsystemController.getStringValue(this, \"memory.max\");\n+        long limit = CgroupSubsystem.limitFromString(strVal);\n+        \/\/ Return unlimited if we already determined it as unlimited or if\n+        \/\/ the limit exceeds the host physical memory limit\n+        if (limit == CgroupSubsystem.LONG_RETVAL_UNLIMITED ||\n+            limit >= physicalMemory) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        return limit;\n+    }\n+\n+    @Override\n+    public long getMemoryUsage() {\n+        return CgroupV2Subsystem.getLongVal(this, \"memory.current\");\n+    }\n+\n+    \/**\n+     * Note that for cgroups v2 the actual limits set for swap and\n+     * memory live in two different files, memory.swap.max and memory.max\n+     * respectively. In order to properly report a cgroup v1 like\n+     * compound value we need to sum the two values. Setting a swap limit\n+     * without also setting a memory limit is not allowed.\n+     *\/\n+    @Override\n+    public long getMemoryAndSwapLimit(long hostMemory, long hostSwap) {\n+        String strVal = CgroupSubsystemController.getStringValue(this, \"memory.swap.max\");\n+        \/\/ We only get a null string when file memory.swap.max doesn't exist.\n+        \/\/ In that case we return the memory limit without any swap.\n+        if (strVal == null) {\n+            return getMemoryLimit(hostMemory);\n+        }\n+        long swapLimit = CgroupSubsystem.limitFromString(strVal);\n+        if (swapLimit >= 0) {\n+            long memoryLimit = getMemoryLimit(hostMemory);\n+            if (memoryLimit < 0) {\n+                \/\/ We have the case where the memory limit is larger than the\n+                \/\/ host memory size: swapLimit >= 0 && memoryLimit < 0\n+                \/\/ In that case reset the memory to the host memory for this\n+                \/\/ calculation\n+                memoryLimit = hostMemory;\n+            }\n+            long memSwapLimit = memoryLimit + swapLimit;\n+            long hostBound = hostMemory + hostSwap;\n+            \/\/ The limit must not exceed host values\n+            if (memSwapLimit >= hostBound) {\n+                return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            }\n+            return memSwapLimit;\n+        }\n+        return CgroupSubsystem.LONG_RETVAL_UNLIMITED; \/\/ unlimited swap case\n+    }\n+\n+    \/**\n+     * Note that for cgroups v2 the actual values set for swap usage and\n+     * memory usage live in two different files, memory.current and memory.swap.current\n+     * respectively. In order to properly report a cgroup v1 like\n+     * compound value we need to sum the two values. Setting a swap limit\n+     * without also setting a memory limit is not allowed.\n+     *\/\n+    @Override\n+    public long getMemoryAndSwapUsage() {\n+        long memoryUsage = getMemoryUsage();\n+        if (memoryUsage >= 0) {\n+            \/\/ If file memory.swap.current doesn't exist, only return the regular\n+            \/\/ memory usage (without swap). Thus, use default value of NO_SWAP.\n+            long swapUsage = CgroupV2Subsystem.getLongVal(this, \"memory.swap.current\", NO_SWAP);\n+            return memoryUsage + swapUsage;\n+        }\n+        return memoryUsage; \/\/ case of no memory limits\n+    }\n+\n+    @Override\n+    public long getMemorySoftLimit(long hostMemory) {\n+        String softLimitStr = CgroupSubsystemController.getStringValue(this, \"memory.low\");\n+        long softLimit = CgroupSubsystem.limitFromString(softLimitStr);\n+        \/\/ Avoid for the soft limit exceeding physical memory\n+        if (softLimit == CgroupSubsystem.LONG_RETVAL_UNLIMITED ||\n+            softLimit >= hostMemory) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        return softLimit;\n+    }\n+\n+    @Override\n+    public long getMemoryFailCount() {\n+        return CgroupV2SubsystemController.getLongEntry(this, \"memory.events\", \"max\");\n+    }\n+\n+    @Override\n+    public long getTcpMemoryUsage() {\n+        return CgroupV2SubsystemController.getLongEntry(this, \"memory.stat\", \"sock\");\n+    }\n+\n+    @Override\n+    public boolean needsAdjustment() {\n+        return !ROOT_PATH.equals(getCgroupPath());\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2MemorySubSystemController.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -31,1 +31,2 @@\n-import java.util.concurrent.TimeUnit;\n+import java.util.Map;\n+import java.util.Objects;\n@@ -36,0 +37,1 @@\n+import jdk.internal.platform.CgroupMetrics;\n@@ -45,1 +47,0 @@\n-    private final CgroupSubsystemController unified;\n@@ -47,1 +48,0 @@\n-    private static final int PER_CPU_SHARES = 1024;\n@@ -49,1 +49,3 @@\n-    private static final long NO_SWAP = 0;\n+    private final CgroupSubsystemController unified;\n+    private final CgroupV2MemorySubSystemController memory;\n+    private final CgroupV2CpuSubSystemController cpu;\n@@ -51,1 +53,3 @@\n-    private CgroupV2Subsystem(CgroupSubsystemController unified) {\n+    private CgroupV2Subsystem(CgroupSubsystemController unified,\n+                              CgroupV2MemorySubSystemController memory,\n+                              CgroupV2CpuSubSystemController cpu) {\n@@ -53,0 +57,2 @@\n+        this.memory = memory;\n+        this.cpu = cpu;\n@@ -55,2 +61,2 @@\n-    private long getLongVal(String file, long defaultValue) {\n-        return CgroupSubsystemController.getLongValue(unified,\n+    static long getLongVal(CgroupSubsystemController controller, String file, long defaultValue) {\n+        return CgroupSubsystemController.getLongValue(controller,\n@@ -62,2 +68,2 @@\n-    private long getLongVal(String file) {\n-        return getLongVal(file, CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    static long getLongVal(CgroupSubsystemController controller, String file) {\n+        return getLongVal(controller, file, CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n@@ -77,1 +83,1 @@\n-    public static CgroupSubsystem getInstance(CgroupInfo anyController) {\n+    public static CgroupSubsystem getInstance(Map<String, CgroupInfo> infos) {\n@@ -79,4 +85,1 @@\n-            CgroupSubsystemController unified = new CgroupV2SubsystemController(\n-                    anyController.getMountPoint(),\n-                    anyController.getCgroupPath());\n-            CgroupV2Subsystem tmpCgroupSystem = new CgroupV2Subsystem(unified);\n+            CgroupV2Subsystem tmpCgroupSystem = initSubSystem(infos);\n@@ -92,0 +95,22 @@\n+    private static CgroupV2Subsystem initSubSystem(Map<String, CgroupInfo> infos) {\n+        \/\/ For unified it doesn't matter which controller we pick.\n+        CgroupInfo anyController = infos.values().iterator().next();\n+        Objects.requireNonNull(anyController);\n+        \/\/ Memory and cpu limits might not be at the leaf, so we ought to\n+        \/\/ iterate the path up the hierarchy and chose the one with the lowest\n+        \/\/ limit. Therefore, we have specific instances for memory and cpu.\n+        \/\/ Other controllers ought to be separate too, but it hasn't yet come up.\n+        CgroupSubsystemController unified = new CgroupV2SubsystemController(\n+                anyController.getMountPoint(),\n+                anyController.getCgroupPath());\n+        CgroupV2MemorySubSystemController memory = new CgroupV2MemorySubSystemController(\n+                anyController.getMountPoint(),\n+                anyController.getCgroupPath());\n+        CgroupUtil.adjustController(memory);\n+        CgroupV2CpuSubSystemController cpu = new CgroupV2CpuSubSystemController(\n+                anyController.getMountPoint(),\n+                anyController.getCgroupPath());\n+        CgroupUtil.adjustController(cpu);\n+        return new CgroupV2Subsystem(unified, memory, cpu);\n+    }\n+\n@@ -99,5 +124,1 @@\n-        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"usage_usec\");\n-        if (micros < 0) {\n-            return micros;\n-        }\n-        return TimeUnit.MICROSECONDS.toNanos(micros);\n+        return cpu.getCpuUsage();\n@@ -113,5 +134,1 @@\n-        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"user_usec\");\n-        if (micros < 0) {\n-            return micros;\n-        }\n-        return TimeUnit.MICROSECONDS.toNanos(micros);\n+        return cpu.getCpuUserUsage();\n@@ -122,5 +139,1 @@\n-        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"system_usec\");\n-        if (micros < 0) {\n-            return micros;\n-        }\n-        return TimeUnit.MICROSECONDS.toNanos(micros);\n+        return cpu.getCpuSystemUsage();\n@@ -131,1 +144,1 @@\n-        return getFromCpuMax(1 \/* $PERIOD index *\/);\n+        return cpu.getCpuPeriod();\n@@ -136,16 +149,1 @@\n-        return getFromCpuMax(0 \/* $MAX index *\/);\n-    }\n-\n-    private long getFromCpuMax(int tokenIdx) {\n-        String cpuMaxRaw = CgroupSubsystemController.getStringValue(unified, \"cpu.max\");\n-        if (cpuMaxRaw == null) {\n-            \/\/ likely file not found\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n-        }\n-        \/\/ $MAX $PERIOD\n-        String[] tokens = cpuMaxRaw.split(\"\\\\s+\");\n-        if (tokens.length != 2) {\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n-        }\n-        String quota = tokens[tokenIdx];\n-        return CgroupSubsystem.limitFromString(quota);\n+        return cpu.getCpuQuota();\n@@ -156,25 +154,1 @@\n-        long sharesRaw = getLongVal(\"cpu.weight\");\n-        if (sharesRaw == 100 || sharesRaw <= 0) {\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n-        }\n-        int shares = (int)sharesRaw;\n-        \/\/ CPU shares (OCI) value needs to get translated into\n-        \/\/ a proper Cgroups v2 value. See:\n-        \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n-        \/\/\n-        \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n-        \/\/ ((262142 * y - 1)\/9999) + 2 = x\n-        \/\/\n-        int x = 262142 * shares - 1;\n-        double frac = x\/9999.0;\n-        x = ((int)frac) + 2;\n-        if ( x <= PER_CPU_SHARES ) {\n-            return PER_CPU_SHARES; \/\/ mimic cgroups v1\n-        }\n-        int f = x\/PER_CPU_SHARES;\n-        int lower_multiple = f * PER_CPU_SHARES;\n-        int upper_multiple = (f + 1) * PER_CPU_SHARES;\n-        int distance_lower = Math.max(lower_multiple, x) - Math.min(lower_multiple, x);\n-        int distance_upper = Math.max(upper_multiple, x) - Math.min(upper_multiple, x);\n-        x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n-        return x;\n+        return cpu.getCpuShares();\n@@ -185,1 +159,1 @@\n-        return CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"nr_periods\");\n+        return cpu.getCpuNumPeriods();\n@@ -190,1 +164,1 @@\n-        return CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"nr_throttled\");\n+        return cpu.getCpuNumThrottled();\n@@ -195,5 +169,1 @@\n-        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"throttled_usec\");\n-        if (micros < 0) {\n-            return micros;\n-        }\n-        return TimeUnit.MICROSECONDS.toNanos(micros);\n+        return cpu.getCpuThrottledTime();\n@@ -240,1 +210,1 @@\n-        return CgroupV2SubsystemController.getLongEntry(unified, \"memory.events\", \"max\");\n+        return memory.getMemoryFailCount();\n@@ -245,2 +215,1 @@\n-        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.max\");\n-        return CgroupSubsystem.limitFromString(strVal);\n+        return memory.getMemoryLimit(CgroupMetrics.getTotalMemorySize0());\n@@ -251,1 +220,1 @@\n-        return getLongVal(\"memory.current\");\n+        return memory.getMemoryUsage();\n@@ -256,1 +225,1 @@\n-        return CgroupV2SubsystemController.getLongEntry(unified, \"memory.stat\", \"sock\");\n+        return memory.getTcpMemoryUsage();\n@@ -259,7 +228,1 @@\n-    \/**\n-     * Note that for cgroups v2 the actual limits set for swap and\n-     * memory live in two different files, memory.swap.max and memory.max\n-     * respectively. In order to properly report a cgroup v1 like\n-     * compound value we need to sum the two values. Setting a swap limit\n-     * without also setting a memory limit is not allowed.\n-     *\/\n+\n@@ -268,13 +231,2 @@\n-        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.swap.max\");\n-        \/\/ We only get a null string when file memory.swap.max doesn't exist.\n-        \/\/ In that case we return the memory limit without any swap.\n-        if (strVal == null) {\n-            return getMemoryLimit();\n-        }\n-        long swapLimit = CgroupSubsystem.limitFromString(strVal);\n-        if (swapLimit >= 0) {\n-            long memoryLimit = getMemoryLimit();\n-            assert memoryLimit >= 0;\n-            return memoryLimit + swapLimit;\n-        }\n-        return swapLimit;\n+        return memory.getMemoryAndSwapLimit(CgroupMetrics.getTotalMemorySize0(),\n+                                            CgroupMetrics.getTotalSwapSize0());\n@@ -283,7 +235,1 @@\n-    \/**\n-     * Note that for cgroups v2 the actual values set for swap usage and\n-     * memory usage live in two different files, memory.current and memory.swap.current\n-     * respectively. In order to properly report a cgroup v1 like\n-     * compound value we need to sum the two values. Setting a swap limit\n-     * without also setting a memory limit is not allowed.\n-     *\/\n+\n@@ -292,8 +238,1 @@\n-        long memoryUsage = getMemoryUsage();\n-        if (memoryUsage >= 0) {\n-            \/\/ If file memory.swap.current doesn't exist, only return the regular\n-            \/\/ memory usage (without swap). Thus, use default value of NO_SWAP.\n-            long swapUsage = getLongVal(\"memory.swap.current\", NO_SWAP);\n-            return memoryUsage + swapUsage;\n-        }\n-        return memoryUsage; \/\/ case of no memory limits\n+        return memory.getMemoryAndSwapUsage();\n@@ -304,2 +243,1 @@\n-        String softLimitStr = CgroupSubsystemController.getStringValue(unified, \"memory.low\");\n-        return CgroupSubsystem.limitFromString(softLimitStr);\n+        return memory.getMemorySoftLimit(CgroupMetrics.getTotalMemorySize0());\n@@ -316,1 +254,1 @@\n-        return getLongVal(\"pids.current\");\n+        return getLongVal(unified, \"pids.current\");\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":59,"deletions":121,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -35,1 +35,3 @@\n-    private final String path;\n+    private final String mountPath;\n+    private String cgroupPath;\n+    private String path;\n@@ -38,0 +40,2 @@\n+        this.mountPath = mountPath;\n+        this.cgroupPath = cgroupPath;\n@@ -46,0 +50,11 @@\n+    @Override\n+    public void setPath(String cgroupPath) {\n+        this.cgroupPath = cgroupPath;\n+        this.path = Paths.get(this.mountPath, cgroupPath).toString();\n+    }\n+\n+    @Override\n+    public String getCgroupPath() {\n+        return this.cgroupPath;\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2SubsystemController.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -65,0 +65,7 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_platform_CgroupMetrics_getTotalCpuCount0\n+  (JNIEnv *env, jclass ignored)\n+{\n+    return JVM_HostActiveProcessorCount();\n+}\n","filename":"src\/java.base\/linux\/native\/libjava\/CgroupMetrics.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assume.assumeTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.Test;\n+\n+import jdk.internal.platform.CgroupMetrics;\n+import jdk.internal.platform.CgroupSubsystemCpuController;\n+import jdk.internal.platform.CgroupUtil;\n+\n+\/*\n+ * @test\n+ * @summary Unit test for controller adjustment for cpu controllers via CgroupUtil.\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform\n+ * @run junit\/othervm CgroupSubsystemCpuControllerTest\n+ *\/\n+public class CgroupSubsystemCpuControllerTest {\n+\n+    private static final CpuLimit UNLIMITED = new CpuLimit(10_000, -1);\n+    @Test\n+    public void noAdjustementNeededIsNoop() {\n+        MockCgroupSubsystemCpuController cpu = new MockCgroupSubsystemCpuController(false, null);\n+        CgroupUtil.adjustController(cpu);\n+\n+        assertNull(cpu.getCgroupPath());\n+    }\n+\n+    @Test\n+    public void adjustmentWithNoLowerLimit() {\n+        String cgroupPath = \"\/a\/b\/c\/d\";\n+        Map<String, CpuLimit> limits = Map.of(cgroupPath, UNLIMITED,\n+                                              \"\/a\/b\/c\", UNLIMITED,\n+                                              \"\/a\/b\", UNLIMITED,\n+                                              \"\/a\", UNLIMITED,\n+                                              \"\/\", UNLIMITED);\n+        MockCgroupSubsystemCpuController cpu = new MockCgroupSubsystemCpuController(true, cgroupPath, limits);\n+        CgroupUtil.adjustController(cpu);\n+\n+        assertNotNull(cpu.getCgroupPath());\n+        assertEquals(cgroupPath, cpu.getCgroupPath());\n+        assertEquals(5, cpu.setCgroupPaths.size());\n+        List<String> expectedList = List.of( \"\/a\/b\/c\", \"\/a\/b\", \"\/a\", \"\/\", cgroupPath);\n+        assertEquals(expectedList, cpu.setCgroupPaths);\n+    }\n+\n+    @Test\n+    public void adjustedLimitLowerInHierarchy() {\n+        String cgroupPath = \"\/a\/b\/c\/d\";\n+        String expectedPath = \"\/a\/b\";\n+        long hostCpus = CgroupMetrics.getTotalCpuCount0();\n+        assumeTrue(hostCpus > 2); \/\/ Skip on systems < 3 host cpus.\n+        Map<String, CpuLimit> limits = Map.of(cgroupPath, UNLIMITED,\n+                                              \"\/a\/b\/c\", UNLIMITED,\n+                                              expectedPath, new CpuLimit(10_000, 20_000) \/* two cores *\/,\n+                                              \"\/a\", UNLIMITED,\n+                                              \"\/\", UNLIMITED);\n+        MockCgroupSubsystemCpuController cpu = new MockCgroupSubsystemCpuController(true, cgroupPath, limits);\n+        CgroupUtil.adjustController(cpu);\n+\n+        assertNotNull(cpu.getCgroupPath());\n+        assertEquals(expectedPath, cpu.getCgroupPath());\n+        \/\/ All paths below \/a\/b\/c\/d => \/, \/a, \/a\/b, \/a\/b\/c and \/a\/b\n+        assertEquals(5, cpu.setCgroupPaths.size());\n+        \/\/ The full hierarchy walk, plus one setPath() call to the expected path\n+        \/\/ due to the lowest limit\n+        List<String> expectedList = List.of(\"\/a\/b\/c\",\n+                                            expectedPath,\n+                                            \"\/a\",\n+                                            \"\/\",\n+                                            expectedPath);\n+        assertEquals(expectedList, cpu.setCgroupPaths);\n+    }\n+\n+    @Test\n+    public void adjustedLimitTwoLowerLimits() {\n+        String cgroupPath = \"\/a\/b\/c\/d\";\n+        String pathWithLimit = \"\/a\/b\/c\";\n+        String expectedPath = \"\/a\";\n+        long hostCpus = CgroupMetrics.getTotalCpuCount0();\n+        assumeTrue(hostCpus > 2); \/\/ Skip on systems < 3 host cpus.\n+        Map<String, CpuLimit> limits = Map.of(cgroupPath, UNLIMITED,\n+                                              pathWithLimit, new CpuLimit(10_000, 20_000), \/* two cores *\/\n+                                              \"\/a\/b\", UNLIMITED,\n+                                              expectedPath, new CpuLimit(10_000, 10_000), \/* one core *\/\n+                                              \"\/\", UNLIMITED);\n+        MockCgroupSubsystemCpuController cpu = new MockCgroupSubsystemCpuController(true, cgroupPath, limits);\n+        CgroupUtil.adjustController(cpu);\n+\n+        assertNotNull(cpu.getCgroupPath());\n+        assertEquals(expectedPath, cpu.getCgroupPath());\n+        \/\/ All paths below \/a\/b\/c\/d => \/, \/a, \/a\/b, \/a\/b\/c and \/a\n+        assertEquals(5, cpu.setCgroupPaths.size());\n+        \/\/ The full hierarchy walk, plus one setPath() call to the expected path\n+        \/\/ due to the lowest limit\n+        List<String> expectedList = List.of(pathWithLimit,\n+                                            \"\/a\/b\",\n+                                            expectedPath,\n+                                            \"\/\",\n+                                            expectedPath);\n+        assertEquals(expectedList, cpu.setCgroupPaths);\n+    }\n+\n+    private static class MockCgroupSubsystemCpuController implements CgroupSubsystemCpuController {\n+\n+        private String cgroupPath;\n+        private final boolean needsAdjustment;\n+        private final List<String> setCgroupPaths = new ArrayList<>();\n+        private final Map<String, CpuLimit> limits;\n+\n+        private MockCgroupSubsystemCpuController(boolean needsAdjustment, String cgroupPath) {\n+            this(needsAdjustment, cgroupPath, null);\n+        }\n+\n+        private MockCgroupSubsystemCpuController(boolean needsAdjustment, String cgroupPath, Map<String, CpuLimit> limits) {\n+            this.needsAdjustment = needsAdjustment;\n+            this.cgroupPath = cgroupPath;\n+            this.limits = limits;\n+        }\n+\n+\n+        @Override\n+        public String path() {\n+            return null; \/\/ doesn't matter\n+        }\n+\n+        @Override\n+        public void setPath(String cgroupPath) {\n+            this.setCgroupPaths.add(cgroupPath);\n+            this.cgroupPath = cgroupPath;\n+        }\n+\n+        @Override\n+        public String getCgroupPath() {\n+            return cgroupPath;\n+        }\n+\n+        @Override\n+        public long getCpuPeriod() {\n+            CpuLimit l = limits.get(cgroupPath);\n+            return l.getPeriod();\n+        }\n+\n+        @Override\n+        public long getCpuQuota() {\n+            CpuLimit l = limits.get(cgroupPath);\n+            return l.getQuota();\n+        }\n+\n+        @Override\n+        public long getCpuShares() {\n+            \/\/ Doesn't matter\n+            return 0;\n+        }\n+\n+        @Override\n+        public long getCpuNumPeriods() {\n+            \/\/ Doesn't matter\n+            return 0;\n+        }\n+\n+        @Override\n+        public long getCpuNumThrottled() {\n+            \/\/ Doesn't matter\n+            return 0;\n+        }\n+\n+        @Override\n+        public long getCpuThrottledTime() {\n+            \/\/ Doesn't matter\n+            return 0;\n+        }\n+\n+        @Override\n+        public boolean needsAdjustment() {\n+            return needsAdjustment;\n+        }\n+\n+    }\n+\n+    private static record CpuLimit(long period, long quota) {\n+        long getPeriod() {\n+            return period;\n+        }\n+\n+        long getQuota() {\n+            return quota;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/CgroupSubsystemCpuControllerTest.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Unit test for controller adjustment for memory controllers via CgroupUtil.\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform\n+ * @run junit\/othervm CgroupSubsystemMemoryControllerTest\n+ *\/\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.Test;\n+\n+import jdk.internal.platform.CgroupSubsystemMemoryController;\n+import jdk.internal.platform.CgroupUtil;\n+\n+public class CgroupSubsystemMemoryControllerTest {\n+\n+    private static final Long UNLIMITED = -1L;\n+    private static final int MB = 1024 * 1024;\n+    private static final Long FIVE_HUNDRED_MB = (long)500 * MB;\n+    private static final Long FOUR_HUNDRED_MB = (long)400 * MB;\n+\n+    @Test\n+    public void noAdjustementNeededIsNoop() {\n+        MockCgroupSubsystemMemoryController memory = new MockCgroupSubsystemMemoryController(false, null);\n+        CgroupUtil.adjustController(memory);\n+\n+        assertNull(memory.getCgroupPath());\n+    }\n+\n+    @Test\n+    public void adjustmentWithNoLowerLimit() {\n+        String cgroupPath = \"\/a\/b\/c\/d\";\n+        Map<String, Long> limits = Map.of(cgroupPath, UNLIMITED,\n+                                          \"\/a\/b\/c\", UNLIMITED,\n+                                          \"\/a\/b\", UNLIMITED,\n+                                          \"\/a\", UNLIMITED,\n+                                          \"\/\", UNLIMITED);\n+        MockCgroupSubsystemMemoryController memory = new MockCgroupSubsystemMemoryController(true, cgroupPath, limits);\n+        CgroupUtil.adjustController(memory);\n+\n+        assertNotNull(memory.getCgroupPath());\n+        assertEquals(cgroupPath, memory.getCgroupPath());\n+        assertEquals(5, memory.setCgroupPaths.size());\n+        List<String> expectedList = List.of( \"\/a\/b\/c\", \"\/a\/b\", \"\/a\", \"\/\", cgroupPath);\n+        assertEquals(expectedList, memory.setCgroupPaths);\n+    }\n+\n+    @Test\n+    public void adjustedLimitAtRoot() {\n+        String cgroupPath = \"\/a\/b\/c\/d\";\n+        String expectedPath = \"\/\";\n+        Map<String, Long> limits = Map.of(cgroupPath, UNLIMITED,\n+                                              \"\/a\/b\/c\", UNLIMITED,\n+                                              \"\/a\/b\", UNLIMITED,\n+                                              \"\/a\", UNLIMITED,\n+                                              expectedPath, FIVE_HUNDRED_MB);\n+        MockCgroupSubsystemMemoryController memory = new MockCgroupSubsystemMemoryController(true, cgroupPath, limits);\n+        CgroupUtil.adjustController(memory);\n+\n+        assertNotNull(memory.getCgroupPath());\n+        assertEquals(expectedPath, memory.getCgroupPath());\n+        \/\/ All paths below \/a\/b\/c\/d => \/a\/b\/c, \/a\/b, \/a, \/ and \/\n+        assertEquals(5, memory.setCgroupPaths.size());\n+        List<String> expectedList = List.of(\"\/a\/b\/c\", \"\/a\/b\", \"\/a\", \"\/\", \"\/\");\n+        assertEquals(expectedList, memory.setCgroupPaths);\n+    }\n+\n+    @Test\n+    public void adjustedLimitTwoLimits() {\n+        String cgroupPath = \"\/a\/b\/c\/d\/e\";\n+        String expectedPath = \"\/a\";\n+        Map<String, Long> limits = Map.of(cgroupPath, FIVE_HUNDRED_MB,\n+                                          \"\/a\/b\/c\/d\", UNLIMITED,\n+                                          \"\/a\/b\/c\", UNLIMITED,\n+                                          \"\/a\/b\", UNLIMITED,\n+                                          expectedPath, FOUR_HUNDRED_MB,\n+                                          \"\/\", UNLIMITED);\n+        MockCgroupSubsystemMemoryController memory = new MockCgroupSubsystemMemoryController(true, cgroupPath, limits);\n+        CgroupUtil.adjustController(memory);\n+\n+        assertNotNull(memory.getCgroupPath());\n+        assertEquals(expectedPath, memory.getCgroupPath());\n+        \/\/ All paths below \/a\/b\/c\/d\/e => \/a\/b\/c\/d, \/a\/b\/c, \/a\/b, \/a, \/ and \/a\n+        assertEquals(6, memory.setCgroupPaths.size());\n+        List<String> expectedList = List.of(\"\/a\/b\/c\/d\", \"\/a\/b\/c\",\n+                                            \"\/a\/b\", \"\/a\", \"\/\", \"\/a\");\n+        assertEquals(expectedList, memory.setCgroupPaths);\n+    }\n+\n+    private static class MockCgroupSubsystemMemoryController implements CgroupSubsystemMemoryController {\n+\n+        private String cgroupPath;\n+        private final boolean needsAdjustment;\n+        private final List<String> setCgroupPaths = new ArrayList<>();\n+        private final Map<String, Long> limits;\n+\n+        private MockCgroupSubsystemMemoryController(boolean needsAdjustment, String cgroupPath) {\n+            this(needsAdjustment, cgroupPath, null);\n+        }\n+\n+        private MockCgroupSubsystemMemoryController(boolean needsAdjustment, String cgroupPath, Map<String, Long> limits) {\n+            this.needsAdjustment = needsAdjustment;\n+            this.limits = limits;\n+            this.cgroupPath = cgroupPath;\n+        }\n+\n+        @Override\n+        public String path() {\n+            \/\/ doesn't matter\n+            return null;\n+        }\n+\n+        @Override\n+        public void setPath(String cgroupPath) {\n+            setCgroupPaths.add(cgroupPath);\n+            this.cgroupPath = cgroupPath;\n+        }\n+\n+        @Override\n+        public String getCgroupPath() {\n+            return cgroupPath;\n+        }\n+\n+        @Override\n+        public long getMemoryLimit(long physicalMemory) {\n+            return limits.get(cgroupPath);\n+        }\n+\n+        @Override\n+        public long getMemoryUsage() {\n+            \/\/ doesn't matter\n+            return 0;\n+        }\n+\n+        @Override\n+        public long getTcpMemoryUsage() {\n+            \/\/ doesn't matter\n+            return 0;\n+        }\n+\n+        @Override\n+        public long getMemoryAndSwapLimit(long hostMemory, long hostSwap) {\n+            \/\/ doesn't matter\n+            return 0;\n+        }\n+\n+        @Override\n+        public long getMemoryAndSwapUsage() {\n+            \/\/ doesn't matter\n+            return 0;\n+        }\n+\n+        @Override\n+        public long getMemorySoftLimit(long hostMemory) {\n+            \/\/ doesn't matter\n+            return 0;\n+        }\n+\n+        @Override\n+        public long getMemoryFailCount() {\n+            \/\/ doesn't matter\n+            return 0;\n+        }\n+\n+        @Override\n+        public boolean needsAdjustment() {\n+            return needsAdjustment;\n+        }\n+\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/CgroupSubsystemMemoryControllerTest.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.platform.Metrics;\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupMetrics.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -217,0 +217,10 @@\n+        @Override\n+        public void setPath(String cgroupPath) {\n+            \/\/ nothing;\n+        }\n+\n+        @Override\n+        public String getCgroupPath() {\n+            return null; \/\/ doesn't matter\n+        }\n+\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemController.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import jdk.internal.platform.CgroupV1MetricsImpl;\n@@ -47,1 +46,0 @@\n-import jdk.internal.platform.Metrics;\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import com.sun.management.OperatingSystemMXBean;\n@@ -27,0 +26,2 @@\n+import com.sun.management.OperatingSystemMXBean;\n+\n@@ -35,0 +36,1 @@\n+        @SuppressWarnings(\"unused\")\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/GetFreeSwapSpaceSize.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.test.lib.Utils;\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerBasic.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,3 +42,1 @@\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-import jdk.test.lib.Asserts;\n+\n@@ -53,1 +51,1 @@\n-    private static final String TARGET_CONTAINER = \"limitsUpdatingJDK_\" + Runtime.getRuntime().version().major();\n+    private static final String TARGET_CONTAINER = \"limitsUpdatingJDK_\" + Runtime.version().feature();\n@@ -94,0 +92,1 @@\n+                @Override\n@@ -115,0 +114,1 @@\n+                @Override\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestLimitsUpdating.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.containers.systemd.SystemdRunOptions;\n+import jdk.test.lib.containers.systemd.SystemdTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.whitebox.WhiteBox;\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @summary Memory\/CPU Metrics awareness for JDK-under-test inside a systemd slice.\n+ * @requires systemd.support\n+ * @modules java.base\/jdk.internal.platform\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar whitebox.jar jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:whitebox.jar -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI SystemdMemoryAwarenessTest\n+ *\/\n+public class SystemdMemoryAwarenessTest {\n+\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+    private static final int HUNDRED_THOUSEND = 100_000;\n+    private static final String TEST_SLICE_NAME = SystemdMemoryAwarenessTest.class.getSimpleName() + \"JDK\";\n+\n+    public static void main(String[] args) throws Exception {\n+        testSystemSettings();\n+    }\n+\n+    private static void testSystemSettings() throws Exception {\n+        SystemdRunOptions opts = SystemdTestUtils.newOpts(\"-version\");\n+        opts.addJavaOpts(\"-XshowSettings:system\");\n+\n+        \/\/ 1 GB memory, but the limit in the lower hierarchy is 512M\n+        opts.memoryLimit(\"1024M\");\n+        int expectedMemLimit = 512;\n+        \/\/ expected detected limit we test for, 512MB\n+        opts.sliceDMemoryLimit(String.format(\"%dM\", expectedMemLimit));\n+        int physicalCpus = wb.hostCPUs();\n+        if (physicalCpus < 2) {\n+           System.err.println(\"WARNING: host system only has \" + physicalCpus +\n+                              \" cpus. Expected >= 2\");\n+           System.err.println(\"Effective CPU Count assertion will trivially pass\");\n+        }\n+        \/\/ Use a CPU core limit of 1 for best coverage\n+        int coreLimit = 1;\n+        System.out.println(\"DEBUG: Running test with a CPU limit of \" + coreLimit);\n+        opts.cpuLimit(String.format(\"%d%%\", coreLimit * 100));\n+        opts.sliceName(TEST_SLICE_NAME);\n+\n+        OutputAnalyzer out = SystemdTestUtils.buildAndRunSystemdJava(opts);\n+        out.shouldHaveExitValue(0)\n+           .shouldContain(\"Operating System Metrics:\")\n+           .shouldContain(String.format(\"Memory Limit: %d.00M\", expectedMemLimit));\n+        try {\n+            out.shouldContain(\"Effective CPU Count: \" + coreLimit)\n+               .shouldContain(String.format(\"CPU Period: %dus\", HUNDRED_THOUSEND))\n+               .shouldContain(String.format(\"CPU Quota: %dus\", (HUNDRED_THOUSEND * coreLimit)));\n+        } catch (RuntimeException e) {\n+            \/\/ CPU delegation needs to be enabled when run as user on cg v2\n+            if (SystemdTestUtils.RUN_AS_USER) {\n+                String hint = \"When run as user on cg v2 cpu delegation needs to be configured!\";\n+                throw new SkippedException(hint);\n+            }\n+            throw e;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/systemd\/SystemdMemoryAwarenessTest.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"","filename":"test\/jdk\/jdk\/internal\/platform\/systemd\/TEST.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/containers\/systemd\/TEST.properties","status":"copied"}]}