{"files":[{"patch":"@@ -92,2 +92,38 @@\n-        assertEquals(2, cpu.setCgroupPaths.size());\n-        List<String> expectedList = List.of(\"\/a\/b\/c\", \"\/a\/b\");\n+        \/\/ All paths below \/a\/b\/c\/d => \/, \/a, \/a\/b, \/a\/b\/c and \/a\/b\n+        assertEquals(5, cpu.setCgroupPaths.size());\n+        \/\/ The full hierarchy walk, plus one setPath() call to the expected path\n+        \/\/ due to the lowest limit\n+        List<String> expectedList = List.of(\"\/a\/b\/c\",\n+                                            expectedPath,\n+                                            \"\/a\",\n+                                            \"\/\",\n+                                            expectedPath);\n+        assertEquals(expectedList, cpu.setCgroupPaths);\n+    }\n+\n+    @Test\n+    public void adjustedLimitTwoLowerLimits() {\n+        String cgroupPath = \"\/a\/b\/c\/d\";\n+        String pathWithLimit = \"\/a\/b\/c\";\n+        String expectedPath = \"\/a\";\n+        long hostCpus = CgroupMetrics.getTotalCpuCount0();\n+        assumeTrue(hostCpus > 2); \/\/ Skip on systems < 3 host cpus.\n+        Map<String, CpuLimit> limits = Map.of(cgroupPath, UNLIMITED,\n+                                              pathWithLimit, new CpuLimit(10_000, 20_000), \/* two cores *\/\n+                                              \"\/a\/b\", UNLIMITED,\n+                                              expectedPath, new CpuLimit(10_000, 10_000), \/* one core *\/\n+                                              \"\/\", UNLIMITED);\n+        MockCgroupSubsystemCpuController cpu = new MockCgroupSubsystemCpuController(true, cgroupPath, limits);\n+        CgroupUtil.adjustController(cpu);\n+\n+        assertNotNull(cpu.getCgroupPath());\n+        assertEquals(expectedPath, cpu.getCgroupPath());\n+        \/\/ All paths below \/a\/b\/c\/d => \/, \/a, \/a\/b, \/a\/b\/c and \/a\n+        assertEquals(5, cpu.setCgroupPaths.size());\n+        \/\/ The full hierarchy walk, plus one setPath() call to the expected path\n+        \/\/ due to the lowest limit\n+        List<String> expectedList = List.of(pathWithLimit,\n+                                            \"\/a\/b\",\n+                                            expectedPath,\n+                                            \"\/\",\n+                                            expectedPath);\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/CgroupSubsystemCpuControllerTest.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -49,1 +49,3 @@\n-    private static final Long FIVE_HUNDRED_MB = (long)500 * 1024 * 1024 * 1024;\n+    private static final int MB = 1024 * 1024;\n+    private static final Long FIVE_HUNDRED_MB = (long)500 * MB;\n+    private static final Long FOUR_HUNDRED_MB = (long)400 * MB;\n@@ -86,8 +88,31 @@\n-        MockCgroupSubsystemMemoryController cpu = new MockCgroupSubsystemMemoryController(true, cgroupPath, limits);\n-        CgroupUtil.adjustController(cpu);\n-\n-        assertNotNull(cpu.getCgroupPath());\n-        assertEquals(expectedPath, cpu.getCgroupPath());\n-        assertEquals(4, cpu.setCgroupPaths.size());\n-        List<String> expectedList = List.of(\"\/a\/b\/c\", \"\/a\/b\", \"\/a\", \"\/\");\n-        assertEquals(expectedList, cpu.setCgroupPaths);\n+        MockCgroupSubsystemMemoryController memory = new MockCgroupSubsystemMemoryController(true, cgroupPath, limits);\n+        CgroupUtil.adjustController(memory);\n+\n+        assertNotNull(memory.getCgroupPath());\n+        assertEquals(expectedPath, memory.getCgroupPath());\n+        \/\/ All paths below \/a\/b\/c\/d => \/a\/b\/c, \/a\/b, \/a, \/ and \/\n+        assertEquals(5, memory.setCgroupPaths.size());\n+        List<String> expectedList = List.of(\"\/a\/b\/c\", \"\/a\/b\", \"\/a\", \"\/\", \"\/\");\n+        assertEquals(expectedList, memory.setCgroupPaths);\n+    }\n+\n+    @Test\n+    public void adjustedLimitTwoLimits() {\n+        String cgroupPath = \"\/a\/b\/c\/d\/e\";\n+        String expectedPath = \"\/a\";\n+        Map<String, Long> limits = Map.of(cgroupPath, FIVE_HUNDRED_MB,\n+                                          \"\/a\/b\/c\/d\", UNLIMITED,\n+                                          \"\/a\/b\/c\", UNLIMITED,\n+                                          \"\/a\/b\", UNLIMITED,\n+                                          expectedPath, FOUR_HUNDRED_MB,\n+                                          \"\/\", UNLIMITED);\n+        MockCgroupSubsystemMemoryController memory = new MockCgroupSubsystemMemoryController(true, cgroupPath, limits);\n+        CgroupUtil.adjustController(memory);\n+\n+        assertNotNull(memory.getCgroupPath());\n+        assertEquals(expectedPath, memory.getCgroupPath());\n+        \/\/ All paths below \/a\/b\/c\/d\/e => \/a\/b\/c\/d, \/a\/b\/c, \/a\/b, \/a, \/ and \/a\n+        assertEquals(6, memory.setCgroupPaths.size());\n+        List<String> expectedList = List.of(\"\/a\/b\/c\/d\", \"\/a\/b\/c\",\n+                                            \"\/a\/b\", \"\/a\", \"\/\", \"\/a\");\n+        assertEquals(expectedList, memory.setCgroupPaths);\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/CgroupSubsystemMemoryControllerTest.java","additions":34,"deletions":9,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -27,0 +28,1 @@\n+import jtreg.SkippedException;\n@@ -58,2 +60,4 @@\n-        if (physicalCpus < 3) {\n-           System.err.println(\"WARNING: host system only has \" + physicalCpus + \" expected >= 3\");\n+        if (physicalCpus < 2) {\n+           System.err.println(\"WARNING: host system only has \" + physicalCpus +\n+                              \" cpus. Expected >= 2\");\n+           System.err.println(\"Effective CPU Count assertion will trivially pass\");\n@@ -61,2 +65,2 @@\n-        \/\/ 1 or 2 cores limit depending on physical CPUs\n-        int coreLimit = Math.min(physicalCpus, 2);\n+        \/\/ Use a CPU core limit of 1 for best coverage\n+        int coreLimit = 1;\n@@ -67,7 +71,16 @@\n-        SystemdTestUtils.buildAndRunSystemdJava(opts)\n-            .shouldHaveExitValue(0)\n-            .shouldContain(\"Operating System Metrics:\")\n-            .shouldContain(\"Effective CPU Count: \" + coreLimit)\n-            .shouldContain(String.format(\"CPU Period: %dus\", HUNDRED_THOUSEND))\n-            .shouldContain(String.format(\"CPU Quota: %dus\", (HUNDRED_THOUSEND * coreLimit)))\n-            .shouldContain(String.format(\"Memory Limit: %d.00M\", expectedMemLimit));\n+        OutputAnalyzer out = SystemdTestUtils.buildAndRunSystemdJava(opts);\n+        out.shouldHaveExitValue(0)\n+           .shouldContain(\"Operating System Metrics:\")\n+           .shouldContain(String.format(\"Memory Limit: %d.00M\", expectedMemLimit));\n+        try {\n+            out.shouldContain(\"Effective CPU Count: \" + coreLimit)\n+               .shouldContain(String.format(\"CPU Period: %dus\", HUNDRED_THOUSEND))\n+               .shouldContain(String.format(\"CPU Quota: %dus\", (HUNDRED_THOUSEND * coreLimit)));\n+        } catch (RuntimeException e) {\n+            \/\/ CPU delegation needs to be enabled when run as user on cg v2\n+            if (SystemdTestUtils.RUN_AS_USER) {\n+                String hint = \"When run as user on cg v2 cpu delegation needs to be configured!\";\n+                throw new SkippedException(hint);\n+            }\n+            throw e;\n+        }\n","filename":"test\/jdk\/jdk\/internal\/platform\/systemd\/SystemdMemoryAwarenessTest.java","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"}]}