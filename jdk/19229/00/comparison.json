{"files":[{"patch":"@@ -133,2 +133,2 @@\n-  \/\/ Clean up old interpreter OopMap entries that were replaced\n-  \/\/ during the GC thread root traversal.\n+  \/\/ GC thread root traversal likely used OopMapCache a lot, which\n+  \/\/ might have created lots of old entries. Clean them up proactively.\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+  \/\/ GC thread root traversal likely used OopMapCache a lot, which\n+  \/\/ might have created lots of old entries. Clean them up proactively.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/globalCounter.inline.hpp\"\n@@ -497,2 +498,1 @@\n-\/\/ Called by GC for thread root scan during a safepoint only.  The other interpreted frame oopmaps\n-\/\/ are generated locally and not cached.\n+\/\/ Lookup or compute\/cache the entry.\n@@ -502,1 +502,0 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"called by GC in a safepoint\");\n@@ -504,2 +503,0 @@\n-  int i;\n-  OopMapCacheEntry* entry = nullptr;\n@@ -515,8 +512,12 @@\n-  \/\/ Search hashtable for match\n-  for(i = 0; i < _probe_depth; i++) {\n-    entry = entry_at(probe + i);\n-    if (entry != nullptr && !entry->is_empty() && entry->match(method, bci)) {\n-      entry_for->resource_copy(entry);\n-      assert(!entry_for->is_empty(), \"A non-empty oop map should be returned\");\n-      log_debug(interpreter, oopmap)(\"- found at hash %d\", probe + i);\n-      return;\n+  \/\/ Search hashtable for match.\n+  \/\/ Need a critical section to avoid race against concurrent reclamation.\n+  {\n+    GlobalCounter::CriticalSection cs(Thread::current());\n+    for (int i = 0; i < _probe_depth; i++) {\n+      OopMapCacheEntry *entry = entry_at(probe + i);\n+      if (entry != nullptr && !entry->is_empty() && entry->match(method, bci)) {\n+        entry_for->resource_copy(entry);\n+        assert(!entry_for->is_empty(), \"A non-empty oop map should be returned\");\n+        log_debug(interpreter, oopmap)(\"- found at hash %d\", probe + i);\n+        return;\n+      }\n@@ -544,2 +545,2 @@\n-  for(i = 0; i < _probe_depth; i++) {\n-    entry = entry_at(probe + i);\n+  for (int i = 0; i < _probe_depth; i++) {\n+    OopMapCacheEntry* entry = entry_at(probe + i);\n@@ -560,0 +561,4 @@\n+    \/\/ Cannot deallocate old entry on the spot: it can still be used by readers\n+    \/\/ that got a reference to it before we were able to replace it in the map.\n+    \/\/ Instead of synchronizing on GlobalCounter here and incurring heavy thread\n+    \/\/ walk, we do this clean up out of band.\n@@ -570,4 +575,2 @@\n-  bool success = false;\n-  OopMapCacheEntry* head;\n-  do {\n-    head = _old_entries;\n+  while (true) {\n+    OopMapCacheEntry* head = Atomic::load(&_old_entries);\n@@ -575,2 +578,5 @@\n-    success = Atomic::cmpxchg(&_old_entries, head, entry) == head;\n-  } while (!success);\n+    if (Atomic::cmpxchg(&_old_entries, head, entry) == head) {\n+      \/\/ Success.\n+      break;\n+    }\n+  }\n@@ -585,2 +591,4 @@\n-\/\/ This is called after GC threads are done and nothing is accessing the old_entries\n-\/\/ list, so no synchronization needed.\n+bool OopMapCache::has_cleanup_work() {\n+  return Atomic::load(&_old_entries) != nullptr;\n+}\n+\n@@ -588,2 +596,10 @@\n-  OopMapCacheEntry* entry = _old_entries;\n-  _old_entries = nullptr;\n+  OopMapCacheEntry* entry = Atomic::xchg(&_old_entries, (OopMapCacheEntry*)nullptr);\n+  if (entry == nullptr) {\n+    \/\/ No work.\n+    return;\n+  }\n+\n+  \/\/ About to delete the entries than might still be accessed by other threads\n+  \/\/ on lookup path. Need to sync up with them before proceeding.\n+  GlobalCounter::write_synchronize();\n+\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":41,"deletions":25,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -182,0 +182,5 @@\n+\n+  \/\/ Check if we need to clean up old entries\n+  static bool has_cleanup_work();\n+\n+  \/\/ Clean up the old entries\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -313,8 +313,1 @@\n-  \/\/ Only GC uses the OopMapCache during thread stack root scanning\n-  \/\/ any other uses generate an oopmap but do not save it in the cache.\n-  if (Universe::heap()->is_stw_gc_active()) {\n-    method_holder()->mask_for(h_this, bci, mask);\n-  } else {\n-    OopMapCache::compute_one_oop_map(h_this, bci, mask);\n-  }\n-  return;\n+  mask_for(h_this, bci, mask);\n@@ -323,0 +316,4 @@\n+void Method::mask_for(const methodHandle& this_mh, int bci, InterpreterOopMap* mask) {\n+  assert(this_mh() == this, \"Sanity\");\n+  method_holder()->mask_for(this_mh, bci, mask);\n+}\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -449,1 +449,2 @@\n-  \/\/ Interpreter oopmap support\n+  \/\/ Interpreter oopmap support.\n+  \/\/ If handle is already available, call with it for better performance.\n@@ -451,0 +452,1 @@\n+  void mask_for(const methodHandle& this_mh, int bci, InterpreterOopMap* mask);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -953,1 +953,1 @@\n-    m->mask_for(bci, &mask);\n+    m->mask_for(m, bci, &mask);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -98,0 +99,1 @@\n+    bool oopmap_cache_work = false;\n@@ -127,1 +129,2 @@\n-              (jvmti_tagmap_work = JvmtiTagMap::has_object_free_events_and_reset())\n+              (jvmti_tagmap_work = JvmtiTagMap::has_object_free_events_and_reset()) |\n+              (oopmap_cache_work = OopMapCache::has_cleanup_work())\n@@ -199,0 +202,4 @@\n+\n+    if (oopmap_cache_work) {\n+      OopMapCache::cleanup_old_entries();\n+    }\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}