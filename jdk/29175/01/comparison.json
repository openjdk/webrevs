{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import java.io.PrintWriter;\n@@ -49,0 +50,12 @@\n+    Log.Logger logger() {\n+        return logger;\n+    }\n+\n+    public void loggerOutputStreams(PrintWriter out, PrintWriter err) {\n+        logger.setPrintWriter(out, err);\n+    }\n+\n+    public void loggerVerbose() {\n+        logger.setVerbose();\n+    }\n+\n@@ -68,0 +81,1 @@\n+    private final Log.Logger logger = new Log.Logger();\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Globals.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -64,10 +64,0 @@\n-        public void flush() {\n-            if (out != null) {\n-                out.flush();\n-            }\n-\n-            if (err != null) {\n-                err.flush();\n-            }\n-        }\n-\n@@ -114,15 +104,0 @@\n-    private static final InheritableThreadLocal<Logger> instance =\n-            new InheritableThreadLocal<Logger>() {\n-                @Override protected Logger initialValue() {\n-                    return new Logger();\n-                }\n-            };\n-\n-    public static void setPrintWriter (PrintWriter out, PrintWriter err) {\n-        instance.get().setPrintWriter(out, err);\n-    }\n-\n-    public static void flush() {\n-        instance.get().flush();\n-    }\n-\n@@ -130,1 +105,1 @@\n-        instance.get().info(msg);\n+        Globals.instance().logger().info(msg);\n@@ -134,1 +109,1 @@\n-        instance.get().fatalError(msg);\n+        Globals.instance().logger().fatalError(msg);\n@@ -138,5 +113,1 @@\n-        instance.get().error(msg);\n-    }\n-\n-    public static void setVerbose() {\n-        instance.get().setVerbose();\n+        Globals.instance().logger().error(msg);\n@@ -146,1 +117,1 @@\n-        return instance.get().isVerbose();\n+        return Globals.instance().logger().isVerbose();\n@@ -150,1 +121,1 @@\n-       instance.get().verbose(msg);\n+        Globals.instance().logger().verbose(msg);\n@@ -154,1 +125,1 @@\n-       instance.get().verbose(t);\n+        Globals.instance().logger().verbose(t);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Log.java","additions":6,"deletions":35,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-            PrintWriter outWriter = new PrintWriter(out, true);\n-            PrintWriter errWriter = new PrintWriter(err, true);\n+            PrintWriter outWriter = toPrintWriter(out);\n+            PrintWriter errWriter = toPrintWriter(err);\n@@ -101,2 +101,2 @@\n-        var out = new PrintWriter(System.out, true);\n-        var err = new PrintWriter(System.err, true);\n+        var out = toPrintWriter(System.out);\n+        var err = toPrintWriter(System.err);\n@@ -130,1 +130,1 @@\n-        Log.setPrintWriter(out, err);\n+        Globals.instance().loggerOutputStreams(out, err);\n@@ -182,1 +182,1 @@\n-                    Log.setVerbose();\n+                    Globals.instance().loggerVerbose();\n@@ -313,0 +313,4 @@\n+    private static PrintWriter toPrintWriter(PrintStream ps) {\n+        return new PrintWriter(ps, true, ps.charset());\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Main.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.spi.ToolProvider;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class JPackageCommandTest extends JUnitAdapter.TestSrcInitializer {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testUseToolProvider(UseToolProviderTestSpec spec) {\n+        \/\/ Run the test with the new state to avoid UnsupportedOperationException\n+        \/\/ that will be thrown if it attempts to alter global variables in the default R\/O state.\n+        TKit.withNewState(spec::test);\n+    }\n+\n+    private static List<UseToolProviderTestSpec> testUseToolProvider() {\n+\n+        var testCases = new ArrayList<UseToolProviderTestSpec>();\n+\n+        for (var globalToolProvider : ExecutableSetterType.values()) {\n+            for (var instanceToolProvider : ExecutableSetterType.values()) {\n+                testCases.add(new UseToolProviderTestSpec(globalToolProvider, instanceToolProvider));\n+            }\n+        }\n+\n+        return testCases;\n+    }\n+\n+    record UseToolProviderTestSpec(ExecutableSetterType globalType, ExecutableSetterType instanceType) {\n+\n+        UseToolProviderTestSpec {\n+            Objects.requireNonNull(globalType);\n+            Objects.requireNonNull(instanceType);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"%s, global=%s\", instanceType, globalType);\n+        }\n+\n+        void test() {\n+\n+            final Optional<ToolProvider> global;\n+            switch (globalType) {\n+                case SET_CUSTOM_TOOL_PROVIDER -> {\n+                    global = Optional.of(createNewToolProvider(\"jpackage-mock-global\"));\n+                    JPackageCommand.useToolProviderByDefault(global.get());\n+                }\n+                case SET_DEFAULT_TOOL_PROVIDER -> {\n+                    global = Optional.of(JavaTool.JPACKAGE.asToolProvider());\n+                    JPackageCommand.useToolProviderByDefault();\n+                }\n+                case SET_PROCESS -> {\n+                    global = Optional.empty();\n+                    JPackageCommand.useExecutableByDefault();\n+                }\n+                case SET_NONE -> {\n+                    global = Optional.empty();\n+                }\n+                default -> {\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+\n+            var cmd = new JPackageCommand();\n+\n+            final Optional<ToolProvider> instance;\n+            switch (instanceType) {\n+                case SET_CUSTOM_TOOL_PROVIDER -> {\n+                    instance = Optional.of(createNewToolProvider(\"jpackage-mock\"));\n+                    cmd.useToolProvider(instance.get());\n+                }\n+                case SET_DEFAULT_TOOL_PROVIDER -> {\n+                    instance = Optional.of(JavaTool.JPACKAGE.asToolProvider());\n+                    cmd.useToolProvider(true);\n+                }\n+                case SET_PROCESS -> {\n+                    instance = Optional.empty();\n+                    cmd.useToolProvider(false);\n+                }\n+                case SET_NONE -> {\n+                    instance = Optional.empty();\n+                }\n+                default -> {\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+\n+            var actual = cmd.createExecutor().getToolProvider();\n+\n+            switch (instanceType) {\n+                case SET_CUSTOM_TOOL_PROVIDER -> {\n+                    assertSame(actual.get(), instance.get());\n+                    assertTrue(cmd.isWithToolProvider());\n+                }\n+                case SET_DEFAULT_TOOL_PROVIDER -> {\n+                    global.ifPresentOrElse(expected -> {\n+                        assertEquals(expected.name(), actual.orElseThrow().name());\n+                    }, () -> {\n+                        assertEquals(instance.get().name(), actual.get().name());\n+                    });\n+                    assertTrue(cmd.isWithToolProvider());\n+                }\n+                case SET_PROCESS -> {\n+                    assertFalse(actual.isPresent());\n+                    assertFalse(cmd.isWithToolProvider());\n+                }\n+                case SET_NONE -> {\n+                    switch (globalType) {\n+                        case SET_CUSTOM_TOOL_PROVIDER -> {\n+                            assertSame(global.get(), actual.get());\n+                            assertTrue(cmd.isWithToolProvider());\n+                        }\n+                        case SET_DEFAULT_TOOL_PROVIDER -> {\n+                            assertEquals(global.get().name(), actual.orElseThrow().name());\n+                            assertTrue(cmd.isWithToolProvider());\n+                        }\n+                        case SET_PROCESS, SET_NONE -> {\n+                            assertFalse(actual.isPresent());\n+                            assertFalse(cmd.isWithToolProvider());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        private static ToolProvider createNewToolProvider(String name) {\n+            return new ToolProvider() {\n+                @Override\n+                public int run(PrintWriter out, PrintWriter err, String... args) {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public String name() {\n+                    return name;\n+                }\n+            };\n+        }\n+    }\n+\n+    enum ExecutableSetterType {\n+        SET_DEFAULT_TOOL_PROVIDER,\n+        SET_CUSTOM_TOOL_PROVIDER,\n+        SET_PROCESS,\n+        SET_NONE,\n+        ;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JPackageCommandTest.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -66,0 +66,1 @@\n+        commandOutputControl.dumpStdout(TKit.state().out()).dumpStderr(TKit.state().err());\n@@ -88,0 +89,4 @@\n+    public Optional<ToolProvider> getToolProvider() {\n+        return Optional.ofNullable(toolProvider);\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,2 +55,0 @@\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.Executors;\n@@ -66,0 +64,1 @@\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n@@ -80,0 +79,1 @@\n+        toolProviderSource = new ToolProviderSource();\n@@ -87,1 +87,1 @@\n-        withToolProvider = cmd.withToolProvider;\n+        toolProviderSource = cmd.toolProviderSource.copy();\n@@ -773,1 +773,1 @@\n-        defaultToolProvider.set(Optional.of(jpackageToolProvider));\n+        TKit.state().setProperty(DefaultToolProviderKey.VALUE, Objects.requireNonNull(jpackageToolProvider));\n@@ -781,1 +781,1 @@\n-        defaultToolProvider.set(Optional.empty());\n+        TKit.state().setProperty(DefaultToolProviderKey.VALUE, null);\n@@ -784,31 +784,8 @@\n-    \/**\n-     * In a separate thread calls {@link #useToolProviderByDefault(ToolProvider)}\n-     * with the specified {@code jpackageToolProvider} and then calls\n-     * {@code workload.run()}. Joins the thread.\n-     * <p>\n-     * The idea is to run the {@code workload} in the context of the specified\n-     * jpackage {@code ToolProvider} without altering the global variable holding\n-     * the default jpackage {@code ToolProvider}. The global variable is\n-     * thread-local; setting its value in a new thread doesn't alter its copy in the\n-     * calling thread.\n-     *\n-     * @param jpackageToolProvider jpackage {@code ToolProvider}\n-     * @param workload             the workload to run\n-     *\/\n-    public static void withToolProvider(Runnable workload, ToolProvider jpackageToolProvider) {\n-        Objects.requireNonNull(workload);\n-        Objects.requireNonNull(jpackageToolProvider);\n-\n-        CompletableFuture.runAsync(() -> {\n-            var oldValue = defaultToolProvider.get();\n-            useToolProviderByDefault(jpackageToolProvider);\n-            try {\n-                workload.run();\n-            } finally {\n-                defaultToolProvider.set(oldValue);\n-            }\n-            \/\/ Run the future in a new native thread. Don't run it in a virtual\/pooled thread.\n-            \/\/ Pooled and\/or virtual threads are problematic when used with inheritable thread-local variables.\n-            \/\/ TKit class depends on such a variable, which results in intermittent test failures\n-            \/\/ if the default executor runs this future.\n-        }, Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory())).join();\n+    public JPackageCommand useToolProvider(boolean v) {\n+        verifyMutable();\n+        if (v) {\n+            toolProviderSource.useDefaultToolProvider();\n+        } else {\n+            toolProviderSource.useProcess();\n+        }\n+        return this;\n@@ -817,1 +794,1 @@\n-    public JPackageCommand useToolProvider(boolean v) {\n+    public JPackageCommand useToolProvider(ToolProvider v) {\n@@ -819,1 +796,1 @@\n-        withToolProvider = v;\n+        toolProviderSource.useToolProvider(v);\n@@ -931,3 +908,1 @@\n-        return Optional.ofNullable(withToolProvider).orElseGet(() -> {\n-            return defaultToolProvider.get().isPresent();\n-        });\n+        return toolProviderSource.toolProvider().isPresent();\n@@ -941,1 +916,1 @@\n-    private Executor createExecutor() {\n+    Executor createExecutor() {\n@@ -948,8 +923,6 @@\n-        if (isWithToolProvider()) {\n-            exec.setToolProvider(defaultToolProvider.get().orElseGet(JavaTool.JPACKAGE::asToolProvider));\n-        } else {\n-            exec.setExecutable(JavaTool.JPACKAGE);\n-            if (TKit.isWindows()) {\n-                exec.setWindowsTmpDir(System.getProperty(\"java.io.tmpdir\"));\n-            }\n-        }\n+        toolProviderSource.toolProvider().ifPresentOrElse(exec::setToolProvider, () -> {\n+                    exec.setExecutable(JavaTool.JPACKAGE);\n+                    if (TKit.isWindows()) {\n+                        exec.setWindowsTmpDir(System.getProperty(\"java.io.tmpdir\"));\n+                    }\n+                });\n@@ -1734,1 +1707,64 @@\n-    private Boolean withToolProvider;\n+    private static final class ToolProviderSource {\n+\n+        ToolProviderSource copy() {\n+            return new ToolProviderSource(this);\n+        }\n+\n+        void useDefaultToolProvider() {\n+            customToolProvider = null;\n+            mode = Mode.USE_TOOL_PROVIDER;\n+        }\n+\n+        void useToolProvider(ToolProvider tp) {\n+            customToolProvider = Objects.requireNonNull(tp);\n+            mode = Mode.USE_TOOL_PROVIDER;\n+        }\n+\n+        void useProcess() {\n+            customToolProvider = null;\n+            mode = Mode.USE_PROCESS;\n+        }\n+\n+        Optional<ToolProvider> toolProvider() {\n+            switch (mode) {\n+                case USE_PROCESS -> {\n+                    return Optional.empty();\n+                }\n+                case USE_TOOL_PROVIDER -> {\n+                    if (customToolProvider != null) {\n+                        return Optional.of(customToolProvider);\n+                    } else {\n+                        return TKit.state().findProperty(DefaultToolProviderKey.VALUE).map(ToolProvider.class::cast).or(() -> {\n+                            return Optional.of(JavaTool.JPACKAGE.asToolProvider());\n+                        });\n+                    }\n+                }\n+                case INHERIT_DEFAULTS -> {\n+                    return TKit.state().findProperty(DefaultToolProviderKey.VALUE).map(ToolProvider.class::cast);\n+                }\n+                default -> {\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+        }\n+\n+        ToolProviderSource() {\n+            mode = Mode.INHERIT_DEFAULTS;\n+        }\n+\n+        private ToolProviderSource(ToolProviderSource other) {\n+            this.customToolProvider = other.customToolProvider;\n+            this.mode = other.mode;\n+        }\n+\n+        private enum Mode {\n+            INHERIT_DEFAULTS,\n+            USE_PROCESS,\n+            USE_TOOL_PROVIDER\n+        }\n+\n+        private ToolProvider customToolProvider;\n+        private Mode mode;\n+    }\n+\n+    private final ToolProviderSource toolProviderSource;\n@@ -1750,6 +1786,4 @@\n-    private static InheritableThreadLocal<Optional<ToolProvider>> defaultToolProvider = new InheritableThreadLocal<>() {\n-        @Override\n-        protected Optional<ToolProvider> initialValue() {\n-            return Optional.empty();\n-        }\n-    };\n+\n+    private enum DefaultToolProviderKey {\n+        VALUE\n+    }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":91,"deletions":57,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n@@ -32,0 +35,1 @@\n+import java.nio.file.StandardOpenOption;\n@@ -37,0 +41,2 @@\n+import java.util.Objects;\n+import java.util.Optional;\n@@ -41,0 +47,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingRunnable;\n@@ -50,0 +57,42 @@\n+        Objects.requireNonNull(builder);\n+\n+        var argList = List.of(args);\n+\n+        var ignoreLogfile = argList.contains(CMDLINE_ARG_PREFIX + \"ignore-logfile\");\n+\n+        List<String> filteredArgs;\n+        if (ignoreLogfile) {\n+            filteredArgs = argList.stream().filter(Predicate.isEqual(CMDLINE_ARG_PREFIX + \"ignore-logfile\").negate()).toList();\n+        } else {\n+            filteredArgs = argList;\n+        }\n+\n+        ThrowingRunnable<Exception> workload = () -> {\n+            run(builder, filteredArgs);\n+        };\n+\n+        try {\n+            Optional.ofNullable(TKit.getConfigProperty(\"logfile\")).filter(_ -> {\n+                return !ignoreLogfile;\n+            }).map(Path::of).ifPresentOrElse(logfile -> {\n+\n+                try (var out = new PrintStream(\n+                        Files.newOutputStream(logfile, StandardOpenOption.CREATE, StandardOpenOption.APPEND),\n+                        true,\n+                        System.out.charset())) {\n+\n+                    TKit.withOutput(workload, out, out);\n+\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+\n+            }, () -> {\n+                ThrowingRunnable.toRunnable(workload).run();\n+            });\n+        } catch (Exception ex) {\n+            throw ExceptionBox.unbox(ex);\n+        }\n+    }\n+\n+    private static void run(TestBuilder.Builder builder, List<String> args) throws Exception {\n@@ -53,1 +102,1 @@\n-            Deque<String> argsAsList = new ArrayDeque<>(List.of(args));\n+            Deque<String> argsAsList = new ArrayDeque<>(args);\n@@ -118,1 +167,1 @@\n-        TKit.withExtraLogStream(() -> runTests(orderedTests));\n+        runTests(orderedTests);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Main.java","additions":52,"deletions":3,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import java.nio.file.StandardOpenOption;\n@@ -55,0 +54,1 @@\n+import java.util.HashMap;\n@@ -112,6 +112,14 @@\n-    static void withExtraLogStream(ThrowingRunnable<? extends Exception> action) {\n-        if (state().extraLogStream != null) {\n-            ThrowingRunnable.toRunnable(action).run();\n-        } else {\n-            try (PrintStream logStream = openLogStream()) {\n-                withExtraLogStream(action, logStream);\n+    public static void withOutput(ThrowingRunnable<? extends Exception> action, PrintStream out, PrintStream err) {\n+        Objects.requireNonNull(action);\n+        Objects.requireNonNull(out);\n+        Objects.requireNonNull(err);\n+\n+        try {\n+            withState(action, stateBuilder -> {\n+                stateBuilder.out(out).err(err);\n+            });\n+        } finally {\n+            try {\n+                out.flush();\n+            } finally {\n+                err.flush();\n@@ -122,17 +130,3 @@\n-    static void withExtraLogStream(ThrowingRunnable<? extends Exception> action, PrintStream logStream) {\n-        withNewState(action, stateBuilder -> {\n-            stateBuilder.extraLogStream(logStream);\n-        });\n-    }\n-\n-    public static void withMainLogStream(ThrowingRunnable<? extends Exception> action, PrintStream logStream) {\n-        withNewState(action, stateBuilder -> {\n-            stateBuilder.mainLogStream(logStream);\n-        });\n-    }\n-\n-    public static void withStackTraceStream(ThrowingRunnable<? extends Exception> action, PrintStream logStream) {\n-        withNewState(action, stateBuilder -> {\n-            stateBuilder.stackTraceStream(logStream);\n-        });\n-    }\n+    public static void withState(ThrowingRunnable<? extends Exception> action, Consumer<State.Builder> stateBuilderMutator) {\n+        Objects.requireNonNull(action);\n+        Objects.requireNonNull(stateBuilderMutator);\n@@ -140,2 +134,3 @@\n-    public static State state() {\n-        return STATE.get();\n+        var stateBuilder = state().buildCopy();\n+        stateBuilderMutator.accept(stateBuilder);\n+        withState(action, stateBuilder.create());\n@@ -144,2 +139,2 @@\n-    public static void state(State v) {\n-        STATE.set(Objects.requireNonNull(v));\n+    public static void withNewState(ThrowingRunnable<? extends Exception> action) {\n+        withState(action, _ -> {});\n@@ -148,1 +143,1 @@\n-    private static void withNewState(ThrowingRunnable<? extends Exception> action, Consumer<State.Builder> stateBuilderMutator) {\n+    public static void withState(ThrowingRunnable<? extends Exception> action, State state) {\n@@ -150,1 +145,3 @@\n-        Objects.requireNonNull(stateBuilderMutator);\n+        Objects.requireNonNull(state);\n+        ScopedValue.where(STATE, state).run(ThrowingRunnable.toRunnable(action));\n+    }\n@@ -152,10 +149,2 @@\n-        var oldState = state();\n-        var builder = oldState.buildCopy();\n-        stateBuilderMutator.accept(builder);\n-        var newState = builder.create();\n-        try {\n-            state(newState);\n-            ThrowingRunnable.toRunnable(action).run();\n-        } finally {\n-            state(oldState);\n-        }\n+    public static State state() {\n+        return STATE.orElse(DEFAULT_STATE);\n@@ -181,15 +170,9 @@\n-        withExtraLogStream(() -> {\n-            tests.stream().forEach(test -> {\n-                withNewState(() -> {\n-                    try {\n-                        if (modes.contains(RunTestMode.FAIL_FAST)) {\n-                            test.run();\n-                        } else {\n-                            ignoreExceptions(test).run();\n-                        }\n-                    } finally {\n-                        Optional.ofNullable(state().extraLogStream).ifPresent(PrintStream::flush);\n-                    }\n-                }, stateBuilder -> {\n-                    stateBuilder.currentTest(test);\n-                });\n+        tests.stream().forEach(test -> {\n+            withState(() -> {\n+                if (modes.contains(RunTestMode.FAIL_FAST)) {\n+                    test.run();\n+                } else {\n+                    ignoreExceptions(test).run();\n+                }\n+            }, stateBuilder -> {\n+                stateBuilder.currentTest(test);\n@@ -200,8 +183,0 @@\n-    static <T> T runAdhocTest(ThrowingSupplier<T, ? extends Exception> action) {\n-        final List<T> box = new ArrayList<>();\n-        runAdhocTest(() -> {\n-            box.add(action.get());\n-        });\n-        return box.getFirst();\n-    }\n-\n@@ -284,4 +259,1 @@\n-        state.mainLogStream.println(v);\n-        if (state.extraLogStream != null) {\n-            state.extraLogStream.println(v);\n-        }\n+        state.out.println(v);\n@@ -695,2 +667,1 @@\n-        Optional.ofNullable(state.extraLogStream).ifPresent(throwable::printStackTrace);\n-        throwable.printStackTrace(state.stackTraceStream);\n+        throwable.printStackTrace(state.err);\n@@ -1258,10 +1229,0 @@\n-    private static PrintStream openLogStream() {\n-        return state().logFile.map(logfile -> {\n-            try {\n-                return Files.newOutputStream(logfile, StandardOpenOption.CREATE, StandardOpenOption.APPEND);\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-            }\n-        }).map(PrintStream::new).orElse(null);\n-    }\n-\n@@ -1379,1 +1340,0 @@\n-                Optional<Path> logFile,\n@@ -1381,3 +1341,3 @@\n-                PrintStream mainLogStream,\n-                PrintStream stackTraceStream,\n-                PrintStream extraLogStream,\n+                PrintStream out,\n+                PrintStream err,\n+                Map<Object, Object> properties,\n@@ -1389,3 +1349,3 @@\n-            Objects.requireNonNull(logFile);\n-            Objects.requireNonNull(mainLogStream);\n-            Objects.requireNonNull(stackTraceStream);\n+            Objects.requireNonNull(out);\n+            Objects.requireNonNull(err);\n+            Objects.requireNonNull(properties);\n@@ -1393,1 +1353,0 @@\n-            this.logFile = logFile;\n@@ -1395,3 +1354,3 @@\n-            this.mainLogStream = mainLogStream;\n-            this.stackTraceStream = stackTraceStream;\n-            this.extraLogStream = extraLogStream;\n+            this.out = out;\n+            this.err = err;\n+            this.properties = Collections.synchronizedMap(properties);\n@@ -1406,1 +1365,0 @@\n-\n@@ -1411,0 +1369,20 @@\n+        PrintStream out() {\n+            return out;\n+        }\n+\n+        PrintStream err() {\n+            return err;\n+        }\n+\n+        Optional<Object> findProperty(Object key) {\n+            return Optional.ofNullable(properties.get(Objects.requireNonNull(key)));\n+        }\n+\n+        void setProperty(Object key, Object value) {\n+            if (value == null) {\n+                properties.remove(Objects.requireNonNull(key));\n+            } else {\n+                properties.put(Objects.requireNonNull(key), value);\n+            }\n+        }\n+\n@@ -1419,1 +1397,0 @@\n-                logFile = Optional.ofNullable(getConfigProperty(\"logfile\")).map(Path::of);\n@@ -1421,3 +1398,2 @@\n-                mainLogStream = System.out;\n-                stackTraceStream = System.err;\n-                extraLogStream = null;\n+                out = System.out;\n+                err = System.err;\n@@ -1447,0 +1423,2 @@\n+                mutable = true;\n+\n@@ -1451,1 +1429,0 @@\n-                logFile = state.logFile;\n@@ -1453,3 +1430,4 @@\n-                mainLogStream = state.mainLogStream;\n-                stackTraceStream = state.stackTraceStream;\n-                extraLogStream = state.extraLogStream;\n+                out = state.out;\n+                err = state.err;\n+                properties.clear();\n+                properties.putAll(state.properties);\n@@ -1466,2 +1444,2 @@\n-            Builder logFile(Optional<Path> v) {\n-                logFile = v;\n+            Builder currentTest(TestInstance v) {\n+                currentTest = v;\n@@ -1471,2 +1449,2 @@\n-            Builder currentTest(TestInstance v) {\n-                currentTest = v;\n+            Builder out(PrintStream v) {\n+                out = v;\n@@ -1476,2 +1454,2 @@\n-            Builder mainLogStream(PrintStream v) {\n-                mainLogStream = v;\n+            Builder err(PrintStream v) {\n+                err = v;\n@@ -1481,2 +1459,6 @@\n-            Builder stackTraceStream(PrintStream v) {\n-                stackTraceStream = v;\n+            Builder property(Object key, Object value) {\n+                if (value == null) {\n+                    properties.remove(Objects.requireNonNull(key));\n+                } else {\n+                    properties.put(Objects.requireNonNull(key), value);\n+                }\n@@ -1486,2 +1468,2 @@\n-            Builder extraLogStream(PrintStream v) {\n-                extraLogStream = v;\n+            Builder mutable(boolean v) {\n+                mutable = v;\n@@ -1492,1 +1474,9 @@\n-                return new State(logFile, currentTest, mainLogStream, stackTraceStream, extraLogStream, trace, traceAsserts, verboseJPackage, verboseTestSetup);\n+                return new State(\n+                        currentTest,\n+                        out,\n+                        err,\n+                        mutable ? new HashMap<>(properties) : Map.copyOf(properties),\n+                        trace,\n+                        traceAsserts,\n+                        verboseJPackage,\n+                        verboseTestSetup);\n@@ -1495,1 +1485,0 @@\n-            private Optional<Path> logFile;\n@@ -1497,3 +1486,3 @@\n-            private PrintStream mainLogStream;\n-            private PrintStream stackTraceStream;\n-            private PrintStream extraLogStream;\n+            private PrintStream out;\n+            private PrintStream err;\n+            private Map<Object, Object> properties = new HashMap<>();\n@@ -1506,0 +1495,2 @@\n+\n+            private boolean mutable = true;\n@@ -1509,1 +1500,0 @@\n-        private final Optional<Path> logFile;\n@@ -1511,3 +1501,4 @@\n-        private final PrintStream mainLogStream;\n-        private final PrintStream stackTraceStream;\n-        private final PrintStream extraLogStream;\n+        private final PrintStream out;\n+        private final PrintStream err;\n+\n+        private final Map<Object, Object> properties;\n@@ -1523,6 +1514,2 @@\n-    private static final InheritableThreadLocal<State> STATE = new InheritableThreadLocal<>() {\n-        @Override\n-        protected State initialValue() {\n-            return State.build().initDefaults().create();\n-        }\n-    };\n+    private static final ScopedValue<State> STATE = ScopedValue.newInstance();\n+    private static final State DEFAULT_STATE = State.build().initDefaults().mutable(false).create();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":112,"deletions":125,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,1 +203,2 @@\n-                JPackageCommand.withToolProvider(() -> {\n+                TKit.withNewState(() -> {\n+                    JPackageCommand.useToolProviderByDefault(jpackageToolProviderMock);\n@@ -209,1 +210,1 @@\n-                }, jpackageToolProviderMock);\n+                });\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsValidationFailTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -37,0 +36,1 @@\n+import jdk.jpackage.internal.util.TeeOutputStream;\n@@ -73,3 +73,7 @@\n-        try (PrintStream ps = new PrintStream(buf, true, StandardCharsets.UTF_8)) {\n-            TKit.withExtraLogStream(runnable, ps);\n-        }\n+        var ps = new PrintStream(buf, false, TKit.state().out().charset());\n+\n+        final var out = new PrintStream(new TeeOutputStream(List.of(TKit.state().out(), ps)), true, ps.charset());\n+\n+        TKit.withOutput(runnable, out, TKit.state().err());\n+\n+        ps.flush();\n@@ -78,1 +82,1 @@\n-                final var reader = new InputStreamReader(in, StandardCharsets.UTF_8);\n+                final var reader = new InputStreamReader(in, ps.charset());\n","filename":"test\/jdk\/tools\/jpackage\/junit\/tools\/jdk\/jpackage\/test\/JUnitAdapter.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.io.PrintWriter;\n@@ -37,1 +36,0 @@\n-import java.util.spi.ToolProvider;\n@@ -39,1 +37,0 @@\n-import jdk.jpackage.internal.util.function.ThrowingRunnable;\n@@ -45,1 +42,0 @@\n-import jdk.jpackage.test.JavaTool;\n@@ -69,1 +65,1 @@\n-        APP_JAR.set(HelloApp.createBundle(JavaAppDesc.parse(\"Hello!\"), TKit.workDir()));\n+        var appJar = HelloApp.createBundle(JavaAppDesc.parse(\"Hello!\"), TKit.workDir());\n@@ -72,1 +68,1 @@\n-        \/\/ Run test cases from InternalAsyncTest class asynchronously.\n+        \/\/ Run test cases from AsyncInnerTest class asynchronously.\n@@ -82,2 +78,0 @@\n-            var runArg = String.format(\"--jpt-run=%s\", AsyncInnerTest.class.getName());\n-\n@@ -87,3 +81,1 @@\n-                    consumer.accept(new Workload(() -> {\n-                        Main.main(runArg, String.format(\"--jpt-include=%s\", id));\n-                    }, id));\n+                    consumer.accept(new Workload(id, appJar));\n@@ -102,4 +94,2 @@\n-                TKit.trace(String.format(\"[%s] STDOUT BEGIN\\n%s\", result.id(), result.stdoutBuffer()));\n-                TKit.trace(String.format(\"[%s] STDOUT END\", result.id()));\n-                TKit.trace(String.format(\"[%s] STDERR BEGIN\\n%s\", result.id(), result.stderrBuffer()));\n-                TKit.trace(String.format(\"[%s] STDERR END\", result.id()));\n+                TKit.trace(String.format(\"[%s] OUTPUT BEGIN\\n%s\", result.testCaseId(), result.testOutput()));\n+                TKit.trace(String.format(\"[%s] OUTPUT END\", result.testCaseId()));\n@@ -145,1 +135,1 @@\n-    private record Result(String stdoutBuffer, String stderrBuffer, String id, Optional<Exception> exception) {\n+    private record Result(String testOutput, String testCaseId, Optional<Exception> exception) {\n@@ -148,3 +138,2 @@\n-            Objects.requireNonNull(stdoutBuffer);\n-            Objects.requireNonNull(stderrBuffer);\n-            Objects.requireNonNull(id);\n+            Objects.requireNonNull(testOutput);\n+            Objects.requireNonNull(testCaseId);\n@@ -157,4 +146,3 @@\n-            ByteArrayOutputStream stdoutBuffer,\n-            ByteArrayOutputStream stderrBuffer,\n-            ThrowingRunnable<? extends Exception> runnable,\n-            String id) implements Callable<Result>  {\n+            String testCaseId,\n+            ByteArrayOutputStream outputSink,\n+            Path appJar) implements Callable<Result> {\n@@ -163,8 +151,3 @@\n-            Objects.requireNonNull(stdoutBuffer);\n-            Objects.requireNonNull(stderrBuffer);\n-            Objects.requireNonNull(runnable);\n-            Objects.requireNonNull(id);\n-        }\n-\n-        Workload(ThrowingRunnable<? extends Exception> runnable, String id) {\n-            this(new ByteArrayOutputStream(), new ByteArrayOutputStream(), runnable, id);\n+            Objects.requireNonNull(testCaseId);\n+            Objects.requireNonNull(outputSink);\n+            Objects.requireNonNull(appJar);\n@@ -173,2 +156,2 @@\n-        private String stdoutBufferAsString() {\n-            return new String(stdoutBuffer.toByteArray(), StandardCharsets.UTF_8);\n+        Workload(String testCaseId, Path appJar) {\n+            this(testCaseId, new ByteArrayOutputStream(), appJar);\n@@ -177,2 +160,2 @@\n-        private String stderrBufferAsString() {\n-            return new String(stderrBuffer.toByteArray(), StandardCharsets.UTF_8);\n+        private String testOutput() {\n+            return new String(outputSink.toByteArray(), StandardCharsets.UTF_8);\n@@ -183,20 +166,1 @@\n-            \/\/ Reset the current test inherited in the state from the parent thread.\n-            TKit.state(DEFAULT_STATE);\n-\n-            var defaultToolProvider = JavaTool.JPACKAGE.asToolProvider();\n-\n-            JPackageCommand.useToolProviderByDefault(new ToolProvider() {\n-\n-                @Override\n-                public int run(PrintWriter out, PrintWriter err, String... args) {\n-                    try (var bufOut = new PrintWriter(stdoutBuffer, true, StandardCharsets.UTF_8);\n-                            var bufErr = new PrintWriter(stderrBuffer, true, StandardCharsets.UTF_8)) {\n-                        return defaultToolProvider.run(bufOut, bufErr, args);\n-                    }\n-                }\n-\n-                @Override\n-                public String name() {\n-                    return defaultToolProvider.name();\n-                }\n-            });\n+            var runArg = String.format(\"--jpt-run=%s\", AsyncInnerTest.class.getName());\n@@ -205,5 +169,9 @@\n-            try (var bufOut = new PrintStream(stdoutBuffer, true, StandardCharsets.UTF_8);\n-                    var bufErr = new PrintStream(stderrBuffer, true, StandardCharsets.UTF_8)) {\n-                TKit.withStackTraceStream(() -> {\n-                    TKit.withMainLogStream(runnable, bufOut);\n-                }, bufErr);\n+            try {\n+                try (var out = new PrintStream(outputSink, false, System.out.charset())) {\n+                    ScopedValue.where(APP_JAR, appJar).run(() -> {\n+                        TKit.withOutput(() -> {\n+                            JPackageCommand.useToolProviderByDefault();\n+                            Main.main(\"--jpt-ignore-logfile\", runArg, String.format(\"--jpt-include=%s\", testCaseId));\n+                        }, out, out);\n+                    });\n+                }\n@@ -213,1 +181,1 @@\n-            return new Result(stdoutBufferAsString(), stderrBufferAsString(), id, err);\n+            return new Result(testOutput(), testCaseId, err);\n@@ -217,1 +185,0 @@\n-\n@@ -219,2 +186,1 @@\n-    private static final TKit.State DEFAULT_STATE = TKit.state();\n-    private static final InheritableThreadLocal<Path> APP_JAR = new InheritableThreadLocal<>();\n+    private static final ScopedValue<Path> APP_JAR = ScopedValue.newInstance();\n","filename":"test\/jdk\/tools\/jpackage\/share\/AsyncTest.java","additions":31,"deletions":65,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-import jdk.tools.jlink.internal.LinkableRuntimeImage;\n+\/\/import jdk.tools.jlink.internal.LinkableRuntimeImage;\n@@ -84,1 +84,1 @@\n-        if (LinkableRuntimeImage.isLinkableRuntime() && noJmods) {\n+        if (noJmods) {\n","filename":"test\/jdk\/tools\/jpackage\/share\/BasicTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+        var state = TKit.state();\n@@ -63,1 +64,3 @@\n-            HelloApp.assertMainLauncher(cmd).get().processListener(f::complete).execute();\n+            TKit.withState(() -> {\n+                HelloApp.assertMainLauncher(cmd).get().processListener(f::complete).execute();\n+            }, state);\n","filename":"test\/jdk\/tools\/jpackage\/windows\/Win8301247Test.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+            var state = TKit.state();\n@@ -102,1 +103,3 @@\n-                HelloApp.assertMainLauncher(cmd).get().processListener(f::complete).execute();\n+                TKit.withState(() -> {\n+                    HelloApp.assertMainLauncher(cmd).get().processListener(f::complete).execute();\n+                }, state);\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinNoRestartTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}