{"files":[{"patch":"@@ -1,484 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * @test\n- * @key headful\n- * @bug 6514990 8198613\n- * @summary Verifies that calling\n- * Graphics2D.drawImage(BufferedImage, BufferedImageOp, x, y) to an\n- * accelerated destination produces the same results when performed\n- * in software via BufferedImageOp.filter().\n- * @run main\/othervm DrawBufImgOp -ignore\n- * @author campbelc\n- *\/\n-\n-import java.awt.*;\n-import java.awt.image.*;\n-import java.io.File;\n-import javax.imageio.ImageIO;\n-\n-\/**\n- * REMIND: This testcase was originally intended to automatically compare\n- * the results of the software BufferedImageOp implementations against\n- * the OGL-accelerated codepaths.  However, there are just too many open\n- * bugs in the mediaLib-based codepaths (see below), which means that\n- * creating the reference image may cause crashes or exceptions,\n- * and even if we work around those cases using the \"-ignore\" flag,\n- * the visual results of the reference image are often buggy as well\n- * (so the comparison will fail even though the OGL results are correct).\n- * Therefore, for now we will run the testcase with the \"-ignore\" flag\n- * but without the \"-compare\" flag, so at least it will be checking for\n- * any exceptions\/crashes in the OGL code.  When we fix all of the\n- * outstanding bugs with the software codepaths, we can remove the\n- * \"-ignore\" flag and maybe even restore the \"-compare\" flag.  In the\n- * meantime, it stil functions well as a manual testcase (with either\n- * the \"-show\" or \"-dump\" options).\n- *\/\n-public class DrawBufImgOp extends Canvas {\n-\n-    private static final int TESTW = 600;\n-    private static final int TESTH = 500;\n-    private static boolean done;\n-\n-    \/*\n-     * If true, skips tests that are known to trigger bugs (which in\n-     * turn may cause crashes, exceptions, or other artifacts).\n-     *\/\n-    private static boolean ignore;\n-\n-    \/\/ Test both pow2 and non-pow2 sized images\n-    private static final int[] srcSizes = { 32, 17 };\n-    private static final int[] srcTypes = {\n-        BufferedImage.TYPE_INT_RGB,\n-        BufferedImage.TYPE_INT_ARGB,\n-        BufferedImage.TYPE_INT_ARGB_PRE,\n-        BufferedImage.TYPE_INT_BGR,\n-        BufferedImage.TYPE_3BYTE_BGR,\n-        BufferedImage.TYPE_4BYTE_ABGR,\n-        BufferedImage.TYPE_USHORT_565_RGB,\n-        BufferedImage.TYPE_BYTE_GRAY,\n-        BufferedImage.TYPE_USHORT_GRAY,\n-    };\n-\n-    private static final RescaleOp\n-        rescale1band, rescale3band, rescale4band;\n-    private static final LookupOp\n-        lookup1bandbyte, lookup3bandbyte, lookup4bandbyte;\n-    private static final LookupOp\n-        lookup1bandshort, lookup3bandshort, lookup4bandshort;\n-    private static final ConvolveOp\n-        convolve3x3zero, convolve5x5zero, convolve7x7zero;\n-    private static final ConvolveOp\n-        convolve3x3noop, convolve5x5noop, convolve7x7noop;\n-\n-    static {\n-        rescale1band = new RescaleOp(0.5f, 10.0f, null);\n-        rescale3band = new RescaleOp(\n-            new float[] {  0.6f,  0.4f, 0.6f },\n-            new float[] { 10.0f, -3.0f, 5.0f },\n-            null);\n-        rescale4band = new RescaleOp(\n-            new float[] {  0.6f, 0.4f, 0.6f, 0.9f },\n-            new float[] { -1.0f, 5.0f, 3.0f, 1.0f },\n-            null);\n-\n-        \/\/ REMIND: we should probably test non-zero offsets, but that\n-        \/\/ would require massaging the source image data to avoid going\n-        \/\/ outside the lookup table array bounds\n-        int offset = 0;\n-        {\n-            byte invert[] = new byte[256];\n-            byte halved[] = new byte[256];\n-            for (int j = 0; j < 256 ; j++) {\n-                invert[j] = (byte) (255-j);\n-                halved[j] = (byte) (j \/ 2);\n-            }\n-            ByteLookupTable lut1 = new ByteLookupTable(offset, invert);\n-            lookup1bandbyte = new LookupOp(lut1, null);\n-            ByteLookupTable lut3 =\n-                new ByteLookupTable(offset,\n-                                    new byte[][] {invert, halved, invert});\n-            lookup3bandbyte = new LookupOp(lut3, null);\n-            ByteLookupTable lut4 =\n-                new ByteLookupTable(offset,\n-                               new byte[][] {invert, halved, invert, halved});\n-            lookup4bandbyte = new LookupOp(lut4, null);\n-        }\n-\n-        {\n-            short invert[] = new short[256];\n-            short halved[] = new short[256];\n-            for (int j = 0; j < 256 ; j++) {\n-                invert[j] = (short) ((255-j) * 255);\n-                halved[j] = (short) ((j \/ 2) * 255);\n-            }\n-            ShortLookupTable lut1 = new ShortLookupTable(offset, invert);\n-            lookup1bandshort = new LookupOp(lut1, null);\n-            ShortLookupTable lut3 =\n-                new ShortLookupTable(offset,\n-                                     new short[][] {invert, halved, invert});\n-            lookup3bandshort = new LookupOp(lut3, null);\n-            ShortLookupTable lut4 =\n-                new ShortLookupTable(offset,\n-                              new short[][] {invert, halved, invert, halved});\n-            lookup4bandshort = new LookupOp(lut4, null);\n-        }\n-\n-        \/\/ 3x3 blur\n-        float[] data3 = {\n-            0.1f, 0.1f, 0.1f,\n-            0.1f, 0.2f, 0.1f,\n-            0.1f, 0.1f, 0.1f,\n-        };\n-        Kernel k3 = new Kernel(3, 3, data3);\n-\n-        \/\/ 5x5 edge\n-        float[] data5 = {\n-            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,\n-            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,\n-            -1.0f, -1.0f, 24.0f, -1.0f, -1.0f,\n-            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,\n-            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,\n-        };\n-        Kernel k5 = new Kernel(5, 5, data5);\n-\n-        \/\/ 7x7 blur\n-        float[] data7 = {\n-            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n-            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n-            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n-            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n-            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n-            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n-            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n-        };\n-        Kernel k7 = new Kernel(7, 7, data7);\n-\n-        convolve3x3zero = new ConvolveOp(k3, ConvolveOp.EDGE_ZERO_FILL, null);\n-        convolve5x5zero = new ConvolveOp(k5, ConvolveOp.EDGE_ZERO_FILL, null);\n-        convolve7x7zero = new ConvolveOp(k7, ConvolveOp.EDGE_ZERO_FILL, null);\n-\n-        convolve3x3noop = new ConvolveOp(k3, ConvolveOp.EDGE_NO_OP, null);\n-        convolve5x5noop = new ConvolveOp(k5, ConvolveOp.EDGE_NO_OP, null);\n-        convolve7x7noop = new ConvolveOp(k7, ConvolveOp.EDGE_NO_OP, null);\n-    }\n-\n-    public void paint(Graphics g) {\n-        synchronized (this) {\n-            if (done) {\n-                return;\n-            }\n-        }\n-\n-        VolatileImage vimg = createVolatileImage(TESTW, TESTH);\n-        vimg.validate(getGraphicsConfiguration());\n-\n-        Graphics2D g2d = vimg.createGraphics();\n-        renderTest(g2d);\n-        g2d.dispose();\n-\n-        g.drawImage(vimg, 0, 0, null);\n-\n-        Toolkit.getDefaultToolkit().sync();\n-\n-        synchronized (this) {\n-            done = true;\n-            notifyAll();\n-        }\n-    }\n-\n-    \/*\n-     * foreach source image size (once with pow2, once with non-pow2)\n-     *\n-     *   foreach BufferedImage type\n-     *\n-     *     RescaleOp (1 band)\n-     *     RescaleOp (3 bands, if src has 3 bands)\n-     *     RescaleOp (4 bands, if src has 4 bands)\n-     *\n-     *     foreach LookupTable type (once with ByteLUT, once with ShortLUT)\n-     *       LookupOp (1 band)\n-     *       LookupOp (3 bands, if src has 3 bands)\n-     *       LookupOp (4 bands, if src has 4 bands)\n-     *\n-     *     foreach edge condition (once with ZERO_FILL, once with EDGE_NO_OP)\n-     *       ConvolveOp (3x3)\n-     *       ConvolveOp (5x5)\n-     *       ConvolveOp (7x7)\n-     *\/\n-    private void renderTest(Graphics2D g2d) {\n-        g2d.setColor(Color.white);\n-        g2d.fillRect(0, 0, TESTW, TESTH);\n-\n-        int yorig = 2;\n-        int xinc = 34;\n-        int yinc = srcSizes[0] + srcSizes[1] + 2 + 2;\n-\n-        for (int srcType : srcTypes) {\n-            int y = yorig;\n-\n-            for (int srcSize : srcSizes) {\n-                int x = 2;\n-                System.out.printf(\"type=%d size=%d\\n\", srcType, srcSize);\n-\n-                BufferedImage srcImg = makeSourceImage(srcSize, srcType);\n-                ColorModel srcCM = srcImg.getColorModel();\n-\n-                \/\/ RescaleOp\n-                g2d.drawImage(srcImg, rescale1band, x, y);\n-                x += xinc;\n-                \/\/ REMIND: 3-band RescaleOp.filter() throws IAE for images\n-                \/\/         that contain an alpha channel (bug to be filed)\n-                if (srcCM.getNumColorComponents() == 3 &&\n-                    !(ignore && srcCM.hasAlpha()))\n-                {\n-                    g2d.drawImage(srcImg, rescale3band, x, y);\n-                }\n-                x += xinc;\n-                if (srcCM.getNumComponents() == 4) {\n-                    g2d.drawImage(srcImg, rescale4band, x, y);\n-                }\n-                x += xinc;\n-\n-                \/\/ LookupOp\n-                \/\/ REMIND: Our LUTs are only 256 elements long, so won't\n-                \/\/         currently work with USHORT_GRAY data\n-                if (srcType != BufferedImage.TYPE_USHORT_GRAY) {\n-                    g2d.drawImage(srcImg, lookup1bandbyte, x, y);\n-                    x += xinc;\n-                    if (srcCM.getNumColorComponents() == 3) {\n-                        g2d.drawImage(srcImg, lookup3bandbyte, x, y);\n-                    }\n-                    x += xinc;\n-                    if (srcCM.getNumComponents() == 4) {\n-                        g2d.drawImage(srcImg, lookup4bandbyte, x, y);\n-                    }\n-                    x += xinc;\n-\n-                    \/\/ REMIND: LookupOp.createCompatibleDestImage() throws\n-                    \/\/         IAE for 3BYTE_BGR\/4BYTE_ABGR (bug to be filed)\n-                    if (!(ignore &&\n-                          (srcType == BufferedImage.TYPE_3BYTE_BGR ||\n-                           srcType == BufferedImage.TYPE_4BYTE_ABGR)))\n-                    {\n-                        g2d.drawImage(srcImg, lookup1bandshort, x, y);\n-                        x += xinc;\n-                        \/\/ REMIND: 3-band LookupOp.filter() throws IAE for\n-                        \/\/         images that contain an alpha channel\n-                        \/\/         (bug to be filed)\n-                        if (srcCM.getNumColorComponents() == 3 &&\n-                            !(ignore && srcCM.hasAlpha()))\n-                        {\n-                            g2d.drawImage(srcImg, lookup3bandshort, x, y);\n-                        }\n-                        x += xinc;\n-                        if (srcCM.getNumComponents() == 4) {\n-                            g2d.drawImage(srcImg, lookup4bandshort, x, y);\n-                        }\n-                        x += xinc;\n-                    } else {\n-                        x += 3*xinc;\n-                    }\n-                } else {\n-                    x += 6*xinc;\n-                }\n-\n-                \/\/ ConvolveOp\n-                \/\/ REMIND: ConvolveOp.filter() throws ImagingOpException\n-                \/\/         for 3BYTE_BGR (see 4957775)\n-                if (srcType != BufferedImage.TYPE_3BYTE_BGR) {\n-                    g2d.drawImage(srcImg, convolve3x3zero, x, y);\n-                    x += xinc;\n-                    g2d.drawImage(srcImg, convolve5x5zero, x, y);\n-                    x += xinc;\n-                    g2d.drawImage(srcImg, convolve7x7zero, x, y);\n-                    x += xinc;\n-\n-                    g2d.drawImage(srcImg, convolve3x3noop, x, y);\n-                    x += xinc;\n-                    g2d.drawImage(srcImg, convolve5x5noop, x, y);\n-                    x += xinc;\n-                    g2d.drawImage(srcImg, convolve7x7noop, x, y);\n-                    x += xinc;\n-                } else {\n-                    x += 6*xinc;\n-                }\n-\n-                y += srcSize + 2;\n-            }\n-\n-            yorig += yinc;\n-        }\n-    }\n-\n-    private BufferedImage makeSourceImage(int size, int type) {\n-        int s2 = size\/2;\n-        BufferedImage img = new BufferedImage(size, size, type);\n-        Graphics2D g2d = img.createGraphics();\n-        g2d.setComposite(AlphaComposite.Src);\n-        g2d.setColor(Color.orange);\n-        g2d.fillRect(0, 0, size, size);\n-        g2d.setColor(Color.red);\n-        g2d.fillRect(0, 0, s2, s2);\n-        g2d.setColor(Color.green);\n-        g2d.fillRect(s2, 0, s2, s2);\n-        g2d.setColor(Color.blue);\n-        g2d.fillRect(0, s2, s2, s2);\n-        g2d.setColor(new Color(255, 255, 0, 128));\n-        g2d.fillRect(s2, s2, s2, s2);\n-        g2d.setColor(Color.pink);\n-        g2d.fillOval(s2-3, s2-3, 6, 6);\n-        g2d.dispose();\n-        return img;\n-    }\n-\n-    public BufferedImage makeReferenceImage() {\n-        BufferedImage img = new BufferedImage(TESTW, TESTH,\n-                                              BufferedImage.TYPE_INT_RGB);\n-        Graphics2D g2d = img.createGraphics();\n-        renderTest(g2d);\n-        g2d.dispose();\n-        return img;\n-    }\n-\n-    public Dimension getPreferredSize() {\n-        return new Dimension(TESTW, TESTH);\n-    }\n-\n-    private static void compareImages(BufferedImage refImg,\n-                                      BufferedImage testImg,\n-                                      int tolerance)\n-    {\n-        int x1 = 0;\n-        int y1 = 0;\n-        int x2 = refImg.getWidth();\n-        int y2 = refImg.getHeight();\n-\n-        for (int y = y1; y < y2; y++) {\n-            for (int x = x1; x < x2; x++) {\n-                Color expected = new Color(refImg.getRGB(x, y));\n-                Color actual   = new Color(testImg.getRGB(x, y));\n-                if (!isSameColor(expected, actual, tolerance)) {\n-                    throw new RuntimeException(\"Test failed at x=\"+x+\" y=\"+y+\n-                                               \" (expected=\"+expected+\n-                                               \" actual=\"+actual+\n-                                               \")\");\n-                }\n-            }\n-        }\n-    }\n-\n-    private static boolean isSameColor(Color c1, Color c2, int e) {\n-        int r1 = c1.getRed();\n-        int g1 = c1.getGreen();\n-        int b1 = c1.getBlue();\n-        int r2 = c2.getRed();\n-        int g2 = c2.getGreen();\n-        int b2 = c2.getBlue();\n-        int rmin = Math.max(r2-e, 0);\n-        int gmin = Math.max(g2-e, 0);\n-        int bmin = Math.max(b2-e, 0);\n-        int rmax = Math.min(r2+e, 255);\n-        int gmax = Math.min(g2+e, 255);\n-        int bmax = Math.min(b2+e, 255);\n-        if (r1 >= rmin && r1 <= rmax &&\n-            g1 >= gmin && g1 <= gmax &&\n-            b1 >= bmin && b1 <= bmax)\n-        {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        boolean show = false;\n-        boolean dump = false;\n-        boolean compare = false;\n-\n-        for (String arg : args) {\n-            if (arg.equals(\"-show\")) {\n-                show = true;\n-            } else if (arg.equals(\"-dump\")) {\n-                dump = true;\n-            } else if (arg.equals(\"-compare\")) {\n-                compare = true;\n-            } else if (arg.equals(\"-ignore\")) {\n-                ignore = true;\n-            }\n-        }\n-\n-        DrawBufImgOp test = new DrawBufImgOp();\n-        Frame frame = new Frame();\n-        frame.add(test);\n-        frame.pack();\n-        frame.setVisible(true);\n-\n-        \/\/ Wait until the component's been painted\n-        synchronized (test) {\n-            while (!done) {\n-                try {\n-                    test.wait();\n-                } catch (InterruptedException e) {\n-                    throw new RuntimeException(\"Failed: Interrupted\");\n-                }\n-            }\n-        }\n-\n-        GraphicsConfiguration gc = frame.getGraphicsConfiguration();\n-        if (gc.getColorModel() instanceof IndexColorModel) {\n-            System.out.println(\"IndexColorModel detected: \" +\n-                               \"test considered PASSED\");\n-            frame.dispose();\n-            return;\n-        }\n-\n-        \/\/ Grab the screen region\n-        BufferedImage capture = null;\n-        try {\n-            Robot robot = new Robot();\n-            Point pt1 = test.getLocationOnScreen();\n-            Rectangle rect = new Rectangle(pt1.x, pt1.y, TESTW, TESTH);\n-            capture = robot.createScreenCapture(rect);\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"Problems creating Robot\");\n-        } finally {\n-            if (!show) {\n-                frame.dispose();\n-            }\n-        }\n-\n-        \/\/ Compare the images (allow for +\/- 1 bit differences in color comps)\n-        if (dump || compare) {\n-            BufferedImage ref = test.makeReferenceImage();\n-            if (dump) {\n-                ImageIO.write(ref,     \"png\",\n-                              new File(\"DrawBufImgOp.ref.png\"));\n-                ImageIO.write(capture, \"png\",\n-                              new File(\"DrawBufImgOp.cap.png\"));\n-            }\n-            if (compare) {\n-                test.compareImages(ref, capture, 1);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/image\/VolatileImage\/DrawBufImgOp.java","additions":0,"deletions":484,"binary":false,"changes":484,"status":"deleted"}]}