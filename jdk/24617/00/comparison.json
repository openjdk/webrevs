{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1814,1 +1814,1 @@\n-                    error();\n+                    commonSuperClass(t, tother);\n@@ -1823,2 +1823,9 @@\n-        Type error() {\n-            throw new AssertionError(\"inconsistent stack types at join point\");\n+        private Type commonSuperClass(Type t1, Type t2) {\n+            Type lub = types.lub(t1, t2);\n+\n+            if (lub.hasTag(BOT)) {\n+                throw Assert.error(\"Cannot find a common super class of: \" +\n+                                   t1 + \" and \" + t2);\n+            }\n+\n+            return types.erasure(lub);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1856,1 +1856,0 @@\n-                code.state.forceStackTop(tree.target.type);\n@@ -1972,1 +1971,0 @@\n-            code.state.forceStackTop(tree.type);\n@@ -1982,1 +1980,0 @@\n-            code.state.forceStackTop(tree.type);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8214031 8214114 8236546\n+ * @bug 8214031 8214114 8236546 8353565\n@@ -35,0 +35,1 @@\n+        new ExpressionSwitchEmbedding().runStackMapMergingTest();\n@@ -333,0 +334,104 @@\n+    private void runStackMapMergingTest() {\n+        \/\/JDK-8353565: verify that two types neither of which is a subtype of the other\n+        \/\/can be merged while computing StackMaps.\n+        if (!(computeTypeAtMergePoint1(E.A, E.A) instanceof Impl1a)) {\n+            throw new AssertionError(\"Unexpected result\");\n+        }\n+        if (runMethodForInterfaceTypeAtMergePoint1(E.A, E.A) != 1) {\n+            throw new AssertionError(\"Unexpected result\");\n+        }\n+        if (runMethodForInterfaceTypeAtMergePoint2(E.A, E.A) != 2) {\n+            throw new AssertionError(\"Unexpected result\");\n+        }\n+    }\n+\n+    private Root computeTypeAtMergePoint1(E e1, E e2) {\n+        return (Root) switch (e1) {\n+            case A -> switch (e2) {\n+                case A -> new Impl1a();\n+                case B -> new Impl1b();\n+                case C -> new Impl1c();\n+            };\n+            case B -> switch (e2) {\n+                case A -> new Impl2a();\n+                case B -> new Impl2b();\n+                case C -> new Impl2c();\n+            };\n+            case C -> switch (e2) {\n+                case A -> new Impl3a();\n+                case B -> new Impl3b();\n+                case C -> new Impl3c();\n+            };\n+        };\n+    }\n+\n+    private int runMethodForInterfaceTypeAtMergePoint1(E e1, E e2) {\n+        return (switch (e1) {\n+            case A -> switch (e2) {\n+                case A -> new C1();\n+                case B -> new C1();\n+                case C -> new C1();\n+            };\n+            case B -> switch (e2) {\n+                case A -> new C2();\n+                case B -> new C2();\n+                case C -> new C2();\n+            };\n+            case C -> switch (e2) {\n+                case A -> new C3();\n+                case B -> new C3();\n+                case C -> new C3();\n+            };\n+        }).test1();\n+    }\n+\n+    private int runMethodForInterfaceTypeAtMergePoint2(E e1, E e2) {\n+        return (switch (e1) {\n+            case A -> switch (e2) {\n+                case A -> new C1();\n+                case B -> new C1();\n+                case C -> new C1();\n+            };\n+            case B -> switch (e2) {\n+                case A -> new C2();\n+                case B -> new C2();\n+                case C -> new C2();\n+            };\n+            case C -> switch (e2) {\n+                case A -> new C3();\n+                case B -> new C3();\n+                case C -> new C3();\n+            };\n+        }).test2();\n+    }\n+\n+    private static class Root {}\n+    private static class Base1 extends Root {}\n+    private static class Impl1a extends Base1 {}\n+    private static class Impl1b extends Base1 {}\n+    private static class Impl1c extends Base1 {}\n+    private static class Base2 extends Root {}\n+    private static class Impl2a extends Base2 {}\n+    private static class Impl2b extends Base2 {}\n+    private static class Impl2c extends Base2 {}\n+    private static class Base3 extends Root {}\n+    private static class Impl3a extends Base3 {}\n+    private static class Impl3b extends Base3 {}\n+    private static class Impl3c extends Base3 {}\n+\n+    private static interface RootInterface1 {\n+        public default int test1() {\n+            return 1;\n+        }\n+    }\n+    private static interface RootInterface2 {\n+        public default int test2() {\n+            return 2;\n+        }\n+    }\n+    private static class C1 implements RootInterface1, RootInterface2 {}\n+    private static class C2 implements RootInterface1, RootInterface2 {}\n+    private static class C3 implements RootInterface1, RootInterface2 {}\n+\n+    enum E {A, B, C;}\n+\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExpressionSwitchEmbedding.java","additions":107,"deletions":2,"binary":false,"changes":109,"status":"modified"}]}