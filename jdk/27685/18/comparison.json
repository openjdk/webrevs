{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"sanitizers\/address.hpp\"\n@@ -89,1 +90,0 @@\n-\n@@ -113,3 +113,9 @@\n-  uint8_t* footer_address() const   { return ((address)this) + sizeof(MallocHeader) + _size; }\n-  uint16_t get_footer() const       { return build_footer(footer_address()[0], footer_address()[1]); }\n-  void set_footer(uint16_t v)       { footer_address()[0] = (uint8_t)(v >> 8); footer_address()[1] = (uint8_t)v; }\n+  uint16_t get_footer() const {\n+    AsanPoisoningHelper aph(reinterpret_cast<uint16_t*>(footer_address()));\n+    return build_footer(footer_address()[0], footer_address()[1]);\n+  }\n+\n+  void set_footer(uint16_t v) {\n+    AsanPoisoningHelper aph(reinterpret_cast<uint16_t*>(footer_address()));\n+    footer_address()[0] = (uint8_t)(v >> 8); footer_address()[1] = (uint8_t)v;\n+  }\n@@ -120,0 +126,36 @@\n+  void asan_poison_self() {\n+      AsanPoisoningHelper<uint16_t>::poison_memory(&_canary);\n+      AsanPoisoningHelper<uint16_t>::poison_memory(reinterpret_cast<uint16_t*>(footer_address()));\n+      AsanPoisoningHelper<size_t>::poison_memory(&_size);\n+      NOT_LP64(AsanPoisoningHelper<uint32_t>::poison_memory(&_alt_canary));\n+  }\n+\n+  void asan_unpoison_self() {\n+      AsanPoisoningHelper<uint16_t>::unpoison_memory(&_canary);\n+      AsanPoisoningHelper<uint16_t>::unpoison_memory(reinterpret_cast<uint16_t*>(footer_address()));\n+      AsanPoisoningHelper<size_t>::unpoison_memory(&_size);\n+      NOT_LP64(AsanPoisoningHelper<uint32_t>::unpoison_memory(&_alt_canary));\n+  }\n+\n+  #ifndef _LP64\n+  inline uint32_t alt_canary() const {\n+    AsanPoisoningHelper aph(&_alt_canary);\n+    return _alt_canary;\n+  }\n+\n+  inline void set_alt_canary(uint32_t value) {\n+    AsanPoisoningHelper aph(&_alt_canary);\n+      _alt_canary = value;\n+  }\n+  #endif\n+\n+  inline void set_header_canary(uint16_t value) {\n+    AsanPoisoningHelper aph(&_canary);\n+    _canary = value;\n+  }\n+\n+  inline uint16_t canary() const {\n+    AsanPoisoningHelper aph(&_canary);\n+    return _canary;\n+  }\n+\n@@ -121,0 +163,2 @@\n+  uint8_t* footer_address() const { return ((address)this) + sizeof(MallocHeader) + size(); }\n+\n@@ -131,1 +175,5 @@\n-  inline size_t size()  const { return _size; }\n+  inline size_t size() const {\n+    AsanPoisoningHelper aph(&_size);\n+    return _size;\n+  }\n+\n@@ -142,3 +190,2 @@\n-\n-  bool is_dead() const { return _canary == _header_canary_dead_mark; }\n-  bool is_live() const { return _canary == _header_canary_live_mark; }\n+  bool is_dead() const { return canary() == _header_canary_dead_mark; }\n+  bool is_live() const { return canary() == _header_canary_live_mark; }\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.hpp","additions":56,"deletions":9,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-  : _size(size), _mst_marker(mst_marker), _mem_tag(mem_tag),\n-    _unused(0), _canary(_header_canary_live_mark)\n+  : _size(size), _mst_marker(mst_marker), _mem_tag(mem_tag), _unused(0),\n+   _canary(_header_canary_live_mark)\n@@ -44,1 +44,1 @@\n-  NOT_LP64(_alt_canary = _header_alt_canary_live_mark;)\n+  NOT_LP64(set_alt_canary(_header_alt_canary_live_mark);)\n@@ -46,0 +46,1 @@\n+  asan_poison_self();\n@@ -49,1 +50,1 @@\n-  assert(_canary == _header_canary_dead_mark, \"must be dead\");\n+  assert(canary() == _header_canary_dead_mark, \"must be dead\");\n@@ -51,3 +52,3 @@\n-  NOT_LP64(assert(_alt_canary == _header_alt_canary_dead_mark, \"must be dead\"));\n-  _canary = _header_canary_live_mark;\n-  NOT_LP64(_alt_canary = _header_alt_canary_live_mark);\n+  NOT_LP64(assert(alt_canary() == _header_alt_canary_dead_mark, \"must be dead\"));\n+  set_header_canary(_header_canary_live_mark);\n+  NOT_LP64(set_alt_canary(_header_alt_canary_live_mark);)\n@@ -55,0 +56,1 @@\n+  asan_poison_self();\n@@ -59,2 +61,3 @@\n-  _canary = _header_canary_dead_mark;\n-  NOT_LP64(_alt_canary = _header_alt_canary_dead_mark);\n+  asan_unpoison_self();\n+  set_header_canary(_header_canary_dead_mark);\n+  NOT_LP64(set_alt_canary(_header_alt_canary_dead_mark);)\n@@ -124,3 +127,3 @@\n-  return ( (_canary == _header_canary_live_mark NOT_LP64(&& _alt_canary == _header_alt_canary_live_mark)) ||\n-           (_canary == _header_canary_dead_mark NOT_LP64(&& _alt_canary == _header_alt_canary_dead_mark)) ) &&\n-           _size > 0 && _size < max_reasonable_malloc_size;\n+  return ( (canary() == _header_canary_live_mark NOT_LP64(&& alt_canary() == _header_alt_canary_live_mark)) ||\n+           (canary() == _header_canary_dead_mark NOT_LP64(&& alt_canary() == _header_alt_canary_dead_mark)) ) &&\n+           size() > 0 && size() < max_reasonable_malloc_size;\n@@ -134,1 +137,1 @@\n-  if (_canary != _header_canary_live_mark) {\n+  if (canary() != _header_canary_live_mark) {\n@@ -142,1 +145,1 @@\n-  if (_alt_canary != _header_alt_canary_live_mark) {\n+  if (alt_canary() != _header_alt_canary_live_mark) {\n@@ -150,1 +153,1 @@\n-  if (_size >= max_reasonable_malloc_size) {\n+  if (size() >= max_reasonable_malloc_size) {\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.inline.hpp","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"sanitizers\/address.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -79,0 +79,27 @@\n+template<typename T>\n+class AsanPoisoningHelper {\n+  const T* _memory_region;\n+ public:\n+  AsanPoisoningHelper() = delete;\n+  AsanPoisoningHelper(const T* addr) : _memory_region(addr) {\n+    #if INCLUDE_ASAN\n+      ASAN_UNPOISON_MEMORY_REGION(_memory_region, sizeof(T));\n+    #endif\n+  }\n+  ~AsanPoisoningHelper() {\n+    #if INCLUDE_ASAN\n+      ASAN_POISON_MEMORY_REGION(_memory_region, sizeof(T));\n+    #endif\n+  }\n+  static void poison_memory(const T* addr) {\n+    #if INCLUDE_ASAN\n+      ASAN_POISON_MEMORY_REGION(addr, sizeof(T));\n+    #endif\n+  }\n+  static void unpoison_memory(const T* addr) {\n+    #if INCLUDE_ASAN\n+      ASAN_UNPOISON_MEMORY_REGION(addr, sizeof(T));\n+    #endif\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/sanitizers\/address.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"testutils.hpp\"\n+#include \"unittest.hpp\"\n@@ -32,2 +34,0 @@\n-#include \"unittest.hpp\"\n-#include \"testutils.hpp\"\n@@ -183,3 +183,11 @@\n-TEST_VM_FATAL_ERROR_MSG(NMT, memory_corruption_call_stack, \".*header canary.*\") {\n-  if (MemTracker::tracking_level() != NMT_detail) {\n-    guarantee(false, \"fake message ignore this - header canary\");\n+#else \/\/ ASAN is enabled\n+\n+#define DEFINE_ASAN_TEST(test_function)                                                   \\\n+  TEST_VM_FATAL_ERROR_MSG(NMT_ASAN, test_function, \".*AddressSanitizer.*\") {              \\\n+    if (MemTracker::tracking_level() > NMT_off) {                                         \\\n+      test_function ();                                                                   \\\n+    } else {                                                                              \\\n+      \/* poisoning header\/footer of memory requires NMT to be on. If off, fake assert. *\/ \\\n+      guarantee(false,                                                                    \\\n+                \"fake message ignore this - AddressSanitizer\");                           \\\n+    }                                                                                     \\\n@@ -187,1 +195,3 @@\n-  const size_t SIZE = 1024;\n+\n+static void test_write_canary() {\n+  const size_t SIZE = 10;\n@@ -189,2 +199,127 @@\n-  *(p - 1) = 0;\n-  os::free(p);\n+  uint16_t* canary_ptr = (uint16_t*)((char*)p - sizeof(uint16_t));\n+  *canary_ptr = 1;\n+}\n+\n+static void test_read_canary() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  uint16_t* canary_ptr = (uint16_t*)((char*)p - sizeof(uint16_t));\n+  uint16_t read_canary = 0;\n+  read_canary = *canary_ptr;\n+}\n+\n+static void test_write_footer() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  uint16_t* footer_ptr = (uint16_t*)(mh->footer_address());\n+  *footer_ptr = 1;\n+}\n+\n+static void test_read_footer() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  uint16_t* footer_ptr = (uint16_t*)(mh->footer_address());\n+  uint16_t read_footer = *footer_ptr;\n+}\n+\n+static void test_write_size() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  size_t* size_ptr = (size_t*)(mh NOT_LP64(+ sizeof(uint32_t)));\n+  *size_ptr = 1;\n+}\n+\n+static void test_read_size() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  size_t* size_ptr = (size_t*)(mh NOT_LP64(+ sizeof(uint32_t)));\n+  size_t read_size = *size_ptr;\n+}\n+\n+static void test_write_canary_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  uint16_t* canary_ptr = (uint16_t*)((char*)p - sizeof(uint16_t));\n+  *canary_ptr = 1;\n+}\n+\n+static void test_read_canary_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  uint16_t* canary_ptr = (uint16_t*)((char*)p - sizeof(uint16_t));\n+  uint16_t read_canary = 0;\n+  read_canary = *canary_ptr;\n+}\n+\n+static void test_write_footer_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  uint16_t* footer_ptr = (uint16_t*)(mh->footer_address());\n+  *footer_ptr = 1;\n+}\n+\n+static void test_read_footer_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  uint16_t* footer_ptr = (uint16_t*)(mh->footer_address());\n+  uint16_t read_footer = *footer_ptr;\n+}\n+\n+static void test_write_size_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  size_t* size_ptr = (size_t*)(mh NOT_LP64(+ sizeof(uint32_t)));\n+  *size_ptr = 1;\n+}\n+\n+static void test_read_size_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  size_t* size_ptr = (size_t*)(mh NOT_LP64(+ sizeof(uint32_t)));\n+  size_t read_size = *size_ptr;\n+}\n+\n+\n+DEFINE_ASAN_TEST(test_write_canary);\n+DEFINE_ASAN_TEST(test_read_canary);\n+DEFINE_ASAN_TEST(test_write_footer);\n+DEFINE_ASAN_TEST(test_read_footer);\n+DEFINE_ASAN_TEST(test_write_size);\n+DEFINE_ASAN_TEST(test_read_size);\n+DEFINE_ASAN_TEST(test_write_canary_after_realloc);\n+DEFINE_ASAN_TEST(test_read_canary_after_realloc);\n+DEFINE_ASAN_TEST(test_write_footer_after_realloc);\n+DEFINE_ASAN_TEST(test_read_footer_after_realloc);\n+DEFINE_ASAN_TEST(test_write_size_after_realloc);\n+DEFINE_ASAN_TEST(test_read_size_after_realloc);\n+\n+static void test_poison_local() {\n+  uint16_t a;\n+  ASAN_POISON_MEMORY_REGION(&a, sizeof(a));\n+  a = 2;\n+}\n+\n+DEFINE_ASAN_TEST(test_poison_local);\n+\n+TEST_VM(NMT_ASAN, poison_no_death) {\n+  uint16_t a;\n+  ASAN_POISON_MEMORY_REGION(&a, sizeof(a));\n+  {\n+    AsanPoisoningHelper<uint16_t> aph(&a);\n+    a = 2;\n+    EXPECT_EQ(a, 2);\n+  }\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":143,"deletions":8,"binary":false,"changes":151,"status":"modified"}]}