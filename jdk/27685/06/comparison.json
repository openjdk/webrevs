{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"sanitizers\/address.hpp\"\n@@ -90,0 +91,41 @@\n+template<typename T>\n+class AsanPoisoner {\n+  char* _memory;\n+ public:\n+  AsanPoisoner() = delete;\n+  AsanPoisoner(char* addr) : _memory(addr) {\n+    ASAN_UNPOISON_MEMORY_REGION(_memory, sizeof(T));\n+  }\n+  ~AsanPoisoner() {\n+    ASAN_POISON_MEMORY_REGION(_memory, sizeof(T));\n+  }\n+  static void register_memory(char* addr) {\n+    ASAN_POISON_MEMORY_REGION(addr, sizeof(T));\n+  }\n+  static void unregister_memory(char* addr) {\n+    ASAN_UNPOISON_MEMORY_REGION(addr, sizeof(T));\n+  }\n+};\n+\n+\/\/ In non-ASAN builds we use 'void' as template parameter, to let\n+\/\/ the AsanPoisoner instances be compiled to nothing\n+template<>\n+class AsanPoisoner<void> {\n+ public:\n+  AsanPoisoner() = delete;\n+  AsanPoisoner(char* addr) { }\n+  static void register_memory(char* addr) { }\n+  static void unregister_memory(char* addr) { }\n+  ~AsanPoisoner() { }\n+};\n+\n+#ifdef INCLUDE_ASAN\n+  using CanaryType = uint16_t;\n+  using SizeType = size_t;\n+  NOT_LP64(using AltCanaryType = uint32_t;)\n+#else\n+  using CanaryType = void;\n+  using SizeType = void;\n+  NOT_LP64(using AltCanaryType = void;)\n+#endif\n+\n@@ -113,3 +155,9 @@\n-  uint8_t* footer_address() const   { return ((address)this) + sizeof(MallocHeader) + _size; }\n-  uint16_t get_footer() const       { return build_footer(footer_address()[0], footer_address()[1]); }\n-  void set_footer(uint16_t v)       { footer_address()[0] = (uint8_t)(v >> 8); footer_address()[1] = (uint8_t)v; }\n+  uint16_t get_footer() const {\n+    AsanPoisoner<CanaryType> _temp((char*)footer_address());\n+    return build_footer(footer_address()[0], footer_address()[1]);\n+  }\n+\n+  void set_footer(uint16_t v) {\n+    AsanPoisoner<CanaryType> _temp((char*)footer_address());\n+    footer_address()[0] = (uint8_t)(v >> 8); footer_address()[1] = (uint8_t)v;\n+  }\n@@ -121,0 +169,25 @@\n+  #ifndef _LP64\n+  inline uint32_t alt_canary() const {\n+    AsanPoisoner<AltCanaryType> _temp((char*)&alt_canary());\n+    return _alt_canary;\n+  }\n+  inline void set_alt_canary(uint32_t value) {\n+    AsanPoisoner<AltCanaryType> _temp((char*)&alt_canary());\n+      _alt_canary = value;\n+  }\n+  #endif\n+  inline void set_poisoned(bool poison) {\n+    if (poison) {\n+      AsanPoisoner<CanaryType>::register_memory((char*)&_canary);\n+      AsanPoisoner<CanaryType>::register_memory((char*)footer_address());\n+      AsanPoisoner<SizeType>::register_memory((char*)&_size);\n+      NOT_LP64(AsanPoisoner<AltCanaryType>::register_memory((char*)&_alt_canary));\n+    } else {\n+      AsanPoisoner<CanaryType>::unregister_memory((char*)&_canary);\n+      AsanPoisoner<CanaryType>::unregister_memory((char*)footer_address());\n+      AsanPoisoner<SizeType>::unregister_memory((char*)&_size);\n+      NOT_LP64(AsanPoisoner<AltCanaryType>::unregister_memory((char*)&_alt_canary));\n+    }\n+  }\n+\n+  uint8_t* footer_address() const { return ((address)this) + sizeof(MallocHeader) + size(); }\n@@ -131,1 +204,4 @@\n-  inline size_t size()  const { return _size; }\n+  inline size_t size() const {\n+    AsanPoisoner<SizeType> _temp((char*)&_size);\n+    return _size;\n+  }\n@@ -143,2 +219,11 @@\n-  bool is_dead() const { return _canary == _header_canary_dead_mark; }\n-  bool is_live() const { return _canary == _header_canary_live_mark; }\n+  inline void set_header_canary(uint16_t value) {\n+    AsanPoisoner<CanaryType> _temp((char*)&_canary);\n+    _canary = value;\n+  }\n+\n+  inline CanaryType canary() const {\n+    AsanPoisoner<CanaryType> _temp((char*)&_canary);\n+    return _canary;\n+  }\n+  bool is_dead() const { return canary() == _header_canary_dead_mark; }\n+  bool is_live() const { return canary() == _header_canary_live_mark; }\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.hpp","additions":92,"deletions":7,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-  : _size(size), _mst_marker(mst_marker), _mem_tag(mem_tag),\n-    _unused(0), _canary(_header_canary_live_mark)\n+  : _size(size), _mst_marker(mst_marker), _mem_tag(mem_tag), _unused(0),\n+   _canary(_header_canary_live_mark)\n@@ -44,1 +44,1 @@\n-  NOT_LP64(_alt_canary = _header_alt_canary_live_mark;)\n+  NOT_LP64(set_alt_canary(_header_alt_canary_live_mark);)\n@@ -46,0 +46,1 @@\n+  set_poisoned(true);\n@@ -49,1 +50,1 @@\n-  assert(_canary == _header_canary_dead_mark, \"must be dead\");\n+  assert(canary() == _header_canary_dead_mark, \"must be dead\");\n@@ -51,3 +52,3 @@\n-  NOT_LP64(assert(_alt_canary == _header_alt_canary_dead_mark, \"must be dead\"));\n-  _canary = _header_canary_live_mark;\n-  NOT_LP64(_alt_canary = _header_alt_canary_live_mark);\n+  NOT_LP64(assert(alt_canary() == _header_alt_canary_dead_mark, \"must be dead\"));\n+  set_header_canary(_header_canary_live_mark);\n+  NOT_LP64(set_alt_canary(_header_alt_canary_live_mark);)\n@@ -55,0 +56,1 @@\n+  set_poisoned(true);\n@@ -59,2 +61,3 @@\n-  _canary = _header_canary_dead_mark;\n-  NOT_LP64(_alt_canary = _header_alt_canary_dead_mark);\n+  set_poisoned(false);\n+  set_header_canary(_header_canary_dead_mark);\n+  NOT_LP64(set_alt_canary(_header_alt_canary_dead_mark);)\n@@ -124,3 +127,3 @@\n-  return ( (_canary == _header_canary_live_mark NOT_LP64(&& _alt_canary == _header_alt_canary_live_mark)) ||\n-           (_canary == _header_canary_dead_mark NOT_LP64(&& _alt_canary == _header_alt_canary_dead_mark)) ) &&\n-           _size > 0 && _size < max_reasonable_malloc_size;\n+  return ( (canary() == _header_canary_live_mark NOT_LP64(&& alt_canary() == _header_alt_canary_live_mark)) ||\n+           (canary() == _header_canary_dead_mark NOT_LP64(&& alt_canary() == _header_alt_canary_dead_mark)) ) &&\n+           size() > 0 && size() < max_reasonable_malloc_size;\n@@ -134,1 +137,1 @@\n-  if (_canary != _header_canary_live_mark) {\n+  if (canary() != _header_canary_live_mark) {\n@@ -142,1 +145,1 @@\n-  if (_alt_canary != _header_alt_canary_live_mark) {\n+  if (alt_canary() != _header_alt_canary_live_mark) {\n@@ -150,1 +153,1 @@\n-  if (_size >= max_reasonable_malloc_size) {\n+  if (size() >= max_reasonable_malloc_size) {\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.inline.hpp","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"sanitizers\/address.hpp\"\n@@ -190,0 +191,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#define __SANITIZE_ADDRESS__\n","filename":"src\/hotspot\/share\/sanitizers\/address.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -166,0 +166,21 @@\n+#else\n+#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)\n+#else\n+#error \"No ASAN\"\n+#endif\n+#define TEST_VM_FATAL_ASAN_MSG(category, name, msg)                \\\n+  static void test_  ## category ## _ ## name ## _();               \\\n+                                                                    \\\n+  static void child_ ## category ## _ ## name ## _() {              \\\n+    ::testing::GTEST_FLAG(throw_on_failure) = true;                 \\\n+    test_ ## category ## _ ## name ## _();                          \\\n+    gtest_exit_from_child_vm(0);                                    \\\n+  }                                                                 \\\n+                                                                    \\\n+  TEST(category, CONCAT(name, _vm_assert)) {                        \\\n+    ASSERT_EXIT(child_ ## category ## _ ## name ## _(),             \\\n+                ::testing::KilledBySignal(SIGABRT),                 \\\n+                msg);                                               \\\n+  }                                                                 \\\n+                                                                    \\\n+  void test_ ## category ## _ ## name ## _()\n@@ -167,0 +188,153 @@\n+#define DEFINE_ASAN_TEST(test_function)                            \\\n+  TEST_VM_FATAL_ASAN_MSG(NMT_ASAN, test_function, \".*AddressSanitizer.*\") {     \\\n+    if (MemTracker::tracking_level() > NMT_off) {                                         \\\n+      test_function ();                                                                   \\\n+    } else {                                                                              \\\n+      \/* overflow detection requires NMT to be on. If off, fake assert. *\/                \\\n+      guarantee(false,                                                                    \\\n+                \"fake message ignore this - .*AddresssSanitizer.*\");                      \\\n+    }                                                                                     \\\n+  }\n+\n+static void test_write_canary() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  CanaryType* canary_ptr = (CanaryType*)((char*)p - sizeof(CanaryType));\n+  *canary_ptr = 1;\n+}\n+\n+static void test_read_canary() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  CanaryType* canary_ptr = (CanaryType*)((char*)p - sizeof(CanaryType));\n+  CanaryType read_canary = 0;\n+  read_canary = *canary_ptr;\n+}\n+\n+static void test_write_footer() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  CanaryType* footer_ptr = (CanaryType*)(mh->footer_address());\n+  *footer_ptr = 1;\n+}\n+\n+static void test_read_footer() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  CanaryType* footer_ptr = (CanaryType*)(mh->footer_address());\n+  CanaryType read_footer = *footer_ptr;\n+}\n+\n+static void test_write_size() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  size_t* size_ptr = (size_t*)(mh);\n+  *size_ptr = 1;\n+}\n+\n+static void test_read_size() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  size_t* size_ptr = (size_t*)(mh);\n+  size_t read_size = *size_ptr;\n+}\n+\n+static void test_write_canary_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  CanaryType* canary_ptr = (CanaryType*)((char*)p - sizeof(CanaryType));\n+  *canary_ptr = 1;\n+}\n+\n+static void test_read_canary_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  CanaryType* canary_ptr = (CanaryType*)((char*)p - sizeof(CanaryType));\n+  CanaryType read_canary = 0;\n+  read_canary = *canary_ptr;\n+}\n+\n+static void test_write_footer_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  CanaryType* footer_ptr = (CanaryType*)(mh->footer_address());\n+  *footer_ptr = 1;\n+}\n+\n+static void test_read_footer_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  CanaryType* footer_ptr = (CanaryType*)(mh->footer_address());\n+  CanaryType read_footer = *footer_ptr;\n+}\n+\n+static void test_write_size_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  size_t* size_ptr = (size_t*)(mh);\n+  *size_ptr = 1;\n+}\n+\n+static void test_read_size_after_realloc() {\n+  const size_t SIZE = 10;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  p = (char*)os::realloc(p, 2 * SIZE, mtTest);\n+  MallocHeader* mh = (MallocHeader*)(p - sizeof(MallocHeader));\n+  size_t* size_ptr = (size_t*)(mh);\n+  size_t read_size = *size_ptr;\n+}\n+\n+\n+DEFINE_ASAN_TEST(test_write_canary);\n+DEFINE_ASAN_TEST(test_read_canary);\n+DEFINE_ASAN_TEST(test_write_footer);\n+DEFINE_ASAN_TEST(test_read_footer);\n+DEFINE_ASAN_TEST(test_write_size);\n+DEFINE_ASAN_TEST(test_read_size);\n+DEFINE_ASAN_TEST(test_write_canary_after_realloc);\n+DEFINE_ASAN_TEST(test_read_canary_after_realloc);\n+DEFINE_ASAN_TEST(test_write_footer_after_realloc);\n+DEFINE_ASAN_TEST(test_read_footer_after_realloc);\n+DEFINE_ASAN_TEST(test_write_size_after_realloc);\n+DEFINE_ASAN_TEST(test_read_size_after_realloc);\n+\n+static void test_poison_local() {\n+  uint16_t a;\n+  ASAN_POISON_MEMORY_REGION(&a, sizeof(a));\n+  a = 2;\n+}\n+\n+DEFINE_ASAN_TEST(test_poison_local);\n+\n+TEST_VM(NMT_ASAN, test_poison_when_no_asan) {\n+  uint16_t a;\n+  {\n+    AsanPoisoner<void> pm((char*)&a);\n+    a = 2;\n+    EXPECT_EQ(a, 2);\n+  }\n+  a = 3;\n+  EXPECT_EQ(a, 3);\n+}\n+\n+TEST_VM(NMT_ASAN, poison_no_death) {\n+  uint16_t a;\n+  ASAN_POISON_MEMORY_REGION(&a, sizeof(a));\n+  {\n+    AsanPoisoner<uint16_t> pm((char*)&a);\n+    a = 2;\n+    EXPECT_EQ(a, 2);\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":174,"deletions":0,"binary":false,"changes":174,"status":"modified"}]}