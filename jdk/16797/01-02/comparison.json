{"files":[{"patch":"@@ -47,0 +47,7 @@\n+            \/\/ We run the VM in interpreted mode, because the JIT might mark\n+            \/\/ a Java method as not-entrant, which means turning the first opcode\n+            \/\/ of the compiled method to NULL. Calling such a method after establishing\n+            \/\/ the new SIGILL signal handler with TestPosixSig.changeSigActionFor(4)\n+            \/\/ below will result in an endless loop, where the invalid opcode will be\n+            \/\/ continously executed, raising SIGILL, and the signal handler will return\n+            \/\/ to the invalid opcode...\n@@ -49,0 +56,1 @@\n+                \"-Xint\",\n","filename":"test\/hotspot\/jtreg\/runtime\/posixSig\/TestPosixSig.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-void(*psig_handler) (int, siginfo_t *, void *) = 0;\n-\n@@ -35,6 +33,0 @@\n-    \/* call the previous signal handler in the chain to avoid unhandled\n-     * illegal Opcode (SIGILL) event, which would result in endles recursion\n-     *\/\n-    if (psig_handler) {\n-        psig_handler(sig, info, context);\n-    }\n@@ -44,1 +36,1 @@\n-    struct sigaction act, oact;\n+    struct sigaction act;\n@@ -47,2 +39,2 @@\n-    act.sa_flags = SA_SIGINFO;\n-    int retval = sigaction(val, &act, &oact);\n+    act.sa_flags = 0;\n+    int retval = sigaction(val, &act, 0);\n@@ -52,9 +44,0 @@\n-    \/* store the previous signal handler in the global psig_handler variable to be able\n-     * to continue the signal chain\n-     *\/\n-    if (oact.sa_handler != SIG_DFL &&\n-        oact.sa_handler != SIG_ERR &&\n-        oact.sa_handler != SIG_IGN &&\n-        oact.sa_handler != NULL) {\n-        psig_handler = oact.sa_sigaction;\n-    }\n","filename":"test\/hotspot\/jtreg\/runtime\/posixSig\/libTestPsig.c","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"}]}