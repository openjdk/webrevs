{"files":[{"patch":"@@ -1400,1 +1400,1 @@\n-BitData MethodData::ex_handler_bci_to_data(int bci) {\n+DataLayout* MethodData::ex_handler_bci_to_data_helper(int bci) {\n@@ -1405,1 +1405,1 @@\n-      return BitData(ex_handler_data);\n+      return ex_handler_data;\n@@ -1408,2 +1408,12 @@\n-  \/\/ called with invalid bci or wrong Method\/MethodData\n-  ShouldNotReachHere();\n+  return nullptr;\n+}\n+\n+BitData* MethodData::ex_handler_bci_to_data_or_null(int bci) {\n+  DataLayout* data = ex_handler_bci_to_data_helper(bci);\n+  return data != nullptr ? new BitData(data) : nullptr;\n+}\n+\n+BitData MethodData::ex_handler_bci_to_data(int bci) {\n+  DataLayout* data = ex_handler_bci_to_data_helper(bci);\n+  assert(data != nullptr, \"invalid bci\");\n+  return BitData(data);\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2171,0 +2171,2 @@\n+  DataLayout* ex_handler_bci_to_data_helper(int bci);\n+\n@@ -2364,0 +2366,1 @@\n+  BitData* ex_handler_bci_to_data_or_null(int bci);\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2436,0 +2436,11 @@\n+    if (ProfileExceptionHandlers && trap_mdo != nullptr) {\n+      BitData* ex_handler_data = trap_mdo->ex_handler_bci_to_data_or_null(trap_bci);\n+      if (ex_handler_data != nullptr) {\n+        \/\/ uncommon trap at the start of an exception handler.\n+        \/\/ C2 generates these for un-entered exception handlers.\n+        \/\/ mark the handler as entered to avoid generating\n+        \/\/ another uncommon trap the next time the handler is compiled\n+        ex_handler_data->set_ex_handler_entered();\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+ * @requires vm.debug\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestExHandlerTrap.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+            \"-XX:CompileCommand=inline,compiler.c2.irTests.TestPrunedExHandler::inlinee\",\n@@ -110,0 +111,34 @@\n+\n+    @Test\n+    @IR(counts = {IRNode.UNREACHED_TRAP, \"0\"})\n+    public static void testNoTrapAfterDeoptInlined(boolean shouldThrow) {\n+        \/\/ check that we handle exception thrown in inlinee, caught in caller.\n+        \/\/ C2 handles exception dispatch differently for those cases\n+        try {\n+            inlinee(shouldThrow);\n+        } catch (IllegalStateException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private static void inlinee(boolean shouldThrow) {\n+        outOfLine(shouldThrow);\n+    }\n+\n+    @Run(test = \"testNoTrapAfterDeoptInlined\", mode = RunMode.STANDALONE)\n+    public static void runNoTrapAfterDeoptInlined(RunInfo info) {\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4\n+            testNoTrapAfterDeoptInlined(false);\n+        }\n+\n+        TestFramework.assertCompiledByC2(info.getTest());\n+\n+        testNoTrapAfterDeoptInlined(true); \/\/ deopt + mark ex handler as entered\n+\n+        TestFramework.assertDeoptimizedByC2(info.getTest());\n+\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4 again\n+            testNoTrapAfterDeoptInlined(false); \/\/ should have no trap\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPrunedExHandler.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"}]}