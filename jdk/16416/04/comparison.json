{"files":[{"patch":"@@ -392,4 +392,0 @@\n-  if (method()->is_synchronized()) {\n-    set_has_monitors(true);\n-  }\n-\n@@ -583,1 +579,1 @@\n-, _has_monitors(false)\n+, _has_monitors(method->is_synchronized() || method->has_monitor_bytecodes())\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2319,1 +2319,0 @@\n-  compilation()->set_has_monitors(true);\n@@ -3509,0 +3508,8 @@\n+static void set_flags_for_inlined_callee(Compilation* compilation, ciMethod* callee) {\n+  if (callee->has_reserved_stack_access()) {\n+    compilation->set_has_reserved_stack_access(true);\n+  }\n+  if (callee->is_synchronized() || callee->has_monitor_bytecodes()) {\n+    compilation->set_has_monitors(true);\n+  }\n+}\n@@ -3526,3 +3533,1 @@\n-      if (callee->has_reserved_stack_access()) {\n-        compilation()->set_has_reserved_stack_access(true);\n-      }\n+      set_flags_for_inlined_callee(compilation(), callee);\n@@ -3539,3 +3544,1 @@\n-      if (callee->has_reserved_stack_access()) {\n-        compilation()->set_has_reserved_stack_access(true);\n-      }\n+      set_flags_for_inlined_callee(compilation(), callee);\n@@ -3559,3 +3562,1 @@\n-    if (callee->has_reserved_stack_access()) {\n-      compilation()->set_has_reserved_stack_access(true);\n-    }\n+    set_flags_for_inlined_callee(compilation(), callee);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+  _parameters_data_offset(0),\n+  _ex_handlers_data_offset(0),\n@@ -53,2 +55,1 @@\n-  _orig(),\n-  _parameters(nullptr) {}\n+  _orig() {}\n@@ -137,2 +138,10 @@\n-                              (HeapWord*)((address) _data + _data_size),\n-                              (_extra_data_size - mdo->parameters_size_in_bytes()) \/ HeapWordSize);\n+                              (HeapWord*) extra_data_base(),\n+                              \/\/ copy everything from extra_data_base() up to parameters_data_base()\n+                              pointer_delta(parameters_data_base(), extra_data_base(), HeapWordSize));\n+\n+  \/\/ skip parameter data copying. Already done in 'load_data'\n+\n+  \/\/ copy exception handler data\n+  Copy::disjoint_words_atomic((HeapWord*) mdo->ex_handler_data_base(),\n+                              (HeapWord*) ex_handler_data_base(),\n+                              ex_handler_data_size() \/ HeapWordSize);\n@@ -198,0 +207,3 @@\n+  \/\/  param_data_limit: ---------------------------\n+  \/\/                    | ex handler data entries |\n+  \/\/                    |           ...           |\n@@ -203,1 +215,3 @@\n-  \/\/ args_data_limit = data_base + total_size - parameter_data_size\n+  \/\/ args_data_limit = param_data_base\n+  \/\/ param_data_limit = ex_handler_data_base\n+  \/\/ extra_data_limit = extra_data_limit\n@@ -221,0 +235,3 @@\n+  \/\/ Copy offsets. This is used below\n+  _parameters_data_offset = mdo->parameters_type_data_di();\n+  _ex_handlers_data_offset = mdo->ex_handlers_data_di();\n@@ -225,2 +242,2 @@\n-    Copy::disjoint_words_atomic((HeapWord*) mdo->args_data_limit(),\n-                                (HeapWord*) ((address)_data + total_size - parameters_data_size),\n+    Copy::disjoint_words_atomic((HeapWord*) mdo->parameters_data_base(),\n+                                (HeapWord*) parameters_data_base(),\n@@ -240,2 +257,2 @@\n-    _parameters = data_layout_at(mdo->parameters_type_data_di());\n-    ciParametersTypeData* parameters = new ciParametersTypeData(_parameters);\n+    DataLayout* parameters_data = data_layout_at(_parameters_data_offset);\n+    ciParametersTypeData* parameters = new ciParametersTypeData(parameters_data);\n@@ -245,1 +262,1 @@\n-  assert((DataLayout*) ((address)_data + total_size - parameters_data_size) == args_data_limit(),\n+  assert((DataLayout*) ((address)_data + total_size - parameters_data_size - ex_handler_data_size()) == args_data_limit(),\n@@ -370,1 +387,1 @@\n-DataLayout* ciMethodData::next_data_layout(DataLayout* current) {\n+DataLayout* ciMethodData::next_data_layout_helper(DataLayout* current, bool extra) {\n@@ -373,1 +390,1 @@\n-  if (out_of_bounds(next_index)) {\n+  if (extra ? out_of_bounds_extra(next_index) : out_of_bounds(next_index)) {\n@@ -380,0 +397,8 @@\n+DataLayout* ciMethodData::next_data_layout(DataLayout* current) {\n+  return next_data_layout_helper(current, false);\n+}\n+\n+DataLayout* ciMethodData::next_extra_data_layout(DataLayout* current) {\n+  return next_data_layout_helper(current, true);\n+}\n+\n@@ -441,0 +466,13 @@\n+ciBitData ciMethodData::ex_handler_bci_to_data(int bci) {\n+  assert(ProfileExceptionHandlers, \"not profiling\");\n+  assert(_data != nullptr, \"must be initialized\");\n+  for (DataLayout* data = ex_handler_data_base(); data < ex_handler_data_limit(); data = next_extra_data_layout(data)) {\n+    assert(data != nullptr, \"out of bounds?\");\n+    if (data->bci() == bci) {\n+      return ciBitData(data);\n+    }\n+  }\n+  \/\/ called with invalid bci or wrong Method\/MethodData\n+  ShouldNotReachHere();\n+}\n+\n@@ -615,1 +653,1 @@\n-  return _parameters != nullptr ? new ciParametersTypeData(_parameters) : nullptr;\n+  return parameter_data_size() != 0 ? new ciParametersTypeData(data_layout_at(_parameters_data_offset)) : nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":51,"deletions":13,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -382,0 +382,4 @@\n+  \/\/ layout of _data\n+  int _parameters_data_offset;\n+  int _ex_handlers_data_offset;\n+\n@@ -406,6 +410,0 @@\n-  \/\/ Area dedicated to parameters. null if no parameter profiling for this method.\n-  DataLayout* _parameters;\n-  int parameters_size() const {\n-    return _parameters == nullptr ? 0 : parameters_type_data()->size_in_bytes();\n-  }\n-\n@@ -417,0 +415,2 @@\n+  int parameter_data_size() const { return _ex_handlers_data_offset - _parameters_data_offset; }\n+  int ex_handler_data_size() const { return dp_to_di((address) ex_handler_data_limit()) - _ex_handlers_data_offset; }\n@@ -428,1 +428,1 @@\n-    assert(data_index % sizeof(intptr_t) == 0, \"unaligned\");\n+    assert(data_index % sizeof(intptr_t) == 0, \"unaligned: %d\", data_index);\n@@ -436,0 +436,6 @@\n+  bool out_of_bounds_extra(int data_index) {\n+    return data_index < data_size() || data_index >= data_size() + extra_data_size();\n+  }\n+\n+  DataLayout* next_data_layout_helper(DataLayout* current, bool extra);\n+\n@@ -503,1 +509,1 @@\n-  int dp_to_di(address dp) {\n+  int dp_to_di(address dp) const {\n@@ -514,0 +520,1 @@\n+  DataLayout* next_extra_data_layout(DataLayout* current);\n@@ -517,0 +524,3 @@\n+  \/\/ pointers to sections in _data\n+  \/\/ NOTE: these may be called before ciMethodData::load_data\n+  \/\/       this works out since everything is initialized to 0 (i.e. there will appear to be no data)\n@@ -518,2 +528,7 @@\n-  DataLayout* args_data_limit() const  { return data_layout_at(data_size() + extra_data_size() -\n-                                                               parameters_size()); }\n+  DataLayout* extra_data_limit() const { return data_layout_at(data_size() + extra_data_size()); }\n+  \/\/ pointers to sections in extra data\n+  DataLayout* args_data_limit() const  { return parameters_data_base(); }\n+  DataLayout* parameters_data_base() const { return data_layout_at(_parameters_data_offset); }\n+  DataLayout* parameters_data_limit() const { return ex_handler_data_base(); }\n+  DataLayout* ex_handler_data_base() const { return data_layout_at(_ex_handlers_data_offset); }\n+  DataLayout* ex_handler_data_limit() const { return extra_data_limit(); }\n@@ -525,0 +540,2 @@\n+  ciBitData ex_handler_bci_to_data(int bci);\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -468,0 +468,1 @@\n+\/\/ Note that the implementation of this method assumes it's only called when an exception has actually occured\n@@ -582,0 +583,1 @@\n+    h_method->set_ex_handler_entered(handler_bci); \/\/ profiling\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -651,0 +651,10 @@\n+void Method::set_ex_handler_entered(int handler_bci) {\n+  if (ProfileExceptionHandlers) {\n+    MethodData* mdo = method_data();\n+    if (mdo != nullptr) {\n+      BitData handler_data = mdo->ex_handler_bci_to_data(handler_bci);\n+      handler_data.set_ex_handler_entered();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -311,0 +311,3 @@\n+  \/\/ mark an exception handler as entered (used to prune dead catch blocks in C2)\n+  void set_ex_handler_entered(int handler_bci);\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -968,0 +968,6 @@\n+\n+  if (ProfileExceptionHandlers && method()->has_exception_handler()) {\n+    int num_ex_handlers = method()->exception_table_length();\n+    object_size += num_ex_handlers * single_ex_handler_data_size();\n+  }\n+\n@@ -1278,0 +1284,1 @@\n+  int parm_data_size = 0;\n@@ -1279,1 +1286,2 @@\n-    object_size += DataLayout::compute_size_in_bytes(parms_cell);\n+    parm_data_size = DataLayout::compute_size_in_bytes(parms_cell);\n+    object_size += parm_data_size;\n@@ -1287,0 +1295,11 @@\n+  _ex_handler_data_di = data_size + extra_size + arg_data_size + parm_data_size;\n+  if (ProfileExceptionHandlers && method()->has_exception_handler()) {\n+    int num_ex_handlers = method()->exception_table_length();\n+    object_size += num_ex_handlers * single_ex_handler_data_size();\n+    ExceptionTableElement* ex_handlers = method()->exception_table_start();\n+    for (int i = 0; i < num_ex_handlers; i++) {\n+      DataLayout *dp = ex_handler_data_at(i);\n+      dp->initialize(DataLayout::bit_data_tag, ex_handlers[i].handler_pc, single_ex_handler_data_cell_count());\n+    }\n+  }\n+\n@@ -1381,0 +1400,22 @@\n+DataLayout* MethodData::ex_handler_bci_to_data_helper(int bci) {\n+  assert(ProfileExceptionHandlers, \"not profiling\");\n+  for (int i = 0; i < num_ex_handler_data(); i++) {\n+    DataLayout* ex_handler_data = ex_handler_data_at(i);\n+    if (ex_handler_data->bci() == bci) {\n+      return ex_handler_data;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+BitData* MethodData::ex_handler_bci_to_data_or_null(int bci) {\n+  DataLayout* data = ex_handler_bci_to_data_helper(bci);\n+  return data != nullptr ? new BitData(data) : nullptr;\n+}\n+\n+BitData MethodData::ex_handler_bci_to_data(int bci) {\n+  DataLayout* data = ex_handler_bci_to_data_helper(bci);\n+  assert(data != nullptr, \"invalid bci\");\n+  return BitData(data);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -494,1 +494,2 @@\n-      null_seen_flag              = DataLayout::first_flag + 0\n+      null_seen_flag              = DataLayout::first_flag + 0,\n+      ex_handler_entered_flag     = null_seen_flag + 1\n@@ -497,1 +498,1 @@\n-    , exception_seen_flag         = null_seen_flag + 1\n+    , exception_seen_flag         = ex_handler_entered_flag + 1\n@@ -528,0 +529,4 @@\n+  \/\/ true if a ex handler block at this bci was entered\n+  bool ex_handler_entered() { return flag_at(ex_handler_entered_flag); }\n+  void set_ex_handler_entered() { set_flag_at(ex_handler_entered_flag); }\n+\n@@ -2066,0 +2071,3 @@\n+  \/\/ data index of exception handler profiling data\n+  int _ex_handler_data_di;\n+\n@@ -2067,0 +2075,1 @@\n+  \/\/ See comment in ciMethodData::load_data\n@@ -2081,0 +2090,16 @@\n+  static int single_ex_handler_data_cell_count() {\n+    return BitData::static_cell_count();\n+  }\n+\n+  static int single_ex_handler_data_size() {\n+    return DataLayout::compute_size_in_bytes(single_ex_handler_data_cell_count());\n+  }\n+\n+  DataLayout* ex_handler_data_at(int ex_handler_index) const {\n+    return data_layout_at(_ex_handler_data_di + (ex_handler_index * single_ex_handler_data_size()));\n+  }\n+\n+  int num_ex_handler_data() const {\n+    return ex_handlers_data_size() \/ single_ex_handler_data_size();\n+  }\n+\n@@ -2146,0 +2171,2 @@\n+  DataLayout* ex_handler_bci_to_data_helper(int bci);\n+\n@@ -2282,2 +2309,5 @@\n-    ParametersTypeData* param = parameters_type_data();\n-    return param == nullptr ? 0 : param->size_in_bytes();\n+    return pointer_delta_as_int((address) parameters_data_limit(), (address) parameters_data_base());\n+  }\n+\n+  int ex_handlers_data_size() const {\n+    return pointer_delta_as_int((address) ex_handler_data_limit(), (address) ex_handler_data_base());\n@@ -2336,0 +2366,3 @@\n+  BitData* ex_handler_bci_to_data_or_null(int bci);\n+  BitData ex_handler_bci_to_data(int bci);\n+\n@@ -2337,0 +2370,1 @@\n+  \/\/ Only valid after 'set_size' is called at the end of MethodData::initialize\n@@ -2339,2 +2373,13 @@\n-  DataLayout* args_data_limit() const  { return (DataLayout*)((address)this + size_in_bytes() -\n-                                                              parameters_size_in_bytes()); }\n+  \/\/ pointers to sections in extra data\n+  DataLayout* args_data_limit() const  { return parameters_data_base(); }\n+  DataLayout* parameters_data_base() const {\n+    assert(_parameters_type_data_di != parameters_uninitialized, \"called too early\");\n+    return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di) : parameters_data_limit();\n+  }\n+  DataLayout* parameters_data_limit() const {\n+    assert(_parameters_type_data_di != parameters_uninitialized, \"called too early\");\n+    return ex_handler_data_base();\n+  }\n+  DataLayout* ex_handler_data_base() const { return data_layout_at(_ex_handler_data_di); }\n+  DataLayout* ex_handler_data_limit() const { return extra_data_limit(); }\n+\n@@ -2388,2 +2433,6 @@\n-    assert(_parameters_type_data_di != parameters_uninitialized && _parameters_type_data_di != no_parameters, \"no args type data\");\n-    return _parameters_type_data_di;\n+    assert(_parameters_type_data_di != parameters_uninitialized, \"called too early\");\n+    return _parameters_type_data_di != no_parameters ? _parameters_type_data_di : ex_handlers_data_di();\n+  }\n+\n+  int ex_handlers_data_di() const {\n+    return _ex_handler_data_di;\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":57,"deletions":8,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -780,0 +780,5 @@\n+  product(bool, PruneDeadExceptionHandlers, true,                           \\\n+          \"Prune exception handlers that are never entered\")                \\\n+                                                                            \\\n+  develop(bool, StressPrunedExceptionHandlers, false,                       \\\n+          \"Always prune exception handlers\")                                \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -182,2 +182,0 @@\n-  C->set_has_monitors(true);\n-\n@@ -201,4 +199,0 @@\n-  \/\/ need to set it for monitor exit as well.\n-  \/\/ OSR compiled methods can start with lock taken\n-  C->set_has_monitors(true);\n-\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-  if (parse_method->is_synchronized()) {\n+  if (parse_method->is_synchronized() || parse_method->has_monitor_bytecodes()) {\n@@ -1535,0 +1535,16 @@\n+  if (ProfileExceptionHandlers && PruneDeadExceptionHandlers && block()->is_handler()) {\n+    ciMethodData* methodData = method()->method_data();\n+    if (methodData->is_mature()) {\n+      ciBitData data = methodData->ex_handler_bci_to_data(block()->start());\n+      if (!data.ex_handler_entered() || StressPrunedExceptionHandlers) {\n+        \/\/ dead catch block\n+        \/\/ Emit an uncommon trap instead of processing the block.\n+        set_parse_bci(block()->start());\n+        uncommon_trap(Deoptimization::Reason_unreached,\n+                      Deoptimization::Action_reinterpret,\n+                      nullptr, \"dead catch block\");\n+        return;\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2436,0 +2436,11 @@\n+    if (ProfileExceptionHandlers && trap_mdo != nullptr) {\n+      BitData* ex_handler_data = trap_mdo->ex_handler_bci_to_data_or_null(trap_bci);\n+      if (ex_handler_data != nullptr) {\n+        \/\/ uncommon trap at the start of an exception handler.\n+        \/\/ C2 generates these for un-entered exception handlers.\n+        \/\/ mark the handler as entered to avoid generating\n+        \/\/ another uncommon trap the next time the handler is compiled\n+        ex_handler_data->set_ex_handler_entered();\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1994,0 +1994,3 @@\n+                                                                            \\\n+  product(bool, ProfileExceptionHandlers, true,                             \\\n+          \"Profile exception handlers\")                                     \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -680,0 +680,1 @@\n+\/\/ Note that the implementation of this method assumes it's only called when an exception has actually occured\n@@ -782,0 +783,3 @@\n+  if (handler_bci != -1) { \/\/ did we find a handler in this method?\n+    sd->method()->set_ex_handler_entered(handler_bci); \/\/ profile\n+  }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2;\n+\n+import java.io.PrintStream;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+\/*\n+ * @test id=default_config\n+ * @bug 8267532\n+ * @summary Test whether trap in place of pruned exception handler block works\n+ *\n+ * @run main\/othervm\n+ *   -Xbatch\n+ *   -Xlog:deoptimization=trace\n+ *   -XX:CompileCommand=PrintCompilation,compiler.c2.TestExHandlerTrap::payload\n+ *   -XX:CompileCommand=dontinline,compiler.c2.TestExHandlerTrap::payload\n+ *   -XX:CompileCommand=dontinline,compiler.c2.TestExHandlerTrap::maybeThrow\n+ *   compiler.c2.TestExHandlerTrap\n+ *\/\n+\n+\/*\n+ * @test id=no_profiling\n+ * @bug 8267532\n+ * @summary basic smoke test for disabled ex. handler profiling\n+ *\n+ * @run main\/othervm\n+ *   -Xbatch\n+ *   -Xlog:deoptimization=trace\n+ *   -XX:CompileCommand=PrintCompilation,compiler.c2.TestExHandlerTrap::payload\n+ *   -XX:CompileCommand=dontinline,compiler.c2.TestExHandlerTrap::payload\n+ *   -XX:CompileCommand=dontinline,compiler.c2.TestExHandlerTrap::maybeThrow\n+ *   -XX:-ProfileExceptionHandlers\n+ *   compiler.c2.TestExHandlerTrap\n+ *\/\n+\n+\/*\n+ * @test id=stress\n+ * @bug 8267532\n+ * @summary basic smoke test for stressing ex. handler pruning\n+ * @requires vm.debug\n+ *\n+ * @run main\/othervm\n+ *   -Xbatch\n+ *   -Xlog:deoptimization=trace\n+ *   -XX:CompileCommand=PrintCompilation,compiler.c2.TestExHandlerTrap::payload\n+ *   -XX:CompileCommand=dontinline,compiler.c2.TestExHandlerTrap::payload\n+ *   -XX:CompileCommand=dontinline,compiler.c2.TestExHandlerTrap::maybeThrow\n+ *   -XX:+StressPrunedExceptionHandlers\n+ *   compiler.c2.TestExHandlerTrap\n+ *\/\n+\n+public class TestExHandlerTrap {\n+\n+    private static final String EX_MESSAGE = \"Testing trap\";\n+\n+    public static void main(String[] args) throws Throwable {\n+        \/\/ warmup, compile payload\n+        for (int i = 0; i < 20_000; i++) {\n+            payload(false);\n+        }\n+\n+        try {\n+            \/\/ trigger uncommon trap in pruned catch block\n+            payload(true);\n+        } catch (IllegalStateException e) {\n+            if (!e.getMessage().equals(EX_MESSAGE)) {\n+                throw e;\n+            }\n+        }\n+\n+        \/\/ continue for a bit, to see if anything breaks\n+        for (int i = 0; i < 1_000; i++) {\n+            payload(false);\n+        }\n+    }\n+\n+    public static void payload(boolean shouldThrow) {\n+        doIt(shouldThrow); \/\/ mix in some inlining\n+    }\n+\n+    public static void doIt(boolean shouldThrow) {\n+        PrintStream err = System.err;\n+        try (ConfinedScope r = new ConfinedScope()) {\n+            r.addCloseAction(dummy);\n+            maybeThrow(shouldThrow); \/\/ out of line to prevent 'payload' from being deoptimized by unstable if\n+        } catch (IllegalArgumentException e) {\n+            \/\/ some side effects to see whether deopt is successful\n+            err.println(\"Exception message: \" + e.getMessage());\n+            err.println(\"shouldThrow: \" + shouldThrow);\n+        }\n+    }\n+\n+    private static void maybeThrow(boolean shouldThrow) {\n+        if (shouldThrow) {\n+            throw new IllegalStateException(EX_MESSAGE);\n+        }\n+    }\n+\n+    static final Runnable dummy = () -> {};\n+\n+    static class ConfinedScope implements AutoCloseable {\n+        final Thread owner;\n+        boolean closed;\n+        final List<Runnable> resources = new ArrayList<>();\n+\n+        private void checkState() {\n+            if (closed) {\n+                throw new AssertionError(\"Closed\");\n+            } else if (owner != Thread.currentThread()) {\n+                throw new AssertionError(\"Wrong thread\");\n+            }\n+        }\n+\n+        ConfinedScope() {\n+            this.owner = Thread.currentThread();\n+        }\n+\n+        void addCloseAction(Runnable runnable) {\n+            checkState();\n+            resources.add(runnable);\n+        }\n+\n+        public void close() {\n+            checkState();\n+            closed = true;\n+            for (Runnable r : resources) {\n+                r.run();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestExHandlerTrap.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267532\n+ * @summary check that uncommon trap is generated for unhandled catch block\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestPrunedExHandler\n+ *\/\n+\n+public class TestPrunedExHandler {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+            \"-XX:+TieredCompilation\", \/\/ we only profile in tier 3\n+            \"-XX:CompileCommand=inline,compiler.c2.irTests.TestPrunedExHandler::inlinee\",\n+            \"-XX:CompileCommand=dontinline,compiler.c2.irTests.TestPrunedExHandler::outOfLine\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UNREACHED_TRAP, \"1\"})\n+    public static void testTrap() {\n+        try {\n+            outOfLine(false);\n+        } catch (IllegalStateException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private static void outOfLine(boolean shouldThrow) {\n+        if (shouldThrow) {\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UNREACHED_TRAP, \"0\"})\n+    public static void testNoTrap(boolean shouldThrow) {\n+        try {\n+            outOfLine(shouldThrow);\n+        } catch (IllegalStateException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Run(test = \"testNoTrap\", mode = RunMode.STANDALONE)\n+    public static void runNoTrap(RunInfo info) {\n+        for (int i = 0; i < 2_000; i++) { \/\/ tier 3\n+            testNoTrap(false);\n+        }\n+\n+        TestFramework.assertCompiledAtLevel(info.getTest(), CompLevel.C1_FULL_PROFILE);\n+\n+        testNoTrap(true); \/\/ mark ex handler as entered\n+\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4\n+            testNoTrap(false); \/\/ should have no trap\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UNREACHED_TRAP, \"0\"})\n+    public static void testNoTrapAfterDeopt(boolean shouldThrow) {\n+        try {\n+            outOfLine(shouldThrow);\n+        } catch (IllegalStateException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Run(test = \"testNoTrapAfterDeopt\", mode = RunMode.STANDALONE)\n+    public static void runNoTrapAfterDeopt(RunInfo info) {\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4\n+            testNoTrapAfterDeopt(false);\n+        }\n+\n+        TestFramework.assertCompiledByC2(info.getTest());\n+\n+        testNoTrapAfterDeopt(true); \/\/ deopt + mark ex handler as entered\n+\n+        TestFramework.assertDeoptimizedByC2(info.getTest());\n+\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4 again\n+            testNoTrapAfterDeopt(false); \/\/ should have no trap\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UNREACHED_TRAP, \"0\"})\n+    public static void testNoTrapAfterDeoptInlined(boolean shouldThrow) {\n+        \/\/ check that we handle exception thrown in inlinee, caught in caller.\n+        \/\/ C2 handles exception dispatch differently for those cases\n+        try {\n+            inlinee(shouldThrow);\n+        } catch (IllegalStateException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private static void inlinee(boolean shouldThrow) {\n+        outOfLine(shouldThrow);\n+    }\n+\n+    @Run(test = \"testNoTrapAfterDeoptInlined\", mode = RunMode.STANDALONE)\n+    public static void runNoTrapAfterDeoptInlined(RunInfo info) {\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4\n+            testNoTrapAfterDeoptInlined(false);\n+        }\n+\n+        TestFramework.assertCompiledByC2(info.getTest());\n+\n+        testNoTrapAfterDeoptInlined(true); \/\/ deopt + mark ex handler as entered\n+\n+        TestFramework.assertDeoptimizedByC2(info.getTest());\n+\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4 again\n+            testNoTrapAfterDeoptInlined(false); \/\/ should have no trap\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPrunedExHandler.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -552,1 +552,1 @@\n-        trapNodes(INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\"intrinsic_or_type_checked_inlining\");\n+        trapNodes(INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP, \"intrinsic_or_type_checked_inlining\");\n@@ -557,1 +557,1 @@\n-        trapNodes(INTRINSIC_TRAP,\"intrinsic\");\n+        trapNodes(INTRINSIC_TRAP, \"intrinsic\");\n@@ -1027,1 +1027,1 @@\n-        trapNodes(NULL_ASSERT_TRAP,\"null_assert\");\n+        trapNodes(NULL_ASSERT_TRAP, \"null_assert\");\n@@ -1032,1 +1032,1 @@\n-        trapNodes(NULL_CHECK_TRAP,\"null_check\");\n+        trapNodes(NULL_CHECK_TRAP, \"null_check\");\n@@ -1116,1 +1116,1 @@\n-        trapNodes(PREDICATE_TRAP,\"predicate\");\n+        trapNodes(PREDICATE_TRAP, \"predicate\");\n@@ -1121,1 +1121,1 @@\n-        trapNodes(RANGE_CHECK_TRAP,\"range_check\");\n+        trapNodes(RANGE_CHECK_TRAP, \"range_check\");\n@@ -1491,1 +1491,1 @@\n-        trapNodes(TRAP,\"reason\");\n+        trapNodes(TRAP, \"reason\");\n@@ -1526,1 +1526,1 @@\n-        trapNodes(UNHANDLED_TRAP,\"unhandled\");\n+        trapNodes(UNHANDLED_TRAP, \"unhandled\");\n@@ -1531,1 +1531,6 @@\n-        trapNodes(UNSTABLE_IF_TRAP,\"unstable_if\");\n+        trapNodes(UNSTABLE_IF_TRAP, \"unstable_if\");\n+    }\n+\n+    public static final String UNREACHED_TRAP = PREFIX + \"UNREACHED_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(UNREACHED_TRAP, \"unreached\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -66,5 +66,5 @@\n-        Arena arena = Arena.ofConfined();\n-        MemorySegment segment = arena.allocate(size);\n-        MemorySegment.copy(arr, start, segment, C_CHAR, 0, size);\n-        arena.close();\n-        return segment;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(size);\n+            MemorySegment.copy(arr, start, segment, C_CHAR, 0, size);\n+            return segment;\n+        }\n@@ -75,4 +75,3 @@\n-        Arena arena = Arena.ofConfined();\n-        MemorySegment segment = arena.allocateFrom(C_CHAR, MemorySegment.ofArray(arr), C_CHAR, start, size);\n-        arena.close();\n-        return segment;\n+        try (Arena arena = Arena.ofConfined()) {\n+            return arena.allocateFrom(C_CHAR, MemorySegment.ofArray(arr), C_CHAR, start, size);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocFromSliceTest.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -71,4 +71,3 @@\n-        Arena arena = Arena.ofConfined();\n-        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n-        arena.close();\n-        return segment;\n+        try (Arena arena = Arena.ofConfined()) {\n+            return arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        }\n@@ -79,4 +78,3 @@\n-        MallocArena arena = new MallocArena();\n-        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n-        arena.close();\n-        return segment;\n+        try (MallocArena arena = new MallocArena()) {\n+            return arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        }\n@@ -87,4 +85,3 @@\n-        UnsafeArena arena = new UnsafeArena();\n-        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n-        arena.close();\n-        return segment;\n+        try (UnsafeArena arena = new UnsafeArena()) {\n+            return arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        }\n@@ -95,4 +92,3 @@\n-        Arena arena = pool.acquire();\n-        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n-        arena.close();\n-        return segment;\n+        try (Arena arena = pool.acquire()) {\n+            return arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocFromTest.java","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -68,4 +68,3 @@\n-        Arena arena = Arena.ofConfined();\n-        MemorySegment segment = arena.allocate(size);\n-        arena.close();\n-        return segment;\n+        try (Arena arena = Arena.ofConfined()) {\n+            return arena.allocate(size);\n+        }\n@@ -76,4 +75,3 @@\n-        CallocArena arena = new CallocArena();\n-        MemorySegment segment = arena.allocate(size);\n-        arena.close();\n-        return segment.address();\n+        try (CallocArena arena = new CallocArena()) {\n+            return arena.allocate(size).address();\n+        }\n@@ -84,4 +82,3 @@\n-        UnsafeArena arena = new UnsafeArena();\n-        MemorySegment segment = arena.allocate(size);\n-        arena.close();\n-        return segment.address();\n+        try (UnsafeArena arena = new UnsafeArena()) {\n+            return arena.allocate(size).address();\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocTest.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class ResourceScopeCloseMin {\n+\n+    Runnable dummy = () -> {};\n+\n+    static class ConfinedScope {\n+        final Thread owner;\n+        boolean closed;\n+        final List<Runnable> resources = new ArrayList<>();\n+\n+        private void checkState() {\n+            if (closed) {\n+                throw new AssertionError(\"Closed\");\n+            } else if (owner != Thread.currentThread()) {\n+                throw new AssertionError(\"Wrong thread\");\n+            }\n+        }\n+\n+        ConfinedScope() {\n+            this.owner = Thread.currentThread();\n+        }\n+\n+        void addCloseAction(Runnable runnable) {\n+            checkState();\n+            resources.add(runnable);\n+        }\n+\n+        public void close() {\n+            checkState();\n+            closed = true;\n+            for (Runnable r : resources) {\n+                r.run();\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void confined_close() {\n+        ConfinedScope scope = new ConfinedScope();\n+        try { \/\/ simulate TWR\n+            scope.addCloseAction(dummy);\n+            scope.close();\n+        } catch (RuntimeException ex) {\n+            scope.close();\n+            throw ex;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void confined_close_notry() {\n+        ConfinedScope scope = new ConfinedScope();\n+        scope.addCloseAction(dummy);\n+        scope.close();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ResourceScopeCloseMin.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -93,1 +93,1 @@\n-    public int panama_strlen() throws Throwable {\n+    public int panama_strlen_alloc() throws Throwable {\n@@ -107,4 +107,3 @@\n-        Arena arena = pool.acquire();\n-        int l = (int) STRLEN.invokeExact(arena.allocateFrom(str));\n-        arena.close();\n-        return l;\n+        try (Arena arena = pool.acquire()) {\n+            return (int) STRLEN.invokeExact(arena.allocateFrom(str));\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -85,4 +85,3 @@\n-        Arena arena = Arena.ofConfined();\n-        MemorySegment segment = arena.allocateFrom(str);\n-        arena.close();\n-        return segment;\n+        try (Arena arena = Arena.ofConfined()) {\n+            return arena.allocateFrom(str);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToCStringTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}