{"files":[{"patch":"@@ -37,3 +37,2 @@\n-    private static class ClassBasic {\n-        int field;\n-        public ClassBasic(int i) { field = i; }\n+    public static void main(String[] args) {\n+        TestFramework.run();\n@@ -41,3 +40,11 @@\n-    private static class ClassWithFinal {\n-        final int field;\n-        public ClassWithFinal(int i) { field = i; }\n+\n+    \/\/ Checks the barrier coalescing\/optimization around field initializations.\n+    \/\/ Uses long fields to avoid store merging.\n+\n+    public static class PlainPlain {\n+        long f1;\n+        long f2;\n+        public PlainPlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n@@ -45,3 +52,8 @@\n-    private static class ClassWithVolatile {\n-        volatile int field;\n-        public ClassWithVolatile(int i) { field = i; }\n+\n+    private static class FinalPlain {\n+        final long f1;\n+        long f2;\n+        public FinalPlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n@@ -50,2 +62,61 @@\n-    public static void main(String[] args) {\n-        TestFramework.run();\n+    private static class PlainFinal {\n+        long f1;\n+        final long f2;\n+        public PlainFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalFinal {\n+        final long f1;\n+        final long f2;\n+        public FinalFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class PlainVolatile {\n+        long f1;\n+        volatile long f2;\n+        public PlainVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatilePlain {\n+        volatile long f1;\n+        long f2;\n+        public VolatilePlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalVolatile {\n+        final long f1;\n+        volatile long f2;\n+        public FinalVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatileFinal {\n+        volatile long f1;\n+        final long f2;\n+        public VolatileFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatileVolatile {\n+        volatile long f1;\n+        volatile long f2;\n+        public VolatileVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n@@ -54,0 +125,5 @@\n+    long l = 42;\n+\n+    @DontInline\n+    public void consume(Object o) {}\n+\n@@ -55,1 +131,1 @@\n-    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n@@ -57,0 +133,8 @@\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_plainPlain() {\n+        PlainPlain c = new PlainPlain(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n@@ -58,2 +142,6 @@\n-    public Object classBasic(int i) {\n-        return new ClassBasic(i);\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_plainFinal() {\n+        PlainFinal c = new PlainFinal(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n@@ -63,1 +151,1 @@\n-    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n@@ -65,3 +153,5 @@\n-    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n-    public int classBasicNoEscape(int i) {\n-        return new ClassBasic(i).field;\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_finalPlain() {\n+        FinalPlain c = new FinalPlain(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n@@ -71,1 +161,1 @@\n-    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n@@ -73,0 +163,9 @@\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_finalFinal() {\n+        FinalFinal c = new FinalFinal(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"1\"})\n@@ -74,2 +173,5 @@\n-    public Object classWithFinal(int i) {\n-        return new ClassWithFinal(i);\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"1\"})\n+    public long escaping_plainVolatile() {\n+        PlainVolatile c = new PlainVolatile(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n@@ -79,5 +181,17 @@\n-    @Arguments(values = {Argument.RANDOM_EACH})\n-    @IR(failOn = IRNode.MEMBAR_RELEASE)\n-    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n-    public int classWithFinalNoEscape(int i) {\n-        return new ClassWithFinal(i).field;\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"1\"})\n+    public long escaping_volatilePlain() {\n+        VolatilePlain c = new VolatilePlain(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"2\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"2\"})\n+    public long escaping_volatileVolatile() {\n+        VolatileVolatile c = new VolatileVolatile(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n@@ -87,1 +201,1 @@\n-    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"1\"})\n@@ -89,0 +203,8 @@\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"1\"})\n+    public long escaping_finalVolatile() {\n+        FinalVolatile c = new FinalVolatile(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n@@ -90,0 +212,1 @@\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n@@ -91,2 +214,18 @@\n-    public Object classWithVolatile(int i) {\n-        return new ClassWithVolatile(i);\n+    public long escaping_volatileFinal() {\n+        VolatileFinal c = new VolatileFinal(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_plainPlain() {\n+        PlainPlain c = new PlainPlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_plainFinal() {\n+        PlainFinal c = new PlainFinal(l);\n+        return c.f1 + c.f2;\n@@ -96,1 +235,8 @@\n-    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_finalPlain() {\n+        FinalPlain c = new FinalPlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n@@ -99,3 +245,48 @@\n-    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n-    public int classWithVolatileNoEscape(int i) {\n-        return new ClassWithVolatile(i).field;\n+    public long non_escaping_finalFinal() {\n+        FinalFinal c = new FinalFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    public long non_escaping_plainVolatile() {\n+        PlainVolatile c = new PlainVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    public long non_escaping_volatilePlain() {\n+        VolatilePlain c = new VolatilePlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    public long non_escaping_volatileVolatile() {\n+        VolatileVolatile c = new VolatileVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    public long non_escaping_finalVolatile() {\n+        FinalVolatile c = new FinalVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    public long non_escaping_volatileFinal() {\n+        VolatileFinal c = new VolatileFinal(l);\n+        return c.f1 + c.f2;\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ConstructorBarriers.java","additions":224,"deletions":33,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -0,0 +1,269 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-Xms512m\", \"-Xmx512m\", \"-XX:+AlwaysPreTouch\", \"-XX:+UseParallelGC\"})\n+public class ConstructorBarriers {\n+\n+    \/\/ Checks the barrier coalescing\/optimization around field initializations.\n+    \/\/ Uses long fields to avoid store merging.\n+\n+    public static class PlainPlain {\n+        long f1;\n+        long f2;\n+        public PlainPlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalPlain {\n+        final long f1;\n+        long f2;\n+        public FinalPlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class PlainFinal {\n+        long f1;\n+        final long f2;\n+        public PlainFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalFinal {\n+        final long f1;\n+        final long f2;\n+        public FinalFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class PlainVolatile {\n+        long f1;\n+        volatile long f2;\n+        public PlainVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatilePlain {\n+        volatile long f1;\n+        long f2;\n+        public VolatilePlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalVolatile {\n+        final long f1;\n+        volatile long f2;\n+        public FinalVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatileFinal {\n+        volatile long f1;\n+        final long f2;\n+        public VolatileFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatileVolatile {\n+        volatile long f1;\n+        volatile long f2;\n+        public VolatileVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    long l = 42;\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_plainPlain(Blackhole bh) {\n+        PlainPlain c = new PlainPlain(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_plainFinal(Blackhole bh) {\n+        PlainFinal c = new PlainFinal(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_finalPlain(Blackhole bh) {\n+        FinalPlain c = new FinalPlain(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_finalFinal(Blackhole bh) {\n+        FinalFinal c = new FinalFinal(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_plainVolatile(Blackhole bh) {\n+        PlainVolatile c = new PlainVolatile(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_volatilePlain(Blackhole bh) {\n+        VolatilePlain c = new VolatilePlain(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_volatileVolatile(Blackhole bh) {\n+        VolatileVolatile c = new VolatileVolatile(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_finalVolatile(Blackhole bh) {\n+        FinalVolatile c = new FinalVolatile(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_volatileFinal(Blackhole bh) {\n+        VolatileFinal c = new VolatileFinal(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_plainPlain() {\n+        PlainPlain c = new PlainPlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_plainFinal() {\n+        PlainFinal c = new PlainFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_finalPlain() {\n+        FinalPlain c = new FinalPlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_finalFinal() {\n+        FinalFinal c = new FinalFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_plainVolatile() {\n+        PlainVolatile c = new PlainVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_volatilePlain() {\n+        VolatilePlain c = new VolatilePlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_volatileVolatile() {\n+        VolatileVolatile c = new VolatileVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_finalVolatile() {\n+        FinalVolatile c = new FinalVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_volatileFinal() {\n+        VolatileFinal c = new VolatileFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/ConstructorBarriers.java","additions":269,"deletions":0,"binary":false,"changes":269,"status":"added"}]}