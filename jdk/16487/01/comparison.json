{"files":[{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+\n+\/**\n+ * This class extends ByteArrayOutputStream by optimizing internal buffering.\n+ * It skips bounds checking, as the buffers are known and input previously\n+ * checked.  toByteArray() returns the internal buffer to avoid an extra copy.\n+ *\n+ * This uses `count` to determine the state of `buf`.  `buf` can still\n+ * point to an array while `count` equals zero.\n+ *\/\n+final class AEADBufferedStream extends ByteArrayOutputStream {\n+\n+    \/**\n+     * Create an instance with the specified buffer\n+     *\/\n+\n+    public AEADBufferedStream(int len) {\n+        super(len);\n+    }\n+\n+    \/**\n+     * This method saves memory by returning the internal buffer. If\n+     * internal buffer is larger than the data stored {@code count}, a copy is\n+     * returned.\n+     *\n+     * @return internal or new byte array of non-blocksize data.\n+     *\/\n+    @Override\n+    public byte[] toByteArray() {\n+        if (buf.length > count) {\n+            return Arrays.copyOfRange(buf, 0, count);\n+        }\n+        return buf;\n+    }\n+\n+    \/**\n+     * Takes a ByteBuffer writing non-blocksize data directly to the internal\n+     * buffer.\n+     * @param src remaining non-blocksize ByteBuffer\n+     *\/\n+    public void write(ByteBuffer src) {\n+        int pos = src.position();\n+        int len = src.remaining();\n+\n+        if (src.hasArray()) {\n+            write(src.array(), pos + src.arrayOffset(), len);\n+            src.position(pos + len);\n+            return;\n+        }\n+        if (buf == null) {\n+            buf = new byte[len];\n+            src.get(buf);\n+            count = buf.length;\n+        } else {\n+            if (buf.length < (count + len)) {\n+                buf = Arrays.copyOf(buf, count + len);\n+            }\n+            src.get(buf, count, len);\n+            count += len;\n+        }\n+    }\n+\n+    @Override\n+    public void write(byte[] in, int offset, int len) {\n+        if (buf == null) {\n+            buf = new byte[len];\n+            System.arraycopy(in, offset, buf, 0, len);\n+            count = buf.length;\n+        } else {\n+            \/\/ Create a new larger buffer and append the new data\n+            if (buf.length < count + len) {\n+                buf = Arrays.copyOf(buf, count + len);\n+            }\n+\n+            System.arraycopy(in, offset, buf, count, len);\n+            count += len;\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return (count == 0 ? \"null\" : HexFormat.of().formatHex(buf));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AEADBufferedStream.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.ByteArrayOutputStream;\n@@ -67,1 +66,0 @@\n-    private static final int CIPHERBUF_BASE = 1024;\n@@ -653,1 +651,1 @@\n-            throw new RuntimeException(exc);\n+            throw new ProviderException(exc);\n@@ -684,1 +682,1 @@\n-            throw new RuntimeException(ke);\n+            throw new ProviderException(ke);\n@@ -689,0 +687,24 @@\n+    \/**\n+     * Update the currently running operation with additional data\n+     *\n+     * @param input the plaintext or ciphertext ByteBuffer\n+     * @param output ByteBuffer that will hold the resulting data.  This\n+     *      must be large enough to hold the resulting data.\n+     *\n+     * @return the length in bytes of the data written into the {@code out}\n+     *      buffer.\n+     *\n+     * @throws ShortBufferException if the buffer {@code out} does not have\n+     *      enough space to hold the resulting data.\n+     *\/\n+    @Override\n+    protected int engineUpdate(ByteBuffer input, ByteBuffer output)\n+        throws ShortBufferException {\n+        try {\n+            return bufferCrypt(input, output, true);\n+        } catch (AEADBadTagException e) {\n+            \/\/ exception is never thrown by update ops\n+            return 0;\n+        }\n+    }\n+\n@@ -756,0 +778,112 @@\n+    \/**\n+     * Complete the currently running operation using any final\n+     * data provided by the caller.\n+     *\n+     * @param input the plaintext or ciphertext input bytebuffer.\n+     * @param output ByteBuffer that will hold the resulting data.  This\n+     *      must be large enough to hold the resulting data.\n+     *\n+     * @return the resulting plaintext or ciphertext bytes.\n+     *\n+     * @throws AEADBadTagException if, during decryption, the provided tag\n+     *      does not match the calculated tag.\n+     *\/\n+    @Override\n+    protected int engineDoFinal(ByteBuffer input, ByteBuffer output)\n+        throws ShortBufferException, AEADBadTagException {\n+        return bufferCrypt(input, output, false);\n+    }\n+\n+    \/*\n+     * Optimized version of bufferCrypt from CipherSpi.java.  Direct\n+     * ByteBuffers send to the engine code.\n+     *\/\n+    private int bufferCrypt(ByteBuffer input, ByteBuffer output,\n+        boolean isUpdate) throws ShortBufferException, AEADBadTagException {\n+        if ((input == null) || (output == null)) {\n+            throw new NullPointerException\n+                (\"Input and output buffers must not be null\");\n+        }\n+        int inPos = input.position();\n+        int inLimit = input.limit();\n+        int inLen = inLimit - inPos;\n+        if (isUpdate && (inLen == 0)) {\n+            return 0;\n+        }\n+        int outLenNeeded = engine.getOutputSize(inLen, !isUpdate);\n+\n+        if (output.remaining() < outLenNeeded) {\n+            throw new ShortBufferException(\"Need at least \" + outLenNeeded\n+                + \" bytes of space in output buffer\");\n+        }\n+\n+        int total = 0;\n+\n+        \/\/ Check if input bytebuffer is heap-backed\n+        if (input.hasArray()) {\n+            byte[] inArray = input.array();\n+            int inOfs = input.arrayOffset() + inPos;\n+\n+            byte[] outArray;\n+            \/\/ Check if output bytebuffer is heap-backed\n+            if (output.hasArray()) {\n+                outArray = output.array();\n+                int outPos = output.position();\n+                int outOfs = output.arrayOffset() + outPos;\n+\n+                \/\/ check array address and offsets and use temp output buffer\n+                \/\/ if output offset is larger than input offset and\n+                \/\/ falls within the range of input data\n+                boolean useTempOut = false;\n+                if (inArray == outArray &&\n+                    ((inOfs < outOfs) && (outOfs < inOfs + inLen))) {\n+                    useTempOut = true;\n+                    outArray = new byte[outLenNeeded];\n+                    outOfs = 0;\n+                }\n+                try {\n+                    if (isUpdate) {\n+                        total = engine.doUpdate(inArray, inOfs, inLen, outArray,\n+                            outOfs);\n+                    } else {\n+                        total = engine.doFinal(inArray, inOfs, inLen, outArray,\n+                            outOfs);\n+                    }\n+                } catch (KeyException e) {\n+                    throw new ProviderException(e);\n+                }\n+                if (useTempOut) {\n+                    output.put(outArray, outOfs, total);\n+                } else {\n+                    \/\/ adjust output position manually\n+                    output.position(outPos + total);\n+                }\n+            } else { \/\/ if output is direct\n+                if (isUpdate) {\n+                    outArray = engineUpdate(inArray, inOfs, inLen);\n+                } else {\n+                    outArray = engineDoFinal(inArray, inOfs, inLen);\n+                }\n+                if (outArray != null && outArray.length != 0) {\n+                    output.put(outArray);\n+                    total = outArray.length;\n+                }\n+            }\n+            \/\/ adjust input position manually\n+            input.position(inLimit);\n+        } else {  \/\/ Bytebuffers are both direct\n+            try {\n+                if (isUpdate) {\n+                    return engine.doUpdate(input, output);\n+                }\n+                return engine.doFinal(input, output);\n+            } catch (KeyException e) {\n+                throw new ProviderException(e);\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+\n+\n@@ -1246,0 +1380,5 @@\n+\n+        int doUpdate(ByteBuffer input, ByteBuffer output) throws\n+            ShortBufferException, KeyException;\n+        int doFinal(ByteBuffer input, ByteBuffer output) throws\n+            ShortBufferException, KeyException, AEADBadTagException;\n@@ -1288,0 +1427,16 @@\n+\n+        @Override\n+        public int doUpdate(ByteBuffer input, ByteBuffer output) throws\n+            ShortBufferException, KeyException {\n+            byte[] data = new byte[input.remaining()];\n+            input.get(data);\n+            doUpdate(data, 0, data.length, data, 0);\n+            output.put(data);\n+            return data.length;\n+        }\n+\n+        @Override\n+        public int doFinal(ByteBuffer input, ByteBuffer output)\n+            throws ShortBufferException, KeyException {\n+            return doUpdate(input, output);\n+        }\n@@ -1351,0 +1506,21 @@\n+\n+        @Override\n+        public int doUpdate(ByteBuffer input, ByteBuffer output) throws\n+            ShortBufferException, KeyException {\n+            byte[] data = new byte[input.remaining()];\n+            input.get(data);\n+            doUpdate(data, 0, data.length, data, 0);\n+            output.put(data);\n+            return data.length;\n+        }\n+\n+        @Override\n+        public int doFinal(ByteBuffer input, ByteBuffer output) throws\n+            ShortBufferException, KeyException {\n+            int len = input.remaining();\n+            byte[] data = new byte[len + TAG_LENGTH];\n+            input.get(data, 0, len);\n+            doFinal(data, 0, len, data, 0);\n+            output.put(data);\n+            return data.length;\n+        }\n@@ -1355,1 +1531,1 @@\n-        private final ByteArrayOutputStream cipherBuf;\n+        private AEADBufferedStream cipherBuf;\n@@ -1367,1 +1543,14 @@\n-                            cipherBuf.size()), 0) : 0);\n+                            getBufferedLength()), 0) : 0);\n+        }\n+\n+        private void initBuffer(int len) {\n+            if (cipherBuf == null) {\n+                cipherBuf = new AEADBufferedStream(len);\n+            }\n+        }\n+\n+        private int getBufferedLength() {\n+            if (cipherBuf != null) {\n+                return cipherBuf.size();\n+            }\n+            return 0;\n@@ -1374,1 +1563,0 @@\n-            cipherBuf = new ByteArrayOutputStream(CIPHERBUF_BASE);\n@@ -1380,1 +1568,1 @@\n-                int outOff) {\n+            int outOff) {\n@@ -1392,0 +1580,1 @@\n+                    initBuffer(inLen);\n@@ -1402,0 +1591,8 @@\n+\n+        @Override\n+        public int doUpdate(ByteBuffer input, ByteBuffer output) {\n+            initBuffer(input.remaining());\n+            cipherBuf.write(input);\n+            return 0;\n+        }\n+\n@@ -1409,1 +1606,1 @@\n-            if (cipherBuf.size() == 0 && inOff == 0) {\n+            if (getBufferedLength() == 0) {\n@@ -1419,0 +1616,1 @@\n+                inOff = 0;\n@@ -1420,0 +1618,1 @@\n+                cipherBuf.reset();\n@@ -1421,1 +1620,0 @@\n-            cipherBuf.reset();\n@@ -1439,2 +1637,2 @@\n-            authFinalizeData(ctPlusTag, 0, ctLen, tag, 0);\n-            long tagCompare = ((long)asLongView.get(ctPlusTag, ctLen) ^\n+            authFinalizeData(ctPlusTag, inOff, ctLen, tag, 0);\n+            long tagCompare = ((long)asLongView.get(ctPlusTag, ctLen + inOff) ^\n@@ -1442,1 +1640,1 @@\n-                    ((long)asLongView.get(ctPlusTag, ctLen + Long.BYTES) ^\n+                    ((long)asLongView.get(ctPlusTag, ctLen + inOff + Long.BYTES) ^\n@@ -1447,1 +1645,1 @@\n-            chaCha20Transform(ctPlusTag, 0, ctLen, out, outOff);\n+            chaCha20Transform(ctPlusTag, inOff, ctLen, out, outOff);\n@@ -1452,0 +1650,53 @@\n+\n+        @Override\n+        public int doFinal(ByteBuffer input, ByteBuffer output)\n+            throws ShortBufferException, AEADBadTagException, KeyException {\n+            int len;\n+            int inLen = input.remaining();\n+            byte[] ct, buf = (getBufferedLength() == 0 ? null : cipherBuf.toByteArray());\n+            int ctLen = getBufferedLength() + inLen;\n+            if (ctLen < TAG_LENGTH) {\n+                throw new AEADBadTagException(\"Input too short - need tag\");\n+            }\n+            if (inLen == 0) {\n+                ct = buf;\n+                buf = null;\n+                len = ctLen;\n+            } else if (inLen < TAG_LENGTH) {\n+                doUpdate(input, output);\n+                ct = cipherBuf.toByteArray();\n+                buf = null;\n+                len = ctLen;\n+            } else {\n+                ct = new byte[inLen];\n+                input.get(ct, 0, inLen);\n+                len = inLen;\n+            }\n+            doUpdate(null, 0, 0, null, 0);\n+\n+            \/\/ If there is an internal buffer, calculate its tag contribution.\n+            if (buf != null) {\n+                dataLen = authUpdate(buf, 0, buf.length);\n+            }\n+            \/\/ Complete tag calculation\n+            len -= TAG_LENGTH;\n+            authFinalizeData(ct, 0, len, tag, 0);\n+            \/\/ Check tag\n+            if ((((long) asLongView.get(ct, len) ^\n+                (long) asLongView.get(tag, 0)) |\n+                ((long) asLongView.get(ct, len + Long.BYTES) ^\n+                    (long) asLongView.get(tag, Long.BYTES))) != 0) {\n+                throw new AEADBadTagException(\"Tag mismatch\");\n+            }\n+\n+            \/\/ decrypt internal buffer in-place, then put it into the bytebuffer\n+            if (buf != null) {\n+                chaCha20Transform(buf, 0, buf.length, buf, 0);\n+                output.put(buf, 0, buf.length);\n+            }\n+            \/\/ decrypt input buffer in-place, append it to the bytebuffer\n+            chaCha20Transform(ct, 0, len, ct, 0);\n+            output.put(ct, 0, len);\n+            aadDone = false;\n+            return ctLen - TAG_LENGTH;\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ChaCha20Cipher.java","additions":265,"deletions":14,"binary":false,"changes":279,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,0 @@\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n@@ -252,1 +250,1 @@\n-            iv == null ? createIv(random) : iv.clone());\n+            iv == null ? createIv(random) : iv);  \/\/ iv.clone() not necessary\n@@ -683,1 +681,1 @@\n-        ByteArrayOutputStream aadBuffer = null;\n+        AEADBufferedStream aadBuffer = null;\n@@ -688,1 +686,1 @@\n-        ByteArrayOutputStream ibuffer = null;\n+        AEADBufferedStream ibuffer = null;\n@@ -739,1 +737,1 @@\n-                ibuffer = new ByteArrayOutputStream(len);\n+                ibuffer = new AEADBufferedStream(len);\n@@ -825,1 +823,1 @@\n-         * Continues a multi-part update of the Additional Authentication\n+         * Continues a multipart update of the Additional Authentication\n@@ -846,1 +844,1 @@\n-                    aadBuffer = new ByteArrayOutputStream(len);\n+                    aadBuffer = new AEADBufferedStream(len);\n@@ -1170,1 +1168,1 @@\n-            \/\/ Encrypt the remaining blocks inside of 'in'\n+            \/\/ Encrypt the remaining blocks inside 'in'\n@@ -1254,2 +1252,0 @@\n-                byte[] b = new byte[srcLen];\n-                src.get(b);\n@@ -1257,5 +1253,1 @@\n-                try {\n-                    ibuffer.write(b);\n-                } catch (IOException e) {\n-                    throw new RuntimeException(e);\n-                }\n+                ibuffer.write(src);\n@@ -1478,9 +1470,2 @@\n-                    byte[] b = new byte[src.remaining()];\n-                    src.get(b);\n-                    initBuffer(b.length);\n-                    try {\n-                        ibuffer.write(b);\n-                    } catch (IOException e) {\n-                        throw new ProviderException(\n-                            \"Unable to add remaining input to the buffer\", e);\n-                    }\n+                    initBuffer(src.remaining());\n+                    ibuffer.write(src);\n@@ -1494,1 +1479,1 @@\n-         * data.  If the verification fails, the 'out' left to it's original\n+         * data.  If the verification fails, the 'out' left to its original\n@@ -1554,1 +1539,1 @@\n-         * data.  If the verification fails, the 'dst' left to it's original\n+         * data.  If the verification fails, the 'dst' left to its original\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":13,"deletions":28,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,900 @@\n+\/*\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Use Cipher update and doFinal with a mixture of byte[], bytebuffer,\n+ * and offset while verifying return values.  Also using different and\n+ * in-place buffers.\n+ *\n+ * in-place is not tested with different buffer types as it is not a logical\n+ * scenario and is complicated by getOutputSize calculations.\n+ *\/\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+public class AEADBufferTest implements Cloneable {\n+\n+    \/\/ Data type for the operation\n+    enum dtype { BYTE, HEAP, DIRECT };\n+    \/\/ Data map\n+    static HashMap<String, List<Data>> datamap = new HashMap<>();\n+    \/\/ List of enum values for order of operation\n+    List<dtype> ops;\n+\n+    static final String AES = \"AES\";\n+    \/\/ The remaining input data length is inserted at the particular index\n+    \/\/ in sizes[] during execution.\n+    static final int REMAINDER = -1;\n+\n+    String algo;\n+    boolean same = true;\n+    int[] sizes;\n+    boolean incremental = false;\n+    \/\/ In some cases the theoretical check is too complicated to verify\n+    boolean theoreticalCheck;\n+    List<Data> dataSet;\n+    int inOfs = 0, outOfs = 0;\n+    static HexFormat hex = HexFormat.of();\n+\n+    static class Data {\n+        int id;\n+        SecretKey key;\n+        byte[] iv;\n+        int counter;  \/\/ for CC20\n+        byte[] pt;\n+        byte[] aad;\n+        byte[] ct;\n+        byte[] tag;\n+        int blockSize;  \/\/ 16 for GCM, 0 for CC20\n+\n+        Data(String keyalgo, int id, String key, String iv, byte[] pt, String aad,\n+            String ct, String tag) {\n+            this(keyalgo, id, key, iv, 0,pt, aad, ct,tag);\n+        }\n+\n+        Data(String keyalgo, int id, String key, String iv, String pt, String aad,\n+            String ct, String tag) {\n+            this(keyalgo, id, key, iv, HexToBytes(pt), aad, ct, tag);\n+        }\n+\n+        Data(String keyalgo, int id, String key, String iv, int counter, byte[] pt, String aad,\n+            String ct, String tag) {\n+            this.id = id;\n+            this.key = new SecretKeySpec(HexToBytes(key), keyalgo);\n+            this.iv = HexToBytes(iv);\n+            this.counter = counter;\n+            this.pt = pt;\n+            this.aad = HexToBytes(aad);\n+            this.ct = HexToBytes(ct);\n+            this.tag = HexToBytes(tag);\n+            this.blockSize = (keyalgo.equals(AES) ? 16 : 0);\n+        }\n+\n+        Data(String keyalgo, int id, String key, String iv, int counter, String pt, String aad,\n+            String ct, String tag) {\n+            this(keyalgo, id, key, iv, counter, HexToBytes(pt), aad, ct, tag);\n+        }\n+\n+        Data(String keyalgo, int id, String key, int ivLen, int ptlen) {\n+            this.id = id;\n+            this.key = new SecretKeySpec(HexToBytes(key), keyalgo);\n+            iv = new byte[ivLen];\n+            counter = 0;\n+            pt = new byte[ptlen];\n+            tag = new byte[16];\n+            aad = new byte[0];\n+            boolean isGCM = keyalgo.equals(AES);\n+            this.blockSize = (isGCM ? 16 : 0);\n+            byte[] tct = null;\n+            try {\n+                SecureRandom r = new SecureRandom();\n+                r.nextBytes(iv);\n+                r.nextBytes(pt);\n+                Cipher c = Cipher.getInstance(isGCM ? \"AES\/GCM\/NoPadding\": \"ChaCha20-Poly1305\");\n+                c.init(Cipher.ENCRYPT_MODE, this.key,\n+                    getAPS(keyalgo, tag.length, iv));\n+                tct = c.doFinal(pt);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Error in generating data for length \" +\n+                    ptlen, e);\n+            }\n+            ct = new byte[ptlen];\n+            System.arraycopy(tct, 0, ct, 0, ct.length);\n+            System.arraycopy(tct, ct.length, tag, 0, tag.length);\n+        }\n+\n+        private static byte[] HexToBytes(String hexVal) {\n+            if (hexVal == null) {\n+                return new byte[0];\n+            }\n+            return hex.parseHex(hexVal);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Construct a test with an algorithm and a list of dtype.\n+     * @param algo Algorithm string\n+     * @param ops List of dtypes.  If only one dtype is specified, only a\n+     *            doFinal operation will occur.  If multiple dtypes are\n+     *            specified, the last is a doFinal, the others are updates.\n+     *\/\n+    AEADBufferTest(String algo, List<dtype> ops) {\n+        this.algo = algo;\n+        this.ops = ops;\n+        theoreticalCheck = true;\n+        dataSet = datamap.get(algo);\n+    }\n+\n+    public AEADBufferTest clone() throws CloneNotSupportedException{\n+        return (AEADBufferTest)super.clone();\n+    }\n+\n+    \/**\n+     * Define particular data sizes to be tested.  \"REMAINDER\", which has a\n+     * value of -1, can be used to insert the remaining input text length at\n+     * that index during execution.\n+     * @param sizes Data sizes for each dtype in the list.\n+     *\/\n+    AEADBufferTest dataSegments(int[] sizes) {\n+        this.sizes = sizes;\n+        return this;\n+    }\n+\n+    \/**\n+     * Do not perform in-place operations\n+     *\/\n+    AEADBufferTest differentBufferOnly() {\n+        this.same = false;\n+        return this;\n+    }\n+\n+    \/**\n+     * Enable incrementing through each data size available.  This can only be\n+     * used when the List has more than one dtype entry.\n+     *\/\n+    AEADBufferTest incrementalSegments() {\n+        this.incremental = true;\n+        return this;\n+    }\n+\n+    \/**\n+     * Specify a particular test dataset.\n+     *\n+     * @param id id value for the test data to used in this test.\n+     *\/\n+    AEADBufferTest dataSet(int id) throws Exception {\n+        for (Data d : datamap.get(algo)) {\n+            if (d.id == id) {\n+                dataSet = List.of(d);\n+                return this;\n+            }\n+        }\n+        throw new Exception(\"Unable to find dataSet id = \" + id);\n+    }\n+\n+    \/**\n+     * Set both input and output offsets to the same offset\n+     * @param offset value for inOfs and outOfs\n+     * @return\n+     *\/\n+    AEADBufferTest offset(int offset) {\n+        this.inOfs = offset;\n+        this.outOfs = offset;\n+        return this;\n+    }\n+\n+    \/**\n+     * Set the input offset\n+     * @param offset value for input offset\n+     *\/\n+    AEADBufferTest inOfs(int offset) {\n+        this.inOfs = offset;\n+        return this;\n+    }\n+\n+    \/**\n+     * Set the output offset\n+     * @param offset value for output offset\n+     *\/\n+    AEADBufferTest outOfs(int offset) {\n+        this.outOfs = offset;\n+        return this;\n+    }\n+\n+    \/**\n+     * Reverse recursive loop that starts at the end-1 index, going to 0, in\n+     * the size array to calculate all the possible sizes.\n+     * It returns the remaining data size not used in the loop.  This remainder\n+     * is used for the end index which is the doFinal op.\n+     *\/\n+    int inc(int index, int max, int total) {\n+        if (sizes[index] == max - total) {\n+            sizes[index + 1]++;\n+            total++;\n+            sizes[index] = 0;\n+        } else if (index == 0) {\n+            sizes[index]++;\n+        }\n+\n+        total += sizes[index];\n+        if (index > 0) {\n+            return inc(index - 1, max, total);\n+        }\n+        return total;\n+    }\n+\n+    \/\/ Call recursive loop and take returned remainder value for last index\n+    boolean incrementSizes(int max) {\n+        sizes[ops.size() - 1] = max - inc(ops.size() - 2, max, 0);\n+        if (sizes[ops.size() - 2] == max) {\n+            \/\/ We are at the end, exit test loop\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    void test() throws Exception {\n+        int i = 1;\n+        System.err.println(\"Algo: \" + algo + \" \\tOps: \" + ops.toString());\n+        for (Data data : dataSet) {\n+\n+            \/\/ If incrementalSegments is enabled, run through that test only\n+            if (incremental) {\n+                if (ops.size() < 2) {\n+                    throw new Exception(\"To do incrementalSegments you must \" +\n+                        \"have more that 1 dtype in the list\");\n+                }\n+                sizes = new int[ops.size()];\n+\n+                while (incrementSizes(data.pt.length)) {\n+                    System.err.print(\"Encrypt:  Data Index: \" + i + \" \\tSizes[ \");\n+                    for (int v : sizes) {\n+                        System.err.print(v + \" \");\n+                    }\n+                    System.err.println(\"]\");\n+                    encrypt(data);\n+                }\n+                Arrays.fill(sizes, 0);\n+\n+                while (incrementSizes(data.ct.length + data.tag.length)) {\n+                    System.err.print(\"Decrypt:  Data Index: \" + i + \" \\tSizes[ \");\n+                    for (int v : sizes) {\n+                        System.err.print(v + \" \");\n+                    }\n+                    System.err.println(\"]\");\n+                    decrypt(data);\n+                }\n+\n+            } else {\n+                \/\/ Default test of 0 and 2 offset doing in place and different\n+                \/\/ i\/o buffers\n+                System.err.println(\"Encrypt:  Data Index: \" + i);\n+                encrypt(data);\n+\n+                System.err.println(\"Decrypt:  Data Index: \" + i);\n+                decrypt(data);\n+            }\n+            i++;\n+        }\n+    }\n+\n+    \/\/ Setup data for encryption\n+    void encrypt(Data data) throws Exception {\n+        byte[] input, output;\n+\n+        input = data.pt;\n+        output = new byte[data.ct.length + data.tag.length];\n+        System.arraycopy(data.ct, 0, output, 0, data.ct.length);\n+        System.arraycopy(data.tag, 0, output, data.ct.length,\n+            data.tag.length);\n+\n+        \/\/ Test different input\/output buffers\n+        System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            inOfs + \"  outOfs \" + outOfs + \"  in\/out buffer: different\");\n+        crypto(true, data, input, output);\n+\n+        \/\/ Test with in-place buffers\n+        if (same) {\n+            System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+                inOfs + \"  outOfs \" + outOfs + \"  in\/out buffer: in-place\");\n+            cryptoSameBuffer(true, data, input, output);\n+        }\n+    }\n+\n+    \/\/ Setup data for decryption\n+    void decrypt(Data data) throws Exception {\n+        byte[] input, output;\n+\n+        input = new byte[data.ct.length + data.tag.length];\n+        System.arraycopy(data.ct, 0, input, 0, data.ct.length);\n+        System.arraycopy(data.tag, 0, input, data.ct.length, data.tag.length);\n+        output = data.pt;\n+\n+        \/\/ Test different input\/output buffers\n+        System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            inOfs + \"  outOfs \" + outOfs + \"  in\/out buffer: different\");\n+        crypto(false, data, input, output);\n+\n+        \/\/ Test with in-place buffers\n+        if (same) {\n+            System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+                inOfs + \"  outOfs \" + outOfs + \"  in-place: same\");\n+            cryptoSameBuffer(false, data, input, output);\n+        }\n+    }\n+\n+    static AlgorithmParameterSpec getAPS(String algo, int tLen, byte[] iv) {\n+        return switch (algo) {\n+            case \"AES\", \"AES\/GCM\/NoPadding\" ->\n+                new GCMParameterSpec(tLen * 8, iv);\n+            case \"CC20\", \"ChaCha20-Poly1305\" -> new IvParameterSpec(iv);\n+            default -> null;\n+        };\n+    }\n+\n+    \/**\n+     * Perform cipher operation using different input and output buffers.\n+     *   This method allows mixing of data types (byte, heap, direct).\n+     *\/\n+    void crypto(boolean encrypt, Data d, byte[] input, byte[] output)\n+        throws Exception {\n+        byte[] pt = new byte[input.length + inOfs];\n+        System.arraycopy(input, 0, pt, inOfs, input.length);\n+        byte[] expectedOut = new byte[output.length + outOfs];\n+        System.arraycopy(output, 0, expectedOut, outOfs, output.length);\n+        int plen = input.length \/ ops.size(); \/\/ partial input length\n+        int theoreticallen;\/\/ expected output length\n+        int dataoffset = 0; \/\/ offset of unconsumed data in pt\n+        int index = 0; \/\/ index of which op we are on\n+        int rlen; \/\/ result length\n+        int pbuflen = 0; \/\/ plen remaining in the internal buffers\n+\n+        Cipher cipher = Cipher.getInstance(algo);\n+        cipher.init((encrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE),\n+            d.key, getAPS(algo, d.tag.length, d.iv));\n+        cipher.updateAAD(d.aad);\n+\n+        ByteArrayOutputStream ba = new ByteArrayOutputStream();\n+        ba.write(new byte[outOfs], 0, outOfs);\n+        for (dtype v : ops) {\n+            if (index < ops.size() - 1) {\n+                if (sizes != null && input.length > 0) {\n+                    if (sizes[index] == -1) {\n+                        plen = input.length - dataoffset;\n+                    } else {\n+                        if (sizes[index] > input.length) {\n+                            plen = input.length;\n+                        } else {\n+                            plen = sizes[index];\n+                        }\n+                    }\n+                }\n+\n+                int olen = cipher.getOutputSize(plen) + outOfs;\n+\n+                \/*\n+                 * The theoretical limit is the length of the data sent to\n+                 * update() + any data might be setting in CipherCore or AEAD\n+                 * internal buffers % the block size.\n+                 *\/\n+                theoreticallen = (plen + pbuflen) - (d.blockSize > 0 ?\n+                    (plen + pbuflen) % d.blockSize : 0);\n+\n+                \/\/ Update operations\n+                switch (v) {\n+                    case BYTE -> {\n+                        byte[] out = new byte[olen];\n+                        rlen = cipher.update(pt, dataoffset + inOfs, plen, out,\n+                            outOfs);\n+                        ba.write(out, outOfs, rlen);\n+                    }\n+                    case HEAP -> {\n+                        ByteBuffer b = ByteBuffer.allocate(plen + outOfs);\n+                        b.position(outOfs);\n+                        b.put(pt, dataoffset + inOfs, plen);\n+                        b.flip();\n+                        b.position(outOfs);\n+                        ByteBuffer out = ByteBuffer.allocate(olen);\n+                        out.position(outOfs);\n+                        rlen = cipher.update(b, out);\n+                        ba.write(out.array(), outOfs, rlen);\n+                    }\n+                    case DIRECT -> {\n+                        ByteBuffer b = ByteBuffer.allocateDirect(plen + outOfs);\n+                        b.position(outOfs);\n+                        b.put(pt, dataoffset + inOfs, plen);\n+                        b.flip();\n+                        b.position(outOfs);\n+                        ByteBuffer out = ByteBuffer.allocateDirect(olen);\n+                        out.position(outOfs);\n+                        rlen = cipher.update(b, out);\n+                        byte[] o = new byte[rlen];\n+                        out.flip();\n+                        out.position(outOfs);\n+                        out.get(o, 0, rlen);\n+                        ba.write(o);\n+                    }\n+                    default -> throw new Exception(\"Unknown op: \" + v.name());\n+                }\n+\n+                if (theoreticalCheck) {\n+                    pbuflen += plen - rlen;\n+                    if (encrypt && rlen != theoreticallen) {\n+                        throw new Exception(\"Wrong update return len (\" +\n+                            v.name() + \"):  \" + \"rlen=\" + rlen +\n+                            \", expected output len=\" + theoreticallen);\n+                    }\n+                }\n+\n+                dataoffset += plen;\n+                index++;\n+\n+            } else {\n+                \/\/ doFinal operation\n+                plen = input.length - dataoffset;\n+\n+                int olen = cipher.getOutputSize(plen) + outOfs;\n+                switch (v) {\n+                    case BYTE -> {\n+                        byte[] out = new byte[olen];\n+                        rlen = cipher.doFinal(pt, dataoffset + inOfs,\n+                            plen, out, outOfs);\n+                        ba.write(out, outOfs, rlen);\n+                    }\n+                    case HEAP -> {\n+                        ByteBuffer b = ByteBuffer.allocate(plen + inOfs);\n+                        b.limit(b.capacity());\n+                        b.position(inOfs);\n+                        b.put(pt, dataoffset + inOfs, plen);\n+                        b.flip();\n+                        b.position(inOfs);\n+                        ByteBuffer out = ByteBuffer.allocate(olen);\n+                        out.limit(out.capacity());\n+                        out.position(outOfs);\n+                        rlen = cipher.doFinal(b, out);\n+                        ba.write(out.array(), outOfs, rlen);\n+                    }\n+                    case DIRECT -> {\n+                        ByteBuffer b = ByteBuffer.allocateDirect(plen + inOfs);\n+                        b.limit(b.capacity());\n+                        b.position(inOfs);\n+                        b.put(pt, dataoffset + inOfs, plen);\n+                        b.flip();\n+                        b.position(inOfs);\n+                        ByteBuffer out = ByteBuffer.allocateDirect(olen);\n+                        out.limit(out.capacity());\n+                        out.position(outOfs);\n+                        rlen = cipher.doFinal(b, out);\n+                        byte[] o = new byte[rlen];\n+                        out.flip();\n+                        out.position(outOfs);\n+                        out.get(o, 0, rlen);\n+                        ba.write(o);\n+                    }\n+                    default -> throw new Exception(\"Unknown op: \" + v.name());\n+                }\n+\n+                if (theoreticalCheck && rlen != olen - outOfs) {\n+                    throw new Exception(\"Wrong doFinal return len (\" +\n+                        v.name() + \"):  \" + \"rlen=\" + rlen +\n+                        \", expected output len=\" + (olen - outOfs));\n+                }\n+\n+                \/\/ Verify results\n+                byte[] ctresult = ba.toByteArray();\n+                if (ctresult.length != expectedOut.length ||\n+                    Arrays.compare(ctresult, expectedOut) != 0) {\n+                    String s = \"Ciphertext mismatch (\" + v.name() +\n+                        \"):\\nresult   (len=\" + ctresult.length + \"): \" +\n+                        hex.formatHex(ctresult) +\n+                        \"\\nexpected (len=\" + output.length + \"): \" +\n+                        hex.formatHex(output);\n+                    System.err.println(s);\n+                    throw new Exception(s);\n+\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Perform cipher operation using in-place buffers.  This method does not\n+     * allow mixing of data types (byte, heap, direct).\n+     *\n+     * Mixing data types makes no sense for in-place operations and would\n+     * greatly complicate the test code.\n+     *\/\n+    void cryptoSameBuffer(boolean encrypt, Data d, byte[] input, byte[] output) throws Exception {\n+\n+        byte[] data, out;\n+        if (encrypt) {\n+            data = new byte[output.length + Math.max(inOfs, outOfs)];\n+        } else {\n+            data = new byte[input.length + Math.max(inOfs, outOfs)];\n+        }\n+\n+        ByteBuffer bbin = null, bbout = null;\n+        System.arraycopy(input, 0, data, inOfs, input.length);\n+        byte[] expectedOut = new byte[output.length + outOfs];\n+        System.arraycopy(output, 0, expectedOut, outOfs, output.length);\n+        int plen = input.length \/ ops.size(); \/\/ partial input length\n+        int theorticallen = plen -\n+            (d.blockSize > 0 ? plen % d.blockSize : 0);  \/\/ output length\n+        int dataoffset = 0;\n+        int index = 0;\n+        int rlen = 0; \/\/ result length\n+        int len = 0;\n+\n+        Cipher cipher = Cipher.getInstance(algo);\n+        cipher.init((encrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE),\n+            d.key, getAPS(algo, d.tag.length, d.iv));\n+        cipher.updateAAD(d.aad);\n+\n+        \/\/ Prepare data\n+        switch (ops.get(0)) {\n+            case HEAP -> {\n+                bbin = ByteBuffer.wrap(data);\n+                bbin.limit(input.length + inOfs);\n+                bbout = bbin.duplicate();\n+            }\n+            case DIRECT -> {\n+                bbin = ByteBuffer.allocateDirect(data.length);\n+                bbout = bbin.duplicate();\n+                bbin.put(data, 0, input.length + inOfs);\n+                bbin.flip();\n+            }\n+        }\n+\n+        \/\/ Set data limits for bytebuffers\n+        if (bbin != null) {\n+            bbin.position(inOfs);\n+            bbout.limit(output.length + outOfs);\n+            bbout.position(outOfs);\n+        }\n+\n+        \/\/ Iterate through each operation\n+        for (dtype v : ops) {\n+            if (index < ops.size() - 1) {\n+                switch (v) {\n+                    case BYTE -> {\n+                        rlen = cipher.update(data, dataoffset + inOfs, plen,\n+                            data, len + outOfs);\n+                    }\n+                    case HEAP, DIRECT -> {\n+                        theorticallen = bbin.remaining() - (d.blockSize > 0 ?\n+                            bbin.remaining() % d.blockSize : 0);\n+                        rlen = cipher.update(bbin, bbout);\n+                    }\n+                    default -> throw new Exception(\"Unknown op: \" + v.name());\n+                }\n+\n+                \/\/ Check that the theoretical return value matches the actual.\n+                if (theoreticalCheck && encrypt && rlen != theorticallen) {\n+                    throw new Exception(\"Wrong update return len (\" +\n+                        v.name() + \"):  \" + \"rlen=\" + rlen +\n+                        \", expected output len=\" + theorticallen);\n+                }\n+\n+                dataoffset += plen;\n+                len += rlen;\n+                index++;\n+\n+            } else {\n+                \/\/ Run doFinal op\n+                plen = input.length - dataoffset;\n+\n+                switch (v) {\n+                    case BYTE -> {\n+                        rlen = cipher.doFinal(data, dataoffset + inOfs,\n+                            plen, data, len + outOfs);\n+                        out = Arrays.copyOfRange(data, 0,len + rlen + outOfs);\n+                    }\n+                    case HEAP, DIRECT -> {\n+                        rlen = cipher.doFinal(bbin, bbout);\n+                        bbout.flip();\n+                        out = new byte[bbout.remaining()];\n+                        bbout.get(out);\n+                    }\n+                    default -> throw new Exception(\"Unknown op: \" + v.name());\n+                }\n+                len += rlen;\n+\n+                \/\/ Verify results\n+                if (len != output.length ||\n+                    Arrays.compare(out, 0, len, expectedOut, 0,\n+                        output.length) != 0) {\n+                    String s = \"Ciphertext mismatch (\" + v.name() +\n+                        \"):\\nresult (len=\" + len + \"):\\n\" +\n+                        hex.formatHex(out) +\n+                        \"\\nexpected (len=\" + output.length + \"):\\n\" +\n+                        hex.formatHex(output);\n+                    System.err.println(s);\n+                    throw new Exception(s);\n+                }\n+            }\n+        }\n+    }\n+    static void offsetTests(AEADBufferTest t) throws Exception {\n+        t.clone().offset(2).test();\n+        t.clone().inOfs(2).test();\n+        \/\/ Test not designed for overlap situations\n+        t.clone().outOfs(2).differentBufferOnly().test();\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        AEADBufferTest t;\n+\n+        initTest();\n+\n+        \/\/ **** GCM Tests\n+\n+        \/\/ Test single byte array\n+        new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE)).test();\n+        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE)));\n+        \/\/ Test update-doFinal with byte arrays\n+        new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE)).test();\n+        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE)));\n+        \/\/ Test update-update-doFinal with byte arrays\n+        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).test();\n+        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)));\n+\n+        \/\/ Test single heap bytebuffer\n+        new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP)).test();\n+        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP)));\n+        \/\/ Test update-doFinal with heap bytebuffer\n+        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.HEAP, dtype.HEAP)).test();\n+        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP, dtype.HEAP)));\n+        \/\/ Test update-update-doFinal with heap bytebuffer\n+        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)).test();\n+        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)));\n+\n+        \/\/ Test single direct bytebuffer\n+        new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.DIRECT)).test();\n+        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.DIRECT)));\n+        \/\/ Test update-doFinal with direct bytebuffer\n+        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT)).test();\n+        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT)));\n+        \/\/ Test update-update-doFinal with direct bytebuffer\n+        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).test();\n+        offsetTests(new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)));\n+\n+        \/\/ Test update-update-doFinal with byte arrays and preset data sizes\n+        t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).dataSegments(\n+            new int[] { 1, 1, AEADBufferTest.REMAINDER});\n+        t.clone().test();\n+        offsetTests(t.clone());\n+\n+        \/\/ Test update-doFinal with a byte array and a direct bytebuffer\n+        t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.DIRECT)).differentBufferOnly();\n+        t.clone().test();\n+        offsetTests(t.clone());\n+        \/\/ Test update-doFinal with a byte array and heap and direct bytebuffer\n+        t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT)).differentBufferOnly();\n+        t.clone().test();\n+        offsetTests(t.clone());\n+\n+        \/\/ Test update-doFinal with a direct bytebuffer and a byte array.\n+        t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly();\n+        t.clone().test();\n+        offsetTests(t.clone());\n+\n+        \/\/ Test update-doFinal with a direct bytebuffer and a byte array with\n+        \/\/ preset data sizes.\n+        t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly().\n+            dataSegments(new int[] { 20, AEADBufferTest.REMAINDER });\n+        t.clone().test();\n+        offsetTests(t.clone());\n+        \/\/ Test update-update-doFinal with a direct and heap bytebuffer and a\n+        \/\/ byte array with preset data sizes.\n+        t = new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.BYTE, dtype.HEAP)).\n+            differentBufferOnly().dataSet(5).\n+            dataSegments(new int[] { 5000, 1000, AEADBufferTest.REMAINDER });\n+        t.clone().test();\n+        offsetTests(t.clone());\n+\n+        \/\/ Test update-update-doFinal with byte arrays, incrementing through\n+        \/\/ every data size combination for the Data set 0\n+        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).incrementalSegments().\n+            dataSet(0).test();\n+        \/\/ Test update-update-doFinal with direct bytebuffers, incrementing through\n+        \/\/ every data size combination for the Data set 0\n+        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n+            incrementalSegments().dataSet(0).test();\n+\n+        new AEADBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n+            dataSegments(new int[] { 49, 0, 2 }).dataSet(0).test();\n+\n+        \/\/ **** CC20P1305 Tests\n+\n+        \/\/ Test single byte array\n+        new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE)).test();\n+        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE)));\n+        \/\/ Test update-doFinal with byte arrays\n+        new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE, dtype.BYTE)).test();\n+        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE, dtype.BYTE)));\n+        \/\/ Test update-update-doFinal with byte arrays\n+        new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).test();\n+        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)));\n+\n+        \/\/ Test single heap bytebuffer\n+        new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.HEAP)).test();\n+        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.HEAP)));\n+        \/\/ Test update-doFinal with heap bytebuffer\n+        new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.HEAP, dtype.HEAP)).test();\n+        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.HEAP, dtype.HEAP)));\n+        \/\/ Test update-update-doFinal with heap bytebuffer\n+        new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)).test();\n+        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)));\n+\n+        \/\/ Test single direct bytebuffer\n+        new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.DIRECT)).test();\n+        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\", List.of(dtype.DIRECT)));\n+        \/\/ Test update-doFinal with direct bytebuffer\n+        new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.DIRECT, dtype.DIRECT)).test();\n+        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.DIRECT, dtype.DIRECT)));\n+        \/\/ Test update-update-doFinal with direct bytebuffer\n+        new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).test();\n+        offsetTests(new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)));\n+\n+        \/\/ Test update-update-doFinal with byte arrays and preset data sizes\n+        t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).dataSegments(\n+            new int[] { 1, 1, AEADBufferTest.REMAINDER});\n+        t.clone().test();\n+        offsetTests(t.clone());\n+\n+        \/\/ Test update-doFinal with a byte array and a direct bytebuffer\n+        t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.BYTE, dtype.DIRECT)).differentBufferOnly();\n+        t.clone().test();\n+        offsetTests(t.clone());\n+        \/\/ Test update-doFinal with a byte array and heap and direct bytebuffer\n+        t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT)).differentBufferOnly();\n+        t.clone().test();\n+        offsetTests(t.clone());\n+\n+        \/\/ Test update-doFinal with a direct bytebuffer and a byte array.\n+        t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly();\n+        t.clone().test();\n+        offsetTests(t.clone());\n+\n+        \/\/ Test update-doFinal with a direct bytebuffer and a byte array with\n+        \/\/ preset data sizes.\n+        t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly().\n+            dataSegments(new int[] { 20, AEADBufferTest.REMAINDER });\n+        t.clone().test();\n+        offsetTests(t.clone());\n+        \/\/ Test update-update-doFinal with a direct and heap bytebuffer and a\n+        \/\/ byte array with preset data sizes.\n+        t = new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.DIRECT, dtype.BYTE, dtype.HEAP)).\n+            differentBufferOnly().dataSet(1).\n+            dataSegments(new int[] { 5000, 1000, AEADBufferTest.REMAINDER });\n+        t.clone().test();\n+        offsetTests(t.clone());\n+\n+        \/\/ Test update-update-doFinal with byte arrays, incrementing through\n+        \/\/ every data size combination for the Data set 0\n+        new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).incrementalSegments().\n+            dataSet(0).test();\n+        \/\/ Test update-update-doFinal with direct bytebuffers, incrementing through\n+        \/\/ every data size combination for the Data set 0\n+        new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n+            incrementalSegments().dataSet(0).test();\n+\n+        new AEADBufferTest(\"ChaCha20-Poly1305\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n+            dataSegments(new int[] { 49, 0, 2 }).dataSet(0).test();\n+    }\n+\n+    \/\/ Test data\n+    static void initTest() {\n+\n+        datamap.put(\"AES\/GCM\/NoPadding\", List.of(\n+            \/\/ GCM KAT\n+            new Data(AES, 0,\n+            \"141f1ce91989b07e7eb6ae1dbd81ea5e\",\n+                \"49451da24bd6074509d3cebc2c0394c972e6934b45a1d91f3ce1d3ca69e19\" +\n+                \"4aa1958a7c21b6f21d530ce6d2cc5256a3f846b6f9d2f38df0102c4791e5\" +\n+                \"7df038f6e69085646007df999751e248e06c47245f4cd3b8004585a7470d\" +\n+                \"ee1690e9d2d63169a58d243c0b57b3e5b4a481a3e4e8c60007094ef3adea\" +\n+                \"2e8f05dd3a1396f\",\n+            \"d384305af2388699aa302f510913fed0f2cb63ba42efa8c5c9de2922a2ec\" +\n+                \"2fe87719dadf1eb0aef212b51e74c9c5b934104a43\",\n+            \"630cf18a91cc5a6481ac9eefd65c24b1a3c93396bd7294d6b8ba3239517\" +\n+                \"27666c947a21894a079ef061ee159c05beeb4\",\n+            \"f4c34e5fbe74c0297313268296cd561d59ccc95bbfcdfcdc71b0097dbd83\" +\n+                \"240446b28dc088abd42b0fc687f208190ff24c0548\",\n+            \"dbb93bbb56d0439cd09f620a57687f5d\"),\n+            \/\/ GCM KAT\n+            new Data(AES, 1, \"11754cd72aec309bf52f7687212e8957\",\n+                \"3c819d9a9bed087615030b65\",\n+                new byte[0], null, null,\n+                \"250327c674aaf477aef2675748cf6971\"),\n+            \/\/ Randomly generated data at the time of execution.\n+            new Data(AES, 5, \"11754cd72aec309bf52f7687212e8957\",\n+                16, 12345)));\n+\n+        datamap.put(\"ChaCha20-Poly1305\", List.of(\n+            new Data(\"CC20\", 0,\n+                \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\",\n+                \"070000004041424344454647\",\n+                1,\n+                \"4c616469657320616e642047656e746c656d656e206f662074686520636c6173\" +\n+                \"73206f66202739393a204966204920636f756c64206f6666657220796f75206f\" +\n+                \"6e6c79206f6e652074697020666f7220746865206675747572652c2073756e73\" +\n+                \"637265656e20776f756c642062652069742e\",\n+                \"50515253c0c1c2c3c4c5c6c7\",\n+                \"d31a8d34648e60db7b86afbc53ef7ec2a4aded51296e08fea9e2b5a736ee62d6\" +\n+                \"3dbea45e8ca9671282fafb69da92728b1a71de0a9e060b2905d6a5b67ecd3b36\" +\n+                \"92ddbd7f2d778b8c9803aee328091b58fab324e4fad675945585808b4831d7bc\" +\n+                \"3ff4def08e4b7a9de576d26586cec64b61161ae10b59\",\n+                \"4f09e26a7e902ecbd0600691\"),\n+                \/\/ Randomly generated data at the time of execution.\n+            new Data(\"CC20\", 1,\n+                \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\",\n+                12, 12345)));\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/AEADBufferTest.java","additions":900,"deletions":0,"binary":false,"changes":900,"status":"added"},{"patch":"@@ -1,843 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Use Cipher update and doFinal with a mixture of byte[], bytebuffer,\n- * and offset while verifying return values.  Also using different and\n- * in-place buffers.\n- *\n- * in-place is not tested with different buffer types as it is not a logical\n- * scenario and is complicated by getOutputSize calculations.\n- *\/\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.SecretKey;\n-import javax.crypto.spec.GCMParameterSpec;\n-import javax.crypto.spec.SecretKeySpec;\n-import java.io.ByteArrayOutputStream;\n-import java.nio.ByteBuffer;\n-import java.security.SecureRandom;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HexFormat;\n-import java.util.List;\n-\n-public class GCMBufferTest implements Cloneable {\n-\n-    \/\/ Data type for the operation\n-    enum dtype { BYTE, HEAP, DIRECT };\n-    \/\/ Data map\n-    static HashMap<String, List<Data>> datamap = new HashMap<>();\n-    \/\/ List of enum values for order of operation\n-    List<dtype> ops;\n-\n-    static final int AESBLOCK = 16;\n-    \/\/ The remaining input data length is inserted at the particular index\n-    \/\/ in sizes[] during execution.\n-    static final int REMAINDER = -1;\n-\n-    String algo;\n-    boolean same = true;\n-    int[] sizes;\n-    boolean incremental = false;\n-    \/\/ In some cases the theoretical check is too complicated to verify\n-    boolean theoreticalCheck;\n-    List<Data> dataSet;\n-    int inOfs = 0, outOfs = 0;\n-    static HexFormat hex = HexFormat.of();\n-\n-    static class Data {\n-        int id;\n-        SecretKey key;\n-        byte[] iv;\n-        byte[] pt;\n-        byte[] aad;\n-        byte[] ct;\n-        byte[] tag;\n-\n-        Data(String keyalgo, int id, String key, String iv, byte[] pt, String aad,\n-            String ct, String tag) {\n-            this.id = id;\n-            this.key = new SecretKeySpec(HexToBytes(key), keyalgo);\n-            this.iv = HexToBytes(iv);\n-            this.pt = pt;\n-            this.aad = HexToBytes(aad);\n-            this.ct = HexToBytes(ct);\n-            this.tag = HexToBytes(tag);\n-        }\n-\n-        Data(String keyalgo, int id, String key, String iv, String pt, String aad,\n-            String ct, String tag) {\n-            this(keyalgo, id, key, iv, HexToBytes(pt), aad, ct, tag);\n-        }\n-\n-        Data(String keyalgo, int id, String key, int ptlen) {\n-            this.id = id;\n-            this.key = new SecretKeySpec(HexToBytes(key), keyalgo);\n-            iv = new byte[16];\n-            pt = new byte[ptlen];\n-            tag = new byte[12];\n-            aad = new byte[0];\n-            byte[] tct = null;\n-            try {\n-                SecureRandom r = new SecureRandom();\n-                r.nextBytes(iv);\n-                r.nextBytes(pt);\n-                Cipher c = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n-                c.init(Cipher.ENCRYPT_MODE, this.key,\n-                    new GCMParameterSpec(tag.length * 8, this.iv));\n-                tct = c.doFinal(pt);\n-            } catch (Exception e) {\n-                throw new RuntimeException(\"Error in generating data for length \" +\n-                    ptlen, e);\n-            }\n-            ct = new byte[ptlen];\n-            System.arraycopy(tct, 0, ct, 0, ct.length);\n-            System.arraycopy(tct, ct.length, tag, 0, tag.length);\n-        }\n-\n-        private static final byte[] HexToBytes(String hexVal) {\n-            if (hexVal == null) {\n-                return new byte[0];\n-            }\n-            return hex.parseHex(hexVal);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Construct a test with an algorithm and a list of dtype.\n-     * @param algo Algorithm string\n-     * @param ops List of dtypes.  If only one dtype is specified, only a\n-     *            doFinal operation will occur.  If multiple dtypes are\n-     *            specified, the last is a doFinal, the others are updates.\n-     *\/\n-    GCMBufferTest(String algo, List<dtype> ops) {\n-        this.algo = algo;\n-        this.ops = ops;\n-        theoreticalCheck = true;\n-        dataSet = datamap.get(algo);\n-    }\n-\n-    public GCMBufferTest clone() throws CloneNotSupportedException{\n-        return (GCMBufferTest)super.clone();\n-    }\n-\n-    \/**\n-     * Define particular data sizes to be tested.  \"REMAINDER\", which has a\n-     * value of -1, can be used to insert the remaining input text length at\n-     * that index during execution.\n-     * @param sizes Data sizes for each dtype in the list.\n-     *\/\n-    GCMBufferTest dataSegments(int[] sizes) {\n-        this.sizes = sizes;\n-        return this;\n-    }\n-\n-    \/**\n-     * Do not perform in-place operations\n-     *\/\n-    GCMBufferTest differentBufferOnly() {\n-        this.same = false;\n-        return this;\n-    }\n-\n-    \/**\n-     * Enable incrementing through each data size available.  This can only be\n-     * used when the List has more than one dtype entry.\n-     *\/\n-    GCMBufferTest incrementalSegments() {\n-        this.incremental = true;\n-        return this;\n-    }\n-\n-    \/**\n-     * Specify a particular test dataset.\n-     *\n-     * @param id id value for the test data to used in this test.\n-     *\/\n-    GCMBufferTest dataSet(int id) throws Exception {\n-        for (Data d : datamap.get(algo)) {\n-            if (d.id == id) {\n-                dataSet = List.of(d);\n-                return this;\n-            }\n-        }\n-        throw new Exception(\"Unable to find dataSet id = \" + id);\n-    }\n-\n-    \/**\n-     * Set both input and output offsets to the same offset\n-     * @param offset value for inOfs and outOfs\n-     * @return\n-     *\/\n-    GCMBufferTest offset(int offset) {\n-        this.inOfs = offset;\n-        this.outOfs = offset;\n-        return this;\n-    }\n-\n-    \/**\n-     * Set the input offset\n-     * @param offset value for input offset\n-     * @return\n-     *\/\n-    GCMBufferTest inOfs(int offset) {\n-        this.inOfs = offset;\n-        return this;\n-    }\n-\n-    \/**\n-     * Set the output offset\n-     * @param offset value for output offset\n-     * @return\n-     *\/\n-    GCMBufferTest outOfs(int offset) {\n-        this.outOfs = offset;\n-        return this;\n-    }\n-\n-    \/**\n-     * Reverse recursive loop that starts at the end-1 index, going to 0, in\n-     * the size array to calculate all the possible sizes.\n-     * It returns the remaining data size not used in the loop.  This remainder\n-     * is used for the end index which is the doFinal op.\n-     *\/\n-    int inc(int index, int max, int total) {\n-        if (sizes[index] == max - total) {\n-            sizes[index + 1]++;\n-            total++;\n-            sizes[index] = 0;\n-        } else if (index == 0) {\n-            sizes[index]++;\n-        }\n-\n-        total += sizes[index];\n-        if (index > 0) {\n-            return inc(index - 1, max, total);\n-        }\n-        return total;\n-    }\n-\n-    \/\/ Call recursive loop and take returned remainder value for last index\n-    boolean incrementSizes(int max) {\n-        sizes[ops.size() - 1] = max - inc(ops.size() - 2, max, 0);\n-        if (sizes[ops.size() - 2] == max) {\n-            \/\/ We are at the end, exit test loop\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    void test() throws Exception {\n-        int i = 1;\n-        System.err.println(\"Algo: \" + algo + \" \\tOps: \" + ops.toString());\n-        for (Data data : dataSet) {\n-\n-            \/\/ If incrementalSegments is enabled, run through that test only\n-            if (incremental) {\n-                if (ops.size() < 2) {\n-                    throw new Exception(\"To do incrementalSegments you must \" +\n-                        \"have more that 1 dtype in the list\");\n-                }\n-                sizes = new int[ops.size()];\n-\n-                while (incrementSizes(data.pt.length)) {\n-                    System.err.print(\"Encrypt:  Data Index: \" + i + \" \\tSizes[ \");\n-                    for (int v : sizes) {\n-                        System.err.print(v + \" \");\n-                    }\n-                    System.err.println(\"]\");\n-                    encrypt(data);\n-                }\n-                Arrays.fill(sizes, 0);\n-\n-                while (incrementSizes(data.ct.length + data.tag.length)) {\n-                    System.err.print(\"Decrypt:  Data Index: \" + i + \" \\tSizes[ \");\n-                    for (int v : sizes) {\n-                        System.err.print(v + \" \");\n-                    }\n-                    System.err.println(\"]\");\n-                    decrypt(data);\n-                }\n-\n-            } else {\n-                \/\/ Default test of 0 and 2 offset doing in place and different\n-                \/\/ i\/o buffers\n-                System.err.println(\"Encrypt:  Data Index: \" + i);\n-                encrypt(data);\n-\n-                System.err.println(\"Decrypt:  Data Index: \" + i);\n-                decrypt(data);\n-            }\n-            i++;\n-        }\n-    }\n-\n-    \/\/ Setup data for encryption\n-    void encrypt(Data data) throws Exception {\n-        byte[] input, output;\n-\n-        input = data.pt;\n-        output = new byte[data.ct.length + data.tag.length];\n-        System.arraycopy(data.ct, 0, output, 0, data.ct.length);\n-        System.arraycopy(data.tag, 0, output, data.ct.length,\n-            data.tag.length);\n-\n-        \/\/ Test different input\/output buffers\n-        System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n-            inOfs + \"  outOfs \" + outOfs + \"  in\/out buffer: different\");\n-        crypto(true, data, input, output);\n-\n-        \/\/ Test with in-place buffers\n-        if (same) {\n-            System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n-            inOfs + \"  outOfs \" + outOfs + \"  in\/out buffer: in-place\");\n-            cryptoSameBuffer(true, data, input, output);\n-        }\n-    }\n-\n-    \/\/ Setup data for decryption\n-    void decrypt(Data data) throws Exception {\n-        byte[] input, output;\n-\n-        input = new byte[data.ct.length + data.tag.length];\n-        System.arraycopy(data.ct, 0, input, 0, data.ct.length);\n-        System.arraycopy(data.tag, 0, input, data.ct.length, data.tag.length);\n-        output = data.pt;\n-\n-        \/\/ Test different input\/output buffers\n-        System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n-            inOfs + \"  outOfs \" + outOfs + \"  in\/out buffer: different\");\n-        crypto(false, data, input, output);\n-\n-        \/\/ Test with in-place buffers\n-        if (same) {\n-            System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n-            inOfs + \"  outOfs \" + outOfs + \"  in-place: same\");\n-            cryptoSameBuffer(false, data, input, output);\n-        }\n-    }\n-\n-    \/**\n-     * Perform cipher operation using different input and output buffers.\n-     *   This method allows mixing of data types (byte, heap, direct).\n-     *\/\n-     void crypto(boolean encrypt, Data d, byte[] input, byte[] output)\n-         throws Exception {\n-        byte[] pt = new byte[input.length + inOfs];\n-        System.arraycopy(input, 0, pt, inOfs, input.length);\n-         byte[] expectedOut = new byte[output.length + outOfs];\n-         System.arraycopy(output, 0, expectedOut, outOfs, output.length);\n-        int plen = input.length \/ ops.size(); \/\/ partial input length\n-        int theoreticallen;\/\/ expected output length\n-        int dataoffset = 0; \/\/ offset of unconsumed data in pt\n-        int index = 0; \/\/ index of which op we are on\n-        int rlen; \/\/ result length\n-        int pbuflen = 0; \/\/ plen remaining in the GCM internal buffers\n-\n-        Cipher cipher = Cipher.getInstance(algo);\n-        cipher.init((encrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE),\n-            d.key, new GCMParameterSpec(d.tag.length * 8, d.iv));\n-        cipher.updateAAD(d.aad);\n-\n-        ByteArrayOutputStream ba = new ByteArrayOutputStream();\n-        ba.write(new byte[outOfs], 0, outOfs);\n-        for (dtype v : ops) {\n-            if (index < ops.size() - 1) {\n-                if (sizes != null && input.length > 0) {\n-                    if (sizes[index] == -1) {\n-                        plen = input.length - dataoffset;\n-                    } else {\n-                        if (sizes[index] > input.length) {\n-                            plen = input.length;\n-                        } else {\n-                            plen = sizes[index];\n-                        }\n-                    }\n-                }\n-\n-                int olen = cipher.getOutputSize(plen) + outOfs;\n-\n-                \/*\n-                 * The theoretical limit is the length of the data sent to\n-                 * update() + any data might be setting in CipherCore or GCM\n-                 * internal buffers % the block size.\n-                 *\/\n-                theoreticallen = (plen + pbuflen) - ((plen + pbuflen) % AESBLOCK);\n-\n-                \/\/ Update operations\n-                switch (v) {\n-                    case BYTE -> {\n-                        byte[] out = new byte[olen];\n-                        rlen = cipher.update(pt, dataoffset + inOfs, plen, out,\n-                            outOfs);\n-                        ba.write(out, outOfs, rlen);\n-                    }\n-                    case HEAP -> {\n-                        ByteBuffer b = ByteBuffer.allocate(plen + outOfs);\n-                        b.position(outOfs);\n-                        b.put(pt, dataoffset + inOfs, plen);\n-                        b.flip();\n-                        b.position(outOfs);\n-                        ByteBuffer out = ByteBuffer.allocate(olen);\n-                        out.position(outOfs);\n-                        rlen = cipher.update(b, out);\n-                        ba.write(out.array(), outOfs, rlen);\n-                    }\n-                    case DIRECT -> {\n-                        ByteBuffer b = ByteBuffer.allocateDirect(plen + outOfs);\n-                        b.position(outOfs);\n-                        b.put(pt, dataoffset + inOfs, plen);\n-                        b.flip();\n-                        b.position(outOfs);\n-                        ByteBuffer out = ByteBuffer.allocateDirect(olen);\n-                        out.position(outOfs);\n-                        rlen = cipher.update(b, out);\n-                        byte[] o = new byte[rlen];\n-                        out.flip();\n-                        out.position(outOfs);\n-                        out.get(o, 0, rlen);\n-                        ba.write(o);\n-                    }\n-                    default -> throw new Exception(\"Unknown op: \" + v.name());\n-                }\n-\n-                if (theoreticalCheck) {\n-                    pbuflen += plen - rlen;\n-                    if (encrypt && rlen != theoreticallen) {\n-                        throw new Exception(\"Wrong update return len (\" +\n-                            v.name() + \"):  \" + \"rlen=\" + rlen +\n-                            \", expected output len=\" + theoreticallen);\n-                    }\n-                }\n-\n-                dataoffset += plen;\n-                index++;\n-\n-            } else {\n-                \/\/ doFinal operation\n-                plen = input.length - dataoffset;\n-\n-                int olen = cipher.getOutputSize(plen) + outOfs;\n-                switch (v) {\n-                    case BYTE -> {\n-                        byte[] out = new byte[olen];\n-                        rlen = cipher.doFinal(pt, dataoffset + inOfs,\n-                            plen, out, outOfs);\n-                        ba.write(out, outOfs, rlen);\n-                    }\n-                    case HEAP -> {\n-                        ByteBuffer b = ByteBuffer.allocate(plen + inOfs);\n-                        b.limit(b.capacity());\n-                        b.position(inOfs);\n-                        b.put(pt, dataoffset + inOfs, plen);\n-                        b.flip();\n-                        b.position(inOfs);\n-                        ByteBuffer out = ByteBuffer.allocate(olen);\n-                        out.limit(out.capacity());\n-                        out.position(outOfs);\n-                        rlen = cipher.doFinal(b, out);\n-                        ba.write(out.array(), outOfs, rlen);\n-                    }\n-                    case DIRECT -> {\n-                        ByteBuffer b = ByteBuffer.allocateDirect(plen + inOfs);\n-                        b.limit(b.capacity());\n-                        b.position(inOfs);\n-                        b.put(pt, dataoffset + inOfs, plen);\n-                        b.flip();\n-                        b.position(inOfs);\n-                        ByteBuffer out = ByteBuffer.allocateDirect(olen);\n-                        out.limit(out.capacity());\n-                        out.position(outOfs);\n-                        rlen = cipher.doFinal(b, out);\n-                        byte[] o = new byte[rlen];\n-                        out.flip();\n-                        out.position(outOfs);\n-                        out.get(o, 0, rlen);\n-                        ba.write(o);\n-                    }\n-                    default -> throw new Exception(\"Unknown op: \" + v.name());\n-                }\n-\n-                if (theoreticalCheck && rlen != olen - outOfs) {\n-                    throw new Exception(\"Wrong doFinal return len (\" +\n-                        v.name() + \"):  \" + \"rlen=\" + rlen +\n-                        \", expected output len=\" + (olen - outOfs));\n-                }\n-\n-                \/\/ Verify results\n-                byte[] ctresult = ba.toByteArray();\n-                if (ctresult.length != expectedOut.length ||\n-                    Arrays.compare(ctresult, expectedOut) != 0) {\n-                    String s = \"Ciphertext mismatch (\" + v.name() +\n-                        \"):\\nresult   (len=\" + ctresult.length + \"): \" +\n-                        hex.formatHex(ctresult) +\n-                        \"\\nexpected (len=\" + output.length + \"): \" +\n-                        hex.formatHex(output);\n-                    System.err.println(s);\n-                    throw new Exception(s);\n-\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Perform cipher operation using in-place buffers.  This method does not\n-     * allow mixing of data types (byte, heap, direct).\n-     *\n-     * Mixing data types makes no sense for in-place operations and would\n-     * greatly complicate the test code.\n-     *\/\n-    void cryptoSameBuffer(boolean encrypt, Data d, byte[] input, byte[] output) throws Exception {\n-\n-        byte[] data, out;\n-        if (encrypt) {\n-            data = new byte[output.length + Math.max(inOfs, outOfs)];\n-        } else {\n-            data = new byte[input.length + Math.max(inOfs, outOfs)];\n-        }\n-\n-        ByteBuffer bbin = null, bbout = null;\n-        System.arraycopy(input, 0, data, inOfs, input.length);\n-        byte[] expectedOut = new byte[output.length + outOfs];\n-        System.arraycopy(output, 0, expectedOut, outOfs, output.length);\n-        int plen = input.length \/ ops.size(); \/\/ partial input length\n-        int theorticallen = plen - (plen % AESBLOCK); \/\/ output length\n-        int dataoffset = 0;\n-        int index = 0;\n-        int rlen = 0; \/\/ result length\n-        int len = 0;\n-\n-        Cipher cipher = Cipher.getInstance(algo);\n-        cipher.init((encrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE),\n-            d.key, new GCMParameterSpec(d.tag.length * 8, d.iv));\n-        cipher.updateAAD(d.aad);\n-\n-        \/\/ Prepare data\n-        switch (ops.get(0)) {\n-            case HEAP -> {\n-                bbin = ByteBuffer.wrap(data);\n-                bbin.limit(input.length + inOfs);\n-                bbout = bbin.duplicate();\n-            }\n-            case DIRECT -> {\n-                bbin = ByteBuffer.allocateDirect(data.length);\n-                bbout = bbin.duplicate();\n-                bbin.put(data, 0, input.length + inOfs);\n-                bbin.flip();\n-            }\n-        }\n-\n-        \/\/ Set data limits for bytebuffers\n-        if (bbin != null) {\n-            bbin.position(inOfs);\n-            bbout.limit(output.length + outOfs);\n-            bbout.position(outOfs);\n-        }\n-\n-        \/\/ Iterate through each operation\n-        for (dtype v : ops) {\n-            if (index < ops.size() - 1) {\n-                switch (v) {\n-                    case BYTE -> {\n-                        rlen = cipher.update(data, dataoffset + inOfs, plen,\n-                            data, len + outOfs);\n-                    }\n-                    case HEAP, DIRECT -> {\n-                        theorticallen = bbin.remaining() -\n-                            (bbin.remaining() % AESBLOCK);\n-                        rlen = cipher.update(bbin, bbout);\n-                    }\n-                    default -> throw new Exception(\"Unknown op: \" + v.name());\n-                }\n-\n-                \/\/ Check that the theoretical return value matches the actual.\n-                if (theoreticalCheck && encrypt && rlen != theorticallen) {\n-                    throw new Exception(\"Wrong update return len (\" +\n-                        v.name() + \"):  \" + \"rlen=\" + rlen +\n-                        \", expected output len=\" + theorticallen);\n-                }\n-\n-                dataoffset += plen;\n-                len += rlen;\n-                index++;\n-\n-            } else {\n-                \/\/ Run doFinal op\n-                plen = input.length - dataoffset;\n-\n-                switch (v) {\n-                    case BYTE -> {\n-                        rlen = cipher.doFinal(data, dataoffset + inOfs,\n-                            plen, data, len + outOfs);\n-                        out = Arrays.copyOfRange(data, 0,len + rlen + outOfs);\n-                    }\n-                    case HEAP, DIRECT -> {\n-                        rlen = cipher.doFinal(bbin, bbout);\n-                        bbout.flip();\n-                        out = new byte[bbout.remaining()];\n-                        bbout.get(out);\n-                    }\n-                    default -> throw new Exception(\"Unknown op: \" + v.name());\n-                }\n-                len += rlen;\n-\n-                \/\/ Verify results\n-                if (len != output.length ||\n-                    Arrays.compare(out, 0, len, expectedOut, 0,\n-                        output.length) != 0) {\n-                    String s = \"Ciphertext mismatch (\" + v.name() +\n-                        \"):\\nresult (len=\" + len + \"):\\n\" +\n-                        hex.formatHex(out) +\n-                        \"\\nexpected (len=\" + output.length + \"):\\n\" +\n-                        hex.formatHex(output);\n-                    System.err.println(s);\n-                    throw new Exception(s);\n-                }\n-            }\n-        }\n-    }\n-    static void offsetTests(GCMBufferTest t) throws Exception {\n-        t.clone().offset(2).test();\n-        t.clone().inOfs(2).test();\n-        \/\/ Test not designed for overlap situations\n-        t.clone().outOfs(2).differentBufferOnly().test();\n-    }\n-\n-    public static void main(String args[]) throws Exception {\n-        GCMBufferTest t;\n-\n-        initTest();\n-\n-        \/\/ Test single byte array\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE)).test();\n-        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE)));\n-        \/\/ Test update-doFinal with byte arrays\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE)).test();\n-        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE)));\n-        \/\/ Test update-update-doFinal with byte arrays\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).test();\n-        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)));\n-\n-        \/\/ Test single heap bytebuffer\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP)).test();\n-        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP)));\n-        \/\/ Test update-doFinal with heap bytebuffer\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.HEAP, dtype.HEAP)).test();\n-        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP, dtype.HEAP)));\n-        \/\/ Test update-update-doFinal with heap bytebuffer\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)).test();\n-        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)));\n-\n-        \/\/ Test single direct bytebuffer\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.DIRECT)).test();\n-        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.DIRECT)));\n-        \/\/ Test update-doFinal with direct bytebuffer\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.DIRECT)).test();\n-        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.DIRECT)));\n-        \/\/ Test update-update-doFinal with direct bytebuffer\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).test();\n-        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)));\n-\n-        \/\/ Test update-update-doFinal with byte arrays and preset data sizes\n-        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).dataSegments(\n-            new int[] { 1, 1, GCMBufferTest.REMAINDER});\n-        t.clone().test();\n-        offsetTests(t.clone());\n-\n-        \/\/ Test update-doFinal with a byte array and a direct bytebuffer\n-        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.BYTE, dtype.DIRECT)).differentBufferOnly();\n-        t.clone().test();\n-        offsetTests(t.clone());\n-        \/\/ Test update-doFinal with a byte array and heap and direct bytebuffer\n-        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT)).differentBufferOnly();\n-        t.clone().test();\n-        offsetTests(t.clone());\n-\n-        \/\/ Test update-doFinal with a direct bytebuffer and a byte array.\n-        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly();\n-        t.clone().test();\n-        offsetTests(t.clone());\n-\n-        \/\/ Test update-doFinal with a direct bytebuffer and a byte array with\n-        \/\/ preset data sizes.\n-        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly().\n-            dataSegments(new int[] { 20, GCMBufferTest.REMAINDER });\n-        t.clone().test();\n-        offsetTests(t.clone());\n-        \/\/ Test update-update-doFinal with a direct and heap bytebuffer and a\n-        \/\/ byte array with preset data sizes.\n-        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.BYTE, dtype.HEAP)).\n-            differentBufferOnly().dataSet(5).\n-            dataSegments(new int[] { 5000, 1000, GCMBufferTest.REMAINDER });\n-        t.clone().test();\n-        offsetTests(t.clone());\n-\n-        \/\/ Test update-update-doFinal with byte arrays, incrementing through\n-        \/\/ every data size combination for the Data set 0\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).incrementalSegments().\n-            dataSet(0).test();\n-        \/\/ Test update-update-doFinal with direct bytebuffers, incrementing through\n-        \/\/ every data size combination for the Data set 0\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n-            incrementalSegments().dataSet(0).test();\n-\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n-            dataSegments(new int[] { 49, 0, 2 }).dataSet(0).test();\n-    }\n-\n-    \/\/ Test data\n-    static void initTest() {\n-        datamap.put(\"AES\/GCM\/NoPadding\", List.of(\n-            \/\/ GCM KAT\n-            new Data(\"AES\", 0,\n-            \"141f1ce91989b07e7eb6ae1dbd81ea5e\",\n-                \"49451da24bd6074509d3cebc2c0394c972e6934b45a1d91f3ce1d3ca69e19\" +\n-                \"4aa1958a7c21b6f21d530ce6d2cc5256a3f846b6f9d2f38df0102c4791e5\" +\n-                \"7df038f6e69085646007df999751e248e06c47245f4cd3b8004585a7470d\" +\n-                \"ee1690e9d2d63169a58d243c0b57b3e5b4a481a3e4e8c60007094ef3adea\" +\n-                \"2e8f05dd3a1396f\",\n-            \"d384305af2388699aa302f510913fed0f2cb63ba42efa8c5c9de2922a2ec\" +\n-                \"2fe87719dadf1eb0aef212b51e74c9c5b934104a43\",\n-            \"630cf18a91cc5a6481ac9eefd65c24b1a3c93396bd7294d6b8ba3239517\" +\n-                \"27666c947a21894a079ef061ee159c05beeb4\",\n-            \"f4c34e5fbe74c0297313268296cd561d59ccc95bbfcdfcdc71b0097dbd83\" +\n-                \"240446b28dc088abd42b0fc687f208190ff24c0548\",\n-            \"dbb93bbb56d0439cd09f620a57687f5d\"),\n-            \/\/ GCM KAT\n-            new Data(\"AES\", 1, \"11754cd72aec309bf52f7687212e8957\",\n-                \"3c819d9a9bed087615030b65\",\n-                (String)null, null, null,\n-                \"250327c674aaf477aef2675748cf6971\"),\n-            \/\/ GCM KAT\n-            new Data(\"AES\", 2, \"272f16edb81a7abbea887357a58c1917\",\n-                \"794ec588176c703d3d2a7a07\",\n-                (String)null, null, null,\n-                \"b6e6f197168f5049aeda32dafbdaeb\"),\n-            \/\/ zero'd test data\n-            new Data(\"AES\", 3, \"272f16edb81a7abbea887357a58c1917\",\n-                \"794ec588176c703d3d2a7a07\", new byte[256], null,\n-                \"15b461672153270e8ba1e6789f7641c5411f3e642abda731b6086f535c216457\" +\n-                \"e87305bc59a1ff1f7e1e0bbdf302b75549b136606c67d7e5f71277aeca4bc670\" +\n-                \"07a98f78e0cfa002ed183e62f07893ad31fe67aad1bb37e15b957a14d145f14f\" +\n-                \"7483d041f2c3612ad5033155984470bdfc64d18df73c2745d92f28461bb09832\" +\n-                \"33524811321ba87d213692825815dd13f528dba601a3c319cac6be9b48686c23\" +\n-                \"a0ce23d5062916ea8827bbb243f585e446131489e951354c8ab24661f625c02e\" +\n-                \"15536c5bb602244e98993ff745f3e523399b2059f0e062d8933fad2366e7e147\" +\n-                \"510a931282bb0e3f635efe7bf05b1dd715f95f5858261b00735224256b6b3e80\",\n-                \"08b3593840d4ed005f5234ae062a5c\"),\n-            \/\/ Random test data\n-            new Data(\"AES\", 4, \"272f16edb81a7abbea887357a58c1917\",\n-                \"794ec588176c703d3d2a7a07\",\n-                new byte[2075], null,\n-                \"15b461672153270e8ba1e6789f7641c5411f3e642abda731b6086f535c216457\" +\n-                \"e87305bc59a1ff1f7e1e0bbdf302b75549b136606c67d7e5f71277aeca4bc670\" +\n-                \"07a98f78e0cfa002ed183e62f07893ad31fe67aad1bb37e15b957a14d145f14f\" +\n-                \"7483d041f2c3612ad5033155984470bdfc64d18df73c2745d92f28461bb09832\" +\n-                \"33524811321ba87d213692825815dd13f528dba601a3c319cac6be9b48686c23\" +\n-                \"a0ce23d5062916ea8827bbb243f585e446131489e951354c8ab24661f625c02e\" +\n-                \"15536c5bb602244e98993ff745f3e523399b2059f0e062d8933fad2366e7e147\" +\n-                \"510a931282bb0e3f635efe7bf05b1dd715f95f5858261b00735224256b6b3e80\" +\n-                \"7364cb53ff6d4e88f928cf67ac70da127718a8a35542efbae9dd7567c818a074\" +\n-                \"9a0c74bd69014639f59768bc55056d1166ea5523e8c66f9d78d980beb8f0d83b\" +\n-                \"a9e2c5544b94dc3a1a4b6f0f95f897b010150e89ebcacf0daee3c2793d6501a0\" +\n-                \"b58b411de273dee987e8e8cf8bb29ef2e7f655b46b55fabf64c6a4295e0d080b\" +\n-                \"6a570ace90eb0fe0f5b5d878bdd90eddaa1150e4d5a6505b350aac814fe99615\" +\n-                \"317ecd0516a464c7904011ef5922409c0d65b1e43b69d7c3293a8f7d3e9fbee9\" +\n-                \"eb91ec0007a7d6f72e64deb675d459c5ba07dcfd58d08e6820b100465e6e04f0\" +\n-                \"663e310584a00d36d23699c1bffc6afa094c75184fc7cde7ad35909c0f49f2f3\" +\n-                \"fe1e6d745ab628d74ea56b757047de57ce18b4b3c71e8af31a6fac16189cb0a3\" +\n-                \"a97a1bea447042ce382fcf726560476d759c24d5c735525ea26a332c2094408e\" +\n-                \"671c7deb81d5505bbfd178f866a6f3a011b3cfdbe089b4957a790688028dfdf7\" +\n-                \"9a096b3853f9d0d6d3feef230c7f5f46ffbf7486ebdaca5804dc5bf9d202415e\" +\n-                \"e0d67b365c2f92a17ea740807e4f0b198b42b54f15faa9dff2c7c35d2cf8d72e\" +\n-                \"b8f8b18875a2e7b5c43d1e0aa5139c461e8153c7f632895aa46ffe2b134e6a0d\" +\n-                \"dfbf6a336e709adfe951bd52c4dfc7b07a15fb3888fc35b7e758922f87a104c4\" +\n-                \"563c5c7839cfe5a7edbdb97264a7c4ebc90367b10cbe09dbf2390767ad7afaa8\" +\n-                \"8fb46b39d3f55f216d2104e5cf040bf3d39b758bea28e2dbce576c808d17a8eb\" +\n-                \"e2fd183ef42a774e39119dff1f539efeb6ad15d889dfcb0d54d0d4d4cc03c8d9\" +\n-                \"aa6c9ebd157f5e7170183298d6a30ada8792dcf793d931e2a1eafccbc63c11c0\" +\n-                \"c5c5ed60837f30017d693ccb294df392a8066a0594a56954aea7b78a16e9a11f\" +\n-                \"4a8bc2104070a7319f5fab0d2c4ccad8ec5cd8f47c839179bfd54a7bf225d502\" +\n-                \"cd0a318752fe763e8c09eb88fa57fc5399ad1f797d0595c7b8afdd23f13603e9\" +\n-                \"6802192bb51433b7723f4e512bd4f799feb94b458e7f9792f5f9bd6733828f70\" +\n-                \"a6b7ffbbc0bb7575021f081ec2a0d37fecd7cda2daec9a3a9d9dfe1c8034cead\" +\n-                \"e4b56b581cc82bd5b74b2b30817967d9da33850336f171a4c68e2438e03f4b11\" +\n-                \"96da92f01b3b7aeab795180ccf40a4b090b1175a1fc0b67c95f93105c3aef00e\" +\n-                \"13d76cc402539192274fee703730cd0d1c5635257719cc96cacdbad00c6255e2\" +\n-                \"bd40c775b43ad09599e84f2c3205d75a6661ca3f151183be284b354ce21457d1\" +\n-                \"3ba65b9b2cdb81874bd14469c2008b3ddec78f7225ecc710cc70de7912ca6a6d\" +\n-                \"348168322ab59fdafcf5c833bfa0ad4046f4b6da90e9f263db7079af592eda07\" +\n-                \"5bf16c6b1a8346da9c292a48bf660860a4fc89eaef40bc132779938eca294569\" +\n-                \"787c740af2b5a8de7f5e10ac750d1e3d0ef3ed168ba408a676e10b8a20bd4be8\" +\n-                \"3e8336b45e54481726d73e1bd19f165a98e242aca0d8387f2dd22d02d74e23db\" +\n-                \"4cef9a523587413e0a44d7e3260019a34d3a6b38426ae9fa4655be338d721970\" +\n-                \"cb9fe76c073f26f9303093a033022cd2c62b2790bce633ba9026a1c93b6535f1\" +\n-                \"1882bf5880e511b9e1b0b7d8f23a993aae5fd275faac3a5b4ccaf7c06b0b266a\" +\n-                \"ee970a1e3a4cd7a41094f516960630534e692545b25a347c30e3f328bba4825f\" +\n-                \"ed754e5525d846131ecba7ca120a6aeabc7bab9f59c890c80b7e31f9bc741591\" +\n-                \"55d292433ce9558e104102f2cc63ee267c1c8333e841522707ea6d595cb802b9\" +\n-                \"61697da77bbc4cb404ea62570ab335ebffa2023730732ac5ddba1c3dbb5be408\" +\n-                \"3c50aea462c1ffa166d7cc3db4b742b747e81b452db2363e91374dee8c6b40f0\" +\n-                \"e7fbf50e60eaf5cc5649f6bb553aae772c185026ceb052af088c545330a1ffbf\" +\n-                \"50615b8c7247c6cd386afd7440654f4e15bcfae0c45442ec814fe88433a9d616\" +\n-                \"ee6cc3f163f0d3d325526d05f25d3b37ad5eeb3ca77248ad86c9042b16c65554\" +\n-                \"aebb6ad3e17b981492b13f42c5a5dc088e991da303e5a273fdbb8601aece4267\" +\n-                \"47b01f6cb972e6da1743a0d7866cf206e95f23c6f8e337c901b9cd34a9a1fbbe\" +\n-                \"1694f2c26b00dfa4d02c0d54540163e798fbdc9c25f30d6406f5b4c13f7ed619\" +\n-                \"34e350f4059c13aa5e973307a9e3058917cda96fdd082e9c629ccfb2a9f98d12\" +\n-                \"5c6e4703a7b0f348f5cdeb63cef2133d1c6c1a087591e0a2bca29d09c6565e66\" +\n-                \"e91042f83b0e74e60a5d57562c23e2fbcd6599c29d7c19e47cf625c2ce24bb8a\" +\n-                \"13f8e54041498437eec2cedd1e3d8e57a051baa962c0a62d70264d99c5ee716d\" +\n-                \"5c8b9078db08c8b2c5613f464198a7aff43f76c5b4612b46a4f1cd2a494386c5\" +\n-                \"7fd28f3d199f0ba8d8e39116cc7db16ce6188205ee49a9dce3d4fa32ea394919\" +\n-                \"f6e91ef58b84d00b99596b4306c2d9f432d917bb4ac73384c42ae12adb4920d8\" +\n-                \"c33a816febcb299dcddf3ec7a8eb6e04cdc90891c6e145bd9fc5f41dc4061a46\" +\n-                \"9feba38545b64ec8203f386ceef52785619e991d274ae80af7e54af535e0b011\" +\n-                \"5effdf847472992875e09398457604d04e0bb965db692c0cdcf11a\",\n-                \"687cc09c89298491deb51061d709af\"),\n-            \/\/ Randomly generated data at the time of execution.\n-            new Data(\"AES\", 5, \"11754cd72aec309bf52f7687212e8957\", 12345)\n-            )\n-        );\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMBufferTest.java","additions":0,"deletions":843,"binary":false,"changes":843,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import org.openjdk.jmh.annotations.Benchmark;\n@@ -29,1 +28,1 @@\n-import javax.crypto.Cipher;\n+import java.security.spec.AlgorithmParameterSpec;\n@@ -31,1 +30,0 @@\n-import javax.crypto.spec.SecretKeySpec;\n@@ -34,5 +32,2 @@\n- * This performance tests runs AES\/GCM encryption and decryption using byte[]\n- * as input and output buffers for single and multi-part testing.\n- *\n- * This test rotates the IV and creates a new GCMParameterSpec for each encrypt\n- * benchmark operation\n+ * This performance tests runs AES\/GCM encryption and decryption\n+ * using input and output byte[] buffers with single and multi-part testing.\n@@ -41,1 +36,1 @@\n-public class AESGCMBench extends CryptoBase {\n+public class AESGCMBench extends BenchBase {\n@@ -44,4 +39,1 @@\n-    private int keyLength;\n-\n-    @Param({\"1024\", \"1500\", \"4096\", \"16384\"})\n-    private int dataSize;\n+    int keyLength;\n@@ -49,7 +41,1 @@\n-    byte[] encryptedData;\n-    byte[] in, out;\n-    private Cipher encryptCipher;\n-    private Cipher decryptCipher;\n-    SecretKeySpec ks;\n-    GCMParameterSpec gcm_spec;\n-    byte[] iv;\n+    public static final int IV_MODULO = 16;\n@@ -57,7 +43,1 @@\n-    private static final int IV_BUFFER_SIZE = 32;\n-    private static final int IV_MODULO = IV_BUFFER_SIZE - 16;\n-    int iv_index = 0;\n-    int updateLen = 0;\n-\n-    private int next_iv_index() {\n-        int r = iv_index;\n+    public AlgorithmParameterSpec getNewSpec() {\n@@ -65,1 +45,1 @@\n-        return r;\n+        return new GCMParameterSpec(128, iv, iv_index, IV_MODULO);\n@@ -70,57 +50,1 @@\n-        setupProvider();\n-\n-        \/\/ Setup key material\n-        byte[] keystring = fillSecureRandom(new byte[keyLength \/ 8]);\n-        ks = new SecretKeySpec(keystring, \"AES\");\n-        iv = fillSecureRandom(new byte[IV_BUFFER_SIZE]);\n-        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n-\n-        \/\/ Setup Cipher classes\n-        encryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n-        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n-        decryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n-        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n-            encryptCipher.getParameters().\n-                getParameterSpec(GCMParameterSpec.class));\n-\n-        \/\/ Setup input\/output buffers\n-        in = fillRandom(new byte[dataSize]);\n-        encryptedData = new byte[encryptCipher.getOutputSize(in.length)];\n-        out = new byte[encryptedData.length];\n-        encryptCipher.doFinal(in, 0, in.length, encryptedData, 0);\n-        updateLen = in.length \/ 2;\n-\n-    }\n-\n-    @Benchmark\n-    public void encrypt() throws Exception {\n-        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n-        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n-        encryptCipher.doFinal(in, 0, in.length, out, 0);\n-    }\n-\n-    @Benchmark\n-    public void encryptMultiPart() throws Exception {\n-        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n-        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n-        int outOfs = encryptCipher.update(in, 0, updateLen, out, 0);\n-        encryptCipher.doFinal(in, updateLen, in.length - updateLen,\n-            out, outOfs);\n-    }\n-\n-    @Benchmark\n-    public void decrypt() throws Exception {\n-        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n-            encryptCipher.getParameters().\n-                getParameterSpec(GCMParameterSpec.class));\n-        decryptCipher.doFinal(encryptedData, 0, encryptedData.length, out, 0);\n-    }\n-\n-    @Benchmark\n-    public void decryptMultiPart() throws Exception {\n-        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n-            encryptCipher.getParameters().\n-                getParameterSpec(GCMParameterSpec.class));\n-        decryptCipher.update(encryptedData, 0, updateLen, out, 0);\n-        decryptCipher.doFinal(encryptedData, updateLen,\n-            encryptedData.length - updateLen, out, 0);\n+        init(\"AES\/GCM\/NoPadding\", keyLength);\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESGCMBench.java","additions":10,"deletions":86,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import org.openjdk.jmh.annotations.Benchmark;\n@@ -29,1 +28,1 @@\n-import javax.crypto.Cipher;\n+import java.security.spec.AlgorithmParameterSpec;\n@@ -31,2 +30,0 @@\n-import javax.crypto.spec.SecretKeySpec;\n-import java.nio.ByteBuffer;\n@@ -38,3 +35,0 @@\n- *\n- * This test rotates the IV and creates a new GCMParameterSpec for each encrypt\n- * benchmark operation\n@@ -43,1 +37,1 @@\n-public class AESGCMByteBuffer extends CryptoBase {\n+public class AESGCMByteBuffer extends ByteBufferBase {\n@@ -46,7 +40,1 @@\n-    private int keyLength;\n-\n-    @Param({\"1024\", \"1500\", \"4096\", \"16384\"})\n-    private int dataSize;\n-\n-    @Param({\"direct\", \"heap\"})\n-    private String dataMethod;\n+    int keyLength;\n@@ -54,8 +42,1 @@\n-    byte[] data;\n-    ByteBuffer encryptedData;\n-    ByteBuffer in, out;\n-    private Cipher encryptCipher;\n-    private Cipher decryptCipher;\n-    SecretKeySpec ks;\n-    GCMParameterSpec gcm_spec;\n-    byte[] iv;\n+    public static final int IV_MODULO = 16;\n@@ -63,7 +44,1 @@\n-    private static final int IV_BUFFER_SIZE = 32;\n-    private static final int IV_MODULO = IV_BUFFER_SIZE - 16;\n-    int iv_index = 0;\n-    int updateLen = 0;\n-\n-    private int next_iv_index() {\n-        int r = iv_index;\n+    public AlgorithmParameterSpec getNewSpec() {\n@@ -71,1 +46,1 @@\n-        return r;\n+        return new GCMParameterSpec(128, iv, iv_index, IV_MODULO);\n@@ -76,45 +51,1 @@\n-        setupProvider();\n-\n-        \/\/ Setup key material\n-        byte[] keystring = fillSecureRandom(new byte[keyLength \/ 8]);\n-        ks = new SecretKeySpec(keystring, \"AES\");\n-        iv = fillSecureRandom(new byte[IV_BUFFER_SIZE]);\n-        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n-\n-        \/\/ Setup Cipher classes\n-        encryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n-        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n-        decryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n-        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n-            encryptCipher.getParameters().\n-                getParameterSpec(GCMParameterSpec.class));\n-\n-        \/\/ Setup input\/output buffers\n-        data = fillRandom(new byte[dataSize]);\n-        if (dataMethod.equalsIgnoreCase(\"direct\")) {\n-            in = ByteBuffer.allocateDirect(data.length);\n-            in.put(data);\n-            in.flip();\n-            encryptedData = ByteBuffer.allocateDirect(\n-                encryptCipher.getOutputSize(data.length));\n-            out = ByteBuffer.allocateDirect(encryptedData.capacity());\n-        } else if (dataMethod.equalsIgnoreCase(\"heap\")) {\n-            in = ByteBuffer.wrap(data);\n-            encryptedData = ByteBuffer.allocate(\n-                encryptCipher.getOutputSize(data.length));\n-            out = ByteBuffer.allocate(encryptedData.capacity());\n-        }\n-\n-        encryptCipher.doFinal(in, encryptedData);\n-        encryptedData.flip();\n-        in.flip();\n-        updateLen = in.remaining() \/ 2;\n-    }\n-\n-    @Benchmark\n-    public void encrypt() throws Exception {\n-        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n-        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n-        encryptCipher.doFinal(in, out);\n-        out.flip();\n-        in.flip();\n+        init(\"AES\/GCM\/NoPadding\", keyLength);\n@@ -122,39 +53,0 @@\n-\n-    @Benchmark\n-    public void encryptMultiPart() throws Exception {\n-        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n-        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n-        in.limit(updateLen);\n-        encryptCipher.update(in, out);\n-        in.limit(in.capacity());\n-        encryptCipher.doFinal(in, out);\n-        out.flip();\n-        in.flip();\n-    }\n-\n-    @Benchmark\n-    public void decrypt() throws Exception {\n-        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n-            encryptCipher.getParameters().\n-                getParameterSpec(GCMParameterSpec.class));\n-        decryptCipher.doFinal(encryptedData, out);\n-        encryptedData.flip();\n-        out.flip();\n-    }\n-\n-    @Benchmark\n-    public void decryptMultiPart() throws Exception {\n-        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n-            encryptCipher.getParameters().\n-                getParameterSpec(GCMParameterSpec.class));\n-\n-        int len = encryptedData.remaining();\n-        encryptedData.limit(updateLen);\n-        decryptCipher.update(encryptedData, out);\n-        encryptedData.limit(len);\n-\n-        decryptCipher.doFinal(encryptedData, out);\n-        encryptedData.flip();\n-        out.flip();\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESGCMByteBuffer.java","additions":8,"deletions":116,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import java.security.spec.AlgorithmParameterSpec;\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+\/**\n+ * This is the common code for the AES\/GCM and ChaCha20-Poly1305 performance\n+ * tests.  Encryption and decryption use byte[] as input and output buffers for\n+ * single and multi-part testing.\n+ *\n+ * The IV rotates through a set buffer and creates a new AlgorithmParameterSpec\n+ * for each encrypt benchmark operation.\n+ *\/\n+\n+public abstract class BenchBase extends CryptoBase {\n+    \/\/ Defined by the test\n+    String algorithm;\n+    int keyLength = 256;\n+\n+    \/\/ Default data sizes for full tests\n+    @Param({\"1024\", \"1500\", \"4096\", \"16384\"})\n+    int dataSize;\n+\n+    static final int IV_BUFFER_SIZE = 36;\n+    public byte[] iv;\n+    public int iv_index = 0;\n+    private int updateLen = 0;\n+\n+    private Cipher encryptCipher, decryptCipher;\n+    private byte[] encryptedData, in, out;\n+    private SecretKeySpec ks;\n+    \/\/ Used for decryption to avoid repeated getParameter() calls\n+    private AlgorithmParameterSpec spec;\n+\n+    abstract AlgorithmParameterSpec getNewSpec();\n+\n+    \/\/ Configure setup with particular test parameters\n+    public void init(String algorithm, int keyLength) throws Exception {\n+        this.algorithm = algorithm;\n+        this.keyLength = keyLength;\n+        init();\n+    }\n+\n+    \/\/ Configure setup with particular test parameters\n+    public void init(String algorithm, int keyLength, int dataSize)\n+        throws Exception {\n+        this.dataSize = dataSize;\n+        init(algorithm, keyLength);\n+    }\n+\n+    \/\/ Initalize test setup\n+    private void init() throws Exception {\n+        setupProvider();\n+\n+        \/\/ Setup key material\n+        iv = fillSecureRandom(new byte[IV_BUFFER_SIZE]);\n+        spec = getNewSpec();\n+        \/\/ CC20 doesn't care about the algorithm name on the key, but AES does.\n+        ks = new SecretKeySpec(fillSecureRandom(new byte[keyLength \/ 8]),\n+            \"AES\");\n+\n+        \/\/ Setup Cipher classes\n+        encryptCipher = makeCipher(prov, algorithm);\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, spec);\n+        decryptCipher = makeCipher(prov, algorithm);\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks, spec);\n+\n+        \/\/ Setup input\/output buffers\n+        in = fillRandom(new byte[dataSize]);\n+        encryptedData = new byte[encryptCipher.getOutputSize(in.length)];\n+        out = new byte[encryptedData.length];\n+        encryptCipher.doFinal(in, 0, in.length, encryptedData, 0);\n+        updateLen = in.length \/ 2;\n+\n+    }\n+\n+    @Benchmark\n+    public void encrypt() throws Exception {\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, getNewSpec());\n+        encryptCipher.doFinal(in, 0, in.length, out, 0);\n+    }\n+\n+    @Benchmark\n+    public void encryptMultiPart() throws Exception {\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, getNewSpec());\n+        int outOfs = encryptCipher.update(in, 0, updateLen, out, 0);\n+        encryptCipher.doFinal(in, updateLen, in.length - updateLen,\n+            out, outOfs);\n+    }\n+\n+    @Benchmark\n+    public void decrypt() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks, spec);\n+        decryptCipher.doFinal(encryptedData, 0, encryptedData.length, out, 0);\n+    }\n+\n+    @Benchmark\n+    public void decryptMultiPart() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks, spec);\n+        decryptCipher.update(encryptedData, 0, updateLen, out, 0);\n+        decryptCipher.doFinal(encryptedData, updateLen,\n+            encryptedData.length - updateLen, out, 0);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/BenchBase.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import java.security.spec.AlgorithmParameterSpec;\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.ByteBuffer;\n+\n+\/**\n+ * This is the common code for the AES\/GCM and ChaCha20-Poly1305 performance\n+ * tests.  Encryption and decryption are run with input and output\n+ * ByteBuffers, direct and heap, for single and multi-part testing.\n+ *\n+ * The IV rotates through a set buffer and creates a new AlgorithmParameterSpec\n+ * for each encrypt benchmark operation.\n+ *\/\n+\n+public abstract class ByteBufferBase extends CryptoBase {\n+    \/\/ Defined by the test\n+    String algorithm;\n+    int keyLength = 256;\n+\n+    @Param({\"1024\", \"1500\", \"4096\", \"16384\"})\n+    int dataSize;\n+\n+    @Param({\"direct\", \"heap\"})\n+    String dataMethod;\n+\n+    static final int IV_BUFFER_SIZE = 36;\n+    public byte[] iv;\n+    public int iv_index = 0;\n+    private int updateLen = 0;\n+\n+    private Cipher encryptCipher, decryptCipher;\n+    private ByteBuffer encryptedData, in, out;\n+    private SecretKeySpec ks;\n+    \/\/ Used for decryption to avoid repeated getParameter() calls\n+    private AlgorithmParameterSpec spec;\n+\n+    abstract AlgorithmParameterSpec getNewSpec();\n+\n+    \/\/ Configure setup with particular test parameters\n+    public void init(String algorithm, int keyLength) throws Exception {\n+        this.algorithm = algorithm;\n+        this.keyLength = keyLength;\n+        init();\n+    }\n+\n+    \/\/ Configure setup with particular test parameters\n+    public void init(String algorithm, int keyLength, int dataSize)\n+        throws Exception {\n+        this.dataSize = dataSize;\n+        init(algorithm, keyLength);\n+    }\n+\n+    \/\/ Initalize test setup\n+    private void init() throws Exception {\n+        setupProvider();\n+\n+        \/\/ Setup key material\n+        iv = fillSecureRandom(new byte[IV_BUFFER_SIZE]);\n+        spec = getNewSpec();\n+        \/\/ CC20 doesn't care about the algorithm name on the key, but AES does.\n+        ks = new SecretKeySpec(fillSecureRandom(new byte[keyLength \/ 8]),\n+            \"AES\");\n+\n+        \/\/ Setup Cipher classes\n+        encryptCipher = makeCipher(prov, algorithm);\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, spec);\n+        decryptCipher = makeCipher(prov, algorithm);\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks, spec);\n+\n+        \/\/ Setup input\/output buffers\n+        byte[] data = fillRandom(new byte[dataSize]);\n+        if (dataMethod.equalsIgnoreCase(\"direct\")) {\n+            in = ByteBuffer.allocateDirect(data.length);\n+            in.put(data);\n+            in.flip();\n+            encryptedData = ByteBuffer.allocateDirect(\n+                encryptCipher.getOutputSize(data.length));\n+            out = ByteBuffer.allocateDirect(encryptedData.capacity());\n+        } else if (dataMethod.equalsIgnoreCase(\"heap\")) {\n+            in = ByteBuffer.wrap(data);\n+            encryptedData = ByteBuffer.allocate(\n+                encryptCipher.getOutputSize(data.length));\n+            out = ByteBuffer.allocate(encryptedData.capacity());\n+        }\n+\n+        encryptCipher.doFinal(in, encryptedData);\n+        encryptedData.flip();\n+        in.flip();\n+        updateLen = in.remaining() \/ 2;\n+    }\n+\n+    @Benchmark\n+    public void encrypt() throws Exception {\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, getNewSpec());\n+        encryptCipher.doFinal(in, out);\n+        out.flip();\n+        in.flip();\n+    }\n+\n+    @Benchmark\n+    public void encryptMultiPart() throws Exception {\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, getNewSpec());\n+        in.limit(updateLen);\n+        encryptCipher.update(in, out);\n+        in.limit(in.capacity());\n+        encryptCipher.doFinal(in, out);\n+        out.flip();\n+        in.flip();\n+    }\n+\n+    @Benchmark\n+    public void decrypt() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks, spec);\n+        decryptCipher.doFinal(encryptedData, out);\n+        encryptedData.flip();\n+        out.flip();\n+    }\n+\n+    @Benchmark\n+    public void decryptMultiPart() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks, spec);\n+\n+        int len = encryptedData.remaining();\n+        encryptedData.limit(updateLen);\n+        decryptCipher.update(encryptedData, out);\n+        encryptedData.limit(len);\n+\n+        decryptCipher.doFinal(encryptedData, out);\n+        encryptedData.flip();\n+        out.flip();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/ByteBufferBase.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import java.security.spec.AlgorithmParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+\/**\n+ * This performance tests runs ChaCha20-Poly1305 encryption and decryption\n+ * using input and output byte[] buffers with single and multi-part testing.\n+ *\/\n+\n+public class CC20P1305Bench extends BenchBase {\n+\n+    public static final int IV_MODULO = 12;\n+\n+    public AlgorithmParameterSpec getNewSpec() {\n+        iv_index = (iv_index + 1) % IV_MODULO;\n+        return new IvParameterSpec(iv, iv_index, IV_MODULO);\n+    }\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        init(\"ChaCha20-Poly1305\/None\/NoPadding\", keyLength);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/CC20P1305Bench.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import java.security.spec.AlgorithmParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+\/**\n+ * This performance tests runs ChaCha20-Poly1305 encryption and decryption\n+ * using heap and direct ByteBuffers for input and output buffers with single\n+ * and multi-part operations.\n+ *\/\n+\n+public class CC20P1305ByteBuffer extends ByteBufferBase {\n+\n+    public static final int IV_MODULO = 12;\n+\n+    public AlgorithmParameterSpec getNewSpec() {\n+        iv_index = (iv_index + 1) % IV_MODULO;\n+        return new IvParameterSpec(iv, iv_index, IV_MODULO);\n+    }\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        init(\"ChaCha20-Poly1305\/None\/NoPadding\", keyLength);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/CC20P1305ByteBuffer.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,10 @@\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import java.security.spec.AlgorithmParameterSpec;\n+import javax.crypto.spec.GCMParameterSpec;\n+\n+\/**\n+ * This small performance tests runs AES\/GCM encryption and decryption\n+ * using input and output byte[] buffers with single and multi-part testing.\n+ * Only 1024 plaintext data length is tested.\n+ *\/\n@@ -31,1 +41,1 @@\n-    private int keyLength;\n+    int keyLength;\n@@ -34,1 +44,1 @@\n-    private int dataSize;\n+    int dataSize;\n@@ -36,0 +46,4 @@\n+    @Setup\n+    public void setup() throws Exception {\n+        init(\"AES\/GCM\/NoPadding\", keyLength, dataSize);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/small\/AESGCMBench.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,10 @@\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import java.security.spec.AlgorithmParameterSpec;\n+import javax.crypto.spec.GCMParameterSpec;\n+\n+\/**\n+ * This small performance tests runs AES\/GCM encryption and decryption\n+ * using heap and direct ByteBuffers for input and output buffers with single\n+ * and multi-part operations.  Only 1024 plaintext data length is tested.\n+ *\/\n@@ -31,1 +41,1 @@\n-    private int keyLength;\n+    int keyLength;\n@@ -34,1 +44,1 @@\n-    private int dataSize;\n+    int dataSize;\n@@ -36,0 +46,4 @@\n+    @Setup\n+    public void setup() throws Exception {\n+        init(\"AES\/GCM\/NoPadding\", keyLength, dataSize);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/small\/AESGCMByteBuffer.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.small;\n+\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import java.security.spec.AlgorithmParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+\/**\n+ * This small performance tests runs ChaCha20-Poly1305 encryption and decryption\n+ * using input and output byte[] buffers with single and multi-part testing.\n+ * Only 1024 plaintext data length is tested.\n+ *\/\n+\n+public class CC20P1305Bench extends\n+    org.openjdk.bench.javax.crypto.full.CC20P1305Bench {\n+\n+    @Param({\"1024\"})\n+    int dataSize;\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        init(\"ChaCha20-Poly1305\/None\/NoPadding\", 256, dataSize);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/small\/CC20P1305Bench.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.small;\n+\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import java.security.spec.AlgorithmParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+\/**\n+ * This small performance tests runs ChaCha20-Poly1305 encryption and decryption\n+ * using heap and direct ByteBuffers for input and output buffers with single\n+ * and multi-part operations.  Only 1024 plaintext data length is tested.\n+ *\/\n+\n+public class CC20P1305ByteBuffer extends\n+    org.openjdk.bench.javax.crypto.full.CC20P1305ByteBuffer {\n+\n+    @Param({\"1024\"})\n+    int dataSize;\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        init(\"ChaCha20-Poly1305\/None\/NoPadding\", 256, dataSize);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/small\/CC20P1305ByteBuffer.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"}]}