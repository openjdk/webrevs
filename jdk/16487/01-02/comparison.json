{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.util.ArraysSupport;\n+\n@@ -43,0 +45,2 @@\n+    private static final int INCREMENT = 64;\n+\n@@ -52,3 +56,3 @@\n-     * This method saves memory by returning the internal buffer. If\n-     * internal buffer is larger than the data stored {@code count}, a copy is\n-     * returned.\n+     * This method saves memory by returning the internal buffer. The calling\n+     * method must use {@code size()} for the relevant data length as the\n+     * returning byte[] maybe larger.\n@@ -60,3 +64,0 @@\n-        if (buf.length > count) {\n-            return Arrays.copyOfRange(buf, 0, count);\n-        }\n@@ -66,0 +67,14 @@\n+    \/**\n+     * This method with expand the buffer if {@code count} + {@code len}\n+     * is larger than the buffer byte[] length.\n+     * @param len length to add to the current buffer\n+     *\/\n+    private void checkCapacity(int len) {\n+        int blen = buf.length;\n+        \/\/ Create a new larger buffer and append the new data\n+        if (blen < count + len) {\n+            buf = Arrays.copyOf(buf, ArraysSupport.newLength(blen, blen + len,\n+                blen));\n+        }\n+    }\n+\n@@ -80,11 +95,4 @@\n-        if (buf == null) {\n-            buf = new byte[len];\n-            src.get(buf);\n-            count = buf.length;\n-        } else {\n-            if (buf.length < (count + len)) {\n-                buf = Arrays.copyOf(buf, count + len);\n-            }\n-            src.get(buf, count, len);\n-            count += len;\n-        }\n+\n+        checkCapacity(len);\n+        src.get(buf, count, len);\n+        count += len;\n@@ -95,13 +103,3 @@\n-        if (buf == null) {\n-            buf = new byte[len];\n-            System.arraycopy(in, offset, buf, 0, len);\n-            count = buf.length;\n-        } else {\n-            \/\/ Create a new larger buffer and append the new data\n-            if (buf.length < count + len) {\n-                buf = Arrays.copyOf(buf, count + len);\n-            }\n-\n-            System.arraycopy(in, offset, buf, count, len);\n-            count += len;\n-        }\n+        checkCapacity(len);\n+        System.arraycopy(in, offset, buf, count, len);\n+        count += len;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AEADBufferedStream.java","additions":28,"deletions":30,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1531,1 +1531,1 @@\n-        private AEADBufferedStream cipherBuf;\n+        private AEADBufferedStream cipherBuf = null;\n@@ -1617,1 +1617,1 @@\n-                ctPlusTagLen = ctPlusTag.length;\n+                ctPlusTagLen = cipherBuf.size();\n@@ -1656,1 +1656,4 @@\n-            byte[] ct, buf = (getBufferedLength() == 0 ? null : cipherBuf.toByteArray());\n+            byte[] ct = null, buf = null;\n+                \/\/buf = (getBufferedLength() == 0 ? null : cipherBuf.toByteArray());\n+            int bufLen = 0;\n+            \/\/ The length of cipher text and tag\n@@ -1658,0 +1661,1 @@\n+\n@@ -1661,8 +1665,8 @@\n-            if (inLen == 0) {\n-                ct = buf;\n-                buf = null;\n-                len = ctLen;\n-            } else if (inLen < TAG_LENGTH) {\n-                doUpdate(input, output);\n-                ct = cipherBuf.toByteArray();\n-                buf = null;\n+\n+            if (inLen < TAG_LENGTH) {\n+                if (inLen > 0) {\n+                    doUpdate(input, output);\n+                }\n+                if (cipherBuf != null) {\n+                    ct = cipherBuf.toByteArray();\n+                }\n@@ -1671,0 +1675,4 @@\n+                if (cipherBuf != null) {\n+                    buf = cipherBuf.toByteArray();\n+                    bufLen = cipherBuf.size();\n+                }\n@@ -1679,1 +1687,1 @@\n-                dataLen = authUpdate(buf, 0, buf.length);\n+                dataLen = authUpdate(buf, 0, bufLen);\n@@ -1694,2 +1702,2 @@\n-                chaCha20Transform(buf, 0, buf.length, buf, 0);\n-                output.put(buf, 0, buf.length);\n+                chaCha20Transform(buf, 0, bufLen, buf, 0);\n+                output.put(buf, 0, bufLen);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ChaCha20Cipher.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -789,14 +789,0 @@\n-        \/**\n-         * The method takes two buffers to create one block of data.  The\n-         * difference with the other mergeBlock is this will calculate\n-         * the bufLen from the existing 'buffer' length & offset\n-         *\n-         * This is only called when buffer length is less than a blockSize\n-         * @return number of bytes used from 'in'\n-         *\/\n-        int mergeBlock(byte[] buffer, int bufOfs, byte[] in, int inOfs,\n-            int inLen, byte[] block) {\n-            return mergeBlock(buffer, bufOfs, buffer.length - bufOfs, in,\n-                inOfs, inLen, block);\n-        }\n-\n@@ -857,1 +843,2 @@\n-                if (aadBuffer.size() > 0) {\n+                sizeOfAAD = aadBuffer.size();\n+                if (sizeOfAAD > 0) {\n@@ -859,3 +846,1 @@\n-                    sizeOfAAD = aad.length;\n-\n-                    int lastLen = aad.length % blockSize;\n+                    int lastLen = sizeOfAAD % blockSize;\n@@ -863,1 +848,1 @@\n-                        ghash.update(aad, 0, aad.length - lastLen);\n+                        ghash.update(aad, 0, sizeOfAAD - lastLen);\n@@ -865,1 +850,1 @@\n-                            aad.length - lastLen, lastLen, blockSize);\n+                            sizeOfAAD - lastLen, lastLen, blockSize);\n@@ -868,1 +853,1 @@\n-                        ghash.update(aad);\n+                        ghash.update(aad, 0, sizeOfAAD);\n@@ -1224,1 +1209,2 @@\n-                    ByteBuffer buffer = ByteBuffer.wrap(ibuffer.toByteArray());\n+                    ByteBuffer buffer = ByteBuffer.wrap(ibuffer.toByteArray(),\n+                        0, ibuffer.size());\n@@ -1291,1 +1277,1 @@\n-                    r = mergeBlock(buffer, 0, in, inOfs, inLen, block);\n+                    r = mergeBlock(buffer, 0, ibuffer.size(), in, inOfs, inLen, block);\n@@ -1348,1 +1334,2 @@\n-                        ByteBuffer.wrap(ibuffer.toByteArray()), src, dst);\n+                        ByteBuffer.wrap(ibuffer.toByteArray(), 0,\n+                            ibuffer.size()), src, dst);\n@@ -1423,2 +1410,3 @@\n-                tagOfs = mergeBlock(buffer,\n-                    buffer.length - (tagLenBytes - inLen), in, inOfs, inLen,\n+                int ofs = ibuffer.size() - (tagLenBytes - inLen);\n+                tagOfs = mergeBlock(buffer, ofs, ibuffer.size() - ofs,\n+                    in, inOfs, inLen,\n@@ -1556,1 +1544,2 @@\n-                buffer = ByteBuffer.wrap(ibuffer.toByteArray());\n+                buffer = ByteBuffer.wrap(ibuffer.toByteArray(), 0,\n+                    ibuffer.size());\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":16,"deletions":27,"binary":false,"changes":43,"status":"modified"}]}