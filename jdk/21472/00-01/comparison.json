{"files":[{"patch":"@@ -2303,3 +2303,0 @@\n-  if (depth == b_depth) {\n-    return true;\n-  }\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-bool is_high_pressure(const Block* b, const LRG* lrg, uint insidx) {\n+static bool is_high_pressure(const Block* b, const LRG* lrg, uint insidx) {\n@@ -486,2 +486,5 @@\n-\/\/ Check if a live range would be spilt in a loop nest\n-static bool is_spilt_in_loop_nest(const PhaseCFG& cfg, CFGLoop* loop, const LRG& lrg) {\n+\/\/ Check if a live range would be spilt in a loop nest so that we will eagerly spill it\n+static bool should_spill_before_loop(const PhaseCFG& cfg, PhaseChaitin& chaitin, CFGLoop* loop, uint lrg_idx, const LRG& lrg) {\n+  assert(&chaitin.lrgs(lrg_idx) == &lrg, \"must be\");\n+  bool spilt = false;\n+  bool used_in_common_path = false;\n@@ -490,0 +493,6 @@\n+    if (!loop->in_loop_nest(b)) {\n+      continue;\n+    }\n+\n+    \/\/ Don't be eager spilling something that will only be spilt uncommonly and is used in the common path\n+    constexpr double uncommon_threshold = 0.1;\n@@ -491,2 +500,27 @@\n-    if (loop->in_loop_nest(b) && is_high_pressure(b, &lrg, b->end_idx())) {\n-      return true;\n+    if (is_high_pressure(b, &lrg, b->end_idx())) {\n+      \/\/ If a node needs to be spilt in a child loop, we can spill it at the child entry, too. Choose the best option.\n+      double spill_freq = b->_freq;\n+      for (CFGLoop* l = b->_loop; l != loop; l = l->parent()) {\n+        assert(l != nullptr, \"\");\n+        Block* l_entry = cfg.get_block_for_node(l->head()->pred(LoopNode::EntryControl));\n+        spill_freq = MIN2(spill_freq, l_entry->_freq);\n+      }\n+      if (spill_freq > loop->head()->_freq * uncommon_threshold) {\n+        return true;\n+      } else {\n+        spilt = true;\n+      }\n+    }\n+\n+    \/\/ If lrg is used in the common path\n+    if (b->_freq > loop->head()->_freq * uncommon_threshold) {\n+      for (uint i = 0; !used_in_common_path && i < b->number_of_nodes(); i++) {\n+        Node* n = b->get_node(i);\n+        for (uint j = 1; j < n->req(); j++) {\n+          Node* in = n->in(j);\n+          if (in != nullptr && chaitin._lrg_map.find_id(in) == lrg_idx) {\n+            used_in_common_path = true;\n+            break;\n+          }\n+        }\n+      }\n@@ -495,1 +529,1 @@\n-  return false;\n+  return spilt && !used_in_common_path;\n@@ -734,1 +768,1 @@\n-        if (!has_phi && b->head()->is_Loop() && is_spilt_in_loop_nest(_cfg, b->_loop, lrgs(lidx))) {\n+        if (!has_phi && b->head()->is_Loop() && should_spill_before_loop(_cfg, *this, b->_loop, lidx, lrgs(lidx))) {\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":41,"deletions":7,"binary":false,"changes":48,"status":"modified"}]}