{"files":[{"patch":"@@ -40,0 +40,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.util.stream.Collectors;\n@@ -48,0 +50,1 @@\n+                buf.thisClass().asSymbol(),\n@@ -59,0 +62,1 @@\n+    private final ClassDesc thisClass;\n@@ -61,0 +65,2 @@\n+    private final boolean isStatic;\n+    private final ByteBuffer bytecode;\n@@ -94,0 +100,1 @@\n+                     ClassDesc thisClass,\n@@ -100,0 +107,1 @@\n+        this.thisClass = thisClass;\n@@ -102,0 +110,2 @@\n+        this.isStatic = isStatic;\n+        this.bytecode = bytecode;\n@@ -250,1 +260,1 @@\n-                                error(\"low must be less than or equal to high in tableswitch\");\n+                                throw error(\"low must be less than or equal to high in tableswitch\");\n@@ -254,1 +264,1 @@\n-                                error(\"too many keys in tableswitch\");\n+                                throw error(\"too many keys in tableswitch\");\n@@ -260,1 +270,1 @@\n-                                error(\"number of keys in lookupswitch less than 0\");\n+                                throw error(\"number of keys in lookupswitch less than 0\");\n@@ -267,1 +277,1 @@\n-                                    error(\"Bad lookupswitch instruction\");\n+                                    throw error(\"Bad lookupswitch instruction\");\n@@ -329,1 +339,1 @@\n-                        error(String.format(\"Bad instruction: %02x\", opcode));\n+                        throw error(String.format(\"Bad instruction: %02x\", opcode));\n@@ -363,1 +373,1 @@\n-                error(\"CP entry #%d %s is not loadable constant\".formatted(index, cp.entryByIndex(index).tag()));\n+                throw error(\"CP entry #%d %s is not loadable constant\".formatted(index, cp.entryByIndex(index).tag()));\n@@ -367,2 +377,2 @@\n-    private void error(String msg) {\n-        throw new IllegalArgumentException(\"%s at bytecode offset %d of method %s(%s)\".formatted(\n+    private IllegalArgumentException error(String msg) {\n+        var sb = new StringBuilder(\"%s at bytecode offset %d of method %s(%s)\".formatted(\n@@ -372,1 +382,3 @@\n-                methodDesc.displayDescriptor()));\n+                methodDesc.parameterList().stream().map(ClassDesc::displayName).collect(Collectors.joining(\",\"))));\n+        Util.dumpMethod(cp, thisClass, methodName, methodDesc, isStatic ? ACC_STATIC : 0, bytecode, sb::append);\n+        return new IllegalArgumentException(sb.toString());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-import java.lang.classfile.components.ClassPrinter;\n-import java.lang.classfile.attribute.CodeAttribute;\n@@ -839,30 +837,1 @@\n-        \/\/try to attach debug info about corrupted bytecode to the message\n-        try {\n-            var cc = ClassFile.of();\n-            var clm = cc.parse(cc.build(cp.classEntry(thisType.sym()), cp, clb ->\n-                    clb.withMethod(methodName, methodDesc, isStatic ? ACC_STATIC : 0, mb ->\n-                            ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.CODE) {\n-                                @Override\n-                                public void writeBody(BufWriter b) {\n-                                    b.writeU2(-1);\/\/max stack\n-                                    b.writeU2(-1);\/\/max locals\n-                                    b.writeInt(bytecode.limit());\n-                                    b.writeBytes(bytecode.array(), 0, bytecode.limit());\n-                                    b.writeU2(0);\/\/exception handlers\n-                                    b.writeU2(0);\/\/attributes\n-                                }\n-                    }))));\n-            ClassPrinter.toYaml(clm.methods().get(0).code().get(), ClassPrinter.Verbosity.TRACE_ALL, sb::append);\n-        } catch (Error | Exception suppresed) {\n-            \/\/fallback to bytecode hex dump\n-            bytecode.rewind();\n-            while (bytecode.position() < bytecode.limit()) {\n-                sb.append(\"%n%04x:\".formatted(bytecode.position()));\n-                for (int i = 0; i < 16 && bytecode.position() < bytecode.limit(); i++) {\n-                    sb.append(\" %02x\".formatted(bytecode.get()));\n-                }\n-            }\n-            var err = new IllegalArgumentException(sb.toString());\n-            err.addSuppressed(suppresed);\n-            return err;\n-        }\n+        Util.dumpMethod(cp, thisType.sym(), methodName, methodDesc, isStatic ? ACC_STATIC : 0, bytecode, sb::append);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.BufWriter;\n@@ -46,0 +48,5 @@\n+import java.lang.classfile.attribute.CodeAttribute;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.nio.ByteBuffer;\n+import java.util.function.Consumer;\n@@ -196,0 +203,37 @@\n+\n+    public static void dumpMethod(SplitConstantPool cp,\n+                                  ClassDesc cls,\n+                                  String methodName,\n+                                  MethodTypeDesc methodDesc,\n+                                  int acc,\n+                                  ByteBuffer bytecode,\n+                                  Consumer<String> dump) {\n+\n+        \/\/ try to dump debug info about corrupted bytecode\n+        try {\n+            var cc = ClassFile.of();\n+            var clm = cc.parse(cc.build(cp.classEntry(cls), cp, clb ->\n+                    clb.withMethod(methodName, methodDesc, acc, mb ->\n+                            ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.CODE) {\n+                                @Override\n+                                public void writeBody(BufWriter b) {\n+                                    b.writeU2(-1);\/\/max stack\n+                                    b.writeU2(-1);\/\/max locals\n+                                    b.writeInt(bytecode.limit());\n+                                    b.writeBytes(bytecode.array(), 0, bytecode.limit());\n+                                    b.writeU2(0);\/\/exception handlers\n+                                    b.writeU2(0);\/\/attributes\n+                                }\n+                    }))));\n+            ClassPrinter.toYaml(clm.methods().get(0).code().get(), ClassPrinter.Verbosity.TRACE_ALL, dump);\n+        } catch (Error | Exception _) {\n+            \/\/ fallback to bytecode hex dump\n+            bytecode.rewind();\n+            while (bytecode.position() < bytecode.limit()) {\n+                dump.accept(\"%n%04x:\".formatted(bytecode.position()));\n+                for (int i = 0; i < 16 && bytecode.position() < bytecode.limit(); i++) {\n+                    dump.accept(\" %02x\".formatted(bytecode.get()));\n+                }\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"}]}