{"files":[{"patch":"@@ -221,1 +221,1 @@\n-  _frame_size = align_up(register_save_size, frame::alignment_in_bytes) + frame::z_abi_160_size; \/\/ FIXME: this could be restricted to argument only\n+  _frame_size = align_up(register_save_size, frame::alignment_in_bytes) + frame::z_abi_160_size;\n@@ -224,1 +224,1 @@\n-  __ push_frame(_frame_size, Z_R14); \/\/ FIXME: check if Z_R1_scaratch can do a job here;\n+  __ push_frame(_frame_size, Z_R14);\n@@ -243,0 +243,1 @@\n+  \/\/ Going to preserve the volatile registers which can be used by Register Allocator.\n@@ -254,2 +255,5 @@\n-\n-      if (std_reg->encoding() >= Z_R2->encoding() && std_reg->encoding() <= Z_R15->encoding()) {\n+      \/\/ Z_R0 and Z_R1 will not be allocated by the register allocator, see s390.ad (Integer Register Classes)\n+      \/\/ Z_R6 to Z_R15 are saved registers, except Z_R14 (see Z-Abi)\n+      if (std_reg->encoding() == Z_R14->encoding() ||\n+         (std_reg->encoding() >= Z_R2->encoding()  &&\n+          std_reg->encoding() <= Z_R5->encoding())) {\n@@ -268,2 +272,4 @@\n-      if (fp_reg->encoding() >= Z_F0->encoding() && fp_reg->encoding() <= Z_F15->encoding()\n-          && fp_reg->encoding() != Z_F1->encoding()) {\n+      \/\/ Z_R1 will not be allocated by the register allocator, see s390.ad (Float Register Classes)\n+      if (fp_reg->encoding() >= Z_F0->encoding() &&\n+          fp_reg->encoding() <= Z_F7->encoding() &&\n+          fp_reg->encoding() != Z_F1->encoding()) {\n@@ -280,2 +286,14 @@\n-    } else if (false \/* vm_reg->is_VectorRegister() *\/){\n-      fatal(\"Vector register support is not there yet!\");\n+    } else if (vm_reg->is_VectorRegister()) {\n+      VectorRegister vs_reg = vm_reg->as_VectorRegister();\n+      \/\/ Z_V0 to Z_V15 will not be allocated by the register allocator, see s390.ad (reg class z_v_reg)\n+      if (vs_reg->encoding() >= Z_V16->encoding() &&\n+          vs_reg->encoding() <= Z_V31->encoding()) {\n+        reg_save_index += 2;\n+        if (action == ACTION_SAVE) {\n+          __ z_vst(vs_reg, Address(Z_SP, offset - reg_save_index * BytesPerWord));\n+        } else if (action == ACTION_RESTORE) {\n+          __ z_vl(vs_reg, Address(Z_SP, offset - reg_save_index * BytesPerWord));\n+        } else {\n+          assert(action == ACTION_COUNT_ONLY, \"Sanity\");\n+        }\n+      }\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"}]}