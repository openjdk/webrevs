{"files":[{"patch":"@@ -58,1 +58,1 @@\n-    output()->print(\", largest_committed=\" SIZE_FORMAT \"%s\", amount_in_current_scale(peak), scale);\n+    output()->print(\", peak=\" SIZE_FORMAT \"%s\", amount_in_current_scale(peak), scale);\n@@ -96,0 +96,1 @@\n+  outputStream* out = output();\n@@ -97,2 +98,7 @@\n-  output()->print(\"(mmap: reserved=\" SIZE_FORMAT \"%s, committed=\" SIZE_FORMAT \"%s, largest_committed=\" SIZE_FORMAT \"%s)\",\n-    amount_in_current_scale(reserved), scale, amount_in_current_scale(committed), scale, amount_in_current_scale(peak), scale);\n+  out->print(\"(mmap: reserved=\" SIZE_FORMAT \"%s, committed=\" SIZE_FORMAT \"%s, \",\n+    amount_in_current_scale(reserved), scale, amount_in_current_scale(committed), scale);\n+  if (peak == committed) {\n+    out->print_raw(\"at peak)\");\n+  } else {\n+    out->print(\"peak=\" SIZE_FORMAT \"%s)\", amount_in_current_scale(peak), scale);\n+  }\n@@ -207,5 +213,14 @@\n-  if (amount_in_current_scale(reserved_amount) > 0) {\n-    outputStream* out   = output();\n-    const char*   scale = current_scale();\n-    out->print(\"-%26s (\", NMTUtil::flag_to_name(flag));\n-    print_total(reserved_amount, committed_amount);\n+  \/\/ Omit printing if the current reserved value as well as all historical peaks (malloc, mmap committed, arena)\n+  \/\/ fall below scale threshold\n+  const size_t pk_vm = virtual_memory->peak_size();\n+  const size_t pk_malloc = malloc_memory->malloc_peak_size();\n+  const size_t pk_arena = malloc_memory->arena_peak_size();\n+\n+  if (amount_in_current_scale(MAX4(reserved_amount, pk_vm, pk_malloc, pk_arena)) == 0) {\n+    return;\n+  }\n+\n+  outputStream* out   = output();\n+  const char*   scale = current_scale();\n+  out->print(\"-%26s (\", NMTUtil::flag_to_name(flag));\n+  print_total(reserved_amount, committed_amount);\n@@ -213,5 +228,5 @@\n-    if (flag == mtClassShared) {\n-        size_t read_only_bytes = FileMapInfo::readonly_total();\n-      output()->print(\", readonly=\" SIZE_FORMAT \"%s\",\n-                      amount_in_current_scale(read_only_bytes), scale);\n-    }\n+  if (flag == mtClassShared) {\n+      size_t read_only_bytes = FileMapInfo::readonly_total();\n+    output()->print(\", readonly=\" SIZE_FORMAT \"%s\",\n+                    amount_in_current_scale(read_only_bytes), scale);\n+  }\n@@ -219,1 +234,1 @@\n-    out->print_cr(\")\");\n+  out->print_cr(\")\");\n@@ -221,23 +236,21 @@\n-    if (flag == mtClass) {\n-      \/\/ report class count\n-      out->print_cr(\"%27s (classes #\" SIZE_FORMAT \")\",\n-        \" \", (_instance_class_count + _array_class_count));\n-      out->print_cr(\"%27s (  instance classes #\" SIZE_FORMAT \", array classes #\" SIZE_FORMAT \")\",\n-        \" \", _instance_class_count, _array_class_count);\n-    } else if (flag == mtThread) {\n-      if (ThreadStackTracker::track_as_vm()) {\n-        const VirtualMemory* thread_stack_usage =\n-         _vm_snapshot->by_type(mtThreadStack);\n-        \/\/ report thread count\n-        out->print_cr(\"%27s (threads #\" SIZE_FORMAT \")\", \" \", ThreadStackTracker::thread_count());\n-        out->print(\"%27s (stack: \", \" \");\n-        print_total(thread_stack_usage->reserved(), thread_stack_usage->committed(), thread_stack_usage->peak_size());\n-      } else {\n-        MallocMemory* thread_stack_memory = _malloc_snapshot->by_type(mtThreadStack);\n-        const char* scale = current_scale();\n-        \/\/ report thread count\n-        out->print_cr(\"%27s (threads #\" SIZE_FORMAT \")\", \" \", thread_stack_memory->malloc_count());\n-        out->print(\"%27s (Stack: \" SIZE_FORMAT \"%s\", \" \",\n-          amount_in_current_scale(thread_stack_memory->malloc_size()), scale);\n-      }\n-      out->print_cr(\")\");\n+  if (flag == mtClass) {\n+    \/\/ report class count\n+    out->print_cr(\"%27s (classes #\" SIZE_FORMAT \")\",\n+      \" \", (_instance_class_count + _array_class_count));\n+    out->print_cr(\"%27s (  instance classes #\" SIZE_FORMAT \", array classes #\" SIZE_FORMAT \")\",\n+      \" \", _instance_class_count, _array_class_count);\n+  } else if (flag == mtThread) {\n+    if (ThreadStackTracker::track_as_vm()) {\n+      const VirtualMemory* thread_stack_usage =\n+       _vm_snapshot->by_type(mtThreadStack);\n+      \/\/ report thread count\n+      out->print_cr(\"%27s (threads #\" SIZE_FORMAT \")\", \" \", ThreadStackTracker::thread_count());\n+      out->print(\"%27s (stack: \", \" \");\n+      print_total(thread_stack_usage->reserved(), thread_stack_usage->committed(), thread_stack_usage->peak_size());\n+    } else {\n+      MallocMemory* thread_stack_memory = _malloc_snapshot->by_type(mtThreadStack);\n+      const char* scale = current_scale();\n+      \/\/ report thread count\n+      out->print_cr(\"%27s (threads #\" SIZE_FORMAT \")\", \" \", thread_stack_memory->malloc_count());\n+      out->print(\"%27s (Stack: \" SIZE_FORMAT \"%s\", \" \",\n+        amount_in_current_scale(thread_stack_memory->malloc_size()), scale);\n@@ -245,0 +258,2 @@\n+    out->print_cr(\")\");\n+  }\n@@ -246,5 +261,4 @@\n-     \/\/ report malloc'd memory\n-    if (amount_in_current_scale(malloc_memory->malloc_size()) > 0\n-        || amount_in_current_scale(malloc_memory->malloc_peak_size()) > 0) {\n-      print_malloc_line(malloc_memory->malloc_counter());\n-    }\n+   \/\/ report malloc'd memory\n+  if (amount_in_current_scale(MAX2(malloc_memory->malloc_size(), pk_malloc)) > 0) {\n+    print_malloc_line(malloc_memory->malloc_counter());\n+  }\n@@ -252,4 +266,3 @@\n-    if (amount_in_current_scale(virtual_memory->reserved()) > 0\n-        DEBUG_ONLY(|| amount_in_current_scale(virtual_memory->peak_size()) > 0)) {\n-      print_virtual_memory_line(virtual_memory->reserved(), virtual_memory->committed(), virtual_memory->peak_size());\n-    }\n+  if (amount_in_current_scale(MAX2(virtual_memory->reserved(), pk_vm)) > 0) {\n+    print_virtual_memory_line(virtual_memory->reserved(), virtual_memory->committed(), virtual_memory->peak_size());\n+  }\n@@ -257,4 +270,3 @@\n-    if (amount_in_current_scale(malloc_memory->arena_size()) > 0\n-        DEBUG_ONLY(|| amount_in_current_scale(malloc_memory->arena_peak_size()) > 0)) {\n-      print_arena_line(malloc_memory->arena_counter());\n-    }\n+  if (amount_in_current_scale(MAX2(malloc_memory->arena_size(), pk_arena)) > 0) {\n+    print_arena_line(malloc_memory->arena_counter());\n+  }\n@@ -262,10 +274,9 @@\n-    if (flag == mtNMT &&\n-      amount_in_current_scale(_malloc_snapshot->malloc_overhead()) > 0) {\n-      out->print_cr(\"%27s (tracking overhead=\" SIZE_FORMAT \"%s)\", \" \",\n-        amount_in_current_scale(_malloc_snapshot->malloc_overhead()), scale);\n-    } else if (flag == mtClass) {\n-      \/\/ Metadata information\n-      report_metadata(Metaspace::NonClassType);\n-      if (Metaspace::using_class_space()) {\n-        report_metadata(Metaspace::ClassType);\n-      }\n+  if (flag == mtNMT &&\n+    amount_in_current_scale(_malloc_snapshot->malloc_overhead()) > 0) {\n+    out->print_cr(\"%27s (tracking overhead=\" SIZE_FORMAT \"%s)\", \" \",\n+      amount_in_current_scale(_malloc_snapshot->malloc_overhead()), scale);\n+  } else if (flag == mtClass) {\n+    \/\/ Metadata information\n+    report_metadata(Metaspace::NonClassType);\n+    if (Metaspace::using_class_space()) {\n+      report_metadata(Metaspace::ClassType);\n@@ -273,1 +284,0 @@\n-    out->print_cr(\" \");\n@@ -275,0 +285,1 @@\n+  out->print_cr(\" \");\n@@ -324,3 +335,2 @@\n-    \/\/ Don't report if site has never allocated less than one unit of whatever our scale is\n-    if (scale() > 1 && amount_in_current_scale(malloc_site->size()) == 0\n-                       DEBUG_ONLY(&& amount_in_current_scale(malloc_site->peak_size()) == 0)) {\n+    \/\/ Omit printing if the current value and the historic peak value both fall below the reporting scale threshold\n+    if (amount_in_current_scale(MAX2(malloc_site->size(), malloc_site->peak_size())) == 0) {\n@@ -356,2 +366,4 @@\n-    \/\/ Don't report if site has reserved less than one unit of whatever our scale is\n-    if (scale() > 1 && amount_in_current_scale(virtual_memory_site->reserved()) == 0) {\n+    \/\/ Omit printing if the current value and the historic peak value both fall below the\n+    \/\/ reporting scale threshold\n+    if (amount_in_current_scale(MAX2(virtual_memory_site->reserved(),\n+                                     virtual_memory_site->peak_size())) == 0) {\n@@ -389,1 +401,10 @@\n-  \/\/ Don't report if size is too small\n+  \/\/ We don't bother about reporting peaks here.\n+  \/\/ That is because peaks - in the context of virtual memory, peak of committed areas - make little sense\n+  \/\/ when we report *by region*, which are identified by their location in memory. There is a philosophical\n+  \/\/ question about identity here: e.g. a committed region that has been split into three regions by\n+  \/\/ uncommitting a middle section of it, should that still count as \"having peaked\" before the split? If\n+  \/\/ yes, which of the three new regions would be the spiritual successor? Rather than introducing more\n+  \/\/ complexity, we avoid printing peaks altogether. Note that peaks should still be printed when reporting\n+  \/\/ usage *by callsite*.\n+\n+  \/\/ Don't report if size is too small.\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":88,"deletions":67,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#ifdef ASSERT\n@@ -49,1 +48,0 @@\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#ifdef ASSERT\n@@ -48,1 +47,0 @@\n-#endif \/\/ ASSERT\n@@ -51,3 +49,1 @@\n-  VirtualMemory() : _reserved(0), _committed(0) {\n-    DEBUG_ONLY(_peak_size  = 0;)\n-  }\n+  VirtualMemory() : _reserved(0), _committed(0), _peak_size(0) {}\n@@ -58,1 +54,0 @@\n-    DEBUG_ONLY(update_peak(sz);)\n@@ -60,0 +55,1 @@\n+    update_peak(_committed);\n@@ -75,1 +71,1 @@\n-    return DEBUG_ONLY(Atomic::load(&_peak_size)) NOT_DEBUG(0);\n+    return Atomic::load(&_peak_size);\n@@ -88,2 +84,0 @@\n-  inline void uncommit_memory(size_t sz) { _c.uncommit_memory(sz); }\n-  inline void release_memory(size_t sz)  { _c.release_memory(sz);  }\n@@ -92,0 +86,1 @@\n+  inline size_t peak_size() const { return _c.peak_size(); }\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2023, Red Hat, Inc. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail HugeArenaTracking\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=summary HugeArenaTracking\n@@ -40,1 +40,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -45,1 +44,2 @@\n-  private static final long GB = 1024 * 1024 * 1024;\n+  private static final long MB = 1024 * 1024;\n+  private static final long GB = MB * 1024;\n@@ -48,1 +48,0 @@\n-    OutputAnalyzer output;\n@@ -51,4 +50,0 @@\n-    \/\/ Grab my own PID\n-    String pid = Long.toString(ProcessTools.getProcessId());\n-    ProcessBuilder pb = new ProcessBuilder();\n-\n@@ -58,4 +53,4 @@\n-    \/\/ Run 'jcmd <pid> VM.native_memory summary'\n-    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\"});\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=2KB, committed=2KB)\");\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[] { \"scale=K\" },\n+            new String[] { \"Test (reserved=2KB, committed=2KB)\",\n+                           \"(arena=2KB #2) (at peak)\" });\n@@ -68,4 +63,2 @@\n-      \/\/ Cap to 10M\n-      long inc = rand.nextInt(10 * 1024 * 1024);\n-      wb.NMTArenaMalloc(arena1, inc);\n-      total += inc;\n+      wb.NMTArenaMalloc(arena1, MB);\n+      total += MB;\n@@ -74,5 +67,12 @@\n-    ProcessBuilder pb2 = new ProcessBuilder();\n-    \/\/ Run 'jcmd <pid> VM.native_memory summary'\n-    pb2.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\", \"scale=GB\"});\n-    output = new OutputAnalyzer(pb2.start());\n-    output.shouldContain(\"Test (reserved=2GB, committed=2GB)\");\n+    \/\/ run a report at GB level. We should see our allocations; since they are rounded\n+    \/\/ to GB, we expect an exact output match\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[] { \"scale=G\" },\n+            new String[] { \"Test (reserved=2GB, committed=2GB)\",\n+                           \"(arena=2GB #2) (at peak)\" });\n+\n+    \/\/ Repeat at MB level; we expect the same behavior\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[] { \"scale=M\" },\n+            new String[] { \"Test (reserved=2048MB, committed=2048MB)\",\n+                           \"(arena=2048MB #2) (at peak)\" });\n@@ -82,2 +82,21 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=1KB, committed=1KB)\");\n+    \/\/ Repeat report at GB level. Reserved should be 0 now. Current usage is 1KB, since arena2 is left, but that\n+    \/\/ is below GB scale threshold, so should show up as 0.\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[] { \"scale=G\" },\n+            new String[] { \"Test (reserved=0GB, committed=0GB)\",\n+                           \"(arena=0GB #1) (peak=2GB #2)\" });\n+\n+    \/\/ Same, for MB scale\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[] { \"scale=M\" },\n+            new String[] { \"Test (reserved=0MB, committed=0MB)\",\n+                           \"(arena=0MB #1) (peak=2048MB #2)\" });\n+\n+    \/\/ At KB level we should see the remaining 1KB. Note that we refrain from testing peak here\n+    \/\/ since the number gets fuzzy: it depends on the size of the initially allocated chunk. At MB\n+    \/\/ and GB scale, these differences don't matter.\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[] { \"scale=K\" },\n+            new String[] { \"Test (reserved=1KB, committed=1KB)\",\n+                           \"(arena=1KB #1) (peak=\" });\n+\n@@ -86,2 +105,5 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldNotContain(\"Test (reserved\");\n+    \/\/ Everything free'd, current usage 0, peak should be preserved.\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[] { \"scale=G\" },\n+            new String[] { \"Test (reserved=0GB, committed=0GB)\",\n+                           \"(arena=0GB #0) (peak=2GB #2)\" });\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/HugeArenaTracking.java","additions":48,"deletions":26,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -36,4 +36,0 @@\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.JDKToolFinder;\n-\n@@ -46,1 +42,0 @@\n-        OutputAnalyzer output;\n@@ -49,4 +44,0 @@\n-        \/\/ Grab my own PID\n-        String pid = Long.toString(ProcessTools.getProcessId());\n-        ProcessBuilder pb = new ProcessBuilder();\n-\n@@ -66,5 +57,4 @@\n-                String expectedOut = (\"Test (reserved=\" + numKB + \"KB, committed=\" + numKB + \"KB)\");\n-\n-                pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\" });\n-                output = new OutputAnalyzer(pb.start());\n-                output.shouldContain(expectedOut);\n+                NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+                        \"Test (reserved=\" + numKB + \"KB, committed=\" + numKB + \"KB)\",\n+                        \"(malloc=\" + numKB + \"KB #1) (at peak)\"\n+                );\n@@ -73,0 +63,1 @@\n+\n@@ -74,3 +65,4 @@\n-                pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\" });\n-                output = new OutputAnalyzer(pb.start());\n-                output.shouldNotContain(\"Test (reserved=\");\n+                NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+                        \"Test (reserved=0KB, committed=0KB)\",\n+                        \"(malloc=0KB) (peak=\" + numKB + \"KB #1)\"\n+                );\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocRoundingReportTest.java","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-        output.shouldNotContain(\"Test (reserved=\");\n+        output.shouldContain(\"Test (reserved=0KB, committed=0KB)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocStressTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,3 +35,0 @@\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.JDKToolFinder;\n@@ -43,1 +40,0 @@\n-    OutputAnalyzer output;\n@@ -46,4 +42,0 @@\n-    \/\/ Grab my own PID\n-    String pid = Long.toString(ProcessTools.getProcessId());\n-    ProcessBuilder pb = new ProcessBuilder();\n-\n@@ -51,5 +43,10 @@\n-    long memAlloc3 = wb.NMTMalloc(128 * 1024);\n-    long memAlloc2 = wb.NMTMalloc(256 * 1024);\n-    wb.NMTFree(memAlloc3);\n-    long memAlloc1 = wb.NMTMalloc(512 * 1024);\n-    wb.NMTFree(memAlloc2);\n+    long memAlloc3 = wb.NMTMalloc(128 * 1024);  \/\/ current +128K #1 peak +128K #1\n+    long memAlloc2 = wb.NMTMalloc(256 * 1024);  \/\/ current +384K #2 peak +384K #2\n+\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[]{\"Test (reserved=384KB, committed=384KB)\",\n+                         \"(malloc=384KB #2) (at peak)\"});\n+\n+    wb.NMTFree(memAlloc3);                           \/\/ current +256K #1 peak +384K #2\n+    long memAlloc1 = wb.NMTMalloc(512 * 1024);  \/\/ current +768K #2 peak +768K #2\n+    wb.NMTFree(memAlloc2);                           \/\/ current +512K #1 peak +768K #2\n@@ -57,4 +54,3 @@\n-    \/\/ Run 'jcmd <pid> VM.native_memory summary'\n-    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\"});\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=512KB, committed=512KB)\");\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[]{\"Test (reserved=512KB, committed=512KB)\",\n+                         \"(malloc=512KB #1) (peak=768KB #2)\"});\n@@ -63,1 +59,1 @@\n-    wb.NMTFree(memAlloc1);\n+    wb.NMTFree(memAlloc1); \/\/ current 0K #0 peak +768K #2\n@@ -65,2 +61,3 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldNotContain(\"Test (reserved=\");\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[]{\"Test (reserved=0KB, committed=0KB)\",\n+                         \"(malloc=0KB) (peak=768KB #2)\"});\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocTestType.java","additions":17,"deletions":20,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail MallocTrackingVerify\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=summary MallocTrackingVerify\n@@ -56,5 +56,0 @@\n-        OutputAnalyzer output;\n-\n-        \/\/ Grab my own PID\n-        String pid = Long.toString(ProcessTools.getProcessId());\n-        ProcessBuilder pb = new ProcessBuilder();\n@@ -77,3 +72,4 @@\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\" });\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4KB, committed=4KB)\");\n+        NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+                \"Test (reserved=4KB, committed=4KB)\",\n+                \"(malloc=4KB #\" + mallocd_memory.size() + \") (at peak)\"\n+        );\n@@ -87,4 +83,5 @@\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid,\n-                \"VM.native_memory\", \"summary\" });\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldNotContain(\"Test (reserved=\");\n+        NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+                \"Test (reserved=0KB, committed=0KB)\",\n+                \"(malloc=0KB) (peak=4KB #\" + + mallocd_memory.size() + \")\"\n+        );\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocTrackingVerify.java","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NMTTestUtils {\n+\n+    public static OutputAnalyzer startJcmdVMNativeMemory(String... additional_args) throws Exception {\n+        if (additional_args == null) {\n+            additional_args = new String[] {};\n+        }\n+        String fullargs[] = new String[3 + additional_args.length];\n+        fullargs[0] = JDKToolFinder.getJDKTool(\"jcmd\");\n+        fullargs[1] = Long.toString(ProcessTools.getProcessId());\n+        fullargs[2] = \"VM.native_memory\";\n+        System.arraycopy(additional_args, 0, fullargs, 3, additional_args.length);\n+        ProcessBuilder pb = new ProcessBuilder();\n+        pb.command(fullargs);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        return output;\n+    }\n+\n+    public static OutputAnalyzer startJcmdVMNativeMemoryDetail(String... additional_args) throws Exception {\n+        return startJcmdVMNativeMemory(\"detail\");\n+    }\n+\n+    public static void runJcmdSummaryReportAndCheckOutput(String[] additional_args, String[] pattern, boolean verbose) throws Exception {\n+        OutputAnalyzer output = startJcmdVMNativeMemory(additional_args);\n+        output.stdoutShouldContainMultiLinePattern(pattern, true);\n+    }\n+\n+    public static void runJcmdSummaryReportAndCheckOutput(String[] additional_args, String[] pattern) throws Exception {\n+        runJcmdSummaryReportAndCheckOutput(additional_args, pattern, true);\n+    }\n+\n+    public static void runJcmdSummaryReportAndCheckOutput(String... pattern) throws Exception {\n+        runJcmdSummaryReportAndCheckOutput(null, pattern, true);\n+    }\n+\n+    public static void checkReservedCommittedSummary(OutputAnalyzer output, long reservedKB, long committedKB, long peakKB) {\n+        String peakString = (committedKB == peakKB) ? \"at peak\" : \"peak=\" + peakKB + \"KB\";\n+        output.stdoutShouldContainMultiLinePattern(\n+                \"Test (reserved=\" + reservedKB + \"KB, committed=\" + committedKB + \"KB)\",\n+                \"(mmap: reserved=\" + reservedKB + \"KB, committed=\" + committedKB + \"KB, \" + peakString + \")\"\n+        );\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTTestUtils.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail ThreadedMallocTestType\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=summary ThreadedMallocTestType\n@@ -34,3 +34,0 @@\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.JDKToolFinder;\n@@ -45,1 +42,0 @@\n-    OutputAnalyzer output;\n@@ -48,4 +44,0 @@\n-    \/\/ Grab my own PID\n-    String pid = Long.toString(ProcessTools.getProcessId());\n-    ProcessBuilder pb = new ProcessBuilder();\n-\n@@ -69,3 +61,4 @@\n-    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\"});\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=896KB, committed=896KB)\");\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            \"Test (reserved=896KB, committed=896KB)\",\n+            \"(malloc=896KB #3) (at peak)\"\n+    );\n@@ -85,2 +78,4 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldNotContain(\"Test (reserved=\");\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            \"Test (reserved=0KB, committed=0KB)\",\n+            \"(malloc=0KB) (peak=896KB #3)\"\n+    );\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/ThreadedMallocTestType.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.test.lib.process.ProcessTools;\n@@ -36,1 +35,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -48,2 +46,0 @@\n-    String pid = Long.toString(ProcessTools.getProcessId());\n-    ProcessBuilder pb = new ProcessBuilder();\n@@ -59,3 +55,2 @@\n-    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"detail\"});\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=512KB, committed=0KB)\");\n+    output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+    checkReservedCommittedSummary(output,512, 0);\n@@ -72,2 +67,2 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=512KB, committed=128KB)\");\n+    output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+    checkReservedCommittedSummary(output,512, 128);\n@@ -84,1 +79,2 @@\n-    output = new OutputAnalyzer(pb.start());\n+    output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+    checkReservedCommittedSummary(output,512, 0);\n@@ -96,2 +92,2 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldNotContain(\"Test (reserved=\");\n+    output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+    checkReservedCommittedSummary(output,0, 0);\n@@ -101,0 +97,9 @@\n+  static long peakKB = 0;\n+\n+  public static void checkReservedCommittedSummary(OutputAnalyzer output, long reservedKB, long committedKB) {\n+    if (committedKB > peakKB) {\n+      peakKB = committedKB;\n+    }\n+    NMTTestUtils.checkReservedCommittedSummary(output, reservedKB, committedKB, peakKB);\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/ThreadedVirtualAllocTestType.java","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.test.lib.process.ProcessTools;\n@@ -41,1 +40,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -56,3 +54,0 @@\n-        String pid = Long.toString(ProcessTools.getProcessId());\n-        ProcessBuilder pb = new ProcessBuilder();\n-\n@@ -61,5 +56,2 @@\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid,\n-                \"VM.native_memory\", \"detail\" });\n-\n-        output = new OutputAnalyzer(pb.start());\n-        checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+        output = NMTTestUtils.startJcmdVMNativeMemory(\"detail\");\n+        checkReservedCommittedSummary(output, 4096, 0);\n@@ -78,2 +70,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -87,2 +79,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -96,2 +88,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -104,2 +96,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -113,2 +105,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -124,2 +116,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -137,2 +129,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -147,2 +139,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"256KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 256);\n@@ -157,2 +149,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -166,2 +158,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"256KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 256);\n@@ -176,2 +168,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -186,2 +178,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -197,2 +189,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -207,2 +199,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -218,2 +210,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -228,2 +220,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -239,2 +231,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -249,2 +241,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -260,2 +252,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -270,2 +262,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -281,2 +273,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -291,2 +283,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -302,2 +294,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -308,2 +300,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldNotContain(\"Test (reserved=\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 0, 0);\n@@ -314,2 +306,8 @@\n-    public static void checkReservedCommittedSummary(OutputAnalyzer output, String reservedString, String committedString) {\n-        output.shouldContain(\"Test (reserved=\" + reservedString + \", committed=\" + committedString + \")\");\n+    \/\/ running peak counter\n+    static long peakKB = 0;\n+\n+    public static void checkReservedCommittedSummary(OutputAnalyzer output, long reservedKB, long committedKB) {\n+        if (committedKB > peakKB) {\n+            peakKB = committedKB;\n+        }\n+        NMTTestUtils.checkReservedCommittedSummary(output, reservedKB, committedKB, peakKB);\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/VirtualAllocCommitMerge.java","additions":58,"deletions":60,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.test.lib.process.ProcessTools;\n@@ -38,2 +37,0 @@\n-import jdk.test.lib.JDKToolFinder;\n-\n@@ -52,3 +49,0 @@\n-        String pid = Long.toString(ProcessTools.getProcessId());\n-        ProcessBuilder pb = new ProcessBuilder();\n-\n@@ -57,5 +51,2 @@\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid,\n-                \"VM.native_memory\", \"detail\" });\n-\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4096KB, committed=0KB)\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 4096, 0);\n@@ -79,2 +70,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4096KB, committed=512KB)\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 4096, 512);\n@@ -89,3 +80,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4096KB, committed=256KB)\");\n-\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 4096, 256);\n@@ -100,2 +90,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4096KB, committed=512KB)\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 4096, 512);\n@@ -109,2 +99,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4096KB, committed=384KB)\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 4096, 384);\n@@ -120,2 +110,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4096KB, committed=768KB)\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 4096, 768);\n@@ -134,2 +124,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4096KB, committed=0KB)\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 4096, 0);\n@@ -142,2 +132,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldNotContain(\"Test (reserved=\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 0, 0);\n@@ -147,0 +137,10 @@\n+\n+    \/\/ running peak counter\n+    static long peakKB = 0;\n+\n+    public static void checkReservedCommittedSummary(OutputAnalyzer output, long reservedKB, long committedKB) {\n+        if (committedKB > peakKB) {\n+            peakKB = committedKB;\n+        }\n+        NMTTestUtils.checkReservedCommittedSummary(output, reservedKB, committedKB, peakKB);\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/VirtualAllocCommitUncommitRecommit.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.test.lib.process.ProcessTools;\n@@ -37,1 +36,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -47,1 +45,1 @@\n-    long addr;\n+    long addr1, addr2;\n@@ -49,2 +47,1 @@\n-    String pid = Long.toString(ProcessTools.getProcessId());\n-    ProcessBuilder pb = new ProcessBuilder();\n+    String info = \"start\";\n@@ -52,2 +49,5 @@\n-    addr = wb.NMTReserveMemory(reserveSize);\n-    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"detail\"});\n+    try {\n+      \/\/ ------\n+      \/\/ Reserve first mapping\n+      addr1 = wb.NMTReserveMemory(reserveSize);\n+      info = \"reserve 1: addr1=\" + addr1;\n@@ -55,3 +55,3 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=256KB, committed=0KB)\");\n-    output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr) + \" - 0x[0]*\" + Long.toHexString(addr + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 256, 0);\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n@@ -59,1 +59,4 @@\n-    wb.NMTCommitMemory(addr, commitSize);\n+      \/\/ ------\n+      \/\/ Reserve second mapping\n+      addr2 = wb.NMTReserveMemory(reserveSize);\n+      info = \"reserve 2: addr2=\" + addr2;\n@@ -61,0 +64,7 @@\n+      \/\/ If the second mapping happens to be adjacent to the first mapping, reserve another mapping and release the second mapping; for\n+      \/\/ this test, we want to see two disjunct mappings.\n+      if (addr2 == addr1 + reserveSize) {\n+        long tmp = wb.NMTReserveMemory(reserveSize);\n+        wb.NMTReleaseMemory(addr2, reserveSize);\n+        addr2 = tmp;\n+      }\n@@ -62,3 +72,4 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=256KB, committed=128KB)\");\n-    output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr) + \" - 0x[0]*\" + Long.toHexString(addr + commitSize) + \"\\\\] committed 128KB\");\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 512, 0);\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n@@ -66,1 +77,4 @@\n-    wb.NMTUncommitMemory(addr, commitSize);\n+      \/\/ ------\n+      \/\/ Now commit the first mapping\n+      wb.NMTCommitMemory(addr1, commitSize);\n+      info = \"commit 1\";\n@@ -68,0 +82,5 @@\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 512, 128);\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + commitSize) + \"\\\\] committed 128KB\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n@@ -69,3 +88,4 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=256KB, committed=0KB)\");\n-    output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr) + \" - 0x[0]*\" + Long.toHexString(addr + commitSize) + \"\\\\] committed\");\n+      \/\/ ------\n+      \/\/ Now commit the second mapping\n+      wb.NMTCommitMemory(addr2, commitSize);\n+      info = \"commit 2\";\n@@ -73,1 +93,6 @@\n-    wb.NMTReleaseMemory(addr, reserveSize);\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 512, 256);\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + commitSize) + \"\\\\] committed 128KB\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + commitSize) + \"\\\\] committed 128KB\");\n@@ -75,3 +100,60 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldNotContain(\"Test (reserved=\");\n-    output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr) + \" - 0x[0]*\" + Long.toHexString(addr + reserveSize) + \"\\\\] reserved\");\n+      \/\/ ------\n+      \/\/ Now uncommit the second mapping\n+      wb.NMTUncommitMemory(addr2, commitSize);\n+      info = \"uncommit 2\";\n+\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 512, 128);\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + commitSize) + \"\\\\] committed 128KB\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + commitSize) + \"\\\\] committed 128KB\");\n+\n+      \/\/ ------\n+      \/\/ Now uncommit the first mapping\n+      wb.NMTUncommitMemory(addr1, commitSize);\n+      info = \"uncommit 1\";\n+\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 512, 0);\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + commitSize) + \"\\\\] committed 128KB\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + commitSize) + \"\\\\] committed 128KB\");\n+\n+      \/\/ ----------\n+      \/\/ Release second mapping\n+      wb.NMTReleaseMemory(addr2, reserveSize);\n+      info = \"release 2\";\n+\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 256, 0);\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + commitSize) + \"\\\\] committed 128KB\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + commitSize) + \"\\\\] committed 128KB\");\n+\n+      \/\/ ----------\n+      \/\/ Release first mapping\n+      wb.NMTReleaseMemory(addr1, reserveSize);\n+      info = \"release 1\";\n+\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 0, 0);\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + commitSize) + \"\\\\] committed 128KB\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + commitSize) + \"\\\\] committed 128KB\");\n+\n+    } catch (Exception e) {\n+      throw new RuntimeException(e.getMessage() + \" (\" + info + \")\");\n+    }\n+  }\n+\n+  static long peakKB = 0;\n+\n+  public static void checkReservedCommittedSummary(OutputAnalyzer output, long reservedKB, long committedKB) {\n+    if (committedKB > peakKB) {\n+      peakKB = committedKB;\n+    }\n+    NMTTestUtils.checkReservedCommittedSummary(output, reservedKB, committedKB, peakKB);\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/VirtualAllocTestType.java","additions":104,"deletions":22,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -624,0 +624,8 @@\n+    public List<String> stdoutAsLines() {\n+        return asLines(getStdout());\n+    }\n+\n+    public List<String> stderrAsLines() {\n+        return asLines(getStderr());\n+    }\n+\n@@ -789,0 +797,68 @@\n+    private void searchLinesForMultiLinePattern(String[] haystack, String[] needles, boolean verbose) {\n+\n+        if (needles.length == 0) {\n+            return;\n+        }\n+\n+        int firstNeedlePos = 0;\n+        for (int i = 0; i < haystack.length; i++) {\n+            if (verbose) {\n+                System.out.println(\"\" + i + \":\" + haystack[i]);\n+            }\n+            if (haystack[i].contains(needles[0])) {\n+                if (verbose) {\n+                    System.out.println(\"Matches pattern 0 (\\\"\" + needles[0] + \"\\\")\");\n+                }\n+                firstNeedlePos = i;\n+                break;\n+            }\n+        }\n+\n+        for (int i = 1; i < needles.length; i++) {\n+            int haystackPos = firstNeedlePos + i;\n+            if (haystackPos < haystack.length) {\n+                if (verbose) {\n+                    System.out.println(\"\" + haystackPos + \":\" + haystack[haystackPos]);\n+                }\n+                if (haystack[haystackPos].contains(needles[i])) {\n+                    if (verbose) {\n+                        System.out.println(\"Matches pattern \" + i  + \"(\\\"\" + needles[i] + \"\\\")\");\n+                    }\n+                } else {\n+                    String err = \"First unmatched pattern: \" + i + \" (\\\"\" + needles[i] + \"\\\")\";\n+                    if (!verbose) { \/\/ don't print twice\n+                        reportDiagnosticSummary();\n+                    }\n+                    throw new RuntimeException(err);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void stdoutShouldContainMultiLinePattern(String[] needles, boolean verbose) {\n+        String [] stdoutLines = stdoutAsLines().toArray(new String[0]);\n+        searchLinesForMultiLinePattern(stdoutLines, needles, verbose);\n+    }\n+\n+    public void stdoutShouldContainMultiLinePattern(String... needles) {\n+        stdoutShouldContainMultiLinePattern(needles, true);\n+    }\n+\n+    public void stderrShouldContainMultiLinePattern(String[] needles, boolean verbose) {\n+        String [] stderrLines = stdoutAsLines().toArray(new String[0]);\n+        searchLinesForMultiLinePattern(stderrLines, needles, verbose);\n+    }\n+\n+    public void stderrShouldContainMultiLinePattern(String... needles) {\n+        stderrShouldContainMultiLinePattern(needles, true);\n+    }\n+\n+    public void shouldContainMultiLinePattern(String[] needles, boolean verbose) {\n+        String [] lines = asLines().toArray(new String[0]);\n+        searchLinesForMultiLinePattern(lines, needles, verbose);\n+    }\n+\n+    public void shouldContainMultiLinePattern(String... needles) {\n+        shouldContainMultiLinePattern(needles, true);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputAnalyzer.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"}]}