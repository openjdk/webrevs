{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,1 @@\n- * an array of {@code Method} objects that include all of the\n+ * an array of {@code Method} objects that include all of the public non-static\n@@ -168,2 +168,3 @@\n- * the proxy interfaces. Specifically, the package and the module membership\n- * of a proxy class defined via the\n+ * the proxy interfaces and all classes and interfaces referenced by signatures\n+ * of all public non-static methods from the proxy interfaces. Specifically, the\n+ * package and the module membership of a proxy class defined via the\n@@ -175,2 +176,10 @@\n- * <li>If all the proxy interfaces are in <em>exported<\/em> or <em>open<\/em>\n- *     packages:\n+ * <li>If some of these classes and interfaces are <em>non-public<\/em>, all\n+ *     non-public classes and interfaces must be in the same package and module,\n+ *     and that module must be able to access all public classes, some of which\n+ *     may be in <em>non-exported<\/em> and <em>non-open<\/em> packages.\n+ *     Otherwise, proxying is {@linkplain ##restrictions not possible}.\n+ *     The proxy class is <em>non-public<\/em> in the same package and module as\n+ *     the non-public classes and interfaces.\n+ *     <\/li>\n+ * <li>Otherwise, all these classes and interfaces are <em>public<\/em>, and all\n+ *     proxy interfaces are public.\n@@ -178,15 +187,8 @@\n- * <li>if all the proxy interfaces are <em>public<\/em>, then the proxy class is\n- *     <em>public<\/em> in an unconditionally exported but non-open package.\n- *     The name of the package and the module are unspecified.<\/li>\n- *\n- * <li>if at least one of all the proxy interfaces is <em>non-public<\/em>, then\n- *     the proxy class is <em>non-public<\/em> in the package and module of the\n- *     non-public interfaces. All the non-public interfaces must be in the same\n- *     package and module; otherwise, proxying them is\n- *     <a href=\"#restrictions\">not possible<\/a>.<\/li>\n- * <\/ol>\n- * <\/li>\n- * <li>If at least one proxy interface is in a package that is\n- *     <em>non-exported<\/em> and <em>non-open<\/em>:\n- * <ol type=\"a\">\n- * <li>if all the proxy interfaces are <em>public<\/em>, then the proxy class is\n+ * <li>If all proxy interfaces are in <em>exported<\/em> or <em>open<\/em>\n+ *     packages, the proxy class is <em>public<\/em> in an unconditionally\n+ *     exported but non-open package in a {@linkplain ##dynamicmodule\n+ *     <em>dynamic module<\/em>}. The names of the package and the module are\n+ *     unspecified. (In this case, any of the referenced class or interface that\n+ *     is not a proxied interface may be non-exported and non-open.)<\/li>\n+ * <li>Otherwise, at least one of the proxy interfaces is in a package that is\n+ *     <em>non-exported<\/em> and <em>non-open<\/em>, and the proxy class is\n@@ -194,8 +196,2 @@\n- *     <a href=\"#dynamicmodule\"><em>dynamic module<\/em>.<\/a>\n- *     The names of the package and the module are unspecified.<\/li>\n- *\n- * <li>if at least one of all the proxy interfaces is <em>non-public<\/em>, then\n- *     the proxy class is <em>non-public<\/em> in the package and module of the\n- *     non-public interfaces. All the non-public interfaces must be in the same\n- *     package and module; otherwise, proxying them is\n- *     <a href=\"#restrictions\">not possible<\/a>.<\/li>\n+ *     a {@linkplain ##dynamicmodule <em>dynamic module<\/em>}. The names of the\n+ *     package and the module are unspecified.<\/li>\n@@ -547,1 +543,1 @@\n-            Objects.requireNonNull(interfaces);\n+            Objects.requireNonNull(interfaces); \/\/ trusted immutable list\n@@ -557,1 +553,1 @@\n-            Set<Class<?>> refTypes = referencedTypes(loader, interfaces);\n+            Set<Class<?>> refTypes = referencedTypes(interfaces);\n@@ -619,6 +615,0 @@\n-                \/*\n-                 * Verify that the class loader resolves the name of this\n-                 * interface to the same Class object.\n-                 *\/\n-                ensureVisible(loader, intf);\n-\n@@ -634,0 +624,5 @@\n+                \/*\n+                 * Verify that the class loader resolves the name of a class or\n+                 * interface that appear in descriptors to the desired Class object,\n+                 * or the name of implemented interfaces.\n+                 *\/\n@@ -640,1 +635,2 @@\n-         * the proxy interfaces\n+         * the proxy interfaces and the interface themselves. Required to ensure\n+         * the generated class files have no format errors.\n@@ -642,3 +638,2 @@\n-        private static Set<Class<?>> referencedTypes(ClassLoader loader,\n-                                                     List<Class<?>> interfaces) {\n-            var types = new HashSet<Class<?>>();\n+        private static Set<Class<?>> referencedTypes(List<Class<?>> interfaces) {\n+            var types = new HashSet<>(interfaces);\n@@ -674,4 +669,2 @@\n-         * module and the package it belongs to and whether it is package-private.\n-         *\n-         * If any of proxy interface is package-private, then the proxy class\n-         * is in the same package and module as the package-private interface.\n+         * module and the package it belongs to and whether it is\n+         * package-private.\n@@ -679,3 +672,7 @@\n-         * If all proxy interfaces are public and in exported packages,\n-         * then the proxy class is in a dynamic module in an unconditionally\n-         * exported package.\n+         * If any of the referenced types is package-private, then the proxy\n+         * class is in the same package and module as the package-private type.\n+         * Validation is performed to ensure the package-private types specify\n+         * exactly one package and module, and ensures accessibility.\n+         * In particular, if all proxy interfaces are public but some proxy\n+         * method refers to a package-private type, package access is required\n+         * to interact with such a type in class files.\n@@ -683,3 +680,11 @@\n-         * If all proxy interfaces are public and at least one in a non-exported\n-         * package, then the proxy class is in a dynamic module in a\n-         * non-exported package.\n+         * Otherwise, all proxy interfaces are public, and the proxy class is in\n+         * a dynamic module. Reads edge and qualified exports are added for\n+         * dynamic module to access.\n+         * 1. If proxy interfaces are all in exported packages, then the proxy\n+         *    class is in an unconditionally exported package. This is safe even\n+         *    if some referenced type is public in a non-exported package per\n+         *    Java access control, as no additional method is exposed.\n+         * 2. Otherwise, at least one in a non-exported package, then the proxy\n+         *    class is in a non-exported package. This ensures that public\n+         *    methods from non-exported packages won't be accessible on the\n+         *    returned proxy.\n@@ -687,3 +692,2 @@\n-         * The package of proxy class is open to java.base for deep reflective access.\n-         *\n-         * Reads edge and qualified exports are added for dynamic module to access.\n+         * The package of proxy class is open to java.base for deep reflective\n+         * access for implementation support.\n@@ -694,2 +698,1 @@\n-            Map<Class<?>, Module> packagePrivateTypes = new HashMap<>();\n-            boolean nonExported = false;\n+            Class<?> packagePrivateTarget = null;\n@@ -697,8 +700,22 @@\n-            for (Class<?> intf : interfaces) {\n-                Module m = intf.getModule();\n-                if (!Modifier.isPublic(intf.getModifiers())) {\n-                    packagePrivateTypes.put(intf, m);\n-                } else {\n-                    if (!intf.getModule().isExported(intf.getPackageName())) {\n-                        \/\/ module-private types\n-                        nonExported = true;\n+            for (Class<?> type : refTypes) {\n+                if (!Modifier.isPublic(type.getModifiers())) {\n+                    var m = type.getModule();\n+                    if (packagePrivateTarget == null) {\n+                        packagePrivateTarget = type;\n+\n+                        if (m.getClassLoader() != loader) {\n+                            \/\/ the specified loader is not the same class loader\n+                            \/\/ of the non-public interface\n+                            throw new IllegalArgumentException(\n+                                    \"non-public interface is not defined by the given loader\");\n+                        }\n+                    } else {\n+                        \/\/ all package-private types must be in the same runtime package\n+                        \/\/ i.e. same package name and same module (named or unnamed)\n+                        \/\/ Same module implies same loader, then the same interned package name is\n+                        \/\/ sufficient to ensure the run-time package is the same\n+                        if ((packagePrivateTarget.getModule() != m) ||\n+                            (packagePrivateTarget.getPackageName() != type.getPackageName())) {\n+                            throw new IllegalArgumentException(\n+                                    \"cannot have non-public interfaces in different packages\");\n+                        }\n@@ -709,26 +726,3 @@\n-            if (packagePrivateTypes.size() > 0) {\n-                \/\/ all package-private types must be in the same runtime package\n-                \/\/ i.e. same package name and same module (named or unnamed)\n-                \/\/\n-                \/\/ Configuration will fail if M1 and in M2 defined by the same loader\n-                \/\/ and both have the same package p (so no need to check class loader)\n-                Module targetModule = null;\n-                String targetPackageName = null;\n-                for (Map.Entry<Class<?>, Module> e : packagePrivateTypes.entrySet()) {\n-                    Class<?> intf = e.getKey();\n-                    Module m = e.getValue();\n-                    if ((targetModule != null && targetModule != m) ||\n-                        (targetPackageName != null && targetPackageName != intf.getPackageName())) {\n-                        throw new IllegalArgumentException(\n-                                \"cannot have non-public interfaces in different packages\");\n-                    }\n-                    if (m.getClassLoader() != loader) {\n-                        \/\/ the specified loader is not the same class loader\n-                        \/\/ of the non-public interface\n-                        throw new IllegalArgumentException(\n-                                \"non-public interface is not defined by the given loader\");\n-                    }\n-\n-                    targetModule = m;\n-                    targetPackageName = e.getKey().getPackageName();\n-                }\n+            if (packagePrivateTarget != null) {\n+                Module targetModule = packagePrivateTarget.getModule();\n+                String targetPackageName = packagePrivateTarget.getPackageName();\n@@ -736,3 +730,3 @@\n-                \/\/ validate if the target module can access all other interfaces\n-                for (Class<?> intf : interfaces) {\n-                    Module m = intf.getModule();\n+                \/\/ validate if the target module can access all other referenced types\n+                for (Class<?> type : refTypes) {\n+                    Module m = type.getModule();\n@@ -741,2 +735,2 @@\n-                    if (!targetModule.canRead(m) || !m.isExported(intf.getPackageName(), targetModule)) {\n-                        throw new IllegalArgumentException(targetModule + \" can't access \" + intf.getName());\n+                    if (!targetModule.canRead(m) || !m.isExported(type.getPackageName(), targetModule)) {\n+                        throw new IllegalArgumentException(targetModule + \" can't access \" + type.getName());\n@@ -754,0 +748,8 @@\n+            boolean nonExported = false;\n+            for (var intf : interfaces) {\n+                if (!intf.getModule().isExported(intf.getPackageName())) {\n+                    \/\/ module-private types\n+                    nonExported = true;\n+                }\n+            }\n+\n@@ -760,3 +762,1 @@\n-            Set<Class<?>> types = new HashSet<>(interfaces);\n-            types.addAll(refTypes);\n-            for (Class<?> c : types) {\n+            for (Class<?> c : refTypes) {\n@@ -870,6 +870,6 @@\n-     * <li>All non-public interfaces must be in the same package\n-     * and module, defined by the specified class loader and\n-     * the module of the non-public interfaces can access all of\n-     * the interface types; otherwise, it would not be possible for\n-     * the proxy class to implement all of the interfaces,\n-     * regardless of what package it is defined in.\n+     * <li>All non-public interfaces and all non-public classes and interfaces\n+     * referenced by all public non-static method signatures must be in the same\n+     * package and module, defined by the specified class loader and can access\n+     * all of the interfaces and the referenced classes and interfaces; otherwise,\n+     * it would not be possible for the proxy class to implement all of the\n+     * interfaces, regardless of what package it is defined in.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":104,"deletions":104,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349716\n+ * @summary Test behaviors with public annotations that have elements of package\n+ *          private accessibility\n+ * @library \/test\/lib\n+ * @run junit WithPackagePrivateTest\n+ *\/\n+\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * Test public annotations that have elements of package-private types.\n+ *\/\n+@WithPackagePrivateTest.InaccessibleElement(WithPackagePrivateTest.MySecretEnum.FIRST)\n+@WithPackagePrivateTest.InaccessibleElement(WithPackagePrivateTest.MySecretEnum.SECOND)\n+@WithPackagePrivateTest.InaccessibleElement(WithPackagePrivateTest.MySecretEnum.THIRD)\n+@WithPackagePrivateTest.DummyPublicAnnotation(WithPackagePrivateTest.MySecretEnum.FIRST)\n+class WithPackagePrivateTest {\n+\n+    \/\/ element of array of package-private interface\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface InaccessibleContainer {\n+        InaccessibleElement[] value();\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Repeatable(InaccessibleContainer.class)\n+    @interface InaccessibleElement {\n+        MySecretEnum value();\n+    }\n+\n+    \/\/ element of package-private (enum) class\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface DummyPublicAnnotation {\n+        MySecretEnum value();\n+    }\n+\n+    \/**\n+     * A package-private enum. Annotation member implementations must be able to\n+     * access this enum.\n+     *\/\n+    enum MySecretEnum {\n+        FIRST,\n+        SECOND,\n+        THIRD\n+    }\n+\n+    \/**\n+     * Ensures the elements work for public\/package-private annotation interfaces\n+     * with elements of package-private types.\n+     *\/\n+    @Test\n+    void testElements() {\n+        var container = WithPackagePrivateTest.class.getDeclaredAnnotation(InaccessibleContainer.class);\n+        assertEquals(List.of(MySecretEnum.FIRST, MySecretEnum.SECOND, MySecretEnum.THIRD),\n+                     Arrays.stream(container.value()).map(InaccessibleElement::value).toList());\n+        var dummyPublic = WithPackagePrivateTest.class.getDeclaredAnnotation(DummyPublicAnnotation.class);\n+        assertSame(MySecretEnum.FIRST, dummyPublic.value());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/annotation\/WithPackagePrivateTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8333854\n+ * @bug 8333854 8349716\n@@ -33,0 +33,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -36,1 +38,1 @@\n-import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -47,0 +49,4 @@\n+    public interface PublicWorkerFactory {\n+        NonPublicWorker provide();\n+    }\n+\n@@ -48,1 +54,1 @@\n-    public void test() {\n+    public void passParameter() {\n@@ -53,4 +59,0 @@\n-        assertNotSame(NonPublicWorker.class.getPackage(),\n-                proxy.getClass().getPackage(),\n-                \"Proxy class should not be able to access method parameter \" +\n-                        \"NonPublic type's package\");\n@@ -59,0 +61,23 @@\n+\n+    @Test\n+    public void obtainReturn() {\n+        PublicWorkerFactory proxy = (PublicWorkerFactory) Proxy.newProxyInstance(\n+               NonPublicMethodTypeTest.class.getClassLoader(),\n+               new Class[] {PublicWorkerFactory.class},\n+               (_, _, _) -> (NonPublicWorker) () -> {});\n+        assertNotNull(proxy.provide()); \/\/ Call should not fail\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(classes = {PublicWorkable.class, PublicWorkerFactory.class})\n+    public void inspectReflectively(Class<?> intf) {\n+        var proxy = Proxy.newProxyInstance(\n+                NonPublicMethodTypeTest.class.getClassLoader(),\n+                new Class[] {intf},\n+                (_, _, _) -> null);\n+\n+        assertSame(NonPublicWorker.class.getPackage(),\n+                   proxy.getClass().getPackage(),\n+                   \"Proxy class must be able to access method parameter \" +\n+                           \"NonPublic type's package\");\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/NonPublicMethodTypeTest.java","additions":33,"deletions":8,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+ * @bug 8349716\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyClassAccessTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+    exports p.two.alt;\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m2\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,4 @@\n-interface B {\n+\/\/ Package-private interface, exposed in public methods.\n+\/\/ Has publicly accessible supertype and subtype for\n+\/\/ proxy public method usage.\n+interface B extends Cloneable {\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m2\/p\/two\/B.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-public class Bar {\n+public class Bar implements B {\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m2\/p\/two\/Bar.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p.two;\n+\n+\/**\n+ * A public interface with package-private types in signatures.\n+ * In the language, external code cannot access package-private\n+ * types unless passing a public subtypes or null, or using an\n+ * instance as one of its supertype (such as Object).\n+ *\/\n+public interface WithPackageReference {\n+    \/\/ For example, this call type can be converted to\n+    \/\/ (Bar) => Cloneable\n+    B process(B input);\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m2\/p\/two\/WithPackageReference.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p.two.alt;\n+\n+\/**\n+ * Used in combination with WithPackageReference to test rejection\n+ * behavior.\n+ *\/\n+public interface AltPackageReference extends PackageInterface {\n+    void process(PackageInterface input);\n+}\n+\n+interface PackageInterface {}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m2\/p\/two\/alt\/AltPackageReference.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import p.two.WithPackageReference;\n+import p.two.alt.AltPackageReference;\n@@ -46,0 +48,1 @@\n+        testProxyWithNonPublicInSignature();\n@@ -98,0 +101,26 @@\n+    static void testProxyWithNonPublicInSignature() {\n+        var proxy = (WithPackageReference) Proxy.newProxyInstance(WithPackageReference.class.getClassLoader(),\n+                new Class<?>[]{WithPackageReference.class}, (_, _, args) -> args[0]);\n+        var bar = new Bar();\n+        Cloneable c = proxy.process(bar);\n+        if (c != bar) {\n+            throw new RuntimeException(\"Cannot call proxy method with non public type in signature successfully\");\n+        }\n+\n+        try {\n+            URLClassLoader loader = new URLClassLoader(new URL[0]);\n+            Proxy.newProxyInstance(loader, new Class<?>[]{WithPackageReference.class}, handler);\n+            throw new RuntimeException(\"IllegalArgumentException not thrown\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+\n+        assert WithPackageReference.class.getModule() == AltPackageReference.class.getModule();\n+        assert WithPackageReference.class.getPackage() != AltPackageReference.class.getPackage();\n+        try {\n+            Proxy.newProxyInstance(WithPackageReference.class.getClassLoader(),\n+                    new Class<?>[]{WithPackageReference.class, AltPackageReference.class}, handler);\n+            throw new RuntimeException(\"IllegalArgumentException not thrown\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/ProxyClassAccess.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"}]}