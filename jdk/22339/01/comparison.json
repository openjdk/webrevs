{"files":[{"patch":"@@ -850,0 +850,5 @@\n+                @Override\n+                public ByteBuffer allocateDirectTemporary(int cap) {\n+                    return new DirectByteBuffer(cap, true);\n+                }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,1 +42,3 @@\n-\n+#if[byte]\n+import jdk.internal.vm.annotation.Stable;\n+#end[byte]\n@@ -75,0 +77,2 @@\n+    private @Stable boolean temporary; \/\/ defaults to false\n+\n@@ -102,1 +106,1 @@\n-    Direct$Type$Buffer$RW$(int cap) {                   \/\/ package-private\n+    Direct$Type$Buffer$RW$(int cap, boolean temporary) { \/\/ package-private\n@@ -105,0 +109,1 @@\n+        this.temporary = temporary;\n@@ -108,1 +113,2 @@\n-        Bits.reserveMemory(size, cap);\n+        if (!temporary)\n+            Bits.reserveMemory(size, cap);\n@@ -114,1 +120,2 @@\n-            Bits.unreserveMemory(size, cap);\n+            if (!temporary)\n+                Bits.unreserveMemory(size, cap);\n@@ -124,7 +131,10 @@\n-        try {\n-            cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n-        } catch (Throwable t) {\n-            \/\/ Prevent leak if the Deallocator or Cleaner fail for any reason\n-            UNSAFE.freeMemory(base);\n-            Bits.unreserveMemory(size, cap);\n-            throw t;\n+        if (!temporary) {\n+            try {\n+                cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n+            } catch (Throwable t) {\n+                \/\/ Prevent leak if the Deallocator or Cleaner fail for any reason\n+                UNSAFE.freeMemory(base);\n+                throw t;\n+            }\n+        } else { \/\/ temporary\n+            cleaner = null;\n@@ -139,0 +149,4 @@\n+    Direct$Type$Buffer$RW$(int cap) { \/\/ package-private\n+        this(cap, false);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":25,"deletions":11,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -70,0 +70,5 @@\n+    \/**\n+     * Used by {@code sun.nio.ch.Util}.\n+     *\/\n+    ByteBuffer allocateDirectTemporary(int cap);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -44,0 +46,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -224,1 +228,1 @@\n-            return ByteBuffer.allocateDirect(size);\n+            return NIO_ACCESS.allocateDirectTemporary(size);\n@@ -239,1 +243,1 @@\n-            return ByteBuffer.allocateDirect(size);\n+            return NIO_ACCESS.allocateDirectTemporary(size);\n@@ -250,1 +254,1 @@\n-            return ByteBuffer.allocateDirect(size + alignment - 1)\n+            return NIO_ACCESS.allocateDirectTemporary(size + alignment - 1)\n@@ -266,1 +270,1 @@\n-        return ByteBuffer.allocateDirect(size + alignment - 1)\n+        return NIO_ACCESS.allocateDirectTemporary(size + alignment - 1)\n@@ -324,1 +328,1 @@\n-        ((DirectBuffer)buf).cleaner().clean();\n+        unsafe.freeMemory(((DirectBuffer)buf).address());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Util.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -72,3 +72,0 @@\n-\n-# Direct buffer memory allocated before test launch\n-java\/nio\/Buffer\/LimitDirectMemory.java 8342849 generic-all\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}