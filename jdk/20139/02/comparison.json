{"files":[{"patch":"@@ -471,0 +471,2 @@\n+  do_intrinsic(_Reference_clear0,           java_lang_ref_Reference, clear0_name,    void_method_signature, F_RN)       \\\n+  do_intrinsic(_PhantomReference_clear0,    java_lang_ref_PhantomReference, clear0_name, void_method_signature, F_RN)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -426,0 +426,1 @@\n+  template(clear0_name,                               \"clear0\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -664,0 +664,22 @@\n+Node* G1BarrierSetC2::store_at_resolved(C2Access& access, C2AccessValue& val) const {\n+  DecoratorSet decorators = access.decorators();\n+\n+  bool on_weak = (decorators & ON_WEAK_OOP_REF) != 0;\n+  bool on_phantom = (decorators & ON_PHANTOM_OOP_REF) != 0;\n+  bool no_keepalive = (decorators & AS_NO_KEEPALIVE) != 0;\n+\n+  if (access.is_parse_access()) {\n+    C2ParseAccess &parse_access = static_cast<C2ParseAccess &>(access);\n+    GraphKit* kit = parse_access.kit();\n+\n+    if ((val.node() == kit->null()) &&\n+        (on_weak || on_phantom) && no_keepalive) {\n+      \/\/ Be extra paranoid around this path. Only accept null stores,\n+      \/\/ otherwise we need a post-store barrier.\n+      return BarrierSetC2::store_at_resolved(access, val);\n+    }\n+  }\n+\n+  return CardTableBarrierSetC2::store_at_resolved(access, val);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+  virtual Node* store_at_resolved(C2Access& access, C2AccessValue& val) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -501,0 +501,4 @@\n+  bool on_weak = (decorators & ON_WEAK_OOP_REF) != 0;\n+  bool on_phantom = (decorators & ON_PHANTOM_OOP_REF) != 0;\n+  bool no_keepalive = (decorators & AS_NO_KEEPALIVE) != 0;\n+\n@@ -509,0 +513,7 @@\n+    if ((val.node() == kit->null()) &&\n+        ((on_weak || on_phantom) && no_keepalive)) {\n+      \/\/ Be extra paranoid around this path. Only accept null stores,\n+      \/\/ otherwise we need IU barrier.\n+      return BarrierSetC2::store_at_resolved(access, val);\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -766,0 +766,2 @@\n+  case vmIntrinsics::_Reference_clear0:\n+  case vmIntrinsics::_PhantomReference_clear0:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -579,0 +579,2 @@\n+  case vmIntrinsics::_Reference_clear0:         return inline_reference_clear0(false);\n+  case vmIntrinsics::_PhantomReference_clear0:  return inline_reference_clear0(true);\n@@ -6835,0 +6837,46 @@\n+\/\/----------------------------inline_reference_clear0----------------------------\n+\/\/ void java.lang.ref.Reference.clear0();\n+\/\/ void java.lang.ref.PhantomReference.clear0();\n+bool LibraryCallKit::inline_reference_clear0(bool is_phantom) {\n+  \/\/ This matches the implementation in JVM_ReferenceClear, see the comments there.\n+\n+  \/\/ Get arguments\n+  Node* reference_obj = null_check_receiver();\n+  if (stopped()) return true;\n+\n+  \/\/ Common access parameters\n+  DecoratorSet decorators = IN_HEAP | AS_NO_KEEPALIVE;\n+  decorators |= (is_phantom ? ON_PHANTOM_OOP_REF : ON_WEAK_OOP_REF);\n+  Node* referent_field_addr = basic_plus_adr(reference_obj, java_lang_ref_Reference::referent_offset());\n+  const TypePtr* referent_field_addr_type = _gvn.type(referent_field_addr)->isa_ptr();\n+  const Type* val_type = TypeOopPtr::make_from_klass(env()->Object_klass());\n+\n+  Node* referent = access_load_at(reference_obj,\n+                                  referent_field_addr,\n+                                  referent_field_addr_type,\n+                                  val_type,\n+                                  T_OBJECT,\n+                                  decorators);\n+\n+  IdealKit ideal(this);\n+#define __ ideal.\n+  __ if_then(referent, BoolTest::ne, null());\n+    sync_kit(ideal);\n+    access_store_at(reference_obj,\n+                    referent_field_addr,\n+                    referent_field_addr_type,\n+                    null(),\n+                    val_type,\n+                    T_OBJECT,\n+                    decorators);\n+    __ sync_kit(this);\n+  __ end_if();\n+  final_sync(ideal);\n+#undef __\n+\n+  \/\/ Add memory barrier to prevent commoning the accesses in this code,\n+  \/\/ since GC can change the value of referent at any time.\n+  insert_mem_bar(Op_MemBarCPUOrder);\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -297,0 +297,1 @@\n+  bool inline_reference_clear0(bool is_phantom);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,0 +80,13 @@\n+    \/* Override the implementation of Reference.clear.\n+     * Phantom references are weaker than finalization, so the referent\n+     * access needs to be handled differently for garbage collectors that\n+     * do reference processing concurrently.\n+     *\/\n+    @Override\n+    void clearImpl() {\n+        clear0();\n+    }\n+\n+    @IntrinsicCandidate\n+    private native void clear0();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -406,0 +406,9 @@\n+        clearImpl();\n+    }\n+\n+    \/* Implementation of clear(), overridden for phantom references.\n+     * This method exists only to avoid making clear0() virtual. Making\n+     * clear0() virtual has the undesirable effect of C2 often preferring\n+     * to call the native implementation over the intrinsic.\n+     *\/\n+    void clearImpl() {\n@@ -413,0 +422,1 @@\n+    @IntrinsicCandidate\n@@ -514,1 +524,1 @@\n-        clear0();               \/\/ Intentionally clear0() rather than clear()\n+        clearImpl(); \/\/ Intentionally clearImpl() to dispatch to overridden method, if needed\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,6 @@\n+\n+JNIEXPORT void JNICALL\n+Java_java_lang_ref_PhantomReference_clear0(JNIEnv *env, jobject ref)\n+{\n+    JVM_ReferenceClear(env, ref);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/PhantomReference.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.gc;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.whitebox.gc.GC;\n+\n+import java.lang.ref.*;\n+import java.util.*;\n+\n+\/*\n+ * @test\n+ * @bug 8329597\n+ * @summary Test that Reference.clear intrinsics are properly handled\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @requires vm.compiler2.enabled\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.c2.irTests.gc.ReferenceClearTests\n+\n+ *\/\n+public class ReferenceClearTests {\n+\n+    private static String[] args(String... add) {\n+        List<String> args = new ArrayList<>();\n+\n+         \/\/ Use PerMethodTrapLimit=0 to compile all branches in the intrinsics.\n+        args.add(\"-XX:PerMethodTrapLimit=0\");\n+\n+        \/\/ Forcefully inline all methods to reach the intrinsic code.\n+        args.add(\"-XX:CompileCommand=inline,compiler.c2.irTests.gc.ReferenceClearTests::*\");\n+        args.add(\"-XX:CompileCommand=inline,java.lang.ref.Reference::*\");\n+        args.add(\"-XX:CompileCommand=inline,java.lang.ref.PhantomReference::*\");\n+\n+        \/\/ Mix in test config code.\n+        args.addAll(Arrays.asList(add));\n+\n+        return args.toArray(new String[0]);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework();\n+\n+        int idx = 0;\n+        if (GC.isSelectedErgonomically() && GC.Serial.isSupported()) {\n+            \/\/ Serial does not have SATB\/keep-alive barriers at all.\n+            \/\/ There are inter-generational barriers on stores, but they are\n+            \/\/ folded away for null stores like clear().\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseSerialGC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.Parallel.isSupported()) {\n+            \/\/ Parallel does not have SATB\/keep-alive barriers at all.\n+            \/\/ There are inter-generational barriers on stores, but they\n+            \/\/ should be folded away for null stores like clear().\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseParallelGC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.G1.isSupported()) {\n+            \/\/ G1 has SATB\/keep-alive barriers, but they should not be present\n+            \/\/ for clear()-s. There are inter-generational barriers on stores,\n+            \/\/ but they should be folded away for null stores like clear().\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseG1GC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.Shenandoah.isSupported()) {\n+            \/\/ Shenandoah has SATB\/keep-alive barriers, but they should not be\n+            \/\/ present clear()-s. There are load-reference barriers, which would\n+            \/\/ confuse the tests, so we enable only SATB barriers.\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:ShenandoahGCMode=passive\",\n+                \"-XX:+ShenandoahSATBBarrier\",\n+                \"-XX:+UseShenandoahGC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.Z.isSupported()) {\n+            \/\/ Z does not have barriers in C2 IR.\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseZGC\"\n+            )));\n+        }\n+        framework.start();\n+    }\n+\n+    static final Object REF = new Object();\n+\n+    static final SoftReference<Object> SR = new SoftReference<>(REF);\n+    static final WeakReference<Object> WR = new WeakReference<>(REF);\n+    static final PhantomReference<Object> PR = new PhantomReference<>(REF, null);\n+\n+    \/\/ We assert there is only a single load and a single store of Reference.referent.\n+    \/\/ This serves as signal that no GC barriers are emitted in IR.\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE, \"1\",\n+                   IRNode.LOAD, \"1\" })\n+    public void soft() {\n+        SR.clear();\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE, \"1\",\n+                   IRNode.LOAD, \"1\" })\n+    public void weak() {\n+        WR.clear();\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE, \"1\",\n+                   IRNode.LOAD, \"1\" })\n+    public void phantom() {\n+        PR.clear();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/gc\/ReferenceClearTests.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/\/\n+\/\/ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.java.lang.ref;\n+\n+import java.lang.ref.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+public class ReferenceClear {\n+\n+    final Reference<Object> soft = new SoftReference<>(new Object());\n+    final Reference<Object> weak = new WeakReference<>(new Object());\n+    final Reference<Object> phantom = new PhantomReference<>(new Object(), null);\n+\n+    @Benchmark\n+    public void soft() {\n+       soft.clear();\n+    }\n+\n+    @Benchmark\n+    public void soft_new(Blackhole bh) {\n+       Object ref = new Object();\n+       bh.consume(ref);\n+       Reference<Object> soft = new SoftReference<>(ref);\n+       soft.clear();\n+    }\n+\n+    @Benchmark\n+    public void weak() {\n+       weak.clear();\n+    }\n+\n+    @Benchmark\n+    public void weak_new(Blackhole bh) {\n+       Object ref = new Object();\n+       bh.consume(ref);\n+       Reference<Object> weak = new WeakReference<>(ref);\n+       weak.clear();\n+    }\n+\n+    @Benchmark\n+    public void phantom() {\n+       phantom.clear();\n+    }\n+\n+    @Benchmark\n+    public void phantom_new(Blackhole bh) {\n+       Object ref = new Object();\n+       bh.consume(ref);\n+       Reference<Object> phantom = new PhantomReference<>(ref, null);\n+       phantom.clear();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ref\/ReferenceClear.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}