{"files":[{"patch":"@@ -1192,0 +1192,2 @@\n+    } else if (stub->is_nokeepalive()) {\n+      __ lea(rscratch1, RuntimeAddress(ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing_addr()));\n@@ -1310,2 +1312,2 @@\n-ZStoreBarrierStubC2Aarch64::ZStoreBarrierStubC2Aarch64(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic)\n-  : ZStoreBarrierStubC2(node, ref_addr, new_zaddress, new_zpointer, is_native, is_atomic), _deferred_emit(false) {}\n+ZStoreBarrierStubC2Aarch64::ZStoreBarrierStubC2Aarch64(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive)\n+  : ZStoreBarrierStubC2(node, ref_addr, new_zaddress, new_zpointer, is_native, is_atomic, is_nokeepalive), _deferred_emit(false) {}\n@@ -1313,2 +1315,2 @@\n-ZStoreBarrierStubC2Aarch64* ZStoreBarrierStubC2Aarch64::create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic) {\n-  ZStoreBarrierStubC2Aarch64* const stub = new (Compile::current()->comp_arena()) ZStoreBarrierStubC2Aarch64(node, ref_addr, new_zaddress, new_zpointer, is_native, is_atomic);\n+ZStoreBarrierStubC2Aarch64* ZStoreBarrierStubC2Aarch64::create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive) {\n+  ZStoreBarrierStubC2Aarch64* const stub = new (Compile::current()->comp_arena()) ZStoreBarrierStubC2Aarch64(node, ref_addr, new_zaddress, new_zpointer, is_native, is_atomic, is_nokeepalive);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -283,1 +283,1 @@\n-  ZStoreBarrierStubC2Aarch64(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic);\n+  ZStoreBarrierStubC2Aarch64(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive);\n@@ -286,1 +286,1 @@\n-  static ZStoreBarrierStubC2Aarch64* create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic);\n+  static ZStoreBarrierStubC2Aarch64* create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-    ZStoreBarrierStubC2Aarch64* const stub = ZStoreBarrierStubC2Aarch64::create(node, ref_addr, rnew_zaddress, rnew_zpointer, is_native, is_atomic);\n+    bool is_nokeepalive = (node->barrier_data() & ZBarrierNoKeepalive) != 0;\n+    ZStoreBarrierStubC2Aarch64* const stub = ZStoreBarrierStubC2Aarch64::create(node, ref_addr, rnew_zaddress, rnew_zpointer, is_native, is_atomic, is_nokeepalive);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -946,0 +946,2 @@\n+    } else if (stub->is_nokeepalive()) {\n+      __ call_VM_leaf(ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing_addr(), R3_ARG1);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,2 @@\n-    ZStoreBarrierStubC2* const stub = ZStoreBarrierStubC2::create(node, Address(ref_base, disp), rnew_zaddress, rnew_zpointer, is_native, is_atomic);\n+    bool is_nokeepalive = (node->barrier_data() & ZBarrierNoKeepalive) != 0;\n+    ZStoreBarrierStubC2* const stub = ZStoreBarrierStubC2::create(node, Address(ref_base, disp), rnew_zaddress, rnew_zpointer, is_native, is_atomic, is_nokeepalive);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/z_ppc.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -764,0 +764,2 @@\n+    } else if (stub->is_nokeepalive()) {\n+      __ la(t0, RuntimeAddress(ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing_addr()));\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,2 @@\n-    ZStoreBarrierStubC2* const stub = ZStoreBarrierStubC2::create(node, ref_addr, rnew_zaddress, rnew_zpointer, is_native, is_atomic);\n+    bool is_nokeepalive = (node->barrier_data() & ZBarrierNoKeepalive) != 0;\n+    ZStoreBarrierStubC2* const stub = ZStoreBarrierStubC2::create(node, ref_addr, rnew_zaddress, rnew_zpointer, is_native, is_atomic, is_nokeepalive);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/z_riscv.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1263,0 +1263,2 @@\n+    } else if (stub->is_nokeepalive()) {\n+      __ call(RuntimeAddress(ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing_addr()));\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-    ZStoreBarrierStubC2* const stub = ZStoreBarrierStubC2::create(node, ref_addr, rnew_zaddress, rnew_zpointer, is_native, is_atomic);\n+    bool is_nokeepalive = (node->barrier_data() & ZBarrierNoKeepalive) != 0;\n+    ZStoreBarrierStubC2* const stub = ZStoreBarrierStubC2::create(node, ref_addr, rnew_zaddress, rnew_zpointer, is_native, is_atomic, is_nokeepalive);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/z_x86_64.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -472,0 +472,2 @@\n+  do_intrinsic(_Reference_clear0,           java_lang_ref_Reference, clear0_name,    void_method_signature, F_RN)       \\\n+  do_intrinsic(_PhantomReference_clear0,    java_lang_ref_PhantomReference, clear0_name, void_method_signature, F_RN)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -429,0 +429,1 @@\n+  template(clear0_name,                               \"clear0\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -664,0 +664,22 @@\n+Node* G1BarrierSetC2::store_at_resolved(C2Access& access, C2AccessValue& val) const {\n+  DecoratorSet decorators = access.decorators();\n+\n+  bool on_weak = (decorators & ON_WEAK_OOP_REF) != 0;\n+  bool on_phantom = (decorators & ON_PHANTOM_OOP_REF) != 0;\n+  bool no_keepalive = (decorators & AS_NO_KEEPALIVE) != 0;\n+\n+  if (access.is_parse_access()) {\n+    C2ParseAccess &parse_access = static_cast<C2ParseAccess &>(access);\n+    GraphKit* kit = parse_access.kit();\n+\n+    if ((val.node() == kit->null()) &&\n+        (on_weak || on_phantom) && no_keepalive) {\n+      \/\/ Be extra paranoid around this path. Only accept null stores,\n+      \/\/ otherwise we need a post-store barrier.\n+      return BarrierSetC2::store_at_resolved(access, val);\n+    }\n+  }\n+\n+  return CardTableBarrierSetC2::store_at_resolved(access, val);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+  virtual Node* store_at_resolved(C2Access& access, C2AccessValue& val) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -483,0 +483,4 @@\n+  bool on_weak = (decorators & ON_WEAK_OOP_REF) != 0;\n+  bool on_phantom = (decorators & ON_PHANTOM_OOP_REF) != 0;\n+  bool no_keepalive = (decorators & AS_NO_KEEPALIVE) != 0;\n+\n@@ -491,0 +495,7 @@\n+    if ((val.node() == kit->null()) &&\n+        ((on_weak || on_phantom) && no_keepalive)) {\n+      \/\/ Be extra paranoid around this path. Only accept null stores,\n+      \/\/ otherwise we need IU barrier.\n+      return BarrierSetC2::store_at_resolved(access, val);\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-ZStoreBarrierStubC2* ZStoreBarrierStubC2::create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic) {\n+ZStoreBarrierStubC2* ZStoreBarrierStubC2::create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive) {\n@@ -244,1 +244,1 @@\n-  ZStoreBarrierStubC2* const stub = new (Compile::current()->comp_arena()) ZStoreBarrierStubC2(node, ref_addr, new_zaddress, new_zpointer, is_native, is_atomic);\n+  ZStoreBarrierStubC2* const stub = new (Compile::current()->comp_arena()) ZStoreBarrierStubC2(node, ref_addr, new_zaddress, new_zpointer, is_native, is_atomic, is_nokeepalive);\n@@ -250,1 +250,2 @@\n-ZStoreBarrierStubC2::ZStoreBarrierStubC2(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic)\n+ZStoreBarrierStubC2::ZStoreBarrierStubC2(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer,\n+                                         bool is_native, bool is_atomic, bool is_nokeepalive)\n@@ -256,1 +257,2 @@\n-    _is_atomic(is_atomic) {}\n+    _is_atomic(is_atomic),\n+    _is_nokeepalive(is_nokeepalive) {}\n@@ -278,0 +280,4 @@\n+bool ZStoreBarrierStubC2::is_nokeepalive() const {\n+  return _is_nokeepalive;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+  const bool     _is_nokeepalive;\n@@ -84,1 +85,1 @@\n-  ZStoreBarrierStubC2(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic);\n+  ZStoreBarrierStubC2(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive);\n@@ -87,1 +88,1 @@\n-  static ZStoreBarrierStubC2* create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic);\n+  static ZStoreBarrierStubC2* create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive);\n@@ -94,0 +95,1 @@\n+  bool is_nokeepalive() const;\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,0 +62,4 @@\n+JRT_LEAF(void, ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing(oop* p))\n+  ZBarrier::no_keep_alive_store_barrier_on_heap_oop_field((zpointer*)p);\n+JRT_END\n+\n@@ -129,0 +133,4 @@\n+address ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing_addr() {\n+  return reinterpret_cast<address>(no_keepalive_store_barrier_on_oop_field_without_healing);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetRuntime.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  static void no_keepalive_store_barrier_on_oop_field_without_healing(oop* p);\n@@ -57,0 +58,1 @@\n+  static address no_keepalive_store_barrier_on_oop_field_without_healing_addr();\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetRuntime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -769,0 +769,2 @@\n+  case vmIntrinsics::_Reference_clear0:\n+  case vmIntrinsics::_PhantomReference_clear0:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -583,0 +583,2 @@\n+  case vmIntrinsics::_Reference_clear0:         return inline_reference_clear0(false);\n+  case vmIntrinsics::_PhantomReference_clear0:  return inline_reference_clear0(true);\n@@ -6958,0 +6960,46 @@\n+\/\/----------------------------inline_reference_clear0----------------------------\n+\/\/ void java.lang.ref.Reference.clear0();\n+\/\/ void java.lang.ref.PhantomReference.clear0();\n+bool LibraryCallKit::inline_reference_clear0(bool is_phantom) {\n+  \/\/ This matches the implementation in JVM_ReferenceClear, see the comments there.\n+\n+  \/\/ Get arguments\n+  Node* reference_obj = null_check_receiver();\n+  if (stopped()) return true;\n+\n+  \/\/ Common access parameters\n+  DecoratorSet decorators = IN_HEAP | AS_NO_KEEPALIVE;\n+  decorators |= (is_phantom ? ON_PHANTOM_OOP_REF : ON_WEAK_OOP_REF);\n+  Node* referent_field_addr = basic_plus_adr(reference_obj, java_lang_ref_Reference::referent_offset());\n+  const TypePtr* referent_field_addr_type = _gvn.type(referent_field_addr)->isa_ptr();\n+  const Type* val_type = TypeOopPtr::make_from_klass(env()->Object_klass());\n+\n+  Node* referent = access_load_at(reference_obj,\n+                                  referent_field_addr,\n+                                  referent_field_addr_type,\n+                                  val_type,\n+                                  T_OBJECT,\n+                                  decorators);\n+\n+  IdealKit ideal(this);\n+#define __ ideal.\n+  __ if_then(referent, BoolTest::ne, null());\n+    sync_kit(ideal);\n+    access_store_at(reference_obj,\n+                    referent_field_addr,\n+                    referent_field_addr_type,\n+                    null(),\n+                    val_type,\n+                    T_OBJECT,\n+                    decorators);\n+    __ sync_kit(this);\n+  __ end_if();\n+  final_sync(ideal);\n+#undef __\n+\n+  \/\/ Add memory barrier to prevent commoning the accesses in this code,\n+  \/\/ since GC can change the value of referent at any time.\n+  insert_mem_bar(Op_MemBarCPUOrder);\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -300,0 +300,1 @@\n+  bool inline_reference_clear0(bool is_phantom);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,0 +80,13 @@\n+    \/* Override the implementation of Reference.clear.\n+     * Phantom references are weaker than finalization, so the referent\n+     * access needs to be handled differently for garbage collectors that\n+     * do reference processing concurrently.\n+     *\/\n+    @Override\n+    void clearImpl() {\n+        clear0();\n+    }\n+\n+    @IntrinsicCandidate\n+    private native void clear0();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -406,1 +406,1 @@\n-        clear0();\n+        clearImpl();\n@@ -409,3 +409,8 @@\n-    \/* Implementation of clear(), also used by enqueue().  A simple\n-     * assignment of the referent field won't do for some garbage\n-     * collectors.\n+    \/* Implementation of clear(). A simple assignment of the referent field\n+     * won't do for some garbage collectors. There is the override for phantom\n+     * references, which requires different semantics. This method is also\n+     * used by enqueue().\n+     *\n+     * <p>This method exists only to avoid making clear0() virtual. Making\n+     * clear0() virtual has the undesirable effect of C2 often preferring\n+     * to call the native implementation over the intrinsic.\n@@ -413,0 +418,5 @@\n+    void clearImpl() {\n+        clear0();\n+    }\n+\n+    @IntrinsicCandidate\n@@ -514,1 +524,1 @@\n-        clear0();               \/\/ Intentionally clear0() rather than clear()\n+        clearImpl(); \/\/ Intentionally clearImpl() to dispatch to overridden method, if needed\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -34,0 +34,6 @@\n+\n+JNIEXPORT void JNICALL\n+Java_java_lang_ref_PhantomReference_clear0(JNIEnv *env, jobject ref)\n+{\n+    JVM_ReferenceClear(env, ref);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/PhantomReference.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.gc;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.whitebox.gc.GC;\n+\n+import java.lang.ref.*;\n+import java.util.*;\n+\n+\/*\n+ * @test\n+ * @bug 8329597\n+ * @summary Test that Reference.clear intrinsics are properly handled\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @requires vm.compiler2.enabled\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.c2.irTests.gc.ReferenceClearTests\n+\n+ *\/\n+public class ReferenceClearTests {\n+\n+    private static String[] args(String... add) {\n+        List<String> args = new ArrayList<>();\n+\n+         \/\/ Use PerMethodTrapLimit=0 to compile all branches in the intrinsics.\n+        args.add(\"-XX:PerMethodTrapLimit=0\");\n+\n+        \/\/ Forcefully inline all methods to reach the intrinsic code.\n+        args.add(\"-XX:CompileCommand=inline,compiler.c2.irTests.gc.ReferenceClearTests::*\");\n+        args.add(\"-XX:CompileCommand=inline,java.lang.ref.Reference::*\");\n+        args.add(\"-XX:CompileCommand=inline,java.lang.ref.PhantomReference::*\");\n+\n+        \/\/ Mix in test config code.\n+        args.addAll(Arrays.asList(add));\n+\n+        return args.toArray(new String[0]);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework();\n+\n+        int idx = 0;\n+        if (GC.isSelectedErgonomically() && GC.Serial.isSupported()) {\n+            \/\/ Serial does not have SATB\/keep-alive barriers at all.\n+            \/\/ There are inter-generational barriers on stores, but they are\n+            \/\/ folded away for null stores like clear().\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseSerialGC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.Parallel.isSupported()) {\n+            \/\/ Parallel does not have SATB\/keep-alive barriers at all.\n+            \/\/ There are inter-generational barriers on stores, but they\n+            \/\/ should be folded away for null stores like clear().\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseParallelGC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.G1.isSupported()) {\n+            \/\/ G1 has SATB\/keep-alive barriers, but they should not be present\n+            \/\/ for clear()-s. There are inter-generational barriers on stores,\n+            \/\/ but they should be folded away for null stores like clear().\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseG1GC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.Shenandoah.isSupported()) {\n+            \/\/ Shenandoah has SATB\/keep-alive barriers, but they should not be\n+            \/\/ present clear()-s. There are load-reference barriers, which would\n+            \/\/ confuse the tests, so we enable only SATB barriers.\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:ShenandoahGCMode=passive\",\n+                \"-XX:+ShenandoahSATBBarrier\",\n+                \"-XX:+UseShenandoahGC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.Z.isSupported()) {\n+            \/\/ Z does not have barriers in C2 IR.\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseZGC\"\n+            )));\n+        }\n+        framework.start();\n+    }\n+\n+    static final Object REF = new Object();\n+\n+    static final SoftReference<Object> SR = new SoftReference<>(REF);\n+    static final WeakReference<Object> WR = new WeakReference<>(REF);\n+    static final PhantomReference<Object> PR = new PhantomReference<>(REF, null);\n+\n+    \/\/ We assert there is only a single load and a single store of Reference.referent.\n+    \/\/ This serves as signal that no GC barriers are emitted in IR.\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE, \"1\",\n+                   IRNode.LOAD, \"1\" })\n+    public void soft() {\n+        SR.clear();\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE, \"1\",\n+                   IRNode.LOAD, \"1\" })\n+    public void weak() {\n+        WR.clear();\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE, \"1\",\n+                   IRNode.LOAD, \"1\" })\n+    public void phantom() {\n+        PR.clear();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/gc\/ReferenceClearTests.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/\/\n+\/\/ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.java.lang.ref;\n+\n+import java.lang.ref.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+public class ReferenceClear {\n+\n+    final Reference<Object> soft = new SoftReference<>(new Object());\n+    final Reference<Object> weak = new WeakReference<>(new Object());\n+    final Reference<Object> phantom = new PhantomReference<>(new Object(), null);\n+\n+    @Benchmark\n+    public void soft() {\n+       soft.clear();\n+    }\n+\n+    @Benchmark\n+    public void soft_new(Blackhole bh) {\n+       Object ref = new Object();\n+       bh.consume(ref);\n+       Reference<Object> soft = new SoftReference<>(ref);\n+       soft.clear();\n+    }\n+\n+    @Benchmark\n+    public void weak() {\n+       weak.clear();\n+    }\n+\n+    @Benchmark\n+    public void weak_new(Blackhole bh) {\n+       Object ref = new Object();\n+       bh.consume(ref);\n+       Reference<Object> weak = new WeakReference<>(ref);\n+       weak.clear();\n+    }\n+\n+    @Benchmark\n+    public void phantom() {\n+       phantom.clear();\n+    }\n+\n+    @Benchmark\n+    public void phantom_new(Blackhole bh) {\n+       Object ref = new Object();\n+       bh.consume(ref);\n+       Reference<Object> phantom = new PhantomReference<>(ref, null);\n+       phantom.clear();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ref\/ReferenceClear.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}