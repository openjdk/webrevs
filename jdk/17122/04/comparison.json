{"files":[{"patch":"@@ -509,1 +509,1 @@\n-  INSN(mul,   0b0110011, 0b000, 0b0000001);\n+  INSN(_mul,  0b0110011, 0b000, 0b0000001);\n@@ -540,3 +540,3 @@\n-  INSN(lbu, 0b0000011, 0b100);\n-  INSN(lh,  0b0000011, 0b001);\n-  INSN(lhu, 0b0000011, 0b101);\n+  INSN(_lbu, 0b0000011, 0b100);\n+  INSN(_lh,  0b0000011, 0b001);\n+  INSN(_lhu, 0b0000011, 0b101);\n@@ -612,2 +612,2 @@\n-  INSN(sb,   Register,      0b0100011, 0b000);\n-  INSN(sh,   Register,      0b0100011, 0b001);\n+  INSN(_sb,   Register,      0b0100011, 0b000);\n+  INSN(_sh,   Register,      0b0100011, 0b001);\n@@ -1872,3 +1872,3 @@\n-  INSN(sext_b, 0b0010011, 0b001, 0b011000000100);\n-  INSN(sext_h, 0b0010011, 0b001, 0b011000000101);\n-  INSN(zext_h, 0b0111011, 0b100, 0b000010000000);\n+  INSN(_sext_b, 0b0010011, 0b001, 0b011000000100);\n+  INSN(_sext_h, 0b0010011, 0b001, 0b011000000101);\n+  INSN(_zext_h, 0b0111011, 0b100, 0b000010000000);\n@@ -2586,0 +2586,9 @@\n+  bool do_compress_zcb(Register reg1 = noreg, Register reg2 = noreg) const {\n+    return do_compress() && VM_Version::ext_Zcb.enabled() &&\n+           (reg1 == noreg || reg1->is_compressed_valid()) && (reg2 == noreg || reg2->is_compressed_valid());\n+  }\n+\n+  bool do_compress_zcb_zbb(Register reg1 = noreg, Register reg2 = noreg) const {\n+    return do_compress_zcb(reg1, reg2) && UseZbb;\n+  }\n+\n@@ -2920,0 +2929,232 @@\n+\/\/ --------------  ZCB Instruction Definitions  --------------\n+\/\/ Zcb additional C instructions\n+ private:\n+  \/\/ Format CLH, c.lh\/c.lhu\n+  template <bool Unsigned>\n+  void c_lh_if(Register Rd_Rs2, Register Rs1, uint32_t uimm) {\n+    assert_cond(uimm == 0 || uimm == 2);\n+    assert_cond(do_compress_zcb(Rd_Rs2, Rs1));\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, 0b00);\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(1)) >> 1);\n+    c_patch((address)&insn, 6, 6, Unsigned ? 0 : 1);\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);\n+    c_patch((address)&insn, 12, 10, 0b001);\n+    c_patch((address)&insn, 15, 13, 0b100);\n+    emit_int16(insn);\n+  }\n+\n+  template <bool Unsigned>\n+  void lh_c_mux(Register Rd_Rs2, Register Rs1, const int32_t uimm) {\n+    if (do_compress_zcb(Rd_Rs2, Rs1) &&\n+        (uimm == 0 || uimm == 2)) {\n+      c_lh_if<Unsigned>(Rd_Rs2, Rs1, uimm);\n+    } else {\n+      if (Unsigned) {\n+        _lhu(Rd_Rs2, Rs1, uimm);\n+      } else {\n+        _lh(Rd_Rs2, Rs1, uimm);\n+      }\n+    }\n+  }\n+\n+  \/\/ Format CU, c.[sz]ext.*, c.not\n+  template <uint8_t InstructionType>\n+  void c_u_if(Register Rs1) {\n+    assert_cond(do_compress_zcb(Rs1));\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, 0b01);\n+    c_patch((address)&insn, 4, 2, InstructionType);\n+    c_patch((address)&insn, 6, 5, 0b11);\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);\n+    c_patch((address)&insn, 12, 10, 0b111);\n+    c_patch((address)&insn, 15, 13, 0b100);\n+    emit_int16(insn);\n+  }\n+\n+ public:\n+\n+  \/\/ Prerequisites: Zcb\n+  void c_lh(Register Rd_Rs2, Register Rs1, const int32_t uimm)  {  c_lh_if<false>(Rd_Rs2, Rs1, uimm); }\n+  void lh(Register Rd_Rs2, Register Rs1, const int32_t uimm)    { lh_c_mux<false>(Rd_Rs2, Rs1, uimm); }\n+\n+  \/\/ Prerequisites: Zcb\n+  void c_lhu(Register Rd_Rs2, Register Rs1, const int32_t uimm) {  c_lh_if<true>(Rd_Rs2, Rs1, uimm); }\n+  void lhu(Register Rd_Rs2, Register Rs1, const int32_t uimm)   { lh_c_mux<true>(Rd_Rs2, Rs1, uimm); }\n+\n+  \/\/ Prerequisites: Zcb\n+  \/\/ Format CLB, single instruction\n+  void c_lbu(Register Rd_Rs2, Register Rs1, uint32_t uimm) {\n+    assert_cond(uimm <= 3);\n+    assert_cond(do_compress_zcb(Rd_Rs2, Rs1));\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, 0b00);\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(1)) >> 1);\n+    c_patch((address)&insn, 6, 6, (uimm & nth_bit(0)) >> 0);\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);\n+    c_patch((address)&insn, 12, 10, 0b000);\n+    c_patch((address)&insn, 15, 13, 0b100);\n+    emit_int16(insn);\n+  }\n+\n+  void lbu(Register Rd_Rs2, Register Rs1, const int32_t uimm) {\n+    if (do_compress_zcb(Rd_Rs2, Rs1) &&\n+        uimm >= 0 && uimm <= 3) {\n+      c_lbu(Rd_Rs2, Rs1, uimm);\n+    } else {\n+      _lbu(Rd_Rs2, Rs1, uimm);\n+    }\n+  }\n+\n+  \/\/ Prerequisites: Zcb\n+  \/\/ Format CSB, single instruction\n+  void c_sb(Register Rd_Rs2, Register Rs1, uint32_t uimm) {\n+    assert_cond(uimm <= 3);\n+    assert_cond(do_compress_zcb(Rd_Rs2, Rs1));\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, 0b00);\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(1)) >> 1);\n+    c_patch((address)&insn, 6, 6, (uimm & nth_bit(0)) >> 0);\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);\n+    c_patch((address)&insn, 12, 10, 0b010);\n+    c_patch((address)&insn, 15, 13, 0b100);\n+    emit_int16(insn);\n+  }\n+\n+  void sb(Register Rd_Rs2, Register Rs1, const int32_t uimm) {\n+    if (do_compress_zcb(Rd_Rs2, Rs1) &&\n+        uimm >= 0 && uimm <= 3) {\n+      c_sb(Rd_Rs2, Rs1, uimm);\n+    } else {\n+      _sb(Rd_Rs2, Rs1, uimm);\n+    }\n+  }\n+\n+  \/\/ Prerequisites: Zcb\n+  \/\/ Format CSH, single instruction\n+  void c_sh(Register Rd_Rs2, Register Rs1, uint32_t uimm) {\n+    assert_cond(uimm == 0 || uimm == 2);\n+    assert_cond(do_compress_zcb(Rd_Rs2, Rs1));\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, 0b00);\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(1)) >> 1);\n+    c_patch((address)&insn, 6, 6, 0);\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);\n+    c_patch((address)&insn, 12, 10, 0b011);\n+    c_patch((address)&insn, 15, 13, 0b100);\n+    emit_int16(insn);\n+  }\n+\n+  void sh(Register Rd_Rs2, Register Rs1, const int32_t uimm) {\n+    if (do_compress_zcb(Rd_Rs2, Rs1) &&\n+        (uimm == 0 || uimm == 2)) {\n+      c_sh(Rd_Rs2, Rs1, uimm);\n+    } else {\n+      _sh(Rd_Rs2, Rs1, uimm);\n+    }\n+  }\n+\n+  \/\/ Prerequisites: Zcb\n+  \/\/ Format CS\n+  void c_zext_b(Register Rs1) {\n+    assert_cond(do_compress_zcb(Rs1));\n+    c_u_if<0b000>(Rs1);\n+  }\n+\n+  \/\/ Prerequisites: Zbb\n+  void sext_b(Register Rd_Rs2, Register Rs1) {\n+    assert_cond(UseZbb);\n+    if (do_compress_zcb_zbb(Rd_Rs2, Rs1) && (Rd_Rs2 == Rs1)) {\n+      c_sext_b(Rd_Rs2);\n+    } else {\n+      _sext_b(Rd_Rs2, Rs1);\n+    }\n+  }\n+\n+  \/\/ Prerequisites: Zcb, Zbb\n+  \/\/ Format CS\n+  void c_sext_b(Register Rs1) {\n+    c_u_if<0b001>(Rs1);\n+  }\n+\n+  \/\/ Prerequisites: Zbb\n+  void zext_h(Register Rd_Rs2, Register Rs1) {\n+    assert_cond(UseZbb);\n+    if (do_compress_zcb_zbb(Rd_Rs2, Rs1) && (Rd_Rs2 == Rs1)) {\n+      c_zext_h(Rd_Rs2);\n+    } else {\n+      _zext_h(Rd_Rs2, Rs1);\n+    }\n+  }\n+\n+  \/\/ Prerequisites: Zcb, Zbb\n+  \/\/ Format CS\n+  void c_zext_h(Register Rs1) {\n+    c_u_if<0b010>(Rs1);\n+  }\n+\n+  \/\/ Prerequisites: Zbb\n+  void sext_h(Register Rd_Rs2, Register Rs1) {\n+    assert_cond(UseZbb);\n+    if (do_compress_zcb_zbb(Rd_Rs2, Rs1) && (Rd_Rs2 == Rs1)) {\n+      c_sext_h(Rd_Rs2);\n+    } else {\n+      _sext_h(Rd_Rs2, Rs1);\n+    }\n+  }\n+\n+  \/\/ Prerequisites: Zcb, Zbb\n+  \/\/ Format CS\n+  void c_sext_h(Register Rs1) {\n+    c_u_if<0b011>(Rs1);\n+  }\n+\n+  \/\/ Prerequisites: Zcb, Zba\n+  \/\/ Format CS\n+  void c_zext_w(Register Rs1) {\n+    c_u_if<0b100>(Rs1);\n+  }\n+\n+  \/\/ Prerequisites: Zcb\n+  \/\/ Format CS\n+  void c_not(Register Rs1) {\n+    c_u_if<0b101>(Rs1);\n+  }\n+\n+  \/\/ Prerequisites: Zcb (M or Zmmul)\n+  \/\/ Format CA, c.mul\n+  void c_mul(Register Rd_Rs1, Register Rs2) {\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, 0b01);\n+    c_patch_compressed_reg((address)&insn, 2, Rs2);\n+    c_patch((address)&insn, 6, 5, 0b10);\n+    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);\n+    c_patch((address)&insn, 12, 10, 0b111);\n+    c_patch((address)&insn, 15, 13, 0b100);\n+    emit_int16(insn);\n+  }\n+\n+  void mul(Register Rd, Register Rs1, Register Rs2) {\n+    if (Rd != Rs1 && Rd != Rs2) {\n+      \/\/ Three registers needed without a mv, emit uncompressed\n+      _mul(Rd, Rs1, Rs2);\n+      return;\n+    }\n+\n+    \/\/ Rd is either Rs1 or Rs2\n+    if (!do_compress_zcb(Rs2, Rs1)) {\n+      _mul(Rd, Rs1, Rs2);\n+    } else {\n+      if (Rd == Rs2) {\n+        Rs2 = Rs1;\n+      } else {\n+        assert(Rd == Rs1, \"must be\");\n+      }\n+      c_mul(Rd, Rs2);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":250,"deletions":9,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -4681,15 +4681,21 @@\n-  if (UseZba && bits == 32) {\n-    zext_w(dst, src);\n-    return;\n-  }\n-\n-  if (UseZbb && bits == 16) {\n-    zext_h(dst, src);\n-    return;\n-  }\n-\n-  if (bits == 8) {\n-    zext_b(dst, src);\n-  } else {\n-    slli(dst, src, XLEN - bits);\n-    srli(dst, dst, XLEN - bits);\n+  switch (bits) {\n+    case 32:\n+      if (UseZba) {\n+        zext_w(dst, src);\n+        return;\n+      }\n+      break;\n+    case 16:\n+      if (UseZbb) {\n+        zext_h(dst, src);\n+        return;\n+      }\n+      break;\n+    case 8:\n+      if (UseZbb) {\n+        zext_b(dst, src);\n+        return;\n+      }\n+      break;\n+    default:\n+      break;\n@@ -4697,0 +4703,2 @@\n+  slli(dst, src, XLEN - bits);\n+  srli(dst, dst, XLEN - bits);\n@@ -4700,3 +4708,3 @@\n-  if (UseZbb) {\n-    if (bits == 8) {\n-      sext_b(dst, src);\n+  switch (bits) {\n+    case 32:\n+      sext_w(dst, src);\n@@ -4704,11 +4712,14 @@\n-    } else if (bits == 16) {\n-      sext_h(dst, src);\n-      return;\n-    }\n-  }\n-\n-  if (bits == 32) {\n-    sext_w(dst, src);\n-  } else {\n-    slli(dst, src, XLEN - bits);\n-    srai(dst, dst, XLEN - bits);\n+    case 16:\n+      if (UseZbb) {\n+        sext_h(dst, src);\n+        return;\n+      }\n+      break;\n+    case 8:\n+      if (UseZbb) {\n+        sext_b(dst, src);\n+        return;\n+      }\n+      break;\n+    default:\n+      break;\n@@ -4716,0 +4727,2 @@\n+  slli(dst, src, XLEN - bits);\n+  srai(dst, dst, XLEN - bits);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":42,"deletions":29,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -476,1 +476,5 @@\n-    xori(Rd, Rs, -1);\n+    if (do_compress_zcb(Rd, Rs) && (Rd == Rs)) {\n+      c_not(Rd);\n+    } else {\n+      xori(Rd, Rs, -1);\n+    }\n@@ -492,1 +496,5 @@\n-    andi(Rd, Rs, 0xFF);\n+    if (do_compress_zcb(Rd, Rs) && (Rd == Rs)) {\n+      c_zext_b(Rd);\n+    } else {\n+      andi(Rd, Rs, 0xFF);\n+    }\n@@ -514,1 +522,6 @@\n-    add_uw(Rd, Rs, zr);\n+    assert(UseZba, \"must be\");\n+    if (do_compress_zcb(Rd, Rs) && (Rd == Rs)) {\n+      c_zext_w(Rd);\n+    } else {\n+      add_uw(Rd, Rs, zr);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -113,0 +113,3 @@\n+  \/\/ Zc  Code Size Reduction - Additional compressed instructions.\n+  \/\/ Zcb Simple code-size saving instructions\n+  \/\/\n@@ -120,0 +123,2 @@\n+ public:\n+\n@@ -140,0 +145,1 @@\n+  decl(ext_Zcb         , \"Zcb\"         , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)              \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -243,0 +243,2 @@\n+  ext_Zcb.enable_feature();\n+\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}