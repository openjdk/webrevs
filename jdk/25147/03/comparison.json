{"files":[{"patch":"@@ -2569,0 +2569,106 @@\n+  address generate_unsafecopy_common_error_exit() {\n+    address start_pc = __ pc();\n+      __ leave();\n+      __ mov(r0, 0);\n+      __ ret(lr);\n+    return start_pc;\n+  }\n+\n+  \/\/\n+  \/\/  Generate 'unsafe' set memory stub\n+  \/\/  Though just as safe as the other stubs, it takes an unscaled\n+  \/\/  size_t (# bytes) argument instead of an element count.\n+  \/\/\n+  \/\/  This fill operation is atomicity preserving: as long as the\n+  \/\/  address supplied is sufficiently aligned, all writes of up to 64\n+  \/\/  bits in size are single-copy atomic.\n+  \/\/\n+  \/\/  Input:\n+  \/\/    c_rarg0   - destination array address\n+  \/\/    c_rarg1   - byte count (size_t)\n+  \/\/    c_rarg2   - byte value\n+  \/\/\n+  address generate_unsafe_setmemory() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n+    address start = __ pc();\n+\n+    Register dest = c_rarg0, count = c_rarg1, value = c_rarg2;\n+    Label tail;\n+\n+    UnsafeMemoryAccessMark umam(this, true, false);\n+\n+    __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+    __ dup(v0, __ T16B, value);\n+\n+    __ subs(count, count, (u1)64);\n+    __ br(__ LO, tail);\n+    {\n+      Label again;\n+      __ bind(again);\n+      __ stpq(v0, v0, Address(dest));\n+      __ stpq(v0, v0, Address(dest, 32));\n+\n+      __ subs(count, count, 64);\n+      __ add(dest, dest, 64);\n+      __ br(__ HS, again);\n+    }\n+\n+    __ bind(tail);\n+    \/\/ The count of bytes is off by 64, but we don't need to correct\n+    \/\/ it because we're only going to use the least-significant few\n+    \/\/ count bits from here on.\n+    \/\/ __ add(count, count, 64);\n+\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(32), dont);\n+      __ stpq(v0, v0, __ post(dest, 32));\n+      __ bind(dont);\n+    }\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(16), dont);\n+      __ strq(v0, __ post(dest, 16));\n+      __ bind(dont);\n+    }\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(8), dont);\n+      __ strd(v0, __ post(dest, 8));\n+      __ bind(dont);\n+    }\n+\n+    Label finished;\n+    __ tst(count, 7);\n+    __ br(__ EQ, finished);\n+\n+    __ bfi(value, value, 8, 8);\n+    __ bfi(value, value, 16, 16);\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(4), dont);\n+      __ strw(value, __ post(dest, 4));\n+      __ bind(dont);\n+    }\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(2), dont);\n+      __ strh(value, __ post(dest, 2));\n+      __ bind(dont);\n+    }\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(1), dont);\n+      __ strb(value, Address(dest));\n+      __ bind(dont);\n+    }\n+\n+    __ bind(finished);\n+    __ leave();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -2618,0 +2724,3 @@\n+    address ucm_common_error_exit       =  generate_unsafecopy_common_error_exit();\n+    UnsafeMemoryAccess::set_common_exit_stub_pc(ucm_common_error_exit);\n+\n@@ -11256,0 +11365,2 @@\n+    StubRoutines::_unsafe_setmemory = generate_unsafe_setmemory();\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-public class MemorySegmentZeroUnsafe {\n+public class MemorySegmentFillUnsafe {\n@@ -86,1 +86,1 @@\n-        segment.fill((byte) 0);\n+        segment.fill((byte) 99);\n@@ -91,1 +91,1 @@\n-        UNSAFE.setMemory(address, size, (byte) 0);\n+        UNSAFE.setMemory(address, size, (byte) 99);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentFillUnsafe.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentZeroUnsafe.java","status":"copied"}]}