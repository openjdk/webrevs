{"files":[{"patch":"@@ -153,1 +153,1 @@\n-    private transient int count;\n+    private transient volatile int count;\n@@ -209,0 +209,2 @@\n+     *\n+     * @return true if the node was added; false otherwise\n@@ -212,2 +214,1 @@\n-        if (count >= capacity)\n-            return false;\n+        if (count >= capacity) return false;\n@@ -228,0 +229,2 @@\n+     *\n+     * @return true if the node was added; false otherwise\n@@ -231,2 +234,1 @@\n-        if (count >= capacity)\n-            return false;\n+        if (count >= capacity) return false;\n@@ -337,0 +339,2 @@\n+        if (count >= capacity)\n+            return false;\n@@ -352,0 +356,2 @@\n+        if (count >= capacity)\n+            return false;\n@@ -370,1 +376,1 @@\n-        lock.lock();\n+        lock.lockInterruptibly();\n@@ -387,1 +393,1 @@\n-        lock.lock();\n+        lock.lockInterruptibly();\n@@ -461,0 +467,1 @@\n+        if (count == 0) return null;\n@@ -471,0 +478,1 @@\n+        if (count == 0) return null;\n@@ -482,1 +490,1 @@\n-        lock.lock();\n+        lock.lockInterruptibly();\n@@ -495,1 +503,1 @@\n-        lock.lock();\n+        lock.lockInterruptibly();\n@@ -561,0 +569,1 @@\n+        if (count == 0) return null;\n@@ -571,0 +580,1 @@\n+        if (count == 0) return null;\n@@ -721,7 +731,1 @@\n-        final ReentrantLock lock = this.lock;\n-        lock.lock();\n-        try {\n-            return capacity - count;\n-        } finally {\n-            lock.unlock();\n-        }\n+        return capacity - count;\n@@ -809,7 +813,1 @@\n-        final ReentrantLock lock = this.lock;\n-        lock.lock();\n-        try {\n-            return count;\n-        } finally {\n-            lock.unlock();\n-        }\n+        return count;\n@@ -861,1 +859,1 @@\n-        int n = 0;\n+        long n = 0;\n@@ -888,1 +886,1 @@\n-                count += n;\n+                count = (int) (count + n);\n@@ -897,0 +895,1 @@\n+        beg = end = null; \/\/ help GC\n@@ -997,2 +996,2 @@\n-                f.prev = null;\n-                f.next = null;\n+                f.prev = f;\n+                f.next = f;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/LinkedBlockingDeque.java","additions":26,"deletions":27,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.concurrent.ExecutionException;\n@@ -48,0 +49,1 @@\n+import java.util.concurrent.Future;\n@@ -1889,0 +1891,104 @@\n+    public void testInterruptedExceptionThrownInBlockingMethods() throws InterruptedException {\n+        \/\/ Ensure that putFirst(), putLast(), takeFirst(), and takeLast()\n+        \/\/ immediately throw an InterruptedException if the thread is\n+        \/\/ interrupted, to be consistent with other blocking queues such as\n+        \/\/ ArrayBlockingQueue and LinkedBlockingQueue\n+        try (var pool = Executors.newSingleThreadExecutor()) {\n+            Future<Void> success = pool.submit(() -> {\n+                var queue = new LinkedBlockingDeque<>();\n+                Thread.currentThread().interrupt();\n+                try {\n+                    queue.putFirst(42);\n+                    fail(\"Expected InterruptedException in putFirst()\");\n+                } catch (InterruptedException expected) {\n+                    \/\/ good that's what we want\n+                }\n+\n+                Thread.currentThread().interrupt();\n+                try {\n+                    queue.putLast(42);\n+                    fail(\"Expected InterruptedException in putLast()\");\n+                } catch (InterruptedException expected) {\n+                    \/\/ good that's what we want\n+                }\n+\n+                queue.add(42);\n+                Thread.currentThread().interrupt();\n+                try {\n+                    queue.takeFirst();\n+                    fail(\"Expected InterruptedException in takeFirst()\");\n+                } catch (InterruptedException expected) {\n+                    \/\/ good that's what we want\n+                }\n+\n+                queue.add(42);\n+                Thread.currentThread().interrupt();\n+                try {\n+                    queue.takeLast();\n+                    fail(\"Expected InterruptedException in takeLast()\");\n+                } catch (InterruptedException expected) {\n+                    \/\/ good that's what we want\n+                }\n+                return null;\n+            });\n+            try {\n+                success.get();\n+            } catch (ExecutionException e) {\n+                try {\n+                    throw e.getCause();\n+                } catch (Error | RuntimeException unchecked) {\n+                    throw unchecked;\n+                } catch (Throwable cause) {\n+                    throw new AssertionError(cause);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testWeaklyConsistentIterationWithClear() {\n+        final LinkedBlockingDeque<Item> q = new LinkedBlockingDeque<>(3);\n+        q.add(one);\n+        q.add(two);\n+        q.add(three);\n+        final Iterator<Item> it = q.iterator();\n+        mustEqual(one, it.next());\n+        q.clear();\n+        q.add(four);\n+        q.add(five);\n+        q.add(six);\n+        mustEqual(two, it.next());\n+        mustEqual(four, it.next());\n+        mustEqual(five, it.next());\n+        mustEqual(six, it.next());\n+        mustEqual(3, q.size());\n+    }\n+\n+    public void testWeaklyConsistentIterationWithIteratorRemove() {\n+        final LinkedBlockingDeque<Item> q = new LinkedBlockingDeque<>(15);\n+        q.add(one);\n+        q.add(two);\n+        q.add(three);\n+        q.add(four);\n+        q.add(five);\n+        final Iterator<Item> it1 = q.iterator();\n+        final Iterator<Item> it2 = q.iterator();\n+        final Iterator<Item> it3 = q.iterator();\n+        mustEqual(one, it1.next());\n+        mustEqual(two, it1.next());\n+        it1.remove(); \/\/ removing \"two\"\n+        mustEqual(one, it2.next());\n+        it2.remove(); \/\/ removing \"one\" - does nothing\n+        mustEqual(three, it2.next());\n+        mustEqual(four, it2.next());\n+        it2.remove(); \/\/ removing \"four\"\n+        mustEqual(one, it3.next());\n+        mustEqual(three, it3.next());\n+        mustEqual(five, it3.next());\n+        assertFalse(it3.hasNext());\n+        mustEqual(three, it1.next());\n+        mustEqual(five, it1.next());\n+        assertFalse(it1.hasNext());\n+        mustEqual(five, it2.next());\n+        assertFalse(it2.hasNext());\n+        mustEqual(3, q.size());\n+    }\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/LinkedBlockingDequeTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"modified"}]}