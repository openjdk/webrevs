{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -642,3 +642,0 @@\n-  do_intrinsic(_isCompileConstant, java_lang_invoke_MethodHandleImpl, isCompileConstant_name, isCompileConstant_signature, F_S) \\\n-   do_name(     isCompileConstant_name,                          \"isCompileConstant\")                                   \\\n-   do_alias(    isCompileConstant_signature,                      object_boolean_signature)                             \\\n@@ -925,0 +922,21 @@\n+                                                                                                                              \\\n+  do_class(jdk_internal_vm_ConstantSupport, \"jdk\/internal\/vm\/ConstantSupport\")                                                                 \\\n+  do_intrinsic(_isCompileConstantZ,       jdk_internal_vm_ConstantSupport, isCompileConstant_name, isCompileConstantZ_signature, F_S)          \\\n+   do_alias(    isCompileConstantZ_signature,                           bool_bool_signature)                                                   \\\n+  do_intrinsic(_isCompileConstantB,       jdk_internal_vm_ConstantSupport, isCompileConstant_name, isCompileConstantB_signature, F_S)          \\\n+   do_alias(    isCompileConstantB_signature,                           byte_bool_signature)                                                   \\\n+  do_intrinsic(_isCompileConstantS,       jdk_internal_vm_ConstantSupport, isCompileConstant_name, isCompileConstantS_signature, F_S)          \\\n+   do_alias(    isCompileConstantS_signature,                           short_bool_signature)                                                  \\\n+  do_intrinsic(_isCompileConstantC,       jdk_internal_vm_ConstantSupport, isCompileConstant_name, isCompileConstantC_signature, F_S)          \\\n+   do_alias(    isCompileConstantC_signature,                           char_bool_signature)                                                   \\\n+  do_intrinsic(_isCompileConstantI,       jdk_internal_vm_ConstantSupport, isCompileConstant_name, isCompileConstantI_signature, F_S)          \\\n+   do_alias(    isCompileConstantI_signature,                           int_bool_signature)                                                    \\\n+  do_intrinsic(_isCompileConstantJ,       jdk_internal_vm_ConstantSupport, isCompileConstant_name, isCompileConstantJ_signature, F_S)          \\\n+   do_alias(    isCompileConstantJ_signature,                           long_bool_signature)                                                   \\\n+  do_intrinsic(_isCompileConstantF,       jdk_internal_vm_ConstantSupport, isCompileConstant_name, isCompileConstantF_signature, F_S)          \\\n+   do_alias(    isCompileConstantF_signature,                           float_bool_signature)                                                  \\\n+  do_intrinsic(_isCompileConstantD,       jdk_internal_vm_ConstantSupport, isCompileConstant_name, isCompileConstantD_signature, F_S)          \\\n+   do_alias(    isCompileConstantD_signature,                           double_bool_signature)                                                 \\\n+  do_intrinsic(_isCompileConstantL,       jdk_internal_vm_ConstantSupport, isCompileConstant_name, isCompileConstantL_signature, F_S)          \\\n+   do_alias(    isCompileConstantL_signature,                           object_boolean_signature)                                              \\\n+   do_name(     isCompileConstant_name,                                 \"isCompileConstant\")                                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -568,0 +568,4 @@\n+  template(bool_bool_signature,                       \"(Z)Z\")                                     \\\n+  template(byte_bool_signature,                       \"(B)Z\")                                     \\\n+  template(short_bool_signature,                      \"(S)Z\")                                     \\\n+  template(char_bool_signature,                       \"(C)Z\")                                     \\\n@@ -569,0 +573,1 @@\n+  template(long_bool_signature,                       \"(J)Z\")                                     \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -727,0 +727,9 @@\n+  case vmIntrinsics::_isCompileConstantZ:\n+  case vmIntrinsics::_isCompileConstantB:\n+  case vmIntrinsics::_isCompileConstantS:\n+  case vmIntrinsics::_isCompileConstantC:\n+  case vmIntrinsics::_isCompileConstantI:\n+  case vmIntrinsics::_isCompileConstantJ:\n+  case vmIntrinsics::_isCompileConstantF:\n+  case vmIntrinsics::_isCompileConstantD:\n+  case vmIntrinsics::_isCompileConstantL:\n@@ -795,1 +804,0 @@\n-  case vmIntrinsics::_isCompileConstant:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -477,0 +477,10 @@\n+  case vmIntrinsics::_isCompileConstantZ:\n+  case vmIntrinsics::_isCompileConstantB:\n+  case vmIntrinsics::_isCompileConstantS:\n+  case vmIntrinsics::_isCompileConstantC:\n+  case vmIntrinsics::_isCompileConstantI:\n+  case vmIntrinsics::_isCompileConstantJ:\n+  case vmIntrinsics::_isCompileConstantF:\n+  case vmIntrinsics::_isCompileConstantD:\n+  case vmIntrinsics::_isCompileConstantL:       return inline_isCompileConstant();\n+\n@@ -667,2 +677,0 @@\n-  case vmIntrinsics::_isCompileConstant:\n-    return inline_isCompileConstant();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.ConstantSupport;\n@@ -622,1 +623,1 @@\n-        if (MethodHandleImpl.isCompileConstant(mh)) {\n+        if (ConstantSupport.isCompileConstant(mh)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -616,7 +616,0 @@\n-    \/\/ Intrinsified by C2. Returns true if obj is a compile-time constant.\n-    @Hidden\n-    @jdk.internal.vm.annotation.IntrinsicCandidate\n-    static boolean isCompileConstant(Object obj) {\n-        return false;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+import jdk.internal.vm.annotation.Hidden;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n+\/**\n+ * This class defines methods to test if a value has been evaluated to a\n+ * compile-time constant by the HotSpot VM.\n+ *\/\n+public class ConstantSupport {\n+    \/**\n+     * Determine if {@code val} can be proved to be a constant by the JIT\n+     * compiler. For example, {@code isCompileConstant(5)} will be evaluated\n+     * to {@code true}, while {@code isCompileConstant(random.nextLong())}\n+     * will likely be evaluated to {@code false}.\n+     *\n+     * <p>Note that the JIT compiler is responsible for changing the return\n+     * value of this method to {@code true}, the interpreter always returns\n+     * {@code false}.\n+     *\n+     * <p>Given the nondeterministic nature of this method, the result of the\n+     * program must not depend on the return value of this method. It must be\n+     * used as a pure optimization to take advantage of the constant nature of\n+     * {@code val}.\n+     *\n+     * <p>Since we will not have profile information in the branch that this\n+     * method returns {@code true}, the compiler may have a harder time\n+     * optimizing it. As a result, apart from simple cases, this technique\n+     * should be used with care.\n+     *\n+     * <p>Usage example:\n+     *\n+     * {@snippet lang=java:\n+     * void checkIndex(int index, int length) {\n+     *     \/\/ Normally, we check length >= 0 && index u< length because\n+     *     \/\/ length >= 0 can often be hoisted out of loops, however, if\n+     *     \/\/ we know that index >= 0, just signed compare index and length\n+     *     boolean indexPos = index >= 0;\n+     *     if (isCompileConstant(indexPos) && indexPos) {\n+     *         if (index >= length) {\n+     *             throw new IndexOutOfBoundsException();\n+     *         }\n+     *         return;\n+     *     }\n+     *\n+     *     if (length < 0 || Integer.compareUnsigned(index, length) >= 0) {\n+     *         throw new IndexOutOfBoundsException();\n+     *     }\n+     * }\n+     * }\n+     *\n+     * @param val the tested value\n+     * @return {@code true} if the JIT compiler determines that {@code val} is\n+     *         a constant, {@code false} otherwise\n+     *\/\n+    @Hidden\n+    @IntrinsicCandidate\n+    public static boolean isCompileConstant(boolean val) {\n+        return false;\n+    }\n+\n+    \/**\n+     * @see #isCompileConstant(boolean)\n+     *\/\n+    @Hidden\n+    @IntrinsicCandidate\n+    public static boolean isCompileConstant(byte val) {\n+        return false;\n+    }\n+\n+    \/**\n+     * @see #isCompileConstant(boolean)\n+     *\/\n+    @Hidden\n+    @IntrinsicCandidate\n+    public static boolean isCompileConstant(short val) {\n+        return false;\n+    }\n+\n+    \/**\n+     * @see #isCompileConstant(boolean)\n+     *\/\n+    @Hidden\n+    @IntrinsicCandidate\n+    public static boolean isCompileConstant(char val) {\n+        return false;\n+    }\n+\n+    \/**\n+     * @see #isCompileConstant(boolean)\n+     *\/\n+    @Hidden\n+    @IntrinsicCandidate\n+    public static boolean isCompileConstant(int val) {\n+        return false;\n+    }\n+\n+    \/**\n+     * @see #isCompileConstant(boolean)\n+     *\/\n+    @Hidden\n+    @IntrinsicCandidate\n+    public static boolean isCompileConstant(long val) {\n+        return false;\n+    }\n+\n+    \/**\n+     * @see #isCompileConstant(boolean)\n+     *\/\n+    @Hidden\n+    @IntrinsicCandidate\n+    public static boolean isCompileConstant(float val) {\n+        return false;\n+    }\n+\n+    \/**\n+     * @see #isCompileConstant(boolean)\n+     *\/\n+    @Hidden\n+    @IntrinsicCandidate\n+    public static boolean isCompileConstant(double val) {\n+        return false;\n+    }\n+\n+    \/**\n+     * @see #isCompileConstant(boolean)\n+     *\/\n+    @Hidden\n+    @IntrinsicCandidate\n+    public static boolean isCompileConstant(Object val) {\n+        return false;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ConstantSupport.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,322 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.internal.vm.ConstantSupport;\n+\n+\/*\n+ * @test\n+ * @bug 8324433\n+ * @summary Test that isCompileConstant is able to constant-fold the computation\n+ *          regarding constant inputs.\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.IsCompileConstantTests\n+ *\/\n+public class IsCompileConstantTests {\n+    private record Point(int x, int y) {}\n+\n+    private static final boolean BOOL_CONSTANT = true;\n+    private static final byte BYTE_CONSTANT = 3;\n+    private static final short SHORT_CONSTANT = 3;\n+    private static final char CHAR_CONSTANT = 3;\n+    private static final int INT_CONSTANT = 3;\n+    private static final long LONG_CONSTANT = 3;\n+    private static final float FLOAT_CONSTANT = 3;\n+    private static final double DOUBLE_CONSTANT = 3;\n+    private static final Point POINT_CONSTANT = new Point(1, 2);\n+\n+    private static final int[] LOOKUP_TABLE;\n+    static {\n+        LOOKUP_TABLE = new int[4];\n+        LOOKUP_TABLE[0] = 125;\n+        LOOKUP_TABLE[1] = 341;\n+        LOOKUP_TABLE[2] = 97;\n+        LOOKUP_TABLE[3] = 460;\n+    }\n+\n+    private boolean boolVariable = true;\n+    private byte byteVariable = 3;\n+    private short shortVariable = 3;\n+    private char charVariable = 3;\n+    private int intVariable = 3;\n+    private long longVariable = 3;\n+    private float floatVariable = 3;\n+    private double doubleVariable = 3;\n+    private Point pointVariable = new Point(1, 2);\n+    private int hashCache = pointVariable.hashCode();\n+\n+    @Test\n+    @IR(failOn = IRNode.LOAD)\n+    public int boolConstant() {\n+        return process(BOOL_CONSTANT);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"2\"})\n+    public int boolVariable() {\n+        return process(boolVariable);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOAD)\n+    public int byteConstant() {\n+        return process(BYTE_CONSTANT);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"2\"})\n+    public int byteVariable() {\n+        return process(byteVariable);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOAD)\n+    public int shortConstant() {\n+        return process(SHORT_CONSTANT);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"2\"})\n+    public int shortVariable() {\n+        return process(shortVariable);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOAD)\n+    public int charConstant() {\n+        return process(CHAR_CONSTANT);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"2\"})\n+    public int charVariable() {\n+        return process(charVariable);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOAD)\n+    public int intConstant() {\n+        return process(INT_CONSTANT);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"2\"})\n+    public int intVariable() {\n+        return process(intVariable);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOAD)\n+    public int longConstant() {\n+        return process(LONG_CONSTANT);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"2\"})\n+    public int longVariable() {\n+        return process(longVariable);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOAD)\n+    public int floatConstant() {\n+        return process(FLOAT_CONSTANT);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"2\"})\n+    public int floatVariable() {\n+        return process(floatVariable);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOAD)\n+    public int doubleConstant() {\n+        return process(DOUBLE_CONSTANT);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"2\"})\n+    public int doubleVariable() {\n+        return process(doubleVariable);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOAD)\n+    public int objectConstant() {\n+        return process(POINT_CONSTANT);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"1\"})\n+    public int objectVariable() {\n+        return process(pointVariable);\n+    }\n+\n+    @ForceInline\n+    public int process(boolean input) {\n+        if (ConstantSupport.isCompileConstant(input)) {\n+            if (input) {\n+                return 125;\n+            } else {\n+                return 341;\n+            }\n+        }\n+\n+        return LOOKUP_TABLE[input ? 1 : 0];\n+    }\n+\n+    @ForceInline\n+    public int process(byte input) {\n+        if (ConstantSupport.isCompileConstant(input)) {\n+            return switch(input) {\n+                case 0 -> 125;\n+                case 1 -> 341;\n+                case 2 -> 97;\n+                case 3 -> 460;\n+                default -> throw new AssertionError();\n+            };\n+        }\n+\n+        return LOOKUP_TABLE[input];\n+    }\n+\n+    @ForceInline\n+    public int process(short input) {\n+        if (ConstantSupport.isCompileConstant(input)) {\n+            return switch(input) {\n+                case 0 -> 125;\n+                case 1 -> 341;\n+                case 2 -> 97;\n+                case 3 -> 460;\n+                default -> throw new AssertionError();\n+            };\n+        }\n+\n+        return LOOKUP_TABLE[input];\n+    }\n+\n+    @ForceInline\n+    public int process(char input) {\n+        if (ConstantSupport.isCompileConstant(input)) {\n+            return switch(input) {\n+                case 0 -> 125;\n+                case 1 -> 341;\n+                case 2 -> 97;\n+                case 3 -> 460;\n+                default -> throw new AssertionError();\n+            };\n+        }\n+\n+        return LOOKUP_TABLE[input];\n+    }\n+\n+    @ForceInline\n+    public int process(int input) {\n+        if (ConstantSupport.isCompileConstant(input)) {\n+            return switch(input) {\n+                case 0 -> 125;\n+                case 1 -> 341;\n+                case 2 -> 97;\n+                case 3 -> 460;\n+                default -> throw new AssertionError();\n+            };\n+        }\n+\n+        return LOOKUP_TABLE[input];\n+    }\n+\n+    @ForceInline\n+    public int process(long input) {\n+        if (ConstantSupport.isCompileConstant(input)) {\n+            if (input == 0) {\n+                return 125;\n+            } else if (input == 1) {\n+                return 341;\n+            } else if (input == 2) {\n+                return 97;\n+            } else if (input == 3) {\n+                return 460;\n+            } else {\n+                throw new AssertionError();\n+            }\n+        }\n+\n+        return LOOKUP_TABLE[(int)input];\n+    }\n+\n+    @ForceInline\n+    public int process(float input) {\n+        if (ConstantSupport.isCompileConstant(input)) {\n+            if (input == 0) {\n+                return 125;\n+            } else if (input == 1) {\n+                return 341;\n+            } else if (input == 2) {\n+                return 97;\n+            } else if (input == 3) {\n+                return 460;\n+            } else {\n+                throw new AssertionError();\n+            }\n+        }\n+\n+        return LOOKUP_TABLE[(int)input];\n+    }\n+\n+    @ForceInline\n+    public int process(double input) {\n+        if (ConstantSupport.isCompileConstant(input)) {\n+            if (input == 0) {\n+                return 125;\n+            } else if (input == 1) {\n+                return 341;\n+            } else if (input == 2) {\n+                return 97;\n+            } else if (input == 3) {\n+                return 460;\n+            } else {\n+                throw new AssertionError();\n+            }\n+        }\n+\n+        return LOOKUP_TABLE[(int)input];\n+    }\n+\n+    @ForceInline\n+    public int process(Point input) {\n+        if (ConstantSupport.isCompileConstant(input)) {\n+            return input.hashCode();\n+        }\n+\n+        return hashCache;\n+    }\n+\n+    public static void main(String[] args) {\n+        var test = new TestFramework(IsCompileConstantTests.class);\n+        test.addFlags(\"--add-exports=java.base\/jdk.internal.vm=ALL-UNNAMED\");\n+        test.start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/IsCompileConstantTests.java","additions":322,"deletions":0,"binary":false,"changes":322,"status":"added"}]}