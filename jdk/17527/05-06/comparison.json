{"files":[{"patch":"@@ -31,1 +31,2 @@\n- * Just-in-time-compiler-related queries\n+ * This class defines methods to test if a value has been evaluated to a\n+ * compile-time constant by the HotSpot VM.\n@@ -35,1 +36,1 @@\n-     * Determine if {@code expr} can be evaluated to a constant value by the JIT\n+     * Determine if {@code val} can be proved to be a constant by the JIT\n@@ -37,3 +38,2 @@\n-     * to {@code true} by the JIT compiler, while\n-     * {@code isCompileConstant(random.nextLong())} will likely be evaluated\n-     * to {@code false}.\n+     * to {@code true}, while {@code isCompileConstant(random.nextLong())}\n+     * will likely be evaluated to {@code false}.\n@@ -41,2 +41,3 @@\n-     * <p>Note that the JIT compiler is responsible to change the return value\n-     * of this method to {@code true}, the interpreter always returns {@code false}.\n+     * <p>Note that the JIT compiler is responsible for changing the return\n+     * value of this method to {@code true}, the interpreter always returns\n+     * {@code false}.\n@@ -47,4 +48,1 @@\n-     * {@code expr}. E.g. for a runtime variable, looking up a hashmap may be\n-     * the most efficient look up method, however, if the look up table is\n-     * constant, it may be better to use a chain of if-else in cases where the\n-     * input is also a constant.\n+     * {@code val}.\n@@ -52,3 +50,29 @@\n-     * @param expr the expression to be evaluated\n-     * @return {@code true} if the JIT compiler determines the {@code expr} is\n-     *         always evaluated to a constant value, {@code false} otherwise\n+     * <p>Since we will not have profile information in the branch that this\n+     * method returns {@code true}, the compiler may have a harder time\n+     * optimizing it. As a result, apart from simple cases, this technique\n+     * should be used with care.\n+     *\n+     * <p>Usage example:\n+     *\n+     * {@snippet lang=java:\n+     * void checkIndex(int index, int length) {\n+     *     \/\/ Normally, we check length >= 0 && index u< length because\n+     *     \/\/ length >= 0 can often be hoisted out of loops, however, if\n+     *     \/\/ we know that index >= 0, just signed compare index and length\n+     *     boolean indexPos = index >= 0;\n+     *     if (isCompileConstant(indexPos) && indexPos) {\n+     *         if (index >= length) {\n+     *             throw new IndexOutOfBoundsException();\n+     *         }\n+     *         return;\n+     *     }\n+     *\n+     *     if (length < 0 || Integer.compareUnsigned(index, length) >= 0) {\n+     *         throw new IndexOutOfBoundsException();\n+     *     }\n+     * }\n+     * }\n+     *\n+     * @param val the tested value\n+     * @return {@code true} if the JIT compiler determines that {@code val} is\n+     *         a constant, {@code false} otherwise\n@@ -58,1 +82,1 @@\n-    public static boolean isCompileConstant(boolean expr) {\n+    public static boolean isCompileConstant(boolean val) {\n@@ -67,1 +91,1 @@\n-    public static boolean isCompileConstant(byte expr) {\n+    public static boolean isCompileConstant(byte val) {\n@@ -76,1 +100,1 @@\n-    public static boolean isCompileConstant(short expr) {\n+    public static boolean isCompileConstant(short val) {\n@@ -85,1 +109,1 @@\n-    public static boolean isCompileConstant(char expr) {\n+    public static boolean isCompileConstant(char val) {\n@@ -94,1 +118,1 @@\n-    public static boolean isCompileConstant(int expr) {\n+    public static boolean isCompileConstant(int val) {\n@@ -103,1 +127,1 @@\n-    public static boolean isCompileConstant(long expr) {\n+    public static boolean isCompileConstant(long val) {\n@@ -112,1 +136,1 @@\n-    public static boolean isCompileConstant(float expr) {\n+    public static boolean isCompileConstant(float val) {\n@@ -121,1 +145,1 @@\n-    public static boolean isCompileConstant(double expr) {\n+    public static boolean isCompileConstant(double val) {\n@@ -130,1 +154,1 @@\n-    public static boolean isCompileConstant(Object expr) {\n+    public static boolean isCompileConstant(Object val) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ConstantSupport.java","additions":47,"deletions":23,"binary":false,"changes":70,"status":"modified"}]}