{"files":[{"patch":"@@ -51,0 +51,1 @@\n+import java.util.function.Function;\n@@ -983,0 +984,1 @@\n+\n@@ -989,1 +991,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(baseloc, Locale::createLocale);\n+            return LOCALE_CACHE.computeIfAbsent(baseloc, LOCALE_LOOKUP);\n@@ -992,1 +994,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(key, Locale::createLocale);\n+            return LOCALE_CACHE.computeIfAbsent(key, LOCALE_LOOKUP);\n@@ -996,4 +998,18 @@\n-    private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n-    private static Locale createLocale(Object key) {\n-        if (key instanceof BaseLocale base) {\n-            return new Locale(base, null);\n+    private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n+            = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+\n+    private static final LocaleKey LOCALE_LOOKUP = new LocaleKey();\n+\n+    private static final class LocaleKey implements Function<Object, Locale> {\n+\n+        @Override\n+        public Locale apply(Object key) {\n+            return createLocale(key);\n+        }\n+\n+        private Locale createLocale(Object key) {\n+            if (key instanceof BaseLocale base) {\n+                return new Locale(base, null);\n+            }\n+            LocaleKey lk = (LocaleKey)key;\n+            return new Locale(lk.base, lk.exts);\n@@ -1001,3 +1017,0 @@\n-        LocaleKey lk = (LocaleKey)key;\n-        return new Locale(lk.base, lk.exts);\n-    }\n@@ -1005,1 +1018,0 @@\n-    private static final class LocaleKey {\n@@ -1010,0 +1022,6 @@\n+        private LocaleKey() {\n+            base = null;\n+            exts = null;\n+            hash = 0;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":28,"deletions":10,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -102,0 +102,15 @@\n+    \/**\n+     * @return a supplier to create a {@code ConcurrentHashMap} appropriate for use in the\n+     *         create methods.\n+     * @param <K> the type of keys maintained by the new map\n+     * @param <V> the type of mapped values\n+     *\/\n+    public static <K, V> Supplier<Map<ReferenceKey<K>, V>> concurrentHashMapSupplier() {\n+        return new Supplier<>() {\n+            @Override\n+            public Map<ReferenceKey<K>, V> get() {\n+                return new ConcurrentHashMap<>();\n+            }\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeyMap.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -78,0 +78,14 @@\n+    \/**\n+     * @return a supplier to create a {@code ConcurrentHashMap} appropriate for use in the\n+     *         create methods.\n+     * @param <E> the type of elements maintained by this set\n+     *\/\n+    public static <E> Supplier<Map<ReferenceKey<E>, ReferenceKey<E>>> concurrentHashMapSupplier() {\n+        return new Supplier<>() {\n+            @Override\n+            public Map<ReferenceKey<E>, ReferenceKey<E>> get() {\n+                return new ConcurrentHashMap<>();\n+            }\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeySet.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.UnaryOperator;\n@@ -96,1 +96,1 @@\n-            ReferencedKeySet.create(true, ConcurrentHashMap::new);\n+            ReferencedKeySet.create(true, ReferencedKeySet.concurrentHashMapSupplier());\n@@ -167,5 +167,11 @@\n-            (b) -> new BaseLocale(\n-                LocaleUtils.toLowerString(b.language).intern(),\n-                LocaleUtils.toTitleString(b.script).intern(),\n-                LocaleUtils.toUpperString(b.region).intern(),\n-                b.variant.intern()));\n+                \/\/ Avoid lambdas since this may be on the bootstrap path in many locales\n+                new UnaryOperator<BaseLocale>() {\n+                    @Override\n+                    public BaseLocale apply(BaseLocale b) {\n+                        return new BaseLocale(\n+                                LocaleUtils.toLowerString(b.language).intern(),\n+                                LocaleUtils.toTitleString(b.script).intern(),\n+                                LocaleUtils.toUpperString(b.region).intern(),\n+                                b.variant.intern());\n+                    }\n+                });\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"}]}