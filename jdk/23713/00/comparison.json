{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,1 +175,1 @@\n-            } catch (Throwable t) {\n+            } catch (RejectedExecutionException t) {\n@@ -181,1 +181,1 @@\n-        private void shutdown() {\n+        void shutdown() {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350019\n+ * @summary Verifies `HttpClientImpl.DelegatingExecutor` behavior\n+ * @modules java.net.http\/jdk.internal.net.http\n+ * @run junit java.net.http\/jdk.internal.net.http.DelegatingExecutorTest\n+ *\/\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/DelegatingExecutorTestDriver.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http;\n+\n+import jdk.internal.net.http.HttpClientImpl.DelegatingExecutor;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class DelegatingExecutorTest {\n+\n+    @Test\n+    public void testInlineExecution() {\n+        Thread callSiteThread = Thread.currentThread();\n+        Thread[] runSiteThreadRef = {null};\n+        new DelegatingExecutor(() -> false, null, null)\n+                .execute(() -> runSiteThreadRef[0] = Thread.currentThread());\n+        assertSame(callSiteThread, runSiteThreadRef[0]);\n+    }\n+\n+    @Test\n+    public void testDelegateDeferral() {\n+        ImmediateExecutor delegate = new ImmediateExecutor();\n+        Runnable task = () -> {};\n+        new DelegatingExecutor(() -> true, delegate, null).execute(task);\n+        delegate.assertReception(task);\n+    }\n+\n+    @Test\n+    public void testRejectedExecutionException() throws InterruptedException {\n+\n+        \/\/ Create a deterministically throwing task\n+        RuntimeException error = new RejectedExecutionException();\n+        FirstThrowingAndThenCompletingRunnable task = new FirstThrowingAndThenCompletingRunnable(error);\n+\n+        \/\/ Create a recording delegate\n+        ImmediateExecutor delegate = new ImmediateExecutor();\n+\n+        \/\/ Create a recording error handler\n+        List<Runnable> reportedTasks = new ArrayList<>();\n+        List<Throwable> reportedErrors = new ArrayList<>();\n+        BiConsumer<Runnable, Throwable> errorHandler = (task_, error_) -> {\n+            synchronized (this) {\n+                reportedTasks.add(task_);\n+                reportedErrors.add(error_);\n+            }\n+        };\n+\n+        \/\/ Verify the initial failing execution\n+        new DelegatingExecutor(() -> true, delegate, errorHandler).execute(task);\n+        delegate.assertReception(task);\n+\n+        \/\/ Verify fallback to the async. pool\n+        assertEquals(1, reportedTasks.size());\n+        assertSame(task, reportedTasks.getFirst());\n+        assertEquals(1, reportedErrors.size());\n+        assertSame(error, reportedErrors.getFirst());\n+        boolean completed = task.completionLatch.await(5, TimeUnit.SECONDS);\n+        assertTrue(completed);\n+\n+    }\n+\n+    @Test\n+    public void testNotRejectedExecutionException() {\n+\n+        \/\/ Create a deterministically throwing task\n+        RuntimeException error = new RuntimeException();\n+        FirstThrowingAndThenCompletingRunnable task = new FirstThrowingAndThenCompletingRunnable(error);\n+\n+        \/\/ Create a recording delegate\n+        ImmediateExecutor delegate = new ImmediateExecutor();\n+\n+        \/\/ Verify the immediate exception propagation\n+        Throwable thrownError = assertThrows(\n+                Throwable.class,\n+                () -> new DelegatingExecutor(() -> true, delegate, null).execute(task));\n+        delegate.assertReception(task);\n+        assertSame(error, thrownError);\n+\n+    }\n+\n+    private static final class ImmediateExecutor implements Executor {\n+\n+        private final List<Runnable> receivedTasks = new ArrayList<>();\n+\n+        @Override\n+        public synchronized void execute(Runnable task) {\n+            receivedTasks.add(task);\n+            task.run();\n+        }\n+\n+        private synchronized void assertReception(Runnable... tasks) {\n+            assertSame(tasks.length, receivedTasks.size());\n+            for (int taskIndex = 0; taskIndex < tasks.length; taskIndex++) {\n+                assertSame(tasks[taskIndex], receivedTasks.get(taskIndex));\n+            }\n+        }\n+\n+    }\n+\n+    private static final class FirstThrowingAndThenCompletingRunnable implements Runnable {\n+\n+        private final AtomicInteger invocationCounter = new AtomicInteger(0);\n+\n+        private final CountDownLatch completionLatch = new CountDownLatch(1);\n+\n+        private final RuntimeException exception;\n+\n+        private FirstThrowingAndThenCompletingRunnable(RuntimeException exception) {\n+            this.exception = exception;\n+        }\n+\n+        @Override\n+        public void run() {\n+            switch (invocationCounter.getAndIncrement()) {\n+                case 0: throw exception;\n+                case 1: { completionLatch.countDown(); break; }\n+                default: fail();\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testDelegateShutdown() {\n+        AtomicInteger invocationCounter = new AtomicInteger();\n+        try (ExecutorService delegate = new ThreadPoolExecutor(1, 1, 1, TimeUnit.DAYS, new LinkedBlockingQueue<>()) {\n+            @Override\n+            public void shutdown() {\n+                invocationCounter.incrementAndGet();\n+                super.shutdown();\n+            }\n+        }) {\n+            new DelegatingExecutor(() -> true, delegate, null).shutdown();\n+            assertEquals(1, invocationCounter.get());\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/DelegatingExecutorTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"}]}