{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import org.junit.jupiter.api.Nested;\n@@ -52,2 +53,1 @@\n-    private static Path expect;\n-\n+    @Nested\n@@ -55,5 +55,91 @@\n-    @BeforeAll\n-    public static void prepareTTY() throws Exception {\n-        expect = Paths.get(\"\/usr\/bin\/expect\"); \/\/ os-specific path\n-        if (!Files.exists(expect) || !Files.isExecutable(expect)) {\n-            throw new SkippedException(\"'\" + expect + \"' not found\");\n+    public class OSSpecificTests {\n+\n+        private static Path expect;\n+\n+        @BeforeAll\n+        public static void prepareTTY() throws Exception {\n+            expect = Paths.get(\"\/usr\/bin\/expect\"); \/\/ os-specific path\n+            if (!Files.exists(expect) || !Files.isExecutable(expect)) {\n+                throw new SkippedException(\"'\" + expect + \"' not found\");\n+            }\n+            \/\/ show terminal settings to aid debugging if any tests below fail\n+            var outputAnalyzer = ProcessTools.executeProcess(expect.toString(), \"-c\", \"\"\"\n+                    spawn -noecho stty -a\n+                    expect eof\n+                    \"\"\");\n+            outputAnalyzer.reportDiagnosticSummary();\n+        }\n+\n+        \/*\n+         * Unlike printTest, which tests a _default_ console that is normally\n+         * jdk.internal.org.jline.JdkConsoleProviderImpl, this test tests\n+         * jdk.internal.io.JdkConsoleImpl. Those console implementations operate\n+         * in different conditions and, thus, are tested separately.\n+         *\n+         * To test jdk.internal.io.JdkConsoleImpl one needs to ensure that both\n+         * conditions are met:\n+         *\n+         *   - a non-existent console provider is requested\n+         *   - isatty is true\n+         *\n+         * To achieve isatty, the test currently uses the EXPECT(1) Unix command,\n+         * which does not work for Windows. Later, a library like pty4j or JPty\n+         * might be used instead of EXPECT, to cover both Unix and Windows.\n+         *\/\n+        @ParameterizedTest\n+        @ValueSource(strings = {\"println\", \"print\"})\n+        public void outputTestInteractive(String mode) throws Exception {\n+            var testSrc = System.getProperty(\"test.src\", \".\");\n+            OutputAnalyzer output = ProcessTools.executeProcess(\n+                    expect.toString(),\n+                    Path.of(testSrc, \"output.exp\").toAbsolutePath().toString(),\n+                    System.getProperty(\"test.jdk\") + \"\/bin\/java\",\n+                    \"--enable-preview\",\n+                    \"-Djdk.console=gibberish\",\n+                    Path.of(testSrc, \"Output.java\").toAbsolutePath().toString(),\n+                    mode);\n+            assertEquals(0, output.getExitValue());\n+            assertTrue(output.getStderr().isEmpty());\n+            output.reportDiagnosticSummary();\n+            String out = output.getStdout();\n+            \/\/ The first half of the output is produced by Console, the second\n+            \/\/ half is produced by IO: those halves must match.\n+            \/\/ Executing Console and IO in the same VM (as opposed to\n+            \/\/ consecutive VM runs, which are cleaner) to be able to compare string\n+            \/\/ representation of objects.\n+            assertFalse(out.isBlank());\n+            assertEquals(out.substring(0, out.length() \/ 2),\n+                    out.substring(out.length() \/ 2));\n+        }\n+\n+        \/*\n+         * This tests simulates terminal interaction (isatty), to check that the\n+         * prompt is output.\n+         *\n+         * To simulate a terminal, the test currently uses the EXPECT(1) Unix\n+         * command, which does not work for Windows. Later, a library like pty4j\n+         * or JPty might be used instead of EXPECT, to cover both Unix and Windows.\n+         *\/\n+        @ParameterizedTest\n+        @MethodSource(\"args\")\n+        public void inputTestInteractive(String console, String prompt) throws Exception {\n+            var testSrc = System.getProperty(\"test.src\", \".\");\n+            var command = new ArrayList<String>();\n+            command.add(expect.toString());\n+            command.add(Path.of(testSrc, \"input.exp\").toAbsolutePath().toString());\n+            command.add(System.getProperty(\"test.jdk\") + \"\/bin\/java\");\n+            command.add(\"--enable-preview\");\n+            if (console != null)\n+                command.add(\"-Djdk.console=\" + console);\n+            command.add(Path.of(testSrc, \"Input.java\").toAbsolutePath().toString());\n+            command.add(prompt == null ? \"0\" : \"1\");\n+            command.add(String.valueOf(prompt));\n+            OutputAnalyzer output = ProcessTools.executeProcess(command.toArray(new String[]{}));\n+            output.reportDiagnosticSummary();\n+            assertEquals(0, output.getExitValue());\n+        }\n+\n+        public static Stream<Arguments> args() {\n+            \/\/ cross product: consoles x prompts\n+            return Stream.of(null, \"gibberish\").flatMap(console -> Stream.of(null, \"?\", \"%s\")\n+                    .map(prompt -> new String[]{console, prompt}).map(Arguments::of));\n@@ -61,6 +147,0 @@\n-        \/\/ show terminal settings to aid debugging if any tests below fail\n-        var outputAnalyzer = ProcessTools.executeProcess(expect.toString(), \"-c\", \"\"\"\n-                spawn -noecho stty -a\n-                expect eof\n-                \"\"\");\n-        outputAnalyzer.reportDiagnosticSummary();\n@@ -90,77 +170,0 @@\n-    \/*\n-     * Unlike printTest, which tests a _default_ console that is normally\n-     * jdk.internal.org.jline.JdkConsoleProviderImpl, this test tests\n-     * jdk.internal.io.JdkConsoleImpl. Those console implementations operate\n-     * in different conditions and, thus, are tested separately.\n-     *\n-     * To test jdk.internal.io.JdkConsoleImpl one needs to ensure that both\n-     * conditions are met:\n-     *\n-     *   - a non-existent console provider is requested\n-     *   - isatty is true\n-     *\n-     * To achieve isatty, the test currently uses the EXPECT(1) Unix command,\n-     * which does not work for Windows. Later, a library like pty4j or JPty\n-     * might be used instead of EXPECT, to cover both Unix and Windows.\n-     *\/\n-    @ParameterizedTest\n-    @EnabledOnOs({OS.LINUX, OS.MAC})\n-    @ValueSource(strings = {\"println\", \"print\"})\n-    public void outputTestInteractive(String mode) throws Exception {\n-        var testSrc = System.getProperty(\"test.src\", \".\");\n-        OutputAnalyzer output = ProcessTools.executeProcess(\n-                expect.toString(),\n-                Path.of(testSrc, \"output.exp\").toAbsolutePath().toString(),\n-                System.getProperty(\"test.jdk\") + \"\/bin\/java\",\n-                \"--enable-preview\",\n-                \"-Djdk.console=gibberish\",\n-                Path.of(testSrc, \"Output.java\").toAbsolutePath().toString(),\n-                mode);\n-        assertEquals(0, output.getExitValue());\n-        assertTrue(output.getStderr().isEmpty());\n-        output.reportDiagnosticSummary();\n-        String out = output.getStdout();\n-        \/\/ The first half of the output is produced by Console, the second\n-        \/\/ half is produced by IO: those halves must match.\n-        \/\/ Executing Console and IO in the same VM (as opposed to\n-        \/\/ consecutive VM runs, which are cleaner) to be able to compare string\n-        \/\/ representation of objects.\n-        assertFalse(out.isBlank());\n-        assertEquals(out.substring(0, out.length() \/ 2),\n-                out.substring(out.length() \/ 2));\n-    }\n-\n-\n-    \/*\n-     * This tests simulates terminal interaction (isatty), to check that the\n-     * prompt is output.\n-     *\n-     * To simulate a terminal, the test currently uses the EXPECT(1) Unix\n-     * command, which does not work for Windows. Later, a library like pty4j\n-     * or JPty might be used instead of EXPECT, to cover both Unix and Windows.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"args\")\n-    @EnabledOnOs({OS.LINUX, OS.MAC})\n-    public void inputTestInteractive(String console, String prompt) throws Exception {\n-        var testSrc = System.getProperty(\"test.src\", \".\");\n-        var command = new ArrayList<String>();\n-        command.add(expect.toString());\n-        command.add(Path.of(testSrc, \"input.exp\").toAbsolutePath().toString());\n-        command.add(System.getProperty(\"test.jdk\") + \"\/bin\/java\");\n-        command.add(\"--enable-preview\");\n-        if (console != null)\n-            command.add(\"-Djdk.console=\" + console);\n-        command.add(Path.of(testSrc, \"Input.java\").toAbsolutePath().toString());\n-        command.add(prompt == null ? \"0\" : \"1\");\n-        command.add(String.valueOf(prompt));\n-        OutputAnalyzer output = ProcessTools.executeProcess(command.toArray(new String[]{}));\n-        output.reportDiagnosticSummary();\n-        assertEquals(0, output.getExitValue());\n-    }\n-\n-    public static Stream<Arguments> args() {\n-        \/\/ cross product: consoles x prompts\n-        return Stream.of(null, \"gibberish\").flatMap(console -> Stream.of(null, \"?\", \"%s\")\n-                .map(prompt -> new String[]{console, prompt}).map(Arguments::of));\n-    }\n","filename":"test\/jdk\/java\/io\/IO\/IO.java","additions":93,"deletions":90,"binary":false,"changes":183,"status":"modified"}]}