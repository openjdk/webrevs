{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-\n@@ -39,1 +38,0 @@\n-import sun.security.action.GetPropertyAction;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/GraphicsEnvironment.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,3 +42,2 @@\n-        \/\/ On Windows, we assume we can always create headful apps.\n-        \/\/ Here is where we can add code that would actually check.\n-        return false;\n+        \/\/ If we don't find usable displays, we run headless.\n+        return !Win32GraphicsEnvironment.hasDisplays();\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/PlatformGraphicsInfo.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,2 @@\n+    static final boolean hasDisplays;\n+\n@@ -63,1 +65,1 @@\n-        initDisplayWrapper();\n+        hasDisplays = initDisplay();\n@@ -89,1 +91,1 @@\n-    private static native void initDisplay();\n+    private static native boolean initDisplay();\n@@ -91,6 +93,2 @@\n-    private static boolean displayInitialized;      \/\/ = false;\n-    public static void initDisplayWrapper() {\n-        if (!displayInitialized) {\n-            displayInitialized = true;\n-            initDisplay();\n-        }\n+    static boolean hasDisplays() {\n+        return hasDisplays;\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/Win32GraphicsEnvironment.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,5 @@\n+typedef struct {\n+    int monitorCounter;\n+    int monitorLimit;\n+    HMONITOR* hmpMonitors;\n+} MonitorData;\n@@ -89,1 +94,0 @@\n-\/* Some helper functions (from awt_MMStub.h\/cpp) *\/\n@@ -91,3 +95,20 @@\n-int g_nMonitorCounter;\n-int g_nMonitorLimit;\n-HMONITOR* g_hmpMonitors;\n+\/\/ Only monitors where CreateDC does not fail are valid\n+static BOOL IsValidMonitor(HMONITOR hMon)\n+{\n+    MONITORINFOEX mieInfo;\n+    memset((void*)(&mieInfo), 0, sizeof(MONITORINFOEX));\n+    mieInfo.cbSize = sizeof(MONITORINFOEX);\n+    if (!::GetMonitorInfo(hMon, (LPMONITORINFOEX)(&mieInfo))) {\n+        J2dTraceLn1(J2D_TRACE_INFO, \"Devices::IsValidMonitor: GetMonitorInfo failed for monitor with handle %p\", hMon);\n+        return FALSE;\n+    }\n+\n+    HDC hDC = CreateDC(mieInfo.szDevice, NULL, NULL, NULL);\n+    if (NULL == hDC) {\n+        J2dTraceLn2(J2D_TRACE_INFO, \"Devices::IsValidMonitor: CreateDC failed for monitor with handle %p, device: %S\", hMon, mieInfo.szDevice);\n+        return FALSE;\n+    }\n+\n+    ::DeleteDC(hDC);\n+    return TRUE;\n+}\n@@ -96,1 +117,1 @@\n-BOOL WINAPI clb_fCountMonitors(HMONITOR hMon, HDC hDC, LPRECT rRect, LPARAM lP)\n+static BOOL WINAPI clb_fCountMonitors(HMONITOR hMon, HDC hDC, LPRECT rRect, LPARAM lpMonitorCounter)\n@@ -98,1 +119,4 @@\n-    g_nMonitorCounter ++;\n+    if (IsValidMonitor(hMon)) {\n+        (*((int *)lpMonitorCounter))++;\n+    }\n+\n@@ -102,1 +126,1 @@\n-int WINAPI CountMonitors(void)\n+static int WINAPI CountMonitors(void)\n@@ -104,4 +128,3 @@\n-    g_nMonitorCounter = 0;\n-    ::EnumDisplayMonitors(NULL, NULL, clb_fCountMonitors, 0L);\n-    return g_nMonitorCounter;\n-\n+    int monitorCounter = 0;\n+    ::EnumDisplayMonitors(NULL, NULL, clb_fCountMonitors, (LPARAM)&monitorCounter);\n+    return monitorCounter;\n@@ -111,1 +134,1 @@\n-BOOL WINAPI clb_fCollectMonitors(HMONITOR hMon, HDC hDC, LPRECT rRect, LPARAM lP)\n+static BOOL WINAPI clb_fCollectMonitors(HMONITOR hMon, HDC hDC, LPRECT rRect, LPARAM lpMonitorData)\n@@ -113,4 +136,4 @@\n-\n-    if ((g_nMonitorCounter < g_nMonitorLimit) && (NULL != g_hmpMonitors)) {\n-        g_hmpMonitors[g_nMonitorCounter] = hMon;\n-        g_nMonitorCounter ++;\n+    MonitorData* pMonitorData = (MonitorData *)lpMonitorData;\n+    if ((pMonitorData->monitorCounter < pMonitorData->monitorLimit) && (IsValidMonitor(hMon))) {\n+        pMonitorData->hmpMonitors[pMonitorData->monitorCounter] = hMon;\n+        pMonitorData->monitorCounter++;\n@@ -122,1 +145,1 @@\n-int WINAPI CollectMonitors(HMONITOR* hmpMonitors, int nNum)\n+static int WINAPI CollectMonitors(HMONITOR* hmpMonitors, int nNum)\n@@ -124,2 +147,0 @@\n-    int retCode = 0;\n-\n@@ -127,13 +148,8 @@\n-\n-        g_nMonitorCounter   = 0;\n-        g_nMonitorLimit     = nNum;\n-        g_hmpMonitors       = hmpMonitors;\n-\n-        ::EnumDisplayMonitors(NULL, NULL, clb_fCollectMonitors, 0L);\n-\n-        retCode             = g_nMonitorCounter;\n-\n-        g_nMonitorCounter   = 0;\n-        g_nMonitorLimit     = 0;\n-        g_hmpMonitors       = NULL;\n-\n+        MonitorData monitorData;\n+        monitorData.monitorCounter = 0;\n+        monitorData.monitorLimit = nNum;\n+        monitorData.hmpMonitors = hmpMonitors;\n+        ::EnumDisplayMonitors(NULL, NULL, clb_fCollectMonitors, (LPARAM)&monitorData);\n+        return monitorData.monitorCounter;\n+    } else {\n+        return 0;\n@@ -141,1 +157,0 @@\n-    return retCode;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/Devices.cpp","additions":49,"deletions":34,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-extern void initScreens(JNIEnv *env);\n+extern jboolean initScreens(JNIEnv *env);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Toolkit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,0 +182,4 @@\n+    VERIFY(hBMDC != NULL);\n+    if (hBMDC == NULL) {\n+        return;\n+    }\n@@ -183,0 +187,5 @@\n+    VERIFY(hBM != NULL);\n+    if (hBM == NULL) {\n+        VERIFY(::DeleteDC(hBMDC));\n+        return;\n+    }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsDevice.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-void initScreens(JNIEnv *env) {\n+jboolean initScreens(JNIEnv *env) {\n@@ -42,1 +42,0 @@\n-        return;\n@@ -44,0 +43,6 @@\n+\n+    \/\/ return true if at least one device is available\n+    Devices * devices = Devices::GetInstance();\n+    int numDevices = devices->GetNumDevices();\n+    devices->Release();\n+    return numDevices > 0 ? JNI_TRUE : JNI_FALSE;\n@@ -138,1 +143,1 @@\n- * Signature: ()V\n+ * Signature: ()Z\n@@ -140,1 +145,1 @@\n-JNIEXPORT void JNICALL\n+JNIEXPORT jboolean JNICALL\n@@ -149,1 +154,1 @@\n-    initScreens(env);\n+    return initScreens(env);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsEnv.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n- * @requires !vm.debug | os.family != \"windows\"\n","filename":"test\/jdk\/javax\/swing\/reliability\/HangDuringStaticInitialization.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}