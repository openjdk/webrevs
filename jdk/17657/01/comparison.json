{"files":[{"patch":"@@ -53,1 +53,0 @@\n-  _data_entry(arena(), 8,  0, nullptr),                     \/\/ nodes with all inputs from outside\n@@ -524,0 +523,14 @@\n+  \/\/ Find memory slices\n+  analyze_memory_slices();\n+\n+  if (!is_marked_reduction_loop() &&\n+      _mem_slice_head.is_empty()) {\n+#ifndef PRODUCT\n+    if (is_trace_superword_any()) {\n+      tty->print_cr(\"\\nNo reductions or memory slices found, abort SuperWord.\");\n+      tty->cr();\n+    }\n+#endif\n+    return false;\n+  }\n+\n@@ -526,1 +539,7 @@\n-    return false; \/\/ Exit if no interesting nodes or complex graph.\n+#ifndef PRODUCT\n+    if (is_trace_superword_any()) {\n+      tty->print_cr(\"\\nSuperWord::construct_bb failed: abort SuperWord\");\n+      tty->cr();\n+    }\n+#endif\n+    return false;\n@@ -529,0 +548,3 @@\n+  \/\/ Ensure extra info is allocated.\n+  initialize_node_info();\n+\n@@ -899,0 +921,30 @@\n+void SuperWord::analyze_memory_slices() {\n+  assert(_mem_slice_head.length() == 0, \"mem_slice_head is empty\");\n+  assert(_mem_slice_tail.length() == 0, \"mem_slice_tail is empty\");\n+\n+  \/\/ Iterate over all memory phis\n+  for (DUIterator_Fast imax, i = lp()->fast_outs(imax); i < imax; i++) {\n+    PhiNode* phi = lp()->fast_out(i)->isa_Phi();\n+    if (phi != nullptr && in_bb(phi) && phi->is_memory_phi()) {\n+      Node* phi_tail = phi->in(LoopNode::LoopBackControl);\n+      if (phi_tail != phi->in(LoopNode::EntryControl)) {\n+        _mem_slice_head.push(phi);\n+        _mem_slice_tail.push(phi_tail->as_Mem());\n+      }\n+    }\n+  }\n+\n+  NOT_PRODUCT( if (is_trace_superword_memory_slices()) { print_memory_slices(); } )\n+}\n+\n+#ifndef PRODUCT\n+void SuperWord::print_memory_slices() {\n+  tty->print_cr(\"\\nSuperWord::print_memory_slices: %s\",\n+                _mem_slice_head.length() > 0 ? \"\" : \"NONE\");\n+  for (int m = 0; m < _mem_slice_head.length(); m++) {\n+    tty->print(\"%6d \", m);  _mem_slice_head.at(m)->dump();\n+    tty->print(\"       \");  _mem_slice_tail.at(m)->dump();\n+  }\n+}\n+#endif\n+\n@@ -2953,2 +3005,0 @@\n-  Node* entry = bb();\n-\n@@ -2956,3 +3006,0 @@\n-  assert(_data_entry.length() == 0,     \"data_entry is empty\");\n-  assert(_mem_slice_head.length() == 0, \"mem_slice_head is empty\");\n-  assert(_mem_slice_tail.length() == 0, \"mem_slice_tail is empty\");\n@@ -2960,5 +3007,5 @@\n-  \/\/ Find non-control nodes with no inputs from within block,\n-  \/\/ create a temporary map from node _idx to bb_idx for use\n-  \/\/ by the visited and post_visited sets,\n-  \/\/ and count number of nodes in block.\n-  int bb_ct = 0;\n+  \/\/ First pass over loop body:\n+  \/\/  (1) Check that there are no unwanted nodes (LoadStore, MergeMem, data Proj).\n+  \/\/  (2) Count number of nodes, and create a temporary map (_idx -> bb_idx).\n+  \/\/  (3) Verify that all non-ctrl nodes have an input inside the loop.\n+  int block_count = 0;\n@@ -2966,1 +3013,1 @@\n-    Node *n = lpt()->_body.at(i);\n+    Node* n = lpt()->_body.at(i);\n@@ -2969,0 +3016,2 @@\n+      block_count++;\n+\n@@ -2973,0 +3022,6 @@\n+#ifndef PRODUCT\n+        if (is_trace_superword_any()) {\n+          tty->print_cr(\"SuperWord::construct_bb: fails because of unhandled node:\");\n+          n->dump();\n+        }\n+#endif\n@@ -2975,1 +3030,2 @@\n-      bb_ct++;\n+\n+#ifdef ASSERT\n@@ -2980,1 +3036,1 @@\n-          if (def && in_bb(def)) {\n+          if (def != nullptr && in_bb(def)) {\n@@ -2985,20 +3041,1 @@\n-        if (!found) {\n-          assert(n != entry, \"can't be entry\");\n-          _data_entry.push(n);\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Find memory slices (head and tail)\n-  for (DUIterator_Fast imax, i = lp()->fast_outs(imax); i < imax; i++) {\n-    Node *n = lp()->fast_out(i);\n-    if (in_bb(n) && n->is_memory_phi()) {\n-      Node* n_tail  = n->in(LoopNode::LoopBackControl);\n-      if (n_tail != n->in(LoopNode::EntryControl)) {\n-        if (!n_tail->is_Mem()) {\n-          assert(n_tail->is_Mem(), \"unexpected node for memory slice: %s\", n_tail->Name());\n-          return false; \/\/ Bailout\n-        }\n-        _mem_slice_head.push(n);\n-        _mem_slice_tail.push(n_tail);\n+        assert(found, \"every non-cfg node must have an input that is also inside the loop\");\n@@ -3006,0 +3043,1 @@\n+#endif\n@@ -3009,2 +3047,1 @@\n-  \/\/ Create an RPO list of nodes in block\n-\n+  \/\/ Create a reverse-post-order list of nodes in block\n@@ -3016,8 +3053,2 @@\n-  \/\/ Push all non-control nodes with no inputs from within block, then control entry\n-  for (int j = 0; j < _data_entry.length(); j++) {\n-    Node* n = _data_entry.at(j);\n-    visited.set(bb_idx(n));\n-    stack.push(n);\n-  }\n-  visited.set(bb_idx(entry));\n-  stack.push(entry);\n+  visited.set(bb_idx(bb()));\n+  stack.push(bb());\n@@ -3026,4 +3057,2 @@\n-  int rpo_idx = bb_ct - 1;\n-  int size;\n-  int reduction_uses = 0;\n-  while ((size = stack.length()) > 0) {\n+  int rpo_idx = block_count - 1;\n+  while (!stack.is_empty()) {\n@@ -3035,0 +3064,1 @@\n+      const int old_length = stack.length();\n@@ -3036,1 +3066,1 @@\n-        Node *use = n->fast_out(i);\n+        Node* use = n->fast_out(i);\n@@ -3039,9 +3069,1 @@\n-            (!use->is_Phi() || n == entry)) {\n-          if (is_marked_reduction(use)) {\n-            \/\/ First see if we can map the reduction on the given system we are on, then\n-            \/\/ make a data entry operation for each reduction we see.\n-            BasicType bt = use->bottom_type()->basic_type();\n-            if (ReductionNode::implemented(use->Opcode(), Matcher::max_vector_size_auto_vectorization(bt), bt)) {\n-              reduction_uses++;\n-            }\n-          }\n+            (!use->is_Phi() || n == bb())) {\n@@ -3051,1 +3073,1 @@\n-      if (stack.length() == size) {\n+      if (stack.length() == old_length) {\n@@ -3054,1 +3076,1 @@\n-        assert(rpo_idx >= 0, \"\");\n+        assert(rpo_idx >= 0, \"must still have idx to pass out\");\n@@ -3058,1 +3080,1 @@\n-        assert(rpo_idx >= 0 || stack.is_empty(), \"\");\n+        assert(rpo_idx >= 0 || stack.is_empty(), \"still have idx left or are finished\");\n@@ -3063,1 +3085,1 @@\n-  }\/\/while\n+  }\n@@ -3065,2 +3087,0 @@\n-  int ii_current = -1;\n-  unsigned int load_idx = (unsigned int)-1;\n@@ -3071,4 +3091,1 @@\n-  }\/\/for\n-\n-  \/\/ Ensure extra info is allocated.\n-  initialize_bb();\n+  }\n@@ -3079,12 +3096,0 @@\n-    tty->print_cr(\"\\ndata entry nodes: %s\", _data_entry.length() > 0 ? \"\" : \"NONE\");\n-    for (int m = 0; m < _data_entry.length(); m++) {\n-      tty->print(\"%3d \", m);\n-      _data_entry.at(m)->dump();\n-    }\n-  }\n-  if (is_trace_superword_memory_slices()) {\n-    tty->print_cr(\"\\nmemory slices: %s\", _mem_slice_head.length() > 0 ? \"\" : \"NONE\");\n-    for (int m = 0; m < _mem_slice_head.length(); m++) {\n-      tty->print(\"%3d \", m); _mem_slice_head.at(m)->dump();\n-      tty->print(\"    \");    _mem_slice_tail.at(m)->dump();\n-    }\n@@ -3093,2 +3098,3 @@\n-  assert(rpo_idx == -1 && bb_ct == _block.length(), \"all block members found\");\n-  return (_mem_slice_head.length() > 0) || (reduction_uses > 0) || (_data_entry.length() > 0);\n+\n+  assert(rpo_idx == -1 && block_count == _block.length(), \"all block members found\");\n+  return true;\n@@ -3097,1 +3103,0 @@\n-\/\/------------------------------initialize_bb---------------------------\n@@ -3099,1 +3104,1 @@\n-void SuperWord::initialize_bb() {\n+void SuperWord::initialize_node_info() {\n@@ -3104,20 +3109,0 @@\n-\/\/------------------------------bb_insert_after---------------------------\n-\/\/ Insert n into block after pos\n-void SuperWord::bb_insert_after(Node* n, int pos) {\n-  int n_pos = pos + 1;\n-  \/\/ Make room\n-  for (int i = _block.length() - 1; i >= n_pos; i--) {\n-    _block.at_put_grow(i+1, _block.at(i));\n-  }\n-  for (int j = _node_info.length() - 1; j >= n_pos; j--) {\n-    _node_info.at_put_grow(j+1, _node_info.at(j));\n-  }\n-  \/\/ Set value\n-  _block.at_put_grow(n_pos, n);\n-  _node_info.at_put_grow(n_pos, SWNodeInfo::initial);\n-  \/\/ Adjust map from node->_idx to _block index\n-  for (int i = n_pos; i < _block.length(); i++) {\n-    set_bb_idx(_block.at(i), i);\n-  }\n-}\n-\n@@ -3779,1 +3764,0 @@\n-  _data_entry.clear();\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":90,"deletions":106,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -217,3 +217,2 @@\n-  GrowableArray<Node*> _data_entry;      \/\/ Nodes with all inputs from outside\n-  GrowableArray<Node*> _mem_slice_head;  \/\/ Memory slice head nodes\n-  GrowableArray<Node*> _mem_slice_tail;  \/\/ Memory slice tail nodes\n+  GrowableArray<PhiNode*> _mem_slice_head; \/\/ Memory slice head nodes\n+  GrowableArray<MemNode*> _mem_slice_tail; \/\/ Memory slice tail nodes\n@@ -470,0 +469,4 @@\n+\n+  \/\/ Analyze the memory slices\n+  void analyze_memory_slices();\n+  NOT_PRODUCT( void print_memory_slices(); )\n@@ -472,0 +475,1 @@\n+\n@@ -540,3 +544,1 @@\n-  void initialize_bb();\n-  \/\/ Insert n into block after pos\n-  void bb_insert_after(Node* n, int pos);\n+  void initialize_node_info();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"}]}