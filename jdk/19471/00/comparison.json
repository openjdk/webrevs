{"files":[{"patch":"@@ -2288,0 +2288,31 @@\n+\/\/ On Neoverse, MSUB uses the same ALU with other instructions (e.g. SDIV).\n+\/\/ The combination of MUL\/SUB can utilize multiple ALUs,\n+\/\/ and can be somewhat faster than MSUB.\n+void MacroAssembler::msub(Register Rd, Register Rn, Register Rm, Register Ra)\n+{\n+  assert(Rn != rscratch2 && Rm != rscratch2 && Ra != rscratch2, \"reg cannot be scratch\");\n+\n+  if (VM_Version::supports_a53mac() && Ra != zr)\n+    nop();\n+  if (VM_Version::is_neoverse()) {\n+    mul(rscratch2, Rn, Rm);\n+    sub(Rd, Ra, rscratch2);\n+  } else {\n+    Assembler::msub(Rd, Rn, Rm, Ra);\n+  }\n+}\n+\n+void MacroAssembler::msubw(Register Rd, Register Rn, Register Rm, Register Ra)\n+{\n+  assert(Rn != rscratch2 && Rm != rscratch2 && Ra != rscratch2, \"reg cannot be scratch\");\n+\n+  if (VM_Version::supports_a53mac() && Ra != zr)\n+    nop();\n+  if (VM_Version::is_neoverse()) {\n+    mulw(rscratch2, Rn, Rm);\n+    subw(Rd, Ra, rscratch2);\n+  } else {\n+    Assembler::msubw(Rd, Rn, Rm, Ra);\n+  }\n+}\n+\n@@ -2312,1 +2343,1 @@\n-    Assembler::msubw(result, scratch, rb, ra);\n+    msubw(result, scratch, rb, ra);\n@@ -2342,1 +2373,1 @@\n-    Assembler::msub(result, scratch, rb, ra);\n+    msub(result, scratch, rb, ra);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -440,1 +440,1 @@\n-  WRAP(madd) WRAP(msub) WRAP(maddw) WRAP(msubw)\n+  WRAP(madd) WRAP(maddw)\n@@ -445,0 +445,3 @@\n+  void msub(Register Rd, Register Rn, Register Rm, Register Ra);\n+  void msubw(Register Rd, Register Rn, Register Rm, Register Ra);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,7 +215,1 @@\n-  \/\/ Neoverse\n-  \/\/   N1: 0xd0c\n-  \/\/   N2: 0xd49\n-  \/\/   V1: 0xd40\n-  \/\/   V2: 0xd4f\n-  if (_cpu == CPU_ARM && (model_is(0xd0c) || model_is(0xd49) ||\n-                          model_is(0xd40) || model_is(0xd4f))) {\n+  if (is_neoverse()) {\n@@ -250,4 +244,1 @@\n-  \/\/ Neoverse\n-  \/\/   V1: 0xd40\n-  \/\/   V2: 0xd4f\n-  if (_cpu == CPU_ARM && (model_is(0xd40) || model_is(0xd4f))) {\n+  if (is_neoverse_v_series()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -117,0 +117,7 @@\n+enum Neoverse_CPU_Model {\n+    CPU_MODEL_NEOVERSE_N1 = 0xd0c,\n+    CPU_MODEL_NEOVERSE_N2 = 0xd49,\n+    CPU_MODEL_NEOVERSE_V1 = 0xd40,\n+    CPU_MODEL_NEOVERSE_V2 = 0xd4f,\n+};\n+\n@@ -159,0 +166,17 @@\n+\n+  static bool is_neoverse() {\n+    switch(_model) {\n+      case CPU_MODEL_NEOVERSE_N1:\n+      case CPU_MODEL_NEOVERSE_N2:\n+      case CPU_MODEL_NEOVERSE_V1:\n+      case CPU_MODEL_NEOVERSE_V2:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  static bool is_neoverse_v_series() {\n+    return (model_is(CPU_MODEL_NEOVERSE_V1) || model_is(CPU_MODEL_NEOVERSE_V2));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}