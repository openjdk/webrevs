[{"commit":{"message":"Align code example data for better reading"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp"}],"sha":"8f1f8aafb86dc20770c630e56dafc98a2a4f28d4"},{"commit":{"message":"Merge branch 'master' into JDK-8363989"},"files":[],"sha":"b48fa9d135460bff4969bd7ba4d7a1ce911be806"},{"commit":{"message":"Improve the comment of the vector expand implementation"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp"}],"sha":"a177797441521987bca544ac14602370c33398ac"},{"commit":{"message":"Merge branch 'master' into JDK-8363989"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp"}],"sha":"54c16b870e5f99c4cf0b61437280471fe07cbe0b"},{"commit":{"message":"8363989: AArch64: Add missing backend support of VectorAPI expand operation\n\nCurrently, on AArch64, the VectorAPI `expand` operation is intrinsified\nfor 32-bit and 64-bit types only when SVE2 is available. In the following\ncases, `expand` has not yet been intrinsified:\n1. **Subword types** on SVE2-capable hardware.\n2. **All types** on NEON and SVE1 environments.\n\nAs a result, `expand` API performance is very poor in these scenarios.\nThis patch intrinsifies the `expand` operation in the above environments.\n\nSince there are no native instructions directly corresponding to `expand`\nin these cases, this patch mainly leverages the `TBL` instruction to\nimplement `expand`. To compute the index input for `TBL`, the prefix sum\nalgorithm (see https:\/\/en.wikipedia.org\/wiki\/Prefix_sum) is used.\nTake a 128-bit byte vector on SVE2 as an example:\n```\nTo compute: dst = src.expand(mask)\nData direction: high <== low\nInput:\n  src                         = p o n m l k j i h g f e d c b a\n  mask                        = 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1\nExpected result:\n  dst                         = 0 0 h g 0 0 f e 0 0 d c 0 0 b a\n```\nStep 1: calculate the index input of the TBL instruction.\n```\n\/\/ Set tmp1 as all 0 vector.\ntmp1                          = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n\/\/ Move the mask bits from the predicate register to a vector register.\n\/\/ **1-bit** mask lane of P register to **8-bit** mask lane of V register.\ntmp2 = mask                   = 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1\n\n\/\/ Shift the entire register. Prefix sum algorithm.\ndst = tmp2 << 8               = 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0\ntmp2 += dst                   = 0 1 2 1 0 1 2 1 0 1 2 1 0 1 2 1\n\ndst = tmp2 << 16              = 2 1 0 1 2 1 0 1 2 1 0 1 2 1 0 0\ntmp2 += dst                   = 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1\n\ndst = tmp2 << 32              = 2 2 2 2 2 2 2 2 2 2 2 1 0 0 0 0\ntmp2 += dst                   = 4 4 4 4 4 4 4 4 4 4 4 3 2 2 2 1\n\ndst = tmp2 << 64              = 4 4 4 3 2 2 2 1 0 0 0 0 0 0 0 0\ntmp2 += dst                   = 8 8 8 7 6 6 6 5 4 4 4 3 2 2 2 1\n\n\/\/ Clear inactive elements.\ndst = sel(mask, tmp2, tmp1)   = 0 0 8 7 0 0 6 5 0 0 4 3 0 0 2 1\n\n\/\/ Set the inactive lane value to -1 and set the active lane to the target index.\ndst -= 1                      = -1 -1 7 6 -1 -1 5 4 -1 -1 3 2 -1 -1 1 0\n```\nStep 2: shuffle the source vector elements to the target vector\n```\ntbl(dst, src, dst)            = 0 0 h g 0 0 f e 0 0 d c 0 0 b a\n```\n\nThe same algorithm is used for NEON and SVE1, but with different\ninstructions where appropriate.\n\nThe following benchmarks are from panama-vector\/vectorIntrinsics.\n\nOn Nvidia Grace machine with option `-XX:UseSVE=2`:\n```\nBenchmark\t\tUnit\tBefore\t\tScore Error\tAfter\t\tScore Error\tUplift\nByte128Vector.expand\tops\/ms\t1791.022366\t5.619883\t9633.388683\t1.968788\t5.37\nDouble128Vector.expand\tops\/ms\t4489.255846\t0.48485\t\t4488.772949\t0.491596\t0.99\nFloat128Vector.expand\tops\/ms\t8863.02424\t6.888087\t8908.352235\t51.487453\t1\nInt128Vector.expand\tops\/ms\t8873.485683\t3.275682\t8879.635643\t1.243863\t1\nLong128Vector.expand\tops\/ms\t4485.1149\t4.458073\t4489.365269\t0.851093\t1\nShort128Vector.expand\tops\/ms\t792.068834\t2.640398\t5880.811288\t6.40683\t\t7.42\nByte64Vector.expand\tops\/ms\t854.455002\t8.548982\t5999.046295\t37.209987\t7.02\nDouble64Vector.expand\tops\/ms\t46.49763\t0.104773\t46.526043\t0.102451\t1\nFloat64Vector.expand\tops\/ms\t4510.596811\t0.504477\t4509.984244\t1.519178\t0.99\nInt64Vector.expand\tops\/ms\t4508.778322\t1.664461\t4535.216611\t26.742484\t1\nLong64Vector.expand\tops\/ms\t45.665462\t0.705485\t46.496232\t0.075648\t1.01\nShort64Vector.expand\tops\/ms\t394.527324\t1.284691\t3860.199621\t0.720015\t9.78\n```\n\nOn Nvidia Grace machine with option `-XX:UseSVE=1`:\n```\nBenchmark\t\tUnit\tBefore\t\tScore Error\tAfter\t\tScore Error\tUplift\nByte128Vector.expand\tops\/ms\t1767.314171\t12.431526\t9630.892248\t1.478813\t5.44\nDouble128Vector.expand\tops\/ms\t197.614381\t0.945541\t2416.075281\t2.664325\t12.22\nFloat128Vector.expand\tops\/ms\t390.878183\t2.089234\t3844.011978\t3.792751\t9.83\nInt128Vector.expand\tops\/ms\t394.550044\t2.025371\t3843.280133\t3.528017\t9.74\nLong128Vector.expand\tops\/ms\t198.366863\t0.651726\t2423.234639\t4.911434\t12.21\nShort128Vector.expand\tops\/ms\t790.044704\t3.339363\t5885.595035\t1.440598\t7.44\nByte64Vector.expand\tops\/ms\t853.479119\t7.158898\t5942.750116\t1.054905\t6.96\nDouble64Vector.expand\tops\/ms\t46.550458\t0.079191\t46.423053\t0.057554\t0.99\nFloat64Vector.expand\tops\/ms\t197.977215\t1.156535\t2445.010767\t1.992358\t12.34\nInt64Vector.expand\tops\/ms\t198.326857\t1.02785\t\t2444.211583\t2.5432\t\t12.32\nLong64Vector.expand\tops\/ms\t46.526513\t0.25779\t\t45.984253\t0.566691\t0.98\nShort64Vector.expand\tops\/ms\t398.649412\t1.87764\t\t3837.495773\t3.528926\t9.62\n```\n\nOn Nvidia Grace machine with option `-XX:UseSVE=0`:\n```\nBenchmark\t\tUnit\tBefore\t\tScore Error\tAfter\t\tScore Error\tUplift\nByte128Vector.expand\tops\/ms\t1802.98702\t6.906394\t9427.491602\t2.067934\t5.22\nDouble128Vector.expand\tops\/ms\t198.498191\t0.429071\t1190.476326\t0.247358\t5.99\nFloat128Vector.expand\tops\/ms\t392.849005\t2.034676\t2373.195574\t2.006566\t6.04\nInt128Vector.expand\tops\/ms\t395.69179\t2.194773\t2372.084745\t2.058303\t5.99\nLong128Vector.expand\tops\/ms\t198.191673\t1.476362\t1189.712301\t1.006821\t6\nShort128Vector.expand\tops\/ms\t795.785831\t5.62611\t\t4731.514053\t2.365213\t5.94\nByte64Vector.expand\tops\/ms\t843.549268\t7.174254\t5865.556155\t37.639415\t6.95\nDouble64Vector.expand\tops\/ms\t45.943599\t0.484743\t46.529755\t0.111551\t1.01\nFloat64Vector.expand\tops\/ms\t193.945993\t0.943338\t1463.836772\t0.618393\t7.54\nInt64Vector.expand\tops\/ms\t194.168021\t0.492286\t1473.004575\t8.802656\t7.58\nLong64Vector.expand\tops\/ms\t46.570488\t0.076372\t46.696353\t0.078649\t1\nShort64Vector.expand\tops\/ms\t387.973334\t2.367312\t2920.428114\t0.863635\t7.52\n```\n\nSome JTReg test cases are added for the above changes. And the patch was\ntested on both aarch64 and x64, all of tier1 tier2 and tier3 tests passed."},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp"}],"sha":"86d011acf9b93df056c5ced0c789a2514a85da62"}]