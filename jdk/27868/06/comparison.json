{"files":[{"patch":"@@ -107,1 +107,1 @@\n-  const void* const res = mmap((void*)addr, length, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n+  const void* const res = mmap((void*)addr, length, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, bsd_mmap_fd, 0);\n@@ -154,1 +154,1 @@\n-  const void* const res = mmap((void*)start, length, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, -1, 0);\n+  const void* const res = mmap((void*)start, length, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, bsd_mmap_fd, 0);\n@@ -175,1 +175,1 @@\n-  const void* const res = mmap((void*)untype(addr), size, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, -1, 0);\n+  const void* const res = mmap((void*)untype(addr), size, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, bsd_mmap_fd, 0);\n","filename":"src\/hotspot\/os\/bsd\/gc\/z\/zPhysicalMemoryBacking_bsd.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  #include <mach\/vm_statistics.h>\n@@ -1520,1 +1521,1 @@\n-                                       MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);\n+                                       MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, bsd_mmap_fd, 0);\n@@ -1647,1 +1648,1 @@\n-        MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);\n+        MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, bsd_mmap_fd, 0);\n@@ -1692,1 +1693,1 @@\n-  char* addr = (char*)::mmap(requested_addr, bytes, PROT_NONE, flags, -1, 0);\n+  char* addr = (char*)::mmap(requested_addr, bytes, PROT_NONE, flags, bsd_mmap_fd, 0);\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,4 @@\n+#ifdef __APPLE__\n+#include <mach\/vm_statistics.h>\n+#endif\n+\n@@ -32,0 +36,8 @@\n+\/\/ Shared constant for mmap file descriptor used across BSD OS implementations\n+static constexpr int bsd_mmap_fd =\n+#if defined(__APPLE__) && defined(VM_MAKE_TAG) && defined(VM_MEMORY_JAVA)\n+  VM_MAKE_TAG(VM_MEMORY_JAVA);\n+#else\n+  -1;\n+#endif\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"testutils.hpp\"\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zForwarding.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1133,0 +1133,1 @@\n+\n@@ -1198,0 +1199,20 @@\n+\n+#if defined(__APPLE__) && defined(VM_MAKE_TAG) && defined(VM_MEMORY_JAVA)\n+\/\/ Test that JVM-allocated memory is properly tagged with VM_MEMORY_JAVA on macOS\n+\/\/ for proper memory accounting and debugging capabilities.\n+TEST_VM(os, memory_tagging_validation) {\n+  const size_t size = 1 * M;\n+\n+  \/\/ Reserve and commit memory through standard JVM allocation path\n+  char* memory = os::reserve_memory(size, mtTest);\n+  ASSERT_NOT_NULL(memory);\n+  ASSERT_TRUE(os::commit_memory(memory, size, false));\n+\n+  \/\/ Verify the memory is tagged with VM_MEMORY_JAVA\n+  EXPECT_TRUE(GtestUtils::is_memory_tagged_as_java(memory, size))\n+    << \"JVM memory should be tagged with VM_MEMORY_JAVA on macOS\";\n+\n+  \/\/ Clean up\n+  os::release_memory(memory, size);\n+}\n+#endif \/\/ defined(__APPLE__) && defined(VM_MAKE_TAG) && defined(VM_MEMORY_JAVA)\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -69,0 +69,32 @@\n+\n+#ifdef __APPLE__\n+bool GtestUtils::is_memory_tagged_as_java(void* addr, size_t size) {\n+  \/\/ Use mach_vm_region with extended info to get the user_tag\n+  mach_vm_address_t address = (mach_vm_address_t)addr;\n+  mach_vm_size_t region_size = 0;\n+  vm_region_extended_info_data_t extended_info;\n+  mach_msg_type_number_t info_count = VM_REGION_EXTENDED_INFO_COUNT;\n+  mach_port_t object_name = MACH_PORT_NULL;\n+\n+  kern_return_t kr = mach_vm_region(mach_task_self(),\n+                                    &address,\n+                                    &region_size,\n+                                    VM_REGION_EXTENDED_INFO,\n+                                    (vm_region_info_t)&extended_info,\n+                                    &info_count,\n+                                    &object_name);\n+\n+  if (kr != KERN_SUCCESS) {\n+    return false;\n+  }\n+\n+  \/\/ Check if the memory region covers our allocation and has the correct tag\n+  if (address <= (mach_vm_address_t)addr &&\n+      (address + region_size) >= ((mach_vm_address_t)addr + size)) {\n+    \/\/ Check if the user_tag matches VM_MEMORY_JAVA\n+    return extended_info.user_tag == VM_MEMORY_JAVA;\n+  }\n+\n+  return false;\n+}\n+#endif\n","filename":"test\/hotspot\/gtest\/testutils.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+#ifdef __APPLE__\n+#include <mach\/mach_vm.h>\n+#include <mach\/vm_statistics.h>\n+#endif\n@@ -48,0 +52,6 @@\n+#ifdef __APPLE__\n+  \/\/ Check if a memory region is tagged with VM_MEMORY_JAVA on macOS\n+  \/\/ This function is used by multiple test files to validate BSD memory tagging\n+  static bool is_memory_tagged_as_java(void* addr, size_t size);\n+#endif\n+\n","filename":"test\/hotspot\/gtest\/testutils.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}