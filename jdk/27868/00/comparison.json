{"files":[{"patch":"@@ -107,0 +107,3 @@\n+#ifdef __APPLE__\n+  const void* const res = mmap((void*)addr, length, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, VM_MAKE_TAG(VM_MEMORY_JAVA), 0);\n+#else\n@@ -108,0 +111,1 @@\n+#endif\n@@ -154,0 +158,3 @@\n+#ifdef __APPLE__\n+  const void* const res = mmap((void*)start, length, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, VM_MAKE_TAG(VM_MEMORY_JAVA), 0);\n+#else\n@@ -155,0 +162,1 @@\n+#endif\n@@ -175,0 +183,3 @@\n+#ifdef __APPLE__\n+  const void* const res = mmap((void*)untype(addr), size, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, VM_MAKE_TAG(VM_MEMORY_JAVA), 0);\n+#else\n@@ -176,0 +187,1 @@\n+#endif\n","filename":"src\/hotspot\/os\/bsd\/gc\/z\/zPhysicalMemoryBacking_bsd.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  #include <mach\/vm_statistics.h>\n@@ -1532,1 +1533,1 @@\n-                                       MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);\n+                                       MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, VM_MAKE_TAG(VM_MEMORY_JAVA), 0);\n@@ -1659,1 +1660,1 @@\n-        MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);\n+        MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, VM_MAKE_TAG(VM_MEMORY_JAVA), 0);\n@@ -1704,0 +1705,3 @@\n+#ifdef __APPLE__\n+  char* addr = (char*)::mmap(requested_addr, bytes, PROT_NONE, flags, VM_MAKE_TAG(VM_MEMORY_JAVA), 0);\n+#else\n@@ -1705,0 +1709,1 @@\n+#endif\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"unittest.hpp\"\n+\n+#ifdef __APPLE__\n+#include <mach\/mach_vm.h>\n+#include <mach\/vm_statistics.h>\n+#include <sys\/mman.h>\n+#include <cstring>\n+\n+\/\/ Test that memory allocations on macOS are properly tagged with VM_MEMORY_JAVA\n+\/\/ This validates the VM_MAKE_TAG(VM_MEMORY_JAVA) changes in os_bsd.cpp\n+class BSDMemoryTaggingTest : public ::testing::Test {\n+protected:\n+  static const size_t test_size = 64 * 1024; \/\/ 64KB test allocation\n+\n+  \/\/ Helper to allocate memory with VM_MEMORY_JAVA tag using mmap directly\n+  void* allocate_with_java_tag(size_t size) {\n+    \/\/ Use mmap with VM_FLAGS_ALIAS_MASK to set VM_MEMORY_JAVA tag\n+    \/\/ VM_MEMORY_JAVA is defined as 300 in mach\/vm_statistics.h\n+    \/\/ VM_MAKE_TAG shifts the tag value into the correct position in flags\n+    int flags = MAP_PRIVATE | MAP_ANON;\n+    int fd = VM_MAKE_TAG(VM_MEMORY_JAVA);\n+    void* addr = ::mmap(nullptr, size, PROT_READ | PROT_WRITE, flags, fd, 0);\n+    return (addr == MAP_FAILED) ? nullptr : addr;\n+  }\n+\n+  \/\/ Helper to check if a memory region is tagged with VM_MEMORY_JAVA\n+  bool is_memory_tagged_as_java(void* addr, size_t size) {\n+    \/\/ Use mach_vm_region with extended info to get the user_tag\n+    mach_vm_address_t address = (mach_vm_address_t)addr;\n+    mach_vm_size_t region_size = 0;\n+    vm_region_extended_info_data_t extended_info;\n+    mach_msg_type_number_t info_count = VM_REGION_EXTENDED_INFO_COUNT;\n+    mach_port_t object_name = MACH_PORT_NULL;\n+\n+    kern_return_t kr = mach_vm_region(mach_task_self(),\n+                                      &address,\n+                                      &region_size,\n+                                      VM_REGION_EXTENDED_INFO,\n+                                      (vm_region_info_t)&extended_info,\n+                                      &info_count,\n+                                      &object_name);\n+\n+    if (kr != KERN_SUCCESS) {\n+      return false;\n+    }\n+\n+    \/\/ Check if the memory region covers our allocation and has the correct tag\n+    if (address <= (mach_vm_address_t)addr &&\n+        (address + region_size) >= ((mach_vm_address_t)addr + size)) {\n+      \/\/ Check if the user_tag matches VM_MEMORY_JAVA\n+      return extended_info.user_tag == VM_MEMORY_JAVA;\n+    }\n+\n+    return false;\n+  }\n+};\n+\n+TEST_F(BSDMemoryTaggingTest, test_mmap_with_java_tag) {\n+  \/\/ Test direct mmap with VM_MAKE_TAG(VM_MEMORY_JAVA)\n+  void* mem = allocate_with_java_tag(test_size);\n+  ASSERT_NE(mem, nullptr) << \"Failed to allocate memory with Java tag\";\n+\n+  \/\/ Verify the memory region exists and has expected properties\n+  EXPECT_TRUE(is_memory_tagged_as_java(mem, test_size))\n+    << \"Memory should be properly tagged with VM_MEMORY_JAVA on macOS\";\n+\n+  \/\/ Test that we can write to the memory\n+  memset(mem, 0xAB, test_size);\n+  EXPECT_EQ(((char*)mem)[0], (char)0xAB) << \"Should be able to write to allocated memory\";\n+\n+  \/\/ Clean up\n+  EXPECT_EQ(::munmap(mem, test_size), 0) << \"Failed to unmap memory\";\n+}\n+\n+TEST_F(BSDMemoryTaggingTest, test_multiple_allocations_with_java_tag) {\n+  \/\/ Test that multiple allocations use consistent tagging\n+  const size_t num_allocations = 5;\n+  void* allocations[num_allocations];\n+\n+  \/\/ Make multiple allocations\n+  for (size_t i = 0; i < num_allocations; i++) {\n+    allocations[i] = allocate_with_java_tag(test_size);\n+    ASSERT_NE(allocations[i], nullptr) << \"Failed to allocate memory for allocation \" << i;\n+\n+    \/\/ Verify tagging\n+    EXPECT_TRUE(is_memory_tagged_as_java(allocations[i], test_size))\n+      << \"Allocation \" << i << \" should be properly tagged with VM_MEMORY_JAVA on macOS\";\n+\n+    \/\/ Write a pattern to verify the memory works\n+    memset(allocations[i], (int)(0xA0 + i), test_size);\n+  }\n+\n+  \/\/ Verify all allocations are still accessible and have correct data\n+  for (size_t i = 0; i < num_allocations; i++) {\n+    EXPECT_EQ(((char*)allocations[i])[0], (char)(0xA0 + i))\n+      << \"Allocation \" << i << \" should retain written data\";\n+    EXPECT_EQ(((char*)allocations[i])[test_size - 1], (char)(0xA0 + i))\n+      << \"Allocation \" << i << \" should retain written data at end\";\n+  }\n+\n+  \/\/ Clean up all allocations\n+  for (size_t i = 0; i < num_allocations; i++) {\n+    EXPECT_EQ(::munmap(allocations[i], test_size), 0)\n+      << \"Failed to unmap memory for allocation \" << i;\n+  }\n+}\n+\n+#endif \/\/ __APPLE__\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_bsd_memory_tagging.cpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"}]}