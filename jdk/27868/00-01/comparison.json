{"files":[{"patch":"@@ -107,5 +107,7 @@\n-#ifdef __APPLE__\n-  const void* const res = mmap((void*)addr, length, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, VM_MAKE_TAG(VM_MEMORY_JAVA), 0);\n-#else\n-  const void* const res = mmap((void*)addr, length, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n-#endif\n+  constexpr int mmap_fd =\n+  #ifdef __APPLE__ \n+    VM_MAKE_TAG(VM_MEMORY_JAVA);\n+  #else \n+    -1; \n+  #endif\n+  const void* const res = mmap((void*)addr, length, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, mmap_fd, 0);\n@@ -158,5 +160,7 @@\n-#ifdef __APPLE__\n-  const void* const res = mmap((void*)start, length, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, VM_MAKE_TAG(VM_MEMORY_JAVA), 0);\n-#else\n-  const void* const res = mmap((void*)start, length, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, -1, 0);\n-#endif\n+  constexpr int mmap_fd =\n+  #ifdef __APPLE__ \n+    VM_MAKE_TAG(VM_MEMORY_JAVA);\n+  #else \n+    -1; \n+  #endif\n+  const void* const res = mmap((void*)start, length, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, mmap_fd, 0);\n@@ -183,5 +187,7 @@\n-#ifdef __APPLE__\n-  const void* const res = mmap((void*)untype(addr), size, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, VM_MAKE_TAG(VM_MEMORY_JAVA), 0);\n-#else\n-  const void* const res = mmap((void*)untype(addr), size, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, -1, 0);\n-#endif\n+  constexpr int mmap_fd =\n+  #ifdef __APPLE__ \n+    VM_MAKE_TAG(VM_MEMORY_JAVA);\n+  #else \n+    -1; \n+  #endif\n+  const void* const res = mmap((void*)untype(addr), size, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, mmap_fd, 0);\n","filename":"src\/hotspot\/os\/bsd\/gc\/z\/zPhysicalMemoryBacking_bsd.cpp","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1693,5 +1693,7 @@\n-#ifdef __APPLE__\n-  char* addr = (char*)::mmap(requested_addr, bytes, PROT_NONE, flags, VM_MAKE_TAG(VM_MEMORY_JAVA), 0);\n-#else\n-  char* addr = (char*)::mmap(requested_addr, bytes, PROT_NONE, flags, -1, 0);\n-#endif\n+  constexpr int mmap_fd = \n+  #ifdef __APPLE__ \n+    VM_MAKE_TAG(VM_MEMORY_JAVA);\n+  #else \n+    -1; \n+  #endif\n+  char* addr = (char*)::mmap(requested_addr, bytes, PROT_NONE, flags, mmap_fd, 0);\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,4 @@\n+#ifdef __APPLE__\n+#include <mach\/mach_vm.h>\n+#include <mach\/vm_statistics.h>\n+#endif\n@@ -37,0 +41,33 @@\n+#ifdef __APPLE__\n+\/\/ Check if a memory region is tagged with VM_MEMORY_JAVA\n+static bool is_memory_tagged_as_java(void* addr, size_t size) {\n+  \/\/ Use mach_vm_region with extended info to get the user_tag\n+  mach_vm_address_t address = (mach_vm_address_t)addr;\n+  mach_vm_size_t region_size = 0;\n+  vm_region_extended_info_data_t extended_info;\n+  mach_msg_type_number_t info_count = VM_REGION_EXTENDED_INFO_COUNT;\n+  mach_port_t object_name = MACH_PORT_NULL;\n+\n+  kern_return_t kr = mach_vm_region(mach_task_self(),\n+                                    &address,\n+                                    &region_size,\n+                                    VM_REGION_EXTENDED_INFO,\n+                                    (vm_region_info_t)&extended_info,\n+                                    &info_count,\n+                                    &object_name);\n+\n+  if (kr != KERN_SUCCESS) {\n+    return false;\n+  }\n+\n+  \/\/ Check if the memory region covers our allocation and has the correct tag\n+  if (address <= (mach_vm_address_t)addr &&\n+      (address + region_size) >= ((mach_vm_address_t)addr + size)) {\n+    \/\/ Check if the user_tag matches VM_MEMORY_JAVA\n+    return extended_info.user_tag == VM_MEMORY_JAVA;\n+  }\n+\n+  return false;\n+}\n+#endif\n+\n@@ -105,0 +142,6 @@\n+#ifdef __APPLE__\n+    \/\/ Validate BSD memory tagging for os::commit_memory path (covers pd_* functions)\n+    EXPECT_TRUE(is_memory_tagged_as_java(_reserved, ZGranuleSize)) \n+      << \"Memory allocated via os::commit_memory should be tagged with VM_MEMORY_JAVA on macOS\";\n+#endif\n+\n@@ -230,0 +273,8 @@\n+#ifdef __APPLE__\n+    \/\/ Validate BSD memory tagging for ZGC allocation path (covers ZPhysicalMemoryBacking functions)\n+    if (!is_null(object)) {\n+      EXPECT_TRUE(is_memory_tagged_as_java((void*)untype(object), object_size)) \n+        << \"ZGC object allocation should be tagged with VM_MEMORY_JAVA on macOS\";\n+    }\n+#endif\n+\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zForwarding.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -40,0 +40,4 @@\n+#ifdef __APPLE__\n+#include <mach\/mach_vm.h>\n+#include <mach\/vm_statistics.h>\n+#endif\n@@ -43,0 +47,33 @@\n+#ifdef __APPLE__\n+\/\/ Check if a memory region is tagged with VM_MEMORY_JAVA\n+static bool is_memory_tagged_as_java(void* addr, size_t size) {\n+  \/\/ Use mach_vm_region with extended info to get the user_tag\n+  mach_vm_address_t address = (mach_vm_address_t)addr;\n+  mach_vm_size_t region_size = 0;\n+  vm_region_extended_info_data_t extended_info;\n+  mach_msg_type_number_t info_count = VM_REGION_EXTENDED_INFO_COUNT;\n+  mach_port_t object_name = MACH_PORT_NULL;\n+\n+  kern_return_t kr = mach_vm_region(mach_task_self(),\n+                                    &address,\n+                                    &region_size,\n+                                    VM_REGION_EXTENDED_INFO,\n+                                    (vm_region_info_t)&extended_info,\n+                                    &info_count,\n+                                    &object_name);\n+\n+  if (kr != KERN_SUCCESS) {\n+    return false;\n+  }\n+\n+  \/\/ Check if the memory region covers our allocation and has the correct tag\n+  if (address <= (mach_vm_address_t)addr &&\n+      (address + region_size) >= ((mach_vm_address_t)addr + size)) {\n+    \/\/ Check if the user_tag matches VM_MEMORY_JAVA\n+    return extended_info.user_tag == VM_MEMORY_JAVA;\n+  }\n+\n+  return false;\n+}\n+#endif\n+\n@@ -739,0 +776,6 @@\n+    \n+#ifdef __APPLE__\n+    \/\/ Validate BSD memory tagging for JVM-allocated memory\n+    EXPECT_TRUE(is_memory_tagged_as_java(p, 1 * M)) \n+      << \"JVM memory allocated via os::reserve_memory should be tagged with VM_MEMORY_JAVA on macOS\";\n+#endif\n@@ -1111,0 +1154,6 @@\n+#ifdef __APPLE__\n+  \/\/ Validate BSD memory tagging for JVM-allocated memory\n+  EXPECT_TRUE(is_memory_tagged_as_java(base, size)) \n+    << \"JVM memory allocated via os::reserve_memory should be tagged with VM_MEMORY_JAVA on macOS\";\n+#endif\n+\n@@ -1133,0 +1182,7 @@\n+  \n+#ifdef __APPLE__\n+  \/\/ Validate BSD memory tagging for JVM-allocated memory\n+  EXPECT_TRUE(is_memory_tagged_as_java(base, size)) \n+    << \"JVM memory allocated via os::reserve_memory should be tagged with VM_MEMORY_JAVA on macOS\";\n+#endif\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"unittest.hpp\"\n-\n-#ifdef __APPLE__\n-#include <mach\/mach_vm.h>\n-#include <mach\/vm_statistics.h>\n-#include <sys\/mman.h>\n-#include <cstring>\n-\n-\/\/ Test that memory allocations on macOS are properly tagged with VM_MEMORY_JAVA\n-\/\/ This validates the VM_MAKE_TAG(VM_MEMORY_JAVA) changes in os_bsd.cpp\n-class BSDMemoryTaggingTest : public ::testing::Test {\n-protected:\n-  static const size_t test_size = 64 * 1024; \/\/ 64KB test allocation\n-\n-  \/\/ Helper to allocate memory with VM_MEMORY_JAVA tag using mmap directly\n-  void* allocate_with_java_tag(size_t size) {\n-    \/\/ Use mmap with VM_FLAGS_ALIAS_MASK to set VM_MEMORY_JAVA tag\n-    \/\/ VM_MEMORY_JAVA is defined as 300 in mach\/vm_statistics.h\n-    \/\/ VM_MAKE_TAG shifts the tag value into the correct position in flags\n-    int flags = MAP_PRIVATE | MAP_ANON;\n-    int fd = VM_MAKE_TAG(VM_MEMORY_JAVA);\n-    void* addr = ::mmap(nullptr, size, PROT_READ | PROT_WRITE, flags, fd, 0);\n-    return (addr == MAP_FAILED) ? nullptr : addr;\n-  }\n-\n-  \/\/ Helper to check if a memory region is tagged with VM_MEMORY_JAVA\n-  bool is_memory_tagged_as_java(void* addr, size_t size) {\n-    \/\/ Use mach_vm_region with extended info to get the user_tag\n-    mach_vm_address_t address = (mach_vm_address_t)addr;\n-    mach_vm_size_t region_size = 0;\n-    vm_region_extended_info_data_t extended_info;\n-    mach_msg_type_number_t info_count = VM_REGION_EXTENDED_INFO_COUNT;\n-    mach_port_t object_name = MACH_PORT_NULL;\n-\n-    kern_return_t kr = mach_vm_region(mach_task_self(),\n-                                      &address,\n-                                      &region_size,\n-                                      VM_REGION_EXTENDED_INFO,\n-                                      (vm_region_info_t)&extended_info,\n-                                      &info_count,\n-                                      &object_name);\n-\n-    if (kr != KERN_SUCCESS) {\n-      return false;\n-    }\n-\n-    \/\/ Check if the memory region covers our allocation and has the correct tag\n-    if (address <= (mach_vm_address_t)addr &&\n-        (address + region_size) >= ((mach_vm_address_t)addr + size)) {\n-      \/\/ Check if the user_tag matches VM_MEMORY_JAVA\n-      return extended_info.user_tag == VM_MEMORY_JAVA;\n-    }\n-\n-    return false;\n-  }\n-};\n-\n-TEST_F(BSDMemoryTaggingTest, test_mmap_with_java_tag) {\n-  \/\/ Test direct mmap with VM_MAKE_TAG(VM_MEMORY_JAVA)\n-  void* mem = allocate_with_java_tag(test_size);\n-  ASSERT_NE(mem, nullptr) << \"Failed to allocate memory with Java tag\";\n-\n-  \/\/ Verify the memory region exists and has expected properties\n-  EXPECT_TRUE(is_memory_tagged_as_java(mem, test_size))\n-    << \"Memory should be properly tagged with VM_MEMORY_JAVA on macOS\";\n-\n-  \/\/ Test that we can write to the memory\n-  memset(mem, 0xAB, test_size);\n-  EXPECT_EQ(((char*)mem)[0], (char)0xAB) << \"Should be able to write to allocated memory\";\n-\n-  \/\/ Clean up\n-  EXPECT_EQ(::munmap(mem, test_size), 0) << \"Failed to unmap memory\";\n-}\n-\n-TEST_F(BSDMemoryTaggingTest, test_multiple_allocations_with_java_tag) {\n-  \/\/ Test that multiple allocations use consistent tagging\n-  const size_t num_allocations = 5;\n-  void* allocations[num_allocations];\n-\n-  \/\/ Make multiple allocations\n-  for (size_t i = 0; i < num_allocations; i++) {\n-    allocations[i] = allocate_with_java_tag(test_size);\n-    ASSERT_NE(allocations[i], nullptr) << \"Failed to allocate memory for allocation \" << i;\n-\n-    \/\/ Verify tagging\n-    EXPECT_TRUE(is_memory_tagged_as_java(allocations[i], test_size))\n-      << \"Allocation \" << i << \" should be properly tagged with VM_MEMORY_JAVA on macOS\";\n-\n-    \/\/ Write a pattern to verify the memory works\n-    memset(allocations[i], (int)(0xA0 + i), test_size);\n-  }\n-\n-  \/\/ Verify all allocations are still accessible and have correct data\n-  for (size_t i = 0; i < num_allocations; i++) {\n-    EXPECT_EQ(((char*)allocations[i])[0], (char)(0xA0 + i))\n-      << \"Allocation \" << i << \" should retain written data\";\n-    EXPECT_EQ(((char*)allocations[i])[test_size - 1], (char)(0xA0 + i))\n-      << \"Allocation \" << i << \" should retain written data at end\";\n-  }\n-\n-  \/\/ Clean up all allocations\n-  for (size_t i = 0; i < num_allocations; i++) {\n-    EXPECT_EQ(::munmap(allocations[i], test_size), 0)\n-      << \"Failed to unmap memory for allocation \" << i;\n-  }\n-}\n-\n-#endif \/\/ __APPLE__\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_bsd_memory_tagging.cpp","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"}]}