{"files":[{"patch":"@@ -33,0 +33,1 @@\n+#include \"testutils.hpp\"\n@@ -34,4 +35,0 @@\n-#ifdef __APPLE__\n-#include <mach\/mach_vm.h>\n-#include <mach\/vm_statistics.h>\n-#endif\n@@ -41,33 +38,0 @@\n-#ifdef __APPLE__\n-\/\/ Check if a memory region is tagged with VM_MEMORY_JAVA\n-static bool is_memory_tagged_as_java(void* addr, size_t size) {\n-  \/\/ Use mach_vm_region with extended info to get the user_tag\n-  mach_vm_address_t address = (mach_vm_address_t)addr;\n-  mach_vm_size_t region_size = 0;\n-  vm_region_extended_info_data_t extended_info;\n-  mach_msg_type_number_t info_count = VM_REGION_EXTENDED_INFO_COUNT;\n-  mach_port_t object_name = MACH_PORT_NULL;\n-\n-  kern_return_t kr = mach_vm_region(mach_task_self(),\n-                                    &address,\n-                                    &region_size,\n-                                    VM_REGION_EXTENDED_INFO,\n-                                    (vm_region_info_t)&extended_info,\n-                                    &info_count,\n-                                    &object_name);\n-\n-  if (kr != KERN_SUCCESS) {\n-    return false;\n-  }\n-\n-  \/\/ Check if the memory region covers our allocation and has the correct tag\n-  if (address <= (mach_vm_address_t)addr &&\n-      (address + region_size) >= ((mach_vm_address_t)addr + size)) {\n-    \/\/ Check if the user_tag matches VM_MEMORY_JAVA\n-    return extended_info.user_tag == VM_MEMORY_JAVA;\n-  }\n-\n-  return false;\n-}\n-#endif\n-\n@@ -144,1 +108,1 @@\n-    EXPECT_TRUE(is_memory_tagged_as_java(_reserved, ZGranuleSize))\n+    EXPECT_TRUE(GtestUtils::is_memory_tagged_as_java(_reserved, ZGranuleSize))\n@@ -276,1 +240,1 @@\n-      EXPECT_TRUE(is_memory_tagged_as_java((void*)untype(object), object_size))\n+      EXPECT_TRUE(GtestUtils::is_memory_tagged_as_java((void*)untype(object), object_size))\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zForwarding.cpp","additions":3,"deletions":39,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -40,4 +40,0 @@\n-#ifdef __APPLE__\n-#include <mach\/mach_vm.h>\n-#include <mach\/vm_statistics.h>\n-#endif\n@@ -47,33 +43,0 @@\n-#ifdef __APPLE__\n-\/\/ Check if a memory region is tagged with VM_MEMORY_JAVA\n-static bool is_memory_tagged_as_java(void* addr, size_t size) {\n-  \/\/ Use mach_vm_region with extended info to get the user_tag\n-  mach_vm_address_t address = (mach_vm_address_t)addr;\n-  mach_vm_size_t region_size = 0;\n-  vm_region_extended_info_data_t extended_info;\n-  mach_msg_type_number_t info_count = VM_REGION_EXTENDED_INFO_COUNT;\n-  mach_port_t object_name = MACH_PORT_NULL;\n-\n-  kern_return_t kr = mach_vm_region(mach_task_self(),\n-                                    &address,\n-                                    &region_size,\n-                                    VM_REGION_EXTENDED_INFO,\n-                                    (vm_region_info_t)&extended_info,\n-                                    &info_count,\n-                                    &object_name);\n-\n-  if (kr != KERN_SUCCESS) {\n-    return false;\n-  }\n-\n-  \/\/ Check if the memory region covers our allocation and has the correct tag\n-  if (address <= (mach_vm_address_t)addr &&\n-      (address + region_size) >= ((mach_vm_address_t)addr + size)) {\n-    \/\/ Check if the user_tag matches VM_MEMORY_JAVA\n-    return extended_info.user_tag == VM_MEMORY_JAVA;\n-  }\n-\n-  return false;\n-}\n-#endif\n-\n@@ -779,1 +742,1 @@\n-    EXPECT_TRUE(is_memory_tagged_as_java(p, 1 * M))\n+    EXPECT_TRUE(GtestUtils::is_memory_tagged_as_java(p, 1 * M))\n@@ -1156,1 +1119,1 @@\n-  EXPECT_TRUE(is_memory_tagged_as_java(base, size))\n+  EXPECT_TRUE(GtestUtils::is_memory_tagged_as_java(base, size))\n@@ -1185,1 +1148,1 @@\n-  EXPECT_TRUE(is_memory_tagged_as_java(base, size))\n+  EXPECT_TRUE(GtestUtils::is_memory_tagged_as_java(base, size))\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":3,"deletions":40,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -69,0 +69,32 @@\n+\n+#ifdef __APPLE__\n+bool GtestUtils::is_memory_tagged_as_java(void* addr, size_t size) {\n+  \/\/ Use mach_vm_region with extended info to get the user_tag\n+  mach_vm_address_t address = (mach_vm_address_t)addr;\n+  mach_vm_size_t region_size = 0;\n+  vm_region_extended_info_data_t extended_info;\n+  mach_msg_type_number_t info_count = VM_REGION_EXTENDED_INFO_COUNT;\n+  mach_port_t object_name = MACH_PORT_NULL;\n+\n+  kern_return_t kr = mach_vm_region(mach_task_self(),\n+                                    &address,\n+                                    &region_size,\n+                                    VM_REGION_EXTENDED_INFO,\n+                                    (vm_region_info_t)&extended_info,\n+                                    &info_count,\n+                                    &object_name);\n+\n+  if (kr != KERN_SUCCESS) {\n+    return false;\n+  }\n+\n+  \/\/ Check if the memory region covers our allocation and has the correct tag\n+  if (address <= (mach_vm_address_t)addr &&\n+      (address + region_size) >= ((mach_vm_address_t)addr + size)) {\n+    \/\/ Check if the user_tag matches VM_MEMORY_JAVA\n+    return extended_info.user_tag == VM_MEMORY_JAVA;\n+  }\n+\n+  return false;\n+}\n+#endif\n","filename":"test\/hotspot\/gtest\/testutils.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+#ifdef __APPLE__\n+#include <mach\/mach_vm.h>\n+#include <mach\/vm_statistics.h>\n+#endif\n@@ -48,0 +52,6 @@\n+#ifdef __APPLE__\n+  \/\/ Check if a memory region is tagged with VM_MEMORY_JAVA on macOS\n+  \/\/ This function is used by multiple test files to validate BSD memory tagging\n+  static bool is_memory_tagged_as_java(void* addr, size_t size);\n+#endif\n+\n","filename":"test\/hotspot\/gtest\/testutils.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}