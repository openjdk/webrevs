{"files":[{"patch":"@@ -369,1 +369,1 @@\n-class CodeBuffer: public StackObj DEBUG_ONLY(COMMA private Scrubber) {\n+class CodeBuffer: public ResourceObj DEBUG_ONLY(COMMA private Scrubber) {\n@@ -377,2 +377,0 @@\n-  void* operator new(size_t size) throw() { return ResourceObj::operator new(size); }\n-  void  operator delete(void* p)          { ShouldNotCallThis(); }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-      ResourceObj(cp),\n+      ResourceObj(),\n","filename":"src\/hotspot\/share\/classfile\/stackMapFrame.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -240,3 +240,1 @@\n-    _allocated_regions((ResourceObj::set_allocation_type((address) &_allocated_regions,\n-                                                         ResourceObj::C_HEAP),\n-                        2), mtGC),\n+    _allocated_regions(2, mtGC),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-class DirtyCardToOopClosure: public MemRegionClosureRO {\n+class DirtyCardToOopClosure : public ResourceObj {\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  DEBUG_ONLY(set_allocation_type(res, ARENA);)\n+  DEBUG_ONLY(_recent_allocations.set_type(res, size, ARENA);)\n@@ -118,1 +118,0 @@\n-    DEBUG_ONLY(set_allocation_type(res, C_HEAP);)\n@@ -121,2 +120,1 @@\n-    \/\/ new(size) sets allocation type RESOURCE_AREA.\n-    res = (address)operator new(size);\n+    res = (address)resource_allocate_bytes(size);\n@@ -127,0 +125,1 @@\n+  DEBUG_ONLY(_recent_allocations.set_type(res, size, type);)\n@@ -137,1 +136,0 @@\n-    DEBUG_ONLY(if (res!= NULL) set_allocation_type(res, C_HEAP);)\n@@ -140,2 +138,1 @@\n-    \/\/ new(size) sets allocation type RESOURCE_AREA.\n-    res = (address)operator new(size, std::nothrow);\n+    res = (address)resource_allocate_bytes(size, AllocFailStrategy::RETURN_NULL);\n@@ -146,0 +143,1 @@\n+  DEBUG_ONLY(if (res!= NULL) _recent_allocations.set_type(res, size, type);)\n@@ -155,1 +153,0 @@\n-  DEBUG_ONLY(((ResourceObj *)p)->_allocation_t[0] = (uintptr_t)badHeapOopVal;)\n@@ -160,17 +157,1 @@\n-void ResourceObj::set_allocation_type(address res, allocation_type type) {\n-  \/\/ Set allocation type in the resource object\n-  uintptr_t allocation = (uintptr_t)res;\n-  assert((allocation & allocation_mask) == 0, \"address should be aligned to 4 bytes at least: \" INTPTR_FORMAT, p2i(res));\n-  assert(type <= allocation_mask, \"incorrect allocation type\");\n-  ResourceObj* resobj = (ResourceObj *)res;\n-  resobj->_allocation_t[0] = ~(allocation + type);\n-  if (type != STACK_OR_EMBEDDED) {\n-    \/\/ Called from operator new(), set verification value.\n-    resobj->_allocation_t[1] = (uintptr_t)&(resobj->_allocation_t[1]) + type;\n-  }\n-}\n-\n-ResourceObj::allocation_type ResourceObj::get_allocation_type() const {\n-  assert(~(_allocation_t[0] | allocation_mask) == (uintptr_t)this, \"lost resource object\");\n-  return (allocation_type)((~_allocation_t[0]) & allocation_mask);\n-}\n+THREAD_LOCAL ResourceObj::RecentAllocations ResourceObj::_recent_allocations;\n@@ -178,5 +159,1 @@\n-bool ResourceObj::is_type_set() const {\n-  allocation_type type = (allocation_type)(_allocation_t[1] & allocation_mask);\n-  return get_allocation_type()  == type &&\n-         (_allocation_t[1] - type) == (uintptr_t)(&_allocation_t[1]);\n-}\n+ResourceObj::ResourceObj() : _type(_recent_allocations.remove_type(this)) {}\n@@ -184,37 +161,1 @@\n-\/\/ This whole business of passing information from ResourceObj::operator new\n-\/\/ to the ResourceObj constructor via fields in the \"object\" is technically UB.\n-\/\/ But it seems to work within the limitations of HotSpot usage (such as no\n-\/\/ multiple inheritance) with the compilers and compiler options we're using.\n-\/\/ And it gives some possibly useful checking for misuse of ResourceObj.\n-void ResourceObj::initialize_allocation_info() {\n-  if (~(_allocation_t[0] | allocation_mask) != (uintptr_t)this) {\n-    \/\/ Operator new() is not called for allocations\n-    \/\/ on stack and for embedded objects.\n-    set_allocation_type((address)this, STACK_OR_EMBEDDED);\n-  } else if (allocated_on_stack_or_embedded()) { \/\/ STACK_OR_EMBEDDED\n-    \/\/ For some reason we got a value which resembles\n-    \/\/ an embedded or stack object (operator new() does not\n-    \/\/ set such type). Keep it since it is valid value\n-    \/\/ (even if it was garbage).\n-    \/\/ Ignore garbage in other fields.\n-  } else if (is_type_set()) {\n-    \/\/ Operator new() was called and type was set.\n-    assert(!allocated_on_stack_or_embedded(),\n-           \"not embedded or stack, this(\" PTR_FORMAT \") type %d a[0]=(\" PTR_FORMAT \") a[1]=(\" PTR_FORMAT \")\",\n-           p2i(this), get_allocation_type(), _allocation_t[0], _allocation_t[1]);\n-  } else {\n-    \/\/ Operator new() was not called.\n-    \/\/ Assume that it is embedded or stack object.\n-    set_allocation_type((address)this, STACK_OR_EMBEDDED);\n-  }\n-  _allocation_t[1] = 0; \/\/ Zap verification value\n-}\n-\n-ResourceObj::ResourceObj() {\n-  initialize_allocation_info();\n-}\n-\n-ResourceObj::ResourceObj(const ResourceObj&) {\n-  \/\/ Initialize _allocation_t as a new object, ignoring object being copied.\n-  initialize_allocation_info();\n-}\n+ResourceObj::ResourceObj(const ResourceObj&) : _type(_recent_allocations.remove_type(this)) {}\n@@ -223,5 +164,1 @@\n-  assert(allocated_on_stack_or_embedded(),\n-         \"copy only into local, this(\" PTR_FORMAT \") type %d a[0]=(\" PTR_FORMAT \") a[1]=(\" PTR_FORMAT \")\",\n-         p2i(this), get_allocation_type(), _allocation_t[0], _allocation_t[1]);\n-  \/\/ Keep current _allocation_t value;\n-  return *this;\n+  return *this; \/\/ allocation type should *not* be updated on assignment, only on allocation\n@@ -230,5 +167,2 @@\n-ResourceObj::~ResourceObj() {\n-  \/\/ allocated_on_C_heap() also checks that encoded (in _allocation) address == this.\n-  if (!allocated_on_C_heap()) { \/\/ ResourceObj::delete() will zap _allocation for C_heap.\n-    _allocation_t[0] = (uintptr_t)badHeapOopVal; \/\/ zap type\n-  }\n+ResourceObj::allocation_type ResourceObj::get_allocation_type() const {\n+  return _type;\n@@ -236,2 +170,1 @@\n-#endif \/\/ ASSERT\n-\n+#endif \/\/ASSERT\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":12,"deletions":79,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -387,2 +387,2 @@\n-\/\/ new or delete (allocation_type is unknown).  If new is used to allocate,\n-\/\/ use delete to deallocate.\n+\/\/ new or delete (allocation_type is unknown).  Only use delete on C_HEAP\n+\/\/ allocated objects\n@@ -391,2 +391,1 @@\n-  enum allocation_type { STACK_OR_EMBEDDED = 0, RESOURCE_AREA, C_HEAP, ARENA, allocation_mask = 0x3 };\n-  static void set_allocation_type(address res, allocation_type type) NOT_DEBUG_RETURN;\n+  enum allocation_type : uint8_t { STACK_OR_EMBEDDED, RESOURCE_AREA, C_HEAP, ARENA };\n@@ -395,7 +394,51 @@\n-  \/\/ When this object is allocated on stack the new() operator is not\n-  \/\/ called but garbage on stack may look like a valid allocation_type.\n-  \/\/ Store negated 'this' pointer when new() is called to distinguish cases.\n-  \/\/ Use second array's element for verification value to distinguish garbage.\n-  uintptr_t _allocation_t[2];\n-  bool is_type_set() const;\n-  void initialize_allocation_info();\n+  allocation_type _type;\n+  \/\/ This debug class is used to record allocation_type when operator new is called.\n+  \/\/ A few entries are needed (depending on compiler and complexity of expressions).\n+  \/\/ When the code was written 2 entries was needed on clang.\n+  \/\/\n+  \/\/ With this information we can, given a pointer, know how that pointer was\n+  \/\/ allocated iff we remove this information directly in the constructor. One\n+  \/\/ additional unfortunate restriction is that (in general) multiple inheritance\n+  \/\/ can not be used. This is unfortunate, but this limitation also existed in the\n+  \/\/ previous solution that failed because it also relied on writing to an\n+  \/\/ un-initalized object before it was constructed. The code will also fail if the\n+  \/\/ allocation is done in a recursive step. In that case an assert will trigger.\n+  class RecentAllocations {\n+    static const unsigned BufferSize = 5;\n+    uintptr_t _begin[BufferSize];\n+    uintptr_t _past_end[BufferSize];\n+    allocation_type _types[BufferSize];\n+  public:\n+    constexpr RecentAllocations() : _begin{},  _past_end{}, _types{} { }\n+\n+    void set_type(void* begin_ptr, size_t size, allocation_type type) {\n+      uintptr_t begin = reinterpret_cast<uintptr_t>(begin_ptr);\n+      for (unsigned i = 0; i < BufferSize; ++i) {\n+        if (_begin[i] == 0) {\n+          assert(_past_end[i] == 0, \"should have been reset\");\n+          assert(_types[i] == STACK_OR_EMBEDDED, \"should have been reset\");\n+          _begin[i] = begin;\n+          _past_end[i] = begin + size;\n+          _types[i] = type;\n+          return;\n+        }\n+      }\n+      assert(false, \"too small buffer, please adjust BufferSize\");\n+    }\n+\n+    allocation_type remove_type(void* p) {\n+      uintptr_t ptr = reinterpret_cast<uintptr_t>(p);\n+      for (unsigned i = 0; i < BufferSize; ++i) {\n+        if (_begin[i] <= ptr && ptr < _past_end[i]) {\n+          allocation_type type = _types[i];\n+          _begin[i] = 0;\n+          _past_end[i] = 0;\n+          _types[i] = STACK_OR_EMBEDDED;\n+          return type;\n+        }\n+      }\n+\n+      \/\/ type not found, that is, operator new was not called, and the object is STACK_OR_EMBEDDED\n+      return STACK_OR_EMBEDDED;\n+   }\n+  };\n@@ -403,0 +446,1 @@\n+  static THREAD_LOCAL RecentAllocations _recent_allocations;\n@@ -405,3 +449,4 @@\n-  bool allocated_on_res_area() const { return get_allocation_type() == RESOURCE_AREA; }\n-  bool allocated_on_C_heap()   const { return get_allocation_type() == C_HEAP; }\n-  bool allocated_on_arena()    const { return get_allocation_type() == ARENA; }\n+  bool allocated_on_res_area()          const { return get_allocation_type() == RESOURCE_AREA; }\n+  bool allocated_on_C_heap()            const { return get_allocation_type() == C_HEAP; }\n+  bool allocated_on_arena()             const { return get_allocation_type() == ARENA; }\n+\n@@ -409,4 +454,3 @@\n-  ResourceObj(); \/\/ default constructor\n-  ResourceObj(const ResourceObj& r); \/\/ default copy constructor\n-  ResourceObj& operator=(const ResourceObj& r); \/\/ default copy assignment\n-  ~ResourceObj();\n+  ResourceObj();\n+  ResourceObj(const ResourceObj&);\n+  ResourceObj& operator=(const ResourceObj& r);\n@@ -427,1 +471,1 @@\n-      DEBUG_ONLY(set_allocation_type(res, RESOURCE_AREA);)\n+      DEBUG_ONLY(_recent_allocations.set_type(res, size, RESOURCE_AREA);)\n@@ -433,1 +477,1 @@\n-      DEBUG_ONLY(if (res != NULL) set_allocation_type(res, RESOURCE_AREA);)\n+      DEBUG_ONLY(if (res != NULL) _recent_allocations.set_type(res, size, RESOURCE_AREA);)\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":64,"deletions":20,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -108,17 +108,0 @@\n-\/\/ A ResourceObj version of MemRegionClosure\n-\n-class MemRegionClosureRO: public MemRegionClosure {\n-public:\n-  void* operator new(size_t size, ResourceObj::allocation_type type, MEMFLAGS flags) throw() {\n-        return ResourceObj::operator new(size, type, flags);\n-  }\n-  void* operator new(size_t size, Arena *arena) throw() {\n-        return ResourceObj::operator new(size, arena);\n-  }\n-  void* operator new(size_t size) throw() {\n-        return ResourceObj::operator new(size);\n-  }\n-\n-  void  operator delete(void* p) {} \/\/ nothing to do\n-};\n-\n","filename":"src\/hotspot\/share\/memory\/memRegion.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -132,2 +132,1 @@\n-    _deferred_locals_updates((ResourceObj::set_allocation_type((address) &_deferred_locals_updates,\n-                              ResourceObj::C_HEAP), 1), mtCompiler) { }\n+    _deferred_locals_updates(1, mtCompiler) { }\n","filename":"src\/hotspot\/share\/prims\/jvmtiDeferredUpdates.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}