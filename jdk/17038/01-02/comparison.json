{"files":[{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipFile;\n-import java.util.zip.ZipOutputStream;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-\n-\/*\n- * @test\n- * @bug 4401122\n- * @run junit Available\n- *\/\n-public class Available {\n-    \/\/ ZIP file produced by this test\n-    private Path zip = Path.of(\"available.zip\");\n-    \/\/ The number of uncompressed bytes to write to the ZIP entry\n-    private static final int EXPECTED_BYTES = 512;\n-\n-    \/**\n-     * Produce a ZIP file containing an entry with byte length\n-     * @throws IOException if an unexpected IOException occurs\n-     *\/\n-    @BeforeEach\n-    public void setUp() throws IOException {\n-        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n-            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n-            zo.write(new byte[EXPECTED_BYTES]);\n-        }\n-    }\n-\n-    \/**\n-     * Clean up the ZIP file produced by this test\n-     * @throws IOException if an unexpected IOException occurs\n-     *\/\n-    @AfterEach\n-    public void cleanup() throws IOException {\n-        Files.deleteIfExists(zip);\n-    }\n-\n-    \/**\n-     * Check that the available() method overriden by the input stream returned by\n-     * ZipFile.getInputStream correctly returns the number of remaining uncompressed bytes\n-     *\n-     * @throws IOException if an unexpected IOException occurs\n-     *\/\n-    @Test\n-    public void shouldReturnRemainingUncompressedBytes() throws IOException {\n-        try (ZipFile zf = new ZipFile(zip.toFile())) {\n-            ZipEntry e = zf.getEntry(\"file.txt\");\n-            try (InputStream in = zf.getInputStream(e)) {\n-                \/\/ Initially, available() should return the full uncompressed size of the entry\n-                assertEquals(EXPECTED_BYTES, in.available(),\n-                        \"wrong initial return value of available\");\n-\n-                \/\/ Reading a few bytes should reduce the number of available bytes accordingly\n-                int bytesToRead = 10;\n-                in.read(new byte[bytesToRead]);\n-                assertEquals(EXPECTED_BYTES - bytesToRead, in.available());\n-\n-                \/\/ Reading all remaining bytes should reduce the number of available bytes to zero\n-                in.transferTo(OutputStream.nullOutputStream());\n-                assertEquals(0, in.available());\n-\n-                \/\/ available on a closed input stream should return zero\n-                in.close();\n-                assertEquals(0, in.available());\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/Available.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test 1.1 99\/06\/01\n-   @bug 4239446\n-   @summary Make sure the ZipEntry fields are correct.\n-   @run junit CopyJar\n- *\/\n-\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.jar.JarOutputStream;\n-import java.util.jar.Manifest;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipFile;\n-import java.util.zip.ZipOutputStream;\n-\n-public class CopyJar {\n-\n-    \/\/ ZIP file produced by this test\n-    private Path jar = Path.of(\"copy-jar.jar\");\n-\n-    \/**\n-     * Create a sample ZIP file used by this test\n-     *\n-     * @throws IOException if an unexpected IOException occurs\n-     *\/\n-    @BeforeEach\n-    public void setUp() throws IOException {\n-        try (JarOutputStream jo = new JarOutputStream(Files.newOutputStream(jar), new Manifest())) {\n-            jo.putNextEntry(new ZipEntry(\"file.txt\"));\n-            jo.write(\"helloworld\".getBytes(StandardCharsets.UTF_8));\n-        }\n-    }\n-\n-    \/**\n-     * Clean up the ZIP file produced by this test\n-     *\n-     * @throws IOException if an unexpected IOException occurs\n-     *\/\n-    @AfterEach\n-    public void cleanup() throws IOException {\n-        Files.deleteIfExists(jar);\n-    }\n-\n-    \/**\n-     * Check that a ZipEntry read by ZipFile.getEntry does not produce\n-     * a CRC value inconsistent with the CRC computed when the entry\n-     * and its content is copied over to a ZipOutputStream\n-     *\n-     * @throws IOException if an unexpected IOException occurs\n-     *\/\n-    @Test\n-    public void copyingZipEntryShouldFailCRCValidation() throws IOException {\n-        try (ZipFile zf = new ZipFile(jar.toFile())) {\n-            ZipEntry ze = zf.getEntry(\"file.txt\");\n-\n-            try (ZipOutputStream zos = new ZipOutputStream(OutputStream.nullOutputStream());\n-                 InputStream in = zf.getInputStream(ze)) {\n-                \/* The original bug mentions that ZipEntry\n-                 * 'loses the correct CRC value read from the CEN directory'.\n-                 * Enable the code below to trigger a ZipException similar to the bug description\n-                 *\/\n-                if (false) {\n-                    \/\/ Reset the CRC, as if a zero value was read from a streaming mode LOC header\n-                    ze.setCrc(0);\n-                    \/\/ Required to set ZipEntry.csizeSet = true\n-                    ze.setCompressedSize(ze.getCompressedSize());\n-                }\n-                zos.putNextEntry(ze);\n-                in.transferTo(zos);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CopyJar.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n-   @bug 4206838\n-   @summary getEntry() will search for a directory\n-            even without an ending '\/'.\n-   @run junit GetDirEntry\n- *\/\n-\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipFile;\n-import java.util.zip.ZipOutputStream;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-\n-public class GetDirEntry {\n-\n-    \/\/ ZIP file produced in this test\n-    private Path zip = Path.of(\"directory-entry.zip\");\n-\n-    \/**\n-     * Create a sample ZIP file containing a directory entry\n-     * @throws IOException if an unexpected IOException occurs\n-     *\/\n-    @BeforeEach\n-    public void setUp() throws IOException {\n-        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n-            ZipEntry e = new ZipEntry(\"META-INF\/\");\n-            e.setMethod(ZipEntry.STORED);\n-            e.setSize(0);\n-            e.setCrc(0);\n-            zo.putNextEntry(e);\n-        }\n-    }\n-\n-    \/**\n-     * Delete the ZIP file produced by this test\n-     * @throws IOException if an unexpected IOException occurs\n-     *\/\n-    @AfterEach\n-    public void cleanup() throws IOException {\n-        Files.deleteIfExists(zip);\n-    }\n-\n-    \/**\n-     * Verify that the a directory entry like 'META-INF\/' can also be looked\n-     * up using just 'META-INF', that is without the trailing '\/'\n-     * @throws IOException if an unexpected IOException occurs\n-     *\/\n-    @Test\n-    public void lookupDirectoryEntryWithoutTrailingSlash() throws IOException {\n-        try (ZipFile zf = new ZipFile(zip.toFile())) {\n-            \/\/ Look up 'META-INF\/' using just 'META-INF'\n-            ZipEntry ze = zf.getEntry(\"META-INF\");\n-            assertNotNull(ze, \"failed to find a directory entry\");\n-            assertEquals(\"META-INF\/\", ze.getName());\n-            \/\/ Sanity check that 'META-INF\/' can be found\n-            ze = zf.getEntry(\"META-INF\/\");\n-            assertNotNull(ze, \"failed to find a directory entry\");\n-            assertEquals(\"META-INF\/\", ze.getName());\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/GetDirEntry.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -25,1 +25,1 @@\n-   @bug 4241361 4842702 4985614 6646605 5032358 6923692 6233323 8144977 8186464\n+   @bug 4241361 4842702 4985614 6646605 5032358 6923692 6233323 8144977 8186464 4401122\n@@ -160,1 +160,1 @@\n-    public void readDirectoryEntry() throws IOException {\n+    public void readDirectoryEntries() throws IOException {\n@@ -162,1 +162,1 @@\n-        \/\/ Create a ZIP containing a directory entry\n+        \/\/ Create a ZIP containing some directory entries\n@@ -165,2 +165,10 @@\n-            ZipEntry ze = new ZipEntry(\"directory\/\");\n-            zos.putNextEntry(ze);\n+            \/\/ Add a META-INF directory with STORED compression type\n+            ZipEntry metaInf = new ZipEntry(\"META-INF\/\");\n+            metaInf.setMethod(ZipEntry.STORED);\n+            metaInf.setSize(0);\n+            metaInf.setCrc(0);\n+            zos.putNextEntry(metaInf);\n+\n+            \/\/ Add a regular directory\n+            ZipEntry dir = new ZipEntry(\"directory\/\");\n+            zos.putNextEntry(dir);\n@@ -170,0 +178,1 @@\n+        \/\/ Verify directory lookups\n@@ -171,0 +180,1 @@\n+            \/\/ Look up 'directory\/' using the full name\n@@ -174,1 +184,2 @@\n-\n+            assertEquals(\"directory\/\", ze.getName());\n+            \n@@ -181,0 +192,1 @@\n+            \/\/ Look up 'directory\/' without the trailing slash\n@@ -184,0 +196,2 @@\n+            assertEquals(\"directory\/\", ze.getName());\n+\n@@ -189,0 +203,5 @@\n+            \/\/ Sanity check that also META-INF\/ can be looked up with or without the trailing slash\n+            assertNotNull(zf.getEntry(\"META-INF\"));\n+            assertNotNull(zf.getEntry(\"META-INF\/\"));\n+            assertEquals(zf.getEntry(\"META-INF\").getName(),\n+                    zf.getEntry(\"META-INF\/\").getName());\n@@ -256,0 +275,40 @@\n+    \/**\n+     * Check that the available() method overriden by the input stream returned by\n+     * ZipFile.getInputStream correctly returns the number of remaining uncompressed bytes\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void availableShouldReturnRemainingUncompressedBytes() throws IOException {\n+        \/\/ The number of uncompressed bytes to write to the sample ZIP entry\n+        final int expectedBytes = 512;\n+\n+        \/\/ Create a sample ZIP with deflated entry of a known uncompressed size\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            zo.write(new byte[expectedBytes]);\n+        }\n+\n+        \/\/ Verify the behavior of ZipFileInflaterInputStream.available()\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry e = zf.getEntry(\"file.txt\");\n+            try (InputStream in = zf.getInputStream(e)) {\n+                \/\/ Initially, available() should return the full uncompressed size of the entry\n+                assertEquals(expectedBytes, in.available(),\n+                        \"wrong initial return value of available\");\n+\n+                \/\/ Reading a few bytes should reduce the number of available bytes accordingly\n+                int bytesToRead = 10;\n+                in.read(new byte[bytesToRead]);\n+                assertEquals(expectedBytes - bytesToRead, in.available());\n+\n+                \/\/ Reading all remaining bytes should reduce the number of available bytes to zero\n+                in.transferTo(OutputStream.nullOutputStream());\n+                assertEquals(0, in.available());\n+\n+                \/\/ available on a closed input stream should return zero\n+                in.close();\n+                assertEquals(0, in.available());\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ReadZip.java","additions":65,"deletions":6,"binary":false,"changes":71,"status":"modified"}]}