{"files":[{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8253952\n@@ -27,1 +28,1 @@\n- * @run main\/othervm CopyZipFile\n+ * @run junit CopyZipFile\n@@ -30,5 +31,5 @@\n-import java.io.File;\n-import java.io.ByteArrayOutputStream;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n@@ -37,0 +38,3 @@\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -40,7 +44,3 @@\n-import java.util.zip.CRC32;\n-import java.util.zip.Deflater;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipException;\n-import java.util.zip.ZipFile;\n-import java.util.zip.ZipInputStream;\n-import java.util.zip.ZipOutputStream;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -49,2 +49,4 @@\n-    private static final String ZIP_FILE = \"first.zip\";\n-    private static final String TEST_STRING = \"TestTestTest\";\n+    \/\/ ZIP file created in this test\n+    private Path zip = Path.of(\"first.zip\");\n+    \/\/ The content to put in each entry\n+    private static final byte[] TEST_STRING = \"TestTestTest\".getBytes(StandardCharsets.UTF_8);\n@@ -52,4 +54,14 @@\n-    private static void createZip(String zipFile) throws Exception {\n-        File f = new File(zipFile);\n-        f.deleteOnExit();\n-        try (OutputStream os = new FileOutputStream(f);\n+    \/**\n+     * Create the sample ZIP file used in this test, including a STORED entry\n+     * and DEFLATE entries with various compression levels.\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void createZip() throws IOException {\n+        \/\/ By default, ZipOutputStream creates zip files with Local File Headers\n+        \/\/ without size, compressed size and crc values and an extra Data\n+        \/\/ Descriptor (see https:\/\/en.wikipedia.org\/wiki\/Zip_(file_format)\n+        \/\/ after the data belonging to that entry with these values if in the\n+        \/\/ corresponding ZipEntry one of the size, compressedSize or crc fields is\n+        \/\/ equal to '-1' (which is the default for newly created ZipEntries).\n+        try (OutputStream os = Files.newOutputStream(zip) ;\n@@ -58,3 +70,4 @@\n-            zos.putNextEntry(new ZipEntry(\"test1.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n-            zos.closeEntry();\n+            zos.setLevel(Deflater.DEFAULT_COMPRESSION);\n+            zos.putNextEntry(new ZipEntry(\"DEFAULT_COMPRESSION.txt\"));\n+            zos.write(TEST_STRING);\n+\n@@ -63,4 +76,3 @@\n-            ZipEntry ze = new ZipEntry(\"test2.txt\");\n-            int length = TEST_STRING.length();\n-            ze.setSize(length);\n-            ze.setCompressedSize(length);\n+            ZipEntry ze = new ZipEntry(\"STORED.txt\");\n+            ze.setSize(TEST_STRING.length);\n+            ze.setCompressedSize(TEST_STRING.length);\n@@ -68,1 +80,1 @@\n-            crc.update(TEST_STRING.getBytes(\"utf8\"), 0, length);\n+            crc.update(TEST_STRING);\n@@ -71,1 +83,2 @@\n-            zos.write(TEST_STRING.getBytes());\n+            zos.write(TEST_STRING);\n+\n@@ -75,2 +88,3 @@\n-            zos.putNextEntry(new ZipEntry(\"test3.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n+            zos.putNextEntry(new ZipEntry(\"NO_COMPRESSION.txt\"));\n+            zos.write(TEST_STRING);\n+\n@@ -79,2 +93,3 @@\n-            zos.putNextEntry(new ZipEntry(\"test4.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n+            zos.putNextEntry(new ZipEntry(\"BEST_SPEED.txt\"));\n+            zos.write(TEST_STRING);\n+\n@@ -83,2 +98,2 @@\n-            zos.putNextEntry(new ZipEntry(\"test5.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n+            zos.putNextEntry(new ZipEntry(\"BEST_COMPRESSION.txt\"));\n+            zos.write(TEST_STRING);\n@@ -88,22 +103,26 @@\n-    public static void main(String args[]) throws Exception {\n-        \/\/ By default, ZipOutputStream creates zip files with Local File Headers\n-        \/\/ without size, compressedSize and crc values and an extra Data\n-        \/\/ Descriptor (see https:\/\/en.wikipedia.org\/wiki\/Zip_(file_format)\n-        \/\/ after the data belonging to that entry with these values if in the\n-        \/\/ corresponding ZipEntry one of the size, compressedSize or crc fields is\n-        \/\/ equal to '-1' (which is the default for newly created ZipEntries).\n-        createZip(ZIP_FILE);\n-\n-        \/\/ Now read all the entries of the newly generated zip file with a ZipInputStream\n-        \/\/ and copy them to a new zip file with the help of a ZipOutputStream.\n-        \/\/ This only works reliably because the generated zip file has no values for the\n-        \/\/ size, compressedSize and crc values of a zip entry in the local file header and\n-        \/\/ therefore the ZipEntry objects created by ZipOutputStream.getNextEntry() will have\n-        \/\/ all these fields set to '-1'.\n-        ZipEntry entry;\n-        byte[] buf = new byte[512];\n-        try (InputStream is = new FileInputStream(ZIP_FILE);\n-             ZipInputStream zis = new ZipInputStream(is);\n-             OutputStream os = new ByteArrayOutputStream();\n-             ZipOutputStream zos = new ZipOutputStream(os)) {\n-            while((entry = zis.getNextEntry())!=null) {\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Read all entries using ZipInputStream.getNextEntry and copy them\n+     * to a new zip file using ZipOutputStream.putNextEntry. This only works\n+     * reliably because the input zip file has no values for the size, compressedSize\n+     * and crc values of streamed zip entries in the local file header and\n+     * therefore the ZipEntry objects created by ZipOutputStream.getNextEntry\n+     * will have all these fields set to '-1'.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void copyFromZipInputStreamToZipOutputStream() throws IOException {\n+\n+        try (ZipInputStream zis = new ZipInputStream(Files.newInputStream(zip));\n+             ZipOutputStream zos = new ZipOutputStream(OutputStream.nullOutputStream())) {\n+            ZipEntry entry;\n+            while ((entry = zis.getNextEntry()) != null) {\n@@ -114,5 +133,7 @@\n-                    String.format(\"name=%s, clen=%d, len=%d, crc=%d\",\n-                                  entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n-                if (entry.getMethod() == ZipEntry.DEFLATED &&\n-                    (entry.getCompressedSize() != -1 || entry.getSize() != -1 || entry.getCrc() != -1)) {\n-                    throw new Exception(\"'size', 'compressedSize' and 'crc' shouldn't be initialized at this point.\");\n+                        String.format(\"name=%s, clen=%d, len=%d, crc=%d\",\n+                                entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n+                if (entry.getMethod() == ZipEntry.DEFLATED) {\n+                    \/\/ Expect size, compressed size and crc to not be initialized at this point\n+                    assertEquals(-1, entry.getCompressedSize());\n+                    assertEquals(-1, entry.getSize());\n+                    assertEquals(-1, entry.getCrc());\n@@ -127,5 +148,6 @@\n-                    String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n-                                  entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n-                if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n-                    throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n-                }\n+                        String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n+                                entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n+                \/\/ Expect size, compressed size and crc to be initialized at this point\n+                assertNotEquals(-1, entry.getCompressedSize());\n+                assertNotEquals(-1, entry.getSize());\n+                assertNotEquals(-1, entry.getCrc());\n@@ -134,0 +156,1 @@\n+    }\n@@ -135,15 +158,21 @@\n-        \/\/ Now we read all the entries of the initially generated zip file with the help\n-        \/\/ of the ZipFile class. The ZipFile class reads all the zip entries from the Central\n-        \/\/ Directory which must have accurate information for size, compressedSize and crc.\n-        \/\/ This means that all ZipEntry objects returned from ZipFile will have correct\n-        \/\/ settings for these fields.\n-        \/\/ If the compression level was different in the initial zip file (which we can't find\n-        \/\/ out any more now because the zip file format doesn't record this information) the\n-        \/\/ size of the re-compressed entry we are writing to the ZipOutputStream might differ\n-        \/\/ from the original compressed size recorded in the ZipEntry. This would result in an\n-        \/\/ \"invalid entry compressed size\" ZipException if ZipOutputStream wouldn't ignore\n-        \/\/ the implicitely set compressed size attribute of ZipEntries read from a ZipFile\n-        \/\/ or ZipInputStream.\n-        try (OutputStream os = new ByteArrayOutputStream();\n-             ZipOutputStream zos = new ZipOutputStream(os);\n-             ZipFile zf = new ZipFile(ZIP_FILE)) {\n+    \/**\n+     * Read all entries using the ZipFile class and copy them to a new zip file\n+     * using ZipOutputStream.putNextEntry.\n+     * The ZipFile class reads all the zip entries from the Central\n+     * Directory, which has accurate information for size, compressedSize and crc.\n+     * This means that all ZipEntry objects returned from ZipFile will have correct\n+     * settings for these fields.\n+     * If the compression level was different in the input zip file (which we can't know\n+     * because the zip file format doesn't record this information), the\n+     * size of the re-compressed entry we are writing to the ZipOutputStream might differ\n+     * from the original compressed size recorded in the ZipEntry. This would result in an\n+     * \"invalid entry compressed size\" ZipException if ZipOutputStream wouldn't ignore\n+     * the implicitely set compressed size attribute of ZipEntries read from a ZipFile\n+     * or ZipInputStream.\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void copyFromZipFileToZipOutputStream() throws IOException {\n+        try (ZipOutputStream zos = new ZipOutputStream(OutputStream.nullOutputStream());\n+             ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry entry;\n@@ -157,4 +186,5 @@\n-                if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n-                    throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n-                }\n-                InputStream is = zf.getInputStream(entry);\n+                \/\/ Expect size, compressed size and crc to be initialized at this point\n+                assertNotEquals(-1, entry.getCompressedSize());\n+                assertNotEquals(-1, entry.getSize());\n+                assertNotEquals(-1, entry.getCrc());\n+\n@@ -162,1 +192,3 @@\n-                is.transferTo(zos);\n+                try (InputStream is = zf.getInputStream(entry)) {\n+                    is.transferTo(zos);\n+                }\n@@ -166,0 +198,17 @@\n+    }\n+\n+    \/**\n+     * If the compressed size is set explicitly using ZipEntry.setCompressedSize(),\n+     * then the entry will be restreamed with a data descriptor and the compressed size\n+     * recomputed. If the source compression level was different from the target compression\n+     * level, the compressed sizes may differ and a ZipException will be thrown\n+     * when the entry is closed in ZipOutputStream.closeEntry\n+     *\n+     * @throws IOException if an unexpected IOException is thrown\n+     *\/\n+    @Test\n+    public void explicitCompressedSizeWithDifferentCompressionLevels() throws IOException {\n+        try (ZipOutputStream zos = new ZipOutputStream(OutputStream.nullOutputStream());\n+             ZipFile zf = new ZipFile(zip.toFile())) {\n+            \/\/ Be explicit about the default compression level\n+            zos.setLevel(Deflater.DEFAULT_COMPRESSION);\n@@ -167,5 +216,0 @@\n-        \/\/ The compressed size attribute of a ZipEntry shouldn't be ignored if it was set\n-        \/\/ explicitely by calling ZipEntry.setCpompressedSize()\n-        try (OutputStream os = new ByteArrayOutputStream();\n-             ZipOutputStream zos = new ZipOutputStream(os);\n-             ZipFile zf = new ZipFile(ZIP_FILE)) {\n@@ -174,4 +218,6 @@\n-                try {\n-                    entry = entries.nextElement();\n-                    entry.setCompressedSize(entry.getCompressedSize());\n-                    InputStream is = zf.getInputStream(entry);\n+                ZipEntry entry = entries.nextElement();\n+\n+                \/\/ Explicitly set compressed size to enforce data descriptor and revalidation\n+                entry.setCompressedSize(entry.getCompressedSize());\n+\n+                try (InputStream is = zf.getInputStream(entry)) {\n@@ -180,9 +226,35 @@\n-                    zos.closeEntry();\n-                    if (\"test3.txt\".equals(entry.getName())) {\n-                        throw new Exception(\n-                            \"Should throw a ZipException if ZipEntry.setCpompressedSize() was called.\");\n-                    }\n-                } catch (ZipException ze) {\n-                    if (\"test1.txt\".equals(entry.getName()) || \"test2.txt\".equals(entry.getName())) {\n-                        throw new Exception(\n-                            \"Shouldn't throw a ZipExcpetion for STORED files or files compressed with DEFAULT_COMPRESSION\");\n+                    \/\/ Some compression levels lead to unexpected recompressed sizes when closing the entry\n+                    switch (entry.getName()) {\n+                        case \"DEFAULT_COMPRESSION.txt\" -> {\n+                            \/\/ DEFAULT_COMPRESSION matches expected size\n+                            zos.closeEntry();\n+                        }\n+                        case \"STORED.txt\" -> {\n+                            \/\/ STORED should not throw\n+                            zos.closeEntry();\n+                        }\n+                        case \"NO_COMPRESSION.txt\", \"BEST_SPEED.txt\" -> {\n+                            \/\/ NO_COMPRESSION and BEST_SPEED should lead to an unexpected recompressed size\n+                            ZipException ze = assertThrows(ZipException.class, () -> {\n+                                zos.closeEntry();\n+                            });\n+\n+                            \/\/ Hack to fix and close the offending zip entry with the correct recompressed size.\n+                            \/\/ The exception message is something like:\n+                            \/\/   \"invalid entry compressed size (expected 12 but got 7 bytes)\"\n+                            \/\/ and we need to extract the second integer.\n+                            Pattern cSize = Pattern.compile(\"\\\\d+\");\n+                            Matcher m = cSize.matcher(ze.getMessage());\n+                            m.find();\n+                            m.find();\n+                            entry.setCompressedSize(Integer.parseInt(m.group()));\n+                            zos.closeEntry();\n+                        }\n+                        case \"BEST_COMPRESSION.txt\" -> {\n+                            \/\/ BEST_COMPRESSION produces the same compressed\n+                            \/\/ size as DEFAULT_COMPRESSION for sample content\n+                            zos.closeEntry();\n+                        }\n+                        default -> {\n+                            throw new IllegalArgumentException(\"Unexpected entry \" + entry.getName());\n+                        }\n@@ -190,9 +262,0 @@\n-                    \/\/ Hack to fix and close the offending zip entry with the correct compressed size.\n-                    \/\/ The exception message is something like:\n-                    \/\/   \"invalid entry compressed size (expected 12 but got 7 bytes)\"\n-                    \/\/ and we need to extract the second integer.\n-                    Pattern cSize = Pattern.compile(\"\\\\d+\");\n-                    Matcher m = cSize.matcher(ze.getMessage());\n-                    m.find();\n-                    m.find();\n-                    entry.setCompressedSize(Integer.parseInt(m.group()));\n","filename":"test\/jdk\/java\/util\/zip\/CopyZipFile.java","additions":176,"deletions":113,"binary":false,"changes":289,"status":"modified"}]}