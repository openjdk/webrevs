{"files":[{"patch":"@@ -1948,4 +1948,5 @@\n-  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop() &&\n-      u_loop->_head->is_CountedLoop() && u_loop->_head->as_CountedLoop()->is_main_loop() &&\n-      n_loop->_next == get_loop(u_loop->_head->as_CountedLoop()->skip_strip_mined())) {\n-    return false;\n+  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop()) {\n+    CountedLoopNode* pre_loop = n_loop->_head->as_CountedLoop();\n+    if (is_dominator(pre_loop->loopexit(), ctrl)) {\n+      return false;\n+    }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342330\n+ * @summary C2: \"node pinned on loop exit test?\" assert failure\n+ * @requires vm.flavor == \"server\"\n+  *\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:-TieredCompilation\n+ *                   -XX:-UseLoopPredicate -XX:LoopMaxUnroll=0 TestSunkRangeFromPreLoopRCE\n+ *\n+ *\/\n+\n+\n+import java.util.Arrays;\n+\n+public class TestSunkRangeFromPreLoopRCE {\n+    private static int[] array = new int[1000];\n+    private static A objectField = new A(42);\n+\n+    public static void main(String[] args) {\n+        boolean[] allTrue = new boolean[1000];\n+        Arrays.fill(allTrue, true);\n+        boolean[] allFalse = new boolean[1000];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(array.length\/4, allTrue, 1, 0);\n+            test1(array.length\/4, allFalse, 1, 0);\n+        }\n+    }\n+\n+    private static int test1(int stop, boolean[] flags, int otherScale, int x) {\n+        int scale;\n+        for (scale = 0; scale < 4; scale++) {\n+            for (int i = 0; i < 10; i++) {\n+\n+            }\n+        }\n+        if (array == null) {\n+        }\n+        int v = 0;\n+        for (int i = 0; i < stop; i++) {\n+            v += array[i];\n+            v += array[scale * i];\n+            if (i * scale + (objectField.intField + 1) == x) {\n+            }\n+            v += (scale - 4) * (x-objectField.intField);\n+            if (flags[i]) {\n+                return (x-objectField.intField);\n+            }\n+        }\n+        return v;\n+    }\n+\n+    private static class A {\n+        A(int field) {\n+            intField = field;\n+        }\n+        public int intField;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestSunkRangeFromPreLoopRCE.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"}]}