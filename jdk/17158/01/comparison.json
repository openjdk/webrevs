{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -28,0 +28,1 @@\n+#include \"procMapsParser.inline.hpp\"\n@@ -30,0 +31,2 @@\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -33,14 +36,13 @@\n-struct ProcMapsInfo {\n-  void* from = 0;\n-  void* to = 0;\n-  char prot[20 + 1];\n-  char offset[20 + 1];\n-  char dev[20 + 1];\n-  char inode[20 + 1];\n-  char filename[1024 + 1];\n-\n-  bool scan_proc_maps_line(const char* line) {\n-    prot[0] = offset[0] = dev[0] = inode[0] = filename[0] = '\\0';\n-    const int items_read = ::sscanf(line, \"%p-%p %20s %20s %20s %20s %1024s\",\n-        &from, &to, prot, offset, dev, inode, filename);\n-    return items_read >= 2; \/\/ need at least from and to\n+class ProcMapsSummary {\n+  unsigned _num_mappings;\n+  size_t _vsize;\n+public:\n+  ProcMapsSummary() : _num_mappings(0), _vsize(0) {}\n+  void add_mapping(ProcMapsInfo& info) {\n+    _num_mappings ++;\n+    _vsize += info.vsize();\n+  }\n+  void print_on(const MappingPrintSession& session) const {\n+    outputStream* st = session.out();\n+    st->print_cr(\"Number of mappings: %u\", _num_mappings);\n+    st->print_cr(\"             vsize: %zu (\" PROPERFMT \")\", _vsize, PROPERFMTARGS(_vsize));\n@@ -50,2 +52,2 @@\n-class LinuxMappingPrintInformation : public MappingPrintInformation {\n-  const ProcMapsInfo _info;\n+class ProcMapsPrinter {\n+  const MappingPrintSession& _session;\n@@ -53,0 +55,30 @@\n+  ProcMapsPrinter(const MappingPrintSession& session) :\n+    _session(session)\n+  {}\n+\n+  void print_single_mapping(const ProcMapsInfo& info) const {\n+    assert(!_session.options().detail_mode, \"Should be called only for simple mode\");\n+    outputStream* st = _session.out();\n+    int pos = 0;\n+#define INDENT_BY(n) pos += n; st->fill_to(pos);\n+    st->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(info.from), p2i(info.to));\n+    INDENT_BY(40);\n+    st->print(\"%10zu\", info.vsize());\n+    INDENT_BY(11);\n+    st->print(\"%s \", info.prot);\n+    INDENT_BY(5);\n+    _session.print_nmt_info_for_region(info.from, info.to);\n+    INDENT_BY(10);\n+    st->print_raw(info.filename);\n+#undef INDENT\n+    st->cr();\n+  }\n+\n+  void print_legend() const {\n+    outputStream* st = _session.out();\n+    st->print_cr(\"from, to, vsize: address range and size\");\n+    st->print_cr(\"prot:            protection\");\n+    st->print_cr(\"vm info:         VM information (requires NMT)\");\n+    _session.print_nmt_flag_legend(16);\n+    st->print_cr(\"file:            file mapped, if mapping is not anonymous\");\n+  }\n@@ -54,2 +86,36 @@\n-  LinuxMappingPrintInformation(const void* from, const void* to, const ProcMapsInfo* info) :\n-    MappingPrintInformation(from, to), _info(*info) {}\n+  void print_header() const {\n+    outputStream* st = _session.out();\n+    \/\/            .         .         .         .         .         .         .         .         .         .         .\n+    \/\/            01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/            0x0000000414000000 - 0x0000000453000000 1234567890 rw-p JAVAHEAP  \/shared\/tmp.txt\n+    st->print_cr(\"from                 to                      vsize prot vm-info   file\");\n+  }\n+};\n+\n+\/\/ A simple histogram for sizes by pagesize. We keep pagesizes in an array by page size bit\n+\/\/ index. Smallest page size we expect is 4k (2^12), largest pagesize we expect is 16G (powerpc)\n+\/\/ - 2^34. So we store 34-12 = 22 sizes.\n+class PageSizeHistogram {\n+  static constexpr int log_smallest_pagesize = 12; \/\/ 4K\n+  static constexpr int log_largest_pagesize = 34;  \/\/ 16G, ppc\n+  static constexpr int num_pagesizes = log_largest_pagesize - log_smallest_pagesize;\n+  size_t _v[num_pagesizes];\n+public:\n+  PageSizeHistogram() { memset(_v, 0, sizeof(_v)); }\n+  void add(size_t pagesize, size_t size) {\n+    assert(is_aligned(size, pagesize), \"strange\");\n+    const int n = exact_log2(pagesize) - log_smallest_pagesize;\n+    assert(n >= 0 && n < num_pagesizes, \"strange\");\n+    _v[n] += size;\n+  }\n+  void print_on(outputStream* st) const {\n+    for (int i = 0; i < num_pagesizes; i++) {\n+      if (_v[i] > 0) {\n+        const size_t pagesize = 1 << (log_smallest_pagesize + i);\n+        st->fill_to(16);\n+        st->print(EXACTFMT, EXACTFMTARGS(pagesize));\n+        st->print_cr(\": %zu pages, %zu bytes (\" PROPERFMT \")\", _v[i] \/ pagesize, _v[i], PROPERFMTARGS(_v[i]));\n+      }\n+    }\n+  }\n+};\n@@ -57,2 +123,28 @@\n-  void print_OS_specific_details(outputStream* st) const override {\n-    st->print(\"%s %s \", _info.prot, _info.offset);\n+class ProcSmapsSummary {\n+  unsigned _num_mappings;\n+  size_t _vsize;\n+  size_t _rss;\n+  size_t _committed;\n+  size_t _shared;\n+  size_t _swapped_out;\n+  size_t _hugetlb;\n+  size_t _thp;\n+  PageSizeHistogram _pagesizes;\n+public:\n+  ProcSmapsSummary() : _num_mappings(0), _vsize(0), _rss(0), _committed(0), _shared(0),\n+                     _swapped_out(0), _hugetlb(0), _thp(0) {}\n+  void add_mapping(ProcSmapsInfo& info) {\n+    _num_mappings ++;\n+    _vsize += info.vsize();\n+    _rss += info.rss;\n+    _committed += info.nr ? 0 : info.vsize();\n+    _shared += info.sh ? info.vsize() : 0;\n+    _swapped_out += info.swap;\n+    _hugetlb += info.private_hugetlb + info.shared_hugetlb;\n+    _thp += info.anonhugepages;\n+    if (info.ht) {\n+      _pagesizes.add(info.kernelpagesize,\n+                     info.private_hugetlb + info.shared_hugetlb);\n+    } else {\n+      _pagesizes.add(info.kernelpagesize, info.rss); \/\/ only resident pages\n+    }\n@@ -61,1 +153,13 @@\n-  const char* filename() const override { return _info.filename; }\n+  void print_on(const MappingPrintSession& session) const {\n+    outputStream* st = session.out();\n+    st->print_cr(\"Number of mappings: %u\", _num_mappings);\n+    st->print_cr(\"             vsize: %zu (\" PROPERFMT \")\", _vsize, PROPERFMTARGS(_vsize));\n+    st->print_cr(\"               rss: %zu (\" PROPERFMT \")\", _rss, PROPERFMTARGS(_rss));\n+    st->print_cr(\"         committed: %zu (\" PROPERFMT \")\", _committed, PROPERFMTARGS(_committed));\n+    st->print_cr(\"            shared: %zu (\" PROPERFMT \")\", _shared, PROPERFMTARGS(_shared));\n+    st->print_cr(\"       swapped out: %zu (\" PROPERFMT \")\", _swapped_out, PROPERFMTARGS(_swapped_out));\n+    st->print_cr(\"         using thp: %zu (\" PROPERFMT \")\", _thp, PROPERFMTARGS(_thp));\n+    st->print_cr(\"           hugetlb: %zu (\" PROPERFMT \")\", _hugetlb, PROPERFMTARGS(_hugetlb));\n+    st->print_cr(\"By page size:\");\n+    _pagesizes.print_on(st);\n+  }\n@@ -64,2 +168,112 @@\n-void MemMapPrinter::pd_print_header(outputStream* st) {\n-  st->print_cr(\"size          prot offset  What\");\n+class ProcSmapsPrinter {\n+  const MappingPrintSession& _session;\n+public:\n+  ProcSmapsPrinter(const MappingPrintSession& session) :\n+    _session(session)\n+  {}\n+\n+  void print_single_mapping(const ProcSmapsInfo& info) const {\n+    assert(_session.options().detail_mode, \"Should be called only for detail mode\");\n+    outputStream* st = _session.out();\n+    int pos = 0;\n+  #define INDENT_BY(n) pos += n; st->fill_to(pos);\n+    st->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(info.from), p2i(info.to));\n+    INDENT_BY(40);\n+    st->print(\"%10zu\", info.vsize());\n+    INDENT_BY(11);\n+    st->print(\"%s \", info.prot);\n+    INDENT_BY(5);\n+    st->print(\"%10zu\", info.rss);\n+    INDENT_BY(11);\n+    st->print(\"%10zu\", info.private_hugetlb);\n+    INDENT_BY(11);\n+    st->print(EXACTFMT \" \", EXACTFMTARGS(info.kernelpagesize));\n+    INDENT_BY(5);\n+\n+    bool comma = false;\n+  #define PRINTIF(cond, s) \\\n+    if (cond) { \\\n+      st->print(\"%s%s\", (comma ? \",\" : \"\"), s); \\\n+      comma = true; \\\n+    }\n+    PRINTIF(info.anonhugepages > 0, \"thp\");\n+    PRINTIF(info.hg, \"thpadv\");\n+    PRINTIF(info.nh, \"nothp\");\n+    PRINTIF(info.sh, \"shrd\");\n+    PRINTIF(info.ht, \"huge\");\n+    PRINTIF(info.nr, \"nores\");\n+    PRINTIF(info.thp_eligible, \"thpel\");\n+    PRINTIF(info.swap > 0, \"swap\");\n+    if (comma) {\n+      st->print(\" \");\n+    }\n+  #undef PRINTIF\n+    INDENT_BY(17);\n+    _session.print_nmt_info_for_region(info.from, info.to);\n+    INDENT_BY(10);\n+    st->print_raw(info.filename);\n+  #undef INDENT_BY\n+    st->cr();\n+  }\n+\n+  void print_legend() const {\n+    outputStream* st = _session.out();\n+    st->print_cr(\"from, to, vsize: address range and size\");\n+    st->print_cr(\"prot:            protection\");\n+    st->print_cr(\"rss:             resident set size\");\n+    st->print_cr(\"hugetlb:         size of private hugetlb pages\");\n+    st->print_cr(\"pgsz:            page size\");\n+    st->print_cr(\"notes:           mapping information  (detail mode only)\");\n+    st->print_cr(\"                    shared: mapping is shared\");\n+    st->print_cr(\"                     nores: mapping uncommitted (no swap space reserved)\");\n+    st->print_cr(\"                      swap: mapping partly or completely swapped out\");\n+    st->print_cr(\"                       thp: mapping uses THP\");\n+    st->print_cr(\"                     thpel: mapping is eligible for THP\");\n+    st->print_cr(\"                    thpadv: mapping is THP-madvised\");\n+    st->print_cr(\"                     nothp: mapping will not THP\");\n+    st->print_cr(\"                      huge: mapping uses hugetlb pages\");\n+    st->print_cr(\"vm info:         VM information (requires NMT)\");\n+    _session.print_nmt_flag_legend(16);\n+    st->print_cr(\"file:            file mapped, if mapping is not anonymous\");\n+  }\n+\n+  void print_header() const {\n+    outputStream* st = _session.out();\n+    \/\/            .         .         .         .         .         .         .         .         .         .         .         .\n+    \/\/            012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/            0x0000000414000000 - 0x0000000453000000 1234567890 rw-p 1234567890 1234567890 16g  thp,thpadv       JAVAHEAP  \/shared\/tmp.txt\n+    st->print_cr(\"from                 to                      vsize prot        rss    hugetlb pgsz notes            vm-info   file\");\n+  }\n+};\n+\n+template <class SUMMARY, class PRINTER, class PARSER, class INFO>\n+static void print_mappings_helper(FILE* f, const MappingPrintSession& session) {\n+  PRINTER printer(session);\n+  SUMMARY summary;\n+\n+  const bool print_each_mapping = !session.options().only_summary;\n+  outputStream* const st = session.out();\n+\n+  if (print_each_mapping) {\n+    printer.print_legend();\n+    st->cr();\n+    printer.print_header();\n+  }\n+\n+  INFO info;\n+  PARSER parser(f);\n+  while (parser.parse_next(info)) {\n+    if (print_each_mapping) {\n+      printer.print_single_mapping(info);\n+    }\n+    summary.add_mapping(info);\n+  }\n+  st->cr();\n+\n+  if (parser.had_error()) {\n+    session.out()->print_cr(\"Error while reading mappings\");\n+    return;\n+  }\n+\n+  summary.print_on(session);\n+  st->cr();\n@@ -68,2 +282,5 @@\n-void MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {\n-  FILE* f = os::fopen(\"\/proc\/self\/maps\", \"r\");\n+\n+void MemMapPrinter::pd_print_all_mappings(const MappingPrintSession& session) {\n+  const bool is_detail_mode = session.options().detail_mode;\n+  const char* filename = is_detail_mode ? \"\/proc\/self\/smaps\" : \"\/proc\/self\/maps\";\n+  FILE* f = os::fopen(filename, \"r\");\n@@ -71,0 +288,1 @@\n+    session.out()->print_cr(\"Cannot open %s\", filename);\n@@ -73,9 +291,5 @@\n-  constexpr size_t linesize = sizeof(ProcMapsInfo);\n-  char line[linesize];\n-  while (fgets(line, sizeof(line), f) == line) {\n-    line[sizeof(line) - 1] = '\\0';\n-    ProcMapsInfo info;\n-    if (info.scan_proc_maps_line(line)) {\n-      LinuxMappingPrintInformation mapinfo(info.from, info.to, &info);\n-      closure.do_it(&mapinfo);\n-    }\n+\n+  if (is_detail_mode) {\n+    print_mappings_helper<ProcSmapsSummary, ProcSmapsPrinter, ProcSmapsParser, ProcSmapsInfo>(f, session);\n+  } else {\n+    print_mappings_helper<ProcMapsSummary, ProcMapsPrinter, ProcMapsParser, ProcMapsInfo>(f, session);\n@@ -83,0 +297,1 @@\n+\n","filename":"src\/hotspot\/os\/linux\/memMapPrinter_linux.cpp","additions":251,"deletions":36,"binary":false,"changes":287,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"procMapsParser.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+static bool is_lowercase_hex(char c) {\n+  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f');\n+}\n+\n+static size_t max_mapping_line_len() {\n+  return 100 + \/\/ everything but the file name\n+         os::vm_page_size() \/\/ the file name (kernel limits \/proc\/pid\/cmdline to 1 page\n+         ;\n+}\n+\n+ProcMapsParserBase::ProcMapsParserBase(FILE* f) :\n+  _f(f), _had_error(false),\n+  _linelen(max_mapping_line_len()), _line(nullptr)\n+{\n+  assert(_f != nullptr, \"Invalid file handle given\");\n+  _line = NEW_C_HEAP_ARRAY(char, max_mapping_line_len(), mtInternal);\n+  _line[0] = '\\0';\n+}\n+\n+ProcMapsParserBase::~ProcMapsParserBase() {\n+  FREE_C_HEAP_ARRAY(char, _line);\n+}\n+\n+bool ProcMapsParserBase::read_line() {\n+  assert(!_had_error, \"Don't call in error state\");\n+  char* rc = ::fgets(_line, _linelen, _f);\n+  if (rc == nullptr) {\n+    _line[0] = '\\0';\n+    _had_error = (::ferror(_f) != 0);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ Starts or continues parsing. Returns true on success,\n+\/\/ false on EOF or on error.\n+bool ProcMapsParser::parse_next(ProcMapsInfo& out) {\n+  bool success = false;\n+  out.reset();\n+  while (success == false) {\n+    if (!read_line()) {\n+      return false;\n+    }\n+    const int items_read = ::sscanf(_line, \"%p-%p %20s %*20s %*20s %*20s %1024s\",\n+        &out.from, &out.to, out.prot, out.filename);\n+    success = (items_read >= 2);\n+  }\n+  return true;\n+}\n+\n+bool ProcSmapsParser::is_header_line() {\n+  return is_lowercase_hex(_line[0]); \/\/ All other lines start with uppercase letters\n+}\n+\n+void ProcSmapsParser::scan_header_line(ProcSmapsInfo& out) {\n+  const int items_read = ::sscanf(_line, \"%p-%p %20s %*s %*s %*s %1024s\",\n+                                  &out.from, &out.to, out.prot, out.filename);\n+  assert(items_read >= 2, \"Expected header_line\");\n+}\n+\n+void ProcSmapsParser::scan_additional_line(ProcSmapsInfo& out) {\n+#define SCAN(key, var) \\\n+ if (::sscanf(_line, key \": %zu kB\", &var) == 1) { \\\n+     var *= K; \\\n+     return; \\\n+ }\n+  SCAN(\"KernelPageSize\", out.kernelpagesize);\n+  SCAN(\"Rss\", out.rss);\n+  SCAN(\"AnonHugePages\", out.anonhugepages);\n+  SCAN(\"Private_Hugetlb\", out.private_hugetlb);\n+  SCAN(\"Shared_Hugetlb\", out.shared_hugetlb);\n+  SCAN(\"Swap\", out.swap);\n+  int i = 0;\n+  if (::sscanf(_line, \"THPeligible: %d\", &i) == 1) {\n+    out.thp_eligible = (i == 1);\n+  }\n+#undef SCAN\n+  \/\/ scan some flags too\n+  if (strncmp(_line, \"VmFlags:\", 8) == 0) {\n+#define SCAN(flag) { out.flag = (::strstr(_line + 8, \" \" #flag) != nullptr); }\n+    SCAN(rd);\n+    SCAN(wr);\n+    SCAN(ex);\n+    SCAN(nr);\n+    SCAN(sh);\n+    SCAN(hg);\n+    SCAN(ht);\n+    SCAN(nh);\n+#undef SCAN\n+    return;\n+  }\n+}\n+\n+\/\/ Starts or continues parsing. Returns true on success,\n+\/\/ false on EOF or on error.\n+bool ProcSmapsParser::parse_next(ProcSmapsInfo& out) {\n+  \/\/ Information about a single mapping reaches across several lines.\n+  out.reset();\n+  \/\/ Read header line, unless we already read it\n+  if (_line[0] == '\\0') {\n+    if (!read_line()) {\n+      return false;\n+    }\n+  }\n+  assert(is_header_line(), \"Not a header line: \\\"%s\\\".\", _line);\n+  scan_header_line(out);\n+  \/\/ Now read until we encounter the next header line or EOF or an error.\n+  bool stop = false;\n+  do {\n+    stop = !read_line() || is_header_line();\n+    if (!stop) {\n+      scan_additional_line(out);\n+    }\n+  } while (!stop);\n+\n+  return !had_error();\n+}\n","filename":"src\/hotspot\/os\/linux\/procMapsParser.cpp","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_PROCMAPSPARSER_HPP\n+#define OS_LINUX_PROCMAPSPARSER_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ This header exposes two simple parsers for \/proc\/pid\/maps and\n+\/\/ \/proc\/pid\/smaps.\n+\/\/\n+\/\/ Usage:\n+\/\/\n+\/\/ FILE* f = fopen(...)\n+\/\/ ProcMapsParser parser(f);\n+\/\/ ProcMapsInfo info;\n+\/\/ while (parser.parse_next(info)) { ... }\n+\n+struct ProcMapsInfo {\n+  void* from;\n+  void* to;\n+  char prot[20 + 1];\n+  char filename[1024 + 1];\n+  inline virtual void reset();\n+  inline size_t vsize() const;\n+};\n+\n+struct ProcSmapsInfo : public ProcMapsInfo {\n+  size_t kernelpagesize;\n+  size_t rss;\n+  size_t private_hugetlb;\n+  size_t shared_hugetlb;\n+  size_t anonhugepages;\n+  size_t swap;\n+  bool rd, wr, ex;\n+  bool sh; \/\/ shared\n+  bool nr; \/\/ no reserve\n+  bool hg; \/\/ thp-advised\n+  bool ht; \/\/ uses hugetlb pages\n+  bool nh; \/\/ thp forbidden\n+  bool thp_eligible;\n+  inline void reset() override;\n+};\n+\n+class ProcMapsParserBase {\n+  FILE* _f;\n+  bool _had_error;\n+protected:\n+  const size_t _linelen;\n+  char* _line;\n+  bool read_line(); \/\/ sets had_error in case of error\n+public:\n+  ProcMapsParserBase(FILE* f);\n+  ~ProcMapsParserBase();\n+  bool had_error() const { return _had_error; }\n+};\n+\n+class ProcMapsParser : public ProcMapsParserBase {\n+public:\n+  ProcMapsParser(FILE* f) : ProcMapsParserBase(f) {}\n+  \/\/ Starts or continues parsing. Returns true on success,\n+  \/\/ false on EOF or on error.\n+  bool parse_next(ProcMapsInfo& out);\n+};\n+\n+class ProcSmapsParser : public ProcMapsParserBase {\n+  bool is_header_line();\n+  void scan_header_line(ProcSmapsInfo& out);\n+  void scan_additional_line(ProcSmapsInfo& out);\n+public:\n+  ProcSmapsParser(FILE* f) : ProcMapsParserBase(f) {}\n+  \/\/ Starts or continues parsing. Returns true on success,\n+  \/\/ false on EOF or on error.\n+  bool parse_next(ProcSmapsInfo& out);\n+};\n+\n+#endif \/\/ OS_LINUX_PROCMAPSPARSER_HPP\n","filename":"src\/hotspot\/os\/linux\/procMapsParser.hpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_PROCMAPSPARSER_INLINE_HPP\n+#define OS_LINUX_PROCMAPSPARSER_INLINE_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"procMapsParser.hpp\"\n+\n+void ProcMapsInfo::reset() {\n+  from = to = nullptr;\n+  prot[0] = filename[0] = '\\0';\n+}\n+\n+size_t ProcMapsInfo::vsize() const {\n+  return from < to ? pointer_delta(to, from, 1) : 0;\n+}\n+\n+void ProcSmapsInfo::reset() {\n+  ProcMapsInfo::reset();\n+  kernelpagesize = rss = private_hugetlb = anonhugepages = swap = 0;\n+}\n+\n+#endif \/\/ OS_LINUX_PROCMAPSPARSER_INLINE_HPP\n","filename":"src\/hotspot\/os\/linux\/procMapsParser.inline.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -1891,0 +1891,12 @@\n+void CodeCache::print_name_for_heap_containing(outputStream *out, const void* p) {\n+  FOR_ALL_ALLOCABLE_HEAPS(heap) {\n+    if ((*heap)->low_boundary() <= p && (*heap)->high_boundary() >= p) {\n+      out->print_raw((*heap)->name());\n+      return;\n+    } else if ((*heap)->low_boundary_segmap() <= p && (*heap)->high_boundary_segmap() >= p) {\n+      out->print(\"Segment map for %s\", (*heap)->name());\n+      return;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -338,0 +338,1 @@\n+  static void print_name_for_heap_containing(outputStream *out, const void* p);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,0 +171,3 @@\n+  \/\/ Boundaries of segment map\n+  const char* low_boundary_segmap() const        { return _segmap.low_boundary(); }\n+  const char* high_boundary_segmap() const       { return _segmap.high_boundary(); }\n","filename":"src\/hotspot\/share\/memory\/heap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"code\/codeCache.hpp\"\n@@ -211,2 +212,6 @@\n-static void print_legend(outputStream* st) {\n-#define DO(flag, shortname, text) st->print_cr(\"%10s    %s\", shortname, text);\n+MappingPrintSession::MappingPrintSession(outputStream* st, const CachedNMTInformation& nmt_info, MappingPrintOptions options) :\n+    _out(st), _options(options), _nmt_info(nmt_info)\n+{}\n+\n+void MappingPrintSession::print_nmt_flag_legend(int indent) const {\n+#define DO(flag, shortname, text) _out->fill_to(indent); _out->print_cr(\"%10s: %s\", shortname, text);\n@@ -217,28 +222,1 @@\n-MappingPrintClosure::MappingPrintClosure(outputStream* st, bool human_readable, const CachedNMTInformation& nmt_info) :\n-    _out(st), _human_readable(human_readable),\n-    _total_count(0), _total_vsize(0), _nmt_info(nmt_info)\n-{}\n-\n-void MappingPrintClosure::do_it(const MappingPrintInformation* info) {\n-\n-  _total_count++;\n-\n-  const void* const vma_from = info->from();\n-  const void* const vma_to = info->to();\n-\n-  \/\/ print from, to\n-  _out->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(vma_from), p2i(vma_to));\n-  const size_t size = pointer_delta(vma_to, vma_from, 1);\n-  _total_vsize += size;\n-\n-  \/\/ print mapping size\n-  if (_human_readable) {\n-    _out->print(PROPERFMT \" \", PROPERFMTARGS(size));\n-  } else {\n-    _out->print(\"%11zu\", size);\n-  }\n-\n-  assert(info->from() <= info->to(), \"Invalid VMA\");\n-  _out->fill_to(53);\n-  info->print_OS_specific_details(_out);\n-  _out->fill_to(70);\n+void MappingPrintSession::print_nmt_info_for_region(const void* vma_from, const void* vma_to) const {\n@@ -258,1 +236,6 @@\n-          _out->print(\" \");\n+          if (flag == mtCode) {\n+            _out->print(\"(\");\n+            CodeCache::print_name_for_heap_containing(_out, vma_from);\n+            _out->print(\")\");\n+          }\n+          _out->put(' ');\n@@ -263,21 +246,0 @@\n-\n-  \/\/ print file name, if available\n-  const char* f = info->filename();\n-  if (f != nullptr) {\n-    _out->print_raw(f);\n-  }\n-  _out->cr();\n-}\n-\n-void MemMapPrinter::print_header(outputStream* st) {\n-  st->print(\n-#ifdef _LP64\n-  \/\/   0x0000000000000000 - 0x0000000000000000\n-      \"from                 to                 \"\n-#else\n-  \/\/   0x00000000 - 0x00000000\n-      \"from         to         \"\n-#endif\n-  );\n-  \/\/ Print platform-specific columns\n-  pd_print_header(st);\n@@ -286,2 +248,1 @@\n-void MemMapPrinter::print_all_mappings(outputStream* st, bool human_readable) {\n-  \/\/ First collect all NMT information\n+void MemMapPrinter::print_all_mappings(outputStream* st, MappingPrintOptions options) {\n@@ -289,2 +250,0 @@\n-  nmt_info.fill_from_nmt();\n-\n@@ -292,3 +251,8 @@\n-  if (!MemTracker::enabled()) {\n-    st->cr();\n-    st->print_cr(\" (NMT is disabled, will not annotate mappings).\");\n+  if (!options.only_summary) {\n+    \/\/ Prepare NMT info cache. But only do so if we print individual mappings,\n+    \/\/ otherwise, we won't need it and can save that work.\n+    if (MemTracker::enabled()) {\n+      nmt_info.fill_from_nmt();\n+    } else {\n+      st->print_cr(\"NMT is disabled. VM info not available.\");\n+    }\n@@ -296,11 +260,2 @@\n-  st->cr();\n-\n-  print_legend(st);\n-  st->print_cr(\"(*) - Mapping contains data from multiple regions\");\n-  st->cr();\n-\n-  pd_print_header(st);\n-  MappingPrintClosure closure(st, human_readable, nmt_info);\n-  pd_iterate_all_mappings(closure);\n-  st->print_cr(\"Total: \" UINTX_FORMAT \" mappings with a total vsize of %zu (\" PROPERFMT \")\",\n-               closure.total_count(), closure.total_vsize(), PROPERFMTARGS(closure.total_vsize()));\n+  MappingPrintSession session(st, nmt_info, options);\n+  pd_print_all_mappings(session);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":25,"deletions":70,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -38,11 +38,8 @@\n-class MappingPrintInformation {\n-  const void* const _from;\n-  const void* const _to;\n-public:\n-  MappingPrintInformation(const void* from, const void* to) : _from(from), _to(to) {}\n-  const void* from() const { return _from; }\n-  const void* to() const { return _to; }\n-  \/\/ Will be called for each mapping before VM annotations are printed.\n-  virtual void print_OS_specific_details(outputStream* st) const {}\n-  \/\/ If mapping is backed by a file, the name of that file\n-  virtual const char* filename() const { return nullptr; }\n+struct MappingPrintOptions {\n+  \/\/ Depending the the platform specifics, prints\n+  \/\/ more information at higher costs (e.g. on Linux,\n+  \/\/ scans \/proc\/pid\/smaps instead of \/proc\/pid\/maps)\n+  bool detail_mode;\n+  \/\/ Don't print individual mappings. Only\n+  \/\/ print accumulated summary.\n+  bool only_summary;\n@@ -51,1 +48,1 @@\n-class MappingPrintClosure {\n+class MappingPrintSession {\n@@ -53,3 +50,1 @@\n-  const bool _human_readable;\n-  uintx _total_count;\n-  size_t _total_vsize;\n+  const MappingPrintOptions _options;\n@@ -58,4 +53,5 @@\n-  MappingPrintClosure(outputStream* st, bool human_readable, const CachedNMTInformation& nmt_info);\n-  void do_it(const MappingPrintInformation* info); \/\/ returns false if timeout reached.\n-  uintx total_count() const { return _total_count; }\n-  size_t total_vsize() const { return _total_vsize; }\n+  MappingPrintSession(outputStream* st, const CachedNMTInformation& nmt_info, MappingPrintOptions options);\n+  void print_nmt_info_for_region(const void* from, const void* to) const;\n+  void print_nmt_flag_legend(int indent) const;\n+  const MappingPrintOptions& options() const { return _options; }\n+  outputStream* out() const { return _out; }\n@@ -65,3 +61,1 @@\n-  static void pd_print_header(outputStream* st);\n-  static void print_header(outputStream* st);\n-  static void pd_iterate_all_mappings(MappingPrintClosure& closure);\n+  static void pd_print_all_mappings(const MappingPrintSession& session);\n@@ -69,2 +63,1 @@\n-  static void mark_page_malloced(const void* p, MEMFLAGS f);\n-  static void print_all_mappings(outputStream* st, bool human_readable);\n+  static void print_all_mappings(outputStream* st, MappingPrintOptions options);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":17,"deletions":24,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1183,3 +1183,5 @@\n-    DCmdWithParser(output, heap),\n-  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\") {\n-  _dcmdparser.add_dcmd_option(&_human_readable);\n+  DCmdWithParser(output, heap),\n+  _only_summary(\"summary\", \"Omit printing individual mappings, only print the summary.\", \"BOOLEAN\", false, \"false\"),\n+  _detail_mode(\"details\", \"Print more information at a potentially higher cost.\", \"BOOLEAN\", false, \"false\") {\n+  _dcmdparser.add_dcmd_option(&_only_summary);\n+  _dcmdparser.add_dcmd_option(&_detail_mode);\n@@ -1189,1 +1191,4 @@\n-  MemMapPrinter::print_all_mappings(output(), _human_readable.value());\n+  MappingPrintOptions options;\n+  options.detail_mode = _detail_mode.value();\n+  options.only_summary = _only_summary.value();\n+  MemMapPrinter::print_all_mappings(output(), options);\n@@ -1193,2 +1198,3 @@\n-    DCmdWithParser(output, heap),\n-  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n+  DCmdWithParser(output, heap),\n+  _only_summary(\"summary\", \"Omit printing individual mappings, only print the summary.\", \"BOOLEAN\", false, \"false\"),\n+  _detail_mode(\"details\", \"Print more information at a potentially higher cost.\", \"BOOLEAN\", false, \"false\"),\n@@ -1196,1 +1202,2 @@\n-  _dcmdparser.add_dcmd_option(&_human_readable);\n+  _dcmdparser.add_dcmd_option(&_only_summary);\n+  _dcmdparser.add_dcmd_option(&_detail_mode);\n@@ -1209,1 +1216,4 @@\n-    MemMapPrinter::print_all_mappings(&fs, _human_readable.value());\n+    MappingPrintOptions options;\n+    options.detail_mode = _detail_mode.value();\n+    options.only_summary = _only_summary.value();\n+    MemMapPrinter::print_all_mappings(&fs, options);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -987,1 +987,2 @@\n-  DCmdArgument<bool> _human_readable;\n+  DCmdArgument<bool> _only_summary;\n+  DCmdArgument<bool> _detail_mode;\n@@ -989,1 +990,1 @@\n-  static int num_arguments() { return 1; }\n+  static int num_arguments() { return 2; }\n@@ -995,1 +996,1 @@\n-  static const char* impact() { return \"Low\"; }\n+  static const char* impact() { return \"Medium to High. Printing in detail mode may be costly if the process size is very large.\"; }\n@@ -1005,1 +1006,2 @@\n-  DCmdArgument<bool> _human_readable;\n+  DCmdArgument<bool> _only_summary;\n+  DCmdArgument<bool> _detail_mode;\n@@ -1008,1 +1010,1 @@\n-  static int num_arguments() { return 2; }\n+  static int num_arguments() { return 3; }\n@@ -1014,1 +1016,1 @@\n-  static const char* impact() { return \"Low\"; }\n+  static const char* impact() { return \"Medium to High. Printing in detail mode may be costly if the process size is very large.\"; }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"}]}