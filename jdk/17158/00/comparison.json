{"files":[{"patch":"@@ -30,0 +30,2 @@\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -33,0 +35,4 @@\n+static bool is_lowercase_hex(char c) {\n+  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f');\n+}\n+\n@@ -37,3 +43,0 @@\n-  char offset[20 + 1];\n-  char dev[20 + 1];\n-  char inode[20 + 1];\n@@ -41,0 +44,110 @@\n+  size_t kernelpagesize;\n+  size_t rss;\n+  size_t private_hugetlb;\n+  size_t shared_hugetlb;\n+  size_t anonhugepages;\n+  size_t swap;\n+  bool sh; \/\/ shared\n+  bool nr; \/\/ no reserve\n+  bool hg; \/\/ thp-advised\n+  bool ht; \/\/ uses hugetlb pages\n+  bool nh; \/\/ thp forbidden\n+  bool thp_eligible;\n+\n+  void reset() {\n+    from = to = nullptr;\n+    prot[0] = filename[0] = '\\0';\n+    kernelpagesize = rss = private_hugetlb = anonhugepages = swap = 0;\n+  }\n+\n+  static bool is_header_line(const char* line) {\n+    void* dummy;\n+    \/\/return ::sscanf(line, \"%p\", &dummy) == 1;\n+    \/\/return ::sscanf(line, \"%p-%p\", &dummy, &dummy) == 2;\n+    return is_lowercase_hex(line[0]); \/\/ All other lines start with uppercase letters\n+  }\n+\n+  void scan_header_line(const char* line) {\n+    const int items_read = ::sscanf(line, \"%p-%p %20s %*s %*s %*s %1024s\",\n+        &from, &to, prot, filename);\n+    assert(items_read >= 2, \"Expected header_line\");\n+  }\n+\n+  void scan_additional_lines(const char* line) {\n+#define SCAN(key, var) \\\n+  if (::sscanf(line, key \": %zu kB\", &var) == 1) { \\\n+      var *= K; \\\n+      return; \\\n+  }\n+    SCAN(\"KernelPageSize\", kernelpagesize);\n+    SCAN(\"Rss\", rss);\n+    SCAN(\"AnonHugePages\", anonhugepages);\n+    SCAN(\"Private_Hugetlb\", private_hugetlb);\n+    SCAN(\"Shared_Hugetlb\", shared_hugetlb);\n+    SCAN(\"Swap\", swap);\n+    int i = 0;\n+    if (::sscanf(line, \"THPeligible: %d\", &i) == 1) {\n+      thp_eligible = (i == 1);\n+    }\n+#undef SCAN\n+    \/\/ scan some flags too\n+    if (strncmp(line, \"VmFlags:\", 8) == 0) {\n+#define SCAN(flag) flag = (::strstr(line + 8, \" \" #flag) != nullptr);\n+      SCAN(nr);\n+      SCAN(sh);\n+      SCAN(hg);\n+      SCAN(ht);\n+      SCAN(nh);\n+#undef SCAN\n+      return;\n+    }\n+  }\n+\n+  size_t vsize() const {\n+    return from < to ? pointer_delta(to, from, 1) : 0;\n+  }\n+\n+  void print_mapping(MappingPrintSession& session) {\n+    outputStream* st = session.out();\n+    int pos = 0;\n+#define INDENT_BY(n) pos += n; st->fill_to(pos);\n+    st->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(from), p2i(to));\n+    INDENT_BY(40);\n+\n+    st->print(\"%10zu\", vsize());\n+    INDENT_BY(11);\n+\n+    st->print(\"%10zu\", rss);\n+    INDENT_BY(11);\n+\n+    st->print(\"%10zu\", private_hugetlb);\n+    INDENT_BY(11);\n+\n+    st->print(EXACTFMT \" \", EXACTFMTARGS(kernelpagesize));\n+    INDENT_BY(5);\n+\n+    st->print(\"%s \", prot);\n+    INDENT_BY(5);\n+\n+    bool comma = false;\n+#define PRINTIF(cond, s) \\\n+    if (cond) { \\\n+      st->print(\"%s%s\", (comma ? \",\" : \"\"), s); \\\n+      comma = true; \\\n+    }\n+    PRINTIF(anonhugepages > 0, \"thp\");\n+    PRINTIF(hg, \"thpadv\");\n+    PRINTIF(nh, \"nothp\");\n+    PRINTIF(sh, \"shrd\");\n+    PRINTIF(ht, \"huge\");\n+    PRINTIF(nr, \"nores\");\n+    PRINTIF(thp_eligible, \"thpel\");\n+    PRINTIF(swap > 0, \"swap\");\n+    if (comma) {\n+      st->print(\" \");\n+    }\n+#undef PRINTIF\n+    INDENT_BY(17);\n+    session.print_nmt_info_for_region(from, to);\n+    st->print_raw(filename);\n+#undef INDENT_BY\n@@ -42,5 +155,1 @@\n-  bool scan_proc_maps_line(const char* line) {\n-    prot[0] = offset[0] = dev[0] = inode[0] = filename[0] = '\\0';\n-    const int items_read = ::sscanf(line, \"%p-%p %20s %20s %20s %20s %1024s\",\n-        &from, &to, prot, offset, dev, inode, filename);\n-    return items_read >= 2; \/\/ need at least from and to\n+    st->cr();\n@@ -50,2 +159,8 @@\n-class LinuxMappingPrintInformation : public MappingPrintInformation {\n-  const ProcMapsInfo _info;\n+\/\/ A simple histogram for sizes by pagesize. We keep pagesizes in an array by page size bit\n+\/\/ index. Smallest page size we expect is 4k (2^12), largest pagesize we expect is 16G (powerpc)\n+\/\/ - 2^34. So we store 34-12 = 22 sizes.\n+class PageSizeHistogram {\n+  static constexpr int log_smallest_pagesize = 12; \/\/ 4K\n+  static constexpr int log_largest_pagesize = 34;  \/\/ 16G, ppc\n+  static constexpr int num_pagesizes = log_largest_pagesize - log_smallest_pagesize;\n+  size_t _v[num_pagesizes];\n@@ -53,0 +168,32 @@\n+  PageSizeHistogram() {\n+    memset(_v, 0, sizeof(_v));\n+  }\n+  void add(size_t pagesize, size_t size) {\n+    assert(is_aligned(size, pagesize), \"strange\");\n+    const int n = exact_log2(pagesize) - log_smallest_pagesize;\n+    assert(n >= 0 && n < num_pagesizes, \"strange\");\n+    _v[n] += size;\n+  }\n+  void print_on(MappingPrintSession& session) {\n+    outputStream* st = session.out();\n+    for (int i = 0; i < num_pagesizes; i++) {\n+      if (_v[i] > 0) {\n+        const size_t pagesize = 1 << (log_smallest_pagesize + i);\n+        st->fill_to(16);\n+        st->print(EXACTFMT, EXACTFMTARGS(pagesize));\n+        st->print_cr(\": %zu pages, %zu bytes (\" PROPERFMT \")\", _v[i] \/ pagesize, _v[i], PROPERFMTARGS(_v[i]));\n+      }\n+    }\n+  }\n+};\n+\n+class Summary {\n+  unsigned _num_mappings;\n+  size_t _vsize;\n+  size_t _rss;\n+  size_t _committed;\n+  size_t _shared;\n+  size_t _swapped_out;\n+  size_t _hugetlb;\n+  size_t _thp;\n+  PageSizeHistogram _pagesizes;\n@@ -54,2 +201,4 @@\n-  LinuxMappingPrintInformation(const void* from, const void* to, const ProcMapsInfo* info) :\n-    MappingPrintInformation(from, to), _info(*info) {}\n+public:\n+\n+  Summary() : _num_mappings(0), _vsize(0), _rss(0), _committed(0), _shared(0),\n+              _swapped_out(0), _hugetlb(0), _thp(0) {}\n@@ -57,2 +206,15 @@\n-  void print_OS_specific_details(outputStream* st) const override {\n-    st->print(\"%s %s \", _info.prot, _info.offset);\n+  void add_mapping(ProcMapsInfo& info) {\n+    _num_mappings ++;\n+    _vsize += info.vsize();\n+    _rss += info.rss;\n+    _committed += info.nr ? 0 : info.vsize();\n+    _shared += info.sh ? info.vsize() : 0;\n+    _swapped_out += info.swap;\n+    _hugetlb += info.private_hugetlb + info.shared_hugetlb;\n+    _thp += info.anonhugepages;\n+    if (info.ht) {\n+      _pagesizes.add(info.kernelpagesize,\n+                     info.private_hugetlb + info.shared_hugetlb);\n+    } else {\n+      _pagesizes.add(info.kernelpagesize, info.rss); \/\/ only resident pages\n+    }\n@@ -61,1 +223,13 @@\n-  const char* filename() const override { return _info.filename; }\n+  void print_on(MappingPrintSession& session) {\n+    outputStream* st = session.out();\n+    st->print_cr(\"Number of mappings: %u\", _num_mappings);\n+    st->print_cr(\"             vsize: %zu (\" PROPERFMT \")\", _vsize, PROPERFMTARGS(_vsize));\n+    st->print_cr(\"               rss: %zu (\" PROPERFMT \")\", _rss, PROPERFMTARGS(_rss));\n+    st->print_cr(\"         committed: %zu (\" PROPERFMT \")\", _committed, PROPERFMTARGS(_committed));\n+    st->print_cr(\"            shared: %zu (\" PROPERFMT \")\", _shared, PROPERFMTARGS(_shared));\n+    st->print_cr(\"       swapped out: %zu (\" PROPERFMT \")\", _swapped_out, PROPERFMTARGS(_swapped_out));\n+    st->print_cr(\"         using thp: %zu (\" PROPERFMT \")\", _thp, PROPERFMTARGS(_thp));\n+    st->print_cr(\"           hugetlb: %zu (\" PROPERFMT \")\", _hugetlb, PROPERFMTARGS(_hugetlb));\n+    st->print_cr(\"By page size:\");\n+    _pagesizes.print_on(session);\n+  }\n@@ -64,2 +238,25 @@\n-void MemMapPrinter::pd_print_header(outputStream* st) {\n-  st->print_cr(\"size          prot offset  What\");\n+static void print_legend(MappingPrintSession& session) {\n+  outputStream* st = session.out();\n+  st->print_cr(\"from, to, size: address range and size\");\n+  st->print_cr(\"rss:            resident set size\");\n+  st->print_cr(\"pgsz:           page size\");\n+  st->print_cr(\"notes:          mapping information\");\n+  st->print_cr(\"                    shared: mapping is shared\");\n+  st->print_cr(\"                     nores: mapping uncommitted (no swap space reserved)\");\n+  st->print_cr(\"                      swap: mapping partly or completely swapped out\");\n+  st->print_cr(\"                       thp: mapping uses THP\");\n+  st->print_cr(\"                     thpel: mapping is eligible for THP\");\n+  st->print_cr(\"                    thpadv: mapping is THP-madvised\");\n+  st->print_cr(\"                     nothp: mapping will not THP\");\n+  st->print_cr(\"                      huge: mapping uses hugetlb pages\");\n+  st->print_cr(\"vm info:        VM information (requires NMT)\");\n+  session.print_nmt_flag_legend(16);\n+  st->print_cr(\"file:           file mapped, if mapping is not anonymous\");\n+}\n+\n+static void print_header(MappingPrintSession& session) {\n+  outputStream* st = session.out();\n+  \/\/            .         .         .         .         .         .         .         .         .         .         .\n+  \/\/            01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+  \/\/            0x0000000414000000 - 0x0000000453000000 1234567890 1234567890 1234567890 16g  rw-p thp,thpadv       JAVAHEAP \/shared\/tmp.txt\n+  st->print_cr(\"from                 to                       size        rss    hugetlb pgsz prot notes            vm-info file\");\n@@ -68,2 +265,12 @@\n-void MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {\n-  FILE* f = os::fopen(\"\/proc\/self\/maps\", \"r\");\n+void MemMapPrinter::pd_print_all_mappings(MappingPrintSession& session) {\n+  outputStream* st = session.out();\n+\n+  const bool print_individual_mappings = !session.summary_only();\n+\n+  if (!session.summary_only()) {\n+    print_legend(session);\n+    st->cr();\n+    print_header(session);\n+  }\n+\n+  FILE* f = os::fopen(\"\/proc\/self\/smaps\", \"r\");\n@@ -73,0 +280,3 @@\n+\n+  Summary summary;\n+\n@@ -75,0 +285,3 @@\n+  int lines_scanned = 0;\n+  ProcMapsInfo info;\n+\n@@ -77,4 +290,19 @@\n-    ProcMapsInfo info;\n-    if (info.scan_proc_maps_line(line)) {\n-      LinuxMappingPrintInformation mapinfo(info.from, info.to, &info);\n-      closure.do_it(&mapinfo);\n+    if (info.is_header_line(line)) {\n+      if (lines_scanned > 0) {\n+        summary.add_mapping(info);\n+        if (print_individual_mappings) {\n+          info.print_mapping(session);\n+        }\n+      }\n+      info.reset();\n+      info.scan_header_line(line);\n+    } else {\n+      info.scan_additional_lines(line);\n+    }\n+    lines_scanned ++;\n+  }\n+\n+  if (lines_scanned > 0) {\n+    summary.add_mapping(info);\n+    if (print_individual_mappings) {\n+      info.print_mapping(session);\n@@ -83,0 +311,1 @@\n+\n@@ -84,0 +313,4 @@\n+\n+  \/\/ print summary\n+  st->cr();\n+  summary.print_on(session);\n","filename":"src\/hotspot\/os\/linux\/memMapPrinter_linux.cpp","additions":256,"deletions":23,"binary":false,"changes":279,"status":"modified"},{"patch":"@@ -1893,0 +1893,12 @@\n+void CodeCache::print_name_for_heap_containing(outputStream *out, const void* p) {\n+  FOR_ALL_ALLOCABLE_HEAPS(heap) {\n+    if ((*heap)->low_boundary() <= p && (*heap)->high_boundary() >= p) {\n+      out->print_raw((*heap)->name());\n+      return;\n+    } else if ((*heap)->low_boundary_segmap() <= p && (*heap)->high_boundary_segmap() >= p) {\n+      out->print(\"Segment map for %s\", (*heap)->name());\n+      return;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -339,0 +339,1 @@\n+  static void print_name_for_heap_containing(outputStream *out, const void* p);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,0 +171,3 @@\n+  \/\/ Boundaries of segment map\n+  const char* low_boundary_segmap() const        { return _segmap.low_boundary(); }\n+  const char* high_boundary_segmap() const       { return _segmap.high_boundary(); }\n","filename":"src\/hotspot\/share\/memory\/heap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"code\/codeCache.hpp\"\n@@ -211,2 +212,6 @@\n-static void print_legend(outputStream* st) {\n-#define DO(flag, shortname, text) st->print_cr(\"%10s    %s\", shortname, text);\n+MappingPrintSession::MappingPrintSession(outputStream* st, const CachedNMTInformation& nmt_info, bool summary_only) :\n+    _out(st), _summary_only(summary_only), _nmt_info(nmt_info)\n+{}\n+\n+void MappingPrintSession::print_nmt_flag_legend(int indent) {\n+#define DO(flag, shortname, text) _out->fill_to(indent); _out->print_cr(\"%10s: %s\", shortname, text);\n@@ -217,28 +222,1 @@\n-MappingPrintClosure::MappingPrintClosure(outputStream* st, bool human_readable, const CachedNMTInformation& nmt_info) :\n-    _out(st), _human_readable(human_readable),\n-    _total_count(0), _total_vsize(0), _nmt_info(nmt_info)\n-{}\n-\n-void MappingPrintClosure::do_it(const MappingPrintInformation* info) {\n-\n-  _total_count++;\n-\n-  const void* const vma_from = info->from();\n-  const void* const vma_to = info->to();\n-\n-  \/\/ print from, to\n-  _out->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(vma_from), p2i(vma_to));\n-  const size_t size = pointer_delta(vma_to, vma_from, 1);\n-  _total_vsize += size;\n-\n-  \/\/ print mapping size\n-  if (_human_readable) {\n-    _out->print(PROPERFMT \" \", PROPERFMTARGS(size));\n-  } else {\n-    _out->print(\"%11zu\", size);\n-  }\n-\n-  assert(info->from() <= info->to(), \"Invalid VMA\");\n-  _out->fill_to(53);\n-  info->print_OS_specific_details(_out);\n-  _out->fill_to(70);\n+void MappingPrintSession::print_nmt_info_for_region(const void* vma_from, const void* vma_to) {\n@@ -258,1 +236,6 @@\n-          _out->print(\" \");\n+          if (flag == mtCode) {\n+            _out->print(\"(\");\n+            CodeCache::print_name_for_heap_containing(_out, vma_from);\n+            _out->print(\")\");\n+          }\n+          _out->put(' ');\n@@ -263,21 +246,0 @@\n-\n-  \/\/ print file name, if available\n-  const char* f = info->filename();\n-  if (f != nullptr) {\n-    _out->print_raw(f);\n-  }\n-  _out->cr();\n-}\n-\n-void MemMapPrinter::print_header(outputStream* st) {\n-  st->print(\n-#ifdef _LP64\n-  \/\/   0x0000000000000000 - 0x0000000000000000\n-      \"from                 to                 \"\n-#else\n-  \/\/   0x00000000 - 0x00000000\n-      \"from         to         \"\n-#endif\n-  );\n-  \/\/ Print platform-specific columns\n-  pd_print_header(st);\n@@ -286,2 +248,1 @@\n-void MemMapPrinter::print_all_mappings(outputStream* st, bool human_readable) {\n-  \/\/ First collect all NMT information\n+void MemMapPrinter::print_all_mappings(outputStream* st, bool summary_only) {\n@@ -289,2 +250,0 @@\n-  nmt_info.fill_from_nmt();\n-\n@@ -292,3 +251,7 @@\n-  if (!MemTracker::enabled()) {\n-    st->cr();\n-    st->print_cr(\" (NMT is disabled, will not annotate mappings).\");\n+  if (!summary_only) {\n+    if (MemTracker::enabled()) {\n+      \/\/ Prepare NMT mapping information.\n+      nmt_info.fill_from_nmt();\n+    } else {\n+      st->print_cr(\"NMT is disabled. VM info not available.\");\n+    }\n@@ -296,11 +259,2 @@\n-  st->cr();\n-\n-  print_legend(st);\n-  st->print_cr(\"(*) - Mapping contains data from multiple regions\");\n-  st->cr();\n-\n-  pd_print_header(st);\n-  MappingPrintClosure closure(st, human_readable, nmt_info);\n-  pd_iterate_all_mappings(closure);\n-  st->print_cr(\"Total: \" UINTX_FORMAT \" mappings with a total vsize of %zu (\" PROPERFMT \")\",\n-               closure.total_count(), closure.total_vsize(), PROPERFMTARGS(closure.total_vsize()));\n+  MappingPrintSession session(st, nmt_info, summary_only);\n+  pd_print_all_mappings(session);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":24,"deletions":70,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -38,14 +38,1 @@\n-class MappingPrintInformation {\n-  const void* const _from;\n-  const void* const _to;\n-public:\n-  MappingPrintInformation(const void* from, const void* to) : _from(from), _to(to) {}\n-  const void* from() const { return _from; }\n-  const void* to() const { return _to; }\n-  \/\/ Will be called for each mapping before VM annotations are printed.\n-  virtual void print_OS_specific_details(outputStream* st) const {}\n-  \/\/ If mapping is backed by a file, the name of that file\n-  virtual const char* filename() const { return nullptr; }\n-};\n-\n-class MappingPrintClosure {\n+class MappingPrintSession {\n@@ -53,3 +40,1 @@\n-  const bool _human_readable;\n-  uintx _total_count;\n-  size_t _total_vsize;\n+  const bool _summary_only;\n@@ -58,4 +43,5 @@\n-  MappingPrintClosure(outputStream* st, bool human_readable, const CachedNMTInformation& nmt_info);\n-  void do_it(const MappingPrintInformation* info); \/\/ returns false if timeout reached.\n-  uintx total_count() const { return _total_count; }\n-  size_t total_vsize() const { return _total_vsize; }\n+  MappingPrintSession(outputStream* st, const CachedNMTInformation& nmt_info, bool summary_only);\n+  void print_nmt_info_for_region(const void* from, const void* to);\n+  void print_nmt_flag_legend(int indent);\n+  outputStream* out() { return _out; }\n+  bool summary_only() const { return _summary_only; }\n@@ -65,3 +51,1 @@\n-  static void pd_print_header(outputStream* st);\n-  static void print_header(outputStream* st);\n-  static void pd_iterate_all_mappings(MappingPrintClosure& closure);\n+  static void pd_print_all_mappings(MappingPrintSession& session);\n@@ -69,2 +53,1 @@\n-  static void mark_page_malloced(const void* p, MEMFLAGS f);\n-  static void print_all_mappings(outputStream* st, bool human_readable);\n+  static void print_all_mappings(outputStream* st, bool summary_only);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":9,"deletions":26,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1165,2 +1165,2 @@\n-  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\") {\n-  _dcmdparser.add_dcmd_option(&_human_readable);\n+  _summary(\"summary\", \"Print only summary\", \"BOOLEAN\", false, \"false\") {\n+  _dcmdparser.add_dcmd_option(&_summary);\n@@ -1170,1 +1170,1 @@\n-  MemMapPrinter::print_all_mappings(output(), _human_readable.value());\n+  MemMapPrinter::print_all_mappings(output(), _summary.value());\n@@ -1175,1 +1175,1 @@\n-  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n+  _summary(\"summary\", \"Print only summary\", \"BOOLEAN\", false, \"false\"),\n@@ -1177,1 +1177,1 @@\n-  _dcmdparser.add_dcmd_option(&_human_readable);\n+  _dcmdparser.add_dcmd_option(&_summary);\n@@ -1190,1 +1190,1 @@\n-    MemMapPrinter::print_all_mappings(&fs, _human_readable.value());\n+    MemMapPrinter::print_all_mappings(&fs, _summary.value());\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -984,1 +984,1 @@\n-  DCmdArgument<bool> _human_readable;\n+  DCmdArgument<bool> _summary;\n@@ -1002,1 +1002,1 @@\n-  DCmdArgument<bool> _human_readable;\n+  DCmdArgument<bool> _summary;\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}