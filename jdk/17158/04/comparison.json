{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -28,1 +28,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -30,0 +29,3 @@\n+#include \"procMapsParser.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/align.hpp\"\n@@ -31,0 +33,2 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n@@ -33,14 +37,33 @@\n-struct ProcMapsInfo {\n-  void* from = 0;\n-  void* to = 0;\n-  char prot[20 + 1];\n-  char offset[20 + 1];\n-  char dev[20 + 1];\n-  char inode[20 + 1];\n-  char filename[1024 + 1];\n-\n-  bool scan_proc_maps_line(const char* line) {\n-    prot[0] = offset[0] = dev[0] = inode[0] = filename[0] = '\\0';\n-    const int items_read = ::sscanf(line, \"%p-%p %20s %20s %20s %20s %1024s\",\n-        &from, &to, prot, offset, dev, inode, filename);\n-    return items_read >= 2; \/\/ need at least from and to\n+class ProcSmapsSummary {\n+  unsigned _num_mappings;\n+  size_t _vsize;        \/\/ combined virtual size\n+  size_t _rss;          \/\/ combined resident set size\n+  size_t _committed;    \/\/ combined committed space\n+  size_t _shared;       \/\/ combined shared size\n+  size_t _swapped_out;  \/\/ combined amount of swapped-out memory\n+  size_t _hugetlb;      \/\/ combined amount of memory backed by explicit huge pages\n+  size_t _thp;          \/\/ combined amount of memory backed by THPs\n+public:\n+  ProcSmapsSummary() : _num_mappings(0), _vsize(0), _rss(0), _committed(0), _shared(0),\n+                     _swapped_out(0), _hugetlb(0), _thp(0) {}\n+  void add_mapping(const ProcSmapsInfo& info) {\n+    _num_mappings++;\n+    _vsize += info.vsize();\n+    _rss += info.rss;\n+    _committed += info.nr ? 0 : info.vsize();\n+    _shared += info.sh ? info.vsize() : 0;\n+    _swapped_out += info.swap;\n+    _hugetlb += info.private_hugetlb + info.shared_hugetlb;\n+    _thp += info.anonhugepages;\n+  }\n+\n+  void print_on(const MappingPrintSession& session) const {\n+    outputStream* st = session.out();\n+    st->print_cr(\"Number of mappings: %u\", _num_mappings);\n+    st->print_cr(\"             vsize: %zu (\" PROPERFMT \")\", _vsize, PROPERFMTARGS(_vsize));\n+    st->print_cr(\"               rss: %zu (\" PROPERFMT \")\", _rss, PROPERFMTARGS(_rss));\n+    st->print_cr(\"         committed: %zu (\" PROPERFMT \")\", _committed, PROPERFMTARGS(_committed));\n+    st->print_cr(\"            shared: %zu (\" PROPERFMT \")\", _shared, PROPERFMTARGS(_shared));\n+    st->print_cr(\"       swapped out: %zu (\" PROPERFMT \")\", _swapped_out, PROPERFMTARGS(_swapped_out));\n+    st->print_cr(\"         using thp: %zu (\" PROPERFMT \")\", _thp, PROPERFMTARGS(_thp));\n+    st->print_cr(\"           hugetlb: %zu (\" PROPERFMT \")\", _hugetlb, PROPERFMTARGS(_hugetlb));\n@@ -50,2 +73,2 @@\n-class LinuxMappingPrintInformation : public MappingPrintInformation {\n-  const ProcMapsInfo _info;\n+class ProcSmapsPrinter {\n+  const MappingPrintSession& _session;\n@@ -53,0 +76,3 @@\n+  ProcSmapsPrinter(const MappingPrintSession& session) :\n+    _session(session)\n+  {}\n@@ -54,2 +80,46 @@\n-  LinuxMappingPrintInformation(const void* from, const void* to, const ProcMapsInfo* info) :\n-    MappingPrintInformation(from, to), _info(*info) {}\n+  void print_single_mapping(const ProcSmapsInfo& info) const {\n+    outputStream* st = _session.out();\n+#define INDENT_BY(n)          \\\n+  if (st->fill_to(n) == 0) {  \\\n+    st->print(\" \");           \\\n+  }\n+    st->print(PTR_FORMAT \"-\" PTR_FORMAT, p2i(info.from), p2i(info.to));\n+    INDENT_BY(38);\n+    st->print(\"%12zu\", info.vsize());\n+    INDENT_BY(51);\n+    st->print(\"%s\", info.prot);\n+    INDENT_BY(56);\n+    st->print(\"%12zu\", info.rss);\n+    INDENT_BY(69);\n+    st->print(\"%12zu\", info.private_hugetlb);\n+    INDENT_BY(82);\n+    st->print(EXACTFMT, EXACTFMTARGS(info.kernelpagesize));\n+    {\n+      INDENT_BY(87);\n+      int num_printed = 0;\n+#define PRINTIF(cond, s)                                    \\\n+      if (cond) {                                           \\\n+        st->print(\"%s%s\", (num_printed > 0 ? \",\" : \"\"), s); \\\n+        num_printed++;                                      \\\n+      }\n+      PRINTIF(info.sh, \"shrd\");\n+      PRINTIF(!info.nr, \"com\");\n+      PRINTIF(info.swap > 0, \"swap\");\n+      PRINTIF(info.ht, \"huge\");\n+      PRINTIF(info.anonhugepages > 0, \"thp\");\n+      PRINTIF(info.hg, \"thpad\");\n+      PRINTIF(info.nh, \"nothp\");\n+      if (num_printed == 0) {\n+        st->print(\"-\");\n+      }\n+#undef PRINTIF\n+    }\n+    INDENT_BY(104);\n+    if (!_session.print_nmt_info_for_region(info.from, info.to)) {\n+      st->print(\"-\");\n+    }\n+    INDENT_BY(142);\n+    st->print_raw(info.filename[0] == '\\0' ? \"-\" : info.filename);\n+  #undef INDENT_BY\n+    st->cr();\n+  }\n@@ -57,2 +127,21 @@\n-  void print_OS_specific_details(outputStream* st) const override {\n-    st->print(\"%s %s \", _info.prot, _info.offset);\n+  void print_legend() const {\n+    outputStream* st = _session.out();\n+    st->print_cr(\"from, to, vsize: address range and size\");\n+    st->print_cr(\"prot:            protection\");\n+    st->print_cr(\"rss:             resident set size\");\n+    st->print_cr(\"hugetlb:         size of private hugetlb pages\");\n+    st->print_cr(\"pgsz:            page size\");\n+    st->print_cr(\"notes:           mapping information  (detail mode only)\");\n+    st->print_cr(\"                      shrd: mapping is shared\");\n+    st->print_cr(\"                       com: mapping committed (swap space reserved)\");\n+    st->print_cr(\"                      swap: mapping partly or completely swapped out\");\n+    st->print_cr(\"                       thp: mapping uses THP\");\n+    st->print_cr(\"                     thpad: mapping is THP-madvised\");\n+    st->print_cr(\"                     nothp: mapping is forbidden to use THP\");\n+    st->print_cr(\"                      huge: mapping uses hugetlb pages\");\n+    st->print_cr(\"vm info:         VM information (requires NMT)\");\n+    {\n+      streamIndentor si(st, 16);\n+      _session.print_nmt_flag_legend();\n+    }\n+    st->print_cr(\"file:            file mapped, if mapping is not anonymous\");\n@@ -61,1 +150,8 @@\n-  const char* filename() const override { return _info.filename; }\n+  void print_header() const {\n+    outputStream* st = _session.out();\n+    \/\/            0         1         2         3         4         5         6         7         8         9         0         1         2         3         4         5         6         7\n+    \/\/            012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/            0x0000000414000000-0x0000000453000000 123456789012 rw-p 123456789012 123456789012 16g  thp,thpadv       STACK-340754-Monitor-Deflation-Thread \/shared\/tmp.txt\n+    st->print_cr(\"from               to                        vsize prot          rss      hugetlb pgsz notes            info                                  file\");\n+    st->print_cr(\"========================================================================================================================================================================\");\n+  }\n@@ -64,6 +160,3 @@\n-void MemMapPrinter::pd_print_header(outputStream* st) {\n-  st->print_cr(\"size          prot offset  What\");\n-}\n-\n-void MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {\n-  FILE* f = os::fopen(\"\/proc\/self\/maps\", \"r\");\n+void MemMapPrinter::pd_print_all_mappings(const MappingPrintSession& session) {\n+  constexpr char filename[] = \"\/proc\/self\/smaps\";\n+  FILE* f = os::fopen(filename, \"r\");\n@@ -71,0 +164,1 @@\n+    session.out()->print_cr(\"Cannot open %s\", filename);\n@@ -73,9 +167,15 @@\n-  constexpr size_t linesize = sizeof(ProcMapsInfo);\n-  char line[linesize];\n-  while (fgets(line, sizeof(line), f) == line) {\n-    line[sizeof(line) - 1] = '\\0';\n-    ProcMapsInfo info;\n-    if (info.scan_proc_maps_line(line)) {\n-      LinuxMappingPrintInformation mapinfo(info.from, info.to, &info);\n-      closure.do_it(&mapinfo);\n-    }\n+\n+  ProcSmapsPrinter printer(session);\n+  ProcSmapsSummary summary;\n+\n+  outputStream* const st = session.out();\n+\n+  printer.print_legend();\n+  st->cr();\n+  printer.print_header();\n+\n+  ProcSmapsInfo info;\n+  ProcSmapsParser parser(f);\n+  while (parser.parse_next(info)) {\n+    printer.print_single_mapping(info);\n+    summary.add_mapping(info);\n@@ -83,0 +183,5 @@\n+  st->cr();\n+\n+  summary.print_on(session);\n+  st->cr();\n+\n","filename":"src\/hotspot\/os\/linux\/memMapPrinter_linux.cpp","additions":144,"deletions":39,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"procMapsParser.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+static bool is_lowercase_hex(char c) {\n+  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f');\n+}\n+\n+static size_t max_mapping_line_len() {\n+  return 100 + \/\/ everything but the file name\n+         os::vm_page_size() \/\/ the file name (kernel limits \/proc\/pid\/cmdline to 1 page\n+         ;\n+}\n+\n+ProcSmapsParser::ProcSmapsParser(FILE* f) :\n+  _f(f), _linelen(max_mapping_line_len()), _line(nullptr) {\n+  assert(_f != nullptr, \"Invalid file handle given\");\n+  _line = NEW_C_HEAP_ARRAY(char, max_mapping_line_len(), mtInternal);\n+  _line[0] = '\\0';\n+}\n+\n+ProcSmapsParser::~ProcSmapsParser() {\n+  FREE_C_HEAP_ARRAY(char, _line);\n+}\n+\n+bool ProcSmapsParser::read_line() {\n+  _line[0] = '\\0';\n+  return ::fgets(_line, _linelen, _f) != nullptr;\n+}\n+\n+bool ProcSmapsParser::is_header_line() {\n+  \/\/ e.g. ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]\n+  return is_lowercase_hex(_line[0]); \/\/ All non-header lines in \/proc\/pid\/smaps start with upper-case letters.\n+}\n+\n+void ProcSmapsParser::scan_header_line(ProcSmapsInfo& out) {\n+  const int items_read = ::sscanf(_line, \"%p-%p %20s %*s %*s %*s %1024s\",\n+                                  &out.from, &out.to, out.prot, out.filename);\n+  assert(items_read >= 2, \"Expected header_line\");\n+}\n+\n+void ProcSmapsParser::scan_additional_line(ProcSmapsInfo& out) {\n+#define SCAN(key, var) \\\n+ if (::sscanf(_line, key \": %zu kB\", &var) == 1) { \\\n+     var *= K; \\\n+     return; \\\n+ }\n+  SCAN(\"KernelPageSize\", out.kernelpagesize);\n+  SCAN(\"Rss\", out.rss);\n+  SCAN(\"AnonHugePages\", out.anonhugepages);\n+  SCAN(\"Private_Hugetlb\", out.private_hugetlb);\n+  SCAN(\"Shared_Hugetlb\", out.shared_hugetlb);\n+  SCAN(\"Swap\", out.swap);\n+  int i = 0;\n+#undef SCAN\n+  \/\/ scan some flags too\n+  if (strncmp(_line, \"VmFlags:\", 8) == 0) {\n+#define SCAN(flag) { out.flag = (::strstr(_line + 8, \" \" #flag) != nullptr); }\n+    SCAN(rd);\n+    SCAN(wr);\n+    SCAN(ex);\n+    SCAN(nr);\n+    SCAN(sh);\n+    SCAN(hg);\n+    SCAN(ht);\n+    SCAN(nh);\n+#undef SCAN\n+    return;\n+  }\n+}\n+\n+\/\/ Starts or continues parsing. Returns true on success,\n+\/\/ false on EOF or on error.\n+bool ProcSmapsParser::parse_next(ProcSmapsInfo& out) {\n+\n+  \/\/ Information about a single mapping reaches across several lines.\n+  out.reset();\n+\n+  \/\/ Read header line, unless we already read it\n+  if (_line[0] == '\\0') {\n+    if (!read_line()) {\n+      return false;\n+    }\n+  }\n+  assert(is_header_line(), \"Not a header line: \\\"%s\\\".\", _line);\n+  scan_header_line(out);\n+\n+  \/\/ Now read until we encounter the next header line or EOF or an error.\n+  bool ok = false, stop = false;\n+  do {\n+    ok = read_line();\n+    stop = !ok || is_header_line();\n+    if (!stop) {\n+      scan_additional_line(out);\n+    }\n+  } while (!stop);\n+\n+  return ok;\n+}\n","filename":"src\/hotspot\/os\/linux\/procMapsParser.cpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_PROCMAPSPARSER_HPP\n+#define OS_LINUX_PROCMAPSPARSER_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ This header exposes two simple parsers for \/proc\/pid\/maps and\n+\/\/ \/proc\/pid\/smaps.\n+\/\/\n+\/\/ Usage:\n+\/\/\n+\/\/ FILE* f = fopen(...)\n+\/\/ ProcSMapsParser parser(f);\n+\/\/ ProcSMapsInfo info;\n+\/\/ while (parser.parse_next(info)) { ... }\n+\n+struct ProcSmapsInfo {\n+  void* from;\n+  void* to;\n+  char prot[20 + 1];\n+  char filename[1024 + 1];\n+  size_t kernelpagesize;\n+  size_t rss;\n+  size_t private_hugetlb;\n+  size_t shared_hugetlb;\n+  size_t anonhugepages;\n+  size_t swap;\n+  bool rd, wr, ex;\n+  bool sh; \/\/ shared\n+  bool nr; \/\/ no reserve\n+  bool hg; \/\/ thp-advised\n+  bool ht; \/\/ uses hugetlb pages\n+  bool nh; \/\/ thp forbidden\n+  inline size_t vsize() const;\n+  inline void reset();\n+};\n+\n+class ProcSmapsParser {\n+  FILE* _f;\n+  const size_t _linelen;\n+  char* _line;\n+\n+  bool read_line(); \/\/ sets had_error in case of error\n+  bool is_header_line();\n+  void scan_header_line(ProcSmapsInfo& out);\n+  void scan_additional_line(ProcSmapsInfo& out);\n+\n+public:\n+\n+  ProcSmapsParser(FILE* f);\n+  ~ProcSmapsParser();\n+\n+  \/\/ Starts or continues parsing. Returns true on success,\n+  \/\/ false on EOF or on error.\n+  bool parse_next(ProcSmapsInfo& out);\n+};\n+\n+#endif \/\/ OS_LINUX_PROCMAPSPARSER_HPP\n","filename":"src\/hotspot\/os\/linux\/procMapsParser.hpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_PROCMAPSPARSER_INLINE_HPP\n+#define OS_LINUX_PROCMAPSPARSER_INLINE_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"procMapsParser.hpp\"\n+\n+size_t ProcSmapsInfo::vsize() const {\n+  return from < to ? pointer_delta(to, from, 1) : 0;\n+}\n+\n+void ProcSmapsInfo::reset() {\n+  from = to = nullptr;\n+  prot[0] = filename[0] = '\\0';\n+  kernelpagesize = rss = private_hugetlb = anonhugepages = swap = 0;\n+}\n+\n+#endif \/\/ OS_LINUX_PROCMAPSPARSER_INLINE_HPP\n","filename":"src\/hotspot\/os\/linux\/procMapsParser.inline.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"logging\/logAsyncWriter.hpp\"\n@@ -32,0 +31,2 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -34,0 +35,4 @@\n+#include \"nmt\/memFlagBitmap.hpp\"\n+#include \"nmt\/memMapPrinter.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n@@ -39,4 +44,0 @@\n-#include \"nmt\/memFlagBitmap.hpp\"\n-#include \"nmt\/memMapPrinter.hpp\"\n-#include \"nmt\/memTracker.hpp\"\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n@@ -44,1 +45,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -162,7 +162,0 @@\n-\n-  void print_on(outputStream* st) const {\n-    for (size_t i = 0; i < _count; i ++) {\n-      st->print_cr(PTR_FORMAT \"-\" PTR_FORMAT \" %s\", p2i(_ranges[i].from), p2i(_ranges[i].to),\n-          NMTUtil::flag_to_enum_name(_flags[i]));\n-    }\n-  }\n@@ -200,1 +193,10 @@\n-  st->print(\"(\" UINTX_FORMAT \" \\\"%s\\\")\", (uintx)thread_id, name);\n+  \/\/ avoid commas and spaces in output to ease post-processing via awk\n+  char tmp[64];\n+  stringStream ss(tmp, sizeof(tmp));\n+  ss.print(\":\" UINTX_FORMAT \"-%s\", (uintx)thread_id, name);\n+  for (int i = 0; tmp[i] != '\\0'; i++) {\n+    if (!isalnum(tmp[i])) {\n+      tmp[i] = '-';\n+    }\n+  }\n+  st->print_raw(tmp);\n@@ -230,2 +232,6 @@\n-static void print_legend(outputStream* st) {\n-#define DO(flag, shortname, text) st->print_cr(\"%10s    %s\", shortname, text);\n+MappingPrintSession::MappingPrintSession(outputStream* st, const CachedNMTInformation& nmt_info) :\n+    _out(st), _nmt_info(nmt_info)\n+{}\n+\n+void MappingPrintSession::print_nmt_flag_legend() const {\n+#define DO(flag, shortname, text) _out->indent(); _out->print_cr(\"%10s: %s\", shortname, text);\n@@ -236,29 +242,2 @@\n-MappingPrintClosure::MappingPrintClosure(outputStream* st, bool human_readable, const CachedNMTInformation& nmt_info) :\n-    _out(st), _human_readable(human_readable),\n-    _total_count(0), _total_vsize(0), _nmt_info(nmt_info)\n-{}\n-\n-void MappingPrintClosure::do_it(const MappingPrintInformation* info) {\n-\n-  _total_count++;\n-\n-  const void* const vma_from = info->from();\n-  const void* const vma_to = info->to();\n-\n-  \/\/ print from, to\n-  _out->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(vma_from), p2i(vma_to));\n-  const size_t size = pointer_delta(vma_to, vma_from, 1);\n-  _total_vsize += size;\n-\n-  \/\/ print mapping size\n-  if (_human_readable) {\n-    _out->print(PROPERFMT \" \", PROPERFMTARGS(size));\n-  } else {\n-    _out->print(\"%11zu\", size);\n-  }\n-\n-  assert(info->from() <= info->to(), \"Invalid VMA\");\n-  _out->fill_to(53);\n-  info->print_OS_specific_details(_out);\n-  _out->fill_to(70);\n-\n+bool MappingPrintSession::print_nmt_info_for_region(const void* vma_from, const void* vma_to) const {\n+  int num_printed = 0;\n@@ -273,0 +252,3 @@\n+          if (num_printed > 0) {\n+            _out->put(',');\n+          }\n@@ -277,1 +259,1 @@\n-          _out->print(\" \");\n+          num_printed ++;\n@@ -282,21 +264,1 @@\n-\n-  \/\/ print file name, if available\n-  const char* f = info->filename();\n-  if (f != nullptr) {\n-    _out->print_raw(f);\n-  }\n-  _out->cr();\n-}\n-\n-void MemMapPrinter::print_header(outputStream* st) {\n-  st->print(\n-#ifdef _LP64\n-  \/\/   0x0000000000000000 - 0x0000000000000000\n-      \"from                 to                 \"\n-#else\n-  \/\/   0x00000000 - 0x00000000\n-      \"from         to         \"\n-#endif\n-  );\n-  \/\/ Print platform-specific columns\n-  pd_print_header(st);\n+  return num_printed > 0;\n@@ -305,2 +267,1 @@\n-void MemMapPrinter::print_all_mappings(outputStream* st, bool human_readable) {\n-  \/\/ First collect all NMT information\n+void MemMapPrinter::print_all_mappings(outputStream* st) {\n@@ -308,2 +269,0 @@\n-  nmt_info.fill_from_nmt();\n-  DEBUG_ONLY(nmt_info.print_on(st);)\n@@ -311,3 +270,6 @@\n-  if (!MemTracker::enabled()) {\n-    st->cr();\n-    st->print_cr(\" (NMT is disabled, will not annotate mappings).\");\n+  \/\/ Prepare NMT info cache. But only do so if we print individual mappings,\n+  \/\/ otherwise, we won't need it and can save that work.\n+  if (MemTracker::enabled()) {\n+    nmt_info.fill_from_nmt();\n+  } else {\n+    st->print_cr(\"NMT is disabled. VM info not available.\");\n@@ -315,11 +277,2 @@\n-  st->cr();\n-\n-  print_legend(st);\n-  st->print_cr(\"(*) - Mapping contains data from multiple regions\");\n-  st->cr();\n-\n-  pd_print_header(st);\n-  MappingPrintClosure closure(st, human_readable, nmt_info);\n-  pd_iterate_all_mappings(closure);\n-  st->print_cr(\"Total: \" UINTX_FORMAT \" mappings with a total vsize of %zu (\" PROPERFMT \")\",\n-               closure.total_count(), closure.total_vsize(), PROPERFMTARGS(closure.total_vsize()));\n+  MappingPrintSession session(st, nmt_info);\n+  pd_print_all_mappings(session);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":38,"deletions":85,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -38,14 +38,1 @@\n-class MappingPrintInformation {\n-  const void* const _from;\n-  const void* const _to;\n-public:\n-  MappingPrintInformation(const void* from, const void* to) : _from(from), _to(to) {}\n-  const void* from() const { return _from; }\n-  const void* to() const { return _to; }\n-  \/\/ Will be called for each mapping before VM annotations are printed.\n-  virtual void print_OS_specific_details(outputStream* st) const {}\n-  \/\/ If mapping is backed by a file, the name of that file\n-  virtual const char* filename() const { return nullptr; }\n-};\n-\n-class MappingPrintClosure {\n+class MappingPrintSession {\n@@ -53,3 +40,0 @@\n-  const bool _human_readable;\n-  uintx _total_count;\n-  size_t _total_vsize;\n@@ -58,4 +42,4 @@\n-  MappingPrintClosure(outputStream* st, bool human_readable, const CachedNMTInformation& nmt_info);\n-  void do_it(const MappingPrintInformation* info); \/\/ returns false if timeout reached.\n-  uintx total_count() const { return _total_count; }\n-  size_t total_vsize() const { return _total_vsize; }\n+  MappingPrintSession(outputStream* st, const CachedNMTInformation& nmt_info);\n+  bool print_nmt_info_for_region(const void* from, const void* to) const;\n+  void print_nmt_flag_legend() const;\n+  outputStream* out() const { return _out; }\n@@ -65,3 +49,1 @@\n-  static void pd_print_header(outputStream* st);\n-  static void print_header(outputStream* st);\n-  static void pd_iterate_all_mappings(MappingPrintClosure& closure);\n+  static void pd_print_all_mappings(const MappingPrintSession& session);\n@@ -69,2 +51,1 @@\n-  static void mark_page_malloced(const void* p, MEMFLAGS f);\n-  static void print_all_mappings(outputStream* st, bool human_readable);\n+  static void print_all_mappings(outputStream* st);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":7,"deletions":26,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -398,1 +398,7 @@\n-    bufferedStream st;\n+    \/\/ jcmd output can get lengthy. As long as we miss jcmd continuous streaming output\n+    \/\/ and instead just send the output in bulk, make sure large command output does not\n+    \/\/ cause asserts. We still retain a max cap, but dimensioned in a way that makes it\n+    \/\/ highly unlikely we should ever hit it under normal conditions.\n+    constexpr size_t initial_size = 1 * M;\n+    constexpr size_t max_size = 3 * G;\n+    bufferedStream st(initial_size, max_size);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1183,5 +1183,1 @@\n-SystemMapDCmd::SystemMapDCmd(outputStream* output, bool heap) :\n-    DCmdWithParser(output, heap),\n-  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\") {\n-  _dcmdparser.add_dcmd_option(&_human_readable);\n-}\n+SystemMapDCmd::SystemMapDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n@@ -1190,1 +1186,1 @@\n-  MemMapPrinter::print_all_mappings(output(), _human_readable.value());\n+  MemMapPrinter::print_all_mappings(output());\n@@ -1196,2 +1192,1 @@\n-    DCmdWithParser(output, heap),\n-  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n+  DCmdWithParser(output, heap),\n@@ -1199,1 +1194,0 @@\n-  _dcmdparser.add_dcmd_option(&_human_readable);\n@@ -1217,1 +1211,1 @@\n-    MemMapPrinter::print_all_mappings(&fs, _human_readable.value());\n+    MemMapPrinter::print_all_mappings(&fs);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -986,2 +986,1 @@\n-class SystemMapDCmd : public DCmdWithParser {\n-  DCmdArgument<bool> _human_readable;\n+class SystemMapDCmd : public DCmd {\n@@ -989,1 +988,0 @@\n-  static int num_arguments() { return 1; }\n@@ -995,1 +993,1 @@\n-  static const char* impact() { return \"Low\"; }\n+  static const char* impact() { return \"Medium; can be high for very large java heaps.\"; }\n@@ -1005,1 +1003,0 @@\n-  DCmdArgument<bool> _human_readable;\n@@ -1008,1 +1005,1 @@\n-  static int num_arguments() { return 2; }\n+  static int num_arguments() { return 1; }\n@@ -1014,1 +1011,1 @@\n-  static const char* impact() { return \"Low\"; }\n+  static const char* impact() { return \"Medium; can be high for very large java heaps.\"; }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -194,2 +194,2 @@\n-void outputStream::fill_to(int col) {\n-  int need_fill = col - position();\n+int outputStream::fill_to(int col) {\n+  const int need_fill = MAX2(col - position(), 0);\n@@ -197,0 +197,1 @@\n+  return need_fill;\n@@ -1040,1 +1041,1 @@\n-      assert(false, \"Exceeded max buffer size for this string.\");\n+      assert(false, \"Exceeded max buffer size for this string (\\\"%.200s...\\\").\", buffer);\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-   void fill_to(int col);\n+   int fill_to(int col);\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -31,0 +31,1 @@\n+import java.lang.StringBuilder;\n@@ -46,1 +47,1 @@\n-public class SystemDumpMapTest {\n+public class SystemDumpMapTest extends SystemMapTestBase {\n@@ -67,1 +68,3 @@\n-            patterns.add(Pattern.compile(regexBase + \".*jvm.*\"));\n+            for (String s: shouldMatchUnconditionally) {\n+                patterns.add(Pattern.compile(s));\n+            }\n@@ -69,4 +72,3 @@\n-                patterns.add(Pattern.compile(regexBase + \".*JAVAHEAP.*\"));\n-                patterns.add(Pattern.compile(regexBase + \".*META.*\"));\n-                patterns.add(Pattern.compile(regexBase + \".*CODE.*\"));\n-                patterns.add(Pattern.compile(regexBase + \".*STACK.*main.*\"));\n+                for (String s: shouldMatchIfNMTIsEnabled) {\n+                    patterns.add(Pattern.compile(s));\n+                }\n@@ -74,0 +76,1 @@\n+\n@@ -77,0 +80,1 @@\n+                    System.out.println(\"   \" + line);\n@@ -79,0 +83,1 @@\n+                            System.out.println(\">>> matches \" + pat);\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemDumpMapTest.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -48,1 +48,1 @@\n-public class SystemMapTest {\n+public class SystemMapTest extends SystemMapTestBase {\n@@ -51,1 +51,0 @@\n-        output.reportDiagnosticSummary();\n@@ -53,3 +52,3 @@\n-\n-        String regexBase = \".*0x\\\\p{XDigit}+ - 0x\\\\p{XDigit}+ +\\\\d+\";\n-        output.shouldMatch(regexBase + \".*jvm.*\");\n+        for (String s: shouldMatchUnconditionally) {\n+            output.shouldMatch(s);\n+        }\n@@ -57,4 +56,3 @@\n-            output.shouldMatch(regexBase + \".*JAVAHEAP.*\");\n-            output.shouldMatch(regexBase + \".*META.*\");\n-            output.shouldMatch(regexBase + \".*CODE.*\");\n-            output.shouldMatch(regexBase + \".*STACK.*main.*\");\n+            for (String s: shouldMatchIfNMTIsEnabled) {\n+                output.shouldMatch(s);\n+            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTest.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class SystemMapTestBase {\n+\n+    \/\/ e.g.\n+    \/\/ 0x00000007ff800000-0x00000007ff91a000      1155072 rw-p      1155072            0 4K   com              JAVAHEAP                              \/shared\/projects\/openjdk\/jdk-jdk\/output-fastdebug\/images\/jdk\/lib\/server\/classes.jsa\n+    private static final String range = \"0x\\\\p{XDigit}+-0x\\\\p{XDigit}+\";\n+    private static final String space = \" +\";\n+    private static final String someSize = \"\\\\d+\";\n+    private static final String pagesize = \"(4K|8K|16K|64K|2M|16M|64M)\";\n+    private static final String prot = \"[rwsxp-]+\";\n+\n+    private static final String regexBase = range + space +\n+            someSize + space +\n+            prot + space +\n+            someSize + space +\n+            someSize + space +\n+            pagesize + space;\n+\n+    private static final String regexBase_committed = regexBase + \"com.*\";\n+    private static final String regexBase_shared_and_committed = regexBase + \"shrd,com.*\";\n+\n+    protected static final String shouldMatchUnconditionally[] = {\n+        \/\/ java launcher\n+        regexBase_committed + \"\/bin\/java\",\n+        \/\/ libjvm\n+        regexBase_committed + \"\/lib\/.*\/libjvm.so\",\n+        \/\/ primordial thread stack\n+        regexBase_committed + \"\\\\[stack\\\\]\",\n+        \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n+        regexBase_shared_and_committed + \"hsperfdata_.*\"\n+    };\n+\n+    protected static final String shouldMatchIfNMTIsEnabled[] = {\n+        regexBase_committed + \"JAVAHEAP.*\",\n+        \/\/ metaspace\n+        regexBase_committed + \"META.*\",\n+        \/\/ parts of metaspace should be uncommitted\n+        regexBase + \"-\" + space + \"META.*\",\n+        \/\/ code cache\n+        regexBase_committed + \"CODE.*\",\n+        \/\/ Main thread stack\n+        regexBase_committed + \"STACK.*main.*\"\n+    };\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTestBase.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"}]}