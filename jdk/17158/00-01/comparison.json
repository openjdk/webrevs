{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -28,0 +28,1 @@\n+#include \"procMapsParser.inline.hpp\"\n@@ -35,46 +36,8 @@\n-static bool is_lowercase_hex(char c) {\n-  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f');\n-}\n-\n-struct ProcMapsInfo {\n-  void* from = 0;\n-  void* to = 0;\n-  char prot[20 + 1];\n-  char filename[1024 + 1];\n-  size_t kernelpagesize;\n-  size_t rss;\n-  size_t private_hugetlb;\n-  size_t shared_hugetlb;\n-  size_t anonhugepages;\n-  size_t swap;\n-  bool sh; \/\/ shared\n-  bool nr; \/\/ no reserve\n-  bool hg; \/\/ thp-advised\n-  bool ht; \/\/ uses hugetlb pages\n-  bool nh; \/\/ thp forbidden\n-  bool thp_eligible;\n-\n-  void reset() {\n-    from = to = nullptr;\n-    prot[0] = filename[0] = '\\0';\n-    kernelpagesize = rss = private_hugetlb = anonhugepages = swap = 0;\n-  }\n-\n-  static bool is_header_line(const char* line) {\n-    void* dummy;\n-    \/\/return ::sscanf(line, \"%p\", &dummy) == 1;\n-    \/\/return ::sscanf(line, \"%p-%p\", &dummy, &dummy) == 2;\n-    return is_lowercase_hex(line[0]); \/\/ All other lines start with uppercase letters\n-  }\n-\n-  void scan_header_line(const char* line) {\n-    const int items_read = ::sscanf(line, \"%p-%p %20s %*s %*s %*s %1024s\",\n-        &from, &to, prot, filename);\n-    assert(items_read >= 2, \"Expected header_line\");\n-  }\n-\n-  void scan_additional_lines(const char* line) {\n-#define SCAN(key, var) \\\n-  if (::sscanf(line, key \": %zu kB\", &var) == 1) { \\\n-      var *= K; \\\n-      return; \\\n+class ProcMapsSummary {\n+  unsigned _num_mappings;\n+  size_t _vsize;\n+public:\n+  ProcMapsSummary() : _num_mappings(0), _vsize(0) {}\n+  void add_mapping(ProcMapsInfo& info) {\n+    _num_mappings ++;\n+    _vsize += info.vsize();\n@@ -82,22 +45,4 @@\n-    SCAN(\"KernelPageSize\", kernelpagesize);\n-    SCAN(\"Rss\", rss);\n-    SCAN(\"AnonHugePages\", anonhugepages);\n-    SCAN(\"Private_Hugetlb\", private_hugetlb);\n-    SCAN(\"Shared_Hugetlb\", shared_hugetlb);\n-    SCAN(\"Swap\", swap);\n-    int i = 0;\n-    if (::sscanf(line, \"THPeligible: %d\", &i) == 1) {\n-      thp_eligible = (i == 1);\n-    }\n-#undef SCAN\n-    \/\/ scan some flags too\n-    if (strncmp(line, \"VmFlags:\", 8) == 0) {\n-#define SCAN(flag) flag = (::strstr(line + 8, \" \" #flag) != nullptr);\n-      SCAN(nr);\n-      SCAN(sh);\n-      SCAN(hg);\n-      SCAN(ht);\n-      SCAN(nh);\n-#undef SCAN\n-      return;\n-    }\n+  void print_on(const MappingPrintSession& session) const {\n+    outputStream* st = session.out();\n+    st->print_cr(\"Number of mappings: %u\", _num_mappings);\n+    st->print_cr(\"             vsize: %zu (\" PROPERFMT \")\", _vsize, PROPERFMTARGS(_vsize));\n@@ -105,0 +50,1 @@\n+};\n@@ -106,3 +52,6 @@\n-  size_t vsize() const {\n-    return from < to ? pointer_delta(to, from, 1) : 0;\n-  }\n+class ProcMapsPrinter {\n+  const MappingPrintSession& _session;\n+public:\n+  ProcMapsPrinter(const MappingPrintSession& session) :\n+    _session(session)\n+  {}\n@@ -110,2 +59,3 @@\n-  void print_mapping(MappingPrintSession& session) {\n-    outputStream* st = session.out();\n+  void print_single_mapping(const ProcMapsInfo& info) const {\n+    assert(!_session.options().detail_mode, \"Should be called only for simple mode\");\n+    outputStream* st = _session.out();\n@@ -114,1 +64,1 @@\n-    st->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(from), p2i(to));\n+    st->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(info.from), p2i(info.to));\n@@ -116,2 +66,1 @@\n-\n-    st->print(\"%10zu\", vsize());\n+    st->print(\"%10zu\", info.vsize());\n@@ -119,11 +68,1 @@\n-\n-    st->print(\"%10zu\", rss);\n-    INDENT_BY(11);\n-\n-    st->print(\"%10zu\", private_hugetlb);\n-    INDENT_BY(11);\n-\n-    st->print(EXACTFMT \" \", EXACTFMTARGS(kernelpagesize));\n-    INDENT_BY(5);\n-\n-    st->print(\"%s \", prot);\n+    st->print(\"%s \", info.prot);\n@@ -131,0 +70,6 @@\n+    _session.print_nmt_info_for_region(info.from, info.to);\n+    INDENT_BY(10);\n+    st->print_raw(info.filename);\n+#undef INDENT\n+    st->cr();\n+  }\n@@ -132,22 +77,8 @@\n-    bool comma = false;\n-#define PRINTIF(cond, s) \\\n-    if (cond) { \\\n-      st->print(\"%s%s\", (comma ? \",\" : \"\"), s); \\\n-      comma = true; \\\n-    }\n-    PRINTIF(anonhugepages > 0, \"thp\");\n-    PRINTIF(hg, \"thpadv\");\n-    PRINTIF(nh, \"nothp\");\n-    PRINTIF(sh, \"shrd\");\n-    PRINTIF(ht, \"huge\");\n-    PRINTIF(nr, \"nores\");\n-    PRINTIF(thp_eligible, \"thpel\");\n-    PRINTIF(swap > 0, \"swap\");\n-    if (comma) {\n-      st->print(\" \");\n-    }\n-#undef PRINTIF\n-    INDENT_BY(17);\n-    session.print_nmt_info_for_region(from, to);\n-    st->print_raw(filename);\n-#undef INDENT_BY\n+  void print_legend() const {\n+    outputStream* st = _session.out();\n+    st->print_cr(\"from, to, vsize: address range and size\");\n+    st->print_cr(\"prot:            protection\");\n+    st->print_cr(\"vm info:         VM information (requires NMT)\");\n+    _session.print_nmt_flag_legend(16);\n+    st->print_cr(\"file:            file mapped, if mapping is not anonymous\");\n+  }\n@@ -155,1 +86,6 @@\n-    st->cr();\n+  void print_header() const {\n+    outputStream* st = _session.out();\n+    \/\/            .         .         .         .         .         .         .         .         .         .         .\n+    \/\/            01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/            0x0000000414000000 - 0x0000000453000000 1234567890 rw-p JAVAHEAP  \/shared\/tmp.txt\n+    st->print_cr(\"from                 to                      vsize prot vm-info   file\");\n@@ -168,3 +104,1 @@\n-  PageSizeHistogram() {\n-    memset(_v, 0, sizeof(_v));\n-  }\n+  PageSizeHistogram() { memset(_v, 0, sizeof(_v)); }\n@@ -177,2 +111,1 @@\n-  void print_on(MappingPrintSession& session) {\n-    outputStream* st = session.out();\n+  void print_on(outputStream* st) const {\n@@ -190,1 +123,1 @@\n-class Summary {\n+class ProcSmapsSummary {\n@@ -200,1 +133,0 @@\n-\n@@ -202,5 +134,3 @@\n-\n-  Summary() : _num_mappings(0), _vsize(0), _rss(0), _committed(0), _shared(0),\n-              _swapped_out(0), _hugetlb(0), _thp(0) {}\n-\n-  void add_mapping(ProcMapsInfo& info) {\n+  ProcSmapsSummary() : _num_mappings(0), _vsize(0), _rss(0), _committed(0), _shared(0),\n+                     _swapped_out(0), _hugetlb(0), _thp(0) {}\n+  void add_mapping(ProcSmapsInfo& info) {\n@@ -223,1 +153,1 @@\n-  void print_on(MappingPrintSession& session) {\n+  void print_on(const MappingPrintSession& session) const {\n@@ -234,1 +164,1 @@\n-    _pagesizes.print_on(session);\n+    _pagesizes.print_on(st);\n@@ -238,18 +168,6 @@\n-static void print_legend(MappingPrintSession& session) {\n-  outputStream* st = session.out();\n-  st->print_cr(\"from, to, size: address range and size\");\n-  st->print_cr(\"rss:            resident set size\");\n-  st->print_cr(\"pgsz:           page size\");\n-  st->print_cr(\"notes:          mapping information\");\n-  st->print_cr(\"                    shared: mapping is shared\");\n-  st->print_cr(\"                     nores: mapping uncommitted (no swap space reserved)\");\n-  st->print_cr(\"                      swap: mapping partly or completely swapped out\");\n-  st->print_cr(\"                       thp: mapping uses THP\");\n-  st->print_cr(\"                     thpel: mapping is eligible for THP\");\n-  st->print_cr(\"                    thpadv: mapping is THP-madvised\");\n-  st->print_cr(\"                     nothp: mapping will not THP\");\n-  st->print_cr(\"                      huge: mapping uses hugetlb pages\");\n-  st->print_cr(\"vm info:        VM information (requires NMT)\");\n-  session.print_nmt_flag_legend(16);\n-  st->print_cr(\"file:           file mapped, if mapping is not anonymous\");\n-}\n+class ProcSmapsPrinter {\n+  const MappingPrintSession& _session;\n+public:\n+  ProcSmapsPrinter(const MappingPrintSession& session) :\n+    _session(session)\n+  {}\n@@ -257,7 +175,43 @@\n-static void print_header(MappingPrintSession& session) {\n-  outputStream* st = session.out();\n-  \/\/            .         .         .         .         .         .         .         .         .         .         .\n-  \/\/            01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n-  \/\/            0x0000000414000000 - 0x0000000453000000 1234567890 1234567890 1234567890 16g  rw-p thp,thpadv       JAVAHEAP \/shared\/tmp.txt\n-  st->print_cr(\"from                 to                       size        rss    hugetlb pgsz prot notes            vm-info file\");\n-}\n+  void print_single_mapping(const ProcSmapsInfo& info) const {\n+    assert(_session.options().detail_mode, \"Should be called only for detail mode\");\n+    outputStream* st = _session.out();\n+    int pos = 0;\n+  #define INDENT_BY(n) pos += n; st->fill_to(pos);\n+    st->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(info.from), p2i(info.to));\n+    INDENT_BY(40);\n+    st->print(\"%10zu\", info.vsize());\n+    INDENT_BY(11);\n+    st->print(\"%s \", info.prot);\n+    INDENT_BY(5);\n+    st->print(\"%10zu\", info.rss);\n+    INDENT_BY(11);\n+    st->print(\"%10zu\", info.private_hugetlb);\n+    INDENT_BY(11);\n+    st->print(EXACTFMT \" \", EXACTFMTARGS(info.kernelpagesize));\n+    INDENT_BY(5);\n+\n+    bool comma = false;\n+  #define PRINTIF(cond, s) \\\n+    if (cond) { \\\n+      st->print(\"%s%s\", (comma ? \",\" : \"\"), s); \\\n+      comma = true; \\\n+    }\n+    PRINTIF(info.anonhugepages > 0, \"thp\");\n+    PRINTIF(info.hg, \"thpadv\");\n+    PRINTIF(info.nh, \"nothp\");\n+    PRINTIF(info.sh, \"shrd\");\n+    PRINTIF(info.ht, \"huge\");\n+    PRINTIF(info.nr, \"nores\");\n+    PRINTIF(info.thp_eligible, \"thpel\");\n+    PRINTIF(info.swap > 0, \"swap\");\n+    if (comma) {\n+      st->print(\" \");\n+    }\n+  #undef PRINTIF\n+    INDENT_BY(17);\n+    _session.print_nmt_info_for_region(info.from, info.to);\n+    INDENT_BY(10);\n+    st->print_raw(info.filename);\n+  #undef INDENT_BY\n+    st->cr();\n+  }\n@@ -265,2 +219,34 @@\n-void MemMapPrinter::pd_print_all_mappings(MappingPrintSession& session) {\n-  outputStream* st = session.out();\n+  void print_legend() const {\n+    outputStream* st = _session.out();\n+    st->print_cr(\"from, to, vsize: address range and size\");\n+    st->print_cr(\"prot:            protection\");\n+    st->print_cr(\"rss:             resident set size\");\n+    st->print_cr(\"hugetlb:         size of private hugetlb pages\");\n+    st->print_cr(\"pgsz:            page size\");\n+    st->print_cr(\"notes:           mapping information  (detail mode only)\");\n+    st->print_cr(\"                    shared: mapping is shared\");\n+    st->print_cr(\"                     nores: mapping uncommitted (no swap space reserved)\");\n+    st->print_cr(\"                      swap: mapping partly or completely swapped out\");\n+    st->print_cr(\"                       thp: mapping uses THP\");\n+    st->print_cr(\"                     thpel: mapping is eligible for THP\");\n+    st->print_cr(\"                    thpadv: mapping is THP-madvised\");\n+    st->print_cr(\"                     nothp: mapping will not THP\");\n+    st->print_cr(\"                      huge: mapping uses hugetlb pages\");\n+    st->print_cr(\"vm info:         VM information (requires NMT)\");\n+    _session.print_nmt_flag_legend(16);\n+    st->print_cr(\"file:            file mapped, if mapping is not anonymous\");\n+  }\n+\n+  void print_header() const {\n+    outputStream* st = _session.out();\n+    \/\/            .         .         .         .         .         .         .         .         .         .         .         .\n+    \/\/            012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/            0x0000000414000000 - 0x0000000453000000 1234567890 rw-p 1234567890 1234567890 16g  thp,thpadv       JAVAHEAP  \/shared\/tmp.txt\n+    st->print_cr(\"from                 to                      vsize prot        rss    hugetlb pgsz notes            vm-info   file\");\n+  }\n+};\n+\n+template <class SUMMARY, class PRINTER, class PARSER, class INFO>\n+static void print_mappings_helper(FILE* f, const MappingPrintSession& session) {\n+  PRINTER printer(session);\n+  SUMMARY summary;\n@@ -268,1 +254,2 @@\n-  const bool print_individual_mappings = !session.summary_only();\n+  const bool print_each_mapping = !session.options().only_summary;\n+  outputStream* const st = session.out();\n@@ -270,2 +257,2 @@\n-  if (!session.summary_only()) {\n-    print_legend(session);\n+  if (print_each_mapping) {\n+    printer.print_legend();\n@@ -273,1 +260,1 @@\n-    print_header(session);\n+    printer.print_header();\n@@ -276,2 +263,12 @@\n-  FILE* f = os::fopen(\"\/proc\/self\/smaps\", \"r\");\n-  if (f == nullptr) {\n+  INFO info;\n+  PARSER parser(f);\n+  while (parser.parse_next(info)) {\n+    if (print_each_mapping) {\n+      printer.print_single_mapping(info);\n+    }\n+    summary.add_mapping(info);\n+  }\n+  st->cr();\n+\n+  if (parser.had_error()) {\n+    session.out()->print_cr(\"Error while reading mappings\");\n@@ -281,1 +278,3 @@\n-  Summary summary;\n+  summary.print_on(session);\n+  st->cr();\n+}\n@@ -283,4 +282,0 @@\n-  constexpr size_t linesize = sizeof(ProcMapsInfo);\n-  char line[linesize];\n-  int lines_scanned = 0;\n-  ProcMapsInfo info;\n@@ -288,15 +283,7 @@\n-  while (fgets(line, sizeof(line), f) == line) {\n-    line[sizeof(line) - 1] = '\\0';\n-    if (info.is_header_line(line)) {\n-      if (lines_scanned > 0) {\n-        summary.add_mapping(info);\n-        if (print_individual_mappings) {\n-          info.print_mapping(session);\n-        }\n-      }\n-      info.reset();\n-      info.scan_header_line(line);\n-    } else {\n-      info.scan_additional_lines(line);\n-    }\n-    lines_scanned ++;\n+void MemMapPrinter::pd_print_all_mappings(const MappingPrintSession& session) {\n+  const bool is_detail_mode = session.options().detail_mode;\n+  const char* filename = is_detail_mode ? \"\/proc\/self\/smaps\" : \"\/proc\/self\/maps\";\n+  FILE* f = os::fopen(filename, \"r\");\n+  if (f == nullptr) {\n+    session.out()->print_cr(\"Cannot open %s\", filename);\n+    return;\n@@ -305,5 +292,4 @@\n-  if (lines_scanned > 0) {\n-    summary.add_mapping(info);\n-    if (print_individual_mappings) {\n-      info.print_mapping(session);\n-    }\n+  if (is_detail_mode) {\n+    print_mappings_helper<ProcSmapsSummary, ProcSmapsPrinter, ProcSmapsParser, ProcSmapsInfo>(f, session);\n+  } else {\n+    print_mappings_helper<ProcMapsSummary, ProcMapsPrinter, ProcMapsParser, ProcMapsInfo>(f, session);\n@@ -313,4 +299,0 @@\n-\n-  \/\/ print summary\n-  st->cr();\n-  summary.print_on(session);\n","filename":"src\/hotspot\/os\/linux\/memMapPrinter_linux.cpp","additions":170,"deletions":188,"binary":false,"changes":358,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"procMapsParser.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+static bool is_lowercase_hex(char c) {\n+  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f');\n+}\n+\n+static size_t max_mapping_line_len() {\n+  return 100 + \/\/ everything but the file name\n+         os::vm_page_size() \/\/ the file name (kernel limits \/proc\/pid\/cmdline to 1 page\n+         ;\n+}\n+\n+ProcMapsParserBase::ProcMapsParserBase(FILE* f) :\n+  _f(f), _had_error(false),\n+  _linelen(max_mapping_line_len()), _line(nullptr)\n+{\n+  assert(_f != nullptr, \"Invalid file handle given\");\n+  _line = NEW_C_HEAP_ARRAY(char, max_mapping_line_len(), mtInternal);\n+  _line[0] = '\\0';\n+}\n+\n+ProcMapsParserBase::~ProcMapsParserBase() {\n+  FREE_C_HEAP_ARRAY(char, _line);\n+}\n+\n+bool ProcMapsParserBase::read_line() {\n+  assert(!_had_error, \"Don't call in error state\");\n+  char* rc = ::fgets(_line, _linelen, _f);\n+  if (rc == nullptr) {\n+    _line[0] = '\\0';\n+    _had_error = (::ferror(_f) != 0);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ Starts or continues parsing. Returns true on success,\n+\/\/ false on EOF or on error.\n+bool ProcMapsParser::parse_next(ProcMapsInfo& out) {\n+  bool success = false;\n+  out.reset();\n+  while (success == false) {\n+    if (!read_line()) {\n+      return false;\n+    }\n+    const int items_read = ::sscanf(_line, \"%p-%p %20s %*20s %*20s %*20s %1024s\",\n+        &out.from, &out.to, out.prot, out.filename);\n+    success = (items_read >= 2);\n+  }\n+  return true;\n+}\n+\n+bool ProcSmapsParser::is_header_line() {\n+  return is_lowercase_hex(_line[0]); \/\/ All other lines start with uppercase letters\n+}\n+\n+void ProcSmapsParser::scan_header_line(ProcSmapsInfo& out) {\n+  const int items_read = ::sscanf(_line, \"%p-%p %20s %*s %*s %*s %1024s\",\n+                                  &out.from, &out.to, out.prot, out.filename);\n+  assert(items_read >= 2, \"Expected header_line\");\n+}\n+\n+void ProcSmapsParser::scan_additional_line(ProcSmapsInfo& out) {\n+#define SCAN(key, var) \\\n+ if (::sscanf(_line, key \": %zu kB\", &var) == 1) { \\\n+     var *= K; \\\n+     return; \\\n+ }\n+  SCAN(\"KernelPageSize\", out.kernelpagesize);\n+  SCAN(\"Rss\", out.rss);\n+  SCAN(\"AnonHugePages\", out.anonhugepages);\n+  SCAN(\"Private_Hugetlb\", out.private_hugetlb);\n+  SCAN(\"Shared_Hugetlb\", out.shared_hugetlb);\n+  SCAN(\"Swap\", out.swap);\n+  int i = 0;\n+  if (::sscanf(_line, \"THPeligible: %d\", &i) == 1) {\n+    out.thp_eligible = (i == 1);\n+  }\n+#undef SCAN\n+  \/\/ scan some flags too\n+  if (strncmp(_line, \"VmFlags:\", 8) == 0) {\n+#define SCAN(flag) { out.flag = (::strstr(_line + 8, \" \" #flag) != nullptr); }\n+    SCAN(rd);\n+    SCAN(wr);\n+    SCAN(ex);\n+    SCAN(nr);\n+    SCAN(sh);\n+    SCAN(hg);\n+    SCAN(ht);\n+    SCAN(nh);\n+#undef SCAN\n+    return;\n+  }\n+}\n+\n+\/\/ Starts or continues parsing. Returns true on success,\n+\/\/ false on EOF or on error.\n+bool ProcSmapsParser::parse_next(ProcSmapsInfo& out) {\n+  \/\/ Information about a single mapping reaches across several lines.\n+  out.reset();\n+  \/\/ Read header line, unless we already read it\n+  if (_line[0] == '\\0') {\n+    if (!read_line()) {\n+      return false;\n+    }\n+  }\n+  assert(is_header_line(), \"Not a header line: \\\"%s\\\".\", _line);\n+  scan_header_line(out);\n+  \/\/ Now read until we encounter the next header line or EOF or an error.\n+  bool stop = false;\n+  do {\n+    stop = !read_line() || is_header_line();\n+    if (!stop) {\n+      scan_additional_line(out);\n+    }\n+  } while (!stop);\n+\n+  return !had_error();\n+}\n","filename":"src\/hotspot\/os\/linux\/procMapsParser.cpp","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_PROCMAPSPARSER_HPP\n+#define OS_LINUX_PROCMAPSPARSER_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ This header exposes two simple parsers for \/proc\/pid\/maps and\n+\/\/ \/proc\/pid\/smaps.\n+\/\/\n+\/\/ Usage:\n+\/\/\n+\/\/ FILE* f = fopen(...)\n+\/\/ ProcMapsParser parser(f);\n+\/\/ ProcMapsInfo info;\n+\/\/ while (parser.parse_next(info)) { ... }\n+\n+struct ProcMapsInfo {\n+  void* from;\n+  void* to;\n+  char prot[20 + 1];\n+  char filename[1024 + 1];\n+  inline virtual void reset();\n+  inline size_t vsize() const;\n+};\n+\n+struct ProcSmapsInfo : public ProcMapsInfo {\n+  size_t kernelpagesize;\n+  size_t rss;\n+  size_t private_hugetlb;\n+  size_t shared_hugetlb;\n+  size_t anonhugepages;\n+  size_t swap;\n+  bool rd, wr, ex;\n+  bool sh; \/\/ shared\n+  bool nr; \/\/ no reserve\n+  bool hg; \/\/ thp-advised\n+  bool ht; \/\/ uses hugetlb pages\n+  bool nh; \/\/ thp forbidden\n+  bool thp_eligible;\n+  inline void reset() override;\n+};\n+\n+class ProcMapsParserBase {\n+  FILE* _f;\n+  bool _had_error;\n+protected:\n+  const size_t _linelen;\n+  char* _line;\n+  bool read_line(); \/\/ sets had_error in case of error\n+public:\n+  ProcMapsParserBase(FILE* f);\n+  ~ProcMapsParserBase();\n+  bool had_error() const { return _had_error; }\n+};\n+\n+class ProcMapsParser : public ProcMapsParserBase {\n+public:\n+  ProcMapsParser(FILE* f) : ProcMapsParserBase(f) {}\n+  \/\/ Starts or continues parsing. Returns true on success,\n+  \/\/ false on EOF or on error.\n+  bool parse_next(ProcMapsInfo& out);\n+};\n+\n+class ProcSmapsParser : public ProcMapsParserBase {\n+  bool is_header_line();\n+  void scan_header_line(ProcSmapsInfo& out);\n+  void scan_additional_line(ProcSmapsInfo& out);\n+public:\n+  ProcSmapsParser(FILE* f) : ProcMapsParserBase(f) {}\n+  \/\/ Starts or continues parsing. Returns true on success,\n+  \/\/ false on EOF or on error.\n+  bool parse_next(ProcSmapsInfo& out);\n+};\n+\n+#endif \/\/ OS_LINUX_PROCMAPSPARSER_HPP\n","filename":"src\/hotspot\/os\/linux\/procMapsParser.hpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_PROCMAPSPARSER_INLINE_HPP\n+#define OS_LINUX_PROCMAPSPARSER_INLINE_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"procMapsParser.hpp\"\n+\n+void ProcMapsInfo::reset() {\n+  from = to = nullptr;\n+  prot[0] = filename[0] = '\\0';\n+}\n+\n+size_t ProcMapsInfo::vsize() const {\n+  return from < to ? pointer_delta(to, from, 1) : 0;\n+}\n+\n+void ProcSmapsInfo::reset() {\n+  ProcMapsInfo::reset();\n+  kernelpagesize = rss = private_hugetlb = anonhugepages = swap = 0;\n+}\n+\n+#endif \/\/ OS_LINUX_PROCMAPSPARSER_INLINE_HPP\n","filename":"src\/hotspot\/os\/linux\/procMapsParser.inline.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -212,2 +212,2 @@\n-MappingPrintSession::MappingPrintSession(outputStream* st, const CachedNMTInformation& nmt_info, bool summary_only) :\n-    _out(st), _summary_only(summary_only), _nmt_info(nmt_info)\n+MappingPrintSession::MappingPrintSession(outputStream* st, const CachedNMTInformation& nmt_info, MappingPrintOptions options) :\n+    _out(st), _options(options), _nmt_info(nmt_info)\n@@ -216,1 +216,1 @@\n-void MappingPrintSession::print_nmt_flag_legend(int indent) {\n+void MappingPrintSession::print_nmt_flag_legend(int indent) const {\n@@ -222,1 +222,1 @@\n-void MappingPrintSession::print_nmt_info_for_region(const void* vma_from, const void* vma_to) {\n+void MappingPrintSession::print_nmt_info_for_region(const void* vma_from, const void* vma_to) const {\n@@ -248,1 +248,1 @@\n-void MemMapPrinter::print_all_mappings(outputStream* st, bool summary_only) {\n+void MemMapPrinter::print_all_mappings(outputStream* st, MappingPrintOptions options) {\n@@ -251,1 +251,3 @@\n-  if (!summary_only) {\n+  if (!options.only_summary) {\n+    \/\/ Prepare NMT info cache. But only do so if we print individual mappings,\n+    \/\/ otherwise, we won't need it and can save that work.\n@@ -253,1 +255,0 @@\n-      \/\/ Prepare NMT mapping information.\n@@ -259,1 +260,1 @@\n-  MappingPrintSession session(st, nmt_info, summary_only);\n+  MappingPrintSession session(st, nmt_info, options);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,0 +38,10 @@\n+struct MappingPrintOptions {\n+  \/\/ Depending the the platform specifics, prints\n+  \/\/ more information at higher costs (e.g. on Linux,\n+  \/\/ scans \/proc\/pid\/smaps instead of \/proc\/pid\/maps)\n+  bool detail_mode;\n+  \/\/ Don't print individual mappings. Only\n+  \/\/ print accumulated summary.\n+  bool only_summary;\n+};\n+\n@@ -40,1 +50,1 @@\n-  const bool _summary_only;\n+  const MappingPrintOptions _options;\n@@ -43,5 +53,5 @@\n-  MappingPrintSession(outputStream* st, const CachedNMTInformation& nmt_info, bool summary_only);\n-  void print_nmt_info_for_region(const void* from, const void* to);\n-  void print_nmt_flag_legend(int indent);\n-  outputStream* out() { return _out; }\n-  bool summary_only() const { return _summary_only; }\n+  MappingPrintSession(outputStream* st, const CachedNMTInformation& nmt_info, MappingPrintOptions options);\n+  void print_nmt_info_for_region(const void* from, const void* to) const;\n+  void print_nmt_flag_legend(int indent) const;\n+  const MappingPrintOptions& options() const { return _options; }\n+  outputStream* out() const { return _out; }\n@@ -51,1 +61,1 @@\n-  static void pd_print_all_mappings(MappingPrintSession& session);\n+  static void pd_print_all_mappings(const MappingPrintSession& session);\n@@ -53,1 +63,1 @@\n-  static void print_all_mappings(outputStream* st, bool summary_only);\n+  static void print_all_mappings(outputStream* st, MappingPrintOptions options);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1183,3 +1183,5 @@\n-    DCmdWithParser(output, heap),\n-  _summary(\"summary\", \"Print only summary\", \"BOOLEAN\", false, \"false\") {\n-  _dcmdparser.add_dcmd_option(&_summary);\n+  DCmdWithParser(output, heap),\n+  _only_summary(\"summary\", \"Omit printing individual mappings, only print the summary.\", \"BOOLEAN\", false, \"false\"),\n+  _detail_mode(\"details\", \"Print more information at a potentially higher cost.\", \"BOOLEAN\", false, \"false\") {\n+  _dcmdparser.add_dcmd_option(&_only_summary);\n+  _dcmdparser.add_dcmd_option(&_detail_mode);\n@@ -1189,1 +1191,4 @@\n-  MemMapPrinter::print_all_mappings(output(), _summary.value());\n+  MappingPrintOptions options;\n+  options.detail_mode = _detail_mode.value();\n+  options.only_summary = _only_summary.value();\n+  MemMapPrinter::print_all_mappings(output(), options);\n@@ -1193,2 +1198,3 @@\n-    DCmdWithParser(output, heap),\n-  _summary(\"summary\", \"Print only summary\", \"BOOLEAN\", false, \"false\"),\n+  DCmdWithParser(output, heap),\n+  _only_summary(\"summary\", \"Omit printing individual mappings, only print the summary.\", \"BOOLEAN\", false, \"false\"),\n+  _detail_mode(\"details\", \"Print more information at a potentially higher cost.\", \"BOOLEAN\", false, \"false\"),\n@@ -1196,1 +1202,2 @@\n-  _dcmdparser.add_dcmd_option(&_summary);\n+  _dcmdparser.add_dcmd_option(&_only_summary);\n+  _dcmdparser.add_dcmd_option(&_detail_mode);\n@@ -1209,1 +1216,4 @@\n-    MemMapPrinter::print_all_mappings(&fs, _summary.value());\n+    MappingPrintOptions options;\n+    options.detail_mode = _detail_mode.value();\n+    options.only_summary = _only_summary.value();\n+    MemMapPrinter::print_all_mappings(&fs, options);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -987,1 +987,2 @@\n-  DCmdArgument<bool> _summary;\n+  DCmdArgument<bool> _only_summary;\n+  DCmdArgument<bool> _detail_mode;\n@@ -989,1 +990,1 @@\n-  static int num_arguments() { return 1; }\n+  static int num_arguments() { return 2; }\n@@ -995,1 +996,1 @@\n-  static const char* impact() { return \"Low\"; }\n+  static const char* impact() { return \"Medium to High. Printing in detail mode may be costly if the process size is very large.\"; }\n@@ -1005,1 +1006,2 @@\n-  DCmdArgument<bool> _summary;\n+  DCmdArgument<bool> _only_summary;\n+  DCmdArgument<bool> _detail_mode;\n@@ -1008,1 +1010,1 @@\n-  static int num_arguments() { return 2; }\n+  static int num_arguments() { return 3; }\n@@ -1014,1 +1016,1 @@\n-  static const char* impact() { return \"Low\"; }\n+  static const char* impact() { return \"Medium to High. Printing in detail mode may be costly if the process size is very large.\"; }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"}]}