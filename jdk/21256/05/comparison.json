{"files":[{"patch":"@@ -717,1 +717,1 @@\n-     * perform the launch.\n+     * configure the FX launch.\n@@ -725,1 +725,1 @@\n-     * @return the application's main class\n+     * @return the application's main entry point\n@@ -728,1 +728,1 @@\n-    public static Class<?> checkAndLoadMain(boolean printToStderr,\n+    public static MainEntry locateMainEntry(boolean printToStderr,\n@@ -733,1 +733,1 @@\n-        Class<?> mainClass = null;\n+        final MainEntry.Builder mainEntryBuilder = new MainEntry.Builder();\n@@ -736,1 +736,1 @@\n-                mainClass = loadModuleMainClass(what);\n+                loadModuleMainClass(what, mainEntryBuilder);\n@@ -739,1 +739,1 @@\n-                mainClass = loadMainClass(mode, what);\n+                loadMainClass(mode, what, mainEntryBuilder);\n@@ -742,1 +742,2 @@\n-\n+        \/\/ at this point, the main class must have been determined and set in the builder\n+        assert mainEntryBuilder.mainClass != null : \"missing main class\";\n@@ -744,2 +745,1 @@\n-        \/\/ neither method above can return null, they will abort()\n-        appClass = mainClass;\n+        mainEntryBuilder.appClass = mainEntryBuilder.mainClass;\n@@ -752,2 +752,2 @@\n-        if (JAVAFX_FXHELPER_CLASS_NAME_SUFFIX.equals(mainClass.getName()) ||\n-            doesExtendFXApplication(mainClass)) {\n+        if (JAVAFX_FXHELPER_CLASS_NAME_SUFFIX.equals(mainEntryBuilder.mainClass.getName()) ||\n+            doesExtendFXApplication(mainEntryBuilder.mainClass)) {\n@@ -756,1 +756,1 @@\n-            mainClass = FXHelper.class;\n+            mainEntryBuilder.mainClass = FXHelper.class;\n@@ -758,3 +758,1 @@\n-\n-        validateMainMethod(mainClass);\n-        return mainClass;\n+        return requireValidMainMethod(mainEntryBuilder);\n@@ -764,1 +762,2 @@\n-     * Returns the main class for a module. The query is either a module name\n+     * Sets the {@linkplain MainEntry.Builder#mainClass main class} after determining the\n+     * main class for a module. The {@code what} is either a module name\n@@ -768,1 +767,1 @@\n-    private static Class<?> loadModuleMainClass(String what) {\n+    private static void loadModuleMainClass(String what, MainEntry.Builder builder) {\n@@ -817,1 +816,1 @@\n-        return c;\n+        builder.mainClass = c;\n@@ -823,1 +822,1 @@\n-    private static Class<?> loadMainClass(int mode, String what) {\n+    private static void loadMainClass(int mode, String what, MainEntry.Builder builder) {\n@@ -826,0 +825,1 @@\n+        Class<?> mainClass = null;\n@@ -831,21 +831,0 @@\n-        switch (mode) {\n-            case LM_CLASS:\n-                cn = what;\n-                break;\n-            case LM_JAR:\n-                try {\n-                    jarFile = new JarFile(what);\n-                    cn = getMainClassFromJar(jarFile);\n-                } catch (IOException ioe) {\n-                    abort(ioe, \"java.launcher.jar.error1\", what);\n-                }\n-                break;\n-            default:\n-                \/\/ should never happen\n-                throw new InternalError(\"\" + mode + \": Unknown launch mode\");\n-        }\n-\n-        \/\/ load the main class\n-        cn = cn.replace('\/', '.');\n-        Class<?> mainClass = null;\n-        ClassLoader scl = ClassLoader.getSystemClassLoader();\n@@ -853,0 +832,20 @@\n+            switch (mode) {\n+                case LM_CLASS:\n+                    cn = what;\n+                    break;\n+                case LM_JAR:\n+                    try {\n+                        jarFile = new JarFile(what);\n+                        cn = getMainClassFromJar(jarFile);\n+                    } catch (IOException ioe) {\n+                        abort(ioe, \"java.launcher.jar.error1\", what);\n+                    }\n+                    break;\n+                default:\n+                    \/\/ should never happen\n+                    throw new InternalError(\"Unknown launch mode: \" + mode);\n+            }\n+            assert cn != null : \"missing main class name\";\n+            \/\/ load the main class (but don't initialize it yet)\n+            cn = cn.replace('\/', '.');\n+            ClassLoader scl = ClassLoader.getSystemClassLoader();\n@@ -886,11 +885,2 @@\n-        return mainClass;\n-    }\n-\n-    \/*\n-     * Accessor method called by the launcher after getting the main class via\n-     * checkAndLoadMain(). The \"application class\" is the class that is finally\n-     * executed to start the application and in this case is used to report\n-     * the correct application name, typically for UI purposes.\n-     *\/\n-    public static Class<?> getApplicationClass() {\n-        return appClass;\n+        assert mainClass != null : \"missing main class\";\n+        builder.mainClass = mainClass;\n@@ -914,5 +904,3 @@\n-    private static boolean isStaticMain = false;\n-    private static boolean noArgMain = false;\n-\n-    \/\/ Check the existence and signature of main and abort if incorrect.\n-    private static void validateMainMethod(Class<?> mainClass) {\n+    \/\/ Determine the presence of a valid main method on the MainEntry.Builder.mainClass.\n+    \/\/ abort() if validation fails.\n+    private static MainEntry requireValidMainMethod(MainEntry.Builder builder) {\n@@ -921,2 +909,1 @@\n-            mainMethod = MethodFinder.findMainMethod(mainClass);\n-\n+            mainMethod = MethodFinder.findMainMethod(builder.mainClass);\n@@ -925,1 +912,1 @@\n-                abort(null, \"java.launcher.cls.error2\", mainClass.getName(),\n+                abort(null, \"java.launcher.cls.error2\", builder.mainClass.getName(),\n@@ -929,1 +916,1 @@\n-            if (mainClass.getModule().isNamed()) {\n+            if (builder.mainClass.getModule().isNamed()) {\n@@ -931,1 +918,1 @@\n-                      mainClass.getName(), mainClass.getModule().getName(),\n+                      builder.mainClass.getName(), builder.mainClass.getModule().getName(),\n@@ -934,1 +921,1 @@\n-                abort(e, \"java.launcher.cls.error5\", mainClass.getName(),\n+                abort(e, \"java.launcher.cls.error5\", builder.mainClass.getName(),\n@@ -938,0 +925,2 @@\n+        \/\/ main method must be located by now\n+        assert mainMethod != null : \"main method wasn't located\";\n@@ -940,1 +929,1 @@\n-        isStaticMain = Modifier.isStatic(mods);\n+        boolean isStaticMain = Modifier.isStatic(mods);\n@@ -942,2 +931,1 @@\n-        noArgMain = mainMethod.getParameterCount() == 0;\n-\n+        boolean noArgMain = mainMethod.getParameterCount() == 0;\n@@ -946,2 +934,2 @@\n-                  abort(null, \"java.launcher.cls.error2\", mainClass.getName(),\n-                       JAVAFX_APPLICATION_CLASS_NAME);\n+                abort(null, \"java.launcher.cls.error2\", builder.mainClass.getName(),\n+                        JAVAFX_APPLICATION_CLASS_NAME);\n@@ -949,1 +937,0 @@\n-            return;\n@@ -951,13 +938,18 @@\n-\n-        if (!isStaticMain) {\n-            String className = mainMethod.getDeclaringClass().getName();\n-            if (mainClass.isMemberClass() && !Modifier.isStatic(mainClass.getModifiers())) {\n-                abort(null, \"java.launcher.cls.error7\", className);\n-            }\n-            try {\n-                Constructor<?> constructor = mainClass.getDeclaredConstructor();\n-                if (Modifier.isPrivate(constructor.getModifiers())) {\n-                    abort(null, \"java.launcher.cls.error6\", className);\n-                }\n-            } catch (Throwable ex) {\n-                abort(null, \"java.launcher.cls.error6\", className);\n+        \/\/ valid main method, set it on the builder\n+        builder.mainMethod = mainMethod;\n+        if (Modifier.isStatic(mainMethod.getModifiers())) {\n+            \/\/ located a valid static main method\n+            return builder.build();\n+        }\n+        \/\/ located an instance main method, now validate that the class to which this main method\n+        \/\/ belongs has the relevant constructor\n+        Constructor<?> noArgConstructor = null;\n+        final String declaringClsName = mainMethod.getDeclaringClass().getName();\n+        if (builder.mainClass.isMemberClass()\n+                && !Modifier.isStatic(builder.mainClass.getModifiers())) {\n+            abort(null, \"java.launcher.cls.error7\", declaringClsName);\n+        }\n+        try {\n+            noArgConstructor = builder.mainClass.getDeclaredConstructor();\n+            if (Modifier.isPrivate(noArgConstructor.getModifiers())) {\n+                abort(null, \"java.launcher.cls.error6\", declaringClsName);\n@@ -965,0 +957,2 @@\n+        } catch (Throwable ex) {\n+            abort(null, \"java.launcher.cls.error6\", declaringClsName);\n@@ -966,0 +960,3 @@\n+        assert noArgConstructor != null : \"missing no-arg constructor for main class\";\n+        builder.noArgConstructor = noArgConstructor;\n+        return builder.build();\n@@ -1329,0 +1326,53 @@\n+    \/**\n+     * Carries details about the main method that has been resolved for an application.\n+     * This information will be used by the native code in the launcher.\n+     *\n+     * @param mainClass        The main class which will be launched for the application.\n+     *                         Cannot be null.\n+     * @param noArgConstructor The no-arg constructor of the {@code mainClass} if the application's\n+     *                         main method is determined to be an instance main method. Can be null,\n+     *                         in which case the main method represents a static main method.\n+     * @param mainMethod       The main method of the application which will be invoked by the\n+     *                         launcher. Cannot be null.\n+     * @param isNoArgMain      {@code true}, if the {@code mainMethod} is a no-arg method,\n+     *                         {@code false} otherwise.\n+     * @param appClass         The class which is the actual main class of the application. In cases\n+     *                         like JavaFX, the {@code mainClass} will represent a wrapper class of\n+     *                         the JavaFX framework and the application's actual main class will\n+     *                         be stored in this {@code appClass}. In all other cases,\n+     *                         the {@code appClass} is the same as {@code mainClass}.\n+     *\/\n+    public record MainEntry(Class<?> mainClass, Constructor<?> noArgConstructor,\n+                            Method mainMethod, boolean isNoArgMain, Class<?> appClass) {\n+\n+        public MainEntry {\n+            assert mainClass != null : \"mainClass is null\";\n+            assert mainMethod != null : \"mainMethod is null\";\n+            assert appClass != null : \"appClass is null\";\n+            if (noArgConstructor == null) {\n+                assert Modifier.isStatic(mainMethod.getModifiers())\n+                        : \"missing no-arg constructor\";\n+            } else {\n+                assert !Modifier.isStatic(mainMethod.getModifiers())\n+                        : \"unexpected static main method\";\n+            }\n+            if (isNoArgMain) {\n+                assert mainMethod.getParameterCount() == 0 : \"main method is not a no-arg method\";\n+            } else {\n+                assert mainMethod.getParameterCount() != 0 : \"main method is a no-arg method\";\n+            }\n+        }\n+\n+        private static final class Builder {\n+            private Class<?> mainClass;\n+            private Class<?> appClass;\n+            private Method mainMethod;\n+            private Constructor<?> noArgConstructor;\n+\n+            MainEntry build() {\n+                final boolean isNoArgMain = mainMethod.getParameterCount() == 0;\n+                return new MainEntry(mainClass, noArgConstructor, mainMethod,\n+                        isNoArgMain, appClass);\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":131,"deletions":81,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -115,1 +115,0 @@\n-static jclass LoadMainClass(JNIEnv *env, int mode, char *name);\n@@ -117,2 +116,1 @@\n-static jclass GetApplicationClass(JNIEnv *env);\n-\n+static jobject LocateMainEntry(JNIEnv *env, int mode, char *name);\n@@ -373,87 +371,0 @@\n-\/*\n- * Invokes static main(String[]) method if found.\n- * Returns 0 with a pending exception if not found. Returns 1 if invoked, maybe\n- * a pending exception if the method threw.\n- *\/\n-int\n-invokeStaticMainWithArgs(JNIEnv *env, jclass mainClass, jobjectArray mainArgs) {\n-    jmethodID mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n-                                  \"([Ljava\/lang\/String;)V\");\n-    if (mainID == NULL) {\n-        \/\/ static main(String[]) not found\n-        return 0;\n-    }\n-    (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n-    return 1; \/\/ method was invoked\n-}\n-\n-\/*\n- * Invokes instance main(String[]) method if found.\n- * Returns 0 with a pending exception if not found. Returns 1 if invoked, maybe\n- * a pending exception if the method threw.\n- *\/\n-int\n-invokeInstanceMainWithArgs(JNIEnv *env, jclass mainClass, jobjectArray mainArgs) {\n-    jmethodID constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n-    if (constructor == NULL) {\n-        \/\/ main class' no-arg constructor not found\n-        return 0;\n-    }\n-    jobject mainObject = (*env)->NewObject(env, mainClass, constructor);\n-    if (mainObject == NULL) {\n-        \/\/ main class instance couldn't be constructed\n-        return 0;\n-    }\n-    jmethodID mainID =\n-        (*env)->GetMethodID(env, mainClass, \"main\", \"([Ljava\/lang\/String;)V\");\n-    if (mainID == NULL) {\n-        \/\/ instance method main(String[]) method not found\n-        return 0;\n-    }\n-    (*env)->CallVoidMethod(env, mainObject, mainID, mainArgs);\n-    return 1; \/\/ method was invoked\n-}\n-\n-\/*\n- * Invokes no-arg static main() method if found.\n- * Returns 0 with a pending exception if not found. Returns 1 if invoked, maybe\n- * a pending exception if the method threw.\n- *\/\n-int\n-invokeStaticMainWithoutArgs(JNIEnv *env, jclass mainClass) {\n-    jmethodID mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n-                                       \"()V\");\n-    if (mainID == NULL) {\n-        \/\/ static main() method couldn't be located\n-        return 0;\n-    }\n-    (*env)->CallStaticVoidMethod(env, mainClass, mainID);\n-    return 1; \/\/ method was invoked\n-}\n-\n-\/*\n- * Invokes no-arg instance main() method if found.\n- * Returns 0 with a pending exception if not found. Returns 1 if invoked, maybe\n- * a pending exception if the method threw.\n- *\/\n-int\n-invokeInstanceMainWithoutArgs(JNIEnv *env, jclass mainClass) {\n-    jmethodID constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n-    if (constructor == NULL) {\n-        \/\/ main class' no-arg constructor not found\n-        return 0;\n-    }\n-    jobject mainObject = (*env)->NewObject(env, mainClass, constructor);\n-    if (mainObject == NULL) {\n-        \/\/ couldn't create instance of main class\n-        return 0;\n-    }\n-    jmethodID mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n-                                 \"()V\");\n-    if (mainID == NULL) {\n-        \/\/ instance method main() not found\n-        return 0;\n-    }\n-    (*env)->CallVoidMethod(env, mainObject, mainID);\n-    return 1; \/\/ method was invoked\n-}\n@@ -473,3 +384,0 @@\n-    jclass mainClass = NULL;\n-    jclass appClass = NULL; \/\/ actual application class being launched\n-    jobjectArray mainArgs;\n@@ -478,5 +386,0 @@\n-    jclass helperClass;\n-    jfieldID isStaticMainField;\n-    jboolean isStaticMain;\n-    jfieldID noArgMainField;\n-    jboolean noArgMain;\n@@ -565,23 +468,7 @@\n-    \/*\n-     * See bugid 5030265.  The Main-Class name has already been parsed\n-     * from the manifest, but not parsed properly for UTF-8 support.\n-     * Hence the code here ignores the value previously extracted and\n-     * uses the pre-existing code to reextract the value.  This is\n-     * possibly an end of release cycle expedient.  However, it has\n-     * also been discovered that passing some character sets through\n-     * the environment has \"strange\" behavior on some variants of\n-     * Windows.  Hence, maybe the manifest parsing code local to the\n-     * launcher should never be enhanced.\n-     *\n-     * Hence, future work should either:\n-     *     1)   Correct the local parsing code and verify that the\n-     *          Main-Class attribute gets properly passed through\n-     *          all environments,\n-     *     2)   Remove the vestages of maintaining main_class through\n-     *          the environment (and remove these comments).\n-     *\n-     * This method also correctly handles launching existing JavaFX\n-     * applications that may or may not have a Main-Class manifest entry.\n-     *\/\n-    mainClass = LoadMainClass(env, mode, what);\n-    CHECK_EXCEPTION_NULL_LEAVE(mainClass);\n+    const jobject mainEntry = LocateMainEntry(env, mode, what);\n+    CHECK_EXCEPTION_NULL_LEAVE(mainEntry);\n+    const jclass mainEntryType = (*env)->GetObjectClass(env, mainEntry); \/\/ sun\/launcher\/LauncherHelper$MainEntry\n+    const jfieldID mainClassFid = (*env)->GetFieldID(env, mainEntryType, \"mainClass\", \"Ljava\/lang\/Class;\");\n+    CHECK_EXCEPTION_NULL_LEAVE(mainClassFid);\n+    const jclass mainClass = (jclass)(*env)->GetObjectField(env, mainEntry, mainClassFid);\n+\n@@ -590,1 +477,1 @@\n-     * JavaFX application with no main method, the mainClass will not be the\n+     * JavaFX application with no main method, the main class will not be the\n@@ -594,1 +481,3 @@\n-    appClass = GetApplicationClass(env);\n+    const jfieldID appClassFid = (*env)->GetFieldID(env, mainEntryType, \"appClass\", \"Ljava\/lang\/Class;\");\n+    CHECK_EXCEPTION_NULL_LEAVE(appClassFid);\n+    const jclass appClass = (jclass)(*env)->GetObjectField(env, mainEntry, appClassFid);\n@@ -598,1 +487,1 @@\n-    mainArgs = CreateApplicationArgs(env, argv, argc);\n+    const jobjectArray mainArgs = CreateApplicationArgs(env, argv, argc);\n@@ -610,1 +499,1 @@\n-     * instead of mainClass as that may be a launcher or helper class instead\n+     * instead of main class as that may be a launcher or helper class instead\n@@ -616,0 +505,15 @@\n+    const jfieldID mainMethodFid = (*env)->GetFieldID(env, mainEntryType, \"mainMethod\",\n+                                                      \"Ljava\/lang\/reflect\/Method;\");\n+    CHECK_EXCEPTION_NULL_LEAVE(mainMethodFid);\n+    const jobject mainMethod = (*env)->GetObjectField(env, mainEntry, mainMethodFid);\n+    CHECK_EXCEPTION_NULL_LEAVE(mainMethod);\n+\n+    const jfieldID noArgCtorFid = (*env)->GetFieldID(env, mainEntryType, \"noArgConstructor\",\n+                                                     \"Ljava\/lang\/reflect\/Constructor;\");\n+    CHECK_EXCEPTION_NULL_LEAVE(noArgCtorFid);\n+    const jobject noArgCtor = (*env)->GetObjectField(env, mainEntry, noArgCtorFid);\n+\n+    const jfieldID isNoArgMainFid = (*env)->GetFieldID(env, mainEntryType, \"isNoArgMain\", \"Z\");\n+    CHECK_EXCEPTION_NULL_LEAVE(isNoArgMainFid);\n+    const jboolean isNoArgMain = (*env)->GetBooleanField(env, mainEntry, isNoArgMainFid);\n+\n@@ -620,22 +524,18 @@\n-\n-    helperClass = GetLauncherHelperClass(env);\n-    isStaticMainField = (*env)->GetStaticFieldID(env, helperClass, \"isStaticMain\", \"Z\");\n-    CHECK_EXCEPTION_NULL_LEAVE(isStaticMainField);\n-    isStaticMain = (*env)->GetStaticBooleanField(env, helperClass, isStaticMainField);\n-\n-    noArgMainField = (*env)->GetStaticFieldID(env, helperClass, \"noArgMain\", \"Z\");\n-    CHECK_EXCEPTION_NULL_LEAVE(noArgMainField);\n-    noArgMain = (*env)->GetStaticBooleanField(env, helperClass, noArgMainField);\n-\n-    if (isStaticMain) {\n-        if (noArgMain) {\n-            ret = invokeStaticMainWithoutArgs(env, mainClass);\n-        } else {\n-            ret = invokeStaticMainWithArgs(env, mainClass, mainArgs);\n-        }\n-    } else {\n-        if (noArgMain) {\n-            ret = invokeInstanceMainWithoutArgs(env, mainClass);\n-        } else {\n-            ret = invokeInstanceMainWithArgs(env, mainClass, mainArgs);\n-        }\n+    \/\/ FromReflectedMethod will internally initialize the class to which the mainMethod belongs\n+    const jmethodID mainMethodId = (*env)->FromReflectedMethod(env, mainMethod);\n+    CHECK_EXCEPTION_NULL_LEAVE(mainMethodId); \/\/ can happen if static initialization of the mainMethod's class failed\n+\n+    jboolean mainInvoked = JNI_FALSE;\n+    if (noArgCtor == NULL) { \/\/ static main method\n+        isNoArgMain ? (*env)->CallStaticVoidMethod(env, mainClass, mainMethodId)\n+                    : (*env)->CallStaticVoidMethod(env, mainClass, mainMethodId, mainArgs);\n+        mainInvoked = JNI_TRUE;\n+    } else { \/\/ instance main method\n+        const jmethodID ctorMethodId = (*env)->FromReflectedMethod(env, noArgCtor);\n+        CHECK_EXCEPTION_NULL_LEAVE(ctorMethodId);\n+        \/\/ instantiate the main class instance\n+        const jobject mainClassInst = (*env)->NewObject(env, mainClass, ctorMethodId);\n+        CHECK_EXCEPTION_NULL_LEAVE(mainClassInst);\n+        isNoArgMain ? (*env)->CallVoidMethod(env, mainClassInst, mainMethodId)\n+                    : (*env)->CallVoidMethod(env, mainClassInst, mainMethodId, mainArgs);\n+        mainInvoked = JNI_TRUE;\n@@ -643,3 +543,3 @@\n-    if (!ret) {\n-        \/\/ An appropriate main method couldn't be located, check and report\n-        \/\/ any exception and LEAVE()\n+    if (!mainInvoked) {\n+        \/\/ An appropriate main method wasn't invoked, check and report\n+        \/\/ any exception and LEAVE().\n@@ -653,1 +553,1 @@\n-    if (ret && (*env)->ExceptionOccurred(env) == NULL) {\n+    if (mainInvoked && (*env)->ExceptionOccurred(env) == NULL) {\n@@ -662,1 +562,1 @@\n-    LEAVE();\n+    LEAVE(); \/\/ exits with the correct \"ret\" code\n@@ -1562,3 +1462,3 @@\n- * Calls LauncherHelper::checkAndLoadMain to verify that the main class\n- * is present, it is ok to load the main class and then load the main class.\n- * For more details refer to the java implementation.\n+ * Calls LauncherHelper::locateMainEntry to determine the main method\n+ * of the main class. For more details refer to the java implementation\n+ * of LauncherHelper::locateMainEntry.\n@@ -1566,2 +1466,2 @@\n-static jclass\n-LoadMainClass(JNIEnv *env, int mode, char *name)\n+static jobject\n+LocateMainEntry(JNIEnv *env, int mode, char *name)\n@@ -1573,2 +1473,2 @@\n-    jclass cls = GetLauncherHelperClass(env);\n-    NULL_CHECK0(cls);\n+    jclass launcherHelperClass = GetLauncherHelperClass(env);\n+    NULL_CHECK0(launcherHelperClass);\n@@ -1578,3 +1478,2 @@\n-    NULL_CHECK0(mid = (*env)->GetStaticMethodID(env, cls,\n-                \"checkAndLoadMain\",\n-                \"(ZILjava\/lang\/String;)Ljava\/lang\/Class;\"));\n+    NULL_CHECK0(mid = (*env)->GetStaticMethodID(env, launcherHelperClass,\n+            \"locateMainEntry\", \"(ZILjava\/lang\/String;)Lsun\/launcher\/LauncherHelper$MainEntry;\"));\n@@ -1583,1 +1482,1 @@\n-    NULL_CHECK0(result = (*env)->CallStaticObjectMethod(env, cls, mid,\n+    NULL_CHECK0(result = (*env)->CallStaticObjectMethod(env, launcherHelperClass, mid,\n@@ -1588,1 +1487,1 @@\n-        printf(\"%ld micro seconds to load main class\\n\", (long)(end-start));\n+        printf(\"%ld micro seconds to locate main method\\n\", (long)(end-start));\n@@ -1592,17 +1491,1 @@\n-    return (jclass)result;\n-}\n-\n-static jclass\n-GetApplicationClass(JNIEnv *env)\n-{\n-    jmethodID mid;\n-    jclass appClass;\n-    jclass cls = GetLauncherHelperClass(env);\n-    NULL_CHECK0(cls);\n-    NULL_CHECK0(mid = (*env)->GetStaticMethodID(env, cls,\n-                \"getApplicationClass\",\n-                \"()Ljava\/lang\/Class;\"));\n-\n-    appClass = (*env)->CallStaticObjectMethod(env, cls, mid);\n-    CHECK_EXCEPTION_RETURN_VALUE(0);\n-    return appClass;\n+    return (jobject) result;\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":64,"deletions":181,"binary":false,"changes":245,"status":"modified"}]}