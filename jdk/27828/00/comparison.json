{"files":[{"patch":"@@ -1423,0 +1423,4 @@\n+\n+  get_archive(is_static_archive)->_unregistered_dictionary.iterate([&] (const RunTimeClassInfo* record) {\n+      classes->append(record->klass());\n+    });\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,412 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/*\n+\n+This is a simple parser for parsing the output of\n+\n+   java -Xshare:dump -Xlog:aot+map=debug,aot+map+oops=trace:file=aot.map:none:filesize=0\n+\n+The map file contains patterns like this for the heap objects:\n+\n+======================================================================\n+0x00000000ffe00000: @@ Object (0xffe00000) java.lang.String \"\"\n+ - klass: 'java\/lang\/String' 0x0000000800010220\n+ - fields (3 words):\n+ - private 'hash' 'I' @12  0 (0x00000000)\n+ - private final 'coder' 'B' @16  0 (0x00)\n+ - private 'hashIsZero' 'Z' @17  true (0x01)\n+ - injected 'flags' 'B' @18  1 (0x01)\n+ - private final 'value' '[B' @20 0x00000000ffe00018 (0xffe00018) [B length: 0\n+0x00000000ffe00018: @@ Object (0xffe00018) [B length: 0\n+ - klass: {type array byte} 0x00000008000024d8\n+======================================================================\n+\n+Currently this parser just check the output related to JDK-8308903.\n+I.e., each oop field must point to a valid HeapObject. For example, the 'value' field\n+in the String must point to a valid byte array.\n+\n+This parser can be extended to check for the other parts of the map file, or perform\n+more analysis on the HeapObjects.\n+\n+*\/\n+\n+public class AOTMapReader {\n+    public static class MapFile {\n+        HashSet<String> classes = new HashSet<>();\n+        ArrayList<HeapObject> heapObjects = new ArrayList<>();\n+        HashMap<Long, HeapObject> oopToObject = new HashMap<>();\n+        HashMap<Long, HeapObject> narrowOopToObject = new HashMap<>();\n+        public int stringCount = 0;\n+\n+        void add(HeapObject heapObject) {\n+            heapObjects.add(heapObject);\n+            oopToObject.put(heapObject.address.oop, heapObject);\n+            if (heapObject.address.narrowOop != 0) {\n+                narrowOopToObject.put(heapObject.address.narrowOop, heapObject);\n+            }\n+            if (heapObject.className.equals(\"java.lang.String\")) {\n+                stringCount ++;\n+            }\n+        }\n+\n+        public int heapObjectCount() {\n+            return heapObjects.size();\n+        }\n+\n+        void addClass(String className) {\n+            classes.add(className);\n+        }\n+\n+        public boolean hasClass(String className) {\n+            return classes.contains(className);\n+        }\n+\n+        public void shouldHaveClass(String className) {\n+            if (!hasClass(className)) {\n+                throw new RuntimeException(\"AOT map file is missing class \" + className);\n+            }\n+        }\n+    }\n+\n+    public static class HeapAddress {\n+        long oop;\n+        long narrowOop;\n+\n+        HeapAddress(String oopStr, String narrowOopStr) {\n+            oop = Long.parseUnsignedLong(oopStr, 16);\n+            if (narrowOopStr != null) {\n+                narrowOop = Long.parseUnsignedLong(narrowOopStr, 16);\n+            }\n+        }\n+    }\n+\n+    public static class Klass {\n+        long address;\n+        String name;\n+\n+        static Klass getKlass(String name, String addr) {\n+            \/\/ TODO: look up from a table of known Klasses\n+            Klass k = new Klass();\n+            k.name = name;\n+            k.address =  Long.parseUnsignedLong(addr, 16);\n+            return k;\n+        }\n+    }\n+\n+    public static class HeapObject {\n+        HeapAddress address;\n+        ArrayList<Field> fields;\n+        String className;\n+        Klass klass;\n+\n+        HeapObject(String className, String oop, String narrowOop) {\n+            this.className = className;\n+            address = new HeapAddress(oop, narrowOop);\n+        }\n+\n+        void setKlass(String klassName, String address) {\n+            klass = Klass.getKlass(klassName, address);\n+        }\n+\n+        void addOopField(String name, String offset, String oopStr, String narrowOopStr) {\n+            if (fields == null) {\n+                fields = new ArrayList<Field>();\n+            }\n+            fields.add(new Field(name, offset, oopStr, narrowOopStr));\n+        }\n+    }\n+\n+    public static class Field {\n+        String name;\n+        int offset;\n+        HeapAddress referentAddress; \/\/ non-null iff this is an object field\n+        int lineCount;\n+\n+        Field(String name, String offset, String oopStr, String narrowOopStr) {\n+            this.name = name;\n+            this.offset = Integer.parseInt(offset);\n+            this.referentAddress = new HeapAddress(oopStr, narrowOopStr);\n+            this.lineCount = AOTMapReader.lineCount;\n+        }\n+    }\n+\n+    \/\/ 0x00000007ffc00000:   4a5b8701 00000063 00010290 00000000 00010100 fff80003\n+    static Pattern rawDataPattern = Pattern.compile(\"^0x([0-9a-f]+): *( [0-9a-f]+)+ *$\");\n+\n+    \/\/ -------------------------------------------------------------------------------\n+    \/\/ Patterns for heap objects\n+    \/\/ -------------------------------------------------------------------------------\n+\n+    \/\/ (one address)\n+    \/\/ 0x00000007ffc00000: @@ Object java.lang.String\n+    static Pattern objPattern1 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object ([^ ]*)\");\n+\n+    \/\/ (two addresses)\n+    \/\/ 0x00000007ffc00000: @@ Object (0xfff80000) java.lang.String\n+    static Pattern objPattern2 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object [(]0x([0-9a-f]+)[)] ([^ ]*)\");\n+\n+    \/\/  - klass: 'java\/lang\/String' 0x0000000800010290\n+    static Pattern instanceObjKlassPattern = Pattern.compile(\"^ - klass: '([^']+)' 0x([0-9a-f]+)\");\n+\n+    \/\/  - klass: {type array byte} 0x00000008000024c8\n+    static Pattern typeArrayKlassPattern = Pattern.compile(\"^ - klass: [{]type array ([a-z]+)[}] 0x([0-9a-f]+)\");\n+\n+    \/\/  - klass: 'java\/lang\/Object'[] 0x00000008000013e0\n+    static Pattern objArrayKlassPattern = Pattern.compile(\"^ - klass: ('[^']+'(\\\\[\\\\])+) 0x([0-9a-f]+)\");\n+\n+    \/\/  - fields (3 words):\n+    static Pattern fieldsWordsPattern = Pattern.compile(\"^ - fields [(]([0-9]+) words[)]:$\");\n+\n+    \/\/ (one address)\n+    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 java.lang.String\n+    static Pattern oopFieldPattern1 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) (.*)\");\n+\n+    \/\/ (two addresses)\n+    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 (0xfff8d04c) java.lang.String\n+    static Pattern oopFieldPattern2 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) [(]0x([0-9a-f]+)[)] (.*)\");\n+\n+    \/\/ (injected module_entry)\n+    \/\/  - injected 'module_entry' 'J' @16 0 (0x0000000000000000)\n+    static Pattern moduleEntryPattern = Pattern.compile(\"- injected 'module_entry' 'J' @[0-9]+[ ]+([0-9]+)\");\n+\n+    \/\/ -------------------------------------------------------------------------------\n+    \/\/ Patterns for metaspace objects\n+    \/\/ -------------------------------------------------------------------------------\n+\n+    \/\/ 0x00000008000d1698: @@ Class             512 [Ljdk.internal.vm.FillerElement;\n+    \/\/ 0x00000008000d18a0: @@ Class             520 java.lang.Cloneable\n+    static Pattern classPattern = Pattern.compile(\"^0x([0-9a-f]+): @@ Class [ ]*([0-9]+) (.*)\");\n+\n+\n+    private static Matcher match(String line, Pattern pattern) {\n+        Matcher m = pattern.matcher(line);\n+        if (m.find()) {\n+            return m;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static void parseHeapObject(String className, String oop, String narrowOop) throws IOException {\n+        HeapObject heapObject = parseHeapObjectImpl(className, oop, narrowOop);\n+        mapFile.add(heapObject);\n+    }\n+\n+    private static HeapObject parseHeapObjectImpl(String className, String oop, String narrowOop) throws IOException {\n+        HeapObject heapObject = new HeapObject(className, oop, narrowOop);\n+        Matcher m;\n+\n+        nextLine();\n+        while (line != null && match(line, rawDataPattern) != null) { \/\/ skip raw data\n+            nextLine();\n+        }\n+\n+        if (line == null || !line.startsWith(\" - \")) {\n+            return heapObject;\n+        }\n+\n+        if ((m = match(line, instanceObjKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(2));\n+            nextLine();\n+            if ((m = match(line, fieldsWordsPattern)) == null) {\n+                throw new RuntimeException(\"Expected field size info\");\n+            }\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+                if (!line.contains(\"marked metadata pointer\")) {\n+                    if ((m = match(line, oopFieldPattern2)) != null) {\n+                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), m.group(4));\n+                    } else if ((m = match(line, oopFieldPattern1)) != null) {\n+                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), null);\n+                    } else if ((m = match(line, moduleEntryPattern)) != null) {\n+                        String value = m.group(1);\n+                        if (!value.equals(\"0\")) {\n+                            throw new RuntimeException(\"module_entry should be 0 but found: \" + line);\n+                        }\n+                    }\n+                }\n+            }\n+        } else if ((m = match(line, typeArrayKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(2));\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+            }\n+        } else if ((m = match(line, objArrayKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(3));\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+            }\n+        } else {\n+            throw new RuntimeException(\"Expected klass info\");\n+        }\n+    }\n+\n+    private static void parseClassObject(String className, String addr, String size) throws IOException {\n+        mapFile.addClass(className);\n+        nextLine();\n+    }\n+\n+    static MapFile mapFile;\n+    static BufferedReader reader;\n+    static String line = null; \/\/ current line being parsed\n+    static int lineCount = 0;\n+    static String nextLine()  throws IOException {\n+        line = reader.readLine();\n+        ++ lineCount;\n+        return line;\n+    }\n+\n+    public static MapFile read(String fileName) {\n+        mapFile = new MapFile();\n+        lineCount = 0;\n+\n+        try (BufferedReader r = new BufferedReader(new FileReader(fileName))) {\n+            reader = r;\n+            nextLine();\n+\n+            Matcher m;\n+            while (line != null) {\n+                if ((m = match(line, objPattern2)) != null) {\n+                    parseHeapObject(m.group(3), m.group(1), m.group(2));\n+                } else if ((m = match(line, objPattern1)) != null) {\n+                    parseHeapObject(m.group(2), m.group(1), null);\n+                } else if ((m = match(line, classPattern)) != null) {\n+                    parseClassObject(m.group(3), m.group(1), m.group(2)); \/\/ name, addr, size\n+                } else {\n+                    nextLine();\n+                }\n+            }\n+            return mapFile;\n+        } catch (Throwable t) {\n+            System.out.println(\"Error parsing line \" + lineCount + \": \" + line);\n+            throw new RuntimeException(t);\n+        } finally {\n+            System.out.println(\"Parsed \" + lineCount + \" lines in \" + fileName);\n+            System.out.println(\"Found \" + mapFile.heapObjectCount() + \" heap objects (\"\n+                               + mapFile.stringCount + \" strings)\");\n+            mapFile = null;\n+            reader = null;\n+            line = null;\n+            lineCount = 0;\n+        }\n+    }\n+\n+    private static void mustContain(HashMap<Long, HeapObject> allObjects, Field field, long pointer, boolean isNarrow) {\n+        if (allObjects.get(pointer) == null) {\n+            throw new RuntimeException((isNarrow ? \"narrowOop\" : \"oop\") + \" pointer 0x\" + Long.toHexString(pointer) +\n+                                       \" on line \" + field.lineCount + \" doesn't point to a valid heap object\");\n+        }\n+    }\n+\n+    public static void validate(MapFile mapFile, String classLoadLogFile) throws IOException {\n+        validateOops(mapFile);\n+        if (classLoadLogFile != null) {\n+            validateClasses(mapFile, classLoadLogFile);\n+        }\n+    }\n+\n+    \/\/ Check that each oop fields in the HeapObjects must point to a valid HeapObject.\n+    static void validateOops(MapFile mapFile) {\n+        int count1 = 0;\n+        int count2 = 0;\n+        for (HeapObject heapObject : mapFile.heapObjects) {\n+            if (heapObject.fields != null) {\n+                for (Field field : heapObject.fields) {\n+                    HeapAddress referentAddress = field.referentAddress;\n+                    long oop = referentAddress.oop;\n+                    long narrowOop = referentAddress.narrowOop;\n+                    \/\/ Is this test actually doing something?\n+                    \/\/     To see how an invalidate pointer may be found, change oop in the\n+                    \/\/     following line to oop+1\n+                    if (oop != 0) {\n+                        mustContain(mapFile.oopToObject, field, oop, false);\n+                        count1 ++;\n+                    }\n+                    if (narrowOop != 0) {\n+                        mustContain(mapFile.narrowOopToObject, field, narrowOop, true);\n+                        count2 ++;\n+                    }\n+                }\n+            }\n+        }\n+        System.out.println(\"Found \" + count1 + \" non-null oop field references (normal)\");\n+        System.out.println(\"Found \" + count2 + \" non-null oop field references (narrow)\");\n+\n+        if (mapFile.heapObjectCount() > 0) {\n+            \/\/ heapObjectCount() may be zero if the selected GC doesn't support heap object archiving.\n+            if (mapFile.stringCount <= 0) {\n+                throw new RuntimeException(\"AOT map file should contain at least one string\");\n+            }\n+            if (count1 < mapFile.stringCount) {\n+                throw new RuntimeException(\"AOT map file seems incorrect: \" + mapFile.heapObjectCount() +\n+                                           \" objects (\" + mapFile.stringCount + \" strings). Each string should\" +\n+                                           \" have one non-null oop field but we found only \" + count1 +\n+                                           \" non-null oop field references\");\n+            }\n+        }\n+    }\n+\n+    \/\/ classLoadLogFile should be generated with -Xlog:class+load:file=<classLoadLogFile>:none:filesize=0\n+    \/\/ Check that every class loaded from \"source: shared objects file\" have an entry inside the mapFile.\n+    static void validateClasses(MapFile mapFile, String classLoadLogFile) throws IOException {\n+        try (BufferedReader r = new BufferedReader(new FileReader(classLoadLogFile))) {\n+            String line;\n+            String suffix = \" source: shared objects file\";\n+            int suffixLen = suffix.length();\n+            while ((line = r.readLine()) != null) {\n+                if (line.endsWith(suffix)) {\n+                    String className = line.substring(0, line.length() - suffixLen);\n+                    if (!mapFile.hasClass(className)) {\n+                        throw new RuntimeException(\"AOT map file is missing class \" + className);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String args[]) throws IOException {\n+        MapFile mapFile = read(args[0]);\n+        validate(mapFile, null);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/AOTMapReader.java","additions":412,"deletions":0,"binary":false,"changes":412,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n- * @run driver\/timeout=240 CDSMapTest\n+ * @run driver\/timeout=240 AOTMapTest\n@@ -40,1 +40,1 @@\n-public class CDSMapTest {\n+public class AOTMapTest {\n@@ -82,2 +82,2 @@\n-        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapName);\n-        CDSMapReader.validate(mapFile);\n+        AOTMapReader.MapFile mapFile = AOTMapReader.read(mapName);\n+        AOTMapReader.validate(mapFile, null);\n@@ -101,2 +101,2 @@\n-        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapName);\n-        CDSMapReader.validate(mapFile);\n+        AOTMapReader.MapFile mapFile = AOTMapReader.read(mapName);\n+        AOTMapReader.validate(mapFile, null);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/AOTMapTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapTest.java","status":"renamed"},{"patch":"@@ -1,351 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/*\n-\n-This is a simple parser for parsing the output of\n-\n-   java -Xshare:dump -Xlog:aot+map=debug,aot+map+oops=trace:file=cds.map:none:filesize=0\n-\n-The map file contains patterns like this for the heap objects:\n-\n-======================================================================\n-0x00000000ffe00000: @@ Object (0xffe00000) java.lang.String \"\"\n- - klass: 'java\/lang\/String' 0x0000000800010220\n- - fields (3 words):\n- - private 'hash' 'I' @12  0 (0x00000000)\n- - private final 'coder' 'B' @16  0 (0x00)\n- - private 'hashIsZero' 'Z' @17  true (0x01)\n- - injected 'flags' 'B' @18  1 (0x01)\n- - private final 'value' '[B' @20 0x00000000ffe00018 (0xffe00018) [B length: 0\n-0x00000000ffe00018: @@ Object (0xffe00018) [B length: 0\n- - klass: {type array byte} 0x00000008000024d8\n-======================================================================\n-\n-Currently this parser just check the output related to JDK-8308903.\n-I.e., each oop field must point to a valid HeapObject. For example, the 'value' field\n-in the String must point to a valid byte array.\n-\n-This parser can be extended to check for the other parts of the map file, or perform\n-more analysis on the HeapObjects.\n-\n-*\/\n-\n-public class CDSMapReader {\n-    public static class MapFile {\n-        ArrayList<HeapObject> heapObjects = new ArrayList<>();\n-        HashMap<Long, HeapObject> oopToObject = new HashMap<>();\n-        HashMap<Long, HeapObject> narrowOopToObject = new HashMap<>();\n-        public int stringCount = 0;\n-\n-        void add(HeapObject heapObject) {\n-            heapObjects.add(heapObject);\n-            oopToObject.put(heapObject.address.oop, heapObject);\n-            if (heapObject.address.narrowOop != 0) {\n-                narrowOopToObject.put(heapObject.address.narrowOop, heapObject);\n-            }\n-            if (heapObject.className.equals(\"java.lang.String\")) {\n-                stringCount ++;\n-            }\n-        }\n-\n-        public int heapObjectCount() {\n-            return heapObjects.size();\n-        }\n-    }\n-\n-    public static class HeapAddress {\n-        long oop;\n-        long narrowOop;\n-\n-        HeapAddress(String oopStr, String narrowOopStr) {\n-            oop = Long.parseUnsignedLong(oopStr, 16);\n-            if (narrowOopStr != null) {\n-                narrowOop = Long.parseUnsignedLong(narrowOopStr, 16);\n-            }\n-        }\n-    }\n-\n-    public static class Klass {\n-        long address;\n-        String name;\n-\n-        static Klass getKlass(String name, String addr) {\n-            \/\/ TODO: look up from a table of known Klasses\n-            Klass k = new Klass();\n-            k.name = name;\n-            k.address =  Long.parseUnsignedLong(addr, 16);\n-            return k;\n-        }\n-    }\n-\n-    public static class HeapObject {\n-        HeapAddress address;\n-        ArrayList<Field> fields;\n-        String className;\n-        Klass klass;\n-\n-        HeapObject(String className, String oop, String narrowOop) {\n-            this.className = className;\n-            address = new HeapAddress(oop, narrowOop);\n-        }\n-\n-        void setKlass(String klassName, String address) {\n-            klass = Klass.getKlass(klassName, address);\n-        }\n-\n-        void addOopField(String name, String offset, String oopStr, String narrowOopStr) {\n-            if (fields == null) {\n-                fields = new ArrayList<Field>();\n-            }\n-            fields.add(new Field(name, offset, oopStr, narrowOopStr));\n-        }\n-    }\n-\n-    public static class Field {\n-        String name;\n-        int offset;\n-        HeapAddress referentAddress; \/\/ non-null iff this is an object field\n-        int lineCount;\n-\n-        Field(String name, String offset, String oopStr, String narrowOopStr) {\n-            this.name = name;\n-            this.offset = Integer.parseInt(offset);\n-            this.referentAddress = new HeapAddress(oopStr, narrowOopStr);\n-            this.lineCount = CDSMapReader.lineCount;\n-        }\n-    }\n-\n-    \/\/ 0x00000007ffc00000:   4a5b8701 00000063 00010290 00000000 00010100 fff80003\n-    static Pattern rawDataPattern = Pattern.compile(\"^0x([0-9a-f]+): *( [0-9a-f]+)+ *$\");\n-\n-    \/\/ (one address)\n-    \/\/ 0x00000007ffc00000: @@ Object java.lang.String\n-    static Pattern objPattern1 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object ([^ ]*)\");\n-\n-    \/\/ (two addresses)\n-    \/\/ 0x00000007ffc00000: @@ Object (0xfff80000) java.lang.String\n-    static Pattern objPattern2 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object [(]0x([0-9a-f]+)[)] ([^ ]*)\");\n-\n-    \/\/  - klass: 'java\/lang\/String' 0x0000000800010290\n-    static Pattern instanceObjKlassPattern = Pattern.compile(\"^ - klass: '([^']+)' 0x([0-9a-f]+)\");\n-\n-    \/\/  - klass: {type array byte} 0x00000008000024c8\n-    static Pattern typeArrayKlassPattern = Pattern.compile(\"^ - klass: [{]type array ([a-z]+)[}] 0x([0-9a-f]+)\");\n-\n-    \/\/  - klass: 'java\/lang\/Object'[] 0x00000008000013e0\n-    static Pattern objArrayKlassPattern = Pattern.compile(\"^ - klass: ('[^']+'(\\\\[\\\\])+) 0x([0-9a-f]+)\");\n-\n-    \/\/  - fields (3 words):\n-    static Pattern fieldsWordsPattern = Pattern.compile(\"^ - fields [(]([0-9]+) words[)]:$\");\n-\n-    \/\/ (one address)\n-    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 java.lang.String\n-    static Pattern oopFieldPattern1 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) (.*)\");\n-\n-    \/\/ (two addresses)\n-    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 (0xfff8d04c) java.lang.String\n-    static Pattern oopFieldPattern2 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) [(]0x([0-9a-f]+)[)] (.*)\");\n-\n-    \/\/ (injected module_entry)\n-    \/\/  - injected 'module_entry' 'J' @16 0 (0x0000000000000000)\n-    static Pattern moduleEntryPattern = Pattern.compile(\"- injected 'module_entry' 'J' @[0-9]+[ ]+([0-9]+)\");\n-\n-    private static Matcher match(String line, Pattern pattern) {\n-        Matcher m = pattern.matcher(line);\n-        if (m.find()) {\n-            return m;\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    private static void parseHeapObject(String className, String oop, String narrowOop) throws IOException {\n-        HeapObject heapObject = parseHeapObjectImpl(className, oop, narrowOop);\n-        mapFile.add(heapObject);\n-    }\n-\n-    private static HeapObject parseHeapObjectImpl(String className, String oop, String narrowOop) throws IOException {\n-        HeapObject heapObject = new HeapObject(className, oop, narrowOop);\n-        Matcher m;\n-\n-        nextLine();\n-        while (line != null && match(line, rawDataPattern) != null) { \/\/ skip raw data\n-            nextLine();\n-        }\n-\n-        if (line == null || !line.startsWith(\" - \")) {\n-            return heapObject;\n-        }\n-\n-        if ((m = match(line, instanceObjKlassPattern)) != null) {\n-            heapObject.setKlass(m.group(1), m.group(2));\n-            nextLine();\n-            if ((m = match(line, fieldsWordsPattern)) == null) {\n-                throw new RuntimeException(\"Expected field size info\");\n-            }\n-            while (true) {\n-                nextLine();\n-                if (line == null || !line.startsWith(\" - \")) {\n-                    return heapObject;\n-                }\n-                if (!line.contains(\"marked metadata pointer\")) {\n-                    if ((m = match(line, oopFieldPattern2)) != null) {\n-                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), m.group(4));\n-                    } else if ((m = match(line, oopFieldPattern1)) != null) {\n-                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), null);\n-                    } else if ((m = match(line, moduleEntryPattern)) != null) {\n-                        String value = m.group(1);\n-                        if (!value.equals(\"0\")) {\n-                            throw new RuntimeException(\"module_entry should be 0 but found: \" + line);\n-                        }\n-                    }\n-                }\n-            }\n-        } else if ((m = match(line, typeArrayKlassPattern)) != null) {\n-            heapObject.setKlass(m.group(1), m.group(2));\n-            \/\/ TODO: read all the array elements\n-            while (true) {\n-                nextLine();\n-                if (line == null || !line.startsWith(\" - \")) {\n-                    return heapObject;\n-                }\n-            }\n-        } else if ((m = match(line, objArrayKlassPattern)) != null) {\n-            heapObject.setKlass(m.group(1), m.group(3));\n-            \/\/ TODO: read all the array elements\n-            while (true) {\n-                nextLine();\n-                if (line == null || !line.startsWith(\" - \")) {\n-                    return heapObject;\n-                }\n-            }\n-        } else {\n-            throw new RuntimeException(\"Expected klass info\");\n-        }\n-    }\n-\n-    static MapFile mapFile;\n-    static BufferedReader reader;\n-    static String line = null; \/\/ current line being parsed\n-    static int lineCount = 0;\n-    static String nextLine()  throws IOException {\n-        line = reader.readLine();\n-        ++ lineCount;\n-        return line;\n-    }\n-\n-    public static MapFile read(String fileName) {\n-        mapFile = new MapFile();\n-        lineCount = 0;\n-\n-        try (BufferedReader r = new BufferedReader(new FileReader(fileName))) {\n-            reader = r;\n-            nextLine();\n-\n-            Matcher m;\n-            while (line != null) {\n-                if ((m = match(line, objPattern2)) != null) {\n-                    parseHeapObject(m.group(3), m.group(1), m.group(2));\n-                } else if ((m = match(line, objPattern1)) != null) {\n-                    parseHeapObject(m.group(2), m.group(1), null);\n-                } else {\n-                    nextLine();\n-                }\n-            }\n-            return mapFile;\n-        } catch (Throwable t) {\n-            System.out.println(\"Error parsing line \" + lineCount + \": \" + line);\n-            throw new RuntimeException(t);\n-        } finally {\n-            System.out.println(\"Parsed \" + lineCount + \" lines in \" + fileName);\n-            System.out.println(\"Found \" + mapFile.heapObjectCount() + \" heap objects (\"\n-                               + mapFile.stringCount + \" strings)\");\n-            mapFile = null;\n-            reader = null;\n-            line = null;\n-            lineCount = 0;\n-        }\n-    }\n-\n-    private static void mustContain(HashMap<Long, HeapObject> allObjects, Field field, long pointer, boolean isNarrow) {\n-        if (allObjects.get(pointer) == null) {\n-            throw new RuntimeException((isNarrow ? \"narrowOop\" : \"oop\") + \" pointer 0x\" + Long.toHexString(pointer) +\n-                                       \" on line \" + field.lineCount + \" doesn't point to a valid heap object\");\n-        }\n-    }\n-\n-    \/\/ Check that each oop fields in the HeapObjects must point to a valid HeapObject.\n-    public static void validate(MapFile mapFile) {\n-        int count1 = 0;\n-        int count2 = 0;\n-        for (HeapObject heapObject : mapFile.heapObjects) {\n-            if (heapObject.fields != null) {\n-                for (Field field : heapObject.fields) {\n-                    HeapAddress referentAddress = field.referentAddress;\n-                    long oop = referentAddress.oop;\n-                    long narrowOop = referentAddress.narrowOop;\n-                    \/\/ Is this test actually doing something?\n-                    \/\/     To see how an invalidate pointer may be found, change oop in the\n-                    \/\/     following line to oop+1\n-                    if (oop != 0) {\n-                        mustContain(mapFile.oopToObject, field, oop, false);\n-                        count1 ++;\n-                    }\n-                    if (narrowOop != 0) {\n-                        mustContain(mapFile.narrowOopToObject, field, narrowOop, true);\n-                        count2 ++;\n-                    }\n-                }\n-            }\n-        }\n-        System.out.println(\"Found \" + count1 + \" non-null oop field references (normal)\");\n-        System.out.println(\"Found \" + count2 + \" non-null oop field references (narrow)\");\n-\n-        if (mapFile.heapObjectCount() > 0) {\n-            \/\/ heapObjectCount() may be zero if the selected GC doesn't support heap object archiving.\n-            if (mapFile.stringCount <= 0) {\n-                throw new RuntimeException(\"CDS map file should contain at least one string\");\n-            }\n-            if (count1 < mapFile.stringCount) {\n-                throw new RuntimeException(\"CDS map file seems incorrect: \" + mapFile.heapObjectCount() +\n-                                           \" objects (\" + mapFile.stringCount + \" strings). Each string should\" +\n-                                           \" have one non-null oop field but we found only \" + count1 +\n-                                           \" non-null oop field references\");\n-            }\n-        }\n-    }\n-\n-    public static void main(String args[]) {\n-        MapFile mapFile = read(args[0]);\n-        validate(mapFile);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapReader.java","additions":0,"deletions":351,"binary":false,"changes":351,"status":"deleted"},{"patch":"@@ -29,2 +29,2 @@\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\n- * @build AOTMapTest\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build AOTMapTest Hello\n@@ -32,0 +32,1 @@\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar cust.jar Hello\n@@ -40,1 +41,1 @@\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n@@ -43,1 +44,1 @@\n- * @build AOTMapTest\n+ * @build AOTMapTest Hello\n@@ -45,0 +46,1 @@\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar cust.jar Hello\n@@ -48,1 +50,3 @@\n-\n+import java.io.File;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n@@ -57,0 +61,1 @@\n+    static final String classLoadLogFile = \"production.class.load.log\";\n@@ -66,2 +71,8 @@\n-        validate(tester.dumpMapFile);\n-        validate(tester.runMapFile);\n+        if (tester.isDynamicWorkflow()) {\n+            \/\/ For dynamic workflow, the AOT map file doesn't include classes in the base archive, so\n+            \/\/ AOTMapReader.validateClasses() will fail.\n+            validate(tester.dumpMapFile, false);\n+        } else {\n+            validate(tester.dumpMapFile, true);\n+        }\n+        validate(tester.runMapFile, true);\n@@ -70,3 +81,9 @@\n-    static void validate(String mapFileName) {\n-        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapFileName);\n-        CDSMapReader.validate(mapFile);\n+    static void validate(String mapFileName, boolean checkClases) throws Exception {\n+        AOTMapReader.MapFile mapFile = AOTMapReader.read(mapFileName);\n+        if (checkClases) {\n+            AOTMapReader.validate(mapFile, classLoadLogFile);\n+        } else {\n+            AOTMapReader.validate(mapFile, null);\n+        }\n+        mapFile.shouldHaveClass(\"AOTMapTestApp\"); \/\/ built-in class\n+        mapFile.shouldHaveClass(\"Hello\"); \/\/ unregistered class\n@@ -100,1 +117,1 @@\n-            String logMapSuffix = \":none:filesize=0\";\n+            String logSuffix = \":none:filesize=0\";\n@@ -103,1 +120,1 @@\n-                vmArgs.add(logMapPrefix + dumpMapFile + logMapSuffix);\n+                vmArgs.add(logMapPrefix + dumpMapFile + logSuffix);\n@@ -105,1 +122,2 @@\n-                vmArgs.add(logMapPrefix + runMapFile + logMapSuffix);\n+                vmArgs.add(logMapPrefix + runMapFile + logSuffix);\n+                vmArgs.add(\"-Xlog:class+load:file=\" + classLoadLogFile + logSuffix);\n@@ -121,1 +139,1 @@\n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws Exception {\n@@ -123,0 +141,9 @@\n+        testCustomLoader();\n+    }\n+\n+    static void testCustomLoader() throws Exception {\n+        File custJar = new File(\"cust.jar\");\n+        URL[] urls = new URL[] {custJar.toURI().toURL()};\n+        URLClassLoader loader = new URLClassLoader(urls, AOTMapTestApp.class.getClassLoader());\n+        Class<?> c = loader.loadClass(\"Hello\");\n+        System.out.println(c);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/AOTMapTest.java","additions":41,"deletions":14,"binary":false,"changes":55,"status":"modified"}]}