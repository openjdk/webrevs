{"files":[{"patch":"@@ -6176,0 +6176,1 @@\n+\n@@ -6182,0 +6183,1 @@\n+  ins_cost(500);\n@@ -6198,0 +6200,1 @@\n+  ins_cost(500);\n@@ -6209,0 +6212,1 @@\n+  ins_cost(500);\n@@ -6235,0 +6239,1 @@\n+  ins_cost(500);\n@@ -6251,0 +6256,24 @@\n+instruct vmuludq_reg(vec dst, vec src1, vec src2) %{\n+  predicate(UseAVX > 0 && n->as_MulVL()->has_uint_inputs());\n+  match(Set dst (MulVL src1 src2));\n+  ins_cost(100);\n+  format %{ \"vpmuludq $dst,$src1,$src2\\t! muludq packedL\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpmuludq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmuldq_reg(vec dst, vec src1, vec src2) %{\n+  predicate(UseAVX > 0 && n->as_MulVL()->has_int_inputs());\n+  match(Set dst (MulVL src1 src2));\n+  ins_cost(100);\n+  format %{ \"vpmuldq $dst,$src1,$src2\\t! muldq packedL\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpmuldq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -196,0 +196,1 @@\n+class MulVLNode;\n@@ -746,0 +747,1 @@\n+        DEFINE_CLASS_ID(MulVL, Vector, 10)\n@@ -973,0 +975,1 @@\n+  DEFINE_CLASS_QUERY(MulVL)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2088,0 +2088,50 @@\n+static bool is_replicate_uint_constant(const Node* n) {\n+  return n->Opcode() == Op_Replicate &&\n+         n->in(1)->is_Con() &&\n+         n->in(1)->bottom_type()->isa_long() &&\n+         n->in(1)->bottom_type()->is_long()->get_con() <= 4294967295L;\n+}\n+\n+static bool is_lower_doubleword_mask_pattern(const Node* n) {\n+  return n->Opcode() == Op_AndV &&\n+         (is_replicate_uint_constant(n->in(1)) ||\n+          is_replicate_uint_constant(n->in(2)));\n+}\n+\n+static bool is_clear_upper_doubleword_uright_shift_pattern(const Node* n) {\n+  return n->Opcode() == Op_URShiftVL &&\n+         n->in(2)->Opcode() == Op_RShiftCntV && n->in(2)->in(1)->is_Con() &&\n+         n->in(2)->in(1)->bottom_type()->isa_int() &&\n+         n->in(2)->in(1)->bottom_type()->is_int()->get_con() >= 32;\n+}\n+\n+static bool has_vector_elements_fit_uint(Node* n) {\n+  return is_lower_doubleword_mask_pattern(n) ||             \/\/ (AndV     SRC (Replicate C)) where C <= 0xFFFFFFFF\n+         is_clear_upper_doubleword_uright_shift_pattern(n); \/\/ (URShiftV SRC S) where S >= 32\n+}\n+\n+static bool has_vector_elements_fit_int(Node* n) {\n+  auto is_cast_integer_to_long_pattern = [](const Node* n) {\n+    return n->Opcode() == Op_VectorCastI2X && Matcher::vector_element_basic_type(n) == T_LONG;\n+  };\n+\n+  auto is_clear_upper_doubleword_right_shift_pattern = [](const Node* n) {\n+    return n->Opcode() == Op_RShiftVL &&\n+           n->in(2)->Opcode() == Op_RShiftCntV && n->in(2)->in(1)->is_Con() &&\n+           n->in(2)->in(1)->bottom_type()->isa_int() &&\n+           n->in(2)->in(1)->bottom_type()->is_int()->get_con() >= 32;\n+  };\n+\n+  return is_cast_integer_to_long_pattern(n) ||             \/\/ (VectorCastI2X SRC)\n+         is_clear_upper_doubleword_right_shift_pattern(n); \/\/ (RShiftV SRC S) where S >= 32\n+}\n+\n+bool MulVLNode::has_int_inputs() const {\n+  return has_vector_elements_fit_int(in(1)) &&\n+         has_vector_elements_fit_int(in(2));\n+}\n+\n+bool MulVLNode::has_uint_inputs() const {\n+  return has_vector_elements_fit_uint(in(1)) &&\n+         has_vector_elements_fit_uint(in(2));\n+}\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -444,1 +444,3 @@\n-  MulVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  MulVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    init_class_id(Class_MulVL);\n+  }\n@@ -446,0 +448,2 @@\n+  bool has_int_inputs() const;\n+  bool has_uint_inputs() const;\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.*;\n+import java.util.Random;\n+import java.util.stream.IntStream;\n+import compiler.lib.ir_framework.*;\n+import java.lang.reflect.Array;\n+\n+\/**\n+ * @test\n+ * @bug 8341137\n+ * @key randomness\n+ * @summary Optimize long vector multiplication using x86 VPMUL[U]DQ instruction.\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.VectorMultiplyOpt\n+ *\/\n+\n+public class VectorMultiplyOpt {\n+\n+    public static int[] isrc1;\n+    public static int[] isrc2;\n+    public static long[] lsrc1;\n+    public static long[] lsrc2;\n+    public static long[] res;\n+\n+    public static final int SIZE = 1024;\n+    public static final Random r = new Random(1024);\n+    public static final VectorSpecies<Long> LSP = LongVector.SPECIES_PREFERRED;\n+    public static final VectorSpecies<Integer> ISP = IntVector.SPECIES_PREFERRED;\n+\n+    public VectorMultiplyOpt() {\n+        lsrc1 = new long[SIZE];\n+        lsrc2 = new long[SIZE];\n+        res  = new long[SIZE];\n+        isrc1 = new int[SIZE + 16];\n+        isrc2 = new int[SIZE + 16];\n+        IntStream.range(0, SIZE).forEach(i -> { lsrc1[i] = Long.MAX_VALUE * r.nextLong(); });\n+        IntStream.range(0, SIZE).forEach(i -> { lsrc2[i] = Long.MAX_VALUE * r.nextLong(); });\n+        IntStream.range(0, SIZE).forEach(i -> { isrc1[i] = Integer.MAX_VALUE * r.nextInt(); });\n+        IntStream.range(0, SIZE).forEach(i -> { isrc2[i] = Integer.MAX_VALUE * r.nextInt(); });\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+        System.out.println(\"PASSED\");\n+    }\n+\n+    interface Validator {\n+        public long apply(long src1, long src2);\n+    }\n+\n+    public static void validate(String msg, long[] actual, Object src1, Object src2, Validator func) {\n+        for (int i = 0; i < actual.length; i++) {\n+            long expected;\n+            if (long[].class == src1.getClass()) {\n+                expected = func.apply(Array.getLong(src1, i), Array.getLong(src2, i));\n+            } else {\n+                assert int[].class == src1.getClass();\n+                expected = func.apply(Array.getInt(src1, i), Array.getInt(src2, i));\n+            }\n+            if (actual[i] != expected) {\n+                throw new AssertionError(msg + \"index \" + i + \": src1 = \" + Array.get(src1, i) + \" src2 = \" +\n+                                         Array.get(src2, i) + \" actual = \" + actual[i] + \" expected = \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_VL, \" >0 \", IRNode.AND_VL, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public static void test_pattern1() {\n+        int i = 0;\n+        for (; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = LongVector.fromArray(LSP, lsrc1, i);\n+            LongVector vsrc2 = LongVector.fromArray(LSP, lsrc2, i);\n+            vsrc1.lanewise(VectorOperators.AND, 0xFFFFFFFFL)\n+                 .lanewise(VectorOperators.MUL, vsrc2.lanewise(VectorOperators.AND, 0xFFFFFFFFL))\n+                 .intoArray(res, i);\n+        }\n+        for (; i < res.length; i++) {\n+            res[i] = (lsrc1[i] & 0xFFFFFFFFL) * (lsrc2[i] & 0xFFFFFFFFL);\n+        }\n+    }\n+\n+    @Check(test = \"test_pattern1\")\n+    public void test_pattern1_validate() {\n+        validate(\"pattern1 \", res, lsrc1, lsrc2, (l1, l2) -> (l1 & 0xFFFFFFFFL) * (l2 & 0xFFFFFFFFL));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_VL, \" >0 \", IRNode.AND_VL, \" >0 \", IRNode.URSHIFT_VL, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public static void test_pattern2() {\n+        int i = 0;\n+        for (; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = LongVector.fromArray(LSP, lsrc1, i);\n+            LongVector vsrc2 = LongVector.fromArray(LSP, lsrc2, i);\n+            vsrc1.lanewise(VectorOperators.AND, 0xFFFFFFFFL)\n+                .lanewise(VectorOperators.MUL, vsrc2.lanewise(VectorOperators.LSHR, 32))\n+                .intoArray(res, i);\n+        }\n+        for (; i < res.length; i++) {\n+            res[i] = (lsrc1[i] & 0xFFFFFFFFL) * (lsrc2[i] >>> 32);\n+        }\n+    }\n+\n+    @Check(test = \"test_pattern2\")\n+    public void test_pattern2_validate() {\n+        validate(\"pattern2 \", res, lsrc1, lsrc2, (l1, l2) -> (l1 & 0xFFFFFFFFL) * (l2 >>> 32));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_VL, \" >0 \", IRNode.URSHIFT_VL, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public static void test_pattern3() {\n+        int i = 0;\n+        for (; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = LongVector.fromArray(LSP, lsrc1, i);\n+            LongVector vsrc2 = LongVector.fromArray(LSP, lsrc2, i);\n+            vsrc1.lanewise(VectorOperators.LSHR, 32)\n+                .lanewise(VectorOperators.MUL, vsrc2.lanewise(VectorOperators.LSHR, 32))\n+                .intoArray(res, i);\n+        }\n+        for (; i < res.length; i++) {\n+            res[i] = (lsrc1[i] >>> 32) * (lsrc2[i] >>> 32);\n+        }\n+    }\n+\n+    @Check(test = \"test_pattern3\")\n+    public void test_pattern3_validate() {\n+        validate(\"pattern3 \", res, lsrc1, lsrc2, (l1, l2) -> (l1 >>> 32) * (l2 >>> 32));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_VL, \" >0 \", IRNode.URSHIFT_VL, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public static void test_pattern4() {\n+        int i = 0;\n+        for (; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = LongVector.fromArray(LSP, lsrc1, i);\n+            LongVector vsrc2 = LongVector.fromArray(LSP, lsrc2, i);\n+            vsrc1.lanewise(VectorOperators.LSHR, 32)\n+                .lanewise(VectorOperators.MUL, vsrc2.lanewise(VectorOperators.AND, 0xFFFFFFFFL))\n+                .intoArray(res, i);\n+        }\n+        for (; i < res.length; i++) {\n+            res[i] = (lsrc1[i] >>> 32) * (lsrc2[i] & 0xFFFFFFFFL);\n+        }\n+    }\n+\n+    @Check(test = \"test_pattern4\")\n+    public void test_pattern4_validate() {\n+        validate(\"pattern4 \", res, lsrc1, lsrc2, (l1, l2) -> (l1 >>> 32) * (l2 & 0xFFFFFFFFL));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_VL, \" >0 \", IRNode.VECTOR_CAST_I2L, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public static void test_pattern5() {\n+        int i = 0;\n+        for (; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = IntVector.fromArray(ISP, isrc1, i)\n+                                        .convert(VectorOperators.I2L, 0)\n+                                        .reinterpretAsLongs();\n+            LongVector vsrc2 = IntVector.fromArray(ISP, isrc2, i)\n+                                        .convert(VectorOperators.I2L, 0)\n+                                        .reinterpretAsLongs();\n+            vsrc1.lanewise(VectorOperators.MUL, vsrc2).intoArray(res, i);\n+        }\n+        for (; i < res.length; i++) {\n+            res[i] = Math.multiplyFull(isrc1[i], isrc2[i]);\n+        }\n+    }\n+\n+    @Check(test = \"test_pattern5\")\n+    public void test_pattern5_validate() {\n+        validate(\"pattern5 \", res, isrc1, isrc2, (i1, i2) -> Math.multiplyFull((int)i1, (int)i2));\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_VL, \" >0 \", IRNode.RSHIFT_VL, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public static void test_pattern6() {\n+        int i = 0;\n+        for (; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = LongVector.fromArray(LSP, lsrc1, i);\n+            LongVector vsrc2 = LongVector.fromArray(LSP, lsrc2, i);\n+            vsrc1.lanewise(VectorOperators.ASHR, 32)\n+                .lanewise(VectorOperators.MUL, vsrc2.lanewise(VectorOperators.ASHR, 32))\n+                .intoArray(res, i);\n+        }\n+        for (; i < res.length; i++) {\n+            res[i] = (lsrc1[i] >> 32) * (lsrc2[i] >> 32);\n+        }\n+    }\n+\n+    @Check(test = \"test_pattern6\")\n+    public void test_pattern6_validate() {\n+        validate(\"pattern6 \", res, lsrc1, lsrc2, (l1, l2) -> (l1 >> 32) * (l2 >> 32));\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMultiplyOpt.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import jdk.incubator.vector.*;\n+import java.util.stream.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorMultiplyOptBenchmark {\n+    @Param({\"1024\", \"2048\", \"4096\"})\n+    private int  SIZE;\n+    private int  [] isrc1;\n+    private int  [] isrc2;\n+    private long [] lsrc1;\n+    private long [] lsrc2;\n+    private long [] res;\n+\n+    private static final VectorSpecies<Long> LSP = LongVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> ISP = IntVector.SPECIES_PREFERRED;\n+\n+    @Setup(Level.Trial)\n+    public void Setup() {\n+        lsrc1 = LongStream.range(Long.MAX_VALUE - SIZE, Long.MAX_VALUE).toArray();\n+        lsrc2 = LongStream.range(0, SIZE).toArray();\n+        isrc1 = IntStream.range(Integer.MAX_VALUE - 2 * SIZE, Integer.MAX_VALUE).toArray();\n+        isrc2 = IntStream.range(0, 2 * SIZE).toArray();\n+        res = new long[SIZE];\n+    }\n+\n+    @Benchmark\n+    public void test_bm_pattern1() {\n+        for (int i = 0; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = LongVector.fromArray(LSP, lsrc1, i);\n+            LongVector vsrc2 = LongVector.fromArray(LSP, lsrc2, i);\n+            vsrc1.lanewise(VectorOperators.AND, 0xFFFFFFFFL)\n+                 .lanewise(VectorOperators.MUL, vsrc2.lanewise(VectorOperators.AND, 0xFFFFFFFFL))\n+                 .intoArray(res, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test_bm_pattern2() {\n+        for (int i = 0; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = LongVector.fromArray(LSP, lsrc1, i);\n+            LongVector vsrc2 = LongVector.fromArray(LSP, lsrc2, i);\n+            vsrc1.lanewise(VectorOperators.AND, 0xFFFFFFFFL)\n+                .lanewise(VectorOperators.MUL, vsrc2.lanewise(VectorOperators.LSHR, 32))\n+                .intoArray(res, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test_bm_pattern3() {\n+        for (int i = 0; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = LongVector.fromArray(LSP, lsrc1, i);\n+            LongVector vsrc2 = LongVector.fromArray(LSP, lsrc2, i);\n+            vsrc1.lanewise(VectorOperators.LSHR, 32)\n+                .lanewise(VectorOperators.MUL, vsrc2.lanewise(VectorOperators.LSHR, 32))\n+                .intoArray(res, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test_bm_pattern4() {\n+        for (int i = 0; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = LongVector.fromArray(LSP, lsrc1, i);\n+            LongVector vsrc2 = LongVector.fromArray(LSP, lsrc2, i);\n+            vsrc1.lanewise(VectorOperators.LSHR, 32)\n+                .lanewise(VectorOperators.MUL, vsrc2.lanewise(VectorOperators.AND, 0xFFFFFFFFL))\n+                .intoArray(res, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test_bm_pattern5() {\n+        for (int i = 0; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = IntVector.fromArray(ISP, isrc1, i)\n+                                        .convert(VectorOperators.I2L, 0)\n+                                        .reinterpretAsLongs();\n+            LongVector vsrc2 = IntVector.fromArray(ISP, isrc2, i)\n+                                        .convert(VectorOperators.I2L, 0)\n+                                        .reinterpretAsLongs();\n+            vsrc1.lanewise(VectorOperators.MUL, vsrc2).intoArray(res, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test_bm_pattern6() {\n+        for (int i = 0; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = LongVector.fromArray(LSP, lsrc1, i);\n+            LongVector vsrc2 = LongVector.fromArray(LSP, lsrc2, i);\n+            vsrc1.lanewise(VectorOperators.ASHR, 32)\n+                .lanewise(VectorOperators.MUL, vsrc2.lanewise(VectorOperators.ASHR, 32))\n+                .intoArray(res, i);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorMultiplyOptBenchmark.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import jdk.incubator.vector.*;\n+import java.util.stream.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorXXH3HashingBenchmark {\n+    @Param({\"1024\", \"2048\", \"4096\", \"8192\"})\n+    private int  SIZE;\n+    private long [] accumulators;\n+    private byte [] input;\n+    private byte [] SECRET;\n+\n+    private static final VectorShuffle<Long> LONG_SHUFFLE_PREFERRED = VectorShuffle.fromOp(LongVector.SPECIES_PREFERRED, i -> i ^ 1);\n+\n+    @Setup(Level.Trial)\n+    public void Setup() {\n+        accumulators = new long[SIZE];\n+        input = new byte[SIZE * 8];\n+        SECRET = new byte[SIZE*8];\n+        IntStream.range(0, SIZE*8).forEach(\n+            i -> {\n+                     input[i] = (byte)i;\n+                     SECRET[i] = (byte)-i;\n+                 }\n+        );\n+    }\n+\n+    @Benchmark\n+    public void hashingKernel() {\n+        for (int block = 0; block < input.length \/ 1024; block++) {\n+            for (int stripe = 0; stripe < 16; stripe++) {\n+                int inputOffset = block * 1024 + stripe * 64;\n+                int secretOffset = stripe * 8;\n+\n+                for (int i = 0; i < 8; i += LongVector.SPECIES_PREFERRED.length()) {\n+                    LongVector accumulatorsVector = LongVector.fromArray(LongVector.SPECIES_PREFERRED, accumulators, i);\n+                    LongVector inputVector = ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, input, inputOffset + i * 8).reinterpretAsLongs();\n+                    LongVector secretVector = ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, SECRET, secretOffset + i * 8).reinterpretAsLongs();\n+\n+                    LongVector key = inputVector\n+                            .lanewise(VectorOperators.XOR, secretVector)\n+                            .reinterpretAsLongs();\n+\n+                    LongVector low = key.and(0xFFFF_FFFFL);\n+                    LongVector high = key.lanewise(VectorOperators.LSHR, 32);\n+\n+                    accumulatorsVector\n+                            .add(inputVector.rearrange(LONG_SHUFFLE_PREFERRED))\n+                            .add(high.mul(low))\n+                            .intoArray(accumulators, i);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorXXH3HashingBenchmark.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}