{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,0 +156,5 @@\n+  \/\/ Does the CPU supports doubleword multiplication with quadword saturation.\n+  static constexpr bool supports_double_word_mult_with_quadword_staturation(void) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,0 +149,5 @@\n+  \/\/ Does the CPU supports doubleword multiplication with quadword saturation.\n+  static constexpr bool supports_double_word_mult_with_quadword_staturation(void) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,0 +156,5 @@\n+  \/\/ Does the CPU supports doubleword multiplication with quadword saturation.\n+  static constexpr bool supports_double_word_mult_with_quadword_staturation(void) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,0 +155,5 @@\n+  \/\/ Does the CPU supports doubleword multiplication with quadword saturation.\n+  static constexpr bool supports_double_word_mult_with_quadword_staturation(void) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -152,0 +152,5 @@\n+  \/\/ Does the CPU supports doubleword multiplication with quadword saturation.\n+  static constexpr bool supports_double_word_mult_with_quadword_staturation(void) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,0 +182,5 @@\n+  \/\/ Does the CPU supports doubleword multiplication with quadword saturation.\n+  static constexpr bool supports_double_word_mult_with_quadword_staturation(void) {\n+    return true;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -6135,0 +6135,1 @@\n+\n@@ -6137,1 +6138,2 @@\n-  predicate((Matcher::vector_length_in_bytes(n) == 64 &&\n+  predicate(!n->as_MulVL()->is_mult_lower_double_word() &&\n+            ((Matcher::vector_length_in_bytes(n) == 64 &&\n@@ -6139,1 +6141,1 @@\n-            VM_Version::supports_avx512vldq());\n+            VM_Version::supports_avx512vldq()));\n@@ -6151,1 +6153,2 @@\n-  predicate((Matcher::vector_length_in_bytes(n) == 64 &&\n+  predicate(!n->as_MulVL()->is_mult_lower_double_word() &&\n+            ((Matcher::vector_length_in_bytes(n) == 64 &&\n@@ -6154,1 +6157,1 @@\n-             VM_Version::supports_avx512vldq()));\n+             VM_Version::supports_avx512vldq())));\n@@ -6166,1 +6169,1 @@\n-  predicate(UseAVX == 0);\n+  predicate(UseAVX == 0 && !n->as_MulVL()->is_mult_lower_double_word());\n@@ -6188,0 +6191,1 @@\n+            !n->as_MulVL()->is_mult_lower_double_word() &&\n@@ -6210,0 +6214,12 @@\n+instruct vmuludq_reg(vec dst, vec src1, vec src2) %{\n+  predicate(UseAVX > 0 && n->as_MulVL()->is_mult_lower_double_word());\n+  match(Set dst (MulVL src1 src2));\n+  ins_cost(100);\n+  format %{ \"vpmuludq $dst,$src1,$src2\\t! muldq packedL\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpmuludq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -194,0 +194,1 @@\n+class MulVLNode;\n@@ -743,0 +744,1 @@\n+        DEFINE_CLASS_ID(MulVL, Vector, 9)\n@@ -969,0 +971,1 @@\n+  DEFINE_CLASS_QUERY(MulVL)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2086,0 +2086,51 @@\n+Node* MulVLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (Matcher::supports_double_word_mult_with_quadword_staturation() &&\n+      !is_mult_lower_double_word()) {\n+    auto is_clear_upper_double_word_uright_shift_op = [](const Node *n) {\n+      return n->Opcode() == Op_URShiftVL &&\n+             n->in(2)->Opcode() == Op_RShiftCntV && n->in(2)->in(1)->is_Con() &&\n+             n->in(2)->in(1)->bottom_type()->isa_int() &&\n+             n->in(2)->in(1)->bottom_type()->is_int()->get_con() == 32L;\n+    };\n+\n+    auto is_lower_double_word_and_mask_op = [](const Node *n) {\n+      if (n->Opcode() == Op_AndV) {\n+        Node *replicate_operand = n->in(1)->Opcode() == Op_Replicate ? n->in(1)\n+                                  : n->in(2)->Opcode() == Op_Replicate\n+                                      ? n->in(2)\n+                                      : nullptr;\n+        if (replicate_operand) {\n+          return replicate_operand->in(1)->is_Con() &&\n+                 replicate_operand->in(1)->bottom_type()->isa_long() &&\n+                 replicate_operand->in(1)\n+                         ->bottom_type()\n+                         ->is_long()\n+                         ->get_con() == 4294967295L;\n+        } else {\n+          return false; \/\/ Replication match failed\n+        }\n+      } else {\n+        return false; \/\/ AndV match failed\n+      }\n+    };\n+\n+    \/\/ Detect following IR pattern for doubleword multiplication with quadword\n+    \/\/ satuation.\n+    \/\/ MulL ( And  SRC1,  0xFFFFFFFF)   ( And  SRC2,  0xFFFFFFFF)\n+    \/\/ MulL (URShift SRC1 , 32) (URShift SRC2, 32)\n+    \/\/ MulL (URShift SRC1 , 32)  ( And  SRC2,  0xFFFFFFFF)\n+    \/\/ MulL ( And  SRC1,  0xFFFFFFFF) (URShift SRC2 , 32)\n+    if ((is_lower_double_word_and_mask_op(in(1)) ||\n+         is_lower_double_word_and_mask_op(in(1)) ||\n+         is_clear_upper_double_word_uright_shift_op(in(1)) ||\n+         is_clear_upper_double_word_uright_shift_op(in(1)))\n+      && (is_clear_upper_double_word_uright_shift_op(in(2)) ||\n+          is_clear_upper_double_word_uright_shift_op(in(2)) ||\n+          is_lower_double_word_and_mask_op(in(2)) ||\n+          is_lower_double_word_and_mask_op(in(2)))) {\n+        return new MulVLNode(in(1), in(2), vect_type(), true);\n+      }\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -401,0 +401,3 @@\n+  \/\/ Only multiply lower doubleword with quadword saturation.\n+  const bool _mult_lower_double_word;\n+\n@@ -402,1 +405,5 @@\n-  MulVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  MulVLNode(Node* in1, Node* in2, const TypeVect* vt, bool mult_lower_double_word = false)\n+    : VectorNode(in1, in2, vt), _mult_lower_double_word(mult_lower_double_word) {\n+    init_class_id(Class_MulVL);\n+  }\n+\n@@ -404,0 +411,5 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+\n+  bool is_mult_lower_double_word() { return _mult_lower_double_word; }\n+  virtual uint size_of() const { return sizeof(*this); }\n+  virtual uint hash() const { return Node::hash() + _mult_lower_double_word; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.*;\n+import java.util.Random;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * @test\n+ * @bug 8341137\n+ * @key randomness\n+ * @requires vm.cpu.features ~= \".*avx.*\"\n+ * @summary Optimize long vector multiplication using x86 VPMULUDQ instruction.\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorMultiplyOpt\n+ *\/\n+\n+public class VectorMultiplyOpt {\n+\n+    public static long [] src1;\n+    public static long [] src2;\n+    public static long [] res;\n+\n+    public static final int SIZE = 4095;\n+    public static final Random r = new Random(1024);\n+    public static final VectorSpecies<Long> LSP = LongVector.SPECIES_PREFERRED;\n+\n+    public static void pattern1(long [] res, long [] src1, long [] src2) {\n+        int i = 0;\n+        for (; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = LongVector.fromArray(LSP, src1, i);\n+            LongVector vsrc2 = LongVector.fromArray(LSP, src2, i);\n+            vsrc1.lanewise(VectorOperators.AND, 0xFFFFFFFFL)\n+                .lanewise(VectorOperators.MUL, vsrc2.lanewise(VectorOperators.AND, 0xFFFFFFFFL))\n+                .intoArray(res, i);\n+        }\n+        for (; i < res.length; i++) {\n+            res[i] = (src1[i] & 0xFFFFFFFFL) * (src2[i] & 0xFFFFFFFFL);\n+        }\n+    }\n+\n+    public static void pattern2(long [] res, long [] src1, long [] src2) {\n+        int i = 0;\n+        for (; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = LongVector.fromArray(LSP, src1, i);\n+            LongVector vsrc2 = LongVector.fromArray(LSP, src2, i);\n+            vsrc1.lanewise(VectorOperators.AND, 0xFFFFFFFFL)\n+                .lanewise(VectorOperators.MUL, vsrc2.lanewise(VectorOperators.LSHR, 32))\n+                .intoArray(res, i);\n+        }\n+        for (; i < res.length; i++) {\n+            res[i] = (src1[i] & 0xFFFFFFFFL) * (src2[i] >>> 32);\n+        }\n+    }\n+\n+    public static void pattern3(long [] res, long [] src1, long [] src2) {\n+        int i = 0;\n+        for (; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = LongVector.fromArray(LSP, src1, i);\n+            LongVector vsrc2 = LongVector.fromArray(LSP, src2, i);\n+            vsrc1.lanewise(VectorOperators.LSHR, 32)\n+                .lanewise(VectorOperators.MUL, vsrc2.lanewise(VectorOperators.LSHR, 32))\n+                .intoArray(res, i);\n+        }\n+        for (; i < res.length; i++) {\n+            res[i] = (src1[i] >>> 32) * (src2[i] >>> 32);\n+        }\n+    }\n+\n+    public static void pattern4(long [] res, long [] src1, long [] src2) {\n+        int i = 0;\n+        for (; i < LSP.loopBound(res.length); i += LSP.length()) {\n+            LongVector vsrc1 = LongVector.fromArray(LSP, src1, i);\n+            LongVector vsrc2 = LongVector.fromArray(LSP, src2, i);\n+            vsrc1.lanewise(VectorOperators.LSHR, 32)\n+                .lanewise(VectorOperators.MUL, vsrc2.lanewise(VectorOperators.AND, 0xFFFFFFFFL))\n+                .intoArray(res, i);\n+        }\n+        for (; i < res.length; i++) {\n+            res[i] = (src1[i] >>> 32) * (src2[i] & 0xFFFFFFFFL);\n+        }\n+    }\n+\n+    interface Validator {\n+        public long apply(long src1, long src2);\n+    }\n+\n+    public static void validate(String msg, long [] actual, long [] src1, long [] src2, Validator func) {\n+        for (int i = 0; i < actual.length; i++) {\n+            if (actual[i] != func.apply(src1[i], src2[i])) {\n+                throw new AssertionError(msg + \"index \" + i + \": src1 = \" + src1[i] + \" src2 = \" +\n+                                         src2[i] + \" actual = \" + actual[i] + \" expected = \" +\n+                                         func.apply(src1[i], src2[i]));\n+            }\n+        }\n+    }\n+\n+    public static void setup() {\n+        src1 = new long[SIZE];\n+        src2 = new long[SIZE];\n+        res  = new long[SIZE];\n+        IntStream.range(0, SIZE).forEach(i -> { src1[i] = Long.MAX_VALUE * r.nextLong(); });\n+        IntStream.range(0, SIZE).forEach(i -> { src2[i] = Long.MAX_VALUE * r.nextLong(); });\n+    }\n+\n+    public static void main(String[] args) {\n+        setup();\n+        for (int ic = 0; ic < 1000; ic++) {\n+            pattern1(res, src1, src2);\n+            validate(\"pattern1 \", res, src1, src2, (src1, src2) -> (src1 & 0xFFFFFFFFL) * (src2 & 0xFFFFFFFFL));\n+\n+            pattern2(res, src1, src2);\n+            validate(\"pattern2 \", res, src1, src2, (src1, src2) -> (src1 & 0xFFFFFFFFL) * (src2 >>> 32));\n+\n+            pattern3(res, src1, src2);\n+            validate(\"pattern3 \", res, src1, src2, (src1, src2) -> (src1 >>> 32) * (src2 >>> 32));\n+\n+            pattern4(res, src1, src2);\n+            validate(\"pattern4 \", res, src1, src2, (src1, src2) -> (src1 >>> 32) * (src2 & 0xFFFFFFFFL));\n+        }\n+        System.out.println(\"PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMultiplyOpt.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import jdk.incubator.vector.*;\n+import java.util.stream.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorXXH3HashingBenchmark {\n+    @Param({\"1024\", \"2048\", \"4096\", \"8192\"})\n+    private int  SIZE;\n+    private long [] accumulators;\n+    private byte [] input;\n+    private byte [] SECRET;\n+\n+    private static final VectorShuffle<Long> LONG_SHUFFLE_PREFERRED = VectorShuffle.fromOp(LongVector.SPECIES_PREFERRED, i -> i ^ 1);\n+\n+    @Setup(Level.Trial)\n+    public void Setup() {\n+        accumulators = new long[SIZE];\n+        input = new byte[SIZE * 8];\n+        SECRET = new byte[SIZE*8];\n+        IntStream.range(0, SIZE*8).forEach(\n+            i -> {\n+                     input[i] = (byte)i;\n+                     SECRET[i] = (byte)-i;\n+                 }\n+        );\n+    }\n+\n+    @Benchmark\n+    public void hashingKernel() {\n+        for (int block = 0; block < input.length \/ 1024; block++) {\n+            for (int stripe = 0; stripe < 16; stripe++) {\n+                int inputOffset = block * 1024 + stripe * 64;\n+                int secretOffset = stripe * 8;\n+\n+                for (int i = 0; i < 8; i += LongVector.SPECIES_PREFERRED.length()) {\n+                    LongVector accumulatorsVector = LongVector.fromArray(LongVector.SPECIES_PREFERRED, accumulators, i);\n+                    LongVector inputVector = ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, input, inputOffset + i * 8).reinterpretAsLongs();\n+                    LongVector secretVector = ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, SECRET, secretOffset + i * 8).reinterpretAsLongs();\n+\n+                    LongVector key = inputVector\n+                            .lanewise(VectorOperators.XOR, secretVector)\n+                            .reinterpretAsLongs();\n+\n+                    LongVector low = key.and(0xFFFF_FFFFL);\n+                    LongVector high = key.lanewise(VectorOperators.LSHR, 32);\n+\n+                    accumulatorsVector\n+                            .add(inputVector.rearrange(LONG_SHUFFLE_PREFERRED))\n+                            .add(high.mul(low))\n+                            .intoArray(accumulators, i);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorXXH3HashingBenchmark.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}