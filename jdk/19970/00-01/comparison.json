{"files":[{"patch":"@@ -130,0 +130,3 @@\n+        \/\/ IGVN already folds constants to in(2). If we find a variable there\n+        \/\/ instead, we cannot further decompose this summand, and have to add\n+        \/\/ it to the terminal summands.\n@@ -173,0 +176,4 @@\n+      default:\n+        \/\/ All other operations cannot be further decomposed. We just add them to the\n+        \/\/ terminal summands below.\n+        break;\n","filename":"src\/hotspot\/share\/opto\/mempointer.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,106 @@\n+\/\/ Intuition and Examples:\n+\/\/   We parse \/ decompose pointers into a linear form:\n+\/\/\n+\/\/     pointer = con + sum_i(scale_i * variable_i)\n+\/\/\n+\/\/   The con and scale_i are compile-time constants (NoOverflowInt), and the variable_i are\n+\/\/   compile-time variables (C2 nodes).\n+\/\/\n+\/\/   For the MemPointer, we do not explicitly track base address. For Java heap pointers, the\n+\/\/   base address is just a variable. For native memory (C heap) pointers, the base address is\n+\/\/   null, and is hence implicitly a zero constant.\n+\/\/\n+\/\/\n+\/\/   Example1: byte array access:\n+\/\/\n+\/\/     array[i]\n+\/\/\n+\/\/     pointer =           array_base + ARRAY_BYTE_BASE_OFFSET + 1       * i\n+\/\/             = 1       * array_base + ARRAY_BYTE_BASE_OFFSET + 1       * i\n+\/\/               --------------------   ----------------------   --------------------\n+\/\/             = scale_0 * variable_0 + con                    + scale_1 * variable_1\n+\/\/\n+\/\/\n+\/\/   Example2: int array access\n+\/\/\n+\/\/     array[5 + i + 3 * j]\n+\/\/\n+\/\/     pointer =           array_base + ARRAY_INT_BASE_OFFSET + 4 * 5 + 4       * j          + 4       * 3 * j\n+\/\/             = 1       * array_base + ARRAY_INT_BASE_OFFSET + 20    + 4       * j          + 12      * j\n+\/\/               --------------------   -----------------------------   --------------------   --------------------\n+\/\/             = scale_0 * variable_0 + con                           + scale_1 * variable_1 + scale_2 * variable_2\n+\/\/\n+\/\/\n+\/\/   Example3: Unsafe with int array\n+\/\/\n+\/\/     UNSAFE.getInt(array, ARRAY_INT_BASE_OFFSET + 4 * i);\n+\/\/\n+\/\/     pointer =           array_base + ARRAY_INT_BASE_OFFSET + 4       * i\n+\/\/             = 1       * array_base + ARRAY_INT_BASE_OFFSET + 4       * i\n+\/\/             = scale_0 * variable_0 + con                   + scale_1 * variable_1\n+\/\/\n+\/\/\n+\/\/   Example4: Unsafe with native memory address\n+\/\/\n+\/\/     long address;\n+\/\/     UNSAFE.getInt(null, address + 4 * i);\n+\/\/\n+\/\/     pointer =           address          + 4       * i\n+\/\/             = 1       * address    + 0   + 4       * i\n+\/\/             = scale_0 * variable_0 + con + scale_1 * variable_1\n+\/\/\n+\/\/\n+\/\/   Example5: MemorySegment with byte array as backing type\n+\/\/\n+\/\/     byte[] array = new byte[1000];\n+\/\/     MemorySegment ms = MemorySegment.ofArray(array);\n+\/\/     assert ms.heapBase().get() == array: \"array is base\";\n+\/\/     assert ms.address() == 0: \"zero offset from base\";\n+\/\/     byte val = ms.get(ValueLayout.JAVA_BYTE, i);\n+\/\/\n+\/\/     pointer =           ms.heapBase() + ARRAY_BYTE_BASE_OFFSET + ms.address() +           i\n+\/\/             = 1       * array_base    + ARRAY_BYTE_BASE_OFFSET + 0            + 1       * i\n+\/\/               -----------------------   -------------------------------------   --------------------\n+\/\/             = scale_0 * variable_0    + con                                   + scale_1 * variable_1\n+\/\/\n+\/\/\n+\/\/   Example6: MemorySegment with native memory\n+\/\/\n+\/\/     MemorySegment ms = Arena.ofAuto().allocate(1000, 1);\n+\/\/     assert ms.heapBase().isEmpty(): \"null base\";\n+\/\/     assert ms.address() != 0: \"non-zero native memory address\";\n+\/\/     byte val2 = ms.get(ValueLayout.JAVA_BYTE, i);\n+\/\/\n+\/\/     pointer = ms.heapBase() +           ms.address() +           i\n+\/\/             = 0             + 1       * ms.address() + 1       * i\n+\/\/               ------------    ----------------------   --------------------\n+\/\/             = con             scale_0 * variable_0   + scale_1 * variable_1\n+\/\/\n+\/\/\n+\/\/   Example7: Non-linear access to int array\n+\/\/\n+\/\/     array[5 + i + j * k]\n+\/\/\n+\/\/     pointer =           array_base + ARRAY_INT_BASE_OFFSET + 4 * 5 + 4       * j          + 4       * j * k\n+\/\/             = 1       * array_base + ARRAY_INT_BASE_OFFSET + 20    + 4       * j          + 4       * j * k\n+\/\/               --------------------   -----------------------------   --------------------   --------------------\n+\/\/             = scale_0 * variable_0 + con                           + scale_1 * variable_1 + scale_2 * variable_2\n+\/\/\n+\/\/     Note: we simply stop parsing once a term is not linear. We keep \"j * k\" as its own variable.\n+\/\/\n+\/\/\n+\/\/   Example8: Unsafe with native memory address, non-linear access\n+\/\/\n+\/\/     UNSAFE.getInt(null, i * j);\n+\/\/\n+\/\/     pointer =                 i * j\n+\/\/             = 0   + 1       * i * j\n+\/\/               ---   --------------------\n+\/\/             = con + scale_0 * variable_0\n+\/\/\n+\/\/     Note: we can always parse a pointer into its trivial linear form:\n+\/\/\n+\/\/             pointer = 0 + 1 * pointer.\n+\/\/\n+\/\/ -----------------------------------------------------------------------------------------\n+\/\/\n@@ -49,0 +155,2 @@\n+\/\/   Note: the scale_i are compile-time constants (NoOverflowInt), and the variable_i are\n+\/\/         compile-time variables (C2 nodes).\n@@ -350,5 +458,1 @@\n-  \/\/ (e.g. array pointer or null for native memory) and a few variables. For example:\n-  \/\/\n-  \/\/   array[j]                      ->  array_base + j + con              -> 2 summands\n-  \/\/   nativeMemorySegment.get(j)    ->  null + address + offset + j + con -> 3 summands\n-  \/\/\n+  \/\/ (e.g. array pointer or null for native memory) and a few variables.\n","filename":"src\/hotspot\/share\/opto\/mempointer.hpp","additions":109,"deletions":5,"binary":false,"changes":114,"status":"modified"}]}