{"files":[{"patch":"@@ -370,2 +370,1 @@\n-    const jint max_distance = 1 << 30;\n-    assert(_distance < max_distance && _distance > -max_distance, \"safe distance\");\n+    assert(_distance != min_jint, \"given by condition S3 of MemPointer Lemma\");\n","filename":"src\/hotspot\/share\/opto\/mempointer.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -187,0 +187,12 @@\n+        \/\/ No result verification here. We only want to make sure we do not hit asserts.\n+        System.out.println(\"test8 and test9\");\n+        for (int i = 0; i < 100_000; i++) {\n+            test8a(big, ANCHOR);\n+            test8b(big, ANCHOR);\n+            test8c(big, ANCHOR);\n+            test8d(big, ANCHOR);\n+            test9a(big, ANCHOR);\n+            test9b(big, ANCHOR);\n+            test9c(big, ANCHOR);\n+        }\n+\n@@ -260,0 +272,52 @@\n+\n+    \/\/ Test: check if large distance leads to assert\n+    static void test8a(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + anchor;\n+        UNSAFE.putByte(a, base + (1L << 11) + 0,          (byte)42);\n+        UNSAFE.putByte(a, base + (1L << 11) + (1L << 30), (byte)11);\n+    }\n+\n+    \/\/ Test: check if large distance leads to assert\n+    static void test8b(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + anchor;\n+        UNSAFE.putByte(a, base + (1L << 11) + (1L << 30), (byte)11);\n+        UNSAFE.putByte(a, base + (1L << 11) + 0,          (byte)42);\n+    }\n+\n+    \/\/ Test: check if large distance leads to assert\n+    static void test8c(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + anchor;\n+        UNSAFE.putByte(a, base - (1L << 11) - 0,          (byte)42);\n+        UNSAFE.putByte(a, base - (1L << 11) - (1L << 30), (byte)11);\n+    }\n+\n+    \/\/ Test: check if large distance leads to assert\n+    static void test8d(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + anchor;\n+        UNSAFE.putByte(a, base - (1L << 11) - (1L << 30), (byte)11);\n+        UNSAFE.putByte(a, base - (1L << 11) - 0,          (byte)42);\n+    }\n+\n+    \/\/ Test: check if large distance leads to assert\n+    \/\/       case: bad distance: NaN\n+    static void test9a(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + anchor;\n+        UNSAFE.putByte(a, base - 100,               (byte)42);\n+        UNSAFE.putByte(a, base - 100  + (1L << 31), (byte)11);\n+    }\n+\n+    \/\/ Test: check if large distance leads to assert\n+    \/\/       case: just before NaN, it is still a valid distance for MemPointer aliasing.\n+    static void test9b(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + anchor;\n+        UNSAFE.putByte(a, base - 100,                   (byte)42);\n+        UNSAFE.putByte(a, base - 100  + (1L << 31) - 1, (byte)11);\n+    }\n+\n+    \/\/ Test: check if large distance leads to assert\n+    \/\/       case: constant too large\n+    static void test9c(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + anchor;\n+        UNSAFE.putByte(a, base,               (byte)42);\n+        UNSAFE.putByte(a, base  + (1L << 31), (byte)11);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStoresUnsafeArrayPointer.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"}]}