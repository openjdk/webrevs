{"files":[{"patch":"@@ -2940,4 +2940,1 @@\n-  if (!pointer_def.is_adjacent_to_and_before(pointer_use)) {\n-    return false;\n-  }\n-  return true;\n+  return pointer_def.is_adjacent_to_and_before(pointer_use);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    if (traversal_count++ > 1000) { return MemPointerDecomposedForm(pointer); }\n+    if (traversal_count++ > 1000) { return MemPointerDecomposedForm::make_trivial(pointer); }\n@@ -50,1 +50,1 @@\n-  if (_con.is_NaN()) { return MemPointerDecomposedForm(pointer); }\n+  if (_con.is_NaN()) { return MemPointerDecomposedForm::make_trivial(pointer); }\n@@ -70,1 +70,1 @@\n-      return MemPointerDecomposedForm(pointer);\n+      return MemPointerDecomposedForm::make_trivial(pointer);\n@@ -302,1 +302,3 @@\n-\/\/ prove that the computed aliasing also applies for the underlying pointers.\n+\/\/ prove that the computed aliasing also applies for the underlying pointers. Note that the\n+\/\/ condition (S0) is already given, because the MemPointerDecomposedForm is always constructed\n+\/\/ using only safe decompositions.\n@@ -352,1 +354,1 @@\n-  \/\/ Hence, all 3 conditions of the \"MemoryPointer Lemma\" are established, and hence\n+  \/\/ Hence, all 4 conditions of the \"MemoryPointer Lemma\" are established, and hence\n","filename":"src\/hotspot\/share\/opto\/mempointer.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -491,0 +491,2 @@\n+\n+private:\n@@ -497,1 +499,0 @@\n-private:\n@@ -511,0 +512,4 @@\n+  static MemPointerDecomposedForm make_trivial(Node* pointer) {\n+    return MemPointerDecomposedForm(pointer);\n+  }\n+\n@@ -515,1 +520,1 @@\n-      return MemPointerDecomposedForm(pointer);\n+      return MemPointerDecomposedForm::make_trivial(pointer);\n","filename":"src\/hotspot\/share\/opto\/mempointer.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}