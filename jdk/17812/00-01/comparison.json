{"files":[{"patch":"@@ -182,1 +182,1 @@\n-  GrowableArray<int> pred_nodes;\n+  GrowableArray<int> memory_pred_edges;\n@@ -194,1 +194,1 @@\n-      pred_nodes.clear();\n+      memory_pred_edges.clear();\n@@ -207,1 +207,1 @@\n-          pred_nodes.append(_body.bb_idx(n2));\n+          memory_pred_edges.append(_body.bb_idx(n2));\n@@ -210,1 +210,1 @@\n-      add_node(n1, pred_nodes);\n+      add_node(n1, memory_pred_edges);\n@@ -220,1 +220,1 @@\n-void VLoopDependencyGraph::add_node(MemNode* n, GrowableArray<int>& extra_pred_edges) {\n+void VLoopDependencyGraph::add_node(MemNode* n, GrowableArray<int>& memory_pred_edges) {\n@@ -222,2 +222,2 @@\n-  if (extra_pred_edges.length() == 0) { return; }\n-  DependencyNode* dn = new (_arena) DependencyNode(n, extra_pred_edges, _arena);\n+  if (memory_pred_edges.length() == 0) { return; }\n+  DependencyNode* dn = new (_arena) DependencyNode(n, memory_pred_edges, _arena);\n@@ -256,2 +256,2 @@\n-      for (uint j = 0; j < dn->extra_pred_edges_length(); j++) {\n-        Node* pred = _body.body().at(dn->extra_pred_edge(j));\n+      for (uint j = 0; j < dn->memory_pred_edges_length(); j++) {\n+        Node* pred = _body.body().at(dn->memory_pred_edge(j));\n@@ -279,1 +279,1 @@\n-                                                     GrowableArray<int>& extra_pred_edges,\n+                                                     GrowableArray<int>& memory_pred_edges,\n@@ -282,2 +282,2 @@\n-    _extra_pred_edges_length(extra_pred_edges.length()),\n-    _extra_pred_edges(nullptr)\n+    _memory_pred_edges_length(memory_pred_edges.length()),\n+    _memory_pred_edges(nullptr)\n@@ -285,4 +285,4 @@\n-  assert(extra_pred_edges.length() > 0, \"not empty\");\n-  uint bytes = extra_pred_edges.length() * sizeof(int);\n-  _extra_pred_edges = (int*)arena->Amalloc(bytes);\n-  memcpy(_extra_pred_edges, extra_pred_edges.adr_at(0), bytes);\n+  assert(memory_pred_edges.length() > 0, \"not empty\");\n+  uint bytes = memory_pred_edges.length() * sizeof(int);\n+  _memory_pred_edges = (int*)arena->Amalloc(bytes);\n+  memcpy(_memory_pred_edges, memory_pred_edges.adr_at(0), bytes);\n@@ -299,2 +299,2 @@\n-    _next_extra_pred(0),\n-    _end_extra_pred((_dependency_node != nullptr) ? _dependency_node->extra_pred_edges_length() : 0)\n+    _next_memory_pred(0),\n+    _end_memory_pred((_dependency_node != nullptr) ? _dependency_node->memory_pred_edges_length() : 0)\n@@ -316,2 +316,2 @@\n-  } else if (_next_extra_pred < _end_extra_pred) {\n-    int pred_bb_idx = _dependency_node->extra_pred_edge(_next_extra_pred++);\n+  } else if (_next_memory_pred < _end_memory_pred) {\n+    int pred_bb_idx = _dependency_node->memory_pred_edge(_next_memory_pred++);\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -496,1 +496,1 @@\n-  void add_node(MemNode* n, GrowableArray<int>& extra_pred_edges);\n+  void add_node(MemNode* n, GrowableArray<int>& memory_pred_edges);\n@@ -509,2 +509,2 @@\n-    const uint _extra_pred_edges_length;\n-    int* _extra_pred_edges; \/\/ extra pred-edges, mapping to bb_idx\n+    const uint _memory_pred_edges_length;\n+    int* _memory_pred_edges; \/\/ memory pred-edges, mapping to bb_idx\n@@ -512,1 +512,1 @@\n-    DependencyNode(MemNode* n, GrowableArray<int>& extra_pred_edges, Arena* arena);\n+    DependencyNode(MemNode* n, GrowableArray<int>& memory_pred_edges, Arena* arena);\n@@ -514,1 +514,1 @@\n-    uint extra_pred_edges_length() const { return _extra_pred_edges_length; }\n+    uint memory_pred_edges_length() const { return _memory_pred_edges_length; }\n@@ -516,3 +516,3 @@\n-    int extra_pred_edge(uint i) const {\n-      assert(i < _extra_pred_edges_length, \"bounds check\");\n-      return _extra_pred_edges[i];\n+    int memory_pred_edge(uint i) const {\n+      assert(i < _memory_pred_edges_length, \"bounds check\");\n+      return _memory_pred_edges[i];\n@@ -537,3 +537,3 @@\n-    \/\/ Iterate in dependency_node->extra_pred_edge(i)\n-    int _next_extra_pred;\n-    int _end_extra_pred;\n+    \/\/ Iterate in dependency_node->memory_pred_edge(i)\n+    int _next_memory_pred;\n+    int _end_memory_pred;\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"}]}