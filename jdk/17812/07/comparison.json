{"files":[{"patch":"@@ -49,1 +49,0 @@\n-  _dg(arena()),                                             \/\/ dependence graph\n@@ -455,6 +454,0 @@\n-  \/\/ build _dg\n-  dependence_graph();\n-\n-  \/\/ compute function depth(Node*)\n-  compute_max_depth();\n-\n@@ -752,80 +745,0 @@\n-\/\/---------------------------dependence_graph---------------------------\n-\/\/ Construct dependency graph.\n-\/\/ Add dependence edges to load\/store nodes for memory dependence\n-\/\/    A.out()->DependNode.in(1) and DependNode.out()->B.prec(x)\n-void SuperWord::dependence_graph() {\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n-\n-  \/\/ First, assign a dependence node to each memory node\n-  for (int i = 0; i < body().length(); i++ ) {\n-    Node* n = body().at(i);\n-    if (n->is_Mem() || n->is_memory_phi()) {\n-      _dg.make_node(n);\n-    }\n-  }\n-\n-  const GrowableArray<PhiNode*>& mem_slice_head = _vloop_analyzer.memory_slices().heads();\n-  const GrowableArray<MemNode*>& mem_slice_tail = _vloop_analyzer.memory_slices().tails();\n-\n-  ResourceMark rm;\n-  GrowableArray<Node*> slice_nodes;\n-\n-  \/\/ For each memory slice, create the dependences\n-  for (int i = 0; i < mem_slice_head.length(); i++) {\n-    PhiNode* head = mem_slice_head.at(i);\n-    MemNode* tail = mem_slice_tail.at(i);\n-\n-    \/\/ Get slice in predecessor order (last is first)\n-    _vloop_analyzer.memory_slices().get_slice_in_reverse_order(head, tail, slice_nodes);\n-\n-    \/\/ Make the slice dependent on the root\n-    DepMem* slice = _dg.dep(head);\n-    _dg.make_edge(_dg.root(), slice);\n-\n-    \/\/ Create a sink for the slice\n-    DepMem* slice_sink = _dg.make_node(nullptr);\n-    _dg.make_edge(slice_sink, _dg.tail());\n-\n-    \/\/ Now visit each pair of memory ops, creating the edges\n-    for (int j = slice_nodes.length() - 1; j >= 0 ; j--) {\n-      Node* s1 = slice_nodes.at(j);\n-\n-      \/\/ If no dependency yet, use slice\n-      if (_dg.dep(s1)->in_cnt() == 0) {\n-        _dg.make_edge(slice, s1);\n-      }\n-      VPointer p1(s1->as_Mem(), _vloop);\n-      bool sink_dependent = true;\n-      for (int k = j - 1; k >= 0; k--) {\n-        Node* s2 = slice_nodes.at(k);\n-        if (s1->is_Load() && s2->is_Load())\n-          continue;\n-        VPointer p2(s2->as_Mem(), _vloop);\n-\n-        int cmp = p1.cmp(p2);\n-        if (!VPointer::not_equal(cmp)) {\n-          \/\/ Possibly same address\n-          _dg.make_edge(s1, s2);\n-          sink_dependent = false;\n-        }\n-      }\n-      if (sink_dependent) {\n-        _dg.make_edge(s1, slice_sink);\n-      }\n-    }\n-\n-#ifndef PRODUCT\n-    if (is_trace_superword_dependence_graph()) {\n-      tty->print_cr(\"\\nDependence graph for slice: %d\", head->_idx);\n-      for (int q = 0; q < slice_nodes.length(); q++) {\n-        _dg.print(slice_nodes.at(q));\n-      }\n-      tty->cr();\n-    }\n-#endif\n-\n-    slice_nodes.clear();\n-  }\n-}\n-\n@@ -864,1 +777,1 @@\n-void VLoopMemorySlices::get_slice_in_reverse_order(PhiNode* head, MemNode* tail, GrowableArray<Node*> &slice) const {\n+void VLoopMemorySlices::get_slice_in_reverse_order(PhiNode* head, MemNode* tail, GrowableArray<MemNode*> &slice) const {\n@@ -874,1 +787,1 @@\n-          slice.push(out);\n+          slice.push(out->as_Load());\n@@ -892,1 +805,1 @@\n-    slice.push(n);\n+    slice.push(n->as_Mem());\n@@ -1004,1 +917,0 @@\n-\/\/------------------------------independent---------------------------\n@@ -1006,1 +918,1 @@\n-bool SuperWord::independent(Node* s1, Node* s2) {\n+bool VLoopDependencyGraph::independent(Node* s1, Node* s2) const {\n@@ -1027,1 +939,1 @@\n-    for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {\n+    for (PredsIterator preds(*this, n); !preds.done(); preds.next()) {\n@@ -1029,1 +941,1 @@\n-      if (in_bb(pred) && depth(pred) >= min_d) {\n+      if (_vloop.in_bb(pred) && depth(pred) >= min_d) {\n@@ -1048,1 +960,1 @@\n-bool SuperWord::mutually_independent(const Node_List* nodes) const {\n+bool VLoopDependencyGraph::mutually_independent(const Node_List* nodes) const {\n@@ -1057,1 +969,1 @@\n-    nodes_set.set(bb_idx(n));\n+    nodes_set.set(_body.bb_idx(n));\n@@ -1061,1 +973,1 @@\n-    for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {\n+    for (PredsIterator preds(*this, n); !preds.done(); preds.next()) {\n@@ -1063,2 +975,2 @@\n-      if (in_bb(pred) && depth(pred) >= min_d) {\n-        if (nodes_set.test(bb_idx(pred))) {\n+      if (_vloop.in_bb(pred) && depth(pred) >= min_d) {\n+        if (nodes_set.test(_body.bb_idx(pred))) {\n@@ -1985,1 +1897,1 @@\n-\/\/ The PacksetGraph combines the DepPreds graph with the packset. In the PackSet\n+\/\/ The PacksetGraph combines the dependency graph with the packset. In the PackSet\n@@ -1990,5 +1902,5 @@\n-\/\/ For any edge (n1, n2) in DepPreds, we add an edge to the PacksetGraph for the\n-\/\/ PacksetGraph nodes corresponding to n1 and n2.\n-\/\/ We work from the DepPreds graph, because it gives us all the data-dependencies,\n-\/\/ as well as more refined memory-dependencies than the C2 graph. DepPreds does\n-\/\/ not have cycles. But packing nodes can introduce cyclic dependencies. Example:\n+\/\/ For any edge (n1, n2) in the dependency graph, we add an edge to the PacksetGraph for\n+\/\/ the PacksetGraph nodes corresponding to n1 and n2.\n+\/\/ We work from the dependency graph, because it gives us all the data-dependencies,\n+\/\/ as well as more refined memory-dependencies than the C2 graph. The dependency graph\n+\/\/ does not have cycles. But packing nodes can introduce cyclic dependencies. Example:\n@@ -2058,1 +1970,1 @@\n-  \/\/ Create nodes (from packs and scalar-nodes), and add edges, based on DepPreds.\n+  \/\/ Create nodes (from packs and scalar-nodes), and add edges, based on the dependency graph.\n@@ -2062,1 +1974,0 @@\n-    const DepGraph& dg = _slp->dg();\n@@ -2099,1 +2010,1 @@\n-        for (DepPreds preds(n, dg); !preds.done(); preds.next()) {\n+        for (VLoopDependencyGraph::PredsIterator preds(_slp->dependency_graph(), n); !preds.done(); preds.next()) {\n@@ -2121,1 +2032,1 @@\n-      for (DepPreds preds(n, dg); !preds.done(); preds.next()) {\n+      for (VLoopDependencyGraph::PredsIterator preds(_slp->dependency_graph(), n); !preds.done(); preds.next()) {\n@@ -2212,1 +2123,1 @@\n-\/\/ (1) Build the PacksetGraph. It combines the DepPreds graph with the\n+\/\/ (1) Build the PacksetGraph. It combines the dependency graph with the\n@@ -3045,35 +2956,0 @@\n-\/\/------------------------------compute_max_depth---------------------------\n-\/\/ Compute max depth for expressions from beginning of block\n-\/\/ Use to prune search paths during test for independence.\n-void SuperWord::compute_max_depth() {\n-  int ct = 0;\n-  bool again;\n-  do {\n-    again = false;\n-    for (int i = 0; i < body().length(); i++) {\n-      Node* n = body().at(i);\n-      if (!n->is_Phi()) {\n-        int d_orig = depth(n);\n-        int d_in   = 0;\n-        for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {\n-          Node* pred = preds.current();\n-          if (in_bb(pred)) {\n-            d_in = MAX2(d_in, depth(pred));\n-          }\n-        }\n-        if (d_in + 1 != d_orig) {\n-          set_depth(n, d_in + 1);\n-          again = true;\n-        }\n-      }\n-    }\n-    ct++;\n-  } while (again);\n-\n-#ifndef PRODUCT\n-  if (is_trace_superword_dependence_graph()) {\n-    tty->print_cr(\"compute_max_depth iterated: %d times\", ct);\n-  }\n-#endif\n-}\n-\n@@ -3737,135 +3613,0 @@\n-\n-\/\/ ============================ DepGraph ===========================\n-\n-\/\/------------------------------make_node---------------------------\n-\/\/ Make a new dependence graph node for an ideal node.\n-DepMem* DepGraph::make_node(Node* node) {\n-  DepMem* m = new (_arena) DepMem(node);\n-  if (node != nullptr) {\n-    assert(_map.at_grow(node->_idx) == nullptr, \"one init only\");\n-    _map.at_put_grow(node->_idx, m);\n-  }\n-  return m;\n-}\n-\n-\/\/------------------------------make_edge---------------------------\n-\/\/ Make a new dependence graph edge from dpred -> dsucc\n-DepEdge* DepGraph::make_edge(DepMem* dpred, DepMem* dsucc) {\n-  DepEdge* e = new (_arena) DepEdge(dpred, dsucc, dsucc->in_head(), dpred->out_head());\n-  dpred->set_out_head(e);\n-  dsucc->set_in_head(e);\n-  return e;\n-}\n-\n-\/\/ ========================== DepMem ========================\n-\n-\/\/------------------------------in_cnt---------------------------\n-int DepMem::in_cnt() {\n-  int ct = 0;\n-  for (DepEdge* e = _in_head; e != nullptr; e = e->next_in()) ct++;\n-  return ct;\n-}\n-\n-\/\/------------------------------out_cnt---------------------------\n-int DepMem::out_cnt() {\n-  int ct = 0;\n-  for (DepEdge* e = _out_head; e != nullptr; e = e->next_out()) ct++;\n-  return ct;\n-}\n-\n-\/\/------------------------------print-----------------------------\n-void DepMem::print() {\n-#ifndef PRODUCT\n-  tty->print(\"  DepNode %d (\", _node->_idx);\n-  for (DepEdge* p = _in_head; p != nullptr; p = p->next_in()) {\n-    Node* pred = p->pred()->node();\n-    tty->print(\" %d\", pred != nullptr ? pred->_idx : 0);\n-  }\n-  tty->print(\") [\");\n-  for (DepEdge* s = _out_head; s != nullptr; s = s->next_out()) {\n-    Node* succ = s->succ()->node();\n-    tty->print(\" %d\", succ != nullptr ? succ->_idx : 0);\n-  }\n-  tty->print_cr(\" ]\");\n-#endif\n-}\n-\n-\/\/ =========================== DepEdge =========================\n-\n-\/\/------------------------------DepPreds---------------------------\n-void DepEdge::print() {\n-#ifndef PRODUCT\n-  tty->print_cr(\"DepEdge: %d [ %d ]\", _pred->node()->_idx, _succ->node()->_idx);\n-#endif\n-}\n-\n-\/\/ =========================== DepPreds =========================\n-\/\/ Iterator over predecessor edges in the dependence graph.\n-\n-\/\/------------------------------DepPreds---------------------------\n-DepPreds::DepPreds(Node* n, const DepGraph& dg) {\n-  _n = n;\n-  _done = false;\n-  if (_n->is_Store() || _n->is_Load()) {\n-    _next_idx = MemNode::Address;\n-    _end_idx  = n->req();\n-    _dep_next = dg.dep(_n)->in_head();\n-  } else if (_n->is_Mem()) {\n-    _next_idx = 0;\n-    _end_idx  = 0;\n-    _dep_next = dg.dep(_n)->in_head();\n-  } else {\n-    _next_idx = 1;\n-    _end_idx  = _n->req();\n-    _dep_next = nullptr;\n-  }\n-  next();\n-}\n-\n-\/\/------------------------------next---------------------------\n-void DepPreds::next() {\n-  if (_dep_next != nullptr) {\n-    _current  = _dep_next->pred()->node();\n-    _dep_next = _dep_next->next_in();\n-  } else if (_next_idx < _end_idx) {\n-    _current  = _n->in(_next_idx++);\n-  } else {\n-    _done = true;\n-  }\n-}\n-\n-\/\/ =========================== DepSuccs =========================\n-\/\/ Iterator over successor edges in the dependence graph.\n-\n-\/\/------------------------------DepSuccs---------------------------\n-DepSuccs::DepSuccs(Node* n, DepGraph& dg) {\n-  _n = n;\n-  _done = false;\n-  if (_n->is_Load()) {\n-    _next_idx = 0;\n-    _end_idx  = _n->outcnt();\n-    _dep_next = dg.dep(_n)->out_head();\n-  } else if (_n->is_Mem() || _n->is_memory_phi()) {\n-    _next_idx = 0;\n-    _end_idx  = 0;\n-    _dep_next = dg.dep(_n)->out_head();\n-  } else {\n-    _next_idx = 0;\n-    _end_idx  = _n->outcnt();\n-    _dep_next = nullptr;\n-  }\n-  next();\n-}\n-\n-\/\/-------------------------------next---------------------------\n-void DepSuccs::next() {\n-  if (_dep_next != nullptr) {\n-    _current  = _dep_next->succ()->node();\n-    _dep_next = _dep_next->next_out();\n-  } else if (_next_idx < _end_idx) {\n-    _current  = _n->raw_out(_next_idx++);\n-  } else {\n-    _done = true;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":21,"deletions":280,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -60,122 +60,0 @@\n-\/\/ ========================= Dependence Graph =====================\n-\n-class DepMem;\n-\n-\/\/------------------------------DepEdge---------------------------\n-\/\/ An edge in the dependence graph.  The edges incident to a dependence\n-\/\/ node are threaded through _next_in for incoming edges and _next_out\n-\/\/ for outgoing edges.\n-class DepEdge : public ArenaObj {\n- protected:\n-  DepMem* _pred;\n-  DepMem* _succ;\n-  DepEdge* _next_in;   \/\/ list of in edges, null terminated\n-  DepEdge* _next_out;  \/\/ list of out edges, null terminated\n-\n- public:\n-  DepEdge(DepMem* pred, DepMem* succ, DepEdge* next_in, DepEdge* next_out) :\n-    _pred(pred), _succ(succ), _next_in(next_in), _next_out(next_out) {}\n-\n-  DepEdge* next_in()  { return _next_in; }\n-  DepEdge* next_out() { return _next_out; }\n-  DepMem*  pred()     { return _pred; }\n-  DepMem*  succ()     { return _succ; }\n-\n-  void print();\n-};\n-\n-\/\/------------------------------DepMem---------------------------\n-\/\/ A node in the dependence graph.  _in_head starts the threaded list of\n-\/\/ incoming edges, and _out_head starts the list of outgoing edges.\n-class DepMem : public ArenaObj {\n- protected:\n-  Node*    _node;     \/\/ Corresponding ideal node\n-  DepEdge* _in_head;  \/\/ Head of list of in edges, null terminated\n-  DepEdge* _out_head; \/\/ Head of list of out edges, null terminated\n-\n- public:\n-  DepMem(Node* node) : _node(node), _in_head(nullptr), _out_head(nullptr) {}\n-\n-  Node*    node()                { return _node;     }\n-  DepEdge* in_head()             { return _in_head;  }\n-  DepEdge* out_head()            { return _out_head; }\n-  void set_in_head(DepEdge* hd)  { _in_head = hd;    }\n-  void set_out_head(DepEdge* hd) { _out_head = hd;   }\n-\n-  int in_cnt();  \/\/ Incoming edge count\n-  int out_cnt(); \/\/ Outgoing edge count\n-\n-  void print();\n-};\n-\n-\/\/------------------------------DepGraph---------------------------\n-class DepGraph {\n- protected:\n-  Arena* _arena;\n-  GrowableArray<DepMem*> _map;\n-  DepMem* _root;\n-  DepMem* _tail;\n-\n- public:\n-  DepGraph(Arena* a) : _arena(a), _map(a, 8,  0, nullptr) {\n-    _root = new (_arena) DepMem(nullptr);\n-    _tail = new (_arena) DepMem(nullptr);\n-  }\n-\n-  DepMem* root() { return _root; }\n-  DepMem* tail() { return _tail; }\n-\n-  \/\/ Return dependence node corresponding to an ideal node\n-  DepMem* dep(Node* node) const { return _map.at(node->_idx); }\n-\n-  \/\/ Make a new dependence graph node for an ideal node.\n-  DepMem* make_node(Node* node);\n-\n-  \/\/ Make a new dependence graph edge dprec->dsucc\n-  DepEdge* make_edge(DepMem* dpred, DepMem* dsucc);\n-\n-  DepEdge* make_edge(Node* pred,   Node* succ)   { return make_edge(dep(pred), dep(succ)); }\n-  DepEdge* make_edge(DepMem* pred, Node* succ)   { return make_edge(pred,      dep(succ)); }\n-  DepEdge* make_edge(Node* pred,   DepMem* succ) { return make_edge(dep(pred), succ);      }\n-\n-  void print(Node* n)   { dep(n)->print(); }\n-  void print(DepMem* d) { d->print(); }\n-};\n-\n-\/\/------------------------------DepPreds---------------------------\n-\/\/ Iterator over predecessors in the dependence graph and\n-\/\/ non-memory-graph inputs of ideal nodes.\n-class DepPreds : public StackObj {\n-private:\n-  Node*    _n;\n-  int      _next_idx, _end_idx;\n-  DepEdge* _dep_next;\n-  Node*    _current;\n-  bool     _done;\n-\n-public:\n-  DepPreds(Node* n, const DepGraph& dg);\n-  Node* current() { return _current; }\n-  bool  done()    { return _done; }\n-  void  next();\n-};\n-\n-\/\/------------------------------DepSuccs---------------------------\n-\/\/ Iterator over successors in the dependence graph and\n-\/\/ non-memory-graph outputs of ideal nodes.\n-class DepSuccs : public StackObj {\n-private:\n-  Node*    _n;\n-  int      _next_idx, _end_idx;\n-  DepEdge* _dep_next;\n-  Node*    _current;\n-  bool     _done;\n-\n-public:\n-  DepSuccs(Node* n, DepGraph& dg);\n-  Node* current() { return _current; }\n-  bool  done()    { return _done; }\n-  void  next();\n-};\n-\n-\n@@ -189,1 +67,0 @@\n-  int         _depth;     \/\/ Max expression (DAG) depth from block start\n@@ -192,1 +69,1 @@\n-  SWNodeInfo() : _alignment(-1), _depth(0), _my_pack(nullptr) {}\n+  SWNodeInfo() : _alignment(-1), _my_pack(nullptr) {}\n@@ -215,2 +92,0 @@\n-  DepGraph _dg; \/\/ Dependence graph\n-\n@@ -283,0 +158,13 @@\n+  \/\/ VLoopDependencyGraph Accessors\n+  const VLoopDependencyGraph& dependency_graph() const {\n+    return _vloop_analyzer.dependency_graph();\n+  }\n+\n+  bool independent(Node* n1, Node* n2) const {\n+    return _vloop_analyzer.dependency_graph().independent(n1, n2);\n+  }\n+\n+  bool mutually_independent(const Node_List* nodes) const {\n+    return _vloop_analyzer.dependency_graph().mutually_independent(nodes);\n+  }\n+\n@@ -290,5 +178,0 @@\n-  bool is_trace_superword_dependence_graph() const {\n-    return TraceSuperWord ||\n-           _vloop.vtrace().is_trace(TraceAutoVectorizationTag::SW_DEPENDENCE_GRAPH);\n-  }\n-\n@@ -324,1 +207,0 @@\n-           _vloop.vtrace().is_trace(TraceAutoVectorizationTag::SW_DEPENDENCE_GRAPH) ||\n@@ -341,1 +223,0 @@\n-  const DepGraph&                  dg()      const { return _dg; }\n@@ -365,4 +246,0 @@\n-  \/\/ Max expression (DAG) depth from beginning of the block for each node\n-  int depth(Node* n) const                   { return _node_info.adr_at(bb_idx(n))->_depth; }\n-  void set_depth(Node* n, int d)             { int i = bb_idx(n); grow_node_info(i); _node_info.adr_at(i)->_depth = d; }\n-\n@@ -390,2 +267,0 @@\n-  \/\/ Construct dependency graph.\n-  void dependence_graph();\n@@ -401,4 +276,0 @@\n-  \/\/ Is there no data path from s1 to s2 or s2 to s1?\n-  bool independent(Node* s1, Node* s2);\n-  \/\/ Are all nodes in nodes list mutually independent?\n-  bool mutually_independent(const Node_List* nodes) const;\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":14,"deletions":143,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+  flags(DEPENDENCY_GRAPH,     \"Trace VLoopDependencyGraph\") \\\n@@ -39,1 +40,0 @@\n-  flags(SW_DEPENDENCE_GRAPH,  \"Trace SuperWord::dependence_graph\") \\\n@@ -118,1 +118,0 @@\n-        _tags.at_put(SW_DEPENDENCE_GRAPH, set_bit);\n@@ -125,1 +124,0 @@\n-        _tags.at_put(SW_DEPENDENCE_GRAPH, set_bit);\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,0 +164,2 @@\n+  _dependency_graph.construct();\n+\n@@ -167,0 +169,159 @@\n+\/\/ Construct the dependency graph:\n+\/\/  - Data-dependencies: implicit (taken from C2 node inputs).\n+\/\/  - Memory-dependencies:\n+\/\/    - No edges between different slices.\n+\/\/    - No Load-Load edges.\n+\/\/    - Inside a slice, add all Store-Load, Load-Store, Store-Store edges,\n+\/\/      except if we can prove that the memory does not overlap.\n+void VLoopDependencyGraph::construct() {\n+  const GrowableArray<PhiNode*>& mem_slice_heads = _memory_slices.heads();\n+  const GrowableArray<MemNode*>& mem_slice_tails = _memory_slices.tails();\n+\n+  ResourceMark rm;\n+  GrowableArray<MemNode*> slice_nodes;\n+  GrowableArray<int> memory_pred_edges;\n+\n+  \/\/ For each memory slice, create the memory subgraph\n+  for (int i = 0; i < mem_slice_heads.length(); i++) {\n+    PhiNode* head = mem_slice_heads.at(i);\n+    MemNode* tail = mem_slice_tails.at(i);\n+\n+    _memory_slices.get_slice_in_reverse_order(head, tail, slice_nodes);\n+\n+    \/\/ In forward order (reverse of reverse), visit all memory nodes in the slice.\n+    for (int j = slice_nodes.length() - 1; j >= 0 ; j--) {\n+      MemNode* n1 = slice_nodes.at(j);\n+      memory_pred_edges.clear();\n+\n+      VPointer p1(n1, _vloop);\n+      \/\/ For all memory nodes before it, check if we need to add a memory edge.\n+      for (int k = slice_nodes.length() - 1; k > j; k--) {\n+        MemNode* n2 = slice_nodes.at(k);\n+\n+        \/\/ Ignore Load-Load dependencies:\n+        if (n1->is_Load() && n2->is_Load()) { continue; }\n+\n+        VPointer p2(n2, _vloop);\n+        if (!VPointer::not_equal(p1.cmp(p2))) {\n+          \/\/ Possibly overlapping memory\n+          memory_pred_edges.append(_body.bb_idx(n2));\n+        }\n+      }\n+      if (memory_pred_edges.is_nonempty()) {\n+        \/\/ Data edges are taken implicitly from the C2 graph, thus we only add\n+        \/\/ a dependency node if we have memory edges.\n+        add_node(n1, memory_pred_edges);\n+      }\n+    }\n+    slice_nodes.clear();\n+  }\n+\n+  compute_depth();\n+\n+  NOT_PRODUCT( if (_vloop.is_trace_dependency_graph()) { print(); } )\n+}\n+\n+void VLoopDependencyGraph::add_node(MemNode* n, GrowableArray<int>& memory_pred_edges) {\n+  assert(_dependency_nodes.at_grow(_body.bb_idx(n), nullptr) == nullptr, \"not yet created\");\n+  assert(!memory_pred_edges.is_empty(), \"no need to create a node without edges\");\n+  DependencyNode* dn = new (_arena) DependencyNode(n, memory_pred_edges, _arena);\n+  _dependency_nodes.at_put_grow(_body.bb_idx(n), dn, nullptr);\n+}\n+\n+\/\/ We iterate over the body, which is already ordered by the dependencies, i.e. pred comes\n+\/\/ before use. With a single pass, we can compute the depth of every node, since we can\n+\/\/ assume that the depth of all preds is already computed when we compute the depth of use.\n+void VLoopDependencyGraph::compute_depth() {\n+  for (int i = 0; i < _body.body().length(); i++) {\n+    Node* n = _body.body().at(i);\n+    int max_pred_depth = 0;\n+    if (n->is_Phi()) {\n+      for (PredsIterator it(*this, n); !it.done(); it.next()) {\n+        Node* pred = it.current();\n+        if (_vloop.in_bb(pred)) {\n+          max_pred_depth = MAX2(max_pred_depth, depth(pred));\n+        }\n+      }\n+    }\n+    set_depth(n, max_pred_depth + 1);\n+  }\n+}\n+\n+#ifndef PRODUCT\n+void VLoopDependencyGraph::print() const {\n+  tty->print_cr(\"\\nVLoopDependencyGraph::print:\");\n+\n+  tty->print_cr(\" Memory pred edges:\");\n+  for (int i = 0; i < _body.body().length(); i++) {\n+    Node* n = _body.body().at(i);\n+    const DependencyNode* dn = dependency_node(n);\n+    if (dn != nullptr) {\n+      tty->print(\"  DependencyNode[%d %s:\", n->_idx, n->Name());\n+      for (uint j = 0; j < dn->memory_pred_edges_length(); j++) {\n+        Node* pred = _body.body().at(dn->memory_pred_edge(j));\n+        tty->print(\"  %d %s\", pred->_idx, pred->Name());\n+      }\n+      tty->print_cr(\"]\");\n+    }\n+  }\n+  tty->cr();\n+\n+  tty->print_cr(\" Complete dependency graph:\");\n+  for (int i = 0; i < _body.body().length(); i++) {\n+    Node* n = _body.body().at(i);\n+    tty->print(\"  d%02d Dependencies[%d %s:\", depth(n), n->_idx, n->Name());\n+    for (PredsIterator it(*this, n); !it.done(); it.next()) {\n+      Node* pred = it.current();\n+      tty->print(\"  %d %s\", pred->_idx, pred->Name());\n+    }\n+    tty->print_cr(\"]\");\n+  }\n+}\n+#endif\n+\n+VLoopDependencyGraph::DependencyNode::DependencyNode(MemNode* n,\n+                                                     GrowableArray<int>& memory_pred_edges,\n+                                                     Arena* arena) :\n+    _node(n),\n+    _memory_pred_edges_length(memory_pred_edges.length()),\n+    _memory_pred_edges(nullptr)\n+{\n+  assert(memory_pred_edges.is_nonempty(), \"not empty\");\n+  uint bytes = memory_pred_edges.length() * sizeof(int);\n+  _memory_pred_edges = (int*)arena->Amalloc(bytes);\n+  memcpy(_memory_pred_edges, memory_pred_edges.adr_at(0), bytes);\n+}\n+\n+VLoopDependencyGraph::PredsIterator::PredsIterator(const VLoopDependencyGraph& dependency_graph,\n+                                                   const Node* node) :\n+    _dependency_graph(dependency_graph),\n+    _node(node),\n+    _dependency_node(dependency_graph.dependency_node(node)),\n+    _current(nullptr),\n+    _next_pred(0),\n+    _end_pred(node->req()),\n+    _next_memory_pred(0),\n+    _end_memory_pred((_dependency_node != nullptr) ? _dependency_node->memory_pred_edges_length() : 0)\n+{\n+  if (_node->is_Store() || _node->is_Load()) {\n+    \/\/ Load: address\n+    \/\/ Store: address, value\n+    _next_pred = MemNode::Address;\n+  } else {\n+    assert(!_node->is_Mem(), \"only loads and stores are expected mem nodes\");\n+    _next_pred = 1; \/\/ skip control\n+  }\n+  next();\n+}\n+\n+void VLoopDependencyGraph::PredsIterator::next() {\n+  if (_next_pred < _end_pred) {\n+    _current = _node->in(_next_pred++);\n+  } else if (_next_memory_pred < _end_memory_pred) {\n+    int pred_bb_idx = _dependency_node->memory_pred_edge(_next_memory_pred++);\n+    _current = _dependency_graph._body.body().at(pred_bb_idx);\n+  } else {\n+    _current = nullptr; \/\/ done\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":161,"deletions":0,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -153,0 +153,4 @@\n+  bool is_trace_dependency_graph() const {\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::DEPENDENCY_GRAPH);\n+  }\n+\n@@ -311,1 +315,1 @@\n-  void get_slice_in_reverse_order(PhiNode* head, MemNode* tail, GrowableArray<Node*>& slice) const;\n+  void get_slice_in_reverse_order(PhiNode* head, MemNode* tail, GrowableArray<MemNode*>& slice) const;\n@@ -444,0 +448,103 @@\n+\/\/ Submodule of VLoopAnalyzer.\n+\/\/ The dependency graph is used to determine if nodes are independent, and can thus potentially\n+\/\/ be executed in parallel. That is a prerequisite for packing nodes into vector operations.\n+\/\/ The dependency graph is a combination:\n+\/\/  - Data-dependencies: they can directly be taken from the C2 node inputs.\n+\/\/  - Memory-dependencies: the edges in the C2 memory-slice are too restrictive: for example all\n+\/\/                         stores are serialized, even if their memory does not overlap. Thus,\n+\/\/                         we refine the memory-dependencies (see construct method).\n+class VLoopDependencyGraph : public StackObj {\n+private:\n+  class DependencyNode;\n+\n+  Arena*                   _arena;\n+  const VLoop&             _vloop;\n+  const VLoopBody&         _body;\n+  const VLoopMemorySlices& _memory_slices;\n+\n+  \/\/ bb_idx -> DependenceNode*\n+  GrowableArray<DependencyNode*> _dependency_nodes;\n+\n+  \/\/ Node depth in DAG: bb_idx -> depth\n+  GrowableArray<int> _depths;\n+\n+public:\n+  VLoopDependencyGraph(Arena* arena,\n+                       const VLoop& vloop,\n+                       const VLoopBody& body,\n+                       const VLoopMemorySlices& memory_slices) :\n+    _arena(arena),\n+    _vloop(vloop),\n+    _body(body),\n+    _memory_slices(memory_slices),\n+    _dependency_nodes(arena,\n+                      vloop.estimated_body_length(),\n+                      vloop.estimated_body_length(),\n+                      nullptr),\n+    _depths(arena,\n+            vloop.estimated_body_length(),\n+            vloop.estimated_body_length(),\n+            0) {}\n+  NONCOPYABLE(VLoopDependencyGraph);\n+\n+  void construct();\n+  bool independent(Node* s1, Node* s2) const;\n+  bool mutually_independent(const Node_List* nodes) const;\n+\n+private:\n+  void add_node(MemNode* n, GrowableArray<int>& memory_pred_edges);\n+  int depth(const Node* n) const { return _depths.at(_body.bb_idx(n)); }\n+  void set_depth(const Node* n, int d) { _depths.at_put(_body.bb_idx(n), d); }\n+  void compute_depth();\n+  NOT_PRODUCT( void print() const; )\n+\n+  const DependencyNode* dependency_node(const Node* n) const {\n+    return _dependency_nodes.at(_body.bb_idx(n));\n+  }\n+\n+  class DependencyNode : public ArenaObj {\n+  private:\n+    MemNode* _node; \/\/ Corresponding ideal node\n+    const uint _memory_pred_edges_length;\n+    int* _memory_pred_edges; \/\/ memory pred-edges, mapping to bb_idx\n+  public:\n+    DependencyNode(MemNode* n, GrowableArray<int>& memory_pred_edges, Arena* arena);\n+    NONCOPYABLE(DependencyNode);\n+    uint memory_pred_edges_length() const { return _memory_pred_edges_length; }\n+\n+    int memory_pred_edge(uint i) const {\n+      assert(i < _memory_pred_edges_length, \"bounds check\");\n+      return _memory_pred_edges[i];\n+    }\n+  };\n+\n+public:\n+  \/\/ Iterator for dependency graph predecessors of a node.\n+  class PredsIterator : public StackObj {\n+  private:\n+    const VLoopDependencyGraph& _dependency_graph;\n+\n+    const Node* _node;\n+    const DependencyNode* _dependency_node;\n+\n+    Node* _current;\n+\n+    \/\/ Iterate in node->in(i)\n+    int _next_pred;\n+    int _end_pred;\n+\n+    \/\/ Iterate in dependency_node->memory_pred_edge(i)\n+    int _next_memory_pred;\n+    int _end_memory_pred;\n+  public:\n+    PredsIterator(const VLoopDependencyGraph& dependency_graph, const Node* node);\n+    NONCOPYABLE(PredsIterator);\n+    void next();\n+    bool done() const { return _current == nullptr; }\n+    Node* current() const {\n+      assert(!done(), \"not done yet\");\n+      return _current;\n+    }\n+  };\n+};\n+\n@@ -466,0 +573,1 @@\n+  VLoopDependencyGraph _dependency_graph;\n@@ -475,1 +583,2 @@\n-    _types           (&_arena, vloop, _body)\n+    _types           (&_arena, vloop, _body),\n+    _dependency_graph(&_arena, vloop, _body, _memory_slices)\n@@ -489,0 +598,1 @@\n+  const VLoopDependencyGraph& dependency_graph() const { return _dependency_graph; }\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":112,"deletions":2,"binary":false,"changes":114,"status":"modified"}]}