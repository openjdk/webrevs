{"files":[{"patch":"@@ -50,1 +50,1 @@\n-  template(jdk_jfr_internal_HiddenWait,                               \"jdk\/jfr\/internal\/HiddenWait\")                 \\\n+  template(jdk_jfr_internal_management_HiddenWait,                    \"jdk\/jfr\/internal\/management\/HiddenWait\")      \\\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1445,1 +1445,1 @@\n-  JFR_ONLY(return vmSymbols::jdk_jfr_internal_HiddenWait() == monitor_klass->name();)\n+  JFR_ONLY(return vmSymbols::jdk_jfr_internal_management_HiddenWait() == monitor_klass->name();)\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jfr.internal;\n-\n-\/**\n- * The HiddenWait class is used to exclude jdk.JavaMonitorWait events\n- * from being generated when Object.wait() is called on an object of this type.\n- *\/\n-public final class HiddenWait {\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/HiddenWait.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -121,1 +122,2 @@\n-            Utils.takeNap(1);\n+            HiddenWait hiddenWait = new HiddenWait();\n+            hiddenWait.takeNap(1);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMSupport.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -62,0 +63,1 @@\n+    private final HiddenWait threadSleeper = new HiddenWait();\n@@ -346,1 +348,1 @@\n-            Utils.takeNap(1);\n+            threadSleeper.takeNap(1);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -47,0 +48,1 @@\n+    private final HiddenWait threadSleeper = new HiddenWait();\n@@ -198,1 +200,3 @@\n-            takeNap();\n+            if (!threadSleeper.takeNap(10)) {\n+                throw new IOException(\"Read operation interrupted\");\n+            }\n@@ -203,8 +207,0 @@\n-    private void takeNap() throws IOException {\n-        try {\n-            Thread.sleep(10);\n-        } catch (InterruptedException ie) {\n-            throw new IOException(\"Read operation interrupted\", ie);\n-        }\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -70,0 +72,1 @@\n+    private final HiddenWait threadSleeper = new HiddenWait();\n@@ -456,1 +459,1 @@\n-        Utils.takeNap(1);\n+        threadSleeper.takeNap(1);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RecordingInput.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import jdk.jfr.internal.management.HiddenWait;;\n@@ -51,1 +52,1 @@\n-    private static final Object WAIT_OBJECT = new Object();\n+    private static final HiddenWait WAIT_OBJECT = new HiddenWait();\n@@ -62,1 +63,1 @@\n-    private final Object waitObject;\n+    private final HiddenWait waitObject;\n@@ -70,1 +71,1 @@\n-        this.waitObject = repository == null ? WAIT_OBJECT : new Object();\n+        this.waitObject = repository == null ? WAIT_OBJECT : new HiddenWait();\n@@ -111,1 +112,1 @@\n-                nap();\n+                waitObject.takeNap(1000);\n@@ -160,10 +161,0 @@\n-    private void nap() {\n-        try {\n-            synchronized (waitObject) {\n-                waitObject.wait(1000);\n-            }\n-        } catch (InterruptedException e) {\n-            \/\/ ignore\n-        }\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.management;\n+\n+\/**\n+ * The HiddenWait class is used to exclude jdk.JavaMonitorWait events\n+ * from being generated when Object.wait() is called on an object of this type.\n+ *\/\n+public final class HiddenWait {\n+\n+    public synchronized boolean takeNap(long timeoutMillis) {\n+        try {\n+            this.wait(timeoutMillis);\n+            return true;\n+        } catch (InterruptedException e) {\n+            \/\/ Ok, ignore\n+            return false;\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/HiddenWait.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n-\n+    private final HiddenWait lock = new HiddenWait();\n@@ -48,6 +48,8 @@\n-    public synchronized void check() {\n-        while (activated) {\n-            try {\n-                this.wait();\n-            } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n+    public void check() {\n+        synchronized (lock) {\n+            while (activated) {\n+                try {\n+                    lock.wait();\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                }\n@@ -58,2 +60,4 @@\n-    public synchronized void setStreamEnd(long timestamp) {\n-        end = timestamp;\n+    public void setStreamEnd(long timestamp) {\n+        synchronized(lock) {\n+            end = timestamp;\n+        }\n@@ -62,2 +66,4 @@\n-    public synchronized long getStreamEnd() {\n-        return end;\n+    public long getStreamEnd() {\n+        synchronized(lock) {\n+            return end;\n+        }\n@@ -66,3 +72,5 @@\n-    public synchronized void activate() {\n-        activated = true;\n-        used = true;\n+    public void activate() {\n+        synchronized (lock) {\n+            activated = true;\n+            used = true;\n+        }\n@@ -73,2 +81,4 @@\n-        activated = false;\n-        this.notifyAll();\n+        synchronized (lock) {\n+            activated = false;\n+            lock.notifyAll();\n+        }\n@@ -80,2 +90,4 @@\n-    public synchronized boolean used() {\n-        return used;\n+    public boolean used() {\n+        synchronized (lock) {\n+            return used;\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/StreamBarrier.java","additions":30,"deletions":18,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import jdk.jfr.internal.HiddenWait;\n@@ -58,0 +57,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -63,1 +63,1 @@\n-    private static final Object flushObject = new Object();\n+    private static final HiddenWait flushObject = new HiddenWait();\n@@ -354,11 +354,0 @@\n-    public static void takeNap(long millis) {\n-        HiddenWait hiddenWait = new HiddenWait();\n-        try {\n-            synchronized(hiddenWait) {\n-                hiddenWait.wait(millis);\n-            }\n-        } catch (InterruptedException e) {\n-            \/\/ ok\n-        }\n-    }\n-\n@@ -372,7 +361,1 @@\n-        synchronized (flushObject) {\n-            try {\n-                flushObject.wait(timeOut);\n-            } catch (InterruptedException e) {\n-                \/\/ OK\n-            }\n-        }\n+        flushObject.takeNap(timeOut);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -39,0 +40,1 @@\n+    private final HiddenWait threadSleeper = new HiddenWait();\n@@ -67,1 +69,1 @@\n-                    takeNap();\n+                    threadSleeper.takeNap(1000);\n@@ -76,8 +78,0 @@\n-\n-    private void takeNap() {\n-        try {\n-            Thread.sleep(1000);\n-        } catch (InterruptedException ie) {\n-            \/\/ ignore\n-        }\n-    }\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DownLoadThread.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -37,0 +38,1 @@\n+    private final HiddenWait lock = new HiddenWait();\n@@ -45,9 +47,11 @@\n-    public synchronized void add(DiskChunk dc) {\n-        if (isComplete()) {\n-            return;\n-        }\n-        dc.acquire();\n-        chunks.addFirst(dc);\n-        long endMillis = dc.endTimeNanos \/ 1_000_000;\n-        if (endMillis >= stopTimeMillis) {\n-            setComplete();\n+    public void add(DiskChunk dc) {\n+        synchronized (lock) {\n+            if (isComplete()) {\n+                return;\n+            }\n+            dc.acquire();\n+            chunks.addFirst(dc);\n+            long endMillis = dc.endTimeNanos \/ 1_000_000;\n+            if (endMillis >= stopTimeMillis) {\n+                setComplete();\n+            }\n@@ -57,2 +61,4 @@\n-    public synchronized boolean isComplete() {\n-        return complete;\n+    public boolean isComplete() {\n+        synchronized (lock) {\n+            return complete;\n+        }\n@@ -61,3 +67,5 @@\n-    public synchronized void setComplete() {\n-        complete = true;\n-        this.notifyAll();\n+    public void setComplete() {\n+        synchronized (lock) {\n+            complete = true;\n+            lock.notifyAll();\n+        }\n@@ -66,3 +74,7 @@\n-    public synchronized void close() {\n-        for (DiskChunk dc : chunks) {\n-            dc.release();\n+    public void close() {\n+        synchronized (lock) {\n+            for (DiskChunk dc : chunks) {\n+                dc.release();\n+            }\n+            chunks.clear();\n+            complete = true;\n@@ -70,2 +82,0 @@\n-        chunks.clear();\n-        complete = true;\n@@ -76,1 +86,1 @@\n-            synchronized (this) {\n+            synchronized (lock) {\n@@ -83,1 +93,1 @@\n-                this.wait();\n+                lock.wait();\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/FileDump.java","additions":31,"deletions":21,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.Name;\n+import jdk.jfr.Event;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test TestHiddenWait\n+ * @key jfr\n+ * @summary Checks that JFR code don't emit noise in the form of ThreadSleep and JavaMonitorWait events.\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.jvm.TestHiddenWait\n+ *\/\n+public class TestHiddenWait {\n+    static final String PERIODIC_EVENT_NAME = \"test.Periodic\";\n+\n+    @Name(PERIODIC_EVENT_NAME)\n+    public static class PeriodicEvent extends Event {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        FlightRecorder.addPeriodicEvent(PeriodicEvent.class,  () -> {\n+            PeriodicEvent event = new PeriodicEvent();\n+            event.commit();\n+        });\n+        try (Recording r = new Recording()) {\n+            AtomicLong counter = new AtomicLong();\n+            r.enable(\"jdk.ThreadSleep\").withoutThreshold();\n+            r.enable(\"jdk.JavaMonitorWait\").withoutThreshold();\n+            r.enable(PERIODIC_EVENT_NAME).withPeriod(Duration.ofMillis(100));\n+            r.start();\n+            \/\/ Triggers Object.wait() in stream barrier\n+            try (RecordingStream b = new RecordingStream()) {\n+                b.startAsync();\n+                b.stop();\n+            }\n+            \/\/ Wait for for periodic events\n+            try (RecordingStream s = new RecordingStream()) {\n+                s.onEvent(PERIODIC_EVENT_NAME, e -> {\n+                    if (counter.incrementAndGet() >= 2) {\n+                        s.close();\n+                    }\n+                });\n+                s.start();\n+            }\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            for (RecordedEvent event : events) {\n+                if (!event.getEventType().getName().equals(PERIODIC_EVENT_NAME)) {\n+                    System.out.println(event);\n+                    throw new Exception(\"Didn't expect ThreadSleep or JavaMonitorWait events\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestHiddenWait.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}