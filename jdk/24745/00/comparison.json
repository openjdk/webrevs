{"files":[{"patch":"@@ -131,2 +131,2 @@\n-        DISCARD_STDOUT(NOP),\n-        DISCARD_STDERR(NOP),\n+        DISCARD_STDOUT(Executor::discardStdout),\n+        DISCARD_STDERR(Executor::discardStderr),\n@@ -216,0 +216,3 @@\n+            assertEquals(expectedResultStdout(commandWithDiscardedStreams), result[0].stdout().getOutput());\n+            assertEquals(expectedResultStderr(commandWithDiscardedStreams), result[0].stderr().getOutput());\n+\n@@ -275,0 +278,22 @@\n+        private List<String> expectedResultStdout(Command command) {\n+            return expectedResultStream(command.stdout());\n+        }\n+\n+        private List<String> expectedResultStderr(Command command) {\n+            if (outputControl.contains(OutputControl.SAVE_FIRST_LINE) && !command.stdout().isEmpty()) {\n+                return List.of();\n+            }\n+            return expectedResultStream(command.stderr());\n+        }\n+\n+        private List<String> expectedResultStream(List<String> commandOutput) {\n+            Objects.requireNonNull(commandOutput);\n+            if (outputControl.contains(OutputControl.SAVE_ALL)) {\n+                return commandOutput;\n+            } else if (outputControl.contains(OutputControl.SAVE_FIRST_LINE)) {\n+                return commandOutput.stream().findFirst().map(List::of).orElseGet(List::of);\n+            } else {\n+                return null;\n+            }\n+        }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/ExecutorTest.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-                        return new Executor.Result(actualJPackageExitCode, null,\n+                        return new Executor.Result(actualJPackageExitCode,\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/PackageTestTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import static java.util.stream.Collectors.joining;\n+\n@@ -28,0 +30,1 @@\n+import java.io.InputStream;\n@@ -35,1 +38,0 @@\n-import java.util.Collections;\n@@ -66,1 +68,1 @@\n-        saveOutputType = new HashSet<>(Set.of(SaveOutputType.NONE));\n+        outputStreamsControl = new OutputStreamsControl();\n@@ -134,3 +136,4 @@\n-     * Configures this instance to save full output that command will produce.\n-     * This function is mutual exclusive with\n-     * saveFirstLineOfOutput() function.\n+     * Configures this instance to save all stdout and stderr streams from the to be\n+     * executed command.\n+     * <p>\n+     * This function is mutually exclusive with {@link #saveFirstLineOfOutput()}.\n@@ -141,3 +144,1 @@\n-        saveOutputType.remove(SaveOutputType.FIRST_LINE);\n-        saveOutputType.add(SaveOutputType.FULL);\n-        return this;\n+        return saveOutput(true);\n@@ -147,4 +148,8 @@\n-     * Configures how to save output that command will produce. If\n-     * <code>v<\/code> is <code>true<\/code>, the function call is equivalent to\n-     * <code>saveOutput()<\/code> call. If <code>v<\/code> is <code>false<\/code>,\n-     * the function will result in not preserving command output.\n+     * Configures if all stdout and stderr streams from the to be executed command\n+     * should be saved.\n+     * <p>\n+     * If <code>v<\/code> is <code>true<\/code>, the function call is equivalent to\n+     * {@link #saveOutput()} call. If <code>v<\/code> is <code>false<\/code>, command\n+     * output will not be saved.\n+     *\n+     * @parameter v if both stdout and stderr streams should be saved\n@@ -155,7 +160,1 @@\n-        if (v) {\n-            saveOutput();\n-        } else {\n-            saveOutputType.remove(SaveOutputType.FIRST_LINE);\n-            saveOutputType.remove(SaveOutputType.FULL);\n-        }\n-        return this;\n+        return setOutputControl(v, OutputControlOption.SAVE_ALL);\n@@ -165,3 +164,4 @@\n-     * Configures this instance to save only the first line out output that\n-     * command will produce. This function is mutual exclusive with\n-     * saveOutput() function.\n+     * Configures this instance to save the first line of a stream merged from\n+     * stdout and stderr streams from the to be executed command.\n+     * <p>\n+     * This function is mutually exclusive with {@link #saveOutput()}.\n@@ -172,3 +172,1 @@\n-        saveOutputType.add(SaveOutputType.FIRST_LINE);\n-        saveOutputType.remove(SaveOutputType.FULL);\n-        return this;\n+        return setOutputControl(true, OutputControlOption.SAVE_FIRST_LINE);\n@@ -178,4 +176,2 @@\n-     * Configures this instance to dump all output that command will produce to\n-     * System.out and System.err. Can be used together with saveOutput() and\n-     * saveFirstLineOfOutput() to save command output and also copy it in the\n-     * default output streams.\n+     * Configures this instance to dump both stdout and stderr streams from the to\n+     * be executed command into {@link System.out}.\n@@ -190,5 +186,5 @@\n-        if (v) {\n-            saveOutputType.add(SaveOutputType.DUMP);\n-        } else {\n-            saveOutputType.remove(SaveOutputType.DUMP);\n-        }\n+        return setOutputControl(v, OutputControlOption.DUMP);\n+    }\n+\n+    public Executor discardStdout(boolean v) {\n+        outputStreamsControl.stdout().discard(v);\n@@ -198,1 +194,3 @@\n-    public record Result(int exitCode, List<String> output, Supplier<String> cmdline) {\n+    public Executor discardStdout() {\n+        return discardStdout(true);\n+    }\n@@ -200,0 +198,22 @@\n+    public Executor discardStderr(boolean v) {\n+        outputStreamsControl.stderr().discard(v);\n+        return this;\n+    }\n+\n+    public Executor discardStderr() {\n+        return discardStderr(true);\n+    }\n+\n+    public interface Output {\n+        public List<String> getOutput();\n+\n+        public default String getFirstLineOfOutput() {\n+            return findFirstLineOfOutput().orElseThrow();\n+        }\n+\n+        public default Optional<String> findFirstLineOfOutput() {\n+            return getOutput().stream().findFirst();\n+        }\n+    }\n+\n+    public record Result(int exitCode, CommandOutput output, Supplier<String> cmdline) implements Output {\n@@ -201,0 +221,1 @@\n+            Objects.requireNonNull(output);\n@@ -204,2 +225,2 @@\n-        public String getFirstLineOfOutput() {\n-            return output.get(0);\n+        public Result(int exitCode, Supplier<String> cmdline) {\n+            this(exitCode, CommandOutput.EMPTY, cmdline);\n@@ -208,0 +229,1 @@\n+        @Override\n@@ -209,1 +231,9 @@\n-            return output;\n+            return output.lines().orElse(null);\n+        }\n+\n+        public Output stdout() {\n+            return createView(output.stdoutLines());\n+        }\n+\n+        public Output stderr() {\n+            return createView(output.stderrLines());\n@@ -226,0 +256,9 @@\n+\n+        private static Output createView(Optional<List<String>> lines) {\n+            return new Output() {\n+                @Override\n+                public List<String> getOutput() {\n+                    return lines.orElse(null);\n+                }\n+            };\n+        }\n@@ -281,3 +320,9 @@\n-    \/*\n-     * Repeates command \"max\" times and waits for \"wait\" seconds between each\n-     * execution until command returns expected error code.\n+    \/**\n+     * Executes the configured command {@code max} at most times and waits for\n+     * {@code wait} seconds between each execution until the command exits with\n+     * {@code expectedCode} exit code.\n+     *\n+     * @param expectedExitCode the expected exit code of the command\n+     * @param max              the maximum times to execute the command\n+     * @param wait             number of seconds to wait between executions of the\n+     *                         command\n@@ -285,1 +330,1 @@\n-    public Result executeAndRepeatUntilExitCode(int expectedCode, int max, int wait) {\n+    public Result executeAndRepeatUntilExitCode(int expectedExitCode, int max, int wait) {\n@@ -289,1 +334,1 @@\n-                if (result.getExitCode() != expectedCode) {\n+                if (result.getExitCode() != expectedExitCode) {\n@@ -293,1 +338,1 @@\n-            }, max, wait).assertExitCodeIs(expectedCode);\n+            }, max, wait).assertExitCodeIs(expectedExitCode);\n@@ -295,1 +340,1 @@\n-            return ex.getValue().assertExitCodeIs(expectedCode);\n+            return ex.getValue().assertExitCodeIs(expectedExitCode);\n@@ -299,3 +344,12 @@\n-    \/*\n-     * Repeates a \"task\" \"max\" times and waits for \"wait\" seconds between each\n-     * execution until the \"task\" returns without throwing an exception.\n+    \/**\n+     * Calls {@code task.get()} at most {@code max} times and waits for {@code wait}\n+     * seconds between each call until {@code task.get()} invocation returns without\n+     * throwing {@link RuntimeException} exception.\n+     * <p>\n+     * Returns the object returned by the first {@code task.get()} invocation that\n+     * didn't throw an exception or rethrows the last exception if all of\n+     * {@code max} attempts ended in exception being thrown.\n+     *\n+     * @param task the object of which to call {@link Supplier#get()} function\n+     * @param max  the maximum times to execute the command\n+     * @param wait number of seconds to wait between executions of the\n@@ -337,3 +391,4 @@\n-    private boolean withSavedOutput() {\n-        return saveOutputType.contains(SaveOutputType.FULL) || saveOutputType.contains(\n-                SaveOutputType.FIRST_LINE);\n+    private Executor setOutputControl(boolean set, OutputControlOption v) {\n+        outputStreamsControl.stdout().set(set, v);\n+        outputStreamsControl.stderr().set(set, v);\n+        return this;\n@@ -352,2 +407,2 @@\n-        \/\/ changing the directory. So to stay of safe side, use absolute path\n-        \/\/ to executable.\n+        \/\/ changing the directory. Use absolute path to executable to play\n+        \/\/ it safely on all platforms.\n@@ -374,0 +429,3 @@\n+\n+        outputStreamsControl.applyTo(builder);\n+\n@@ -375,11 +433,4 @@\n-        if (withSavedOutput()) {\n-            builder.redirectErrorStream(true);\n-            sb.append(\"; save output\");\n-        } else if (saveOutputType.contains(SaveOutputType.DUMP)) {\n-            builder.inheritIO();\n-            sb.append(\"; inherit I\/O\");\n-        } else {\n-            builder.redirectError(ProcessBuilder.Redirect.DISCARD);\n-            builder.redirectOutput(ProcessBuilder.Redirect.DISCARD);\n-            sb.append(\"; discard I\/O\");\n-        }\n+        outputStreamsControl.describe().ifPresent(desc -> {\n+            sb.append(\"; \").append(desc);\n+        });\n+\n@@ -417,24 +468,3 @@\n-        List<String> outputLines = null;\n-        if (withSavedOutput()) {\n-            try (BufferedReader outReader = new BufferedReader(\n-                    new InputStreamReader(process.getInputStream()))) {\n-                if (saveOutputType.contains(SaveOutputType.DUMP)\n-                        || saveOutputType.contains(SaveOutputType.FULL)) {\n-                    outputLines = outReader.lines().collect(Collectors.toList());\n-                } else {\n-                    outputLines = Optional.ofNullable(outReader.readLine()).map(List::of).orElseGet(List::of);\n-                    outReader.transferTo(Writer.nullWriter());\n-                }\n-            } finally {\n-                if (saveOutputType.contains(SaveOutputType.DUMP) && outputLines != null) {\n-                    outputLines.stream().forEach(System.out::println);\n-                    if (saveOutputType.contains(SaveOutputType.FIRST_LINE)) {\n-                        \/\/ Pick the first line of saved output if there is one\n-                        for (String line: outputLines) {\n-                            outputLines = List.of(line);\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+        final var output = combine(\n+                processProcessStream(outputStreamsControl.stdout(), process.getInputStream()),\n+                processProcessStream(outputStreamsControl.stderr(), process.getErrorStream()));\n@@ -445,6 +475,0 @@\n-        final List<String> output;\n-        if (outputLines != null) {\n-            output = Collections.unmodifiableList(outputLines);\n-        } else {\n-            output = null;\n-        }\n@@ -455,1 +479,5 @@\n-        trace(\"Execute \" + getPrintableCommandLine() + \"...\");\n+        final var sb = new StringBuilder(getPrintableCommandLine());\n+        outputStreamsControl.describe().ifPresent(desc -> {\n+            sb.append(\"; \").append(desc);\n+        });\n+        trace(\"Execute \" + sb + \"...\");\n@@ -462,2 +490,9 @@\n-    private Result createResult(int exitCode, List<String> output) {\n-        return new Result(exitCode, output, this::getPrintableCommandLine);\n+    private Result runToolProvider() throws IOException {\n+        final var toolProviderStreamConfig = ToolProviderStreamConfig.create(outputStreamsControl);\n+\n+        final var exitCode = runToolProvider(toolProviderStreamConfig);\n+\n+        final var output = combine(\n+                read(outputStreamsControl.stdout(), toolProviderStreamConfig.out()),\n+                read(outputStreamsControl.stderr(), toolProviderStreamConfig.err()));\n+        return createResult(exitCode, output);\n@@ -466,5 +501,8 @@\n-    private Result runToolProvider() throws IOException {\n-        if (!withSavedOutput()) {\n-            if (saveOutputType.contains(SaveOutputType.DUMP)) {\n-                return createResult(runToolProvider(System.out, System.err), null);\n-            }\n+    private int runToolProvider(ToolProviderStreamConfig cfg) throws IOException {\n+        try {\n+            return runToolProvider(cfg.out().ps(), cfg.err().ps());\n+        } finally {\n+            cfg.out().ps().flush();\n+            cfg.err().ps().flush();\n+        }\n+    }\n@@ -472,23 +510,18 @@\n-            PrintStream nullPrintStream = new PrintStream(new OutputStream() {\n-                @Override\n-                public void write(int b) {\n-                    \/\/ Nop\n-                }\n-            });\n-            return createResult(runToolProvider(nullPrintStream, nullPrintStream), null);\n-        }\n-\n-        try (ByteArrayOutputStream buf = new ByteArrayOutputStream();\n-                PrintStream ps = new PrintStream(buf)) {\n-            final var exitCode = runToolProvider(ps, ps);\n-            ps.flush();\n-            final List<String> output;\n-            final var bufAsString = buf.toString();\n-            try (BufferedReader bufReader = new BufferedReader(new StringReader(\n-                    bufAsString))) {\n-                if (saveOutputType.contains(SaveOutputType.FIRST_LINE)) {\n-                    output = bufReader.lines().findFirst().map(List::of).orElseGet(List::of);\n-                } else if (saveOutputType.contains(SaveOutputType.FULL)) {\n-                    output = bufReader.lines().collect(Collectors.toUnmodifiableList());\n-                } else {\n-                    output = null;\n+    private static Optional<List<String>> processProcessStream(OutputControl outputControl, InputStream in) throws IOException {\n+        List<String> outputLines = null;\n+        try (final var bufReader = new BufferedReader(new InputStreamReader(in))) {\n+            if (outputControl.dump() || outputControl.saveAll()) {\n+                outputLines = bufReader.lines().toList();\n+            } else if (outputControl.saveFirstLine()) {\n+                outputLines = Optional.ofNullable(bufReader.readLine()).map(List::of).orElseGet(List::of);\n+                \/\/ Read all input, or the started process may exit with an error (cmd.exe does so).\n+                bufReader.transferTo(Writer.nullWriter());\n+            } else {\n+                \/\/ This should be empty input stream, fetch it anyway.\n+                bufReader.transferTo(Writer.nullWriter());\n+            }\n+        } finally {\n+            if (outputControl.dump() && outputLines != null) {\n+                outputLines.forEach(System.out::println);\n+                if (outputControl.saveFirstLine()) {\n+                    outputLines = outputLines.stream().findFirst().map(List::of).orElseGet(List::of);\n@@ -496,0 +529,22 @@\n+            }\n+            if (!outputControl.save()) {\n+                outputLines = null;\n+            }\n+        }\n+        return Optional.ofNullable(outputLines);\n+    }\n+\n+    private static Optional<List<String>> read(OutputControl outputControl, CachingPrintStream cps) throws IOException {\n+        final var bufferAsString = cps.bufferContents();\n+        try (final var bufReader = new BufferedReader(new StringReader(bufferAsString.orElse(\"\")))) {\n+            if (outputControl.saveFirstLine()) {\n+                return Optional.of(bufReader.lines().findFirst().map(List::of).orElseGet(List::of));\n+            } else if (outputControl.saveAll()) {\n+                return Optional.of(bufReader.lines().toList());\n+            } else if (bufferAsString.isPresent()) {\n+                return Optional.of(List.of());\n+            } else {\n+                return Optional.empty();\n+            }\n+        }\n+    }\n@@ -497,9 +552,14 @@\n-                if (saveOutputType.contains(SaveOutputType.DUMP)) {\n-                    Stream<String> lines;\n-                    if (saveOutputType.contains(SaveOutputType.FULL)) {\n-                        lines = output.stream();\n-                    } else {\n-                        lines = new BufferedReader(new StringReader(bufAsString)).lines();\n-                    }\n-                    lines.forEach(System.out::println);\n-                }\n+    private CommandOutput combine(Optional<List<String>> out, Optional<List<String>> err) {\n+        if (out.isEmpty() && err.isEmpty()) {\n+            return new CommandOutput();\n+        } else if (out.isEmpty()) {\n+            return new CommandOutput(err, -1);\n+        } else if (err.isEmpty()) {\n+            return new CommandOutput(out, Integer.MAX_VALUE);\n+        } else {\n+            final var combined = Stream.of(out, err).map(Optional::orElseThrow).flatMap(List::stream);\n+            if (outputStreamsControl.stdout().saveFirstLine() && outputStreamsControl.stderr().saveFirstLine()) {\n+                return new CommandOutput(Optional.of(combined.findFirst().map(List::of).orElseGet(List::of)),\n+                        Integer.min(1, out.orElseThrow().size()));\n+            } else {\n+                return new CommandOutput(Optional.of(combined.toList()), out.orElseThrow().size());\n@@ -507,1 +567,0 @@\n-            return createResult(exitCode, output);\n@@ -511,0 +570,4 @@\n+    private Result createResult(int exitCode, CommandOutput output) {\n+        return new Result(exitCode, output, this::getPrintableCommandLine);\n+    }\n+\n@@ -542,0 +605,327 @@\n+    private static PrintStream nullPrintStream() {\n+        return new PrintStream(OutputStream.nullOutputStream());\n+    }\n+\n+    private record OutputStreamsControl(OutputControl stdout, OutputControl stderr) {\n+        OutputStreamsControl {\n+            Objects.requireNonNull(stdout);\n+            Objects.requireNonNull(stderr);\n+        }\n+\n+        OutputStreamsControl() {\n+            this(new OutputControl(), new OutputControl());\n+        }\n+\n+        void applyTo(ProcessBuilder pb) {\n+            pb.redirectOutput(stdout.asProcessBuilderRedirect());\n+            pb.redirectError(stderr.asProcessBuilderRedirect());\n+        }\n+\n+        Optional<String> describe() {\n+            final List<String> tokens = new ArrayList<>();\n+            if (stdout.save() || stderr.save()) {\n+                streamsLabel(\"save \", true).ifPresent(tokens::add);\n+            }\n+            if (stdout.dump() || stderr.dump()) {\n+                streamsLabel(\"inherit \", true).ifPresent(tokens::add);\n+            }\n+            streamsLabel(\"discard \", false).ifPresent(tokens::add);\n+            if (tokens.isEmpty()) {\n+                return Optional.empty();\n+            } else {\n+                return Optional.of(String.join(\"; \", tokens));\n+            }\n+        }\n+\n+        Optional<String> streamsLabel(String prefix, boolean negate) {\n+            Objects.requireNonNull(prefix);\n+            final var str = Stream.of(stdoutLabel(negate), stderrLabel(negate))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::orElseThrow)\n+                    .collect(joining(\"+\"));\n+            if (str.isEmpty()) {\n+                return Optional.empty();\n+            } else {\n+                return Optional.of(prefix + str);\n+            }\n+        }\n+\n+        private Optional<String> stdoutLabel(boolean negate) {\n+            if ((stdout.discard() && !negate) || (!stdout.discard() && negate)) {\n+                return Optional.of(\"out\");\n+            } else {\n+                return Optional.empty();\n+            }\n+        }\n+\n+        private Optional<String> stderrLabel(boolean negate) {\n+            if ((stderr.discard() && !negate) || (!stderr.discard() && negate)) {\n+                return Optional.of(\"err\");\n+            } else {\n+                return Optional.empty();\n+            }\n+        }\n+    }\n+\n+    private record CachingPrintStream(PrintStream ps, Optional<ByteArrayOutputStream> buf) {\n+        CachingPrintStream {\n+            Objects.requireNonNull(ps);\n+            Objects.requireNonNull(buf);\n+        }\n+\n+        Optional<String> bufferContents() {\n+            return buf.map(ByteArrayOutputStream::toString);\n+        }\n+\n+        static Builder build() {\n+            return new Builder();\n+        }\n+\n+        static final class Builder {\n+\n+            Builder save(boolean v) {\n+                save = v;\n+                return this;\n+            }\n+\n+            Builder discard(boolean v) {\n+                discard = v;\n+                return this;\n+            }\n+\n+            Builder dumpStream(PrintStream v) {\n+                dumpStream = v;\n+                return this;\n+            }\n+\n+            CachingPrintStream create() {\n+                final Optional<ByteArrayOutputStream> buf;\n+                if (save && !discard) {\n+                    buf = Optional.of(new ByteArrayOutputStream());\n+                } else {\n+                    buf = Optional.empty();\n+                }\n+\n+                final PrintStream ps;\n+                if (buf.isPresent() && dumpStream != null) {\n+                    ps = new PrintStream(new TeeOutputStream(List.of(buf.orElseThrow(), dumpStream)), true, dumpStream.charset());\n+                } else if (!discard) {\n+                    ps = buf.map(PrintStream::new).or(() -> Optional.ofNullable(dumpStream)).orElseGet(Executor::nullPrintStream);\n+                } else {\n+                    ps = nullPrintStream();\n+                }\n+\n+                return new CachingPrintStream(ps, buf);\n+            }\n+\n+            private boolean save;\n+            private boolean discard;\n+            private PrintStream dumpStream;\n+        }\n+    }\n+\n+    private record ToolProviderStreamConfig(CachingPrintStream out, CachingPrintStream err) {\n+        ToolProviderStreamConfig {\n+            Objects.requireNonNull(out);\n+            Objects.requireNonNull(err);\n+        }\n+\n+        static ToolProviderStreamConfig create(OutputStreamsControl cfg) {\n+            final var errCfgBuilder = cfg.stderr().buildCachingPrintStream(System.err);\n+            if (cfg.stderr().dump() && cfg.stderr().save()) {\n+                errCfgBuilder.dumpStream(System.out);\n+            }\n+            return new ToolProviderStreamConfig(\n+                    cfg.stdout().buildCachingPrintStream(System.out).create(), errCfgBuilder.create());\n+        }\n+    }\n+\n+    private static final class OutputControl {\n+\n+        boolean save() {\n+            return save.isPresent();\n+        }\n+\n+        boolean saveAll() {\n+            return save.orElse(null) == OutputControlOption.SAVE_ALL;\n+        }\n+\n+        boolean saveFirstLine() {\n+            return save.orElse(null) == OutputControlOption.SAVE_FIRST_LINE;\n+        }\n+\n+        boolean discard() {\n+            return discard || (!dump && save.isEmpty());\n+        }\n+\n+        boolean dump() {\n+            return !discard && dump;\n+        }\n+\n+        OutputControl dump(boolean v) {\n+            this.dump = v;\n+            return this;\n+        }\n+\n+        OutputControl discard(boolean v) {\n+            this.discard = v;\n+            return this;\n+        }\n+\n+        OutputControl saveAll(boolean v) {\n+            if (v) {\n+                save = Optional.of(OutputControlOption.SAVE_ALL);\n+            } else {\n+                save = Optional.empty();\n+            }\n+            return this;\n+        }\n+\n+        OutputControl saveFirstLine(boolean v) {\n+            if (v) {\n+                save = Optional.of(OutputControlOption.SAVE_FIRST_LINE);\n+            } else {\n+                save = Optional.empty();\n+            }\n+            return this;\n+        }\n+\n+        OutputControl set(boolean set, OutputControlOption v) {\n+            switch (v) {\n+            case DUMP -> dump(set);\n+            case SAVE_ALL -> saveAll(set);\n+            case SAVE_FIRST_LINE -> saveFirstLine(set);\n+            }\n+            return this;\n+        }\n+\n+        ProcessBuilder.Redirect asProcessBuilderRedirect() {\n+            if (discard()) {\n+                return ProcessBuilder.Redirect.DISCARD;\n+            } else if (dump && !save()) {\n+                return ProcessBuilder.Redirect.INHERIT;\n+            } else {\n+                return ProcessBuilder.Redirect.PIPE;\n+            }\n+        }\n+\n+        CachingPrintStream.Builder buildCachingPrintStream(PrintStream dumpStream) {\n+            Objects.requireNonNull(dumpStream);\n+            final var builder = CachingPrintStream.build().save(save()).discard(discard());\n+            if (dump()) {\n+                builder.dumpStream(dumpStream);\n+            }\n+            return builder;\n+        }\n+\n+        private boolean dump;\n+        private boolean discard;\n+        private Optional<OutputControlOption> save = Optional.empty();\n+    }\n+\n+    private static final class TeeOutputStream extends OutputStream {\n+\n+        public TeeOutputStream(Iterable<OutputStream> streams) {\n+            streams.forEach(Objects::requireNonNull);\n+            this.streams = streams;\n+        }\n+\n+        @Override\n+        public void write(int b) throws IOException {\n+            for (final var out : streams) {\n+                out.write(b);\n+            }\n+        }\n+\n+        @Override\n+        public void write(byte[] b) throws IOException {\n+            for (final var out : streams) {\n+                out.write(b);\n+            }\n+        }\n+\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            for (final var out : streams) {\n+                out.write(b, off, len);\n+            }\n+        }\n+\n+        @Override\n+        public void flush() throws IOException {\n+            forEach(OutputStream::flush);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            forEach(OutputStream::close);\n+        }\n+\n+        private void forEach(OutputStreamConsumer c) throws IOException {\n+            IOException firstEx = null;\n+            for (final var out : streams) {\n+                try {\n+                    c.accept(out);\n+                } catch (IOException e) {\n+                    if (firstEx == null) {\n+                        firstEx = e;\n+                    }\n+                }\n+            }\n+            if (firstEx != null) {\n+                throw firstEx;\n+            }\n+        }\n+\n+        @FunctionalInterface\n+        private static interface OutputStreamConsumer {\n+            void accept(OutputStream out) throws IOException;\n+        }\n+\n+        private final Iterable<OutputStream> streams;\n+    }\n+\n+    private static final class CommandOutput {\n+        CommandOutput(Optional<List<String>> lines, int stdoutLineCount) {\n+            this.lines = Objects.requireNonNull(lines);\n+            this.stdoutLineCount = stdoutLineCount;\n+        }\n+\n+        CommandOutput() {\n+            this(Optional.empty(), 0);\n+        }\n+\n+        Optional<List<String>> lines() {\n+            return lines;\n+        }\n+\n+        Optional<List<String>> stdoutLines() {\n+            if (lines.isEmpty() || stdoutLineCount < 0) {\n+                return Optional.empty();\n+            }\n+\n+            final var theLines = lines.orElseThrow();\n+            if (stdoutLineCount == theLines.size()) {\n+                return lines;\n+            } else {\n+                return Optional.of(theLines.subList(0, Integer.min(stdoutLineCount, theLines.size())));\n+            }\n+        }\n+\n+        Optional<List<String>> stderrLines() {\n+            if (lines.isEmpty() || stdoutLineCount > lines.orElseThrow().size()) {\n+                return Optional.empty();\n+            } else if (stdoutLineCount == 0) {\n+                return lines;\n+            } else {\n+                final var theLines = lines.orElseThrow();\n+                return Optional.of(theLines.subList(stdoutLineCount, theLines.size()));\n+            }\n+        }\n+\n+        private final Optional<List<String>> lines;\n+        private final int stdoutLineCount;\n+\n+        static final CommandOutput EMPTY = new CommandOutput();\n+    }\n+\n@@ -544,1 +934,1 @@\n-    private Set<SaveOutputType> saveOutputType;\n+    private OutputStreamsControl outputStreamsControl;\n@@ -551,3 +941,3 @@\n-    private static enum SaveOutputType {\n-        NONE, FULL, FIRST_LINE, DUMP\n-    };\n+    private static enum OutputControlOption {\n+        SAVE_ALL, SAVE_FIRST_LINE, DUMP\n+    }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":529,"deletions":139,"binary":false,"changes":668,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+        discardStdout = cmd.discardStdout;\n+        discardStderr = cmd.discardStderr;\n@@ -682,0 +684,12 @@\n+    public JPackageCommand discardStdout(boolean v) {\n+        verifyMutable();\n+        discardStdout = v;\n+        return this;\n+    }\n+\n+    public JPackageCommand discardStderr(boolean v) {\n+        verifyMutable();\n+        discardStderr = v;\n+        return this;\n+    }\n+\n@@ -773,0 +787,1 @@\n+                .discardStdout(discardStdout).discardStderr(discardStderr)\n@@ -1275,0 +1290,2 @@\n+    private boolean discardStdout;\n+    private boolean discardStderr;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-        List<String> output = Executor.of(\"wmic\", \"process\", \"where\", \"(name\",\n+        final var result = Executor.of(\"wmic\", \"process\", \"where\", \"(name\",\n@@ -330,2 +330,2 @@\n-                setWinRunWithEnglishOutput(true).executeAndGetOutput();\n-        if (\"No Instance(s) Available.\".equals(output.getFirst().trim())) {\n+                setWinRunWithEnglishOutput(true).execute();\n+        if (\"No Instance(s) Available.\".equals(result.stderr().findFirstLineOfOutput().map(String::trim).orElse(\"\"))) {\n@@ -335,1 +335,2 @@\n-        String[] headers = Stream.of(output.getFirst().split(\"\\\\s+\", 2)).map(\n+        final var stdout = result.stdout();\n+        String[] headers = Stream.of(stdout.getFirstLineOfOutput().split(\"\\\\s+\", 2)).map(\n@@ -337,1 +338,1 @@\n-        Pattern pattern;\n+        final Pattern pattern;\n@@ -349,1 +350,1 @@\n-        List<long[]> processes = output.stream().skip(1).map(line -> {\n+        List<long[]> processes = stdout.getOutput().stream().skip(1).map(line -> {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -240,0 +240,1 @@\n+                .discardStdout(true)\n@@ -246,1 +247,1 @@\n-        final var textVerifier = Stream.of(\n+        cmd.validateOutput(Stream.of(\n@@ -251,1 +252,1 @@\n-        }).map(CannedFormattedString::getValue).map(TKit::assertTextStream).reduce(TKit.TextStreamVerifier::andThen).orElseThrow();\n+        }).toArray(CannedFormattedString[]::new));\n@@ -253,1 +254,1 @@\n-        textVerifier.apply(cmd.saveConsoleOutput(true).execute(1).getOutput().stream().filter(Predicate.not(JPackageCommand::withTimestamp)));\n+        cmd.execute(1);\n","filename":"test\/jdk\/tools\/jpackage\/share\/BasicTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,2 @@\n-import java.io.IOException;\n+import static jdk.jpackage.test.WindowsHelper.killAppLauncherProcess;\n+\n@@ -26,3 +27,0 @@\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import jdk.jpackage.test.JPackageCommand;\n@@ -31,1 +29,1 @@\n-import static jdk.jpackage.test.WindowsHelper.killAppLauncherProcess;\n+import jdk.jpackage.test.JPackageCommand;\n@@ -51,1 +49,1 @@\n-    public void test() throws IOException, InterruptedException {\n+    public void test() throws InterruptedException {\n@@ -59,5 +57,4 @@\n-        try ( \/\/ Launch the app in a separate thread\n-                ExecutorService exec = Executors.newSingleThreadExecutor()) {\n-            exec.execute(() -> {\n-                HelloApp.executeLauncher(cmd);\n-            });\n+        \/\/ Launch the app in a separate thread\n+        new Thread(() -> {\n+            HelloApp.executeLauncher(cmd);\n+        }).start();\n@@ -65,2 +62,2 @@\n-            \/\/ Wait a bit to let the app start\n-            Thread.sleep(Duration.ofSeconds(10));\n+        \/\/ Wait a bit to let the app start\n+        Thread.sleep(Duration.ofSeconds(10));\n@@ -68,2 +65,2 @@\n-            \/\/ Find the main app launcher process and kill it\n-            killAppLauncherProcess(cmd, null, 2);\n+        \/\/ Find the main app launcher process and kill it\n+        killAppLauncherProcess(cmd, null, 2);\n@@ -71,2 +68,2 @@\n-            \/\/ Wait a bit and check if child app launcher process is still running (it must NOT)\n-            Thread.sleep(Duration.ofSeconds(5));\n+        \/\/ Wait a bit and check if child app launcher process is still running (it must NOT)\n+        Thread.sleep(Duration.ofSeconds(5));\n@@ -74,2 +71,1 @@\n-            killAppLauncherProcess(cmd, null, 0);\n-        }\n+        killAppLauncherProcess(cmd, null, 0);\n","filename":"test\/jdk\/tools\/jpackage\/windows\/Win8301247Test.java","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"}]}