{"files":[{"patch":"@@ -39,10 +39,3 @@\n-G1ServiceThread::G1ServiceThread() :\n-    ConcurrentGCThread(),\n-    _monitor(Mutex::nonleaf,\n-             \"G1ServiceThread monitor\",\n-             true,\n-             Monitor::_safepoint_check_never),\n-    _last_periodic_gc_attempt_s(os::elapsedTime()),\n-    _vtime_accum(0) {\n-  set_name(\"G1 Service\");\n-  create_and_start();\n+G1SentinelTask::G1SentinelTask() : G1ServiceTask(\"Sentinel Task\") {\n+  set_time(max_jlong);\n+  set_next(this);\n@@ -51,6 +44,2 @@\n-void G1ServiceThread::sleep_before_next_cycle() {\n-  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n-  if (!should_terminate()) {\n-    uintx waitms = G1ConcRefinementServiceIntervalMillis;\n-    ml.wait(waitms);\n-  }\n+void G1SentinelTask::execute() {\n+  guarantee(false, \"Sentinel service task should never be executed.\");\n@@ -59,7 +48,9 @@\n-bool G1ServiceThread::should_start_periodic_gc() {\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  \/\/ If we are currently in a concurrent mark we are going to uncommit memory soon.\n-  if (g1h->concurrent_mark()->cm_thread()->in_progress()) {\n-    log_debug(gc, periodic)(\"Concurrent cycle in progress. Skipping.\");\n-    return false;\n-  }\n+\/\/ Task handling periodic GCs\n+class G1PeriodicGCTask : public G1ServiceTask {\n+  bool should_start_periodic_gc() {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    \/\/ If we are currently in a concurrent mark we are going to uncommit memory soon.\n+    if (g1h->concurrent_mark()->cm_thread()->in_progress()) {\n+      log_debug(gc, periodic)(\"Concurrent cycle in progress. Skipping.\");\n+      return false;\n+    }\n@@ -67,7 +58,7 @@\n-  \/\/ Check if enough time has passed since the last GC.\n-  uintx time_since_last_gc = (uintx)g1h->time_since_last_collection().milliseconds();\n-  if ((time_since_last_gc < G1PeriodicGCInterval)) {\n-    log_debug(gc, periodic)(\"Last GC occurred \" UINTX_FORMAT \"ms before which is below threshold \" UINTX_FORMAT \"ms. Skipping.\",\n-                            time_since_last_gc, G1PeriodicGCInterval);\n-    return false;\n-  }\n+    \/\/ Check if enough time has passed since the last GC.\n+    uintx time_since_last_gc = (uintx)g1h->time_since_last_collection().milliseconds();\n+    if ((time_since_last_gc < G1PeriodicGCInterval)) {\n+      log_debug(gc, periodic)(\"Last GC occurred \" UINTX_FORMAT \"ms before which is below threshold \" UINTX_FORMAT \"ms. Skipping.\",\n+                              time_since_last_gc, G1PeriodicGCInterval);\n+      return false;\n+    }\n@@ -75,7 +66,9 @@\n-  \/\/ Check if load is lower than max.\n-  double recent_load;\n-  if ((G1PeriodicGCSystemLoadThreshold > 0.0f) &&\n-      (os::loadavg(&recent_load, 1) == -1 || recent_load > G1PeriodicGCSystemLoadThreshold)) {\n-    log_debug(gc, periodic)(\"Load %1.2f is higher than threshold %1.2f. Skipping.\",\n-                            recent_load, G1PeriodicGCSystemLoadThreshold);\n-    return false;\n+    \/\/ Check if load is lower than max.\n+    double recent_load;\n+    if ((G1PeriodicGCSystemLoadThreshold > 0.0f) &&\n+        (os::loadavg(&recent_load, 1) == -1 || recent_load > G1PeriodicGCSystemLoadThreshold)) {\n+      log_debug(gc, periodic)(\"Load %1.2f is higher than threshold %1.2f. Skipping.\",\n+                              recent_load, G1PeriodicGCSystemLoadThreshold);\n+      return false;\n+    }\n+    return true;\n@@ -84,2 +77,5 @@\n-  return true;\n-}\n+  void check_for_periodic_gc(){\n+    \/\/ If disabled, just return.\n+    if (G1PeriodicGCInterval == 0) {\n+      return;\n+    }\n@@ -87,6 +83,0 @@\n-void G1ServiceThread::check_for_periodic_gc(){\n-  \/\/ If disabled, just return.\n-  if (G1PeriodicGCInterval == 0) {\n-    return;\n-  }\n-  if ((os::elapsedTime() - _last_periodic_gc_attempt_s) > (G1PeriodicGCInterval \/ 1000.0)) {\n@@ -99,1 +89,0 @@\n-    _last_periodic_gc_attempt_s = os::elapsedTime();\n@@ -101,13 +90,2 @@\n-}\n-\n-void G1ServiceThread::run_service() {\n-  double vtime_start = os::elapsedVTime();\n-\n-  while (!should_terminate()) {\n-    sample_young_list_rs_length();\n-\n-    if (os::supports_vtime()) {\n-      _vtime_accum = (os::elapsedVTime() - vtime_start);\n-    } else {\n-      _vtime_accum = 0.0;\n-    }\n+public:\n+  G1PeriodicGCTask(const char* name) : G1ServiceTask(name) { }\n@@ -115,0 +93,1 @@\n+  virtual void execute() {\n@@ -116,2 +95,5 @@\n-\n-    sleep_before_next_cycle();\n+    \/\/ G1PeriodicGCInterval is a manageable flag and can be updated\n+    \/\/ during runtime. If no value is set, wait a second and run it\n+    \/\/ again to see if the value has been updated. Otherwise use the\n+    \/\/ real value provided.\n+    schedule(G1PeriodicGCInterval == 0 ? 1000 : G1PeriodicGCInterval);\n@@ -119,6 +101,1 @@\n-}\n-\n-void G1ServiceThread::stop_service() {\n-  MutexLocker x(&_monitor, Mutex::_no_safepoint_check_flag);\n-  _monitor.notify();\n-}\n+};\n@@ -158,4 +135,77 @@\n-void G1ServiceThread::sample_young_list_rs_length() {\n-  SuspendibleThreadSetJoiner sts;\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  G1Policy* policy = g1h->policy();\n+\/\/ Task handling young gen remembered set sampling.\n+class G1RemSetSamplingTask : public G1ServiceTask {\n+  \/\/ Sample the current length of remembered sets for young.\n+  \/\/\n+  \/\/ At the end of the GC G1 determines the length of the young gen based on\n+  \/\/ how much time the next GC can take, and when the next GC may occur\n+  \/\/ according to the MMU.\n+  \/\/\n+  \/\/ The assumption is that a significant part of the GC is spent on scanning\n+  \/\/ the remembered sets (and many other components), so this thread constantly\n+  \/\/ reevaluates the prediction for the remembered set scanning costs, and potentially\n+  \/\/ G1Policy resizes the young gen. This may do a premature GC or even\n+  \/\/ increase the young gen size to keep pause time length goal.\n+  void sample_young_list_rs_length(){\n+    SuspendibleThreadSetJoiner sts;\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    G1Policy* policy = g1h->policy();\n+\n+    if (policy->use_adaptive_young_list_length()) {\n+      G1YoungRemSetSamplingClosure cl(&sts);\n+\n+      G1CollectionSet* g1cs = g1h->collection_set();\n+      g1cs->iterate(&cl);\n+\n+      if (cl.is_complete()) {\n+        policy->revise_young_list_target_length_if_necessary(cl.sampled_rs_length());\n+      }\n+    }\n+  }\n+public:\n+  G1RemSetSamplingTask(const char* name) : G1ServiceTask(name) { }\n+  virtual void execute() {\n+    sample_young_list_rs_length();\n+    schedule(G1ConcRefinementServiceIntervalMillis);\n+  }\n+};\n+\n+G1ServiceThread::G1ServiceThread() :\n+    ConcurrentGCThread(),\n+    _monitor(Mutex::nonleaf,\n+             \"G1ServiceThread monitor\",\n+             true,\n+             Monitor::_safepoint_check_never),\n+    _task_queue(),\n+    _vtime_accum(0) {\n+  set_name(\"G1 Service\");\n+  create_and_start();\n+}\n+\n+void G1ServiceThread::register_task(G1ServiceTask* task, jlong delay) {\n+  guarantee(!task->is_registered(), \"Task already registered\");\n+  guarantee(task->next() == NULL, \"Task already in queue\");\n+\n+  log_debug(gc, task)(\"G1 Service Thread (%s) (register)\", task->name());\n+\n+  \/\/ Associate the task with the service thread.\n+  task->set_service_thread(this);\n+\n+  \/\/ Schedule the task to run after the given delay.\n+  schedule_task(task, delay);\n+\n+  \/\/ Notify the service thread that there is a new task, thread might\n+  \/\/ be waiting and the newly added task might be first in the list.\n+  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  ml.notify();\n+}\n+\n+void G1ServiceThread::schedule_task(G1ServiceTask* task, jlong delay_ms) {\n+  guarantee(task->is_registered(), \"Must be registered before scheduled\");\n+  guarantee(task->next() == NULL, \"Task already in queue\");\n+\n+  \/\/ Schedule task by setting the task time and adding it to queue.\n+  jlong delay = TimeHelper::millis_to_counter(delay_ms);\n+  task->set_time(os::elapsed_counter() + delay);\n+\n+  MutexLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  _task_queue.add_ordered(task);\n@@ -163,2 +213,45 @@\n-  if (policy->use_adaptive_young_list_length()) {\n-    G1YoungRemSetSamplingClosure cl(&sts);\n+  log_trace(gc, task)(\"G1 Service Thread (%s) (schedule) @%1.3fs\",\n+                      task->name(), TimeHelper::counter_to_seconds(task->time()));\n+}\n+\n+int64_t G1ServiceThread::time_to_next_task_ms() {\n+  assert(_monitor.owned_by_self(), \"Must be owner of lock\");\n+  assert(!_task_queue.is_empty(), \"Should not be called for empty list\");\n+\n+  jlong time_diff = _task_queue.peek()->time() - os::elapsed_counter();\n+  if (time_diff < 0) {\n+    \/\/ Run without sleeping.\n+    return 0;\n+  }\n+\n+  \/\/ Return sleep time in milliseconds.\n+  return (int64_t) TimeHelper::counter_to_millis(time_diff);\n+}\n+\n+void G1ServiceThread::sleep_before_next_cycle() {\n+  if (should_terminate()) {\n+    return;\n+  }\n+\n+  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  if (_task_queue.is_empty()) {\n+    \/\/ Sleep until new task is registered if no tasks available.\n+    log_trace(gc, task)(\"G1 Service Thread (wait for new tasks)\");\n+    ml.wait(0);\n+  } else {\n+    int64_t sleep_ms = time_to_next_task_ms();\n+    if (sleep_ms > 0) {\n+      log_trace(gc, task)(\"G1 Service Thread (wait) %1.3fs\", sleep_ms \/ 1000.0);\n+      ml.wait(sleep_ms);\n+    }\n+  }\n+}\n+\n+G1ServiceTask* G1ServiceThread::pop_due_task() {\n+  MutexLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  if (_task_queue.is_empty() || time_to_next_task_ms() != 0) {\n+    return NULL;\n+  }\n+\n+  return _task_queue.pop();\n+}\n@@ -166,2 +259,3 @@\n-    G1CollectionSet* g1cs = g1h->collection_set();\n-    g1cs->iterate(&cl);\n+void G1ServiceThread::run_task(G1ServiceTask* task) {\n+  double start = os::elapsedTime();\n+  double vstart = os::elapsedVTime();\n@@ -169,2 +263,24 @@\n-    if (cl.is_complete()) {\n-      policy->revise_young_list_target_length_if_necessary(cl.sampled_rs_length());\n+  log_debug(gc, task, start)(\"G1 Service Thread (%s) (run)\", task->name());\n+  task->execute();\n+\n+  double duration = os::elapsedVTime() - start;\n+  double vduration = os::elapsedVTime() - vstart;\n+  log_debug(gc, task)(\"G1 Service Thread (%s) (run) %1.3fms (cpu: %1.3fms)\",\n+                      task->name(), duration * MILLIUNITS, vduration * MILLIUNITS);\n+}\n+\n+void G1ServiceThread::run_service() {\n+  double vtime_start = os::elapsedVTime();\n+\n+  \/\/ Setup the tasks handeled by the service thread and\n+  \/\/ add them to the task list.\n+  G1PeriodicGCTask gc_task(\"Periodic GC Task\");\n+  register_task(&gc_task);\n+\n+  G1RemSetSamplingTask remset_task(\"Remembered Set Sampling Task\");\n+  register_task(&remset_task);\n+\n+  while (!should_terminate()) {\n+    G1ServiceTask* task = pop_due_task();\n+    if (task != NULL) {\n+      run_task(task);\n@@ -172,0 +288,106 @@\n+\n+    if (os::supports_vtime()) {\n+      _vtime_accum = (os::elapsedVTime() - vtime_start);\n+    } else {\n+      _vtime_accum = 0.0;\n+    }\n+    sleep_before_next_cycle();\n+  }\n+}\n+\n+void G1ServiceThread::stop_service() {\n+  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  ml.notify();\n+}\n+\n+G1ServiceTask::G1ServiceTask(const char* name) :\n+  _time(),\n+  _name(name),\n+  _next(NULL),\n+  _service_thread(NULL) { }\n+\n+void G1ServiceTask::set_service_thread(G1ServiceThread* thread) {\n+  _service_thread = thread;\n+}\n+\n+bool G1ServiceTask::is_registered() {\n+  return _service_thread != NULL;\n+}\n+\n+void G1ServiceTask::schedule(jlong delay_ms) {\n+  _service_thread->schedule_task(this, delay_ms);\n+}\n+\n+const char* G1ServiceTask::name() {\n+  return _name;\n+}\n+\n+void G1ServiceTask::set_time(jlong time) {\n+  assert(_next == NULL, \"Not allowed to update time while in queue\");\n+  _time = time;\n+}\n+\n+jlong G1ServiceTask::time() {\n+  return _time;\n+}\n+\n+void G1ServiceTask::set_next(G1ServiceTask* next) {\n+  _next = next;\n+}\n+\n+G1ServiceTask* G1ServiceTask::next() {\n+  return _next;\n+}\n+\n+G1ServiceTaskQueue::G1ServiceTaskQueue() : _sentinel() { }\n+\n+G1ServiceTask* G1ServiceTaskQueue::pop() {\n+  verify_task_queue();\n+\n+  G1ServiceTask* task = _sentinel.next();\n+  _sentinel.set_next(task->next());\n+  task->set_next(NULL);\n+\n+  return task;\n+}\n+\n+G1ServiceTask* G1ServiceTaskQueue::peek() {\n+  verify_task_queue();\n+  return _sentinel.next();\n+}\n+\n+bool G1ServiceTaskQueue::is_empty() {\n+  return &_sentinel == _sentinel.next();\n+}\n+\n+void G1ServiceTaskQueue::add_ordered(G1ServiceTask* task) {\n+  assert(task != NULL, \"not a valid task\");\n+  assert(task->next() == NULL, \"invariant\");\n+  assert(task->time() != max_jlong, \"invalid time for task\");\n+\n+  G1ServiceTask* current = &_sentinel;\n+  while (task->time() >= current->next()->time()) {\n+    assert(task != current, \"Task should only be added once.\");\n+    current = current->next();\n+  }\n+\n+  \/\/ Update the links.\n+  task->set_next(current->next());\n+  current->set_next(task);\n+\n+  verify_task_queue();\n+}\n+\n+#ifdef ASSERT\n+void G1ServiceTaskQueue::verify_task_queue() {\n+  G1ServiceTask* cur = _sentinel.next();\n+\n+  assert(cur != &_sentinel, \"Should never try to verify empty queue\");\n+  while (cur != &_sentinel) {\n+    G1ServiceTask* next = cur->next();\n+    assert(cur->time() <= next->time(),\n+           \"Tasks out of order, prev: %s (%1.3fs), next: %s (%1.3fs)\",\n+           cur->name(), TimeHelper::counter_to_seconds(cur->time()), next->name(), TimeHelper::counter_to_seconds(next->time()));\n+\n+    assert(cur != next, \"Invariant\");\n+    cur = next;\n@@ -174,0 +396,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":300,"deletions":77,"binary":false,"changes":377,"status":"modified"},{"patch":"@@ -31,0 +31,64 @@\n+class G1ServiceTaskQueue;\n+class G1ServiceThread;\n+\n+class G1ServiceTask : public CHeapObj<mtGC> {\n+  friend class G1ServiceTaskQueue;\n+  friend class G1ServiceThread;\n+\n+  \/\/ The next absolute time this task should be executed.\n+  jlong _time;\n+  \/\/ Name of the task.\n+  const char* _name;\n+  \/\/ Next task in the task queue.\n+  G1ServiceTask* _next;\n+  \/\/ The service thread this task is registered with.\n+  G1ServiceThread* _service_thread;\n+\n+  void set_service_thread(G1ServiceThread* thread);\n+  bool is_registered();\n+\n+public:\n+  G1ServiceTask(const char* name);\n+\n+  jlong time();\n+  const char* name();\n+  G1ServiceTask* next();\n+\n+  \/\/ Do the actual work for the task. To get added back to the\n+  \/\/ execution queue a task can call schedule(delay_ms).\n+  virtual void execute() = 0;\n+\n+protected:\n+  \/\/ Schedule the task on the associated service thread\n+  \/\/ using the provided delay in milliseconds.\n+  void schedule(jlong delay_ms);\n+\n+  \/\/ These setters are protected for use by testing and the\n+  \/\/ sentinel task only.\n+  void set_time(jlong time);\n+  void set_next(G1ServiceTask* next);\n+};\n+\n+class G1SentinelTask : public G1ServiceTask {\n+public:\n+  G1SentinelTask();\n+  virtual void execute();\n+};\n+\n+class G1ServiceTaskQueue {\n+  \/\/ The sentinel task is the entry point of this priority queue holding the\n+  \/\/ service tasks. The queue is ordered by the time the tasks are scheduled\n+  \/\/ to run. To simplify list management the sentinel task has its time set\n+  \/\/ to max_jlong, guaranteeing it to be the last task in the queue.\n+  G1SentinelTask _sentinel;\n+\n+  \/\/ Verify that the queue is ordered.\n+  void verify_task_queue() NOT_DEBUG_RETURN;\n+public:\n+  G1ServiceTaskQueue();\n+  G1ServiceTask* pop();\n+  G1ServiceTask* peek();\n+  void add_ordered(G1ServiceTask* task);\n+  bool is_empty();\n+};\n+\n@@ -36,1 +100,3 @@\n-private:\n+  friend class G1ServiceTask;\n+  \/\/ The monitor is used to ensure thread safety for the task queue\n+  \/\/ and allow other threads to signal the service thread to wake up.\n@@ -38,2 +104,1 @@\n-\n-  double _last_periodic_gc_attempt_s;\n+  G1ServiceTaskQueue _task_queue;\n@@ -43,13 +108,0 @@\n-  \/\/ Sample the current length of remembered sets for young.\n-  \/\/\n-  \/\/ At the end of the GC G1 determines the length of the young gen based on\n-  \/\/ how much time the next GC can take, and when the next GC may occur\n-  \/\/ according to the MMU.\n-  \/\/\n-  \/\/ The assumption is that a significant part of the GC is spent on scanning\n-  \/\/ the remembered sets (and many other components), so this thread constantly\n-  \/\/ reevaluates the prediction for the remembered set scanning costs, and potentially\n-  \/\/ G1Policy resizes the young gen. This may do a premature GC or even\n-  \/\/ increase the young gen size to keep pause time length goal.\n-  void sample_young_list_rs_length();\n-\n@@ -57,2 +109,0 @@\n-  void check_for_periodic_gc();\n-\n@@ -61,0 +111,4 @@\n+  \/\/ Returns the time in milliseconds until the next task is due.\n+  \/\/ Used both to determine if there are tasks ready to run and\n+  \/\/ how long to sleep when nothing is ready.\n+  int64_t time_to_next_task_ms();\n@@ -63,1 +117,5 @@\n-  bool should_start_periodic_gc();\n+  G1ServiceTask* pop_due_task();\n+  void run_task(G1ServiceTask* task);\n+\n+  \/\/ Schedule a registered task to run after the given delay.\n+  void schedule_task(G1ServiceTask* task, jlong delay);\n@@ -68,0 +126,3 @@\n+  \/\/ Register a task with the service thread and schedule it. If\n+  \/\/ no delay is specified the task is scheduled to run directly.\n+  void register_task(G1ServiceTask* task, jlong delay = 0);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":80,"deletions":19,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/autoRestore.hpp\"\n+#include \"unittest.hpp\"\n+\n+class CheckTask : public G1ServiceTask {\n+  int _execution_count;\n+  bool _reschedule;\n+\n+public:\n+  CheckTask(const char* name) :\n+      G1ServiceTask(name),\n+      _execution_count(0),\n+      _reschedule(true) { }\n+  virtual void execute() {\n+    _execution_count++;\n+    if (_reschedule) {\n+      schedule(100);\n+    }\n+  }\n+\n+  int execution_count() { return _execution_count;}\n+  void set_reschedule(bool reschedule) { _reschedule = reschedule; }\n+};\n+\n+static void stop_service_thread(G1ServiceThread* thread) {\n+  ThreadInVMfromNative tvn(JavaThread::current());\n+  thread->stop();\n+}\n+\n+\/\/ Test that a task that is added during runtime gets run.\n+TEST_VM(G1ServiceThread, test_add) {\n+  \/\/ Create thread and let it start.\n+  G1ServiceThread* st = new G1ServiceThread();\n+  os::naked_short_sleep(500);\n+\n+  CheckTask ct(\"AddAndRun\");\n+  st->register_task(&ct);\n+\n+  \/\/ Give CheckTask time to run.\n+  os::naked_short_sleep(500);\n+  stop_service_thread(st);\n+\n+  ASSERT_GT(ct.execution_count(), 0);\n+}\n+\n+\/\/ Test that a task that is added while the service thread is\n+\/\/ waiting gets run in a timely manner.\n+TEST_VM(G1ServiceThread, test_add_while_waiting) {\n+  \/\/ Make sure default tasks use long intervals so that the service thread\n+  \/\/ is doing a long wait for the next execution.\n+  AutoModifyRestore<uintx> f1(G1PeriodicGCInterval, 100000);\n+  AutoModifyRestore<uintx> f2(G1ConcRefinementServiceIntervalMillis, 100000);\n+\n+  \/\/ Create thread and let it start.\n+  G1ServiceThread* st = new G1ServiceThread();\n+  os::naked_short_sleep(500);\n+\n+  \/\/ Register a new task that should run right away.\n+  CheckTask ct(\"AddWhileWaiting\");\n+  st->register_task(&ct);\n+\n+  \/\/ Give CheckTask time to run.\n+  os::naked_short_sleep(500);\n+  stop_service_thread(st);\n+\n+  ASSERT_GT(ct.execution_count(), 0);\n+}\n+\n+\/\/ Test that a task with negative timeout is not rescheduled.\n+TEST_VM(G1ServiceThread, test_add_run_once) {\n+  \/\/ Create thread and let it start.\n+  G1ServiceThread* st = new G1ServiceThread();\n+  os::naked_short_sleep(500);\n+\n+  \/\/ Set reschedule to false to only run once.\n+  CheckTask ct(\"AddRunOnce\");\n+  ct.set_reschedule(false);\n+  st->register_task(&ct);\n+\n+  \/\/ Give CheckTask time to run.\n+  os::naked_short_sleep(500);\n+  stop_service_thread(st);\n+\n+  \/\/ Should be exactly 1 since negative timeout should\n+  \/\/ prevent rescheduling.\n+  ASSERT_EQ(ct.execution_count(), 1);\n+}\n+\n+class TestTask : public G1ServiceTask {\n+  jlong _delay_ms;\n+public:\n+  TestTask(jlong delay) :\n+      G1ServiceTask(\"TestTask\"),\n+      _delay_ms(delay) {\n+    set_time(delay);\n+  }\n+  virtual void execute() {}\n+  void update_time(jlong now, int multiplier) {\n+    set_time(now + (_delay_ms * multiplier));\n+  }\n+};\n+\n+TEST_VM(G1ServiceTaskQueue, add_ordered) {\n+  G1ServiceTaskQueue queue;\n+\n+  int num_test_tasks = 5;\n+  for (int i = 1; i <= num_test_tasks; i++) {\n+    \/\/ Create tasks with different timeout.\n+    TestTask* task = new TestTask(100 * i);\n+    queue.add_ordered(task);\n+  }\n+\n+  \/\/ Now fake a run-loop, that reschedules the tasks using a\n+  \/\/ random multiplier.\n+  for (jlong now = 0; now < 1000000; now++) {\n+    \/\/ Random multiplier is at least 1 to ensure progress.\n+    int multiplier = 1 + os::random() % 10;\n+    while (queue.peek()->time() < now) {\n+      TestTask* task = (TestTask*) queue.pop();\n+      \/\/ Update delay multiplier.\n+      task->execute();\n+      task->update_time(now, multiplier);\n+      \/\/ All additions will verify that the queue is sorted.\n+      queue.add_ordered(task);\n+    }\n+  }\n+\n+  while (!queue.is_empty()) {\n+    G1ServiceTask* task = queue.pop();\n+    delete task;\n+  }\n+}\n+\n+#ifdef ASSERT\n+TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, pop_empty,\n+    \"Should never try to verify empty queue\") {\n+  G1ServiceTaskQueue queue;\n+  queue.pop();\n+}\n+\n+TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, peek_empty,\n+    \"Should never try to verify empty queue\") {\n+  G1ServiceTaskQueue queue;\n+  queue.peek();\n+}\n+\n+TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, set_time_in_queue,\n+    \"Not allowed to update time while in queue\") {\n+  G1ServiceTaskQueue queue;\n+  TestTask a(100);\n+  queue.add_ordered(&a);\n+  \/\/ Not allowed to update time while in queue.\n+  a.update_time(500, 1);\n+}\n+\n+#endif\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1ServiceThread.cpp","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"}]}