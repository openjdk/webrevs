{"files":[{"patch":"@@ -699,1 +699,1 @@\n-INTERIM_LANGTOOLS_BASE_MODULES := java.compiler jdk.compiler jdk.javadoc\n+INTERIM_LANGTOOLS_BASE_MODULES := java.compiler jdk.compiler jdk.internal.md jdk.javadoc\n","filename":"make\/autoconf\/spec.gmk.in","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,0 +164,8 @@\n+        \/**\n+         * Used for instances of {@link RawTextTree}\n+         * representing a fragment of Markdown content.\n+         *\n+         * @since 22\n+         *\/\n+        MARKDOWN,\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/DocTree.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -250,0 +250,15 @@\n+    \/**\n+     * Visits a {@code RawTextTree} node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     *\n+     * @implSpec Visits the provided {@code RawTextTree} node\n+     * by calling {@code visitOther(node, p)}.\n+     *\n+     * @since 22\n+     *\/\n+    default R visitRawText(RawTextTree node, P p) {\n+        return visitOther(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/DocTreeVisitor.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,0 +36,5 @@\n+ * @apiNote\n+ * There is no requirement that the comment containing the tag and the comment\n+ * containing the inherited documentation should either be both Markdown comments\n+ * or both standard (not Markdown) comments.\n+ *\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/InheritDocTree.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.doctree;\n+\n+\/**\n+ * A tree node for a fragment of uninterpreted raw text content.\n+ *\n+ * <p>\n+ * The content may contain any text except that for\n+ * {@linkplain InlineTagTree inline tags}.\n+ *\n+ * <p>The format of the content is indicated by the {@linkplain #getKind() kind}\n+ * of the tree node.\n+ *\n+ * @apiNote\n+ * This class may be used to represent tree nodes containing\n+ * {@linkplain DocTree.Kind#MARKDOWN Markdown} text.\n+ * Such nodes will typically exist in a list of {@code DocTree} nodes,\n+ * along with other kinds of {@code DocTree} nodes, such as for inline tags.\n+ * When processing any such list, any non-Markdown nodes will be processed\n+ * recursively first, and then treated as opaque objects within the remaining\n+ * stream of Markdown nodes. Thus, the content of any non-Markdown nodes will\n+ * not affect how the Markdown nodes will be processed.\n+ *\n+ * @since 22\n+ *\/\n+public interface RawTextTree extends DocTree {\n+    \/**\n+     * {@return the content}\n+     *\/\n+    String getContent();\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/RawTextTree.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @author Jonathan Gibbons\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/package-info.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import com.sun.source.doctree.RawTextTree;\n@@ -292,0 +293,12 @@\n+    \/**\n+     * Creates a new {@code RawTextTree} object, to represent a fragment of uninterpreted raw text.\n+     *\n+     * @param kind the kind of text\n+     * @param code the code\n+     * @return a {@code RawTextTree} object\n+     * @throws IllegalArgumentException if the kind is not a recognized kind for raw text\n+     *\n+     * @since 22\n+     *\/\n+    RawTextTree newRawTextTree(DocTree.Kind kind, String code) throws IllegalArgumentException;\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeFactory.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -416,0 +416,16 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\n+     * @since 22\n+     *\/\n+    @Override\n+    public R visitRawText(RawTextTree node, P p) {\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeScanner.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+\n@@ -39,0 +40,1 @@\n+import com.sun.source.doctree.BlockTagTree;\n@@ -42,0 +44,2 @@\n+import com.sun.source.doctree.InlineTagTree;\n+import com.sun.source.doctree.LinkTree;\n@@ -87,0 +91,22 @@\n+    \/**\n+     * The style of a documentation comment.\n+     *\n+     * @since 22\n+     *\/\n+    public enum CommentKind {\n+        \/** The style of comments whose lines are prefixed by{@code \/\/\/}. *\/\n+        LINE,\n+        \/** The style of comments that begin with {@code \/**}. *\/\n+        BLOCK\n+    }\n+\n+    \/**\n+     * {@return the style of the documentation comment associated with a tree node.}\n+     *\n+     * @param path the path for the tree node\n+     *\n+     * @see Trees#getPath(Element)\n+     * @since 22\n+     *\/\n+    public abstract CommentKind getDocCommentKind(TreePath path);\n+\n@@ -116,4 +142,8 @@\n-     * Returns the doc comment tree of the given file. The file must be\n-     * an HTML file, in which case the doc comment tree represents the\n-     * entire contents of the file.\n-     * Returns {@code null} if no doc comment was found.\n+     * Returns the doc comment tree of the given file, which must\n+     * be of one of the supported file types.\n+     *\n+     * <p>The supported file types are:\n+     * <ul>\n+     * <li>HTML files, identified by a file name ending in {@code .html},\n+     * <li>Markdown files, identified by a file name ending in {@code .md}.\n+     * <\/ul>\n@@ -127,0 +157,2 @@\n+     * @throws IllegalArgumentException if the file type is not supported\n+     *\n@@ -132,5 +164,9 @@\n-     * Returns the doc comment tree of the given file whose path is\n-     * specified relative to the given element. The file must be an HTML\n-     * file, in which case the doc comment tree represents the contents\n-     * of the &lt;body&gt; tag, and any enclosing tags are ignored.\n-     * Returns {@code null} if no doc comment was found.\n+     * Returns the doc comment tree of the given file, which must\n+     * be of one of the supported file types, and whose path is\n+     * specified relative to the given element.\n+     *\n+     * <p>The supported file types are:\n+     * <ul>\n+     * <li>HTML files, identified by a file name ending in {@code .html},\n+     * <li>Markdown files, identified by a file name ending in {@code .md}.\n+     * <\/ul>\n@@ -145,1 +181,2 @@\n-     * @throws java.io.IOException if an exception occurs\n+     * @throws IOException if an exception occurs\n+     * @throws IllegalArgumentException if the file type is not supported\n@@ -152,3 +189,6 @@\n-     * Returns a doc tree path containing the doc comment tree of the given file.\n-     * The file must be an HTML file, in which case the doc comment tree represents\n-     * the contents of the {@code <body>} tag, and any enclosing tags are ignored.\n+     * Returns a doc tree path containing the doc comment tree of the given file,\n+     * which must be of one of the supported file types.\n+     *\n+     * Supported file types are HTML files and Markdown files.\n+     * Future releases may support additional file types.\n+     *\n@@ -164,1 +204,1 @@\n-     * @throws IllegalArgumentException if the fileObject is not an HTML file\n+     * @throws IllegalArgumentException if the file type is not supported\n@@ -255,0 +295,63 @@\n+\n+    \/**\n+     * A functional interface to transform a {@code DocCommentTree}.\n+     *\n+     * <p>An implementation may detect specific patterns within a documentation\n+     * comment and replace them with alternate forms, perhaps involving the\n+     * tree nodes for instances of {@link InlineTagTree} or {@link BlockTagTree}.\n+     *\n+     * <p>Implementations may be located by using the\n+     * {@linkplain java.util.ServiceLoader service loader}.\n+     *\n+     * @apiNote\n+     * The standard implementation of this interface supports an extended form\n+     * of reference links in Markdown comments, such that if the label for a\n+     * reference link is undefined and matches a reference to a program\n+     * element, the link is replaced by an equivalent {@link LinkTree} node.\n+     * The standard implementation is used by {@linkplain jdk.javadoc <em>javadoc<\/em>}\n+     * and related tools.\n+     *\n+     * <p>The standard implementation returns the string {@code \"standard\"}\n+     * from {@link DocCommentTreeTransformer#name()}.\n+     *\n+     * @since 22\n+     *\/\n+    public interface DocCommentTreeTransformer {\n+        \/**\n+         * {@return the name of this transformer}\n+         * @implSpec this implementation returns an empty string\n+         *\/\n+        default String name() { return \"\"; }\n+\n+        \/**\n+         * Transforms a documentation comment tree.\n+         *\n+         * @param trees an instance of the {@link Trees} utility interface.\n+         * @param tree the tree to be transformed\n+         * @return the transformed tree\n+         *\/\n+        DocCommentTree transform(DocTrees trees, DocCommentTree tree);\n+    }\n+\n+    \/**\n+     * {@return the transformer to be used after a documentation comment has been parsed,\n+     * or {@code null} if no transformer is to be used}\n+     *\n+     * @since 22\n+     *\/\n+    public abstract DocCommentTreeTransformer getDocCommentTreeTransformer();\n+\n+    \/**\n+     * Sets the transformer to be used after a documentation comment has been parsed,\n+     * or {@code null} if no transformer is to be used.\n+     *\n+     * @apiNote\n+     * This should normally be called before accessing any {@code DocCommentTree}\n+     * through this class. The effects are undefined if this method is invoked\n+     * after any {@code DocCommentTree} has been accessed.\n+     *\n+     * @param transformer the transformer\n+     *\n+     * @since 22\n+     *\/\n+    public abstract void setDocCommentTreeTransformer(DocCommentTreeTransformer transformer);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTrees.java","additions":118,"deletions":15,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -369,0 +369,16 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\n+     * @since 22\n+     *\/\n+    @Override\n+    public R visitRawText(RawTextTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleDocTreeVisitor.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-import com.sun.source.util.DocTreeScanner;\n@@ -103,0 +102,1 @@\n+import com.sun.tools.javac.parser.ReferenceParser;\n@@ -172,1 +172,0 @@\n-    private final ParserFactory parser;\n@@ -176,0 +175,3 @@\n+    private final ParserFactory parserFactory;\n+\n+    private DocCommentTreeTransformer docCommentTreeTransformer;\n@@ -217,1 +219,1 @@\n-        parser = ParserFactory.instance(context);\n+        parserFactory = ParserFactory.instance(context);\n@@ -264,14 +266,0 @@\n-    private DocTree getLastChild(DocTree tree) {\n-        final DocTree[] last = new DocTree[] {null};\n-\n-        tree.accept(new DocTreeScanner<Void, Void>() {\n-            @Override @DefinedBy(Api.COMPILER_TREE)\n-            public Void scan(DocTree node, Void p) {\n-                if (node != null) last[0] = node;\n-                return null;\n-            }\n-        }, null);\n-\n-        return last[0];\n-    }\n-\n@@ -718,2 +706,2 @@\n-        Tree t = path.getLeaf();\n-        Type ty = ((JCTree)t).type;\n+        Tree leaf = path.getLeaf();\n+        Type ty = ((JCTree) leaf).type;\n@@ -728,0 +716,16 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public CommentKind getDocCommentKind(TreePath path) {\n+        var compUnit = path.getCompilationUnit();\n+        var leaf = path.getLeaf();\n+        if (compUnit instanceof JCTree.JCCompilationUnit cu && leaf instanceof JCTree l\n+                && cu.docComments != null) {\n+            Comment c = cu.docComments.getComment(l);\n+            return (c == null) ? null : switch (c.getStyle()) {\n+                case JAVADOC_BLOCK -> DocTrees.CommentKind.BLOCK;\n+                case JAVADOC_LINE -> DocTrees.CommentKind.LINE;\n+                default -> null;\n+            };\n+        }\n+        return null;\n+    }\n+\n@@ -730,6 +734,5 @@\n-        CompilationUnitTree t = path.getCompilationUnit();\n-        Tree leaf = path.getLeaf();\n-        if (t instanceof JCTree.JCCompilationUnit compilationUnit && leaf instanceof JCTree tree) {\n-            if (compilationUnit.docComments != null) {\n-                return compilationUnit.docComments.getCommentText(tree);\n-            }\n+        var compUnit = path.getCompilationUnit();\n+        var leaf = path.getLeaf();\n+        if (compUnit instanceof JCTree.JCCompilationUnit cu && leaf instanceof JCTree l\n+                && cu.docComments != null) {\n+            return cu.docComments.getCommentText(l);\n@@ -742,6 +745,5 @@\n-        CompilationUnitTree t = path.getCompilationUnit();\n-        Tree leaf = path.getLeaf();\n-        if (t instanceof JCTree.JCCompilationUnit compilationUnit && leaf instanceof JCTree tree) {\n-            if (compilationUnit.docComments != null) {\n-                return compilationUnit.docComments.getCommentTree(tree);\n-            }\n+        var compUnit = path.getCompilationUnit();\n+        var leaf = path.getLeaf();\n+        if (compUnit instanceof JCTree.JCCompilationUnit cu && leaf instanceof JCTree l\n+                && cu.docComments != null) {\n+            return cu.docComments.getCommentTree(l);\n@@ -985,11 +987,2 @@\n-    static JavaFileObject asJavaFileObject(FileObject fileObject) {\n-        JavaFileObject jfo = null;\n-\n-        if (fileObject instanceof JavaFileObject javaFileObject) {\n-            checkHtmlKind(fileObject, Kind.HTML);\n-            return javaFileObject;\n-        }\n-\n-        checkHtmlKind(fileObject);\n-        jfo = new HtmlFileObject(fileObject);\n-        return jfo;\n+    private static boolean isHtmlFile(FileObject fo) {\n+        return fo.getName().endsWith(\".html\");\n@@ -998,2 +991,2 @@\n-    private static void checkHtmlKind(FileObject fileObject) {\n-        checkHtmlKind(fileObject, BaseFileManager.getKind(fileObject.getName()));\n+    private static boolean isMarkdownFile(FileObject fo) {\n+        return fo.getName().endsWith(\".md\");\n@@ -1002,3 +995,17 @@\n-    private static void checkHtmlKind(FileObject fileObject, JavaFileObject.Kind kind) {\n-        if (kind != JavaFileObject.Kind.HTML) {\n-            throw new IllegalArgumentException(\"HTML file expected:\" + fileObject.getName());\n+\n+    static JavaFileObject asDocFileObject(FileObject fo) {\n+        if (fo instanceof JavaFileObject jfo) {\n+            switch (jfo.getKind()) {\n+                case HTML -> {\n+                    return jfo;\n+                }\n+                case OTHER -> {\n+                    if (isMarkdownFile(jfo)) {\n+                        return jfo;\n+                    }\n+                }\n+            }\n+        } else {\n+            if (isHtmlFile(fo) || isMarkdownFile(fo)) {\n+                return new DocFileObject(fo);\n+            }\n@@ -1006,0 +1013,2 @@\n+\n+        throw new IllegalArgumentException((\"Not a documentation file: \" + fo.getName()));\n@@ -1008,1 +1017,1 @@\n-    private static class HtmlFileObject extends ForwardingFileObject<FileObject>\n+    private static class DocFileObject extends ForwardingFileObject<FileObject>\n@@ -1011,1 +1020,1 @@\n-        public HtmlFileObject(FileObject fileObject) {\n+        public DocFileObject(FileObject fileObject) {\n@@ -1038,1 +1047,1 @@\n-        JavaFileObject jfo = asJavaFileObject(fileObject);\n+        JavaFileObject jfo = asDocFileObject(fileObject);\n@@ -1061,1 +1070,3 @@\n-                throw new UnsupportedOperationException();\n+                return isHtmlFile(fileObject) ? CommentStyle.JAVADOC_BLOCK\n+                        : isMarkdownFile(fileObject) ? CommentStyle.JAVADOC_LINE\n+                        : null;\n@@ -1066,1 +1077,16 @@\n-                throw new UnsupportedOperationException();\n+                return false;\n+            }\n+\n+            private String info(FileObject fo) {\n+                try {\n+                    var text = fo.getCharContent(true).toString();\n+                    int MAX_LENGTH = 48;\n+                    String ELLIPSIS = \"...\";\n+                    return fo.getName() + \": \"\n+                            + (text.length() < MAX_LENGTH ? text\n+                                : text.substring(0, MAX_LENGTH \/ 2)\n+                                    + ELLIPSIS\n+                                    + text.substring(text.length() - MAX_LENGTH \/ 2));\n+                } catch (IOException e) {\n+                    return fo.getName() + \": \" + e;\n+                }\n@@ -1070,1 +1096,4 @@\n-        return new DocCommentParser(parser, diagSource, comment, true).parse();\n+        boolean isHtmlFile = jfo.getKind() == Kind.HTML;\n+\n+        var dct = new DocCommentParser(parserFactory, diagSource, comment, isHtmlFile).parse();\n+        return transform(dct);\n@@ -1075,1 +1104,1 @@\n-        JavaFileObject jfo = asJavaFileObject(fileObject);\n+        JavaFileObject jfo = asDocFileObject(fileObject);\n@@ -1093,0 +1122,41 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public DocCommentTreeTransformer getDocCommentTreeTransformer() {\n+        return docCommentTreeTransformer;\n+    }\n+\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public void setDocCommentTreeTransformer(DocTrees.DocCommentTreeTransformer transformer) {\n+        docCommentTreeTransformer = transformer;\n+    }\n+\n+    \/**\n+     * {@return the doc comment tree for a given comment}\n+     *\n+     * @param diagSource the source containing the comment, used when displaying any diagnostics\n+     * @param c the comment\n+     *\/\n+    public DocCommentTree getDocCommentTree(DiagnosticSource diagSource, Comment c) {\n+        var dct = new DocCommentParser(parserFactory, diagSource, c).parse();\n+        return transform(dct);\n+    }\n+\n+    \/**\n+     * Transforms the given tree using the current\n+     * {@linkplain #setDocCommentTreeTransformer(DocCommentTreeTransformer) transformer}.\n+     * If there is no current transformer, the tree is returned unmodified.\n+     *\n+     * @param tree the tree\n+     * @return the transformed tree\n+     *\/\n+    private DocCommentTree transform(DocCommentTree tree) {\n+        return docCommentTreeTransformer == null ? tree : docCommentTreeTransformer.transform(this, tree);\n+    }\n+\n+    \/**\n+     * {@return the {@linkplain ParserFactory} parser factory}.\n+     * The factory can be used to create a {@link ReferenceParser}, to parse link references.\n+     *\/\n+    public ParserFactory getParserFactory() {\n+        return parserFactory;\n+    }\n+\n@@ -1196,14 +1266,4 @@\n-            case ERROR:\n-                log.error(DiagnosticFlag.API, pos, Errors.ProcMessager(msg.toString()));\n-                break;\n-\n-            case WARNING:\n-                log.warning(pos, Warnings.ProcMessager(msg.toString()));\n-                break;\n-\n-            case MANDATORY_WARNING:\n-                log.mandatoryWarning(pos, Warnings.ProcMessager(msg.toString()));\n-                break;\n-\n-            default:\n-                log.note(pos, Notes.ProcMessager(msg.toString()));\n+                case ERROR ->             log.error(DiagnosticFlag.API, pos, Errors.ProcMessager(msg.toString()));\n+                case WARNING ->           log.warning(pos, Warnings.ProcMessager(msg.toString()));\n+                case MANDATORY_WARNING -> log.mandatoryWarning(pos, Warnings.ProcMessager(msg.toString()));\n+                default ->                log.note(pos, Notes.ProcMessager(msg.toString()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":128,"deletions":68,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.regex.Pattern;\n@@ -33,0 +34,1 @@\n+import com.sun.source.doctree.DocTree;\n@@ -79,1 +81,10 @@\n-    private enum Phase { PREAMBLE, BODY, POSTAMBLE }\n+    private enum Phase {\n+        \/** The initial part of an HTML file up to and including the {@code body} and possible {@code <main>} tag. *\/\n+        PREAMBLE,\n+        \/** The initial part of a doc comment, or the rich-text content of a block tag. *\/\n+        BODY,\n+        \/** The end of an HTML file, from and including the {@code <\/main>} or {@code <\/body>} tag. *\/\n+        POSTAMBLE,\n+        \/** The rich-text content of an inline documentation comment tag. *\/\n+        INLINE\n+    }\n@@ -87,1 +98,2 @@\n-    private final boolean isFileContent;\n+    private final boolean isHtmlFile;\n+    private final DocTree.Kind textKind;\n@@ -106,0 +118,25 @@\n+    \/**\n+     * Creates a parser for a documentation comment.\n+     *\n+     * @param fac a parser factory, for a doc-tree maker and for reference parsers\n+     * @param diagSource the source in which the comment was found\n+     * @param comment the comment\n+     *\/\n+    public DocCommentParser(ParserFactory fac, DiagnosticSource diagSource, Comment comment) {\n+        this(fac, diagSource, comment, false);\n+    }\n+\n+    \/**\n+     * Create a parser for a documentation comment.\n+     *\n+     * If the comment is the content of a standalone HTML file, it will be parsed\n+     * in three parts: a preamble (up to and including the {@code <main>} tag,\n+     * or {@code <body>} tag if there is no {@code <main>} tag, then the main content\n+     * of the file, and then finally the end part of the file starting at the\n+     * end tag matching the tag that ended the preamble.\n+     *\n+     * @param fac a parser factory, for a doc-tree maker and for reference parsers\n+     * @param diagSource the source in which the comment was found\n+     * @param comment the comment\n+     * @param isHtmlFile whether the comment is the entire content of an HTML file\n+     *\/\n@@ -107,1 +144,1 @@\n-                            Comment comment, boolean isFileContent) {\n+                            Comment comment, boolean isHtmlFile) {\n@@ -113,1 +150,2 @@\n-        this.isFileContent = isFileContent;\n+        this.isHtmlFile = isHtmlFile;\n+        textKind = isHtmlFile ? DocTree.Kind.TEXT : getTextKind(comment);\n@@ -118,2 +156,6 @@\n-    public DocCommentParser(ParserFactory fac, DiagnosticSource diagSource, Comment comment) {\n-        this(fac, diagSource, comment, false);\n+    private static DocTree.Kind getTextKind(Comment c) {\n+        return switch (c.getStyle()) {\n+            case JAVADOC_BLOCK -> DocTree.Kind.TEXT;\n+            case JAVADOC_LINE -> DocTree.Kind.MARKDOWN;\n+            default -> throw new IllegalArgumentException(c.getStyle().name());\n+        };\n@@ -131,2 +173,2 @@\n-        List<DCTree> preamble = isFileContent ? blockContent(Phase.PREAMBLE) : List.nil();\n-        List<DCTree> body = blockContent(Phase.BODY);\n+        List<DCTree> preamble = isHtmlFile ? content(Phase.PREAMBLE) : List.nil();\n+        List<DCTree> body = content(Phase.BODY);\n@@ -134,1 +176,1 @@\n-        List<DCTree> postamble = isFileContent ? blockContent(Phase.POSTAMBLE) : List.nil();\n+        List<DCTree> postamble = isHtmlFile ? content(Phase.POSTAMBLE) : List.nil();\n@@ -136,1 +178,2 @@\n-        int pos = !preamble.isEmpty() ? preamble.head.pos\n+        int pos = textKind == DocTree.Kind.MARKDOWN  ? 0\n+                : !preamble.isEmpty() ? preamble.head.pos\n@@ -148,1 +191,11 @@\n-            case '\\f', '\\n', '\\r' -> newline = true;\n+            case '\\n' -> {\n+                newline = true;\n+            }\n+\n+            case '\\r' -> {\n+                if (bp + 1 < buflen && buf[bp + 1] == '\\n') {\n+                    bp++;\n+                    ch = '\\n';\n+                }\n+                newline = true;\n+            }\n@@ -156,0 +209,13 @@\n+    String peekLine() {\n+        int p = bp;\n+        while (p < buflen) {\n+             switch (buf[p]) {\n+                 case '\\n', '\\r' -> {\n+                     return newString(bp, p);\n+                 }\n+                 default -> p++;\n+             }\n+        }\n+        return newString(bp, buflen);\n+    }\n+\n@@ -157,1 +223,4 @@\n-        return blockContent(Phase.BODY);\n+        while (ch == ' ' && bp < buflen) {\n+            nextChar();\n+        }\n+        return content(Phase.BODY);\n@@ -161,3 +230,20 @@\n-     * Read block content, consisting of text, html and inline tags.\n-     * Terminated by the end of input, or the beginning of the next block tag:\n-     * that is, @ as the first non-whitespace character on a line.\n+     * Reads \"rich text\" content, consisting of text, html and inline tags,\n+     * according to the given {@code phase}.\n+     *\n+     * Inline tags are only recognized in {@code BODY} and {@code INLINE}\n+     * phases, and not in {@code PREAMBLE} and {@code POSTAMBLE} phases.\n+     *\n+     * The end of the content is dependent on the phase:\n+     *\n+     * <ul>\n+     * <li>{@code PREAMBLE}: the appearance of {@code <body>} (or {@code <main>}),\n+     *      as determined by {@link #isEndPreamble()}\n+     * <li>{@code BODY}: the beginning of a block tag, or when readung from\n+     *      an HTML file, the appearance of {@code <\/main>} (or {@code <\/body>},\n+     *       as determined by {@link #isEndBody()}\n+     * <li>{@code INLINE}: '}', after skipping any matching {@code { }}\n+     * <li>{@code PREAMBLE}: end of file\n+     * <\/ul>\n+     *\n+     *\n+     *\n@@ -165,2 +251,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n-    protected List<DCTree> blockContent(Phase phase) {\n+    protected List<DCTree> content(Phase phase) {\n@@ -170,0 +255,6 @@\n+        int depth = 1;                  \/\/ only used when phase is INLINE\n+        int pos = bp;                   \/\/ only used when phase is INLINE\n+        LineKind lineKind = textKind == DocTree.Kind.MARKDOWN ? peekLineKind() : null;\n+\n+        if (DEBUG) System.err.println(\"starting content \" + showPos(bp) + \" \" + newline);\n+\n@@ -172,0 +263,1 @@\n+            if (DEBUG) System.err.println(\"   in content \" + showPos(bp) + \" \" + newline);\n@@ -173,2 +265,1 @@\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n+                case '\\n', '\\r' -> {\n@@ -176,1 +267,18 @@\n-                    break;\n+                    if (textKind == DocTree.Kind.MARKDOWN) {\n+\/\/                        \/\/ FIXME?\n+\/\/                        if (textStart == -1) {\n+\/\/                            textStart = bp;\n+\/\/                        }\n+                        int indent = readIndent();\n+                        \/\/ in the following, the evaluation of INDENTED_CODE_BLOCK is\n+                        \/\/ inductively a sequence of indented lines following any\n+                        \/\/ line that is not OTHER\n+                        lineKind = (ch == '\\n' || ch == '\\r') ? LineKind.BLANK\n+                                : (indent <= 3) ? peekLineKind()\n+                                : lineKind != LineKind.OTHER ? LineKind.INDENTED_CODE_BLOCK\n+                                : LineKind.OTHER;\n+                        if (lineKind == LineKind.INDENTED_CODE_BLOCK) {\n+                            skipLine();\n+                        }\n+                    }\n+                }\n@@ -178,3 +286,6 @@\n-                case '&':\n-                    entity(trees);\n-                    break;\n+                case ' ', '\\t' -> {\n+                    if (textKind == DocTree.Kind.MARKDOWN && textStart == -1) {\n+                        textStart = bp;\n+                    }\n+                    nextChar();\n+                }\n@@ -182,10 +293,29 @@\n-                case '<':\n-                    newline = false;\n-                    if (isFileContent) {\n-                        switch (phase) {\n-                            case PREAMBLE -> {\n-                                if (isEndPreamble()) {\n-                                    trees.add(html());\n-                                    if (textStart == -1) {\n-                                        textStart = bp;\n-                                        lastNonWhite = -1;\n+\n+                case '&' -> {\n+                    switch (textKind) {\n+                        case MARKDOWN -> defaultContentCharacter();\n+                        case TEXT -> entity(trees);\n+                        default -> throw unknownTextKind(textKind);\n+                    }\n+                }\n+\n+                case '<' -> {\n+                    switch (textKind) {\n+                        case MARKDOWN -> {\n+                            defaultContentCharacter();\n+                        }\n+                        case TEXT -> {\n+                            newline = false;\n+                            if (isHtmlFile) {\n+                                switch (phase) {\n+                                    case PREAMBLE -> {\n+                                        if (isEndPreamble()) {\n+                                            trees.add(html());\n+                                            if (textStart == -1) {\n+                                                textStart = bp;\n+                                                lastNonWhite = -1;\n+                                            }\n+                                            \/\/ mark this as the start, for processing purposes\n+                                            newline = true;\n+                                            break loop;\n+                                        }\n@@ -193,9 +323,7 @@\n-                                    \/\/ mark this as the start, for processing purposes\n-                                    newline = true;\n-                                    break loop;\n-                                }\n-                            }\n-                            case BODY -> {\n-                                if (isEndBody()) {\n-                                    addPendingText(trees, lastNonWhite);\n-                                    break loop;\n+                                    case BODY -> {\n+                                        if (isEndBody()) {\n+                                            addPendingText(trees, lastNonWhite);\n+                                            break loop;\n+                                        }\n+                                    }\n+                                    default -> { }\n@@ -204,0 +332,2 @@\n+                            addPendingText(trees, bp - 1);\n+                            trees.add(html());\n@@ -205,1 +335,7 @@\n-                            default -> { }\n+                            if (phase == Phase.PREAMBLE || phase == Phase.POSTAMBLE) {\n+                                break; \/\/ Ignore newlines after html tags, in the meta content\n+                            }\n+                            if (textStart == -1) {\n+                                textStart = bp;\n+                                lastNonWhite = -1;\n+                            }\n@@ -207,0 +343,1 @@\n+                        default -> throw unknownTextKind(textKind);\n@@ -208,2 +345,1 @@\n-                    addPendingText(trees, bp - 1);\n-                    trees.add(html());\n+                }\n@@ -211,6 +347,9 @@\n-                    if (phase == Phase.PREAMBLE || phase == Phase.POSTAMBLE) {\n-                        break; \/\/ Ignore newlines after html tags, in the meta content\n-                    }\n-                    if (textStart == -1) {\n-                        textStart = bp;\n-                        lastNonWhite = -1;\n+                case '{' -> {\n+                    switch (phase) {\n+                        case PREAMBLE, POSTAMBLE -> defaultContentCharacter();\n+                        case BODY -> inlineTag(trees);\n+                        case INLINE -> {\n+                            if (!inlineTag(trees)) {\n+                                depth++;\n+                            }\n+                        }\n@@ -218,1 +357,1 @@\n-                    break;\n+                }\n@@ -220,3 +359,13 @@\n-                case '{':\n-                    inlineTag(trees);\n-                    break;\n+                case '}' -> {\n+                    if (phase == Phase.INLINE) {\n+                        newline = false;\n+                        if (--depth == 0) {\n+                            addPendingText(trees, bp - 1);\n+                            nextChar();\n+                            return trees.toList();\n+                        }\n+                        nextChar();\n+                    } else {\n+                        defaultContentCharacter();\n+                    }\n+                }\n@@ -224,1 +373,2 @@\n-                case '@':\n+                case '@' -> {\n+                    if (DEBUG) System.err.println(\"  content @\");\n@@ -230,0 +380,1 @@\n+                        if (DEBUG) System.err.println(\"  content @ newline\");\n@@ -232,0 +383,1 @@\n+                            if (DEBUG) System.err.println(\"  content @ newline escape1 \" + peek);\n@@ -239,1 +391,2 @@\n-                        } else {\n+                        } else if (phase == Phase.BODY) {\n+                            if (DEBUG) System.err.println(\"  content @ newline BODY will break loop\");\n@@ -244,0 +397,1 @@\n+                        if (DEBUG) System.err.println(\"  content @ newline escape2\");\n@@ -252,1 +406,3 @@\n-                    \/\/ fallthrough\n+                    if (DEBUG) System.err.println(\"  content @ final default\");\n+                    defaultContentCharacter();\n+                }\n@@ -254,6 +410,29 @@\n-                default:\n-                    newline = false;\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    lastNonWhite = bp;\n-                    nextChar();\n+                case '`', '~' -> {\n+                    switch (textKind) {\n+                        case MARKDOWN -> {\n+                            newline = false;\n+                            if (textStart == -1) {\n+                                textStart = bp;\n+                            }\n+                            lastNonWhite = bp;\n+                            if (ch == '`' || ch == '~' && lineKind == LineKind.CODE_FENCE) {\n+                                int end = skipMarkdownCode(ch, count(ch), lineKind);\n+                                if (end == -1) {\n+                                    bp = lastNonWhite;\n+                                    nextChar();\n+                                } else {\n+                                    lastNonWhite = end - 1;\n+                                }\n+                            } else {\n+                                nextChar();\n+                            }\n+                        }\n+                        case TEXT -> {\n+                            defaultContentCharacter();\n+                        }\n+                    }\n+                }\n+\n+                default -> {\n+                    defaultContentCharacter();\n+                }\n@@ -266,1 +445,15 @@\n-        return trees.toList();\n+        return (phase == Phase.INLINE)\n+                ? List.of(erroneous(\"dc.unterminated.inline.tag\", pos))\n+                : trees.toList();\n+    }\n+\n+    void defaultContentCharacter() {\n+        newline = false;\n+        if (textStart == -1)\n+            textStart = bp;\n+        lastNonWhite = bp;\n+        nextChar();\n+    }\n+\n+    private IllegalStateException unknownTextKind(DocTree.Kind textKind) {\n+        return new IllegalStateException(textKind.toString());\n@@ -298,0 +491,1 @@\n+                    if (DEBUG) System.err.println(\"blockTag \" + tp + \" \" + showPos(bp) + \" \" + textStart);\n@@ -315,1 +509,36 @@\n-    protected void inlineTag(ListBuffer<DCTree> list) {\n+    private static final boolean DEBUG = false;\n+\n+    \/\/DEBUG\n+    String showPos(int p) {\n+        var sb = new StringBuilder();\n+        sb.append(\"[\").append(p).append(\"] \");\n+        if (p >= 0) {\n+            for (int i = Math.max(p - 10, 0); i < Math.min(p + 10, buflen); i++) {\n+                if (i == p) sb.append(\"[\");\n+                var c = buf[i];\n+                sb.append(switch (c) {\n+                    case '\\n' -> '|';\n+                    case ' ' -> '_';\n+                    default -> c;\n+                });\n+                if (i == p) sb.append(\"]\");\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Reads a possible inline tag, after finding an opening brace <code>{<\/code> character.\n+     *\n+     * If the next character is {@code @}, an opening tag is read and added to the\n+     * given {@code list}, and the result is {@code true}.\n+     *\n+     * Otherwise, the {@code list} is updated with the characters that have been read,\n+     * and the result is {@code false}. The result also indicates that a single\n+     * opening brace was read, and that a corresponding closing brace should eventually\n+     * be read.\n+     *\n+     * @param list the list of trees being accumulated\n+     * @return {@code true} if an inline tag was read, and {@code false} otherwise\n+     *\/\n+    protected boolean inlineTag(ListBuffer<DCTree> list) {\n@@ -336,0 +565,1 @@\n+                return true;\n@@ -342,0 +572,1 @@\n+        return false;\n@@ -589,1 +820,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -591,2 +821,0 @@\n-        ListBuffer<DCTree> trees = new ListBuffer<>();\n-\n@@ -594,86 +822,1 @@\n-        int pos = bp;\n-        int depth = 1;\n-        textStart = -1;\n-\n-        loop:\n-        while (bp < buflen) {\n-\n-            switch (ch) {\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n-                    nextChar();\n-                    break;\n-\n-                case '&':\n-                    entity(trees);\n-                    break;\n-\n-                case '<':\n-                    newline = false;\n-                    addPendingText(trees, bp - 1);\n-                    trees.add(html());\n-                    textStart = bp;\n-                    lastNonWhite = -1;\n-                    break;\n-\n-                case '{':\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    newline = false;\n-                    nextChar();\n-                    if (ch == '@') {\n-                        addPendingText(trees, bp - 2);\n-                        trees.add(inlineTag());\n-                        textStart = bp;\n-                        lastNonWhite = -1;\n-                    } else {\n-                        depth++;\n-                    }\n-                    break;\n-\n-                case '}':\n-                    newline = false;\n-                    if (--depth == 0) {\n-                        addPendingText(trees, bp - 1);\n-                        nextChar();\n-                        return trees.toList();\n-                    }\n-                    nextChar();\n-                    break;\n-\n-                case '@':\n-                    \/\/ check for context-sensitive escape sequences:\n-                    \/\/   newline whitespace @@\n-                    \/\/   newline whitespace @*\n-                    \/\/   *@\/\n-                    if (newline) {\n-                        char peek = peekChar();\n-                        if (peek == '@' || peek == '*') {\n-                            addPendingText(trees, bp - 1);\n-                            nextChar();\n-                            trees.add(m.at(bp - 1).newEscapeTree(ch));\n-                            newline = false;\n-                            nextChar();\n-                            textStart = bp;\n-                            break;\n-                        }\n-                    } else if (textStart != -1 && buf[bp - 1] == '*' && peekChar() == '\/') {\n-                        addPendingText(trees, bp - 1);\n-                        nextChar();\n-                        trees.add(m.at(bp - 1).newEscapeTree('\/'));\n-                        newline = false;\n-                        nextChar();\n-                        textStart = bp;\n-                        break;\n-                    }\n-                    \/\/ fallthrough\n-\n-                default:\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    nextChar();\n-                    break;\n-            }\n-        }\n-\n-        return List.of(erroneous(\"dc.unterminated.inline.tag\", pos));\n+        return content(Phase.INLINE);\n@@ -848,2 +991,10 @@\n-     * Read the start or end of an HTML tag, or an HTML comment\n-     * {@literal <identifier attrs> } or {@literal <\/identifier> }\n+     * Reads an HTML construct, beginning with {@code <}.\n+     *\n+     * <ul>\n+     * <li>start element: {@code <identifier attrs> }\n+     * <li>end element: {@code <\/identifier> }\n+     * <li>comment: {@code <!-- ... -->}\n+     * <li>doctype: {@code <!doctype ... >}\n+     * <li>cdata: {@code <![CDATA[ ... ]]>}\n+     * <\/ul>\n+     *  or\n@@ -986,1 +1137,1 @@\n-                    addPendingText(v, bp - 1);\n+                    addPendingText(v, bp - 1, DocTree.Kind.TEXT);\n@@ -994,1 +1145,1 @@\n-                    addPendingText(v, bp - 1);\n+                    addPendingText(v, bp - 1, DocTree.Kind.TEXT);\n@@ -1014,0 +1165,1 @@\n+\n@@ -1015,0 +1167,4 @@\n+        addPendingText(list, textEnd, textKind);\n+    }\n+\n+    protected void addPendingText(ListBuffer<DCTree> list, int textEnd, DocTree.Kind kind) {\n@@ -1017,1 +1173,8 @@\n-                list.add(m.at(textStart).newTextTree(newString(textStart, textEnd + 1)));\n+                switch (kind) {\n+                    case TEXT ->\n+                            list.add(m.at(textStart).newTextTree(newString(textStart, textEnd + 1)));\n+                    case MARKDOWN ->\n+                            list.add(m.at(textStart).newRawTextTree(DocTree.Kind.MARKDOWN, newString(textStart, textEnd + 1)));\n+                    default ->\n+                        throw new IllegalArgumentException(kind.toString());\n+                }\n@@ -1127,0 +1290,143 @@\n+    protected int readIndent() {\n+        int indent = 0;\n+        while (bp < buflen) {\n+            switch (ch) {\n+                case ' ' -> indent++;\n+                case '\\t' -> indent = 4;\n+                default -> {\n+                    return indent;\n+                }\n+            }\n+            nextChar();\n+        }\n+        return indent;\n+    }\n+\n+    int count(char c) {\n+        int n = 1;\n+        nextChar();\n+        while (bp < buflen && ch == c) {\n+            n++;\n+            nextChar();\n+        }\n+        return n;\n+    }\n+\n+    void skipLine() {\n+        while (bp < buflen) {\n+            if (ch == '\\n' || ch == '\\r') {\n+                return;\n+            }\n+            nextChar();\n+        }\n+    }\n+\n+    int skipMarkdownCode(char term, int count, LineKind initialLineKind) {\n+        LineKind lineKind = null;\n+        while (bp < buflen) {\n+            switch (ch) {\n+                case '\\n', '\\r' -> {\n+                    nextChar();\n+                    int indent = readIndent();\n+                    lineKind = (ch == '\\n' || ch == '\\r') ? LineKind.BLANK\n+                            : (indent <= 3) ? peekLineKind()\n+                            : LineKind.OTHER;\n+                    switch (initialLineKind) {\n+                        case CODE_FENCE -> {\n+                            if (lineKind == LineKind.CODE_FENCE && ch == term && count(ch) == count) {\n+                                return bp;\n+                            }\n+                        }\n+\n+                        case OTHER -> {\n+                            if (lineKind != LineKind.OTHER) {\n+                                return -1;\n+                            }\n+                        }\n+\n+                        default -> {\n+                            return -1;\n+                        }\n+\n+                    }\n+\n+                }\n+\n+                default -> {\n+                    if (ch == term && initialLineKind != LineKind.CODE_FENCE ) {\n+                        if (count(ch) == count) {\n+                            return bp;\n+                        }\n+                    }\n+                    nextChar();\n+                }\n+\n+            }\n+        }\n+        \/\/ found end of input\n+        return -1;\n+    }\n+\n+    enum LineKind {\n+        BLANK(Pattern.compile(\"[ \\t]*\")),\n+\n+        \/**\n+         * ATX header: starts with 1 to 6 # characters, followed by space or end of line.\n+         * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#atx-headings\">ATX Headings<\/a>\n+         *\/\n+        ATX_HEADER(Pattern.compile(\"#{1,6}( .*|$)\")),\n+\n+        \/** Setext header: underline is sequence of = or - followed by optional spaces and tabs.\n+         *  @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#setext-headings\">Setext Headings<\/a>\n+         *\/\n+        SETEXT_UNDERLINE(Pattern.compile(\"[=-]+[ \\t]*\")),\n+\n+        \/**\n+         * Thematic break: a line of + - _ interspersed with optional spaces and tabs\n+         * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#thematic-breaks\">Thematic Break<\/a>\n+         *\/\n+        THEMATIC_BREAK(Pattern.compile(\"((\\\\+[ \\t]*+){3,})|((-[ \\t]*+){3,})|((_[ \\t]*+){3,})\")),\n+\n+        \/**\n+         * Code fence: 3 or more back ticks or tildes; back tick fence cannot have back ticks\n+         * in the info string.\n+         * Note potential conflict with strikeout for similar reasons if strikeout is supported.\n+         * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#code-fence\">Code Fence<\/a>\n+         *\/\n+        CODE_FENCE(Pattern.compile(\"(`{3,}[^`]*+)|(~{3,}.*+)\")),\n+\n+        \/**\n+         * Indented code blocks are defined by preceding lines and indentation,\n+         * not by any line-specific pattern.\n+         * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#indented-code-block\">Indented Code Block<\/a>\n+         *\/\n+        INDENTED_CODE_BLOCK(null),\n+\n+        \/**\n+         * Everything else...\n+         *\/\n+        OTHER(Pattern.compile(\".*\"));\n+\n+        LineKind(Pattern p) {\n+            this.pattern = p;\n+        }\n+\n+        final Pattern pattern;\n+    }\n+\n+    LineKind peekLineKind() {\n+        switch (ch) {\n+            case '#', '=', '-', '+', '_', '`', '~' -> {\n+                String line = peekLine();\n+                for (LineKind lk : LineKind.values()) {\n+                    if (lk.pattern != null) {\n+                        if (lk.pattern.matcher(line).matches()) {\n+                            return lk;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return LineKind.OTHER;\n+    }\n+\n@@ -1562,1 +1868,1 @@\n-                                addPendingText(v, bp - 1);\n+                                addPendingText(v, bp - 1, DocTree.Kind.TEXT);\n@@ -1571,1 +1877,1 @@\n-                                addPendingText(v, bp - 1);\n+                                addPendingText(v, bp - 1, DocTree.Kind.TEXT);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":468,"deletions":162,"binary":false,"changes":630,"status":"modified"},{"patch":"@@ -1065,1 +1065,12 @@\n-                        skipToEOLN();\n+                        if (accept('\/')) { \/\/ Markdown comment\n+                            int endPos;\n+                            do {\n+                                skipToEOLN();\n+                                endPos = position();\n+                                skipLineTerminator();\n+                                skipWhitespace();\n+                             } while (accept(\"\/\/\/\"));\n+\n+                            comments = appendComment(comments, processComment(pos, endPos, CommentStyle.JAVADOC_LINE));\n+                        } else {\n+                            skipToEOLN();\n@@ -1067,2 +1078,3 @@\n-                        if (isAvailable()) {\n-                            comments = appendComment(comments, processComment(pos, position(), CommentStyle.LINE));\n+                            if (isAvailable()) {\n+                                comments = appendComment(comments, processComment(pos, position(), CommentStyle.LINE));\n+                            }\n@@ -1076,1 +1088,1 @@\n-                            style = CommentStyle.JAVADOC;\n+                            style = CommentStyle.JAVADOC_BLOCK;\n@@ -1540,0 +1552,44 @@\n+        \/**\n+         * Determine how much indent to remove from markdown comment.\n+         *\n+         * @return minimum indent to remove\n+         *\/\n+        int getMarkdownIndent() {\n+            int result = Integer.MAX_VALUE;\n+            UnicodeReader fullReader = lineReader(position(), position() + length());\n+\n+            while (fullReader.isAvailable()) {\n+                UnicodeReader line = fullReader.lineReader();\n+                line.skipWhitespace();\n+                line.accept(\"\/\/\/\");\n+                int pos = line.position();\n+                line.skipWhitespace();\n+\n+                if (line.isAvailable()) {\n+                    result = Integer.min(result, line.position() - pos);\n+                }\n+            }\n+\n+            return result == Integer.MAX_VALUE ? 0 : result;\n+        }\n+\n+        \/**\n+         * Trim the first part of the Markdown comment.\n+         *\n+         * @param indent how much indentation to remove\n+         * @param line line reader\n+         *\n+         * @return modified line reader\n+         *\/\n+        UnicodeReader trimMarkdownComment(UnicodeReader line, int indent) {\n+            int pos = line.position();\n+            line.skipWhitespace();\n+            line.accept(\"\/\/\/\");\n+\n+            for (int i = 0; line.isAvailable() && i < indent; i++) {\n+                line.next();\n+            }\n+\n+            return line;\n+        }\n+\n@@ -1556,0 +1612,3 @@\n+                boolean isMarkdown = false;\n+                int indent = 0;\n+                int start = position();\n@@ -1557,7 +1616,4 @@\n-                if (!accept(\"\/**\")) {\n-                    return;\n-                }\n-\n-                if (skip('*') != 0 && is('\/')) {\n-                    return ;\n-                }\n+                if (accept(\"\/**\")) {\n+                    if (skip('*') != 0 && is('\/')) {\n+                        return ;\n+                    }\n@@ -1565,1 +1621,1 @@\n-                skipWhitespace();\n+                    skipWhitespace();\n@@ -1567,3 +1623,10 @@\n-                if (isEOLN()) {\n-                    accept('\\r');\n-                    accept('\\n');\n+                    if (isEOLN()) {\n+                        accept('\\r');\n+                        accept('\\n');\n+                    }\n+                } else if (accept(\"\/\/\/\")) {\n+                    isMarkdown = true;\n+                    reset(start);\n+                    indent = getMarkdownIndent();\n+                } else {\n+                    return;\n@@ -1574,12 +1637,16 @@\n-                    line = trimJavadocComment(line);\n-\n-                    \/\/ If standalone @deprecated tag\n-                    int pos = line.position();\n-                    line.skipWhitespace();\n-\n-                    if (line.accept(\"@deprecated\") &&\n-                            (!line.isAvailable() ||\n-                                    line.isWhitespace() ||\n-                                    line.isEOLN() ||\n-                                    line.get() == EOI)) {\n-                        deprecatedFlag = true;\n+                    line = isMarkdown ? trimMarkdownComment(line, indent) : trimJavadocComment(line);\n+\n+                    if (cs == CommentStyle.JAVADOC_BLOCK) {\n+                        \/\/ If standalone @deprecated tag\n+                        int pos = line.position();\n+                        line.skipWhitespace();\n+\n+                        if (line.accept(\"@deprecated\") &&\n+                                (!line.isAvailable() ||\n+                                        line.isWhitespace() ||\n+                                        line.isEOLN() ||\n+                                        line.get() == EOI)) {\n+                            deprecatedFlag = true;\n+                        }\n+\n+                        line.reset(pos);\n@@ -1588,1 +1655,0 @@\n-                    line.reset(pos);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":94,"deletions":28,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import com.sun.source.doctree.DocCommentTree;\n+\n@@ -32,1 +34,0 @@\n-import com.sun.tools.javac.tree.DCTree.DCDocComment;\n@@ -47,1 +48,1 @@\n-        DCDocComment tree;\n+        DocCommentTree tree;\n@@ -82,1 +83,1 @@\n-    public DCDocComment getCommentTree(JCTree tree) {\n+    public DocCommentTree getCommentTree(JCTree tree) {\n@@ -84,1 +85,1 @@\n-        if (e == null)\n+        if (e == null) {\n@@ -86,2 +87,4 @@\n-        if (e.tree == null)\n-            e.tree = new DocCommentParser(fac, diagSource, e.comment).parse();\n+        }\n+        if (e.tree == null) {\n+            e.tree = fac.getTrees().getDocCommentTree(diagSource, e.comment);\n+        }\n@@ -95,1 +98,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/LazyDocCommentTable.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import com.sun.source.util.DocTrees;\n+import com.sun.tools.javac.api.JavacTrees;\n@@ -35,1 +37,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic;\n@@ -72,0 +73,2 @@\n+    private final JavacTrees trees;\n+\n@@ -86,0 +89,1 @@\n+        this.trees = JavacTrees.instance(context);\n@@ -96,0 +100,4 @@\n+\n+    public JavacTrees getTrees() {\n+        return trees;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ParserFactory.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -277,3 +277,4 @@\n-            LINE,       \/\/ Starting with \/\/\n-            BLOCK,      \/\/ starting with \/*\n-            JAVADOC,    \/\/ starting with \/**\n+            LINE,            \/\/ starting with \/\/   -- also known in JLS as \"end-of-line comment\"\n+            BLOCK,           \/\/ starting with \/*   -- also known in JLS as \"traditional comment\"\n+            JAVADOC_LINE,    \/\/ starting with \/\/\/\n+            JAVADOC_BLOCK    \/\/ starting with \/**\n@@ -362,1 +363,1 @@\n-            List<Comment> comments = getComments(Comment.CommentStyle.JAVADOC);\n+            List<Comment> comments = getDocComments();\n@@ -373,1 +374,1 @@\n-            for (Comment c : getComments(Comment.CommentStyle.JAVADOC)) {\n+            for (Comment c : getDocComments()) {\n@@ -381,1 +382,1 @@\n-        private List<Comment> getComments(Comment.CommentStyle style) {\n+        private List<Comment> getDocComments() {\n@@ -387,2 +388,3 @@\n-                    if (c.getStyle() == style) {\n-                        buf.add(c);\n+                    Comment.CommentStyle style = c.getStyle();\n+                    switch (style) {\n+                        case JAVADOC_BLOCK, JAVADOC_LINE -> buf.add(c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Tokens.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -161,0 +161,5 @@\n+            case MARKDOWN -> {\n+                DCRawText markdown = (DCRawText) this;\n+                return markdown.pos + markdown.code.length();\n+            }\n+\n@@ -899,0 +904,33 @@\n+    public static class DCRawText extends DCTree implements RawTextTree {\n+        public final Kind kind;\n+        public final String code;\n+\n+        DCRawText(Kind kind, String code) {\n+            if (kind != Kind.MARKDOWN) {\n+                throw new IllegalArgumentException(kind.toString());\n+            }\n+            this.kind = kind;\n+            this.code = code;\n+        }\n+\n+        @Override\n+        public boolean isBlank() {\n+            return code.isBlank();\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.MARKDOWN;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(DocTreeVisitor<R, D> v, D d) {\n+            return v.visitRawText(this, d);\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public String getContent() {\n+            return code;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DCTree.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.source.doctree.DocCommentTree;\n@@ -29,0 +30,1 @@\n+\n@@ -30,1 +32,0 @@\n-import com.sun.tools.javac.tree.DCTree.DCDocComment;\n@@ -61,1 +62,1 @@\n-    DCDocComment getCommentTree(JCTree tree);\n+    DocCommentTree getCommentTree(JCTree tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocCommentTable.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import com.sun.source.util.DocTreeScanner;\n@@ -393,0 +394,10 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public Void visitRawText(RawTextTree node, Void p) {\n+        try {\n+            print(node.getContent());\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        return null;\n+    }\n+\n@@ -630,2 +641,6 @@\n-            print(' ');\n-            print(node.getContent());\n+            var content = node.getContent();\n+            boolean isEmpty = content.stream().allMatch(n -> (n instanceof TextTree t) && t.getBody().isEmpty());\n+            if (!isEmpty) {\n+                print(' ');\n+                print(content);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocPretty.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -71,0 +73,1 @@\n+import com.sun.tools.javac.tree.DCTree.DCRawText;\n@@ -226,0 +229,4 @@\n+            \/\/ Currently, the style for a synthetic comment is not user-visible\n+            \/\/ through the {@link DocTrees} API. Nevertheless, we heuristically\n+            \/\/ infer a suitable style, based on the {@code preamble}, {@code postamble},\n+            \/\/ and {@code fullBody}.\n@@ -228,1 +235,4 @@\n-                return CommentStyle.JAVADOC;\n+                return preamble.isEmpty()\n+                        && postamble.isEmpty()\n+                        && fullBody.stream().anyMatch(t -> t.getKind() == Kind.MARKDOWN)\n+                        ? CommentStyle.JAVADOC_LINE : CommentStyle.JAVADOC_BLOCK;\n@@ -345,0 +355,7 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public DCRawText newRawTextTree(DocTree.Kind kind, String text) {\n+        DCTree.DCRawText tree = new DCRawText(kind, text);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n@@ -572,9 +589,8 @@\n-                        case TEXT -> {\n-                            var dtPos = dt.pos;\n-                            var s = ((DCText) dt).getBody();\n-                            var peekedNext = iter.hasNext()\n-                                    ? alist.get(iter.nextIndex())\n-                                    : null;\n-                            int sbreak = getSentenceBreak(s, peekedNext);\n-                            if (sbreak > 0) {\n-                                var fsPart = m.at(dtPos).newTextTree(s.substring(0, sbreak).stripTrailing());\n+                        case TEXT, MARKDOWN -> {\n+                            var peekedNext = iter.hasNext() ? alist.get(iter.nextIndex()) : null;\n+                            var content = getContent(dt);\n+                            int breakOffset = getSentenceBreak(dt.getKind(), content, peekedNext);\n+                            if (breakOffset > 0) {\n+                                \/\/ the end of sentence is within the current node;\n+                                \/\/ split it, skipping whitespace in between the two parts\n+                                var fsPart = newNode(dt.getKind(), dt.pos, content.substring(0, breakOffset).stripTrailing());\n@@ -582,3 +598,3 @@\n-                                int offsetPos = skipWhiteSpace(s, sbreak);\n-                                if (offsetPos > 0) {\n-                                    DCText bodyPart = m.at(dtPos + offsetPos).newTextTree(s.substring(offsetPos));\n+                                int wsOffset = skipWhiteSpace(content, breakOffset);\n+                                if (wsOffset > 0) {\n+                                    var bodyPart = newNode(dt.getKind(), dt.pos + wsOffset, content.substring(wsOffset));\n@@ -588,11 +604,6 @@\n-                            } else if (peekedNext != null) {\n-                                \/\/ if the next doctree is a break, remove trailing spaces\n-                                if (isSentenceBreak(peekedNext, false)) {\n-                                    DCTree next = iter.next();\n-                                    DCText fsPart = m.at(dtPos).newTextTree(s.stripTrailing());\n-                                    fs.add(fsPart);\n-                                    body.add(next);\n-                                    foundFirstSentence = true;\n-                                } else {\n-                                    fs.add(dt);\n-                                }\n+                            } else if (peekedNext != null && isSentenceBreak(peekedNext, false)) {\n+                                \/\/ the next node is a sentence break, so this is the end of the first sentence;\n+                                \/\/ remove trailing spaces\n+                                var fsPart = newNode(dt.getKind(), dt.pos, content.stripTrailing());\n+                                fs.add(fsPart);\n+                                foundFirstSentence = true;\n@@ -600,0 +611,1 @@\n+                                \/\/ no sentence break found; keep scanning\n@@ -631,21 +643,7 @@\n-        \/*\n-         * Computes the first sentence break, a simple dot-space algorithm.\n-         *\/\n-        private int defaultSentenceBreak(String s) {\n-            \/\/ scan for period followed by whitespace\n-            int period = -1;\n-            for (int i = 0; i < s.length(); i++) {\n-                switch (s.charAt(i)) {\n-                    case '.':\n-                        period = i;\n-                        break;\n-\n-                    case ' ':\n-                    case '\\f':\n-                    case '\\n':\n-                    case '\\r':\n-                    case '\\t':\n-                        if (period >= 0) {\n-                            return i;\n-                        }\n-                        break;\n+        private String getContent(DCTree dt) {\n+            return switch (dt.getKind()) {\n+                case TEXT -> ((DCText) dt).text;\n+                case MARKDOWN -> ((DCRawText) dt).code;\n+                default -> throw new IllegalArgumentException(dt.getKind().toString());\n+            };\n+        }\n@@ -653,6 +651,6 @@\n-                    default:\n-                        period = -1;\n-                        break;\n-                }\n-            }\n-            return -1;\n+        private DCTree newNode(DocTree.Kind kind, int pos, String text) {\n+            return switch (kind) {\n+                case TEXT -> m.at(pos).newTextTree(text);\n+                case MARKDOWN -> m.at(pos).newRawTextTree(kind, text);\n+                default -> throw new IllegalArgumentException(kind.toString());\n+            };\n@@ -681,1 +679,1 @@\n-        private int getSentenceBreak(String s, DCTree nextTree) {\n+        private int getSentenceBreak(DocTree.Kind kind, String s, DCTree nextTree) {\n@@ -684,1 +682,1 @@\n-                return defaultSentenceBreak(s);\n+                return defaultSentenceBreak(kind, s);\n@@ -686,1 +684,4 @@\n-            breakIterator.setText(s);\n+\n+            String s2 = normalize(kind, s);\n+            if (s2.length() != s.length()) throw new AssertionError(\"normalize\"); \/\/ DEBUG\n+            breakIterator.setText(s2);\n@@ -688,0 +689,10 @@\n+\n+            switch (kind) {\n+                case MARKDOWN -> {\n+                    int endParaPos = endParaPos(s2);\n+                    if (endParaPos != -1) {\n+                        return Math.min(sbrk, endParaPos);\n+                    }\n+                }\n+            }\n+\n@@ -693,1 +704,1 @@\n-            \/\/ If the break is well within the span of the string ie. not\n+            \/\/ If the break is well within the span of the string i.e. not\n@@ -699,12 +710,13 @@\n-            if (nextTree.getKind() == Kind.TEXT) {\n-                \/\/ Two adjacent text trees, a corner case, perhaps\n-                \/\/ produced by a tool synthesizing a doctree. In\n-                \/\/ this case, does the break lie within the first span,\n-                \/\/ then we have the droid, otherwise allow the callers\n-                \/\/ logic to handle the break in the adjacent doctree.\n-                TextTree ttnext = (TextTree) nextTree;\n-                String combined = s + ttnext.getBody();\n-                breakIterator.setText(combined);\n-                int sbrk2 = breakIterator.next();\n-                if (sbrk < sbrk2) {\n-                    return sbrk;\n+            switch (nextTree.getKind()) {\n+                case TEXT, MARKDOWN -> {\n+                    \/\/ Two adjacent text trees, a corner case, perhaps\n+                    \/\/ produced by a tool synthesizing a doctree. In\n+                    \/\/ this case, does the break lie within the first span,\n+                    \/\/ then we have the droid, otherwise allow the callers\n+                    \/\/ logic to handle the break in the adjacent doctree.\n+                    String combined = s2 + normalize(nextTree.getKind(), getContent(nextTree));\n+                    breakIterator.setText(combined);\n+                    int sbrk2 = breakIterator.next();\n+                    if (sbrk < sbrk2) {\n+                        return sbrk;\n+                    }\n@@ -731,0 +743,54 @@\n+        \/*\n+         * Computes the first sentence break, a simple dot-space algorithm.\n+         *\/\n+        private int defaultSentenceBreak(DocTree.Kind kind, String s) {\n+            String s2 = normalize(kind, s);\n+\n+            \/\/ scan for period followed by whitespace\n+            int period = -1;\n+            for (int i = 0; i < s2.length(); i++) {\n+                switch (s2.charAt(i)) {\n+                    case '.':\n+                        period = i;\n+                        break;\n+\n+                    case ' ':\n+                    case '\\f':\n+                    case '\\n':\n+                    case '\\r':\n+                    case '\\t':\n+                        if (period >= 0) {\n+                            switch (kind) {\n+                                case MARKDOWN -> {\n+                                    int endParaPos = endParaPos(s2);\n+                                    return endParaPos == -1 || i < endParaPos ? i : endParaPos;\n+                                }\n+                                case TEXT -> {\n+                                    return i;\n+                                }\n+                                default -> throw new IllegalArgumentException(kind.toString());\n+                            }\n+                        }\n+                        break;\n+\n+                    default:\n+                        period = -1;\n+                        break;\n+                }\n+            }\n+\n+            return switch (kind) {\n+                case MARKDOWN -> endParaPos(s2); \/\/ may be -1\n+                case TEXT -> -1;\n+                default -> throw new IllegalArgumentException(kind.toString());\n+            };\n+        }\n+\n+        \/\/ end of paragraph is newline, followed by a blank line or the beginning of the next block\n+        private static final Pattern endPara = Pattern.compile(\"\\n(([ \\t]*\\n)|( {0,3}[-+*#=]))\");\n+\n+        private static int endParaPos(String s) {\n+            Matcher m = endPara.matcher(s);\n+            return m.find() ? m.start() : -1;\n+        }\n+\n@@ -760,0 +826,66 @@\n+\n+        private String normalize(DocTree.Kind kind, String s) {\n+            return switch (kind) {\n+                case TEXT -> s;\n+                case MARKDOWN -> normalizeMarkdown(s);\n+                default -> throw new IllegalArgumentException(kind.toString());\n+            };\n+        }\n+\n+        private String normalizeMarkdown(String s) {\n+            StringBuilder sb = new StringBuilder();\n+            int slen = s.length();\n+            int i = 0;\n+            while (i < slen) {\n+                char ch = s.charAt(i);\n+                switch (ch) {\n+                    case '\\\\' -> {\n+                        sb.append(ch);\n+                        i++;\n+                        if (i < slen) {\n+                            sb.append(s.charAt(i));\n+                            i++;\n+                        }\n+                    }\n+\n+                    case '<' -> i = skip(sb, s, i, ch, '>');\n+                    case '[' -> i = skip(sb, s, i, ch, ']');\n+                    case '(' -> i = skip(sb, s, i, ch, ')');\n+\n+                    case '`' -> {\n+                        int start = i;\n+                        i++;\n+                        while (i < slen && s.charAt(i) == '`') {\n+                            i++;\n+                        }\n+                        String prefix = s.substring(start, i);\n+                        sb.append(prefix);\n+                        int j = s.indexOf(prefix, i);\n+                        if (j > i) {\n+                            sb.append(s.substring(i, j).replace('.', '-'));\n+                            sb.append(prefix);\n+                            i = j + prefix.length();\n+                        }\n+                    }\n+\n+                    default -> {\n+                        sb.append(ch);\n+                        i++;\n+                    }\n+                }\n+            }\n+\n+            return sb.toString();\n+        }\n+\n+        private int skip(StringBuilder sb, String s, int i, char ch, char term) {\n+            sb.append(ch);\n+            i++;\n+            int j = s.indexOf(term, i);\n+            if (j != -1) {\n+                sb.append(s.substring(i, j).replace('.', '-'));\n+                return j;\n+            } else {\n+                return i;\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocTreeMaker.java","additions":199,"deletions":67,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -406,7 +406,0 @@\n-    public static DCTree.DCDocComment getCommentTree(Env<?> env, JCTree tree) {\n-        DocCommentTable docComments = (tree.hasTag(JCTree.Tag.TOPLEVEL))\n-                ? ((JCCompilationUnit) tree).docComments\n-                : env.toplevel.docComments;\n-        return (docComments == null) ? null : docComments.getCommentTree(tree);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -233,1 +233,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.internal.md;\n@@ -253,1 +254,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.internal.md;\n@@ -259,1 +261,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.internal.md;\n@@ -263,1 +266,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.internal.md;\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,951 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.markdown;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.DocTreeVisitor;\n+import com.sun.source.doctree.RawTextTree;\n+import com.sun.source.util.DocTreeScanner;\n+import com.sun.source.util.DocTrees;\n+\n+import com.sun.tools.javac.api.JavacTrees;\n+import com.sun.tools.javac.parser.ReferenceParser;\n+import com.sun.tools.javac.tree.DCTree;\n+import com.sun.tools.javac.tree.DocTreeMaker;\n+import com.sun.tools.javac.util.DefinedBy;\n+\n+import jdk.internal.org.commonmark.ext.gfm.tables.TablesExtension;\n+import jdk.internal.org.commonmark.internal.InlineParserImpl;\n+import jdk.internal.org.commonmark.node.AbstractVisitor;\n+import jdk.internal.org.commonmark.node.Link;\n+import jdk.internal.org.commonmark.node.LinkReferenceDefinition;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.node.Text;\n+import jdk.internal.org.commonmark.parser.IncludeSourceSpans;\n+import jdk.internal.org.commonmark.parser.InlineParser;\n+import jdk.internal.org.commonmark.parser.InlineParserContext;\n+import jdk.internal.org.commonmark.parser.InlineParserFactory;\n+import jdk.internal.org.commonmark.parser.Parser;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+\n+import static com.sun.tools.javac.util.Position.NOPOS;\n+\n+\/**\n+ * A class to transform a {@code DocTree} node into a similar one with\n+ * doc-comment \"extensions\" translated into equivalent standard {@code DocTree} nodes.\n+ *\n+ * <p>The primary extension is to allow references to program elements to be\n+ * translated to {@code {@link ...}} or {@code {@linkplain ...}} tags.\n+ *\/\n+public class MarkdownTransformer implements DocTrees.DocCommentTreeTransformer {\n+\n+    \/**\n+     * Public no-args constructor, suitable for use with {@link java.util.ServiceLoader}.\n+     *\/\n+    public MarkdownTransformer() { }\n+\n+    public String name() {\n+        return \"standard\";\n+    }\n+\n+    @Override @DefinedBy(DefinedBy.Api.COMPILER_TREE)\n+    public DocCommentTree transform(DocTrees trees, DocCommentTree tree) {\n+        if (!(trees instanceof JavacTrees t)) {\n+            throw new IllegalArgumentException(\"class not supported: \" + trees.getClass());\n+        }\n+        if (!(tree instanceof DCTree.DCDocComment dc)) {\n+            throw new IllegalArgumentException(\"class not supported: \" + tree.getClass());\n+        }\n+\n+        return isMarkdown(dc) ? new DCTransformer(t).transform(dc) : dc;\n+    }\n+\n+    private boolean isMarkdown(DocCommentTree node) {\n+        return isMarkdownVisitor.visitDocComment(node, null);\n+    }\n+\n+    \/**\n+     * A fast scanner for detecting Markdown nodes in documentation comment nodes.\n+     * The scanner returns as soon as any Markdown node is found.\n+     *\/\n+    private static final DocTreeVisitor<Boolean, Void> isMarkdownVisitor = new DocTreeScanner<Boolean,Void>() {\n+        @Override\n+        public Boolean scan(Iterable<? extends DocTree> nodes, Void ignore) {\n+            if (nodes != null) {\n+                boolean first = true;\n+                for (DocTree node : nodes) {\n+                    Boolean b = scan(node, ignore);\n+                    if (b == Boolean.TRUE) {\n+                        return b;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean scan(DocTree node, Void ignore) {\n+            return node != null && node.getKind() == DocTree.Kind.MARKDOWN ? Boolean.TRUE : super.scan(node, ignore);\n+        }\n+\n+        @Override\n+        public Boolean reduce(Boolean r1, Boolean r2) {\n+            return r1 == Boolean.TRUE || r2 == Boolean.TRUE;\n+        }\n+    };\n+\n+    private static final char PLACEHOLDER = '\\uFFFC'; \/\/ Unicode Object Replacement Character\n+\n+    private static class DCTransformer {\n+        private final DocTreeMaker m;\n+        private final ReferenceParser refParser;\n+\n+        DCTransformer(JavacTrees t) {\n+            m = t.getDocTreeFactory();\n+            refParser = new ReferenceParser(t.getParserFactory());\n+        }\n+\n+        \/**\n+         * Transforms a doc tree node.\n+         * This node dispatches to a more specific overload, based on the kind of the node.\n+         * The result may be the same as the argument if no transformations were made.\n+         *\n+         * @param tree the tree node\n+         * @return a tree with any \"extensions\" converted into tags\n+         *\/\n+        public DCTree transform(DCTree tree) {\n+            \/\/ The following switch statement could eventually be converted to a\n+            \/\/ pattern switch. It is intended to be a total switch, with a default\n+            \/\/ to catch any omissions.\n+            return switch (tree.getKind()) {\n+                \/\/ The following cannot contain Markdown and so always transform to themselves.\n+                case ATTRIBUTE,\n+                        CODE, COMMENT,\n+                        DOC_ROOT, DOC_TYPE,\n+                        END_ELEMENT, ENTITY, ERRONEOUS, ESCAPE,\n+                        IDENTIFIER, INHERIT_DOC,\n+                        LITERAL,\n+                        REFERENCE,\n+                        SNIPPET, START_ELEMENT, SYSTEM_PROPERTY,\n+                        TEXT,\n+                        VALUE -> tree;\n+\n+                \/\/ The following may contain Markdown in at least one of their fields.\n+                case AUTHOR -> transform((DCTree.DCAuthor) tree);\n+                case DEPRECATED -> transform((DCTree.DCDeprecated) tree);\n+                case DOC_COMMENT -> transform((DCTree.DCDocComment) tree);\n+                case EXCEPTION, THROWS -> transform((DCTree.DCThrows) tree);\n+                case HIDDEN -> transform((DCTree.DCHidden) tree);\n+                case INDEX -> transform((DCTree.DCIndex) tree);\n+                case LINK, LINK_PLAIN -> transform((DCTree.DCLink) tree);\n+                case PARAM -> transform((DCTree.DCParam) tree);\n+                case PROVIDES -> transform((DCTree.DCProvides) tree);\n+                case RETURN -> transform((DCTree.DCReturn) tree);\n+                case SEE -> transform((DCTree.DCSee) tree);\n+                case SERIAL -> transform((DCTree.DCSerial) tree);\n+                case SERIAL_DATA -> transform((DCTree.DCSerialData) tree);\n+                case SERIAL_FIELD -> transform((DCTree.DCSerialField) tree);\n+                case SINCE -> transform((DCTree.DCSince) tree);\n+                case SPEC -> transform((DCTree.DCSpec) tree);\n+                case SUMMARY -> transform((DCTree.DCSummary) tree);\n+                case UNKNOWN_BLOCK_TAG -> transform((DCTree.DCUnknownBlockTag) tree);\n+                case UNKNOWN_INLINE_TAG -> transform((DCTree.DCUnknownInlineTag) tree);\n+                case USES -> transform((DCTree.DCUses) tree);\n+                case VERSION -> transform((DCTree.DCVersion) tree);\n+\n+                \/\/ This should never be handled directly; instead it should be handled as part of\n+                \/\/   transform(List<? extends DocTree>);\n+                \/\/ because a Markdown node has the potential to be split into multiple nodes.\n+                case MARKDOWN -> throw new IllegalArgumentException(tree.getKind().toString());\n+\n+                \/\/ Catch in case new kinds are added\n+                default -> throw new IllegalArgumentException(tree.getKind().toString());\n+            };\n+        }\n+\n+        \/**\n+         * Transforms a list of doc tree nodes.\n+         * If any of the nodes contain Markdown, the Markdown source is parsed\n+         * and analyzed for any transformations.\n+         * Any non-Markdown nodes are individually transformed.\n+         *\n+         * @param trees the list of tree nodes to be transformed\n+         * @return the transformed list\n+         *\/\n+        private List<? extends DCTree> transform(List<? extends DCTree> trees) {\n+            boolean hasMarkdown = trees.stream().anyMatch(t -> t.getKind() == DocTree.Kind.MARKDOWN);\n+            if (hasMarkdown) {\n+                var sourceBuilder = new StringBuilder();\n+                var replacements = new ArrayList<>();\n+\n+                \/*\n+                 * Step 1: Convert the trees into a string containing Markdown text,\n+                 *         using Unicode Object Replacement characters to mark the positions\n+                 *         of non-Markdown content.\n+                 *\/\n+                for (DCTree tree : trees) {\n+                    if (tree instanceof RawTextTree t) {\n+                        if (t.getKind() != DocTree.Kind.MARKDOWN) {\n+                            throw new IllegalStateException(t.getKind().toString());\n+                        }\n+                        String code = t.getContent();\n+                        \/\/ handle the (unlikely) case of FFFC characters existing in the code\n+                        int start = 0;\n+                        int pos;\n+                        while ((pos = code.indexOf(PLACEHOLDER, start)) != -1) {\n+                            sourceBuilder.append(code, start, pos);\n+                            sourceBuilder.append(PLACEHOLDER);\n+                            replacements.add(PLACEHOLDER);\n+                            start = pos + 1;\n+                        }\n+                        sourceBuilder.append(code.substring(start));\n+                    } else {\n+                        replacements.add(transform(tree));\n+                        sourceBuilder.append(PLACEHOLDER);\n+                    }\n+                }\n+\n+                \/*\n+                 * Step 2: Build a parser, and configure it to accept additional syntactic constructs,\n+                 *         such as reference-style links to program elements.\n+                 *\/\n+                String source = sourceBuilder.toString();\n+                Parser parser = Parser.builder()\n+                        .extensions(List.of(TablesExtension.create()))\n+                        .inlineParserFactory(new AutoRefInlineParserFactory(refParser))\n+                        .includeSourceSpans(IncludeSourceSpans.BLOCKS_AND_INLINES)\n+                        .build();\n+                Node document = parser.parse(source);\n+\n+                \/*\n+                 * Step 3: Analyze the parsed tree, converting it back to a list of DocTree nodes,\n+                 *         consisting of Markdown text interspersed with any pre-existing\n+                 *         DocTree nodes, as well as any new nodes created by converting\n+                 *         parts of the Markdown tree into nodes for old-style javadoc tags.\n+                 *\/\n+                Lower v = new Lower(m, document, source, replacements);\n+                document.accept(v);\n+\n+                return v.getTrees();\n+\n+            } else {\n+                var list2 = trees.stream()\n+                        .map(this::transform)\n+                        .toList();\n+                return equal(list2, trees) ? trees : list2;\n+            }\n+        }\n+\n+        \/\/-----------------------------------------------------------------------------\n+        \/\/\n+        \/\/ The following {@code transform} methods invoke {@code transform} on\n+        \/\/ any children that may contain Markdown. If the transformations on\n+        \/\/ the children are all identify transformations (that is the result\n+        \/\/ of the transformations are the same as the originals) then the\n+        \/\/ result of the overall transform is the original object. But if\n+        \/\/ any transformation on the children is not an identity transformation\n+        \/\/ then the result is a new node containing the transformed values.\n+        \/\/\n+        \/\/ Thus, we only duplicate the parts of the tree that have changed,\n+        \/\/ and we do not duplicate the parts of the tree that have not changed.\n+\n+        private DCTree.DCAuthor transform(DCTree.DCAuthor tree) {\n+            var name2 = transform(tree.name);\n+            return (equal(name2, tree.name))\n+                    ? tree\n+                    : m.at(tree.pos).newAuthorTree(name2);\n+        }\n+\n+        private DCTree.DCDeprecated transform(DCTree.DCDeprecated tree) {\n+            var body2 = transform(tree.body);\n+            return (equal(body2, tree.body))\n+                    ? tree\n+                    : m.at(tree.pos).newDeprecatedTree(body2);\n+        }\n+\n+        public DCTree.DCDocComment transform(DCTree.DCDocComment tree) {\n+            var fullBody2 = transform(tree.fullBody);\n+            var tags2 = transform(tree.tags);\n+            \/\/ Note: preamble and postamble only appear in HTML files, so should always be\n+            \/\/ null or empty for doc comments and\/or Markdown files\n+            var pre2 = transform(tree.preamble);\n+            var post2 = transform(tree.postamble);\n+            return (equal(fullBody2, tree.fullBody) && equal(tags2, tree.tags)\n+                    && equal(pre2, tree.preamble) && equal(post2, tree.postamble))\n+                    ? tree\n+                    : m.at(tree.pos).newDocCommentTree(tree.comment, fullBody2, tags2, pre2, post2);\n+        }\n+\n+        private DCTree.DCHidden transform(DCTree.DCHidden tree) {\n+            var body2 = transform(tree.body);\n+            return (equal(body2, tree.body))\n+                    ? tree\n+                    : m.at(tree.pos).newHiddenTree(body2);\n+        }\n+\n+        private DCTree.DCIndex transform(DCTree.DCIndex tree) {\n+            \/\/ The public API permits a DocTree, although in the implementation, it is always a TextTree.\n+            var term2 = transform(tree.term);\n+            var desc2 = transform(tree.description);\n+            return (equal(term2, tree.term) && equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newIndexTree(term2, desc2).setEndPos(tree.getEndPos());\n+        }\n+\n+        private DCTree.DCLink transform(DCTree.DCLink tree) {\n+            var label2 = transform(tree.label);\n+            return (equal(label2, tree.label))\n+                    ? tree\n+                    : switch (tree.getKind()) {\n+                case LINK -> m.at(tree.pos).newLinkTree(tree.ref, label2).setEndPos(tree.getEndPos());\n+                case LINK_PLAIN -> m.at(tree.pos).newLinkPlainTree(tree.ref, label2).setEndPos(tree.getEndPos());\n+                default -> throw new IllegalArgumentException(tree.getKind().toString());\n+            };\n+        }\n+\n+        private DCTree.DCParam transform(DCTree.DCParam tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newParamTree(tree.isTypeParameter, tree.name, desc2);\n+        }\n+\n+        private DCTree.DCProvides transform(DCTree.DCProvides tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newProvidesTree(tree.serviceType, desc2);\n+        }\n+\n+        private DCTree.DCReturn transform(DCTree.DCReturn tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newReturnTree(tree.inline, desc2).setEndPos(tree.getEndPos());\n+        }\n+\n+        private DCTree.DCSee transform(DCTree.DCSee tree) {\n+            List<? extends DocTree> ref2 = transform(tree.reference);\n+            return (equal(ref2, tree.getReference()))\n+                    ? tree\n+                    : m.at(tree.pos).newSeeTree(ref2);\n+        }\n+\n+        private DCTree.DCSerial transform(DCTree.DCSerial tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newSerialTree(desc2);\n+        }\n+\n+        private DCTree.DCSerialData transform(DCTree.DCSerialData tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newSerialDataTree(desc2);\n+        }\n+\n+        private DCTree.DCSerialField transform(DCTree.DCSerialField tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newSerialFieldTree(tree.name, tree.type, desc2);\n+        }\n+\n+        DCTree.DCSince transform(DCTree.DCSince tree) {\n+            var body2 = transform(tree.body);\n+            return (equal(body2, tree.body))\n+                    ? tree\n+                    : m.at(tree.pos).newSinceTree(body2);\n+        }\n+\n+        private DCTree.DCSpec transform(DCTree.DCSpec tree) {\n+            var title2 = transform(tree.title);\n+            return (equal(title2, tree.title))\n+                    ? tree\n+                    : m.at(tree.pos).newSpecTree(tree.uri, title2);\n+        }\n+\n+        private DCTree.DCSummary transform(DCTree.DCSummary tree) {\n+            var summ2 = transform(tree.summary);\n+            return (equal(summ2, tree.summary))\n+                    ? tree\n+                    : m.at(tree.pos).newSummaryTree(summ2).setEndPos(tree.getEndPos());\n+        }\n+\n+        private DCTree.DCThrows transform(DCTree.DCThrows tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : switch (tree.getKind()) {\n+                case EXCEPTION -> m.at(tree.pos).newExceptionTree(tree.name, desc2);\n+                case THROWS -> m.at(tree.pos).newThrowsTree(tree.name, desc2);\n+                default -> throw new IllegalArgumentException(tree.getKind().toString());\n+            };\n+        }\n+\n+        private DCTree.DCUnknownBlockTag transform(DCTree.DCUnknownBlockTag tree) {\n+            var cont2 = transform(tree.content);\n+            return (equal(cont2, tree.content))\n+                    ? tree\n+                    : m.at(tree.pos).newUnknownBlockTagTree(tree.name, cont2);\n+        }\n+\n+        private DCTree.DCUnknownInlineTag transform(DCTree.DCUnknownInlineTag tree) {\n+            var cont2 = transform(tree.content);\n+            return (equal(cont2, tree.content))\n+                    ? tree\n+                    : m.at(tree.pos).newUnknownInlineTagTree(tree.name, cont2).setEndPos(tree.getEndPos());\n+        }\n+\n+        private DCTree.DCUses transform(DCTree.DCUses tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newUsesTree(tree.serviceType, desc2);\n+        }\n+\n+        private DCTree.DCVersion transform(DCTree.DCVersion tree) {\n+            var body2 = transform(tree.body);\n+            return (equal(body2, tree.body))\n+                    ? tree\n+                    : m.at(tree.pos).newVersionTree(body2);\n+        }\n+\n+        \/**\n+         * Shallow \"equals\" for two doc tree nodes.\n+         *\n+         * @param <T> the type of the items\n+         * @param item1 the first item\n+         * @param item2 the second item\n+         * @return {@code true} if the items are reference-equal, and {@code false} otherwise\n+         *\/\n+        private static <T extends DocTree> boolean equal(T item1, T item2) {\n+            return item1 == item2;\n+        }\n+\n+        \/**\n+         * Shallow \"equals\" for two lists of doc tree nodes.\n+         *\n+         * @param <T> the type of the items\n+         * @param list1 the first item\n+         * @param list2 the second item\n+         * @return {@code true} if the items are reference-equal, and {@code false} otherwise\n+         *\/\n+        private static <T extends DocTree> boolean equal(List<? extends T> list1, List<? extends T> list2) {\n+            if (list1 == null || list2 == null) {\n+                return (list1 == list2);\n+            }\n+\n+            if (list1.size() != list2.size()) {\n+                return false;\n+            }\n+\n+            var iter1 = list1.iterator();\n+            var iter2 = list2.iterator();\n+            while (iter1.hasNext()) {\n+                var item1 = iter1.next();\n+                var item2 = iter2.next();\n+                if (item1 != item2) {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+    }\n+\n+    private static final String AUTOREF_PREFIX = \"code:\";\n+\n+    \/**\n+     * An {@code InlineParserFactory} that checks any unresolved link references in\n+     * reference links. If an unresolved link reference appears to be a reference to a\n+     * program element, such as may be used in {@code @see ...} or {@code {@link ...}}\n+     * tags, it generates a synthetic {@code LinkReferenceDefinition}.\n+     *\n+     * The reference is not validated to ensure it refers to any existing element.\n+     *\n+     * The primary function of this {@code InlineParserFactory} is to provide\n+     * a custom implementation of an {@code InlineParserContext} via the\n+     * {@code create(InlineParserContext inlineParserContext)} method.\n+     * It is this {@code InlineParserContext} that actually manages the set\n+     * of link reference definitions.\n+     *\n+     * This {@code InlineParserFactory} is intended to be registered with a\n+     * {@code Parser.Builder} using {@code setInlineParserFactory}.\n+     *\/\n+    private static class AutoRefInlineParserFactory implements InlineParserFactory {\n+        private final ReferenceParser refParser;\n+\n+        AutoRefInlineParserFactory(ReferenceParser refParser) {\n+            this.refParser = refParser;\n+        }\n+\n+        \/**\n+         * Creates a parser with a modified {@code InlineParserContext} that\n+         * delegates to the standard {@code InlineParserContext} and also\n+         * checks unresolved link references.\n+         *\n+         * @param inlineParserContext the standard {@code InlineParserContext}\n+         * @return the {@code InlineParser}\n+         *\/\n+        @Override\n+        public InlineParser create(InlineParserContext inlineParserContext) {\n+            return new InlineParserImpl(new InlineParserContext() {\n+\n+                @Override\n+                public List<DelimiterProcessor> getCustomDelimiterProcessors() {\n+                    return inlineParserContext.getCustomDelimiterProcessors();\n+                }\n+\n+                \/**\n+                 * {@inheritDoc}\n+                 *\n+                 * If the given label does not match any explicitly defined\n+                 * link reference definition, but does match a reference\n+                 * to a program element, a synthetic link reference definition\n+                 * is returned, with the label prefixed by {@code code:}.\n+                 *\n+                 * @param label the link label to look up\n+                 * @return the link reference definition for the label, or {@code null}\n+                 *\/\n+                @Override\n+                public LinkReferenceDefinition getLinkReferenceDefinition(String label) {\n+                    var l = label.replace(\"\\\\[\\\\]\", \"[]\");\n+                    var d = inlineParserContext.getLinkReferenceDefinition(l);\n+                    return d == null && isReference(l)\n+                            ? new LinkReferenceDefinition(\"\", AUTOREF_PREFIX + l, \"\")\n+                            : d;\n+                }\n+            });\n+        }\n+\n+        \/**\n+         * {@return whether a string appears to be a reference to a program element}\n+         *\n+         * @param s the string\n+         *\/\n+        private boolean isReference(String s) {\n+            try {\n+                var ref = refParser.parse(s, ReferenceParser.Mode.MEMBER_OPTIONAL);\n+                return true;\n+            } catch (ReferenceParser.ParseException e) {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A visitor to scan a Markdown document looking for any constructs that\n+     * should be mapped to doc comment nodes.\n+     *\n+     * The intended use is as follows:\n+     * {@snippet\n+     *     Lower v = new Lower(document, source, replacements);\n+     *     document.accept(v);\n+     *     var result = v.getTrees();\n+     * }\n+     *\n+     * On coordinates ...\n+     *\n+     * There are various position\/coordinate systems in play in this code:\n+     *\n+     * 1. Tree positions, which correspond to positions in the original comment,\n+     *    represented as a 0-based character offset within the content of the comment.\n+     * 2. Positions in the source string given to the Markdown parser,\n+     *    represented as a 0-based character offset within the source string.\n+     *    These differ from positions in the original comment if the source string\n+     *    contains U+FFFC characters representing embedded tree nodes.\n+     * 3. Positions in the source string given to the Markdown parser,\n+     *    represented as (line, column) values within SourceSpan nodes.\n+     *    Both line and column are 0-based.\n+     *    Note: SourceSpan objects never include newline characters.\n+     *\n+     * See {@link Lower#toSourcePos(int, int)} to convert from (line, column)\n+     * coordinates to a source position.\n+     * See {@link Lower#sourcePosToTreePos(int)} to convert from a source\n+     * position to a position in the original comment, for use in tree nodes.\n+     *\/\n+\n+    \/\/ Future opportunity:\n+    \/\/\n+    \/\/ It would be possible to override {@code visit(Heading)} and\n+    \/\/ check for certain recognized headings, and for those headings,\n+    \/\/ check the content that follows up to but not including\n+    \/\/ the next heading at the same or higher level, or end of text.\n+    \/\/ When a match occurs, the heading and the content could be translated\n+    \/\/ into one or more block tags. Note that any such block tags should\n+    \/\/ probably be stored separately from {@code trees}, and handled\n+    \/\/ appropriately by the caller of this method, either by accepting\n+    \/\/ such tags, or by reporting an error if they are not applicable.\n+    \/\/\n+    \/\/ A variant would be to pass in a boolean parameter to indicate\n+    \/\/ whether such tags would be acceptable if found, and to ignore\n+    \/\/ the heading and content if the block tag would not be acceptable.\n+    \/\/\n+    \/\/ If a heading and any following content is converted to a block tag,\n+    \/\/ the content should probably be removed from the tree, so that\n+    \/\/ it is not handled by the call of {@code visitChildren} that\n+    \/\/ invoked {@code visit(Heading)}.\n+    \/\/\n+    \/\/ Overall, this would allow Markdown constructs such as the following:\n+    \/\/\n+    \/\/ \/\/\/ Method description.\n+    \/\/ \/\/\/\n+    \/\/ \/\/\/ # Parameters\n+    \/\/ \/\/\/ * args\n+    \/\/ \/\/\/\n+    \/\/ \/\/\/ # Returns\n+    \/\/ \/\/\/   a result\n+    \/\/ \/\/\/\n+    \/\/ \/\/\/ # Throws\n+    \/\/ \/\/\/ * IOException if an error occurs\n+    \/\/\n+    \/\/ That being said, is it so much better than using standard block tags?\n+    \/\/ It is somewhat more concise for any repeatable block tag, if we\n+    \/\/ leverage the idea of a heading followed by a list.\n+    private static class Lower extends AbstractVisitor {\n+        private final DocTreeMaker m;\n+\n+        \/**\n+         * The Markdown document being processed.\n+         *\/\n+        private final Node document;\n+\n+        \/**\n+         * The source for the Markdown document being processed.\n+         * The document has \"source spans\" that indirectly point into this string\n+         * using {@code (line, column)} coordinates.\n+         * @see #toSourcePos(int, int)\n+         *\/\n+        private final String source;\n+\n+        \/**\n+         * An array giving the position of the first character after each newline\n+         * in the source.\n+         * Used to convert {@code (line, column)} coordinates to a character offset\n+         * in {@code source}.\n+         *\/\n+        private final int[] sourceLineOffsets;\n+\n+        \/**\n+         * An iterator containing the values to be substituted into the generated\n+         * tree when U+FFFC characters are encountered in the document.\n+         * There is a 1-1 correspondence between the values returned by the\n+         * iterator and the U+FFFC characters in the document.\n+         * The replacement objects may be either {@code DCTree} objects or\n+         * U+FFFC characters that were found in the original document.\n+         *\/\n+        Iterator<?> replaceIter;\n+\n+        \/**\n+         * The list of trees being built.\n+         * It may be temporarily replaced while visiting the children of\n+         * {@code Link} codes.\n+         *\/\n+        private List<DCTree> trees;\n+\n+        \/**\n+         * The source text being accumulated, prior to being placed in a\n+         * Markdown source node ({@code RawTextTree} with kind {@code MARKDOWN}).\n+         *\/\n+        private final StringBuilder text;\n+\n+        \/**\n+         * The start of source text to be copied literally when required.\n+         *\/\n+        private int copyStartPos;\n+\n+        \/**\n+         * The current adjustment from positions in {@code source} to positions\n+         * in the original comment, as used in doc tree nodes.\n+         * The difference arises because of the use of U+FFFC characters for\n+         * embedded objects. As the document (and source) are scanned,\n+         * this offset is updated when U+FFFC characters are encountered.\n+         *\/\n+        private int replaceAdjustPos;\n+\n+        \/**\n+         * The pattern for a line break.\n+         * This is equivalent to the detection in the Markdown parser, so that\n+         * {@code (line, column)} coordinates can be accurately converted back\n+         * into source positions.\n+         *\n+         * @see jdk.internal.org.commonmark.internal.DocumentParser#parse(String)\n+         * @see jdk.internal.org.commonmark.internal.util.Parsing#findLineBreak(CharSequence, int)\n+         *\/\n+        private static final Pattern lineBreak = Pattern.compile(\"\\n|\\r\\n?\");\n+\n+        \/**\n+         * Creates an instance of the visitor, given a document,\n+         * the source text for the document and objects to be substituted\n+         * when U+FFFC characters are encountered.\n+         *\n+         * Note the document does not itself contain any source text:\n+         * it just contains {@code SourceSpan} objects that point into\n+         * the source text using line and column indices.\n+         *\n+         * @param document the document to be converted\n+         * @param source the source of the document to be converted\n+         * @param replacements the objects to be substituted when U+FFFC is encountered\n+         *\/\n+        public Lower(DocTreeMaker docTreeMaker, Node document, String source, List<?> replacements) {\n+            this.m = docTreeMaker;\n+            this.document = document;\n+            this.source = source;\n+\n+            var offsets = new ArrayList<Integer>();\n+            offsets.add(0);\n+            var m = lineBreak.matcher(source);\n+            while (m.find()) {\n+                offsets.add(m.end());\n+            }\n+            sourceLineOffsets = offsets.stream().mapToInt(Integer::intValue).toArray();\n+\n+            replaceIter = replacements.iterator();\n+\n+            trees = new ArrayList<>();\n+            text = new StringBuilder();\n+            copyStartPos = 0;\n+            replaceAdjustPos = 0;\n+        }\n+\n+        \/**\n+         * {@return the trees that were built after using the visitor}\n+         *\/\n+        public List<DCTree> getTrees() {\n+            return trees;\n+        }\n+\n+        \/**\n+         * Visits a {@code Link} node.\n+         *\n+         * If the destination for the link begins with {@code code:}\n+         * convert it to {@code {@link ...}} or {@linkplain ...}} node.\n+         * {@code {@link ...}} will be used if the content (label) for\n+         * the link is the same as the reference found after the {@code code:}};\n+         * otherwise, {@code {@linkplain ...}} will be used.\n+         *\n+         * The label will be left blank for {@code {@link ...}} nodes,\n+         * implying that a default label should be used, based on the\n+         * program element that was referenced.\n+         *\n+         * @param link the link node\n+         *\/\n+        @Override\n+        public void visit(Link link) {\n+            String dest = link.getDestination();\n+            if (dest.startsWith(AUTOREF_PREFIX)) {\n+                \/\/ copy the source text up to the start of the node\n+                copyTo(getStartPos(link));\n+                \/\/ push temporary value for {@code trees} while handling the content of the node\n+                var saveTrees = trees;\n+                trees = new ArrayList<>();\n+                try {\n+                    copyStartPos = getStartPos(link.getFirstChild());\n+                    visitChildren(link);\n+                    copyTo(getEndPos(link.getLastChild()));\n+\n+                    \/\/ determine whether to use {@link... } or {@linkplain ...}\n+                    \/\/ based on whether the \"link text\" is the same as the \"link destination\"\n+                    String ref = dest.substring(AUTOREF_PREFIX.length());\n+                    int refPos = sourcePosToTreePos(getRefPos(ref, link));\n+                    var newRefTree = m.at(refPos).newReferenceTree(ref).setEndPos(refPos + ref.length());\n+\n+                    Node child = link.getFirstChild();\n+                    DocTree.Kind linkKind = child.getNext() == null\n+                            && child instanceof Text t\n+                            && t.getLiteral().equals(ref) ? DocTree.Kind.LINK : DocTree.Kind.LINK_PLAIN;\n+\n+                    DCTree newLinkTree = linkKind == DocTree.Kind.LINK\n+                            ? m.at(NOPOS).newLinkTree(newRefTree, List.of()) \/\/ ignore the child trees\n+                            : m.at(NOPOS).newLinkPlainTree(newRefTree, trees);\n+\n+                    saveTrees.add(newLinkTree);\n+                } finally {\n+                    \/\/ start any subsequent copy after the end of the link node\n+                    copyStartPos = getEndPos(link);\n+                    trees = saveTrees;\n+                }\n+            } else {\n+                visitChildren(link);\n+            }\n+        }\n+\n+        \/**\n+         * {@return the position in the source for the reference in a link}\n+         * Many syntactic forms may yield a {@code Link} object, so scan the\n+         * source looking for a match. Since the reference typically comes\n+         * after any text (when they are different), scan the source backwards.\n+         *\n+         * @param ref the reference to find\n+         * @param link the link containing the reference\n+         *\/\n+        private int getRefPos(String ref, Link link) {\n+            var spans = link.getSourceSpans();\n+            var revSpanIter = spans.listIterator(spans.size());\n+            while (revSpanIter.hasPrevious()) {\n+                var span = revSpanIter.previous();\n+                var start = toSourcePos(span.getLineIndex(), span.getColumnIndex());\n+                var end = toSourcePos(span.getLineIndex(), span.getColumnIndex() + span.getLength());\n+                var s = source.substring(start, end);\n+                var index = s.lastIndexOf(ref);\n+                if (index != -1) {\n+                    return start + index;\n+                }\n+            }\n+            return NOPOS;\n+        }\n+\n+        \/**\n+         * {@return the position in the original comment for a position in {@code source},\n+         * using {@link #replaceAdjustPos}}.\n+         *\n+         * @param pos the position in {@code source}\n+         *\/\n+        private int sourcePosToTreePos(int pos) {\n+            return pos == NOPOS ? NOPOS : pos + replaceAdjustPos;\n+        }\n+\n+        \/**\n+         * Process a node and any children.\n+         *\n+         * If the node has children, the children are each visited by\n+         * calling their {@code accept} method, and then finally, if this\n+         * is the top-level {@code document} node, any pending text is\n+         * flushed.\n+         *\n+         * If the node does not have children, the source spans for\n+         * the node are processed instead.\n+         *\n+         * Note that unlike the default implementation of {@code visitChildren},\n+         * the next child is not accessed until after the current child\n+         * has been visited.  This allows a child to peek at and possibly remove\n+         * any child nodes that may follow it.\n+         *\n+         * @param node the node whose children should be visited\n+         *\/\n+        @Override\n+        protected void visitChildren(Node node) {\n+            Node child = node.getFirstChild();\n+            if (child != null) {\n+                while (child != null) {\n+                    \/\/ defer getting the next child until after this node has\n+                    \/\/ been processed, in case any following nodes were handled\n+                    \/\/ by this node, and removed from the document\n+                    child.accept(this);\n+                    child = child.getNext();\n+                }\n+                if (node == document) {\n+                    \/\/ the top level document has no spans of its own, so use the last child\n+                    copyTo(getEndPos(document.getLastChild()));\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * {@return the start of this node, from the start of the first span}\n+         *\n+         * @param node the node\n+         *\/\n+        private int getStartPos(Node node) {\n+            var spans = node.getSourceSpans();\n+            var firstSpan = spans.get(0);\n+            return toSourcePos(firstSpan.getLineIndex(), firstSpan.getColumnIndex());\n+        }\n+\n+        \/**\n+         * {@return the end of this node, from the end of the last span}\n+         * The end points to the first character not included in the span.\n+         *\n+         * @param node the node\n+         *\/\n+        private int getEndPos(Node node) {\n+            var spans = node.getSourceSpans();\n+            var lastSpan = spans.get(spans.size() - 1);\n+            return toSourcePos(lastSpan.getLineIndex(), lastSpan.getColumnIndex() + lastSpan.getLength());\n+        }\n+\n+        \/**\n+         * {@return the position in the {@code source} string for a given {@code (line, column}}\n+         *\n+         * @param lineIndex the line index\n+         * @param columnIndex the column index\n+         *\/\n+        private int toSourcePos(int lineIndex, int columnIndex) {\n+            return sourceLineOffsets[lineIndex] + columnIndex;\n+        }\n+\n+        \/**\n+         * Copies source text from the saved copy-start position to the given end position\n+         * using the saved {@code source}, to the list of {@code trees}.\n+         *\n+         * @param endPos the end position\n+         *\/\n+        private void copyTo(int endPos) {\n+            int startPos = copyStartPos;\n+            int pos;\n+            while ((pos = source.indexOf(PLACEHOLDER, startPos)) != -1 && pos < endPos) {\n+                text.append(source, startPos, pos);\n+                assert replaceIter.hasNext();\n+                Object r = replaceIter.next();\n+                if (r instanceof DCTree t) {\n+                    flushText(startPos);\n+                    trees.add(t);\n+                    replaceAdjustPos += t.getEndPosition() - t.getStartPosition() - 1;\n+                } else if (r.equals(PLACEHOLDER)) {\n+                    text.append(PLACEHOLDER);\n+                } else {\n+                    throw new IllegalStateException(r.getClass().toString());\n+                }\n+                startPos = pos + 1;\n+            }\n+            if (startPos < endPos) {\n+                text.append(source, startPos, endPos);\n+            }\n+            flushText(startPos);\n+        }\n+\n+        \/**\n+         * Flush any text in the {@code text} buffer, by creating a new\n+         * Markdown source text node and adding it to the list of trees.\n+         *\/\n+        private void flushText(int pos) {\n+            if (!text.isEmpty()) {\n+                trees.add(m.at(sourcePosToTreePos(pos)).newRawTextTree(DocTree.Kind.MARKDOWN, text.toString()));\n+                text.setLength(0);\n+            }\n+        }\n+    }\n+\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/markdown\/MarkdownTransformer.java","additions":951,"deletions":0,"binary":false,"changes":951,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark;\n+\n+\/**\n+ * Base interface for a parser\/renderer extension.\n+ * <p>\n+ * Doesn't have any methods itself, but has specific sub interfaces to\n+ * configure parser\/renderer. This base interface is for convenience, so that a list of extensions can be built and then\n+ * used for configuring both the parser and renderer in the same way.\n+ *\/\n+public interface Extension {\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/Extension.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables;\n+\n+import jdk.internal.org.commonmark.node.CustomBlock;\n+\n+\/**\n+ * Table block containing a {@link TableHead} and optionally a {@link TableBody}.\n+ *\/\n+public class TableBlock extends CustomBlock {\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/TableBlock.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables;\n+\n+import jdk.internal.org.commonmark.node.CustomNode;\n+\n+\/**\n+ * Body part of a {@link TableBlock} containing {@link TableRow TableRows}.\n+ *\/\n+public class TableBody extends CustomNode {\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/TableBody.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables;\n+\n+import jdk.internal.org.commonmark.node.CustomNode;\n+\n+\/**\n+ * Table cell of a {@link TableRow} containing inline nodes.\n+ *\/\n+public class TableCell extends CustomNode {\n+\n+    private boolean header;\n+    private Alignment alignment;\n+\n+    \/**\n+     * @return whether the cell is a header or not\n+     *\/\n+    public boolean isHeader() {\n+        return header;\n+    }\n+\n+    public void setHeader(boolean header) {\n+        this.header = header;\n+    }\n+\n+    \/**\n+     * @return the cell alignment\n+     *\/\n+    public Alignment getAlignment() {\n+        return alignment;\n+    }\n+\n+    public void setAlignment(Alignment alignment) {\n+        this.alignment = alignment;\n+    }\n+\n+    \/**\n+     * How the cell is aligned horizontally.\n+     *\/\n+    public enum Alignment {\n+        LEFT, CENTER, RIGHT\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/TableCell.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables;\n+\n+import jdk.internal.org.commonmark.node.CustomNode;\n+\n+\/**\n+ * Head part of a {@link TableBlock} containing {@link TableRow TableRows}.\n+ *\/\n+public class TableHead extends CustomNode {\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/TableHead.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables;\n+\n+import jdk.internal.org.commonmark.node.CustomNode;\n+\n+\/**\n+ * Table row of a {@link TableHead} or {@link TableBody} containing {@link TableCell TableCells}.\n+ *\/\n+public class TableRow extends CustomNode {\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/TableRow.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables;\n+\n+import jdk.internal.org.commonmark.Extension;\n+import jdk.internal.org.commonmark.ext.gfm.tables.internal.TableBlockParser;\n+import jdk.internal.org.commonmark.ext.gfm.tables.internal.TableHtmlNodeRenderer;\n+import jdk.internal.org.commonmark.ext.gfm.tables.internal.TableTextContentNodeRenderer;\n+import jdk.internal.org.commonmark.parser.Parser;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.renderer.html.HtmlNodeRendererContext;\n+import jdk.internal.org.commonmark.renderer.html.HtmlNodeRendererFactory;\n+import jdk.internal.org.commonmark.renderer.html.HtmlRenderer;\n+import jdk.internal.org.commonmark.renderer.text.TextContentNodeRendererContext;\n+import jdk.internal.org.commonmark.renderer.text.TextContentNodeRendererFactory;\n+import jdk.internal.org.commonmark.renderer.text.TextContentRenderer;\n+\n+\/**\n+ * Extension for GFM tables using \"|\" pipes (GitHub Flavored Markdown).\n+ * <p>\n+ * Create it with {@link #create()} and then configure it on the builders\n+ * ({@link org.commonmark.parser.Parser.Builder#extensions(Iterable)},\n+ * {@link HtmlRenderer.Builder#extensions(Iterable)}).\n+ * <\/p>\n+ * <p>\n+ * The parsed tables are turned into {@link TableBlock} blocks.\n+ * <\/p>\n+ *\n+ * @see <a href=\"https:\/\/github.github.com\/gfm\/#tables-extension-\">Tables (extension) in GitHub Flavored Markdown Spec<\/a>\n+ *\/\n+public class TablesExtension implements Parser.ParserExtension, HtmlRenderer.HtmlRendererExtension,\n+        TextContentRenderer.TextContentRendererExtension {\n+\n+    private TablesExtension() {\n+    }\n+\n+    public static Extension create() {\n+        return new TablesExtension();\n+    }\n+\n+    @Override\n+    public void extend(Parser.Builder parserBuilder) {\n+        parserBuilder.customBlockParserFactory(new TableBlockParser.Factory());\n+    }\n+\n+    @Override\n+    public void extend(HtmlRenderer.Builder rendererBuilder) {\n+        rendererBuilder.nodeRendererFactory(new HtmlNodeRendererFactory() {\n+            @Override\n+            public NodeRenderer create(HtmlNodeRendererContext context) {\n+                return new TableHtmlNodeRenderer(context);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void extend(TextContentRenderer.Builder rendererBuilder) {\n+        rendererBuilder.nodeRendererFactory(new TextContentNodeRendererFactory() {\n+            @Override\n+            public NodeRenderer create(TextContentNodeRendererContext context) {\n+                return new TableTextContentNodeRenderer(context);\n+            }\n+        });\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/TablesExtension.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables.internal;\n+\n+import jdk.internal.org.commonmark.ext.gfm.tables.*;\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.parser.InlineParser;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+import jdk.internal.org.commonmark.parser.block.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class TableBlockParser extends AbstractBlockParser {\n+\n+    private final TableBlock block = new TableBlock();\n+    private final List<SourceLine> rowLines = new ArrayList<>();\n+    private final List<TableCell.Alignment> columns;\n+\n+    private boolean canHaveLazyContinuationLines = true;\n+\n+    private TableBlockParser(List<TableCell.Alignment> columns, SourceLine headerLine) {\n+        this.columns = columns;\n+        this.rowLines.add(headerLine);\n+    }\n+\n+    @Override\n+    public boolean canHaveLazyContinuationLines() {\n+        return canHaveLazyContinuationLines;\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        CharSequence content = state.getLine().getContent();\n+        int pipe = Parsing.find('|', content, state.getNextNonSpaceIndex());\n+        if (pipe != -1) {\n+            if (pipe == state.getNextNonSpaceIndex()) {\n+                \/\/ If we *only* have a pipe character (and whitespace), that is not a valid table row and ends the table.\n+                if (Parsing.skipSpaceTab(content, pipe + 1, content.length()) == content.length()) {\n+                    \/\/ We also don't want the pipe to be added via lazy continuation.\n+                    canHaveLazyContinuationLines = false;\n+                    return BlockContinue.none();\n+                }\n+            }\n+            return BlockContinue.atIndex(state.getIndex());\n+        } else {\n+            return BlockContinue.none();\n+        }\n+    }\n+\n+    @Override\n+    public void addLine(SourceLine line) {\n+        rowLines.add(line);\n+    }\n+\n+    @Override\n+    public void parseInlines(InlineParser inlineParser) {\n+        List<SourceSpan> sourceSpans = block.getSourceSpans();\n+\n+        SourceSpan headerSourceSpan = !sourceSpans.isEmpty() ? sourceSpans.get(0) : null;\n+        Node head = new TableHead();\n+        if (headerSourceSpan != null) {\n+            head.addSourceSpan(headerSourceSpan);\n+        }\n+        block.appendChild(head);\n+\n+        TableRow headerRow = new TableRow();\n+        headerRow.setSourceSpans(head.getSourceSpans());\n+        head.appendChild(headerRow);\n+\n+        List<SourceLine> headerCells = split(rowLines.get(0));\n+        int headerColumns = headerCells.size();\n+        for (int i = 0; i < headerColumns; i++) {\n+            SourceLine cell = headerCells.get(i);\n+            TableCell tableCell = parseCell(cell, i, inlineParser);\n+            tableCell.setHeader(true);\n+            headerRow.appendChild(tableCell);\n+        }\n+\n+        TableBody body = null;\n+        \/\/ Body starts at index 2. 0 is header, 1 is separator.\n+        for (int rowIndex = 2; rowIndex < rowLines.size(); rowIndex++) {\n+            SourceLine rowLine = rowLines.get(rowIndex);\n+            SourceSpan sourceSpan = rowIndex < sourceSpans.size() ? sourceSpans.get(rowIndex) : null;\n+            List<SourceLine> cells = split(rowLine);\n+            TableRow row = new TableRow();\n+            if (sourceSpan != null) {\n+                row.addSourceSpan(sourceSpan);\n+            }\n+\n+            \/\/ Body can not have more columns than head\n+            for (int i = 0; i < headerColumns; i++) {\n+                SourceLine cell = i < cells.size() ? cells.get(i) : SourceLine.of(\"\", null);\n+                TableCell tableCell = parseCell(cell, i, inlineParser);\n+                row.appendChild(tableCell);\n+            }\n+\n+            if (body == null) {\n+                \/\/ It's valid to have a table without body. In that case, don't add an empty TableBody node.\n+                body = new TableBody();\n+                block.appendChild(body);\n+            }\n+            body.appendChild(row);\n+            body.addSourceSpan(sourceSpan);\n+        }\n+    }\n+\n+    private TableCell parseCell(SourceLine cell, int column, InlineParser inlineParser) {\n+        TableCell tableCell = new TableCell();\n+        SourceSpan sourceSpan = cell.getSourceSpan();\n+        if (sourceSpan != null) {\n+            tableCell.addSourceSpan(sourceSpan);\n+        }\n+\n+        if (column < columns.size()) {\n+            tableCell.setAlignment(columns.get(column));\n+        }\n+\n+        CharSequence content = cell.getContent();\n+        int start = Parsing.skipSpaceTab(content, 0, content.length());\n+        int end = Parsing.skipSpaceTabBackwards(content, content.length() - 1, start);\n+        inlineParser.parse(SourceLines.of(cell.substring(start, end + 1)), tableCell);\n+\n+        return tableCell;\n+    }\n+\n+    private static List<SourceLine> split(SourceLine line) {\n+        CharSequence row = line.getContent();\n+        int nonSpace = Parsing.skipSpaceTab(row, 0, row.length());\n+        int cellStart = nonSpace;\n+        int cellEnd = row.length();\n+        if (row.charAt(nonSpace) == '|') {\n+            \/\/ This row has leading\/trailing pipes - skip the leading pipe\n+            cellStart = nonSpace + 1;\n+            \/\/ Strip whitespace from the end but not the pipe or we could miss an empty (\"||\") cell\n+            int nonSpaceEnd = Parsing.skipSpaceTabBackwards(row, row.length() - 1, cellStart);\n+            cellEnd = nonSpaceEnd + 1;\n+        }\n+        List<SourceLine> cells = new ArrayList<>();\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = cellStart; i < cellEnd; i++) {\n+            char c = row.charAt(i);\n+            switch (c) {\n+                case '\\\\':\n+                    if (i + 1 < cellEnd && row.charAt(i + 1) == '|') {\n+                        \/\/ Pipe is special for table parsing. An escaped pipe doesn't result in a new cell, but is\n+                        \/\/ passed down to inline parsing as an unescaped pipe. Note that that applies even for the `\\|`\n+                        \/\/ in an input like `\\\\|` - in other words, table parsing doesn't support escaping backslashes.\n+                        sb.append('|');\n+                        i++;\n+                    } else {\n+                        \/\/ Preserve backslash before other characters or at end of line.\n+                        sb.append('\\\\');\n+                    }\n+                    break;\n+                case '|':\n+                    String content = sb.toString();\n+\n+                    cells.add(SourceLine.of(content, line.substring(cellStart, i).getSourceSpan()));\n+                    sb.setLength(0);\n+                    \/\/ + 1 to skip the pipe itself for the next cell's span\n+                    cellStart = i + 1;\n+                    break;\n+                default:\n+                    sb.append(c);\n+            }\n+        }\n+        if (sb.length() > 0) {\n+            String content = sb.toString();\n+            cells.add(SourceLine.of(content, line.substring(cellStart, line.getContent().length()).getSourceSpan()));\n+        }\n+        return cells;\n+    }\n+\n+    \/\/ Examples of valid separators:\n+    \/\/\n+    \/\/ |-\n+    \/\/ -|\n+    \/\/ |-|\n+    \/\/ -|-\n+    \/\/ |-|-|\n+    \/\/ --- | ---\n+    private static List<TableCell.Alignment> parseSeparator(CharSequence s) {\n+        List<TableCell.Alignment> columns = new ArrayList<>();\n+        int pipes = 0;\n+        boolean valid = false;\n+        int i = 0;\n+        while (i < s.length()) {\n+            char c = s.charAt(i);\n+            switch (c) {\n+                case '|':\n+                    i++;\n+                    pipes++;\n+                    if (pipes > 1) {\n+                        \/\/ More than one adjacent pipe not allowed\n+                        return null;\n+                    }\n+                    \/\/ Need at lest one pipe, even for a one column table\n+                    valid = true;\n+                    break;\n+                case '-':\n+                case ':':\n+                    if (pipes == 0 && !columns.isEmpty()) {\n+                        \/\/ Need a pipe after the first column (first column doesn't need to start with one)\n+                        return null;\n+                    }\n+                    boolean left = false;\n+                    boolean right = false;\n+                    if (c == ':') {\n+                        left = true;\n+                        i++;\n+                    }\n+                    boolean haveDash = false;\n+                    while (i < s.length() && s.charAt(i) == '-') {\n+                        i++;\n+                        haveDash = true;\n+                    }\n+                    if (!haveDash) {\n+                        \/\/ Need at least one dash\n+                        return null;\n+                    }\n+                    if (i < s.length() && s.charAt(i) == ':') {\n+                        right = true;\n+                        i++;\n+                    }\n+                    columns.add(getAlignment(left, right));\n+                    \/\/ Next, need another pipe\n+                    pipes = 0;\n+                    break;\n+                case ' ':\n+                case '\\t':\n+                    \/\/ White space is allowed between pipes and columns\n+                    i++;\n+                    break;\n+                default:\n+                    \/\/ Any other character is invalid\n+                    return null;\n+            }\n+        }\n+        if (!valid) {\n+            return null;\n+        }\n+        return columns;\n+    }\n+\n+    private static TableCell.Alignment getAlignment(boolean left, boolean right) {\n+        if (left && right) {\n+            return TableCell.Alignment.CENTER;\n+        } else if (left) {\n+            return TableCell.Alignment.LEFT;\n+        } else if (right) {\n+            return TableCell.Alignment.RIGHT;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+\n+        @Override\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            List<SourceLine> paragraphLines = matchedBlockParser.getParagraphLines().getLines();\n+            if (paragraphLines.size() == 1 && Parsing.find('|', paragraphLines.get(0).getContent(), 0) != -1) {\n+                SourceLine line = state.getLine();\n+                SourceLine separatorLine = line.substring(state.getIndex(), line.getContent().length());\n+                List<TableCell.Alignment> columns = parseSeparator(separatorLine.getContent());\n+                if (columns != null && !columns.isEmpty()) {\n+                    SourceLine paragraph = paragraphLines.get(0);\n+                    List<SourceLine> headerCells = split(paragraph);\n+                    if (columns.size() >= headerCells.size()) {\n+                        return BlockStart.of(new TableBlockParser(columns, paragraph))\n+                                .atIndex(state.getIndex())\n+                                .replaceActiveBlockParser();\n+                    }\n+                }\n+            }\n+            return BlockStart.none();\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/internal\/TableBlockParser.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables.internal;\n+\n+import jdk.internal.org.commonmark.ext.gfm.tables.*;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.renderer.html.HtmlNodeRendererContext;\n+import jdk.internal.org.commonmark.renderer.html.HtmlWriter;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+\n+public class TableHtmlNodeRenderer extends TableNodeRenderer {\n+\n+    private final HtmlWriter htmlWriter;\n+    private final HtmlNodeRendererContext context;\n+\n+    public TableHtmlNodeRenderer(HtmlNodeRendererContext context) {\n+        this.htmlWriter = context.getWriter();\n+        this.context = context;\n+    }\n+\n+    protected void renderBlock(TableBlock tableBlock) {\n+        htmlWriter.line();\n+        htmlWriter.tag(\"table\", getAttributes(tableBlock, \"table\"));\n+        renderChildren(tableBlock);\n+        htmlWriter.tag(\"\/table\");\n+        htmlWriter.line();\n+    }\n+\n+    protected void renderHead(TableHead tableHead) {\n+        htmlWriter.line();\n+        htmlWriter.tag(\"thead\", getAttributes(tableHead, \"thead\"));\n+        renderChildren(tableHead);\n+        htmlWriter.tag(\"\/thead\");\n+        htmlWriter.line();\n+    }\n+\n+    protected void renderBody(TableBody tableBody) {\n+        htmlWriter.line();\n+        htmlWriter.tag(\"tbody\", getAttributes(tableBody, \"tbody\"));\n+        renderChildren(tableBody);\n+        htmlWriter.tag(\"\/tbody\");\n+        htmlWriter.line();\n+    }\n+\n+    protected void renderRow(TableRow tableRow) {\n+        htmlWriter.line();\n+        htmlWriter.tag(\"tr\", getAttributes(tableRow, \"tr\"));\n+        renderChildren(tableRow);\n+        htmlWriter.tag(\"\/tr\");\n+        htmlWriter.line();\n+    }\n+\n+    protected void renderCell(TableCell tableCell) {\n+        String tagName = tableCell.isHeader() ? \"th\" : \"td\";\n+        htmlWriter.line();\n+        htmlWriter.tag(tagName, getCellAttributes(tableCell, tagName));\n+        renderChildren(tableCell);\n+        htmlWriter.tag(\"\/\" + tagName);\n+        htmlWriter.line();\n+    }\n+\n+    private Map<String, String> getAttributes(Node node, String tagName) {\n+        return context.extendAttributes(node, tagName, Collections.<String, String>emptyMap());\n+    }\n+\n+    private Map<String, String> getCellAttributes(TableCell tableCell, String tagName) {\n+        if (tableCell.getAlignment() != null) {\n+            return context.extendAttributes(tableCell, tagName, Collections.singletonMap(\"align\", getAlignValue(tableCell.getAlignment())));\n+        } else {\n+            return context.extendAttributes(tableCell, tagName, Collections.<String, String>emptyMap());\n+        }\n+    }\n+\n+    private static String getAlignValue(TableCell.Alignment alignment) {\n+        switch (alignment) {\n+            case LEFT:\n+                return \"left\";\n+            case CENTER:\n+                return \"center\";\n+            case RIGHT:\n+                return \"right\";\n+        }\n+        throw new IllegalStateException(\"Unknown alignment: \" + alignment);\n+    }\n+\n+    private void renderChildren(Node parent) {\n+        Node node = parent.getFirstChild();\n+        while (node != null) {\n+            Node next = node.getNext();\n+            context.render(node);\n+            node = next;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/internal\/TableHtmlNodeRenderer.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables.internal;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableBlock;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableBody;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableCell;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableHead;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableRow;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+\n+abstract class TableNodeRenderer implements NodeRenderer {\n+\n+    @Override\n+    public Set<Class<? extends Node>> getNodeTypes() {\n+        return new HashSet<>(Arrays.asList(\n+                TableBlock.class,\n+                TableHead.class,\n+                TableBody.class,\n+                TableRow.class,\n+                TableCell.class\n+        ));\n+    }\n+\n+    @Override\n+    public void render(Node node) {\n+        if (node instanceof TableBlock) {\n+            renderBlock((TableBlock) node);\n+        } else if (node instanceof TableHead) {\n+            renderHead((TableHead) node);\n+        } else if (node instanceof TableBody) {\n+            renderBody((TableBody) node);\n+        } else if (node instanceof TableRow) {\n+            renderRow((TableRow) node);\n+        } else if (node instanceof TableCell) {\n+            renderCell((TableCell) node);\n+        }\n+    }\n+\n+    protected abstract void renderBlock(TableBlock node);\n+\n+    protected abstract void renderHead(TableHead node);\n+\n+    protected abstract void renderBody(TableBody node);\n+\n+    protected abstract void renderRow(TableRow node);\n+\n+    protected abstract void renderCell(TableCell node);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/internal\/TableNodeRenderer.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables.internal;\n+\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableBlock;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableBody;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableCell;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableHead;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableRow;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.renderer.text.TextContentNodeRendererContext;\n+import jdk.internal.org.commonmark.renderer.text.TextContentWriter;\n+\n+\/**\n+ * The Table node renderer that is needed for rendering GFM tables (GitHub Flavored Markdown) to text content.\n+ *\/\n+public class TableTextContentNodeRenderer extends TableNodeRenderer {\n+\n+    private final TextContentWriter textContentWriter;\n+    private final TextContentNodeRendererContext context;\n+\n+    public TableTextContentNodeRenderer(TextContentNodeRendererContext context) {\n+        this.textContentWriter = context.getWriter();\n+        this.context = context;\n+    }\n+\n+    protected void renderBlock(TableBlock tableBlock) {\n+        renderChildren(tableBlock);\n+        if (tableBlock.getNext() != null) {\n+            textContentWriter.write(\"\\n\");\n+        }\n+    }\n+\n+    protected void renderHead(TableHead tableHead) {\n+        renderChildren(tableHead);\n+    }\n+\n+    protected void renderBody(TableBody tableBody) {\n+        renderChildren(tableBody);\n+    }\n+\n+    protected void renderRow(TableRow tableRow) {\n+        textContentWriter.line();\n+        renderChildren(tableRow);\n+        textContentWriter.line();\n+    }\n+\n+    protected void renderCell(TableCell tableCell) {\n+        renderChildren(tableCell);\n+        textContentWriter.write('|');\n+        textContentWriter.whitespace();\n+    }\n+\n+    private void renderLastCell(TableCell tableCell) {\n+        renderChildren(tableCell);\n+    }\n+\n+    private void renderChildren(Node parent) {\n+        Node node = parent.getFirstChild();\n+        while (node != null) {\n+            Node next = node.getNext();\n+\n+            \/\/ For last cell in row, we dont render the delimiter.\n+            if (node instanceof TableCell && next == null) {\n+                renderLastCell((TableCell) node);\n+            } else {\n+                context.render(node);\n+            }\n+\n+            node = next;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/internal\/TableTextContentNodeRenderer.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+class BlockContent {\n+\n+    private final StringBuilder sb;\n+\n+    private int lineCount = 0;\n+\n+    public BlockContent() {\n+        sb = new StringBuilder();\n+    }\n+\n+    public BlockContent(String content) {\n+        sb = new StringBuilder(content);\n+    }\n+\n+    public void add(CharSequence line) {\n+        if (lineCount != 0) {\n+            sb.append('\\n');\n+        }\n+        sb.append(line);\n+        lineCount++;\n+    }\n+\n+    public String getString() {\n+        return sb.toString();\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/BlockContent.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.parser.block.BlockContinue;\n+\n+public class BlockContinueImpl extends BlockContinue {\n+\n+    private final int newIndex;\n+    private final int newColumn;\n+    private final boolean finalize;\n+\n+    public BlockContinueImpl(int newIndex, int newColumn, boolean finalize) {\n+        this.newIndex = newIndex;\n+        this.newColumn = newColumn;\n+        this.finalize = finalize;\n+    }\n+\n+    public int getNewIndex() {\n+        return newIndex;\n+    }\n+\n+    public int getNewColumn() {\n+        return newColumn;\n+    }\n+\n+    public boolean isFinalize() {\n+        return finalize;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/BlockContinueImpl.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.BlockQuote;\n+import jdk.internal.org.commonmark.parser.block.*;\n+\n+public class BlockQuoteParser extends AbstractBlockParser {\n+\n+    private final BlockQuote block = new BlockQuote();\n+\n+    @Override\n+    public boolean isContainer() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean canContain(Block block) {\n+        return true;\n+    }\n+\n+    @Override\n+    public BlockQuote getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        int nextNonSpace = state.getNextNonSpaceIndex();\n+        if (isMarker(state, nextNonSpace)) {\n+            int newColumn = state.getColumn() + state.getIndent() + 1;\n+            \/\/ optional following space or tab\n+            if (Parsing.isSpaceOrTab(state.getLine().getContent(), nextNonSpace + 1)) {\n+                newColumn++;\n+            }\n+            return BlockContinue.atColumn(newColumn);\n+        } else {\n+            return BlockContinue.none();\n+        }\n+    }\n+\n+    private static boolean isMarker(ParserState state, int index) {\n+        CharSequence line = state.getLine().getContent();\n+        return state.getIndent() < Parsing.CODE_BLOCK_INDENT && index < line.length() && line.charAt(index) == '>';\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            int nextNonSpace = state.getNextNonSpaceIndex();\n+            if (isMarker(state, nextNonSpace)) {\n+                int newColumn = state.getColumn() + state.getIndent() + 1;\n+                \/\/ optional following space or tab\n+                if (Parsing.isSpaceOrTab(state.getLine().getContent(), nextNonSpace + 1)) {\n+                    newColumn++;\n+                }\n+                return BlockStart.of(new BlockQuoteParser()).atColumn(newColumn);\n+            } else {\n+                return BlockStart.none();\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/BlockQuoteParser.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.parser.block.BlockParser;\n+import jdk.internal.org.commonmark.parser.block.BlockStart;\n+\n+public class BlockStartImpl extends BlockStart {\n+\n+    private final BlockParser[] blockParsers;\n+    private int newIndex = -1;\n+    private int newColumn = -1;\n+    private boolean replaceActiveBlockParser = false;\n+\n+    public BlockStartImpl(BlockParser... blockParsers) {\n+        this.blockParsers = blockParsers;\n+    }\n+\n+    public BlockParser[] getBlockParsers() {\n+        return blockParsers;\n+    }\n+\n+    public int getNewIndex() {\n+        return newIndex;\n+    }\n+\n+    public int getNewColumn() {\n+        return newColumn;\n+    }\n+\n+    public boolean isReplaceActiveBlockParser() {\n+        return replaceActiveBlockParser;\n+    }\n+\n+    @Override\n+    public BlockStart atIndex(int newIndex) {\n+        this.newIndex = newIndex;\n+        return this;\n+    }\n+\n+    @Override\n+    public BlockStart atColumn(int newColumn) {\n+        this.newColumn = newColumn;\n+        return this;\n+    }\n+\n+    @Override\n+    public BlockStart replaceActiveBlockParser() {\n+        this.replaceActiveBlockParser = true;\n+        return this;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/BlockStartImpl.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.inline.Position;\n+import jdk.internal.org.commonmark.node.Text;\n+\n+\/**\n+ * Opening bracket for links (<code>[<\/code>) or images (<code>![<\/code>).\n+ *\/\n+public class Bracket {\n+\n+    public final Text node;\n+\n+    \/**\n+     * The position of the marker for the bracket (<code>[<\/code> or <code>![<\/code>)\n+     *\/\n+    public final Position markerPosition;\n+\n+    \/**\n+     * The position of the content (after the opening bracket)\n+     *\/\n+    public final Position contentPosition;\n+\n+    \/**\n+     * Whether this is an image or link.\n+     *\/\n+    public final boolean image;\n+\n+    \/**\n+     * Previous bracket.\n+     *\/\n+    public final Bracket previous;\n+\n+    \/**\n+     * Previous delimiter (emphasis, etc) before this bracket.\n+     *\/\n+    public final Delimiter previousDelimiter;\n+\n+    \/**\n+     * Whether this bracket is allowed to form a link\/image (also known as \"active\").\n+     *\/\n+    public boolean allowed = true;\n+\n+    \/**\n+     * Whether there is an unescaped bracket (opening or closing) anywhere after this opening bracket.\n+     *\/\n+    public boolean bracketAfter = false;\n+\n+    static public Bracket link(Text node, Position markerPosition, Position contentPosition, Bracket previous, Delimiter previousDelimiter) {\n+        return new Bracket(node, markerPosition, contentPosition, previous, previousDelimiter, false);\n+    }\n+\n+    static public Bracket image(Text node, Position markerPosition, Position contentPosition, Bracket previous, Delimiter previousDelimiter) {\n+        return new Bracket(node, markerPosition, contentPosition, previous, previousDelimiter, true);\n+    }\n+\n+    private Bracket(Text node, Position markerPosition, Position contentPosition, Bracket previous, Delimiter previousDelimiter, boolean image) {\n+        this.node = node;\n+        this.markerPosition = markerPosition;\n+        this.contentPosition = contentPosition;\n+        this.image = image;\n+        this.previous = previous;\n+        this.previousDelimiter = previousDelimiter;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/Bracket.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.node.Text;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterRun;\n+\n+import java.util.List;\n+\n+\/**\n+ * Delimiter (emphasis, strong emphasis or custom emphasis).\n+ *\/\n+public class Delimiter implements DelimiterRun {\n+\n+    public final List<Text> characters;\n+    public final char delimiterChar;\n+    private final int originalLength;\n+\n+    \/\/ Can open emphasis, see spec.\n+    private final boolean canOpen;\n+\n+    \/\/ Can close emphasis, see spec.\n+    private final boolean canClose;\n+\n+    public Delimiter previous;\n+    public Delimiter next;\n+\n+    public Delimiter(List<Text> characters, char delimiterChar, boolean canOpen, boolean canClose, Delimiter previous) {\n+        this.characters = characters;\n+        this.delimiterChar = delimiterChar;\n+        this.canOpen = canOpen;\n+        this.canClose = canClose;\n+        this.previous = previous;\n+        this.originalLength = characters.size();\n+    }\n+\n+    @Override\n+    public boolean canOpen() {\n+        return canOpen;\n+    }\n+\n+    @Override\n+    public boolean canClose() {\n+        return canClose;\n+    }\n+\n+    @Override\n+    public int length() {\n+        return characters.size();\n+    }\n+\n+    @Override\n+    public int originalLength() {\n+        return originalLength;\n+    }\n+\n+    @Override\n+    public Text getOpener() {\n+        return characters.get(characters.size() - 1);\n+    }\n+\n+    @Override\n+    public Text getCloser() {\n+        return characters.get(0);\n+    }\n+\n+    @Override\n+    public Iterable<Text> getOpeners(int length) {\n+        if (!(length >= 1 && length <= length())) {\n+            throw new IllegalArgumentException(\"length must be between 1 and \" + length() + \", was \" + length);\n+        }\n+\n+        return characters.subList(characters.size() - length, characters.size());\n+    }\n+\n+    @Override\n+    public Iterable<Text> getClosers(int length) {\n+        if (!(length >= 1 && length <= length())) {\n+            throw new IllegalArgumentException(\"length must be between 1 and \" + length() + \", was \" + length);\n+        }\n+\n+        return characters.subList(0, length);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/Delimiter.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.Document;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.block.AbstractBlockParser;\n+import jdk.internal.org.commonmark.parser.block.BlockContinue;\n+import jdk.internal.org.commonmark.parser.block.ParserState;\n+\n+public class DocumentBlockParser extends AbstractBlockParser {\n+\n+    private final Document document = new Document();\n+\n+    @Override\n+    public boolean isContainer() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean canContain(Block block) {\n+        return true;\n+    }\n+\n+    @Override\n+    public Document getBlock() {\n+        return document;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        return BlockContinue.atIndex(state.getIndex());\n+    }\n+\n+    @Override\n+    public void addLine(SourceLine line) {\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/DocumentBlockParser.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,609 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.parser.*;\n+import jdk.internal.org.commonmark.parser.block.*;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.*;\n+\n+public class DocumentParser implements ParserState {\n+\n+    private static final Set<Class<? extends Block>> CORE_FACTORY_TYPES = new LinkedHashSet<>(Arrays.asList(\n+            BlockQuote.class,\n+            Heading.class,\n+            FencedCodeBlock.class,\n+            HtmlBlock.class,\n+            ThematicBreak.class,\n+            ListBlock.class,\n+            IndentedCodeBlock.class));\n+\n+    private static final Map<Class<? extends Block>, BlockParserFactory> NODES_TO_CORE_FACTORIES;\n+\n+    static {\n+        Map<Class<? extends Block>, BlockParserFactory> map = new HashMap<>();\n+        map.put(BlockQuote.class, new BlockQuoteParser.Factory());\n+        map.put(Heading.class, new HeadingParser.Factory());\n+        map.put(FencedCodeBlock.class, new FencedCodeBlockParser.Factory());\n+        map.put(HtmlBlock.class, new HtmlBlockParser.Factory());\n+        map.put(ThematicBreak.class, new ThematicBreakParser.Factory());\n+        map.put(ListBlock.class, new ListBlockParser.Factory());\n+        map.put(IndentedCodeBlock.class, new IndentedCodeBlockParser.Factory());\n+        NODES_TO_CORE_FACTORIES = Collections.unmodifiableMap(map);\n+    }\n+\n+    private SourceLine line;\n+\n+    \/**\n+     * Line index (0-based)\n+     *\/\n+    private int lineIndex = -1;\n+\n+    \/**\n+     * current index (offset) in input line (0-based)\n+     *\/\n+    private int index = 0;\n+\n+    \/**\n+     * current column of input line (tab causes column to go to next 4-space tab stop) (0-based)\n+     *\/\n+    private int column = 0;\n+\n+    \/**\n+     * if the current column is within a tab character (partially consumed tab)\n+     *\/\n+    private boolean columnIsInTab;\n+\n+    private int nextNonSpace = 0;\n+    private int nextNonSpaceColumn = 0;\n+    private int indent = 0;\n+    private boolean blank;\n+\n+    private final List<BlockParserFactory> blockParserFactories;\n+    private final InlineParserFactory inlineParserFactory;\n+    private final List<DelimiterProcessor> delimiterProcessors;\n+    private final IncludeSourceSpans includeSourceSpans;\n+    private final DocumentBlockParser documentBlockParser;\n+    private final LinkReferenceDefinitions definitions = new LinkReferenceDefinitions();\n+\n+    private final List<OpenBlockParser> openBlockParsers = new ArrayList<>();\n+    private final List<BlockParser> allBlockParsers = new ArrayList<>();\n+\n+    public DocumentParser(List<BlockParserFactory> blockParserFactories, InlineParserFactory inlineParserFactory,\n+                          List<DelimiterProcessor> delimiterProcessors, IncludeSourceSpans includeSourceSpans) {\n+        this.blockParserFactories = blockParserFactories;\n+        this.inlineParserFactory = inlineParserFactory;\n+        this.delimiterProcessors = delimiterProcessors;\n+        this.includeSourceSpans = includeSourceSpans;\n+\n+        this.documentBlockParser = new DocumentBlockParser();\n+        activateBlockParser(new OpenBlockParser(documentBlockParser, 0));\n+    }\n+\n+    public static Set<Class<? extends Block>> getDefaultBlockParserTypes() {\n+        return CORE_FACTORY_TYPES;\n+    }\n+\n+    public static List<BlockParserFactory> calculateBlockParserFactories(List<BlockParserFactory> customBlockParserFactories, Set<Class<? extends Block>> enabledBlockTypes) {\n+        List<BlockParserFactory> list = new ArrayList<>();\n+        \/\/ By having the custom factories come first, extensions are able to change behavior of core syntax.\n+        list.addAll(customBlockParserFactories);\n+        for (Class<? extends Block> blockType : enabledBlockTypes) {\n+            list.add(NODES_TO_CORE_FACTORIES.get(blockType));\n+        }\n+        return list;\n+    }\n+\n+    public static void checkEnabledBlockTypes(Set<Class<? extends Block>> enabledBlockTypes) {\n+        for (Class<? extends Block> enabledBlockType : enabledBlockTypes) {\n+            if (!NODES_TO_CORE_FACTORIES.containsKey(enabledBlockType)) {\n+                throw new IllegalArgumentException(\"Can't enable block type \" + enabledBlockType + \", possible options are: \" + NODES_TO_CORE_FACTORIES.keySet());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * The main parsing function. Returns a parsed document AST.\n+     *\/\n+    public Document parse(String input) {\n+        int lineStart = 0;\n+        int lineBreak;\n+        while ((lineBreak = Parsing.findLineBreak(input, lineStart)) != -1) {\n+            String line = input.substring(lineStart, lineBreak);\n+            parseLine(line);\n+            if (lineBreak + 1 < input.length() && input.charAt(lineBreak) == '\\r' && input.charAt(lineBreak + 1) == '\\n') {\n+                lineStart = lineBreak + 2;\n+            } else {\n+                lineStart = lineBreak + 1;\n+            }\n+        }\n+        if (input.length() > 0 && (lineStart == 0 || lineStart < input.length())) {\n+            String line = input.substring(lineStart);\n+            parseLine(line);\n+        }\n+\n+        return finalizeAndProcess();\n+    }\n+\n+    public Document parse(Reader input) throws IOException {\n+        BufferedReader bufferedReader;\n+        if (input instanceof BufferedReader) {\n+            bufferedReader = (BufferedReader) input;\n+        } else {\n+            bufferedReader = new BufferedReader(input);\n+        }\n+\n+        String line;\n+        while ((line = bufferedReader.readLine()) != null) {\n+            parseLine(line);\n+        }\n+\n+        return finalizeAndProcess();\n+    }\n+\n+    @Override\n+    public SourceLine getLine() {\n+        return line;\n+    }\n+\n+    @Override\n+    public int getIndex() {\n+        return index;\n+    }\n+\n+    @Override\n+    public int getNextNonSpaceIndex() {\n+        return nextNonSpace;\n+    }\n+\n+    @Override\n+    public int getColumn() {\n+        return column;\n+    }\n+\n+    @Override\n+    public int getIndent() {\n+        return indent;\n+    }\n+\n+    @Override\n+    public boolean isBlank() {\n+        return blank;\n+    }\n+\n+    @Override\n+    public BlockParser getActiveBlockParser() {\n+        return openBlockParsers.get(openBlockParsers.size() - 1).blockParser;\n+    }\n+\n+    \/**\n+     * Analyze a line of text and update the document appropriately. We parse markdown text by calling this on each\n+     * line of input, then finalizing the document.\n+     *\/\n+    private void parseLine(CharSequence ln) {\n+        setLine(ln);\n+\n+        \/\/ For each containing block, try to parse the associated line start.\n+        \/\/ The document will always match, so we can skip the first block parser and start at 1 matches\n+        int matches = 1;\n+        for (int i = 1; i < openBlockParsers.size(); i++) {\n+            OpenBlockParser openBlockParser = openBlockParsers.get(i);\n+            BlockParser blockParser = openBlockParser.blockParser;\n+            findNextNonSpace();\n+\n+            BlockContinue result = blockParser.tryContinue(this);\n+            if (result instanceof BlockContinueImpl) {\n+                BlockContinueImpl blockContinue = (BlockContinueImpl) result;\n+                openBlockParser.sourceIndex = getIndex();\n+                if (blockContinue.isFinalize()) {\n+                    addSourceSpans();\n+                    closeBlockParsers(openBlockParsers.size() - i);\n+                    return;\n+                } else {\n+                    if (blockContinue.getNewIndex() != -1) {\n+                        setNewIndex(blockContinue.getNewIndex());\n+                    } else if (blockContinue.getNewColumn() != -1) {\n+                        setNewColumn(blockContinue.getNewColumn());\n+                    }\n+                    matches++;\n+                }\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        int unmatchedBlocks = openBlockParsers.size() - matches;\n+        BlockParser blockParser = openBlockParsers.get(matches - 1).blockParser;\n+        boolean startedNewBlock = false;\n+\n+        int lastIndex = index;\n+\n+        \/\/ Unless last matched container is a code block, try new container starts,\n+        \/\/ adding children to the last matched container:\n+        boolean tryBlockStarts = blockParser.getBlock() instanceof Paragraph || blockParser.isContainer();\n+        while (tryBlockStarts) {\n+            lastIndex = index;\n+            findNextNonSpace();\n+\n+            \/\/ this is a little performance optimization:\n+            if (isBlank() || (indent < Parsing.CODE_BLOCK_INDENT && Parsing.isLetter(this.line.getContent(), nextNonSpace))) {\n+                setNewIndex(nextNonSpace);\n+                break;\n+            }\n+\n+            BlockStartImpl blockStart = findBlockStart(blockParser);\n+            if (blockStart == null) {\n+                setNewIndex(nextNonSpace);\n+                break;\n+            }\n+\n+            startedNewBlock = true;\n+            int sourceIndex = getIndex();\n+\n+            \/\/ We're starting a new block. If we have any previous blocks that need to be closed, we need to do it now.\n+            if (unmatchedBlocks > 0) {\n+                closeBlockParsers(unmatchedBlocks);\n+                unmatchedBlocks = 0;\n+            }\n+\n+            if (blockStart.getNewIndex() != -1) {\n+                setNewIndex(blockStart.getNewIndex());\n+            } else if (blockStart.getNewColumn() != -1) {\n+                setNewColumn(blockStart.getNewColumn());\n+            }\n+\n+            List<SourceSpan> replacedSourceSpans = null;\n+            if (blockStart.isReplaceActiveBlockParser()) {\n+                Block replacedBlock = prepareActiveBlockParserForReplacement();\n+                replacedSourceSpans = replacedBlock.getSourceSpans();\n+            }\n+\n+            for (BlockParser newBlockParser : blockStart.getBlockParsers()) {\n+                addChild(new OpenBlockParser(newBlockParser, sourceIndex));\n+                if (replacedSourceSpans != null) {\n+                    newBlockParser.getBlock().setSourceSpans(replacedSourceSpans);\n+                }\n+                blockParser = newBlockParser;\n+                tryBlockStarts = newBlockParser.isContainer();\n+            }\n+        }\n+\n+        \/\/ What remains at the offset is a text line. Add the text to the\n+        \/\/ appropriate block.\n+\n+        \/\/ First check for a lazy paragraph continuation:\n+        if (!startedNewBlock && !isBlank() &&\n+                getActiveBlockParser().canHaveLazyContinuationLines()) {\n+            openBlockParsers.get(openBlockParsers.size() - 1).sourceIndex = lastIndex;\n+            \/\/ lazy paragraph continuation\n+            addLine();\n+\n+        } else {\n+\n+            \/\/ finalize any blocks not matched\n+            if (unmatchedBlocks > 0) {\n+                closeBlockParsers(unmatchedBlocks);\n+            }\n+\n+            if (!blockParser.isContainer()) {\n+                addLine();\n+            } else if (!isBlank()) {\n+                \/\/ create paragraph container for line\n+                ParagraphParser paragraphParser = new ParagraphParser();\n+                addChild(new OpenBlockParser(paragraphParser, lastIndex));\n+                addLine();\n+            } else {\n+                \/\/ This can happen for a list item like this:\n+                \/\/ ```\n+                \/\/ *\n+                \/\/ list item\n+                \/\/ ```\n+                \/\/\n+                \/\/ The first line does not start a paragraph yet, but we still want to record source positions.\n+                addSourceSpans();\n+            }\n+        }\n+    }\n+\n+    private void setLine(CharSequence ln) {\n+        lineIndex++;\n+        index = 0;\n+        column = 0;\n+        columnIsInTab = false;\n+\n+        CharSequence lineContent = Parsing.prepareLine(ln);\n+        SourceSpan sourceSpan = null;\n+        if (includeSourceSpans != IncludeSourceSpans.NONE) {\n+            sourceSpan = SourceSpan.of(lineIndex, 0, lineContent.length());\n+        }\n+        this.line = SourceLine.of(lineContent, sourceSpan);\n+    }\n+\n+    private void findNextNonSpace() {\n+        int i = index;\n+        int cols = column;\n+\n+        blank = true;\n+        int length = line.getContent().length();\n+        while (i < length) {\n+            char c = line.getContent().charAt(i);\n+            switch (c) {\n+                case ' ':\n+                    i++;\n+                    cols++;\n+                    continue;\n+                case '\\t':\n+                    i++;\n+                    cols += (4 - (cols % 4));\n+                    continue;\n+            }\n+            blank = false;\n+            break;\n+        }\n+\n+        nextNonSpace = i;\n+        nextNonSpaceColumn = cols;\n+        indent = nextNonSpaceColumn - column;\n+    }\n+\n+    private void setNewIndex(int newIndex) {\n+        if (newIndex >= nextNonSpace) {\n+            \/\/ We can start from here, no need to calculate tab stops again\n+            index = nextNonSpace;\n+            column = nextNonSpaceColumn;\n+        }\n+        int length = line.getContent().length();\n+        while (index < newIndex && index != length) {\n+            advance();\n+        }\n+        \/\/ If we're going to an index as opposed to a column, we're never within a tab\n+        columnIsInTab = false;\n+    }\n+\n+    private void setNewColumn(int newColumn) {\n+        if (newColumn >= nextNonSpaceColumn) {\n+            \/\/ We can start from here, no need to calculate tab stops again\n+            index = nextNonSpace;\n+            column = nextNonSpaceColumn;\n+        }\n+        int length = line.getContent().length();\n+        while (column < newColumn && index != length) {\n+            advance();\n+        }\n+        if (column > newColumn) {\n+            \/\/ Last character was a tab and we overshot our target\n+            index--;\n+            column = newColumn;\n+            columnIsInTab = true;\n+        } else {\n+            columnIsInTab = false;\n+        }\n+    }\n+\n+    private void advance() {\n+        char c = line.getContent().charAt(index);\n+        index++;\n+        if (c == '\\t') {\n+            column += Parsing.columnsToNextTabStop(column);\n+        } else {\n+            column++;\n+        }\n+    }\n+\n+    \/**\n+     * Add line content to the active block parser. We assume it can accept lines -- that check should be done before\n+     * calling this.\n+     *\/\n+    private void addLine() {\n+        CharSequence content;\n+        if (columnIsInTab) {\n+            \/\/ Our column is in a partially consumed tab. Expand the remaining columns (to the next tab stop) to spaces.\n+            int afterTab = index + 1;\n+            CharSequence rest = line.getContent().subSequence(afterTab, line.getContent().length());\n+            int spaces = Parsing.columnsToNextTabStop(column);\n+            StringBuilder sb = new StringBuilder(spaces + rest.length());\n+            for (int i = 0; i < spaces; i++) {\n+                sb.append(' ');\n+            }\n+            sb.append(rest);\n+            content = sb.toString();\n+        } else if (index == 0) {\n+            content = line.getContent();\n+        } else {\n+            content = line.getContent().subSequence(index, line.getContent().length());\n+        }\n+        SourceSpan sourceSpan = null;\n+        if (includeSourceSpans == IncludeSourceSpans.BLOCKS_AND_INLINES) {\n+            \/\/ Note that if we're in a partially-consumed tab, the length here corresponds to the content but not to the\n+            \/\/ actual source length. That sounds like a problem, but I haven't found a test case where it matters (yet).\n+            sourceSpan = SourceSpan.of(lineIndex, index, content.length());\n+        }\n+        getActiveBlockParser().addLine(SourceLine.of(content, sourceSpan));\n+        addSourceSpans();\n+    }\n+\n+    private void addSourceSpans() {\n+        if (includeSourceSpans != IncludeSourceSpans.NONE) {\n+            \/\/ Don't add source spans for Document itself (it would get the whole source text)\n+            for (int i = 1; i < openBlockParsers.size(); i++) {\n+                OpenBlockParser openBlockParser = openBlockParsers.get(i);\n+                int blockIndex = openBlockParser.sourceIndex;\n+                int length = line.getContent().length() - blockIndex;\n+                if (length != 0) {\n+                    openBlockParser.blockParser.addSourceSpan(SourceSpan.of(lineIndex, blockIndex, length));\n+                }\n+            }\n+        }\n+    }\n+\n+    private BlockStartImpl findBlockStart(BlockParser blockParser) {\n+        MatchedBlockParser matchedBlockParser = new MatchedBlockParserImpl(blockParser);\n+        for (BlockParserFactory blockParserFactory : blockParserFactories) {\n+            BlockStart result = blockParserFactory.tryStart(this, matchedBlockParser);\n+            if (result instanceof BlockStartImpl) {\n+                return (BlockStartImpl) result;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Finalize a block. Close it and do any necessary postprocessing, e.g. setting the content of blocks and\n+     * collecting link reference definitions from paragraphs.\n+     *\/\n+    private void finalize(BlockParser blockParser) {\n+        if (blockParser instanceof ParagraphParser) {\n+            addDefinitionsFrom((ParagraphParser) blockParser);\n+        }\n+\n+        blockParser.closeBlock();\n+    }\n+\n+    private void addDefinitionsFrom(ParagraphParser paragraphParser) {\n+        for (LinkReferenceDefinition definition : paragraphParser.getDefinitions()) {\n+            \/\/ Add nodes into document before paragraph.\n+            paragraphParser.getBlock().insertBefore(definition);\n+\n+            definitions.add(definition);\n+        }\n+    }\n+\n+    \/**\n+     * Walk through a block & children recursively, parsing string content into inline content where appropriate.\n+     *\/\n+    private void processInlines() {\n+        InlineParserContextImpl context = new InlineParserContextImpl(delimiterProcessors, definitions);\n+        InlineParser inlineParser = inlineParserFactory.create(context);\n+\n+        for (BlockParser blockParser : allBlockParsers) {\n+            blockParser.parseInlines(inlineParser);\n+        }\n+    }\n+\n+    \/**\n+     * Add block of type tag as a child of the tip. If the tip can't accept children, close and finalize it and try\n+     * its parent, and so on until we find a block that can accept children.\n+     *\/\n+    private void addChild(OpenBlockParser openBlockParser) {\n+        while (!getActiveBlockParser().canContain(openBlockParser.blockParser.getBlock())) {\n+            closeBlockParsers(1);\n+        }\n+\n+        getActiveBlockParser().getBlock().appendChild(openBlockParser.blockParser.getBlock());\n+        activateBlockParser(openBlockParser);\n+    }\n+\n+    private void activateBlockParser(OpenBlockParser openBlockParser) {\n+        openBlockParsers.add(openBlockParser);\n+    }\n+\n+    private OpenBlockParser deactivateBlockParser() {\n+        return openBlockParsers.remove(openBlockParsers.size() - 1);\n+    }\n+\n+    private Block prepareActiveBlockParserForReplacement() {\n+        \/\/ Note that we don't want to parse inlines, as it's getting replaced.\n+        BlockParser old = deactivateBlockParser().blockParser;\n+\n+        if (old instanceof ParagraphParser) {\n+            ParagraphParser paragraphParser = (ParagraphParser) old;\n+            \/\/ Collect any link reference definitions. Note that replacing the active block parser is done after a\n+            \/\/ block parser got the current paragraph content using MatchedBlockParser#getContentString. In case the\n+            \/\/ paragraph started with link reference definitions, we parse and strip them before the block parser gets\n+            \/\/ the content. We want to keep them.\n+            \/\/ If no replacement happens, we collect the definitions as part of finalizing paragraph blocks.\n+            addDefinitionsFrom(paragraphParser);\n+        }\n+\n+        \/\/ Do this so that source positions are calculated, which we will carry over to the replacing block.\n+        old.closeBlock();\n+        old.getBlock().unlink();\n+        return old.getBlock();\n+    }\n+\n+    private Document finalizeAndProcess() {\n+        closeBlockParsers(openBlockParsers.size());\n+        processInlines();\n+        return documentBlockParser.getBlock();\n+    }\n+\n+    private void closeBlockParsers(int count) {\n+        for (int i = 0; i < count; i++) {\n+            BlockParser blockParser = deactivateBlockParser().blockParser;\n+            finalize(blockParser);\n+            \/\/ Remember for inline parsing. Note that a lot of blocks don't need inline parsing. We could have a\n+            \/\/ separate interface (e.g. BlockParserWithInlines) so that we only have to remember those that actually\n+            \/\/ have inlines to parse.\n+            allBlockParsers.add(blockParser);\n+        }\n+    }\n+\n+    private static class MatchedBlockParserImpl implements MatchedBlockParser {\n+\n+        private final BlockParser matchedBlockParser;\n+\n+        public MatchedBlockParserImpl(BlockParser matchedBlockParser) {\n+            this.matchedBlockParser = matchedBlockParser;\n+        }\n+\n+        @Override\n+        public BlockParser getMatchedBlockParser() {\n+            return matchedBlockParser;\n+        }\n+\n+        @Override\n+        public SourceLines getParagraphLines() {\n+            if (matchedBlockParser instanceof ParagraphParser) {\n+                ParagraphParser paragraphParser = (ParagraphParser) matchedBlockParser;\n+                return paragraphParser.getParagraphLines();\n+            }\n+            return SourceLines.empty();\n+        }\n+    }\n+\n+    private static class OpenBlockParser {\n+        private final BlockParser blockParser;\n+        private int sourceIndex;\n+\n+        OpenBlockParser(BlockParser blockParser, int sourceIndex) {\n+            this.blockParser = blockParser;\n+            this.sourceIndex = sourceIndex;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/DocumentParser.java","additions":609,"deletions":0,"binary":false,"changes":609,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.FencedCodeBlock;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.block.*;\n+\n+import static jdk.internal.org.commonmark.internal.util.Escaping.unescapeString;\n+\n+public class FencedCodeBlockParser extends AbstractBlockParser {\n+\n+    private final FencedCodeBlock block = new FencedCodeBlock();\n+\n+    private String firstLine;\n+    private StringBuilder otherLines = new StringBuilder();\n+\n+    public FencedCodeBlockParser(char fenceChar, int fenceLength, int fenceIndent) {\n+        block.setFenceChar(fenceChar);\n+        block.setFenceLength(fenceLength);\n+        block.setFenceIndent(fenceIndent);\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        int nextNonSpace = state.getNextNonSpaceIndex();\n+        int newIndex = state.getIndex();\n+        CharSequence line = state.getLine().getContent();\n+        if (state.getIndent() < Parsing.CODE_BLOCK_INDENT && nextNonSpace < line.length() && line.charAt(nextNonSpace) == block.getFenceChar() && isClosing(line, nextNonSpace)) {\n+            \/\/ closing fence - we're at end of line, so we can finalize now\n+            return BlockContinue.finished();\n+        } else {\n+            \/\/ skip optional spaces of fence indent\n+            int i = block.getFenceIndent();\n+            int length = line.length();\n+            while (i > 0 && newIndex < length && line.charAt(newIndex) == ' ') {\n+                newIndex++;\n+                i--;\n+            }\n+        }\n+        return BlockContinue.atIndex(newIndex);\n+    }\n+\n+    @Override\n+    public void addLine(SourceLine line) {\n+        if (firstLine == null) {\n+            firstLine = line.getContent().toString();\n+        } else {\n+            otherLines.append(line.getContent());\n+            otherLines.append('\\n');\n+        }\n+    }\n+\n+    @Override\n+    public void closeBlock() {\n+        \/\/ first line becomes info string\n+        block.setInfo(unescapeString(firstLine.trim()));\n+        block.setLiteral(otherLines.toString());\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+\n+        @Override\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            int indent = state.getIndent();\n+            if (indent >= Parsing.CODE_BLOCK_INDENT) {\n+                return BlockStart.none();\n+            }\n+\n+            int nextNonSpace = state.getNextNonSpaceIndex();\n+            FencedCodeBlockParser blockParser = checkOpener(state.getLine().getContent(), nextNonSpace, indent);\n+            if (blockParser != null) {\n+                return BlockStart.of(blockParser).atIndex(nextNonSpace + blockParser.block.getFenceLength());\n+            } else {\n+                return BlockStart.none();\n+            }\n+        }\n+    }\n+\n+    \/\/ spec: A code fence is a sequence of at least three consecutive backtick characters (`) or tildes (~). (Tildes and\n+    \/\/ backticks cannot be mixed.)\n+    private static FencedCodeBlockParser checkOpener(CharSequence line, int index, int indent) {\n+        int backticks = 0;\n+        int tildes = 0;\n+        int length = line.length();\n+        loop:\n+        for (int i = index; i < length; i++) {\n+            switch (line.charAt(i)) {\n+                case '`':\n+                    backticks++;\n+                    break;\n+                case '~':\n+                    tildes++;\n+                    break;\n+                default:\n+                    break loop;\n+            }\n+        }\n+        if (backticks >= 3 && tildes == 0) {\n+            \/\/ spec: If the info string comes after a backtick fence, it may not contain any backtick characters.\n+            if (Parsing.find('`', line, index + backticks) != -1) {\n+                return null;\n+            }\n+            return new FencedCodeBlockParser('`', backticks, indent);\n+        } else if (tildes >= 3 && backticks == 0) {\n+            \/\/ spec: Info strings for tilde code blocks can contain backticks and tildes\n+            return new FencedCodeBlockParser('~', tildes, indent);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ spec: The content of the code block consists of all subsequent lines, until a closing code fence of the same type\n+    \/\/ as the code block began with (backticks or tildes), and with at least as many backticks or tildes as the opening\n+    \/\/ code fence.\n+    private boolean isClosing(CharSequence line, int index) {\n+        char fenceChar = block.getFenceChar();\n+        int fenceLength = block.getFenceLength();\n+        int fences = Parsing.skip(fenceChar, line, index, line.length()) - index;\n+        if (fences < fenceLength) {\n+            return false;\n+        }\n+        \/\/ spec: The closing code fence [...] may be followed only by spaces, which are ignored.\n+        int after = Parsing.skipSpaceTab(line, index + fences, line.length());\n+        return after == line.length();\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/FencedCodeBlockParser.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.inline.Position;\n+import jdk.internal.org.commonmark.internal.inline.Scanner;\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.Heading;\n+import jdk.internal.org.commonmark.parser.InlineParser;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+import jdk.internal.org.commonmark.parser.block.*;\n+\n+public class HeadingParser extends AbstractBlockParser {\n+\n+    private final Heading block = new Heading();\n+    private final SourceLines content;\n+\n+    public HeadingParser(int level, SourceLines content) {\n+        block.setLevel(level);\n+        this.content = content;\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState parserState) {\n+        \/\/ In both ATX and Setext headings, once we have the heading markup, there's nothing more to parse.\n+        return BlockContinue.none();\n+    }\n+\n+    @Override\n+    public void parseInlines(InlineParser inlineParser) {\n+        inlineParser.parse(content, block);\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+\n+        @Override\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            if (state.getIndent() >= Parsing.CODE_BLOCK_INDENT) {\n+                return BlockStart.none();\n+            }\n+\n+            SourceLine line = state.getLine();\n+            int nextNonSpace = state.getNextNonSpaceIndex();\n+            if (line.getContent().charAt(nextNonSpace) == '#') {\n+                HeadingParser atxHeading = getAtxHeading(line.substring(nextNonSpace, line.getContent().length()));\n+                if (atxHeading != null) {\n+                    return BlockStart.of(atxHeading).atIndex(line.getContent().length());\n+                }\n+            }\n+\n+            int setextHeadingLevel = getSetextHeadingLevel(line.getContent(), nextNonSpace);\n+            if (setextHeadingLevel > 0) {\n+                SourceLines paragraph = matchedBlockParser.getParagraphLines();\n+                if (!paragraph.isEmpty()) {\n+                    return BlockStart.of(new HeadingParser(setextHeadingLevel, paragraph))\n+                            .atIndex(line.getContent().length())\n+                            .replaceActiveBlockParser();\n+                }\n+            }\n+\n+            return BlockStart.none();\n+        }\n+    }\n+\n+    \/\/ spec: An ATX heading consists of a string of characters, parsed as inline content, between an opening sequence of\n+    \/\/ 1\\u20136 unescaped # characters and an optional closing sequence of any number of unescaped # characters. The opening\n+    \/\/ sequence of # characters must be followed by a space or by the end of line. The optional closing sequence of #s\n+    \/\/ must be preceded by a space and may be followed by spaces only.\n+    private static HeadingParser getAtxHeading(SourceLine line) {\n+        Scanner scanner = Scanner.of(SourceLines.of(line));\n+        int level = scanner.matchMultiple('#');\n+\n+        if (level == 0 || level > 6) {\n+            return null;\n+        }\n+\n+        if (!scanner.hasNext()) {\n+            \/\/ End of line after markers is an empty heading\n+            return new HeadingParser(level, SourceLines.empty());\n+        }\n+\n+        char next = scanner.peek();\n+        if (!(next == ' ' || next == '\\t')) {\n+            return null;\n+        }\n+\n+        scanner.whitespace();\n+        Position start = scanner.position();\n+        Position end = start;\n+        boolean hashCanEnd = true;\n+\n+        while (scanner.hasNext()) {\n+            char c = scanner.peek();\n+            switch (c) {\n+                case '#':\n+                    if (hashCanEnd) {\n+                        scanner.matchMultiple('#');\n+                        int whitespace = scanner.whitespace();\n+                        \/\/ If there's other characters, the hashes and spaces were part of the heading\n+                        if (scanner.hasNext()) {\n+                            end = scanner.position();\n+                        }\n+                        hashCanEnd = whitespace > 0;\n+                    } else {\n+                        scanner.next();\n+                        end = scanner.position();\n+                    }\n+                    break;\n+                case ' ':\n+                case '\\t':\n+                    hashCanEnd = true;\n+                    scanner.next();\n+                    break;\n+                default:\n+                    hashCanEnd = false;\n+                    scanner.next();\n+                    end = scanner.position();\n+            }\n+        }\n+\n+        SourceLines source = scanner.getSource(start, end);\n+        String content = source.getContent();\n+        if (content.isEmpty()) {\n+            return new HeadingParser(level, SourceLines.empty());\n+        }\n+        return new HeadingParser(level, source);\n+    }\n+\n+    \/\/ spec: A setext heading underline is a sequence of = characters or a sequence of - characters, with no more than\n+    \/\/ 3 spaces indentation and any number of trailing spaces.\n+    @SuppressWarnings(\"fallthrough\") private static int getSetextHeadingLevel(CharSequence line, int index) {\n+        switch (line.charAt(index)) {\n+            case '=':\n+                if (isSetextHeadingRest(line, index + 1, '=')) {\n+                    return 1;\n+                }\n+            case '-':\n+                if (isSetextHeadingRest(line, index + 1, '-')) {\n+                    return 2;\n+                }\n+        }\n+        return 0;\n+    }\n+\n+    private static boolean isSetextHeadingRest(CharSequence line, int index, char marker) {\n+        int afterMarker = Parsing.skip(marker, line, index, line.length());\n+        int afterSpace = Parsing.skipSpaceTab(line, afterMarker, line.length());\n+        return afterSpace >= line.length();\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/HeadingParser.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.HtmlBlock;\n+import jdk.internal.org.commonmark.node.Paragraph;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.block.*;\n+\n+import java.util.regex.Pattern;\n+\n+public class HtmlBlockParser extends AbstractBlockParser {\n+\n+    private static final Pattern[][] BLOCK_PATTERNS = new Pattern[][]{\n+            {null, null}, \/\/ not used (no type 0)\n+            {\n+                    Pattern.compile(\"^<(?:script|pre|style|textarea)(?:\\\\s|>|$)\", Pattern.CASE_INSENSITIVE),\n+                    Pattern.compile(\"<\/(?:script|pre|style|textarea)>\", Pattern.CASE_INSENSITIVE)\n+            },\n+            {\n+                    Pattern.compile(\"^<!--\"),\n+                    Pattern.compile(\"-->\")\n+            },\n+            {\n+                    Pattern.compile(\"^<[?]\"),\n+                    Pattern.compile(\"\\\\?>\")\n+            },\n+            {\n+                    Pattern.compile(\"^<![A-Z]\"),\n+                    Pattern.compile(\">\")\n+            },\n+            {\n+                    Pattern.compile(\"^<!\\\\[CDATA\\\\[\"),\n+                    Pattern.compile(\"\\\\]\\\\]>\")\n+            },\n+            {\n+                    Pattern.compile(\"^<\/?(?:\" +\n+                            \"address|article|aside|\" +\n+                            \"base|basefont|blockquote|body|\" +\n+                            \"caption|center|col|colgroup|\" +\n+                            \"dd|details|dialog|dir|div|dl|dt|\" +\n+                            \"fieldset|figcaption|figure|footer|form|frame|frameset|\" +\n+                            \"h1|h2|h3|h4|h5|h6|head|header|hr|html|\" +\n+                            \"iframe|\" +\n+                            \"legend|li|link|\" +\n+                            \"main|menu|menuitem|\" +\n+                            \"nav|noframes|\" +\n+                            \"ol|optgroup|option|\" +\n+                            \"p|param|\" +\n+                            \"section|source|summary|\" +\n+                            \"table|tbody|td|tfoot|th|thead|title|tr|track|\" +\n+                            \"ul\" +\n+                            \")(?:\\\\s|[\/]?[>]|$)\", Pattern.CASE_INSENSITIVE),\n+                    null \/\/ terminated by blank line\n+            },\n+            {\n+                    Pattern.compile(\"^(?:\" + Parsing.OPENTAG + '|' + Parsing.CLOSETAG + \")\\\\s*$\", Pattern.CASE_INSENSITIVE),\n+                    null \/\/ terminated by blank line\n+            }\n+    };\n+\n+    private final HtmlBlock block = new HtmlBlock();\n+    private final Pattern closingPattern;\n+\n+    private boolean finished = false;\n+    private BlockContent content = new BlockContent();\n+\n+    private HtmlBlockParser(Pattern closingPattern) {\n+        this.closingPattern = closingPattern;\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        if (finished) {\n+            return BlockContinue.none();\n+        }\n+\n+        \/\/ Blank line ends type 6 and type 7 blocks\n+        if (state.isBlank() && closingPattern == null) {\n+            return BlockContinue.none();\n+        } else {\n+            return BlockContinue.atIndex(state.getIndex());\n+        }\n+    }\n+\n+    @Override\n+    public void addLine(SourceLine line) {\n+        content.add(line.getContent());\n+\n+        if (closingPattern != null && closingPattern.matcher(line.getContent()).find()) {\n+            finished = true;\n+        }\n+    }\n+\n+    @Override\n+    public void closeBlock() {\n+        block.setLiteral(content.getString());\n+        content = null;\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+\n+        @Override\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            int nextNonSpace = state.getNextNonSpaceIndex();\n+            CharSequence line = state.getLine().getContent();\n+\n+            if (state.getIndent() < 4 && line.charAt(nextNonSpace) == '<') {\n+                for (int blockType = 1; blockType <= 7; blockType++) {\n+                    \/\/ Type 7 can not interrupt a paragraph (not even a lazy one)\n+                    if (blockType == 7 && (\n+                            matchedBlockParser.getMatchedBlockParser().getBlock() instanceof Paragraph ||\n+                                    state.getActiveBlockParser().canHaveLazyContinuationLines())) {\n+                        continue;\n+                    }\n+                    Pattern opener = BLOCK_PATTERNS[blockType][0];\n+                    Pattern closer = BLOCK_PATTERNS[blockType][1];\n+                    boolean matches = opener.matcher(line.subSequence(nextNonSpace, line.length())).find();\n+                    if (matches) {\n+                        return BlockStart.of(new HtmlBlockParser(closer)).atIndex(state.getIndex());\n+                    }\n+                }\n+            }\n+            return BlockStart.none();\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/HtmlBlockParser.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.IndentedCodeBlock;\n+import jdk.internal.org.commonmark.node.Paragraph;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.block.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class IndentedCodeBlockParser extends AbstractBlockParser {\n+\n+    private final IndentedCodeBlock block = new IndentedCodeBlock();\n+    private final List<CharSequence> lines = new ArrayList<>();\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        if (state.getIndent() >= Parsing.CODE_BLOCK_INDENT) {\n+            return BlockContinue.atColumn(state.getColumn() + Parsing.CODE_BLOCK_INDENT);\n+        } else if (state.isBlank()) {\n+            return BlockContinue.atIndex(state.getNextNonSpaceIndex());\n+        } else {\n+            return BlockContinue.none();\n+        }\n+    }\n+\n+    @Override\n+    public void addLine(SourceLine line) {\n+        lines.add(line.getContent());\n+    }\n+\n+    @Override\n+    public void closeBlock() {\n+        int lastNonBlank = lines.size() - 1;\n+        while (lastNonBlank >= 0) {\n+            if (!Parsing.isBlank(lines.get(lastNonBlank))) {\n+                break;\n+            }\n+            lastNonBlank--;\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < lastNonBlank + 1; i++) {\n+            sb.append(lines.get(i));\n+            sb.append('\\n');\n+        }\n+\n+        String literal = sb.toString();\n+        block.setLiteral(literal);\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+\n+        @Override\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            \/\/ An indented code block cannot interrupt a paragraph.\n+            if (state.getIndent() >= Parsing.CODE_BLOCK_INDENT && !state.isBlank() && !(state.getActiveBlockParser().getBlock() instanceof Paragraph)) {\n+                return BlockStart.of(new IndentedCodeBlockParser()).atColumn(state.getColumn() + Parsing.CODE_BLOCK_INDENT);\n+            } else {\n+                return BlockStart.none();\n+            }\n+        }\n+    }\n+}\n+\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/IndentedCodeBlockParser.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.node.LinkReferenceDefinition;\n+import jdk.internal.org.commonmark.parser.InlineParserContext;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class InlineParserContextImpl implements InlineParserContext {\n+\n+    private final List<DelimiterProcessor> delimiterProcessors;\n+    private final LinkReferenceDefinitions linkReferenceDefinitions;\n+\n+    public InlineParserContextImpl(List<DelimiterProcessor> delimiterProcessors,\n+                                   LinkReferenceDefinitions linkReferenceDefinitions) {\n+        this.delimiterProcessors = delimiterProcessors;\n+        this.linkReferenceDefinitions = linkReferenceDefinitions;\n+    }\n+\n+    @Override\n+    public List<DelimiterProcessor> getCustomDelimiterProcessors() {\n+        return delimiterProcessors;\n+    }\n+\n+    @Override\n+    public LinkReferenceDefinition getLinkReferenceDefinition(String label) {\n+        return linkReferenceDefinitions.get(label);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/InlineParserContextImpl.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,786 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.inline.Scanner;\n+import jdk.internal.org.commonmark.internal.inline.*;\n+import jdk.internal.org.commonmark.internal.util.Escaping;\n+import jdk.internal.org.commonmark.internal.util.LinkScanner;\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.parser.InlineParser;\n+import jdk.internal.org.commonmark.parser.InlineParserContext;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+\n+import java.util.*;\n+\n+public class InlineParserImpl implements InlineParser, InlineParserState {\n+\n+    private final BitSet specialCharacters;\n+    private final Map<Character, DelimiterProcessor> delimiterProcessors;\n+    private final InlineParserContext context;\n+    private final Map<Character, List<InlineContentParser>> inlineParsers;\n+\n+    private Scanner scanner;\n+    private boolean includeSourceSpans;\n+    private int trailingSpaces;\n+\n+    \/**\n+     * Top delimiter (emphasis, strong emphasis or custom emphasis). (Brackets are on a separate stack, different\n+     * from the algorithm described in the spec.)\n+     *\/\n+    private Delimiter lastDelimiter;\n+\n+    \/**\n+     * Top opening bracket (<code>[<\/code> or <code>![)<\/code>).\n+     *\/\n+    private Bracket lastBracket;\n+\n+    public InlineParserImpl(InlineParserContext inlineParserContext) {\n+        this.delimiterProcessors = calculateDelimiterProcessors(inlineParserContext.getCustomDelimiterProcessors());\n+\n+        this.context = inlineParserContext;\n+        this.inlineParsers = new HashMap<>();\n+        this.inlineParsers.put('\\\\', Collections.<InlineContentParser>singletonList(new BackslashInlineParser()));\n+        this.inlineParsers.put('`', Collections.<InlineContentParser>singletonList(new BackticksInlineParser()));\n+        this.inlineParsers.put('&', Collections.<InlineContentParser>singletonList(new EntityInlineParser()));\n+        this.inlineParsers.put('<', Arrays.asList(new AutolinkInlineParser(), new HtmlInlineParser()));\n+\n+        this.specialCharacters = calculateSpecialCharacters(this.delimiterProcessors.keySet(), inlineParsers.keySet());\n+    }\n+\n+    public static BitSet calculateSpecialCharacters(Set<Character> delimiterCharacters, Set<Character> characters) {\n+        BitSet bitSet = new BitSet();\n+        for (Character c : delimiterCharacters) {\n+            bitSet.set(c);\n+        }\n+        for (Character c : characters) {\n+            bitSet.set(c);\n+        }\n+        bitSet.set('[');\n+        bitSet.set(']');\n+        bitSet.set('!');\n+        bitSet.set('\\n');\n+        return bitSet;\n+    }\n+\n+    public static Map<Character, DelimiterProcessor> calculateDelimiterProcessors(List<DelimiterProcessor> delimiterProcessors) {\n+        Map<Character, DelimiterProcessor> map = new HashMap<>();\n+        addDelimiterProcessors(Arrays.<DelimiterProcessor>asList(new AsteriskDelimiterProcessor(), new UnderscoreDelimiterProcessor()), map);\n+        addDelimiterProcessors(delimiterProcessors, map);\n+        return map;\n+    }\n+\n+    @Override\n+    public Scanner scanner() {\n+        return scanner;\n+    }\n+\n+    private static void addDelimiterProcessors(Iterable<DelimiterProcessor> delimiterProcessors, Map<Character, DelimiterProcessor> map) {\n+        for (DelimiterProcessor delimiterProcessor : delimiterProcessors) {\n+            char opening = delimiterProcessor.getOpeningCharacter();\n+            char closing = delimiterProcessor.getClosingCharacter();\n+            if (opening == closing) {\n+                DelimiterProcessor old = map.get(opening);\n+                if (old != null && old.getOpeningCharacter() == old.getClosingCharacter()) {\n+                    StaggeredDelimiterProcessor s;\n+                    if (old instanceof StaggeredDelimiterProcessor) {\n+                        s = (StaggeredDelimiterProcessor) old;\n+                    } else {\n+                        s = new StaggeredDelimiterProcessor(opening);\n+                        s.add(old);\n+                    }\n+                    s.add(delimiterProcessor);\n+                    map.put(opening, s);\n+                } else {\n+                    addDelimiterProcessorForChar(opening, delimiterProcessor, map);\n+                }\n+            } else {\n+                addDelimiterProcessorForChar(opening, delimiterProcessor, map);\n+                addDelimiterProcessorForChar(closing, delimiterProcessor, map);\n+            }\n+        }\n+    }\n+\n+    private static void addDelimiterProcessorForChar(char delimiterChar, DelimiterProcessor toAdd, Map<Character, DelimiterProcessor> delimiterProcessors) {\n+        DelimiterProcessor existing = delimiterProcessors.put(delimiterChar, toAdd);\n+        if (existing != null) {\n+            throw new IllegalArgumentException(\"Delimiter processor conflict with delimiter char '\" + delimiterChar + \"'\");\n+        }\n+    }\n+\n+    \/**\n+     * Parse content in block into inline children, appending them to the block node.\n+     *\/\n+    @Override\n+    public void parse(SourceLines lines, Node block) {\n+        reset(lines);\n+\n+        while (true) {\n+            List<? extends Node> nodes = parseInline();\n+            if (nodes != null) {\n+                for (Node node : nodes) {\n+                    block.appendChild(node);\n+                }\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        processDelimiters(null);\n+        mergeChildTextNodes(block);\n+    }\n+\n+    void reset(SourceLines lines) {\n+        this.scanner = Scanner.of(lines);\n+        this.includeSourceSpans = !lines.getSourceSpans().isEmpty();\n+        this.trailingSpaces = 0;\n+        this.lastDelimiter = null;\n+        this.lastBracket = null;\n+    }\n+\n+    private Text text(SourceLines sourceLines) {\n+        Text text = new Text(sourceLines.getContent());\n+        text.setSourceSpans(sourceLines.getSourceSpans());\n+        return text;\n+    }\n+\n+    \/**\n+     * Parse the next inline element in subject, advancing our position.\n+     * On success, return the new inline node.\n+     * On failure, return null.\n+     *\/\n+    private List<? extends Node> parseInline() {\n+        char c = scanner.peek();\n+\n+        switch (c) {\n+            case '[':\n+                return Collections.singletonList(parseOpenBracket());\n+            case '!':\n+                return Collections.singletonList(parseBang());\n+            case ']':\n+                return Collections.singletonList(parseCloseBracket());\n+            case '\\n':\n+                return Collections.singletonList(parseLineBreak());\n+            case Scanner.END:\n+                return null;\n+        }\n+\n+        \/\/ No inline parser, delimiter or other special handling.\n+        if (!specialCharacters.get(c)) {\n+            return Collections.singletonList(parseText());\n+        }\n+\n+        List<InlineContentParser> inlineParsers = this.inlineParsers.get(c);\n+        if (inlineParsers != null) {\n+            Position position = scanner.position();\n+            for (InlineContentParser inlineParser : inlineParsers) {\n+                ParsedInline parsedInline = inlineParser.tryParse(this);\n+                if (parsedInline instanceof ParsedInlineImpl) {\n+                    ParsedInlineImpl parsedInlineImpl = (ParsedInlineImpl) parsedInline;\n+                    Node node = parsedInlineImpl.getNode();\n+                    scanner.setPosition(parsedInlineImpl.getPosition());\n+                    if (includeSourceSpans && node.getSourceSpans().isEmpty()) {\n+                        node.setSourceSpans(scanner.getSource(position, scanner.position()).getSourceSpans());\n+                    }\n+                    return Collections.singletonList(node);\n+                } else {\n+                    \/\/ Reset position\n+                    scanner.setPosition(position);\n+                }\n+            }\n+        }\n+\n+        DelimiterProcessor delimiterProcessor = delimiterProcessors.get(c);\n+        if (delimiterProcessor != null) {\n+            List<? extends Node> nodes = parseDelimiters(delimiterProcessor, c);\n+            if (nodes != null) {\n+                return nodes;\n+            }\n+        }\n+\n+        \/\/ If we get here, even for a special\/delimiter character, we will just treat it as text.\n+        return Collections.singletonList(parseText());\n+    }\n+\n+    \/**\n+     * Attempt to parse delimiters like emphasis, strong emphasis or custom delimiters.\n+     *\/\n+    private List<? extends Node> parseDelimiters(DelimiterProcessor delimiterProcessor, char delimiterChar) {\n+        DelimiterData res = scanDelimiters(delimiterProcessor, delimiterChar);\n+        if (res == null) {\n+            return null;\n+        }\n+\n+        List<Text> characters = res.characters;\n+\n+        \/\/ Add entry to stack for this opener\n+        lastDelimiter = new Delimiter(characters, delimiterChar, res.canOpen, res.canClose, lastDelimiter);\n+        if (lastDelimiter.previous != null) {\n+            lastDelimiter.previous.next = lastDelimiter;\n+        }\n+\n+        return characters;\n+    }\n+\n+    \/**\n+     * Add open bracket to delimiter stack and add a text node to block's children.\n+     *\/\n+    private Node parseOpenBracket() {\n+        Position start = scanner.position();\n+        scanner.next();\n+        Position contentPosition = scanner.position();\n+\n+        Text node = text(scanner.getSource(start, contentPosition));\n+\n+        \/\/ Add entry to stack for this opener\n+        addBracket(Bracket.link(node, start, contentPosition, lastBracket, lastDelimiter));\n+\n+        return node;\n+    }\n+\n+    \/**\n+     * If next character is [, and ! delimiter to delimiter stack and add a text node to block's children.\n+     * Otherwise just add a text node.\n+     *\/\n+    private Node parseBang() {\n+        Position start = scanner.position();\n+        scanner.next();\n+        if (scanner.next('[')) {\n+            Position contentPosition = scanner.position();\n+            Text node = text(scanner.getSource(start, contentPosition));\n+\n+            \/\/ Add entry to stack for this opener\n+            addBracket(Bracket.image(node, start, contentPosition, lastBracket, lastDelimiter));\n+            return node;\n+        } else {\n+            return text(scanner.getSource(start, scanner.position()));\n+        }\n+    }\n+\n+    \/**\n+     * Try to match close bracket against an opening in the delimiter stack. Return either a link or image, or a\n+     * plain [ character. If there is a matching delimiter, remove it from the delimiter stack.\n+     *\/\n+    private Node parseCloseBracket() {\n+        Position beforeClose = scanner.position();\n+        scanner.next();\n+        Position afterClose = scanner.position();\n+\n+        \/\/ Get previous `[` or `![`\n+        Bracket opener = lastBracket;\n+        if (opener == null) {\n+            \/\/ No matching opener, just return a literal.\n+            return text(scanner.getSource(beforeClose, afterClose));\n+        }\n+\n+        if (!opener.allowed) {\n+            \/\/ Matching opener but it's not allowed, just return a literal.\n+            removeLastBracket();\n+            return text(scanner.getSource(beforeClose, afterClose));\n+        }\n+\n+        \/\/ Check to see if we have a link\/image\n+        String dest = null;\n+        String title = null;\n+\n+        \/\/ Maybe a inline link like `[foo](\/uri \"title\")`\n+        if (scanner.next('(')) {\n+            scanner.whitespace();\n+            dest = parseLinkDestination(scanner);\n+            if (dest == null) {\n+                scanner.setPosition(afterClose);\n+            } else {\n+                int whitespace = scanner.whitespace();\n+                \/\/ title needs a whitespace before\n+                if (whitespace >= 1) {\n+                    title = parseLinkTitle(scanner);\n+                    scanner.whitespace();\n+                }\n+                if (!scanner.next(')')) {\n+                    \/\/ Don't have a closing `)`, so it's not a destination and title -> reset.\n+                    \/\/ Note that something like `[foo](` could be valid, `(` will just be text.\n+                    scanner.setPosition(afterClose);\n+                    dest = null;\n+                    title = null;\n+                }\n+            }\n+        }\n+\n+        \/\/ Maybe a reference link like `[foo][bar]`, `[foo][]` or `[foo]`.\n+        \/\/ Note that even `[foo](` could be a valid link if there's a reference, which is why this is not just an `else`\n+        \/\/ here.\n+        if (dest == null) {\n+            \/\/ See if there's a link label like `[bar]` or `[]`\n+            String ref = parseLinkLabel(scanner);\n+            if (ref == null) {\n+                scanner.setPosition(afterClose);\n+            }\n+            if ((ref == null || ref.isEmpty()) && !opener.bracketAfter) {\n+                \/\/ If the second label is empty `[foo][]` or missing `[foo]`, then the first label is the reference.\n+                \/\/ But it can only be a reference when there's no (unescaped) bracket in it.\n+                \/\/ If there is, we don't even need to try to look up the reference. This is an optimization.\n+                ref = scanner.getSource(opener.contentPosition, beforeClose).getContent();\n+            }\n+\n+            if (ref != null) {\n+                LinkReferenceDefinition definition = context.getLinkReferenceDefinition(ref);\n+                if (definition != null) {\n+                    dest = definition.getDestination();\n+                    title = definition.getTitle();\n+                }\n+            }\n+        }\n+\n+        if (dest != null) {\n+            \/\/ If we got here, we have a link or image\n+            Node linkOrImage = opener.image ? new Image(dest, title) : new Link(dest, title);\n+\n+            \/\/ Add all nodes between the opening bracket and now (closing bracket) as child nodes of the link\n+            Node node = opener.node.getNext();\n+            while (node != null) {\n+                Node next = node.getNext();\n+                linkOrImage.appendChild(node);\n+                node = next;\n+            }\n+\n+            if (includeSourceSpans) {\n+                linkOrImage.setSourceSpans(scanner.getSource(opener.markerPosition, scanner.position()).getSourceSpans());\n+            }\n+\n+            \/\/ Process delimiters such as emphasis inside link\/image\n+            processDelimiters(opener.previousDelimiter);\n+            mergeChildTextNodes(linkOrImage);\n+            \/\/ We don't need the corresponding text node anymore, we turned it into a link\/image node\n+            opener.node.unlink();\n+            removeLastBracket();\n+\n+            \/\/ Links within links are not allowed. We found this link, so there can be no other link around it.\n+            if (!opener.image) {\n+                Bracket bracket = lastBracket;\n+                while (bracket != null) {\n+                    if (!bracket.image) {\n+                        \/\/ Disallow link opener. It will still get matched, but will not result in a link.\n+                        bracket.allowed = false;\n+                    }\n+                    bracket = bracket.previous;\n+                }\n+            }\n+\n+            return linkOrImage;\n+\n+        } else {\n+            \/\/ No link or image, parse just the bracket as text and continue\n+            removeLastBracket();\n+\n+            scanner.setPosition(afterClose);\n+            return text(scanner.getSource(beforeClose, afterClose));\n+        }\n+    }\n+\n+    private void addBracket(Bracket bracket) {\n+        if (lastBracket != null) {\n+            lastBracket.bracketAfter = true;\n+        }\n+        lastBracket = bracket;\n+    }\n+\n+    private void removeLastBracket() {\n+        lastBracket = lastBracket.previous;\n+    }\n+\n+    \/**\n+     * Attempt to parse link destination, returning the string or null if no match.\n+     *\/\n+    private String parseLinkDestination(Scanner scanner) {\n+        char delimiter = scanner.peek();\n+        Position start = scanner.position();\n+        if (!LinkScanner.scanLinkDestination(scanner)) {\n+            return null;\n+        }\n+\n+        String dest;\n+        if (delimiter == '<') {\n+            \/\/ chop off surrounding <..>:\n+            String rawDestination = scanner.getSource(start, scanner.position()).getContent();\n+            dest = rawDestination.substring(1, rawDestination.length() - 1);\n+        } else {\n+            dest = scanner.getSource(start, scanner.position()).getContent();\n+        }\n+\n+        return Escaping.unescapeString(dest);\n+    }\n+\n+    \/**\n+     * Attempt to parse link title (sans quotes), returning the string or null if no match.\n+     *\/\n+    private String parseLinkTitle(Scanner scanner) {\n+        Position start = scanner.position();\n+        if (!LinkScanner.scanLinkTitle(scanner)) {\n+            return null;\n+        }\n+\n+        \/\/ chop off ', \" or parens\n+        String rawTitle = scanner.getSource(start, scanner.position()).getContent();\n+        String title = rawTitle.substring(1, rawTitle.length() - 1);\n+        return Escaping.unescapeString(title);\n+    }\n+\n+    \/**\n+     * Attempt to parse a link label, returning the label between the brackets or null.\n+     *\/\n+    String parseLinkLabel(Scanner scanner) {\n+        if (!scanner.next('[')) {\n+            return null;\n+        }\n+\n+        Position start = scanner.position();\n+        if (!LinkScanner.scanLinkLabelContent(scanner)) {\n+            return null;\n+        }\n+        Position end = scanner.position();\n+\n+        if (!scanner.next(']')) {\n+            return null;\n+        }\n+\n+        String content = scanner.getSource(start, end).getContent();\n+        \/\/ spec: A link label can have at most 999 characters inside the square brackets.\n+        if (content.length() > 999) {\n+            return null;\n+        }\n+\n+        return content;\n+    }\n+\n+    private Node parseLineBreak() {\n+        scanner.next();\n+\n+        if (trailingSpaces >= 2) {\n+            return new HardLineBreak();\n+        } else {\n+            return new SoftLineBreak();\n+        }\n+    }\n+\n+    \/**\n+     * Parse the next character as plain text, and possibly more if the following characters are non-special.\n+     *\/\n+    private Node parseText() {\n+        Position start = scanner.position();\n+        scanner.next();\n+        char c;\n+        while (true) {\n+            c = scanner.peek();\n+            if (c == Scanner.END || specialCharacters.get(c)) {\n+                break;\n+            }\n+            scanner.next();\n+        }\n+\n+        SourceLines source = scanner.getSource(start, scanner.position());\n+        String content = source.getContent();\n+\n+        if (c == '\\n') {\n+            \/\/ We parsed until the end of the line. Trim any trailing spaces and remember them (for hard line breaks).\n+            int end = Parsing.skipBackwards(' ', content, content.length() - 1, 0) + 1;\n+            trailingSpaces = content.length() - end;\n+            content = content.substring(0, end);\n+        } else if (c == Scanner.END) {\n+            \/\/ For the last line, both tabs and spaces are trimmed for some reason (checked with commonmark.js).\n+            int end = Parsing.skipSpaceTabBackwards(content, content.length() - 1, 0) + 1;\n+            content = content.substring(0, end);\n+        }\n+\n+        Text text = new Text(content);\n+        text.setSourceSpans(source.getSourceSpans());\n+        return text;\n+    }\n+\n+    \/**\n+     * Scan a sequence of characters with code delimiterChar, and return information about the number of delimiters\n+     * and whether they are positioned such that they can open and\/or close emphasis or strong emphasis.\n+     *\n+     * @return information about delimiter run, or {@code null}\n+     *\/\n+    private DelimiterData scanDelimiters(DelimiterProcessor delimiterProcessor, char delimiterChar) {\n+        int before = scanner.peekPreviousCodePoint();\n+        Position start = scanner.position();\n+\n+        \/\/ Quick check to see if we have enough delimiters.\n+        int delimiterCount = scanner.matchMultiple(delimiterChar);\n+        if (delimiterCount < delimiterProcessor.getMinLength()) {\n+            scanner.setPosition(start);\n+            return null;\n+        }\n+\n+        \/\/ We do have enough, extract a text node for each delimiter character.\n+        List<Text> delimiters = new ArrayList<>();\n+        scanner.setPosition(start);\n+        Position positionBefore = start;\n+        while (scanner.next(delimiterChar)) {\n+            delimiters.add(text(scanner.getSource(positionBefore, scanner.position())));\n+            positionBefore = scanner.position();\n+        }\n+\n+        int after = scanner.peekCodePoint();\n+\n+        \/\/ We could be more lazy here, in most cases we don't need to do every match case.\n+        boolean beforeIsPunctuation = before == Scanner.END || Parsing.isPunctuationCodePoint(before);\n+        boolean beforeIsWhitespace = before == Scanner.END || Parsing.isWhitespaceCodePoint(before);\n+        boolean afterIsPunctuation = after == Scanner.END || Parsing.isPunctuationCodePoint(after);\n+        boolean afterIsWhitespace = after == Scanner.END || Parsing.isWhitespaceCodePoint(after);\n+\n+        boolean leftFlanking = !afterIsWhitespace &&\n+                (!afterIsPunctuation || beforeIsWhitespace || beforeIsPunctuation);\n+        boolean rightFlanking = !beforeIsWhitespace &&\n+                (!beforeIsPunctuation || afterIsWhitespace || afterIsPunctuation);\n+        boolean canOpen;\n+        boolean canClose;\n+        if (delimiterChar == '_') {\n+            canOpen = leftFlanking && (!rightFlanking || beforeIsPunctuation);\n+            canClose = rightFlanking && (!leftFlanking || afterIsPunctuation);\n+        } else {\n+            canOpen = leftFlanking && delimiterChar == delimiterProcessor.getOpeningCharacter();\n+            canClose = rightFlanking && delimiterChar == delimiterProcessor.getClosingCharacter();\n+        }\n+\n+        return new DelimiterData(delimiters, canOpen, canClose);\n+    }\n+\n+    private void processDelimiters(Delimiter stackBottom) {\n+\n+        Map<Character, Delimiter> openersBottom = new HashMap<>();\n+\n+        \/\/ find first closer above stackBottom:\n+        Delimiter closer = lastDelimiter;\n+        while (closer != null && closer.previous != stackBottom) {\n+            closer = closer.previous;\n+        }\n+        \/\/ move forward, looking for closers, and handling each\n+        while (closer != null) {\n+            char delimiterChar = closer.delimiterChar;\n+\n+            DelimiterProcessor delimiterProcessor = delimiterProcessors.get(delimiterChar);\n+            if (!closer.canClose() || delimiterProcessor == null) {\n+                closer = closer.next;\n+                continue;\n+            }\n+\n+            char openingDelimiterChar = delimiterProcessor.getOpeningCharacter();\n+\n+            \/\/ Found delimiter closer. Now look back for first matching opener.\n+            int usedDelims = 0;\n+            boolean openerFound = false;\n+            boolean potentialOpenerFound = false;\n+            Delimiter opener = closer.previous;\n+            while (opener != null && opener != stackBottom && opener != openersBottom.get(delimiterChar)) {\n+                if (opener.canOpen() && opener.delimiterChar == openingDelimiterChar) {\n+                    potentialOpenerFound = true;\n+                    usedDelims = delimiterProcessor.process(opener, closer);\n+                    if (usedDelims > 0) {\n+                        openerFound = true;\n+                        break;\n+                    }\n+                }\n+                opener = opener.previous;\n+            }\n+\n+            if (!openerFound) {\n+                if (!potentialOpenerFound) {\n+                    \/\/ Set lower bound for future searches for openers.\n+                    \/\/ Only do this when we didn't even have a potential\n+                    \/\/ opener (one that matches the character and can open).\n+                    \/\/ If an opener was rejected because of the number of\n+                    \/\/ delimiters (e.g. because of the \"multiple of 3\" rule),\n+                    \/\/ we want to consider it next time because the number\n+                    \/\/ of delimiters can change as we continue processing.\n+                    openersBottom.put(delimiterChar, closer.previous);\n+                    if (!closer.canOpen()) {\n+                        \/\/ We can remove a closer that can't be an opener,\n+                        \/\/ once we've seen there's no matching opener:\n+                        removeDelimiterKeepNode(closer);\n+                    }\n+                }\n+                closer = closer.next;\n+                continue;\n+            }\n+\n+            \/\/ Remove number of used delimiters nodes.\n+            for (int i = 0; i < usedDelims; i++) {\n+                Text delimiter = opener.characters.remove(opener.characters.size() - 1);\n+                delimiter.unlink();\n+            }\n+            for (int i = 0; i < usedDelims; i++) {\n+                Text delimiter = closer.characters.remove(0);\n+                delimiter.unlink();\n+            }\n+\n+            removeDelimitersBetween(opener, closer);\n+\n+            \/\/ No delimiter characters left to process, so we can remove delimiter and the now empty node.\n+            if (opener.length() == 0) {\n+                removeDelimiterAndNodes(opener);\n+            }\n+\n+            if (closer.length() == 0) {\n+                Delimiter next = closer.next;\n+                removeDelimiterAndNodes(closer);\n+                closer = next;\n+            }\n+        }\n+\n+        \/\/ remove all delimiters\n+        while (lastDelimiter != null && lastDelimiter != stackBottom) {\n+            removeDelimiterKeepNode(lastDelimiter);\n+        }\n+    }\n+\n+    private void removeDelimitersBetween(Delimiter opener, Delimiter closer) {\n+        Delimiter delimiter = closer.previous;\n+        while (delimiter != null && delimiter != opener) {\n+            Delimiter previousDelimiter = delimiter.previous;\n+            removeDelimiterKeepNode(delimiter);\n+            delimiter = previousDelimiter;\n+        }\n+    }\n+\n+    \/**\n+     * Remove the delimiter and the corresponding text node. For used delimiters, e.g. `*` in `*foo*`.\n+     *\/\n+    private void removeDelimiterAndNodes(Delimiter delim) {\n+        removeDelimiter(delim);\n+    }\n+\n+    \/**\n+     * Remove the delimiter but keep the corresponding node as text. For unused delimiters such as `_` in `foo_bar`.\n+     *\/\n+    private void removeDelimiterKeepNode(Delimiter delim) {\n+        removeDelimiter(delim);\n+    }\n+\n+    private void removeDelimiter(Delimiter delim) {\n+        if (delim.previous != null) {\n+            delim.previous.next = delim.next;\n+        }\n+        if (delim.next == null) {\n+            \/\/ top of stack\n+            lastDelimiter = delim.previous;\n+        } else {\n+            delim.next.previous = delim.previous;\n+        }\n+    }\n+\n+    private void mergeChildTextNodes(Node node) {\n+        \/\/ No children, no need for merging\n+        if (node.getFirstChild() == null) {\n+            return;\n+        }\n+\n+        mergeTextNodesInclusive(node.getFirstChild(), node.getLastChild());\n+    }\n+\n+    private void mergeTextNodesInclusive(Node fromNode, Node toNode) {\n+        Text first = null;\n+        Text last = null;\n+        int length = 0;\n+\n+        Node node = fromNode;\n+        while (node != null) {\n+            if (node instanceof Text) {\n+                Text text = (Text) node;\n+                if (first == null) {\n+                    first = text;\n+                }\n+                length += text.getLiteral().length();\n+                last = text;\n+            } else {\n+                mergeIfNeeded(first, last, length);\n+                first = null;\n+                last = null;\n+                length = 0;\n+\n+                mergeChildTextNodes(node);\n+            }\n+            if (node == toNode) {\n+                break;\n+            }\n+            node = node.getNext();\n+        }\n+\n+        mergeIfNeeded(first, last, length);\n+    }\n+\n+    private void mergeIfNeeded(Text first, Text last, int textLength) {\n+        if (first != null && last != null && first != last) {\n+            StringBuilder sb = new StringBuilder(textLength);\n+            sb.append(first.getLiteral());\n+            SourceSpans sourceSpans = null;\n+            if (includeSourceSpans) {\n+                sourceSpans = new SourceSpans();\n+                sourceSpans.addAll(first.getSourceSpans());\n+            }\n+            Node node = first.getNext();\n+            Node stop = last.getNext();\n+            while (node != stop) {\n+                sb.append(((Text) node).getLiteral());\n+                if (sourceSpans != null) {\n+                    sourceSpans.addAll(node.getSourceSpans());\n+                }\n+\n+                Node unlink = node;\n+                node = node.getNext();\n+                unlink.unlink();\n+            }\n+            String literal = sb.toString();\n+            first.setLiteral(literal);\n+            if (sourceSpans != null) {\n+                first.setSourceSpans(sourceSpans.getSourceSpans());\n+            }\n+        }\n+    }\n+\n+    private static class DelimiterData {\n+\n+        final List<Text> characters;\n+        final boolean canClose;\n+        final boolean canOpen;\n+\n+        DelimiterData(List<Text> characters, boolean canOpen, boolean canClose) {\n+            this.characters = characters;\n+            this.canOpen = canOpen;\n+            this.canClose = canClose;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/InlineParserImpl.java","additions":786,"deletions":0,"binary":false,"changes":786,"status":"added"},{"patch":"@@ -0,0 +1,311 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.inline.Position;\n+import jdk.internal.org.commonmark.internal.inline.Scanner;\n+import jdk.internal.org.commonmark.internal.util.Escaping;\n+import jdk.internal.org.commonmark.internal.util.LinkScanner;\n+import jdk.internal.org.commonmark.node.LinkReferenceDefinition;\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Parser for link reference definitions at the beginning of a paragraph.\n+ *\n+ * @see <a href=\"https:\/\/spec.commonmark.org\/0.29\/#link-reference-definition\">Link reference definitions<\/a>\n+ *\/\n+public class LinkReferenceDefinitionParser {\n+\n+    private State state = State.START_DEFINITION;\n+\n+    private final List<SourceLine> paragraphLines = new ArrayList<>();\n+    private final List<LinkReferenceDefinition> definitions = new ArrayList<>();\n+    private final List<SourceSpan> sourceSpans = new ArrayList<>();\n+\n+    private StringBuilder label;\n+    private String destination;\n+    private char titleDelimiter;\n+    private StringBuilder title;\n+    private boolean referenceValid = false;\n+\n+    public void parse(SourceLine line) {\n+        paragraphLines.add(line);\n+        if (state == State.PARAGRAPH) {\n+            \/\/ We're in a paragraph now. Link reference definitions can only appear at the beginning, so once\n+            \/\/ we're in a paragraph, there's no going back.\n+            return;\n+        }\n+\n+        Scanner scanner = Scanner.of(SourceLines.of(line));\n+        while (scanner.hasNext()) {\n+            boolean success;\n+            switch (state) {\n+                case START_DEFINITION: {\n+                    success = startDefinition(scanner);\n+                    break;\n+                }\n+                case LABEL: {\n+                    success = label(scanner);\n+                    break;\n+                }\n+                case DESTINATION: {\n+                    success = destination(scanner);\n+                    break;\n+                }\n+                case START_TITLE: {\n+                    success = startTitle(scanner);\n+                    break;\n+                }\n+                case TITLE: {\n+                    success = title(scanner);\n+                    break;\n+                }\n+                default: {\n+                    throw new IllegalStateException(\"Unknown parsing state: \" + state);\n+                }\n+            }\n+            \/\/ Parsing failed, which means we fall back to treating text as a paragraph.\n+            if (!success) {\n+                state = State.PARAGRAPH;\n+                return;\n+            }\n+        }\n+    }\n+\n+    public void addSourceSpan(SourceSpan sourceSpan) {\n+        sourceSpans.add(sourceSpan);\n+    }\n+\n+    \/**\n+     * @return the lines that are normal paragraph content, without newlines\n+     *\/\n+    SourceLines getParagraphLines() {\n+        return SourceLines.of(paragraphLines);\n+    }\n+\n+    List<SourceSpan> getParagraphSourceSpans() {\n+        return sourceSpans;\n+    }\n+\n+    List<LinkReferenceDefinition> getDefinitions() {\n+        finishReference();\n+        return definitions;\n+    }\n+\n+    State getState() {\n+        return state;\n+    }\n+\n+    private boolean startDefinition(Scanner scanner) {\n+        scanner.whitespace();\n+        if (!scanner.next('[')) {\n+            return false;\n+        }\n+\n+        state = State.LABEL;\n+        label = new StringBuilder();\n+\n+        if (!scanner.hasNext()) {\n+            label.append('\\n');\n+        }\n+        return true;\n+    }\n+\n+    private boolean label(Scanner scanner) {\n+        Position start = scanner.position();\n+        if (!LinkScanner.scanLinkLabelContent(scanner)) {\n+            return false;\n+        }\n+\n+        label.append(scanner.getSource(start, scanner.position()).getContent());\n+\n+        if (!scanner.hasNext()) {\n+            \/\/ label might continue on next line\n+            label.append('\\n');\n+            return true;\n+        } else if (scanner.next(']')) {\n+            \/\/ end of label\n+            if (!scanner.next(':')) {\n+                return false;\n+            }\n+\n+            \/\/ spec: A link label can have at most 999 characters inside the square brackets.\n+            if (label.length() > 999) {\n+                return false;\n+            }\n+\n+            String normalizedLabel = Escaping.normalizeLabelContent(label.toString());\n+            if (normalizedLabel.isEmpty()) {\n+                return false;\n+            }\n+\n+            state = State.DESTINATION;\n+\n+            scanner.whitespace();\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private boolean destination(Scanner scanner) {\n+        scanner.whitespace();\n+        Position start = scanner.position();\n+        if (!LinkScanner.scanLinkDestination(scanner)) {\n+            return false;\n+        }\n+\n+        String rawDestination = scanner.getSource(start, scanner.position()).getContent();\n+        destination = rawDestination.startsWith(\"<\") ?\n+                rawDestination.substring(1, rawDestination.length() - 1) :\n+                rawDestination;\n+\n+        int whitespace = scanner.whitespace();\n+        if (!scanner.hasNext()) {\n+            \/\/ Destination was at end of line, so this is a valid reference for sure (and maybe a title).\n+            \/\/ If not at end of line, wait for title to be valid first.\n+            referenceValid = true;\n+            paragraphLines.clear();\n+        } else if (whitespace == 0) {\n+            \/\/ spec: The title must be separated from the link destination by whitespace\n+            return false;\n+        }\n+\n+        state = State.START_TITLE;\n+        return true;\n+    }\n+\n+    private boolean startTitle(Scanner scanner) {\n+        scanner.whitespace();\n+        if (!scanner.hasNext()) {\n+            state = State.START_DEFINITION;\n+            return true;\n+        }\n+\n+        titleDelimiter = '\\0';\n+        char c = scanner.peek();\n+        switch (c) {\n+            case '\"':\n+            case '\\'':\n+                titleDelimiter = c;\n+                break;\n+            case '(':\n+                titleDelimiter = ')';\n+                break;\n+        }\n+\n+        if (titleDelimiter != '\\0') {\n+            state = State.TITLE;\n+            title = new StringBuilder();\n+            scanner.next();\n+            if (!scanner.hasNext()) {\n+                title.append('\\n');\n+            }\n+        } else {\n+            finishReference();\n+            \/\/ There might be another reference instead, try that for the same character.\n+            state = State.START_DEFINITION;\n+        }\n+        return true;\n+    }\n+\n+    private boolean title(Scanner scanner) {\n+        Position start = scanner.position();\n+        if (!LinkScanner.scanLinkTitleContent(scanner, titleDelimiter)) {\n+            \/\/ Invalid title, stop\n+            return false;\n+        }\n+\n+        title.append(scanner.getSource(start, scanner.position()).getContent());\n+\n+        if (!scanner.hasNext()) {\n+            \/\/ Title ran until the end of line, so continue on next line (until we find the delimiter)\n+            title.append('\\n');\n+            return true;\n+        }\n+\n+        \/\/ Skip delimiter character\n+        scanner.next();\n+        scanner.whitespace();\n+        if (scanner.hasNext()) {\n+            \/\/ spec: No further non-whitespace characters may occur on the line.\n+            return false;\n+        }\n+        referenceValid = true;\n+        finishReference();\n+        paragraphLines.clear();\n+\n+        \/\/ See if there's another definition.\n+        state = State.START_DEFINITION;\n+        return true;\n+    }\n+\n+    private void finishReference() {\n+        if (!referenceValid) {\n+            return;\n+        }\n+\n+        String d = Escaping.unescapeString(destination);\n+        String t = title != null ? Escaping.unescapeString(title.toString()) : null;\n+        LinkReferenceDefinition definition = new LinkReferenceDefinition(label.toString(), d, t);\n+        definition.setSourceSpans(sourceSpans);\n+        sourceSpans.clear();\n+        definitions.add(definition);\n+\n+        label = null;\n+        referenceValid = false;\n+        destination = null;\n+        title = null;\n+    }\n+\n+    enum State {\n+        \/\/ Looking for the start of a definition, i.e. `[`\n+        START_DEFINITION,\n+        \/\/ Parsing the label, i.e. `foo` within `[foo]`\n+        LABEL,\n+        \/\/ Parsing the destination, i.e. `\/url` in `[foo]: \/url`\n+        DESTINATION,\n+        \/\/ Looking for the start of a title, i.e. the first `\"` in `[foo]: \/url \"title\"`\n+        START_TITLE,\n+        \/\/ Parsing the content of the title, i.e. `title` in `[foo]: \/url \"title\"`\n+        TITLE,\n+\n+        \/\/ End state, no matter what kind of lines we add, they won't be references\n+        PARAGRAPH,\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/LinkReferenceDefinitionParser.java","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Escaping;\n+import jdk.internal.org.commonmark.node.LinkReferenceDefinition;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+public class LinkReferenceDefinitions {\n+\n+    \/\/ LinkedHashMap for determinism and to preserve document order\n+    private final Map<String, LinkReferenceDefinition> definitions = new LinkedHashMap<>();\n+\n+    public void add(LinkReferenceDefinition definition) {\n+        String normalizedLabel = Escaping.normalizeLabelContent(definition.getLabel());\n+\n+        \/\/ spec: When there are multiple matching link reference definitions, the first is used\n+        if (!definitions.containsKey(normalizedLabel)) {\n+            definitions.put(normalizedLabel, definition);\n+        }\n+    }\n+\n+    public LinkReferenceDefinition get(String label) {\n+        String normalizedLabel = Escaping.normalizeLabelContent(label);\n+        return definitions.get(normalizedLabel);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/LinkReferenceDefinitions.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,288 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.parser.block.*;\n+\n+public class ListBlockParser extends AbstractBlockParser {\n+\n+    private final ListBlock block;\n+\n+    private boolean hadBlankLine;\n+    private int linesAfterBlank;\n+\n+    public ListBlockParser(ListBlock block) {\n+        this.block = block;\n+    }\n+\n+    @Override\n+    public boolean isContainer() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean canContain(Block childBlock) {\n+        if (childBlock instanceof ListItem) {\n+            \/\/ Another list item is added to this list block. If the previous line was blank, that means this list block\n+            \/\/ is \"loose\" (not tight).\n+            \/\/\n+            \/\/ spec: A list is loose if any of its constituent list items are separated by blank lines\n+            if (hadBlankLine && linesAfterBlank == 1) {\n+                block.setTight(false);\n+                hadBlankLine = false;\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        if (state.isBlank()) {\n+            hadBlankLine = true;\n+            linesAfterBlank = 0;\n+        } else if (hadBlankLine) {\n+            linesAfterBlank++;\n+        }\n+        \/\/ List blocks themselves don't have any markers, only list items. So try to stay in the list.\n+        \/\/ If there is a block start other than list item, canContain makes sure that this list is closed.\n+        return BlockContinue.atIndex(state.getIndex());\n+    }\n+\n+    \/**\n+     * Parse a list marker and return data on the marker or null.\n+     *\/\n+    private static ListData parseList(CharSequence line, final int markerIndex, final int markerColumn,\n+                                      final boolean inParagraph) {\n+        ListMarkerData listMarker = parseListMarker(line, markerIndex);\n+        if (listMarker == null) {\n+            return null;\n+        }\n+        ListBlock listBlock = listMarker.listBlock;\n+\n+        int indexAfterMarker = listMarker.indexAfterMarker;\n+        int markerLength = indexAfterMarker - markerIndex;\n+        \/\/ marker doesn't include tabs, so counting them as columns directly is ok\n+        int columnAfterMarker = markerColumn + markerLength;\n+        \/\/ the column within the line where the content starts\n+        int contentColumn = columnAfterMarker;\n+\n+        \/\/ See at which column the content starts if there is content\n+        boolean hasContent = false;\n+        int length = line.length();\n+        for (int i = indexAfterMarker; i < length; i++) {\n+            char c = line.charAt(i);\n+            if (c == '\\t') {\n+                contentColumn += Parsing.columnsToNextTabStop(contentColumn);\n+            } else if (c == ' ') {\n+                contentColumn++;\n+            } else {\n+                hasContent = true;\n+                break;\n+            }\n+        }\n+\n+        if (inParagraph) {\n+            \/\/ If the list item is ordered, the start number must be 1 to interrupt a paragraph.\n+            if (listBlock instanceof OrderedList && ((OrderedList) listBlock).getStartNumber() != 1) {\n+                return null;\n+            }\n+            \/\/ Empty list item can not interrupt a paragraph.\n+            if (!hasContent) {\n+                return null;\n+            }\n+        }\n+\n+        if (!hasContent || (contentColumn - columnAfterMarker) > Parsing.CODE_BLOCK_INDENT) {\n+            \/\/ If this line is blank or has a code block, default to 1 space after marker\n+            contentColumn = columnAfterMarker + 1;\n+        }\n+\n+        return new ListData(listBlock, contentColumn);\n+    }\n+\n+    private static ListMarkerData parseListMarker(CharSequence line, int index) {\n+        char c = line.charAt(index);\n+        switch (c) {\n+            \/\/ spec: A bullet list marker is a -, +, or * character.\n+            case '-':\n+            case '+':\n+            case '*':\n+                if (isSpaceTabOrEnd(line, index + 1)) {\n+                    BulletList bulletList = new BulletList();\n+                    bulletList.setBulletMarker(c);\n+                    return new ListMarkerData(bulletList, index + 1);\n+                } else {\n+                    return null;\n+                }\n+            default:\n+                return parseOrderedList(line, index);\n+        }\n+    }\n+\n+    \/\/ spec: An ordered list marker is a sequence of 1\\u20139 arabic digits (0-9), followed by either a `.` character or a\n+    \/\/ `)` character.\n+    private static ListMarkerData parseOrderedList(CharSequence line, int index) {\n+        int digits = 0;\n+        int length = line.length();\n+        for (int i = index; i < length; i++) {\n+            char c = line.charAt(i);\n+            switch (c) {\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    digits++;\n+                    if (digits > 9) {\n+                        return null;\n+                    }\n+                    break;\n+                case '.':\n+                case ')':\n+                    if (digits >= 1 && isSpaceTabOrEnd(line, i + 1)) {\n+                        String number = line.subSequence(index, i).toString();\n+                        OrderedList orderedList = new OrderedList();\n+                        orderedList.setStartNumber(Integer.parseInt(number));\n+                        orderedList.setDelimiter(c);\n+                        return new ListMarkerData(orderedList, i + 1);\n+                    } else {\n+                        return null;\n+                    }\n+                default:\n+                    return null;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static boolean isSpaceTabOrEnd(CharSequence line, int index) {\n+        if (index < line.length()) {\n+            switch (line.charAt(index)) {\n+                case ' ':\n+                case '\\t':\n+                    return true;\n+                default:\n+                    return false;\n+            }\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if the two list items are of the same type,\n+     * with the same delimiter and bullet character. This is used\n+     * in agglomerating list items into lists.\n+     *\/\n+    private static boolean listsMatch(ListBlock a, ListBlock b) {\n+        if (a instanceof BulletList && b instanceof BulletList) {\n+            return equals(((BulletList) a).getBulletMarker(), ((BulletList) b).getBulletMarker());\n+        } else if (a instanceof OrderedList && b instanceof OrderedList) {\n+            return equals(((OrderedList) a).getDelimiter(), ((OrderedList) b).getDelimiter());\n+        }\n+        return false;\n+    }\n+\n+    private static boolean equals(Object a, Object b) {\n+        return (a == null) ? (b == null) : a.equals(b);\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+\n+        @Override\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            BlockParser matched = matchedBlockParser.getMatchedBlockParser();\n+\n+            if (state.getIndent() >= Parsing.CODE_BLOCK_INDENT) {\n+                return BlockStart.none();\n+            }\n+            int markerIndex = state.getNextNonSpaceIndex();\n+            int markerColumn = state.getColumn() + state.getIndent();\n+            boolean inParagraph = !matchedBlockParser.getParagraphLines().isEmpty();\n+            ListData listData = parseList(state.getLine().getContent(), markerIndex, markerColumn, inParagraph);\n+            if (listData == null) {\n+                return BlockStart.none();\n+            }\n+\n+            int newColumn = listData.contentColumn;\n+            ListItemParser listItemParser = new ListItemParser(newColumn - state.getColumn());\n+\n+            \/\/ prepend the list block if needed\n+            if (!(matched instanceof ListBlockParser) ||\n+                    !(listsMatch((ListBlock) matched.getBlock(), listData.listBlock))) {\n+\n+                ListBlockParser listBlockParser = new ListBlockParser(listData.listBlock);\n+                \/\/ We start out with assuming a list is tight. If we find a blank line, we set it to loose later.\n+                listData.listBlock.setTight(true);\n+\n+                return BlockStart.of(listBlockParser, listItemParser).atColumn(newColumn);\n+            } else {\n+                return BlockStart.of(listItemParser).atColumn(newColumn);\n+            }\n+        }\n+    }\n+\n+    private static class ListData {\n+        final ListBlock listBlock;\n+        final int contentColumn;\n+\n+        ListData(ListBlock listBlock, int contentColumn) {\n+            this.listBlock = listBlock;\n+            this.contentColumn = contentColumn;\n+        }\n+    }\n+\n+    private static class ListMarkerData {\n+        final ListBlock listBlock;\n+        final int indexAfterMarker;\n+\n+        ListMarkerData(ListBlock listBlock, int indexAfterMarker) {\n+            this.listBlock = listBlock;\n+            this.indexAfterMarker = indexAfterMarker;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/ListBlockParser.java","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.ListBlock;\n+import jdk.internal.org.commonmark.node.ListItem;\n+import jdk.internal.org.commonmark.node.Paragraph;\n+import jdk.internal.org.commonmark.parser.block.AbstractBlockParser;\n+import jdk.internal.org.commonmark.parser.block.BlockContinue;\n+import jdk.internal.org.commonmark.parser.block.ParserState;\n+\n+public class ListItemParser extends AbstractBlockParser {\n+\n+    private final ListItem block = new ListItem();\n+\n+    \/**\n+     * Minimum number of columns that the content has to be indented (relative to the containing block) to be part of\n+     * this list item.\n+     *\/\n+    private int contentIndent;\n+\n+    private boolean hadBlankLine;\n+\n+    public ListItemParser(int contentIndent) {\n+        this.contentIndent = contentIndent;\n+    }\n+\n+    @Override\n+    public boolean isContainer() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean canContain(Block childBlock) {\n+        if (hadBlankLine) {\n+            \/\/ We saw a blank line in this list item, that means the list block is loose.\n+            \/\/\n+            \/\/ spec: if any of its constituent list items directly contain two block-level elements with a blank line\n+            \/\/ between them\n+            Block parent = block.getParent();\n+            if (parent instanceof ListBlock) {\n+                ((ListBlock) parent).setTight(false);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        if (state.isBlank()) {\n+            if (block.getFirstChild() == null) {\n+                \/\/ Blank line after empty list item\n+                return BlockContinue.none();\n+            } else {\n+                Block activeBlock = state.getActiveBlockParser().getBlock();\n+                \/\/ If the active block is a code block, blank lines in it should not affect if the list is tight.\n+                hadBlankLine = activeBlock instanceof Paragraph || activeBlock instanceof ListItem;\n+                return BlockContinue.atIndex(state.getNextNonSpaceIndex());\n+            }\n+        }\n+\n+        if (state.getIndent() >= contentIndent) {\n+            return BlockContinue.atColumn(state.getColumn() + contentIndent);\n+        } else {\n+            \/\/ Note: We'll hit this case for lazy continuation lines, they will get added later.\n+            return BlockContinue.none();\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/ListItemParser.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.LinkReferenceDefinition;\n+import jdk.internal.org.commonmark.node.Paragraph;\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.parser.InlineParser;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+import jdk.internal.org.commonmark.parser.block.AbstractBlockParser;\n+import jdk.internal.org.commonmark.parser.block.BlockContinue;\n+import jdk.internal.org.commonmark.parser.block.ParserState;\n+\n+import java.util.List;\n+\n+public class ParagraphParser extends AbstractBlockParser {\n+\n+    private final Paragraph block = new Paragraph();\n+    private final LinkReferenceDefinitionParser linkReferenceDefinitionParser = new LinkReferenceDefinitionParser();\n+\n+    @Override\n+    public boolean canHaveLazyContinuationLines() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        if (!state.isBlank()) {\n+            return BlockContinue.atIndex(state.getIndex());\n+        } else {\n+            return BlockContinue.none();\n+        }\n+    }\n+\n+    @Override\n+    public void addLine(SourceLine line) {\n+        linkReferenceDefinitionParser.parse(line);\n+    }\n+\n+    @Override\n+    public void addSourceSpan(SourceSpan sourceSpan) {\n+        \/\/ Some source spans might belong to link reference definitions, others to the paragraph.\n+        \/\/ The parser will handle that.\n+        linkReferenceDefinitionParser.addSourceSpan(sourceSpan);\n+    }\n+\n+    @Override\n+    public void closeBlock() {\n+        if (linkReferenceDefinitionParser.getParagraphLines().isEmpty()) {\n+            block.unlink();\n+        } else {\n+            block.setSourceSpans(linkReferenceDefinitionParser.getParagraphSourceSpans());\n+        }\n+    }\n+\n+    @Override\n+    public void parseInlines(InlineParser inlineParser) {\n+        SourceLines lines = linkReferenceDefinitionParser.getParagraphLines();\n+        if (!lines.isEmpty()) {\n+            inlineParser.parse(lines, block);\n+        }\n+    }\n+\n+    public SourceLines getParagraphLines() {\n+        return linkReferenceDefinitionParser.getParagraphLines();\n+    }\n+\n+    public List<LinkReferenceDefinition> getDefinitions() {\n+        return linkReferenceDefinitionParser.getDefinitions();\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/ParagraphParser.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterRun;\n+\n+import java.util.LinkedList;\n+import java.util.ListIterator;\n+\n+\/**\n+ * An implementation of DelimiterProcessor that dispatches all calls to two or more other DelimiterProcessors\n+ * depending on the length of the delimiter run. All child DelimiterProcessors must have different minimum\n+ * lengths. A given delimiter run is dispatched to the child with the largest acceptable minimum length. If no\n+ * child is applicable, the one with the largest minimum length is chosen.\n+ *\/\n+class StaggeredDelimiterProcessor implements DelimiterProcessor {\n+\n+    private final char delim;\n+    private int minLength = 0;\n+    private LinkedList<DelimiterProcessor> processors = new LinkedList<>(); \/\/ in reverse getMinLength order\n+\n+    StaggeredDelimiterProcessor(char delim) {\n+        this.delim = delim;\n+    }\n+\n+\n+    @Override\n+    public char getOpeningCharacter() {\n+        return delim;\n+    }\n+\n+    @Override\n+    public char getClosingCharacter() {\n+        return delim;\n+    }\n+\n+    @Override\n+    public int getMinLength() {\n+        return minLength;\n+    }\n+\n+    void add(DelimiterProcessor dp) {\n+        final int len = dp.getMinLength();\n+        ListIterator<DelimiterProcessor> it = processors.listIterator();\n+        boolean added = false;\n+        while (it.hasNext()) {\n+            DelimiterProcessor p = it.next();\n+            int pLen = p.getMinLength();\n+            if (len > pLen) {\n+                it.previous();\n+                it.add(dp);\n+                added = true;\n+                break;\n+            } else if (len == pLen) {\n+                throw new IllegalArgumentException(\"Cannot add two delimiter processors for char '\" + delim + \"' and minimum length \" + len + \"; conflicting processors: \" + p + \", \" + dp);\n+            }\n+        }\n+        if (!added) {\n+            processors.add(dp);\n+            this.minLength = len;\n+        }\n+    }\n+\n+    private DelimiterProcessor findProcessor(int len) {\n+        for (DelimiterProcessor p : processors) {\n+            if (p.getMinLength() <= len) {\n+                return p;\n+            }\n+        }\n+        return processors.getFirst();\n+    }\n+\n+    @Override\n+    public int process(DelimiterRun openingRun, DelimiterRun closingRun) {\n+        return findProcessor(openingRun.length()).process(openingRun, closingRun);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/StaggeredDelimiterProcessor.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.ThematicBreak;\n+import jdk.internal.org.commonmark.parser.block.*;\n+\n+public class ThematicBreakParser extends AbstractBlockParser {\n+\n+    private final ThematicBreak block = new ThematicBreak();\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        \/\/ a horizontal rule can never container > 1 line, so fail to match\n+        return BlockContinue.none();\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+\n+        @Override\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            if (state.getIndent() >= 4) {\n+                return BlockStart.none();\n+            }\n+            int nextNonSpace = state.getNextNonSpaceIndex();\n+            CharSequence line = state.getLine().getContent();\n+            if (isThematicBreak(line, nextNonSpace)) {\n+                return BlockStart.of(new ThematicBreakParser()).atIndex(line.length());\n+            } else {\n+                return BlockStart.none();\n+            }\n+        }\n+    }\n+\n+    \/\/ spec: A line consisting of 0-3 spaces of indentation, followed by a sequence of three or more matching -, _, or *\n+    \/\/ characters, each followed optionally by any number of spaces, forms a thematic break.\n+    private static boolean isThematicBreak(CharSequence line, int index) {\n+        int dashes = 0;\n+        int underscores = 0;\n+        int asterisks = 0;\n+        int length = line.length();\n+        for (int i = index; i < length; i++) {\n+            switch (line.charAt(i)) {\n+                case '-':\n+                    dashes++;\n+                    break;\n+                case '_':\n+                    underscores++;\n+                    break;\n+                case '*':\n+                    asterisks++;\n+                    break;\n+                case ' ':\n+                case '\\t':\n+                    \/\/ Allowed, even between markers\n+                    break;\n+                default:\n+                    return false;\n+            }\n+        }\n+\n+        return ((dashes >= 3 && underscores == 0 && asterisks == 0) ||\n+                (underscores >= 3 && dashes == 0 && asterisks == 0) ||\n+                (asterisks >= 3 && dashes == 0 && underscores == 0));\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/ThematicBreakParser.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+public class AsteriskDelimiterProcessor extends EmphasisDelimiterProcessor {\n+\n+    public AsteriskDelimiterProcessor() {\n+        super('*');\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/AsteriskDelimiterProcessor.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.node.Link;\n+import jdk.internal.org.commonmark.node.Text;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Attempt to parse an autolink (URL or email in pointy brackets).\n+ *\/\n+public class AutolinkInlineParser implements InlineContentParser {\n+\n+    private static final Pattern URI = Pattern\n+            .compile(\"^[a-zA-Z][a-zA-Z0-9.+-]{1,31}:[^<>\\u0000-\\u0020]*$\");\n+\n+    private static final Pattern EMAIL = Pattern\n+            .compile(\"^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$\");\n+\n+    @Override\n+    public ParsedInline tryParse(InlineParserState inlineParserState) {\n+        Scanner scanner = inlineParserState.scanner();\n+        scanner.next();\n+        Position textStart = scanner.position();\n+        if (scanner.find('>') > 0) {\n+            SourceLines textSource = scanner.getSource(textStart, scanner.position());\n+            String content = textSource.getContent();\n+            scanner.next();\n+\n+            String destination = null;\n+            if (URI.matcher(content).matches()) {\n+                destination = content;\n+            } else if (EMAIL.matcher(content).matches()) {\n+                destination = \"mailto:\" + content;\n+            }\n+\n+            if (destination != null) {\n+                Link link = new Link(destination, null);\n+                Text text = new Text(content);\n+                text.setSourceSpans(textSource.getSourceSpans());\n+                link.appendChild(text);\n+                return ParsedInline.of(link, scanner.position());\n+            }\n+        }\n+        return ParsedInline.none();\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/AutolinkInlineParser.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.internal.util.Escaping;\n+import jdk.internal.org.commonmark.node.HardLineBreak;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.node.Text;\n+\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Parse a backslash-escaped special character, adding either the escaped  character, a hard line break\n+ * (if the backslash is followed by a newline), or a literal backslash to the block's children.\n+ *\/\n+public class BackslashInlineParser implements InlineContentParser {\n+\n+    private static final Pattern ESCAPABLE = Pattern.compile('^' + Escaping.ESCAPABLE);\n+\n+    @Override\n+    public ParsedInline tryParse(InlineParserState inlineParserState) {\n+        Scanner scanner = inlineParserState.scanner();\n+        \/\/ Backslash\n+        scanner.next();\n+\n+        char next = scanner.peek();\n+        if (next == '\\n') {\n+            scanner.next();\n+            return ParsedInline.of(new HardLineBreak(), scanner.position());\n+        } else if (ESCAPABLE.matcher(String.valueOf(next)).matches()) {\n+            scanner.next();\n+            return ParsedInline.of(new Text(String.valueOf(next)), scanner.position());\n+        } else {\n+            return ParsedInline.of(new Text(\"\\\\\"), scanner.position());\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/BackslashInlineParser.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.Code;\n+import jdk.internal.org.commonmark.node.Text;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+\n+\/**\n+ * Attempt to parse backticks, returning either a backtick code span or a literal sequence of backticks.\n+ *\/\n+public class BackticksInlineParser implements InlineContentParser {\n+\n+    @Override\n+    public ParsedInline tryParse(InlineParserState inlineParserState) {\n+        Scanner scanner = inlineParserState.scanner();\n+        Position start = scanner.position();\n+        int openingTicks = scanner.matchMultiple('`');\n+        Position afterOpening = scanner.position();\n+\n+        while (scanner.find('`') > 0) {\n+            Position beforeClosing = scanner.position();\n+            int count = scanner.matchMultiple('`');\n+            if (count == openingTicks) {\n+                Code node = new Code();\n+\n+                String content = scanner.getSource(afterOpening, beforeClosing).getContent();\n+                content = content.replace('\\n', ' ');\n+\n+                \/\/ spec: If the resulting string both begins and ends with a space character, but does not consist\n+                \/\/ entirely of space characters, a single space character is removed from the front and back.\n+                if (content.length() >= 3 &&\n+                        content.charAt(0) == ' ' &&\n+                        content.charAt(content.length() - 1) == ' ' &&\n+                        Parsing.hasNonSpace(content)) {\n+                    content = content.substring(1, content.length() - 1);\n+                }\n+\n+                node.setLiteral(content);\n+                return ParsedInline.of(node, scanner.position());\n+            }\n+        }\n+\n+        \/\/ If we got here, we didn't find a matching closing backtick sequence.\n+        SourceLines source = scanner.getSource(start, afterOpening);\n+        Text text = new Text(source.getContent());\n+        return ParsedInline.of(text, afterOpening);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/BackticksInlineParser.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterRun;\n+\n+public abstract class EmphasisDelimiterProcessor implements DelimiterProcessor {\n+\n+    private final char delimiterChar;\n+\n+    protected EmphasisDelimiterProcessor(char delimiterChar) {\n+        this.delimiterChar = delimiterChar;\n+    }\n+\n+    @Override\n+    public char getOpeningCharacter() {\n+        return delimiterChar;\n+    }\n+\n+    @Override\n+    public char getClosingCharacter() {\n+        return delimiterChar;\n+    }\n+\n+    @Override\n+    public int getMinLength() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public int process(DelimiterRun openingRun, DelimiterRun closingRun) {\n+        \/\/ \"multiple of 3\" rule for internal delimiter runs\n+        if ((openingRun.canClose() || closingRun.canOpen()) &&\n+                closingRun.originalLength() % 3 != 0 &&\n+                (openingRun.originalLength() + closingRun.originalLength()) % 3 == 0) {\n+            return 0;\n+        }\n+\n+        int usedDelimiters;\n+        Node emphasis;\n+        \/\/ calculate actual number of delimiters used from this closer\n+        if (openingRun.length() >= 2 && closingRun.length() >= 2) {\n+            usedDelimiters = 2;\n+            emphasis = new StrongEmphasis(String.valueOf(delimiterChar) + delimiterChar);\n+        } else {\n+            usedDelimiters = 1;\n+            emphasis = new Emphasis(String.valueOf(delimiterChar));\n+        }\n+\n+        SourceSpans sourceSpans = SourceSpans.empty();\n+        sourceSpans.addAllFrom(openingRun.getOpeners(usedDelimiters));\n+\n+        Text opener = openingRun.getOpener();\n+        for (Node node : Nodes.between(opener, closingRun.getCloser())) {\n+            emphasis.appendChild(node);\n+            sourceSpans.addAll(node.getSourceSpans());\n+        }\n+\n+        sourceSpans.addAllFrom(closingRun.getClosers(usedDelimiters));\n+\n+        emphasis.setSourceSpans(sourceSpans.getSourceSpans());\n+        opener.insertAfter(emphasis);\n+\n+        return usedDelimiters;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/EmphasisDelimiterProcessor.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.internal.util.AsciiMatcher;\n+import jdk.internal.org.commonmark.internal.util.Html5Entities;\n+import jdk.internal.org.commonmark.node.Text;\n+\n+\/**\n+ * Attempts to parse a HTML entity or numeric character reference.\n+ *\/\n+public class EntityInlineParser implements InlineContentParser {\n+\n+    private static final AsciiMatcher hex = AsciiMatcher.builder().range('0', '9').range('A', 'F').range('a', 'f').build();\n+    private static final AsciiMatcher dec = AsciiMatcher.builder().range('0', '9').build();\n+    private static final AsciiMatcher entityStart = AsciiMatcher.builder().range('A', 'Z').range('a', 'z').build();\n+    private static final AsciiMatcher entityContinue = entityStart.newBuilder().range('0', '9').build();\n+\n+    @Override\n+    public ParsedInline tryParse(InlineParserState inlineParserState) {\n+        Scanner scanner = inlineParserState.scanner();\n+        Position start = scanner.position();\n+        \/\/ Skip `&`\n+        scanner.next();\n+\n+        char c = scanner.peek();\n+        if (c == '#') {\n+            \/\/ Numeric\n+            scanner.next();\n+            if (scanner.next('x') || scanner.next('X')) {\n+                int digits = scanner.match(hex);\n+                if (1 <= digits && digits <= 6 && scanner.next(';')) {\n+                    return entity(scanner, start);\n+                }\n+            } else {\n+                int digits = scanner.match(dec);\n+                if (1 <= digits && digits <= 7 && scanner.next(';')) {\n+                    return entity(scanner, start);\n+                }\n+            }\n+        } else if (entityStart.matches(c)) {\n+            scanner.match(entityContinue);\n+            if (scanner.next(';')) {\n+                return entity(scanner, start);\n+            }\n+        }\n+\n+        return ParsedInline.none();\n+    }\n+\n+    private ParsedInline entity(Scanner scanner, Position start) {\n+        String text = scanner.getSource(start, scanner.position()).getContent();\n+        return ParsedInline.of(new Text(Html5Entities.entityToString(text)), scanner.position());\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/EntityInlineParser.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.internal.util.AsciiMatcher;\n+import jdk.internal.org.commonmark.node.HtmlInline;\n+\n+\/**\n+ * Attempt to parse inline HTML.\n+ *\/\n+public class HtmlInlineParser implements InlineContentParser {\n+\n+    private static final AsciiMatcher asciiLetter = AsciiMatcher.builder().range('A', 'Z').range('a', 'z').build();\n+\n+    \/\/ spec: A tag name consists of an ASCII letter followed by zero or more ASCII letters, digits, or hyphens (-).\n+    private static final AsciiMatcher tagNameStart = asciiLetter;\n+    private static final AsciiMatcher tagNameContinue = tagNameStart.newBuilder().range('0', '9').c('-').build();\n+\n+    \/\/ spec: An attribute name consists of an ASCII letter, _, or :, followed by zero or more ASCII letters, digits,\n+    \/\/ _, ., :, or -. (Note: This is the XML specification restricted to ASCII. HTML5 is laxer.)\n+    private static final AsciiMatcher attributeStart = asciiLetter.newBuilder().c('_').c(':').build();\n+    private static final AsciiMatcher attributeContinue = attributeStart.newBuilder().range('0', '9').c('.').c('-').build();\n+    \/\/ spec: An unquoted attribute value is a nonempty string of characters not including whitespace, \", ', =, <, >, or `.\n+    private static final AsciiMatcher attributeValueEnd = AsciiMatcher.builder()\n+            .c(' ').c('\\t').c('\\n').c('\\u000B').c('\\f').c('\\r')\n+            .c('\"').c('\\'').c('=').c('<').c('>').c('`')\n+            .build();\n+\n+    @Override\n+    public ParsedInline tryParse(InlineParserState inlineParserState) {\n+        Scanner scanner = inlineParserState.scanner();\n+        Position start = scanner.position();\n+        \/\/ Skip over `<`\n+        scanner.next();\n+\n+        char c = scanner.peek();\n+        if (tagNameStart.matches(c)) {\n+            if (tryOpenTag(scanner)) {\n+                return htmlInline(start, scanner);\n+            }\n+        } else if (c == '\/') {\n+            if (tryClosingTag(scanner)) {\n+                return htmlInline(start, scanner);\n+            }\n+        } else if (c == '?') {\n+            if (tryProcessingInstruction(scanner)) {\n+                return htmlInline(start, scanner);\n+            }\n+        } else if (c == '!') {\n+            \/\/ comment, declaration or CDATA\n+            scanner.next();\n+            c = scanner.peek();\n+            if (c == '-') {\n+                if (tryComment(scanner)) {\n+                    return htmlInline(start, scanner);\n+                }\n+            } else if (c == '[') {\n+                if (tryCdata(scanner)) {\n+                    return htmlInline(start, scanner);\n+                }\n+            } else if (asciiLetter.matches(c)) {\n+                if (tryDeclaration(scanner)) {\n+                    return htmlInline(start, scanner);\n+                }\n+            }\n+        }\n+\n+        return ParsedInline.none();\n+    }\n+\n+    private static ParsedInline htmlInline(Position start, Scanner scanner) {\n+        String text = scanner.getSource(start, scanner.position()).getContent();\n+        HtmlInline node = new HtmlInline();\n+        node.setLiteral(text);\n+        return ParsedInline.of(node, scanner.position());\n+    }\n+\n+    private static boolean tryOpenTag(Scanner scanner) {\n+        \/\/ spec: An open tag consists of a < character, a tag name, zero or more attributes, optional whitespace,\n+        \/\/ an optional \/ character, and a > character.\n+        scanner.next();\n+        scanner.match(tagNameContinue);\n+        boolean whitespace = scanner.whitespace() >= 1;\n+        \/\/ spec: An attribute consists of whitespace, an attribute name, and an optional attribute value specification.\n+        while (whitespace && scanner.match(attributeStart) >= 1) {\n+            scanner.match(attributeContinue);\n+            \/\/ spec: An attribute value specification consists of optional whitespace, a = character,\n+            \/\/ optional whitespace, and an attribute value.\n+            whitespace = scanner.whitespace() >= 1;\n+            if (scanner.next('=')) {\n+                scanner.whitespace();\n+                char valueStart = scanner.peek();\n+                if (valueStart == '\\'') {\n+                    scanner.next();\n+                    if (scanner.find('\\'') < 0) {\n+                        return false;\n+                    }\n+                    scanner.next();\n+                } else if (valueStart == '\"') {\n+                    scanner.next();\n+                    if (scanner.find('\"') < 0) {\n+                        return false;\n+                    }\n+                    scanner.next();\n+                } else {\n+                    if (scanner.find(attributeValueEnd) <= 0) {\n+                        return false;\n+                    }\n+                }\n+\n+                \/\/ Whitespace is required between attributes\n+                whitespace = scanner.whitespace() >= 1;\n+            }\n+        }\n+\n+        scanner.next('\/');\n+        return scanner.next('>');\n+    }\n+\n+    private static boolean tryClosingTag(Scanner scanner) {\n+        \/\/ spec: A closing tag consists of the string <\/, a tag name, optional whitespace, and the character >.\n+        scanner.next();\n+        if (scanner.match(tagNameStart) >= 1) {\n+            scanner.match(tagNameContinue);\n+            scanner.whitespace();\n+            return scanner.next('>');\n+        }\n+        return false;\n+    }\n+\n+    private static boolean tryProcessingInstruction(Scanner scanner) {\n+        \/\/ spec: A processing instruction consists of the string <?, a string of characters not including the string ?>,\n+        \/\/ and the string ?>.\n+        scanner.next();\n+        while (scanner.find('?') > 0) {\n+            scanner.next();\n+            if (scanner.next('>')) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean tryComment(Scanner scanner) {\n+        \/\/ spec: An HTML comment consists of <!-- + text + -->, where text does not start with > or ->, does not end\n+        \/\/ with -, and does not contain --. (See the HTML5 spec.)\n+\n+        \/\/ Skip first `-`\n+        scanner.next();\n+        if (!scanner.next('-')) {\n+            return false;\n+        }\n+\n+        if (scanner.next('>') || scanner.next(\"->\")) {\n+            return false;\n+        }\n+\n+        while (scanner.find('-') >= 0) {\n+            if (scanner.next(\"--\")) {\n+                return scanner.next('>');\n+            } else {\n+                scanner.next();\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private static boolean tryCdata(Scanner scanner) {\n+        \/\/ spec: A CDATA section consists of the string <![CDATA[, a string of characters not including the string ]]>,\n+        \/\/ and the string ]]>.\n+\n+        \/\/ Skip `[`\n+        scanner.next();\n+\n+        if (scanner.next(\"CDATA[\")) {\n+            while (scanner.find(']') >= 0) {\n+                if (scanner.next(\"]]>\")) {\n+                    return true;\n+                } else {\n+                    scanner.next();\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private static boolean tryDeclaration(Scanner scanner) {\n+        \/\/ spec: A declaration consists of the string <!, an ASCII letter, zero or more characters not including\n+        \/\/ the character >, and the character >.\n+        scanner.match(asciiLetter);\n+        if (scanner.whitespace() <= 0) {\n+            return false;\n+        }\n+        if (scanner.find('>') >= 0) {\n+            scanner.next();\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/HtmlInlineParser.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+public interface InlineContentParser {\n+\n+    ParsedInline tryParse(InlineParserState inlineParserState);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/InlineContentParser.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+public interface InlineParserState {\n+\n+    \/**\n+     * Return a scanner for the input for the current position (on the character that the inline parser registered\n+     * interest for).\n+     * <p>\n+     * Note that this always returns the same instance, if you want to backtrack you need to use\n+     * {@link Scanner#position()} and {@link Scanner#setPosition(Position)}.\n+     *\/\n+    Scanner scanner();\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/InlineParserState.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+public abstract class ParsedInline {\n+\n+    protected ParsedInline() {\n+    }\n+\n+    public static ParsedInline none() {\n+        return null;\n+    }\n+\n+    public static ParsedInline of(Node node, Position position) {\n+        if (node == null) {\n+            throw new NullPointerException(\"node must not be null\");\n+        }\n+        if (position == null) {\n+            throw new NullPointerException(\"position must not be null\");\n+        }\n+        return new ParsedInlineImpl(node, position);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/ParsedInline.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+public class ParsedInlineImpl extends ParsedInline {\n+    private final Node node;\n+    private final Position position;\n+\n+    ParsedInlineImpl(Node node, Position position) {\n+        this.node = node;\n+        this.position = position;\n+    }\n+\n+    public Node getNode() {\n+        return node;\n+    }\n+\n+    public Position getPosition() {\n+        return position;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/ParsedInlineImpl.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+\/**\n+ * Position within a {@link Scanner}. This is intentionally kept opaque so as not to expose the internal structure of\n+ * the Scanner.\n+ *\/\n+public class Position {\n+\n+    final int lineIndex;\n+    final int index;\n+\n+    Position(int lineIndex, int index) {\n+        this.lineIndex = lineIndex;\n+        this.index = index;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/Position.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.internal.util.CharMatcher;\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+\n+import java.util.List;\n+\n+public class Scanner {\n+\n+    \/**\n+     * Character representing the end of input source (or outside of the text in case of the \"previous\" methods).\n+     * <p>\n+     * Note that we can use NULL to represent this because CommonMark does not allow those in the input (we replace them\n+     * in the beginning of parsing).\n+     *\/\n+    public static final char END = '\\0';\n+\n+    \/\/ Lines without newlines at the end. The scanner will yield `\\n` between lines because they're significant for\n+    \/\/ parsing and the final output. There is no `\\n` after the last line.\n+    private final List<SourceLine> lines;\n+    \/\/ Which line we're at.\n+    private int lineIndex;\n+    \/\/ The index within the line. If index == length(), we pretend that there's a `\\n` and only advance after we yield\n+    \/\/ that.\n+    private int index;\n+\n+    \/\/ Current line or \"\" if at the end of the lines (using \"\" instead of null saves a null check)\n+    private SourceLine line = SourceLine.of(\"\", null);\n+    private int lineLength = 0;\n+\n+    Scanner(List<SourceLine> lines, int lineIndex, int index) {\n+        this.lines = lines;\n+        this.lineIndex = lineIndex;\n+        this.index = index;\n+        if (!lines.isEmpty()) {\n+            checkPosition(lineIndex, index);\n+            setLine(lines.get(lineIndex));\n+        }\n+    }\n+\n+    public static Scanner of(SourceLines lines) {\n+        return new Scanner(lines.getLines(), 0, 0);\n+    }\n+\n+    public char peek() {\n+        if (index < lineLength) {\n+            return line.getContent().charAt(index);\n+        } else {\n+            if (lineIndex < lines.size() - 1) {\n+                return '\\n';\n+            } else {\n+                \/\/ Don't return newline for end of last line\n+                return END;\n+            }\n+        }\n+    }\n+\n+    public int peekCodePoint() {\n+        if (index < lineLength) {\n+            char c = line.getContent().charAt(index);\n+            if (Character.isHighSurrogate(c) && index + 1 < lineLength) {\n+                char low = line.getContent().charAt(index + 1);\n+                if (Character.isLowSurrogate(low)) {\n+                    return Character.toCodePoint(c, low);\n+                }\n+            }\n+            return c;\n+        } else {\n+            if (lineIndex < lines.size() - 1) {\n+                return '\\n';\n+            } else {\n+                \/\/ Don't return newline for end of last line\n+                return END;\n+            }\n+        }\n+    }\n+\n+    public int peekPreviousCodePoint() {\n+        if (index > 0) {\n+            int prev = index - 1;\n+            char c = line.getContent().charAt(prev);\n+            if (Character.isLowSurrogate(c) && prev > 0) {\n+                char high = line.getContent().charAt(prev - 1);\n+                if (Character.isHighSurrogate(high)) {\n+                    return Character.toCodePoint(high, c);\n+                }\n+            }\n+            return c;\n+        } else {\n+            if (lineIndex > 0) {\n+                return '\\n';\n+            } else {\n+                return END;\n+            }\n+        }\n+    }\n+\n+    public boolean hasNext() {\n+        if (index < lineLength) {\n+            return true;\n+        } else {\n+            \/\/ No newline at end of last line\n+            return lineIndex < lines.size() - 1;\n+        }\n+    }\n+\n+    public void next() {\n+        index++;\n+        if (index > lineLength) {\n+            lineIndex++;\n+            if (lineIndex < lines.size()) {\n+                setLine(lines.get(lineIndex));\n+            } else {\n+                setLine(SourceLine.of(\"\", null));\n+            }\n+            index = 0;\n+        }\n+    }\n+\n+    \/**\n+     * Check if the specified char is next and advance the position.\n+     *\n+     * @param c the char to check (including newline characters)\n+     * @return true if matched and position was advanced, false otherwise\n+     *\/\n+    public boolean next(char c) {\n+        if (peek() == c) {\n+            next();\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * Check if we have the specified content on the line and advanced the position. Note that if you want to match\n+     * newline characters, use {@link #next(char)}.\n+     *\n+     * @param content the text content to match on a single line (excluding newline characters)\n+     * @return true if matched and position was advanced, false otherwise\n+     *\/\n+    public boolean next(String content) {\n+        if (index < lineLength && index + content.length() <= lineLength) {\n+            \/\/ Can't use startsWith because it's not available on CharSequence\n+            for (int i = 0; i < content.length(); i++) {\n+                if (line.getContent().charAt(index + i) != content.charAt(i)) {\n+                    return false;\n+                }\n+            }\n+            index += content.length();\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int matchMultiple(char c) {\n+        int count = 0;\n+        while (peek() == c) {\n+            count++;\n+            next();\n+        }\n+        return count;\n+    }\n+\n+    public int match(CharMatcher matcher) {\n+        int count = 0;\n+        while (matcher.matches(peek())) {\n+            count++;\n+            next();\n+        }\n+        return count;\n+    }\n+\n+    public int whitespace() {\n+        int count = 0;\n+        while (true) {\n+            switch (peek()) {\n+                case ' ':\n+                case '\\t':\n+                case '\\n':\n+                case '\\u000B':\n+                case '\\f':\n+                case '\\r':\n+                    count++;\n+                    next();\n+                    break;\n+                default:\n+                    return count;\n+            }\n+        }\n+    }\n+\n+    public int find(char c) {\n+        int count = 0;\n+        while (true) {\n+            char cur = peek();\n+            if (cur == Scanner.END) {\n+                return -1;\n+            } else if (cur == c) {\n+                return count;\n+            }\n+            count++;\n+            next();\n+        }\n+    }\n+\n+    public int find(CharMatcher matcher) {\n+        int count = 0;\n+        while (true) {\n+            char c = peek();\n+            if (c == END) {\n+                return -1;\n+            } else if (matcher.matches(c)) {\n+                return count;\n+            }\n+            count++;\n+            next();\n+        }\n+    }\n+\n+    \/\/ Don't expose the int index, because it would be good if we could switch input to a List<String> of lines later\n+    \/\/ instead of one contiguous String.\n+    public Position position() {\n+        return new Position(lineIndex, index);\n+    }\n+\n+    public void setPosition(Position position) {\n+        checkPosition(position.lineIndex, position.index);\n+        this.lineIndex = position.lineIndex;\n+        this.index = position.index;\n+        setLine(lines.get(this.lineIndex));\n+    }\n+\n+    \/\/ For cases where the caller appends the result to a StringBuilder, we could offer another method to avoid some\n+    \/\/ unnecessary copying.\n+    public SourceLines getSource(Position begin, Position end) {\n+        if (begin.lineIndex == end.lineIndex) {\n+            \/\/ Shortcut for common case of text from a single line\n+            SourceLine line = lines.get(begin.lineIndex);\n+            CharSequence newContent = line.getContent().subSequence(begin.index, end.index);\n+            SourceSpan newSourceSpan = null;\n+            SourceSpan sourceSpan = line.getSourceSpan();\n+            if (sourceSpan != null) {\n+                newSourceSpan = SourceSpan.of(sourceSpan.getLineIndex(), sourceSpan.getColumnIndex() + begin.index, newContent.length());\n+            }\n+            return SourceLines.of(SourceLine.of(newContent, newSourceSpan));\n+        } else {\n+            SourceLines sourceLines = SourceLines.empty();\n+\n+            SourceLine firstLine = lines.get(begin.lineIndex);\n+            sourceLines.addLine(firstLine.substring(begin.index, firstLine.getContent().length()));\n+\n+            \/\/ Lines between begin and end (we are appending the full line)\n+            for (int line = begin.lineIndex + 1; line < end.lineIndex; line++) {\n+                sourceLines.addLine(lines.get(line));\n+            }\n+\n+            SourceLine lastLine = lines.get(end.lineIndex);\n+            sourceLines.addLine(lastLine.substring(0, end.index));\n+            return sourceLines;\n+        }\n+    }\n+\n+    private void setLine(SourceLine line) {\n+        this.line = line;\n+        this.lineLength = line.getContent().length();\n+    }\n+\n+    private void checkPosition(int lineIndex, int index) {\n+        if (lineIndex < 0 || lineIndex >= lines.size()) {\n+            throw new IllegalArgumentException(\"Line index \" + lineIndex + \" out of range, number of lines: \" + lines.size());\n+        }\n+        SourceLine line = lines.get(lineIndex);\n+        if (index < 0 || index > line.getContent().length()) {\n+            throw new IllegalArgumentException(\"Index \" + index + \" out of range, line length: \" + line.getContent().length());\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/Scanner.java","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+public class UnderscoreDelimiterProcessor extends EmphasisDelimiterProcessor {\n+\n+    public UnderscoreDelimiterProcessor() {\n+        super('_');\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/UnderscoreDelimiterProcessor.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.renderer;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class NodeRendererMap {\n+\n+    private final Map<Class<? extends Node>, NodeRenderer> renderers = new HashMap<>(32);\n+\n+    public void add(NodeRenderer nodeRenderer) {\n+        for (Class<? extends Node> nodeType : nodeRenderer.getNodeTypes()) {\n+            \/\/ Overwrite existing renderer\n+            renderers.put(nodeType, nodeRenderer);\n+        }\n+    }\n+\n+    public void render(Node node) {\n+        NodeRenderer nodeRenderer = renderers.get(node.getClass());\n+        if (nodeRenderer != null) {\n+            nodeRenderer.render(node);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/renderer\/NodeRendererMap.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.renderer.text;\n+\n+import jdk.internal.org.commonmark.node.BulletList;\n+\n+public class BulletListHolder extends ListHolder {\n+    private final char marker;\n+\n+    public BulletListHolder(ListHolder parent, BulletList list) {\n+        super(parent);\n+        marker = list.getBulletMarker();\n+    }\n+\n+    public char getMarker() {\n+        return marker;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/renderer\/text\/BulletListHolder.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.renderer.text;\n+\n+public abstract class ListHolder {\n+    private static final String INDENT_DEFAULT = \"   \";\n+    private static final String INDENT_EMPTY = \"\";\n+\n+    private final ListHolder parent;\n+    private final String indent;\n+\n+    ListHolder(ListHolder parent) {\n+        this.parent = parent;\n+\n+        if (parent != null) {\n+            indent = parent.indent + INDENT_DEFAULT;\n+        } else {\n+            indent = INDENT_EMPTY;\n+        }\n+    }\n+\n+    public ListHolder getParent() {\n+        return parent;\n+    }\n+\n+    public String getIndent() {\n+        return indent;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/renderer\/text\/ListHolder.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.renderer.text;\n+\n+import jdk.internal.org.commonmark.node.OrderedList;\n+\n+public class OrderedListHolder extends ListHolder {\n+    private final char delimiter;\n+    private int counter;\n+\n+    public OrderedListHolder(ListHolder parent, OrderedList list) {\n+        super(parent);\n+        delimiter = list.getDelimiter();\n+        counter = list.getStartNumber();\n+    }\n+\n+    public char getDelimiter() {\n+        return delimiter;\n+    }\n+\n+    public int getCounter() {\n+        return counter;\n+    }\n+\n+    public void increaseCounter() {\n+        counter++;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/renderer\/text\/OrderedListHolder.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.util;\n+\n+import java.util.BitSet;\n+\n+public class AsciiMatcher implements CharMatcher {\n+    private final BitSet set;\n+\n+    private AsciiMatcher(Builder builder) {\n+        this.set = builder.set;\n+    }\n+\n+    @Override\n+    public boolean matches(char c) {\n+        return set.get(c);\n+    }\n+\n+    public Builder newBuilder() {\n+        return new Builder((BitSet) set.clone());\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder(new BitSet());\n+    }\n+\n+    public static class Builder {\n+        private final BitSet set;\n+\n+        private Builder(BitSet set) {\n+            this.set = set;\n+        }\n+\n+        public Builder c(char c) {\n+            if (c > 127) {\n+                throw new IllegalArgumentException(\"Can only match ASCII characters\");\n+            }\n+            set.set(c);\n+            return this;\n+        }\n+\n+        public Builder range(char from, char toInclusive) {\n+            for (char c = from; c <= toInclusive; c++) {\n+                c(c);\n+            }\n+            return this;\n+        }\n+\n+        public AsciiMatcher build() {\n+            return new AsciiMatcher(this);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/AsciiMatcher.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.util;\n+\n+public interface CharMatcher {\n+\n+    boolean matches(char c);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/CharMatcher.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.util;\n+\n+import java.nio.charset.Charset;\n+import java.util.Locale;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class Escaping {\n+\n+    public static final String ESCAPABLE = \"[!\\\"#$%&\\'()*+,.\/:;<=>?@\\\\[\\\\\\\\\\\\]^_`{|}~-]\";\n+\n+    public static final String ENTITY = \"&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});\";\n+\n+    private static final Pattern BACKSLASH_OR_AMP = Pattern.compile(\"[\\\\\\\\&]\");\n+\n+    private static final Pattern ENTITY_OR_ESCAPED_CHAR =\n+            Pattern.compile(\"\\\\\\\\\" + ESCAPABLE + '|' + ENTITY, Pattern.CASE_INSENSITIVE);\n+\n+    \/\/ From RFC 3986 (see \"reserved\", \"unreserved\") except don't escape '[' or ']' to be compatible with JS encodeURI\n+    private static final Pattern ESCAPE_IN_URI =\n+            Pattern.compile(\"(%[a-fA-F0-9]{0,2}|[^:\/?#@!$&'()*+,;=a-zA-Z0-9\\\\-._~])\");\n+\n+    private static final char[] HEX_DIGITS =\n+            new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n+\n+    private static final Pattern WHITESPACE = Pattern.compile(\"[ \\t\\r\\n]+\");\n+\n+    private static final Replacer UNESCAPE_REPLACER = new Replacer() {\n+        @Override\n+        public void replace(String input, StringBuilder sb) {\n+            if (input.charAt(0) == '\\\\') {\n+                sb.append(input, 1, input.length());\n+            } else {\n+                sb.append(Html5Entities.entityToString(input));\n+            }\n+        }\n+    };\n+\n+    private static final Replacer URI_REPLACER = new Replacer() {\n+        @Override\n+        public void replace(String input, StringBuilder sb) {\n+            if (input.startsWith(\"%\")) {\n+                if (input.length() == 3) {\n+                    \/\/ Already percent-encoded, preserve\n+                    sb.append(input);\n+                } else {\n+                    \/\/ %25 is the percent-encoding for %\n+                    sb.append(\"%25\");\n+                    sb.append(input, 1, input.length());\n+                }\n+            } else {\n+                byte[] bytes = input.getBytes(Charset.forName(\"UTF-8\"));\n+                for (byte b : bytes) {\n+                    sb.append('%');\n+                    sb.append(HEX_DIGITS[(b >> 4) & 0xF]);\n+                    sb.append(HEX_DIGITS[b & 0xF]);\n+                }\n+            }\n+        }\n+    };\n+\n+    public static String escapeHtml(String input) {\n+        \/\/ Avoid building a new string in the majority of cases (nothing to escape)\n+        StringBuilder sb = null;\n+\n+        loop:\n+        for (int i = 0; i < input.length(); i++) {\n+            char c = input.charAt(i);\n+            String replacement;\n+            switch (c) {\n+                case '&':\n+                    replacement = \"&amp;\";\n+                    break;\n+                case '<':\n+                    replacement = \"&lt;\";\n+                    break;\n+                case '>':\n+                    replacement = \"&gt;\";\n+                    break;\n+                case '\\\"':\n+                    replacement = \"&quot;\";\n+                    break;\n+                default:\n+                    if (sb != null) {\n+                        sb.append(c);\n+                    }\n+                    continue loop;\n+            }\n+            if (sb == null) {\n+                sb = new StringBuilder();\n+                sb.append(input, 0, i);\n+            }\n+            sb.append(replacement);\n+        }\n+\n+        return sb != null ? sb.toString() : input;\n+    }\n+\n+    \/**\n+     * Replace entities and backslash escapes with literal characters.\n+     *\/\n+    public static String unescapeString(String s) {\n+        if (BACKSLASH_OR_AMP.matcher(s).find()) {\n+            return replaceAll(ENTITY_OR_ESCAPED_CHAR, s, UNESCAPE_REPLACER);\n+        } else {\n+            return s;\n+        }\n+    }\n+\n+    public static String percentEncodeUrl(String s) {\n+        return replaceAll(ESCAPE_IN_URI, s, URI_REPLACER);\n+    }\n+\n+    public static String normalizeLabelContent(String input) {\n+        String trimmed = input.trim();\n+\n+        \/\/ This is necessary to correctly case fold \"\\u1e9e\" to \"SS\":\n+        \/\/ \"\\u1e9e\".toLowerCase(Locale.ROOT)  -> \"\\u00df\"\n+        \/\/ \"\\u00df\".toUpperCase(Locale.ROOT)  -> \"SS\"\n+        \/\/ Note that doing upper first (or only upper without lower) wouldn't work because:\n+        \/\/ \"\\u1e9e\".toUpperCase(Locale.ROOT)  -> \"\\u1e9e\"\n+        String caseFolded = trimmed.toLowerCase(Locale.ROOT).toUpperCase(Locale.ROOT);\n+\n+        return WHITESPACE.matcher(caseFolded).replaceAll(\" \");\n+    }\n+\n+    private static String replaceAll(Pattern p, String s, Replacer replacer) {\n+        Matcher matcher = p.matcher(s);\n+\n+        if (!matcher.find()) {\n+            return s;\n+        }\n+\n+        StringBuilder sb = new StringBuilder(s.length() + 16);\n+        int lastEnd = 0;\n+        do {\n+            sb.append(s, lastEnd, matcher.start());\n+            replacer.replace(matcher.group(), sb);\n+            lastEnd = matcher.end();\n+        } while (matcher.find());\n+\n+        if (lastEnd != s.length()) {\n+            sb.append(s, lastEnd, s.length());\n+        }\n+        return sb.toString();\n+    }\n+\n+    private interface Replacer {\n+        void replace(String input, StringBuilder sb);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/Escaping.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.util;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class Html5Entities {\n+\n+    private static final Map<String, String> NAMED_CHARACTER_REFERENCES = readEntities();\n+    private static final String ENTITY_PATH = \"\/jdk\/internal\/org\/commonmark\/internal\/util\/entities.txt\";\n+\n+    public static String entityToString(String input) {\n+        if (!input.startsWith(\"&\") || !input.endsWith(\";\")) {\n+            return input;\n+        }\n+\n+        String value = input.substring(1, input.length() - 1);\n+        if (value.startsWith(\"#\")) {\n+            value = value.substring(1);\n+            int base = 10;\n+            if (value.startsWith(\"x\") || value.startsWith(\"X\")) {\n+                value = value.substring(1);\n+                base = 16;\n+            }\n+\n+            try {\n+                int codePoint = Integer.parseInt(value, base);\n+                if (codePoint == 0) {\n+                    return \"\\uFFFD\";\n+                }\n+                return new String(Character.toChars(codePoint));\n+            } catch (IllegalArgumentException e) {\n+                return \"\\uFFFD\";\n+            }\n+        } else {\n+            String s = NAMED_CHARACTER_REFERENCES.get(value);\n+            if (s != null) {\n+                return s;\n+            } else {\n+                return input;\n+            }\n+        }\n+    }\n+\n+    private static Map<String, String> readEntities() {\n+        Map<String, String> entities = new HashMap<>();\n+        InputStream stream = Html5Entities.class.getResourceAsStream(ENTITY_PATH);\n+        Charset charset = StandardCharsets.UTF_8;\n+        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(stream, charset))) {\n+            String line;\n+            while ((line = bufferedReader.readLine()) != null) {\n+                if (line.length() == 0) {\n+                    continue;\n+                }\n+                int equal = line.indexOf(\"=\");\n+                String key = line.substring(0, equal);\n+                String value = line.substring(equal + 1);\n+                entities.put(key, value);\n+            }\n+        } catch (IOException e) {\n+            throw new IllegalStateException(\"Failed reading data for HTML named character references\", e);\n+        }\n+        entities.put(\"NewLine\", \"\\n\");\n+        return entities;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/Html5Entities.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.util;\n+\n+import jdk.internal.org.commonmark.internal.inline.Scanner;\n+\n+public class LinkScanner {\n+\n+    \/**\n+     * Attempt to scan the contents of a link label (inside the brackets), stopping after the content or returning false.\n+     * The stopped position can bei either the closing {@code ]}, or the end of the line if the label continues on\n+     * the next line.\n+     *\/\n+    public static boolean scanLinkLabelContent(Scanner scanner) {\n+        while (scanner.hasNext()) {\n+            switch (scanner.peek()) {\n+                case '\\\\':\n+                    scanner.next();\n+                    if (Parsing.isEscapable(scanner.peek())) {\n+                        scanner.next();\n+                    }\n+                    break;\n+                case ']':\n+                    return true;\n+                case '[':\n+                    \/\/ spec: Unescaped square bracket characters are not allowed inside the opening and closing\n+                    \/\/ square brackets of link labels.\n+                    return false;\n+                default:\n+                    scanner.next();\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Attempt to scan a link destination, stopping after the destination or returning false.\n+     *\/\n+    public static boolean scanLinkDestination(Scanner scanner) {\n+        if (!scanner.hasNext()) {\n+            return false;\n+        }\n+\n+        if (scanner.next('<')) {\n+            while (scanner.hasNext()) {\n+                switch (scanner.peek()) {\n+                    case '\\\\':\n+                        scanner.next();\n+                        if (Parsing.isEscapable(scanner.peek())) {\n+                            scanner.next();\n+                        }\n+                        break;\n+                    case '\\n':\n+                    case '<':\n+                        return false;\n+                    case '>':\n+                        scanner.next();\n+                        return true;\n+                    default:\n+                        scanner.next();\n+                }\n+            }\n+            return false;\n+        } else {\n+            return scanLinkDestinationWithBalancedParens(scanner);\n+        }\n+    }\n+\n+    public static boolean scanLinkTitle(Scanner scanner) {\n+        if (!scanner.hasNext()) {\n+            return false;\n+        }\n+\n+        char endDelimiter;\n+        switch (scanner.peek()) {\n+            case '\"':\n+                endDelimiter = '\"';\n+                break;\n+            case '\\'':\n+                endDelimiter = '\\'';\n+                break;\n+            case '(':\n+                endDelimiter = ')';\n+                break;\n+            default:\n+                return false;\n+        }\n+        scanner.next();\n+\n+        if (!scanLinkTitleContent(scanner, endDelimiter)) {\n+            return false;\n+        }\n+        if (!scanner.hasNext()) {\n+            return false;\n+        }\n+        scanner.next();\n+        return true;\n+    }\n+\n+    public static boolean scanLinkTitleContent(Scanner scanner, char endDelimiter) {\n+        while (scanner.hasNext()) {\n+            char c = scanner.peek();\n+            if (c == '\\\\') {\n+                scanner.next();\n+                if (Parsing.isEscapable(scanner.peek())) {\n+                    scanner.next();\n+                }\n+            } else if (c == endDelimiter) {\n+                return true;\n+            } else if (endDelimiter == ')' && c == '(') {\n+                \/\/ unescaped '(' in title within parens is invalid\n+                return false;\n+            } else {\n+                scanner.next();\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/\/ spec: a nonempty sequence of characters that does not start with <, does not include ASCII space or control\n+    \/\/ characters, and includes parentheses only if (a) they are backslash-escaped or (b) they are part of a balanced\n+    \/\/ pair of unescaped parentheses\n+    private static boolean scanLinkDestinationWithBalancedParens(Scanner scanner) {\n+        int parens = 0;\n+        boolean empty = true;\n+        while (scanner.hasNext()) {\n+            char c = scanner.peek();\n+            switch (c) {\n+                case ' ':\n+                    return !empty;\n+                case '\\\\':\n+                    scanner.next();\n+                    if (Parsing.isEscapable(scanner.peek())) {\n+                        scanner.next();\n+                    }\n+                    break;\n+                case '(':\n+                    parens++;\n+                    \/\/ Limit to 32 nested parens for pathological cases\n+                    if (parens > 32) {\n+                        return false;\n+                    }\n+                    scanner.next();\n+                    break;\n+                case ')':\n+                    if (parens == 0) {\n+                        return true;\n+                    } else {\n+                        parens--;\n+                    }\n+                    scanner.next();\n+                    break;\n+                default:\n+                    \/\/ or control character\n+                    if (Character.isISOControl(c)) {\n+                        return !empty;\n+                    }\n+                    scanner.next();\n+                    break;\n+            }\n+            empty = false;\n+        }\n+        return true;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/LinkScanner.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,278 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.util;\n+\n+public class Parsing {\n+\n+    private static final String TAGNAME = \"[A-Za-z][A-Za-z0-9-]*\";\n+    private static final String ATTRIBUTENAME = \"[a-zA-Z_:][a-zA-Z0-9:._-]*\";\n+    private static final String UNQUOTEDVALUE = \"[^\\\"'=<>`\\\\x00-\\\\x20]+\";\n+    private static final String SINGLEQUOTEDVALUE = \"'[^']*'\";\n+    private static final String DOUBLEQUOTEDVALUE = \"\\\"[^\\\"]*\\\"\";\n+    private static final String ATTRIBUTEVALUE = \"(?:\" + UNQUOTEDVALUE + \"|\" + SINGLEQUOTEDVALUE\n+            + \"|\" + DOUBLEQUOTEDVALUE + \")\";\n+    private static final String ATTRIBUTEVALUESPEC = \"(?:\" + \"\\\\s*=\" + \"\\\\s*\" + ATTRIBUTEVALUE\n+            + \")\";\n+    private static final String ATTRIBUTE = \"(?:\" + \"\\\\s+\" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC\n+            + \"?)\";\n+\n+    public static final String OPENTAG = \"<\" + TAGNAME + ATTRIBUTE + \"*\" + \"\\\\s*\/?>\";\n+    public static final String CLOSETAG = \"<\/\" + TAGNAME + \"\\\\s*[>]\";\n+\n+    public static int CODE_BLOCK_INDENT = 4;\n+\n+    public static int columnsToNextTabStop(int column) {\n+        \/\/ Tab stop is 4\n+        return 4 - (column % 4);\n+    }\n+\n+    public static int find(char c, CharSequence s, int startIndex) {\n+        int length = s.length();\n+        for (int i = startIndex; i < length; i++) {\n+            if (s.charAt(i) == c) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public static int findLineBreak(CharSequence s, int startIndex) {\n+        int length = s.length();\n+        for (int i = startIndex; i < length; i++) {\n+            switch (s.charAt(i)) {\n+                case '\\n':\n+                case '\\r':\n+                    return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public static boolean isBlank(CharSequence s) {\n+        return findNonSpace(s, 0) == -1;\n+    }\n+\n+    public static boolean hasNonSpace(CharSequence s) {\n+        int length = s.length();\n+        int skipped = skip(' ', s, 0, length);\n+        return skipped != length;\n+    }\n+\n+    public static boolean isLetter(CharSequence s, int index) {\n+        int codePoint = Character.codePointAt(s, index);\n+        return Character.isLetter(codePoint);\n+    }\n+\n+    public static boolean isSpaceOrTab(CharSequence s, int index) {\n+        if (index < s.length()) {\n+            switch (s.charAt(index)) {\n+                case ' ':\n+                case '\\t':\n+                    return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static boolean isEscapable(char c) {\n+        switch (c) {\n+            case '!':\n+            case '\"':\n+            case '#':\n+            case '$':\n+            case '%':\n+            case '&':\n+            case '\\'':\n+            case '(':\n+            case ')':\n+            case '*':\n+            case '+':\n+            case ',':\n+            case '-':\n+            case '.':\n+            case '\/':\n+            case ':':\n+            case ';':\n+            case '<':\n+            case '=':\n+            case '>':\n+            case '?':\n+            case '@':\n+            case '[':\n+            case '\\\\':\n+            case ']':\n+            case '^':\n+            case '_':\n+            case '`':\n+            case '{':\n+            case '|':\n+            case '}':\n+            case '~':\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    \/\/ See https:\/\/spec.commonmark.org\/0.29\/#punctuation-character\n+    public static boolean isPunctuationCodePoint(int codePoint) {\n+        switch (Character.getType(codePoint)) {\n+            case Character.CONNECTOR_PUNCTUATION:\n+            case Character.DASH_PUNCTUATION:\n+            case Character.END_PUNCTUATION:\n+            case Character.FINAL_QUOTE_PUNCTUATION:\n+            case Character.INITIAL_QUOTE_PUNCTUATION:\n+            case Character.OTHER_PUNCTUATION:\n+            case Character.START_PUNCTUATION:\n+                return true;\n+            default:\n+                switch (codePoint) {\n+                    case '$':\n+                    case '+':\n+                    case '<':\n+                    case '=':\n+                    case '>':\n+                    case '^':\n+                    case '`':\n+                    case '|':\n+                    case '~':\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+        }\n+    }\n+\n+    public static boolean isWhitespaceCodePoint(int codePoint) {\n+        switch (codePoint) {\n+            case ' ':\n+            case '\\t':\n+            case '\\r':\n+            case '\\n':\n+            case '\\f':\n+                return true;\n+            default:\n+                return Character.getType(codePoint) == Character.SPACE_SEPARATOR;\n+        }\n+    }\n+\n+    \/**\n+     * Prepares the input line replacing {@code \\0}\n+     *\/\n+    public static CharSequence prepareLine(CharSequence line) {\n+        \/\/ Avoid building a new string in the majority of cases (no \\0)\n+        StringBuilder sb = null;\n+        int length = line.length();\n+        for (int i = 0; i < length; i++) {\n+            char c = line.charAt(i);\n+            if (c == '\\0') {\n+                if (sb == null) {\n+                    sb = new StringBuilder(length);\n+                    sb.append(line, 0, i);\n+                }\n+                sb.append('\\uFFFD');\n+            } else {\n+                if (sb != null) {\n+                    sb.append(c);\n+                }\n+            }\n+        }\n+\n+        if (sb != null) {\n+            return sb.toString();\n+        } else {\n+            return line;\n+        }\n+    }\n+\n+    public static int skip(char skip, CharSequence s, int startIndex, int endIndex) {\n+        for (int i = startIndex; i < endIndex; i++) {\n+            if (s.charAt(i) != skip) {\n+                return i;\n+            }\n+        }\n+        return endIndex;\n+    }\n+\n+    public static int skipBackwards(char skip, CharSequence s, int startIndex, int lastIndex) {\n+        for (int i = startIndex; i >= lastIndex; i--) {\n+            if (s.charAt(i) != skip) {\n+                return i;\n+            }\n+        }\n+        return lastIndex - 1;\n+    }\n+\n+    public static int skipSpaceTab(CharSequence s, int startIndex, int endIndex) {\n+        for (int i = startIndex; i < endIndex; i++) {\n+            switch (s.charAt(i)) {\n+                case ' ':\n+                case '\\t':\n+                    break;\n+                default:\n+                    return i;\n+            }\n+        }\n+        return endIndex;\n+    }\n+\n+    public static int skipSpaceTabBackwards(CharSequence s, int startIndex, int lastIndex) {\n+        for (int i = startIndex; i >= lastIndex; i--) {\n+            switch (s.charAt(i)) {\n+                case ' ':\n+                case '\\t':\n+                    break;\n+                default:\n+                    return i;\n+            }\n+        }\n+        return lastIndex - 1;\n+    }\n+\n+    private static int findNonSpace(CharSequence s, int startIndex) {\n+        int length = s.length();\n+        for (int i = startIndex; i < length; i++) {\n+            switch (s.charAt(i)) {\n+                case ' ':\n+                case '\\t':\n+                case '\\n':\n+                case '\\u000B':\n+                case '\\f':\n+                case '\\r':\n+                    break;\n+                default:\n+                    return i;\n+            }\n+        }\n+        return -1;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/Parsing.java","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"},{"patch":"@@ -0,0 +1,2126 @@\n+Aacute=Á\n+aacute=á\n+Abreve=Ă\n+abreve=ă\n+ac=∾\n+acd=∿\n+acE=∾̳\n+Acirc=Â\n+acirc=â\n+acute=´\n+Acy=А\n+acy=а\n+AElig=Æ\n+aelig=æ\n+af=⁡\n+Afr=𝔄\n+afr=𝔞\n+Agrave=À\n+agrave=à\n+alefsym=ℵ\n+aleph=ℵ\n+Alpha=Α\n+alpha=α\n+Amacr=Ā\n+amacr=ā\n+amalg=⨿\n+amp=&\n+AMP=&\n+andand=⩕\n+And=⩓\n+and=∧\n+andd=⩜\n+andslope=⩘\n+andv=⩚\n+ang=∠\n+ange=⦤\n+angle=∠\n+angmsdaa=⦨\n+angmsdab=⦩\n+angmsdac=⦪\n+angmsdad=⦫\n+angmsdae=⦬\n+angmsdaf=⦭\n+angmsdag=⦮\n+angmsdah=⦯\n+angmsd=∡\n+angrt=∟\n+angrtvb=⊾\n+angrtvbd=⦝\n+angsph=∢\n+angst=Å\n+angzarr=⍼\n+Aogon=Ą\n+aogon=ą\n+Aopf=𝔸\n+aopf=𝕒\n+apacir=⩯\n+ap=≈\n+apE=⩰\n+ape=≊\n+apid=≋\n+apos='\n+ApplyFunction=⁡\n+approx=≈\n+approxeq=≊\n+Aring=Å\n+aring=å\n+Ascr=𝒜\n+ascr=𝒶\n+Assign=≔\n+ast=*\n+asymp=≈\n+asympeq=≍\n+Atilde=Ã\n+atilde=ã\n+Auml=Ä\n+auml=ä\n+awconint=∳\n+awint=⨑\n+backcong=≌\n+backepsilon=϶\n+backprime=‵\n+backsim=∽\n+backsimeq=⋍\n+Backslash=∖\n+Barv=⫧\n+barvee=⊽\n+barwed=⌅\n+Barwed=⌆\n+barwedge=⌅\n+bbrk=⎵\n+bbrktbrk=⎶\n+bcong=≌\n+Bcy=Б\n+bcy=б\n+bdquo=„\n+becaus=∵\n+because=∵\n+Because=∵\n+bemptyv=⦰\n+bepsi=϶\n+bernou=ℬ\n+Bernoullis=ℬ\n+Beta=Β\n+beta=β\n+beth=ℶ\n+between=≬\n+Bfr=𝔅\n+bfr=𝔟\n+bigcap=⋂\n+bigcirc=◯\n+bigcup=⋃\n+bigodot=⨀\n+bigoplus=⨁\n+bigotimes=⨂\n+bigsqcup=⨆\n+bigstar=★\n+bigtriangledown=▽\n+bigtriangleup=△\n+biguplus=⨄\n+bigvee=⋁\n+bigwedge=⋀\n+bkarow=⤍\n+blacklozenge=⧫\n+blacksquare=▪\n+blacktriangle=▴\n+blacktriangledown=▾\n+blacktriangleleft=◂\n+blacktriangleright=▸\n+blank=␣\n+blk12=▒\n+blk14=░\n+blk34=▓\n+block=█\n+bne==⃥\n+bnequiv=≡⃥\n+bNot=⫭\n+bnot=⌐\n+Bopf=𝔹\n+bopf=𝕓\n+bot=⊥\n+bottom=⊥\n+bowtie=⋈\n+boxbox=⧉\n+boxdl=┐\n+boxdL=╕\n+boxDl=╖\n+boxDL=╗\n+boxdr=┌\n+boxdR=╒\n+boxDr=╓\n+boxDR=╔\n+boxh=─\n+boxH=═\n+boxhd=┬\n+boxHd=╤\n+boxhD=╥\n+boxHD=╦\n+boxhu=┴\n+boxHu=╧\n+boxhU=╨\n+boxHU=╩\n+boxminus=⊟\n+boxplus=⊞\n+boxtimes=⊠\n+boxul=┘\n+boxuL=╛\n+boxUl=╜\n+boxUL=╝\n+boxur=└\n+boxuR=╘\n+boxUr=╙\n+boxUR=╚\n+boxv=│\n+boxV=║\n+boxvh=┼\n+boxvH=╪\n+boxVh=╫\n+boxVH=╬\n+boxvl=┤\n+boxvL=╡\n+boxVl=╢\n+boxVL=╣\n+boxvr=├\n+boxvR=╞\n+boxVr=╟\n+boxVR=╠\n+bprime=‵\n+breve=˘\n+Breve=˘\n+brvbar=¦\n+bscr=𝒷\n+Bscr=ℬ\n+bsemi=⁏\n+bsim=∽\n+bsime=⋍\n+bsolb=⧅\n+bsol=\\\n+bsolhsub=⟈\n+bull=•\n+bullet=•\n+bump=≎\n+bumpE=⪮\n+bumpe=≏\n+Bumpeq=≎\n+bumpeq=≏\n+Cacute=Ć\n+cacute=ć\n+capand=⩄\n+capbrcup=⩉\n+capcap=⩋\n+cap=∩\n+Cap=⋒\n+capcup=⩇\n+capdot=⩀\n+CapitalDifferentialD=ⅅ\n+caps=∩︀\n+caret=⁁\n+caron=ˇ\n+Cayleys=ℭ\n+ccaps=⩍\n+Ccaron=Č\n+ccaron=č\n+Ccedil=Ç\n+ccedil=ç\n+Ccirc=Ĉ\n+ccirc=ĉ\n+Cconint=∰\n+ccups=⩌\n+ccupssm=⩐\n+Cdot=Ċ\n+cdot=ċ\n+cedil=¸\n+Cedilla=¸\n+cemptyv=⦲\n+cent=¢\n+centerdot=·\n+CenterDot=·\n+cfr=𝔠\n+Cfr=ℭ\n+CHcy=Ч\n+chcy=ч\n+check=✓\n+checkmark=✓\n+Chi=Χ\n+chi=χ\n+circ=ˆ\n+circeq=≗\n+circlearrowleft=↺\n+circlearrowright=↻\n+circledast=⊛\n+circledcirc=⊚\n+circleddash=⊝\n+CircleDot=⊙\n+circledR=®\n+circledS=Ⓢ\n+CircleMinus=⊖\n+CirclePlus=⊕\n+CircleTimes=⊗\n+cir=○\n+cirE=⧃\n+cire=≗\n+cirfnint=⨐\n+cirmid=⫯\n+cirscir=⧂\n+ClockwiseContourIntegral=∲\n+CloseCurlyDoubleQuote=”\n+CloseCurlyQuote=’\n+clubs=♣\n+clubsuit=♣\n+colon=:\n+Colon=∷\n+Colone=⩴\n+colone=≔\n+coloneq=≔\n+comma=,\n+commat=@\n+comp=∁\n+compfn=∘\n+complement=∁\n+complexes=ℂ\n+cong=≅\n+congdot=⩭\n+Congruent=≡\n+conint=∮\n+Conint=∯\n+ContourIntegral=∮\n+copf=𝕔\n+Copf=ℂ\n+coprod=∐\n+Coproduct=∐\n+copy=©\n+COPY=©\n+copysr=℗\n+CounterClockwiseContourIntegral=∳\n+crarr=↵\n+cross=✗\n+Cross=⨯\n+Cscr=𝒞\n+cscr=𝒸\n+csub=⫏\n+csube=⫑\n+csup=⫐\n+csupe=⫒\n+ctdot=⋯\n+cudarrl=⤸\n+cudarrr=⤵\n+cuepr=⋞\n+cuesc=⋟\n+cularr=↶\n+cularrp=⤽\n+cupbrcap=⩈\n+cupcap=⩆\n+CupCap=≍\n+cup=∪\n+Cup=⋓\n+cupcup=⩊\n+cupdot=⊍\n+cupor=⩅\n+cups=∪︀\n+curarr=↷\n+curarrm=⤼\n+curlyeqprec=⋞\n+curlyeqsucc=⋟\n+curlyvee=⋎\n+curlywedge=⋏\n+curren=¤\n+curvearrowleft=↶\n+curvearrowright=↷\n+cuvee=⋎\n+cuwed=⋏\n+cwconint=∲\n+cwint=∱\n+cylcty=⌭\n+dagger=†\n+Dagger=‡\n+daleth=ℸ\n+darr=↓\n+Darr=↡\n+dArr=⇓\n+dash=‐\n+Dashv=⫤\n+dashv=⊣\n+dbkarow=⤏\n+dblac=˝\n+Dcaron=Ď\n+dcaron=ď\n+Dcy=Д\n+dcy=д\n+ddagger=‡\n+ddarr=⇊\n+DD=ⅅ\n+dd=ⅆ\n+DDotrahd=⤑\n+ddotseq=⩷\n+deg=°\n+Del=∇\n+Delta=Δ\n+delta=δ\n+demptyv=⦱\n+dfisht=⥿\n+Dfr=𝔇\n+dfr=𝔡\n+dHar=⥥\n+dharl=⇃\n+dharr=⇂\n+DiacriticalAcute=´\n+DiacriticalDot=˙\n+DiacriticalDoubleAcute=˝\n+DiacriticalGrave=`\n+DiacriticalTilde=˜\n+diam=⋄\n+diamond=⋄\n+Diamond=⋄\n+diamondsuit=♦\n+diams=♦\n+die=¨\n+DifferentialD=ⅆ\n+digamma=ϝ\n+disin=⋲\n+div=÷\n+divide=÷\n+divideontimes=⋇\n+divonx=⋇\n+DJcy=Ђ\n+djcy=ђ\n+dlcorn=⌞\n+dlcrop=⌍\n+dollar=$\n+Dopf=𝔻\n+dopf=𝕕\n+Dot=¨\n+dot=˙\n+DotDot=⃜\n+doteq=≐\n+doteqdot=≑\n+DotEqual=≐\n+dotminus=∸\n+dotplus=∔\n+dotsquare=⊡\n+doublebarwedge=⌆\n+DoubleContourIntegral=∯\n+DoubleDot=¨\n+DoubleDownArrow=⇓\n+DoubleLeftArrow=⇐\n+DoubleLeftRightArrow=⇔\n+DoubleLeftTee=⫤\n+DoubleLongLeftArrow=⟸\n+DoubleLongLeftRightArrow=⟺\n+DoubleLongRightArrow=⟹\n+DoubleRightArrow=⇒\n+DoubleRightTee=⊨\n+DoubleUpArrow=⇑\n+DoubleUpDownArrow=⇕\n+DoubleVerticalBar=∥\n+DownArrowBar=⤓\n+downarrow=↓\n+DownArrow=↓\n+Downarrow=⇓\n+DownArrowUpArrow=⇵\n+DownBreve=̑\n+downdownarrows=⇊\n+downharpoonleft=⇃\n+downharpoonright=⇂\n+DownLeftRightVector=⥐\n+DownLeftTeeVector=⥞\n+DownLeftVectorBar=⥖\n+DownLeftVector=↽\n+DownRightTeeVector=⥟\n+DownRightVectorBar=⥗\n+DownRightVector=⇁\n+DownTeeArrow=↧\n+DownTee=⊤\n+drbkarow=⤐\n+drcorn=⌟\n+drcrop=⌌\n+Dscr=𝒟\n+dscr=𝒹\n+DScy=Ѕ\n+dscy=ѕ\n+dsol=⧶\n+Dstrok=Đ\n+dstrok=đ\n+dtdot=⋱\n+dtri=▿\n+dtrif=▾\n+duarr=⇵\n+duhar=⥯\n+dwangle=⦦\n+DZcy=Џ\n+dzcy=џ\n+dzigrarr=⟿\n+Eacute=É\n+eacute=é\n+easter=⩮\n+Ecaron=Ě\n+ecaron=ě\n+Ecirc=Ê\n+ecirc=ê\n+ecir=≖\n+ecolon=≕\n+Ecy=Э\n+ecy=э\n+eDDot=⩷\n+Edot=Ė\n+edot=ė\n+eDot=≑\n+ee=ⅇ\n+efDot=≒\n+Efr=𝔈\n+efr=𝔢\n+eg=⪚\n+Egrave=È\n+egrave=è\n+egs=⪖\n+egsdot=⪘\n+el=⪙\n+Element=∈\n+elinters=⏧\n+ell=ℓ\n+els=⪕\n+elsdot=⪗\n+Emacr=Ē\n+emacr=ē\n+empty=∅\n+emptyset=∅\n+EmptySmallSquare=◻\n+emptyv=∅\n+EmptyVerySmallSquare=▫\n+emsp13= \n+emsp14= \n+emsp= \n+ENG=Ŋ\n+eng=ŋ\n+ensp= \n+Eogon=Ę\n+eogon=ę\n+Eopf=𝔼\n+eopf=𝕖\n+epar=⋕\n+eparsl=⧣\n+eplus=⩱\n+epsi=ε\n+Epsilon=Ε\n+epsilon=ε\n+epsiv=ϵ\n+eqcirc=≖\n+eqcolon=≕\n+eqsim=≂\n+eqslantgtr=⪖\n+eqslantless=⪕\n+Equal=⩵\n+equals==\n+EqualTilde=≂\n+equest=≟\n+Equilibrium=⇌\n+equiv=≡\n+equivDD=⩸\n+eqvparsl=⧥\n+erarr=⥱\n+erDot=≓\n+escr=ℯ\n+Escr=ℰ\n+esdot=≐\n+Esim=⩳\n+esim=≂\n+Eta=Η\n+eta=η\n+ETH=Ð\n+eth=ð\n+Euml=Ë\n+euml=ë\n+euro=€\n+excl=!\n+exist=∃\n+Exists=∃\n+expectation=ℰ\n+exponentiale=ⅇ\n+ExponentialE=ⅇ\n+fallingdotseq=≒\n+Fcy=Ф\n+fcy=ф\n+female=♀\n+ffilig=ﬃ\n+fflig=ﬀ\n+ffllig=ﬄ\n+Ffr=𝔉\n+ffr=𝔣\n+filig=ﬁ\n+FilledSmallSquare=◼\n+FilledVerySmallSquare=▪\n+fjlig=fj\n+flat=♭\n+fllig=ﬂ\n+fltns=▱\n+fnof=ƒ\n+Fopf=𝔽\n+fopf=𝕗\n+forall=∀\n+ForAll=∀\n+fork=⋔\n+forkv=⫙\n+Fouriertrf=ℱ\n+fpartint=⨍\n+frac12=½\n+frac13=⅓\n+frac14=¼\n+frac15=⅕\n+frac16=⅙\n+frac18=⅛\n+frac23=⅔\n+frac25=⅖\n+frac34=¾\n+frac35=⅗\n+frac38=⅜\n+frac45=⅘\n+frac56=⅚\n+frac58=⅝\n+frac78=⅞\n+frasl=⁄\n+frown=⌢\n+fscr=𝒻\n+Fscr=ℱ\n+gacute=ǵ\n+Gamma=Γ\n+gamma=γ\n+Gammad=Ϝ\n+gammad=ϝ\n+gap=⪆\n+Gbreve=Ğ\n+gbreve=ğ\n+Gcedil=Ģ\n+Gcirc=Ĝ\n+gcirc=ĝ\n+Gcy=Г\n+gcy=г\n+Gdot=Ġ\n+gdot=ġ\n+ge=≥\n+gE=≧\n+gEl=⪌\n+gel=⋛\n+geq=≥\n+geqq=≧\n+geqslant=⩾\n+gescc=⪩\n+ges=⩾\n+gesdot=⪀\n+gesdoto=⪂\n+gesdotol=⪄\n+gesl=⋛︀\n+gesles=⪔\n+Gfr=𝔊\n+gfr=𝔤\n+gg=≫\n+Gg=⋙\n+ggg=⋙\n+gimel=ℷ\n+GJcy=Ѓ\n+gjcy=ѓ\n+gla=⪥\n+gl=≷\n+glE=⪒\n+glj=⪤\n+gnap=⪊\n+gnapprox=⪊\n+gne=⪈\n+gnE=≩\n+gneq=⪈\n+gneqq=≩\n+gnsim=⋧\n+Gopf=𝔾\n+gopf=𝕘\n+grave=`\n+GreaterEqual=≥\n+GreaterEqualLess=⋛\n+GreaterFullEqual=≧\n+GreaterGreater=⪢\n+GreaterLess=≷\n+GreaterSlantEqual=⩾\n+GreaterTilde=≳\n+Gscr=𝒢\n+gscr=ℊ\n+gsim=≳\n+gsime=⪎\n+gsiml=⪐\n+gtcc=⪧\n+gtcir=⩺\n+gt=>\n+GT=>\n+Gt=≫\n+gtdot=⋗\n+gtlPar=⦕\n+gtquest=⩼\n+gtrapprox=⪆\n+gtrarr=⥸\n+gtrdot=⋗\n+gtreqless=⋛\n+gtreqqless=⪌\n+gtrless=≷\n+gtrsim=≳\n+gvertneqq=≩︀\n+gvnE=≩︀\n+Hacek=ˇ\n+hairsp= \n+half=½\n+hamilt=ℋ\n+HARDcy=Ъ\n+hardcy=ъ\n+harrcir=⥈\n+harr=↔\n+hArr=⇔\n+harrw=↭\n+Hat=^\n+hbar=ℏ\n+Hcirc=Ĥ\n+hcirc=ĥ\n+hearts=♥\n+heartsuit=♥\n+hellip=…\n+hercon=⊹\n+hfr=𝔥\n+Hfr=ℌ\n+HilbertSpace=ℋ\n+hksearow=⤥\n+hkswarow=⤦\n+hoarr=⇿\n+homtht=∻\n+hookleftarrow=↩\n+hookrightarrow=↪\n+hopf=𝕙\n+Hopf=ℍ\n+horbar=―\n+HorizontalLine=─\n+hscr=𝒽\n+Hscr=ℋ\n+hslash=ℏ\n+Hstrok=Ħ\n+hstrok=ħ\n+HumpDownHump=≎\n+HumpEqual=≏\n+hybull=⁃\n+hyphen=‐\n+Iacute=Í\n+iacute=í\n+ic=⁣\n+Icirc=Î\n+icirc=î\n+Icy=И\n+icy=и\n+Idot=İ\n+IEcy=Е\n+iecy=е\n+iexcl=¡\n+iff=⇔\n+ifr=𝔦\n+Ifr=ℑ\n+Igrave=Ì\n+igrave=ì\n+ii=ⅈ\n+iiiint=⨌\n+iiint=∭\n+iinfin=⧜\n+iiota=℩\n+IJlig=Ĳ\n+ijlig=ĳ\n+Imacr=Ī\n+imacr=ī\n+image=ℑ\n+ImaginaryI=ⅈ\n+imagline=ℐ\n+imagpart=ℑ\n+imath=ı\n+Im=ℑ\n+imof=⊷\n+imped=Ƶ\n+Implies=⇒\n+incare=℅\n+in=∈\n+infin=∞\n+infintie=⧝\n+inodot=ı\n+intcal=⊺\n+int=∫\n+Int=∬\n+integers=ℤ\n+Integral=∫\n+intercal=⊺\n+Intersection=⋂\n+intlarhk=⨗\n+intprod=⨼\n+InvisibleComma=⁣\n+InvisibleTimes=⁢\n+IOcy=Ё\n+iocy=ё\n+Iogon=Į\n+iogon=į\n+Iopf=𝕀\n+iopf=𝕚\n+Iota=Ι\n+iota=ι\n+iprod=⨼\n+iquest=¿\n+iscr=𝒾\n+Iscr=ℐ\n+isin=∈\n+isindot=⋵\n+isinE=⋹\n+isins=⋴\n+isinsv=⋳\n+isinv=∈\n+it=⁢\n+Itilde=Ĩ\n+itilde=ĩ\n+Iukcy=І\n+iukcy=і\n+Iuml=Ï\n+iuml=ï\n+Jcirc=Ĵ\n+jcirc=ĵ\n+Jcy=Й\n+jcy=й\n+Jfr=𝔍\n+jfr=𝔧\n+jmath=ȷ\n+Jopf=𝕁\n+jopf=𝕛\n+Jscr=𝒥\n+jscr=𝒿\n+Jsercy=Ј\n+jsercy=ј\n+Jukcy=Є\n+jukcy=є\n+Kappa=Κ\n+kappa=κ\n+kappav=ϰ\n+Kcedil=Ķ\n+kcedil=ķ\n+Kcy=К\n+kcy=к\n+Kfr=𝔎\n+kfr=𝔨\n+kgreen=ĸ\n+KHcy=Х\n+khcy=х\n+KJcy=Ќ\n+kjcy=ќ\n+Kopf=𝕂\n+kopf=𝕜\n+Kscr=𝒦\n+kscr=𝓀\n+lAarr=⇚\n+Lacute=Ĺ\n+lacute=ĺ\n+laemptyv=⦴\n+lagran=ℒ\n+Lambda=Λ\n+lambda=λ\n+lang=⟨\n+Lang=⟪\n+langd=⦑\n+langle=⟨\n+lap=⪅\n+Laplacetrf=ℒ\n+laquo=«\n+larrb=⇤\n+larrbfs=⤟\n+larr=←\n+Larr=↞\n+lArr=⇐\n+larrfs=⤝\n+larrhk=↩\n+larrlp=↫\n+larrpl=⤹\n+larrsim=⥳\n+larrtl=↢\n+latail=⤙\n+lAtail=⤛\n+lat=⪫\n+late=⪭\n+lates=⪭︀\n+lbarr=⤌\n+lBarr=⤎\n+lbbrk=❲\n+lbrace={\n+lbrack=[\n+lbrke=⦋\n+lbrksld=⦏\n+lbrkslu=⦍\n+Lcaron=Ľ\n+lcaron=ľ\n+Lcedil=Ļ\n+lcedil=ļ\n+lceil=⌈\n+lcub={\n+Lcy=Л\n+lcy=л\n+ldca=⤶\n+ldquo=“\n+ldquor=„\n+ldrdhar=⥧\n+ldrushar=⥋\n+ldsh=↲\n+le=≤\n+lE=≦\n+LeftAngleBracket=⟨\n+LeftArrowBar=⇤\n+leftarrow=←\n+LeftArrow=←\n+Leftarrow=⇐\n+LeftArrowRightArrow=⇆\n+leftarrowtail=↢\n+LeftCeiling=⌈\n+LeftDoubleBracket=⟦\n+LeftDownTeeVector=⥡\n+LeftDownVectorBar=⥙\n+LeftDownVector=⇃\n+LeftFloor=⌊\n+leftharpoondown=↽\n+leftharpoonup=↼\n+leftleftarrows=⇇\n+leftrightarrow=↔\n+LeftRightArrow=↔\n+Leftrightarrow=⇔\n+leftrightarrows=⇆\n+leftrightharpoons=⇋\n+leftrightsquigarrow=↭\n+LeftRightVector=⥎\n+LeftTeeArrow=↤\n+LeftTee=⊣\n+LeftTeeVector=⥚\n+leftthreetimes=⋋\n+LeftTriangleBar=⧏\n+LeftTriangle=⊲\n+LeftTriangleEqual=⊴\n+LeftUpDownVector=⥑\n+LeftUpTeeVector=⥠\n+LeftUpVectorBar=⥘\n+LeftUpVector=↿\n+LeftVectorBar=⥒\n+LeftVector=↼\n+lEg=⪋\n+leg=⋚\n+leq=≤\n+leqq=≦\n+leqslant=⩽\n+lescc=⪨\n+les=⩽\n+lesdot=⩿\n+lesdoto=⪁\n+lesdotor=⪃\n+lesg=⋚︀\n+lesges=⪓\n+lessapprox=⪅\n+lessdot=⋖\n+lesseqgtr=⋚\n+lesseqqgtr=⪋\n+LessEqualGreater=⋚\n+LessFullEqual=≦\n+LessGreater=≶\n+lessgtr=≶\n+LessLess=⪡\n+lesssim=≲\n+LessSlantEqual=⩽\n+LessTilde=≲\n+lfisht=⥼\n+lfloor=⌊\n+Lfr=𝔏\n+lfr=𝔩\n+lg=≶\n+lgE=⪑\n+lHar=⥢\n+lhard=↽\n+lharu=↼\n+lharul=⥪\n+lhblk=▄\n+LJcy=Љ\n+ljcy=љ\n+llarr=⇇\n+ll=≪\n+Ll=⋘\n+llcorner=⌞\n+Lleftarrow=⇚\n+llhard=⥫\n+lltri=◺\n+Lmidot=Ŀ\n+lmidot=ŀ\n+lmoustache=⎰\n+lmoust=⎰\n+lnap=⪉\n+lnapprox=⪉\n+lne=⪇\n+lnE=≨\n+lneq=⪇\n+lneqq=≨\n+lnsim=⋦\n+loang=⟬\n+loarr=⇽\n+lobrk=⟦\n+longleftarrow=⟵\n+LongLeftArrow=⟵\n+Longleftarrow=⟸\n+longleftrightarrow=⟷\n+LongLeftRightArrow=⟷\n+Longleftrightarrow=⟺\n+longmapsto=⟼\n+longrightarrow=⟶\n+LongRightArrow=⟶\n+Longrightarrow=⟹\n+looparrowleft=↫\n+looparrowright=↬\n+lopar=⦅\n+Lopf=𝕃\n+lopf=𝕝\n+loplus=⨭\n+lotimes=⨴\n+lowast=∗\n+lowbar=_\n+LowerLeftArrow=↙\n+LowerRightArrow=↘\n+loz=◊\n+lozenge=◊\n+lozf=⧫\n+lpar=(\n+lparlt=⦓\n+lrarr=⇆\n+lrcorner=⌟\n+lrhar=⇋\n+lrhard=⥭\n+lrm=‎\n+lrtri=⊿\n+lsaquo=‹\n+lscr=𝓁\n+Lscr=ℒ\n+lsh=↰\n+Lsh=↰\n+lsim=≲\n+lsime=⪍\n+lsimg=⪏\n+lsqb=[\n+lsquo=‘\n+lsquor=‚\n+Lstrok=Ł\n+lstrok=ł\n+ltcc=⪦\n+ltcir=⩹\n+lt=<\n+LT=<\n+Lt=≪\n+ltdot=⋖\n+lthree=⋋\n+ltimes=⋉\n+ltlarr=⥶\n+ltquest=⩻\n+ltri=◃\n+ltrie=⊴\n+ltrif=◂\n+ltrPar=⦖\n+lurdshar=⥊\n+luruhar=⥦\n+lvertneqq=≨︀\n+lvnE=≨︀\n+macr=¯\n+male=♂\n+malt=✠\n+maltese=✠\n+Map=⤅\n+map=↦\n+mapsto=↦\n+mapstodown=↧\n+mapstoleft=↤\n+mapstoup=↥\n+marker=▮\n+mcomma=⨩\n+Mcy=М\n+mcy=м\n+mdash=—\n+mDDot=∺\n+measuredangle=∡\n+MediumSpace= \n+Mellintrf=ℳ\n+Mfr=𝔐\n+mfr=𝔪\n+mho=℧\n+micro=µ\n+midast=*\n+midcir=⫰\n+mid=∣\n+middot=·\n+minusb=⊟\n+minus=−\n+minusd=∸\n+minusdu=⨪\n+MinusPlus=∓\n+mlcp=⫛\n+mldr=…\n+mnplus=∓\n+models=⊧\n+Mopf=𝕄\n+mopf=𝕞\n+mp=∓\n+mscr=𝓂\n+Mscr=ℳ\n+mstpos=∾\n+Mu=Μ\n+mu=μ\n+multimap=⊸\n+mumap=⊸\n+nabla=∇\n+Nacute=Ń\n+nacute=ń\n+nang=∠⃒\n+nap=≉\n+napE=⩰̸\n+napid=≋̸\n+napos=ŉ\n+napprox=≉\n+natural=♮\n+naturals=ℕ\n+natur=♮\n+nbsp= \n+nbump=≎̸\n+nbumpe=≏̸\n+ncap=⩃\n+Ncaron=Ň\n+ncaron=ň\n+Ncedil=Ņ\n+ncedil=ņ\n+ncong=≇\n+ncongdot=⩭̸\n+ncup=⩂\n+Ncy=Н\n+ncy=н\n+ndash=–\n+nearhk=⤤\n+nearr=↗\n+neArr=⇗\n+nearrow=↗\n+ne=≠\n+nedot=≐̸\n+NegativeMediumSpace=​\n+NegativeThickSpace=​\n+NegativeThinSpace=​\n+NegativeVeryThinSpace=​\n+nequiv=≢\n+nesear=⤨\n+nesim=≂̸\n+NestedGreaterGreater=≫\n+NestedLessLess=≪\n+NewLine=\n+\n+nexist=∄\n+nexists=∄\n+Nfr=𝔑\n+nfr=𝔫\n+ngE=≧̸\n+nge=≱\n+ngeq=≱\n+ngeqq=≧̸\n+ngeqslant=⩾̸\n+nges=⩾̸\n+nGg=⋙̸\n+ngsim=≵\n+nGt=≫⃒\n+ngt=≯\n+ngtr=≯\n+nGtv=≫̸\n+nharr=↮\n+nhArr=⇎\n+nhpar=⫲\n+ni=∋\n+nis=⋼\n+nisd=⋺\n+niv=∋\n+NJcy=Њ\n+njcy=њ\n+nlarr=↚\n+nlArr=⇍\n+nldr=‥\n+nlE=≦̸\n+nle=≰\n+nleftarrow=↚\n+nLeftarrow=⇍\n+nleftrightarrow=↮\n+nLeftrightarrow=⇎\n+nleq=≰\n+nleqq=≦̸\n+nleqslant=⩽̸\n+nles=⩽̸\n+nless=≮\n+nLl=⋘̸\n+nlsim=≴\n+nLt=≪⃒\n+nlt=≮\n+nltri=⋪\n+nltrie=⋬\n+nLtv=≪̸\n+nmid=∤\n+NoBreak=⁠\n+NonBreakingSpace= \n+nopf=𝕟\n+Nopf=ℕ\n+Not=⫬\n+not=¬\n+NotCongruent=≢\n+NotCupCap=≭\n+NotDoubleVerticalBar=∦\n+NotElement=∉\n+NotEqual=≠\n+NotEqualTilde=≂̸\n+NotExists=∄\n+NotGreater=≯\n+NotGreaterEqual=≱\n+NotGreaterFullEqual=≧̸\n+NotGreaterGreater=≫̸\n+NotGreaterLess=≹\n+NotGreaterSlantEqual=⩾̸\n+NotGreaterTilde=≵\n+NotHumpDownHump=≎̸\n+NotHumpEqual=≏̸\n+notin=∉\n+notindot=⋵̸\n+notinE=⋹̸\n+notinva=∉\n+notinvb=⋷\n+notinvc=⋶\n+NotLeftTriangleBar=⧏̸\n+NotLeftTriangle=⋪\n+NotLeftTriangleEqual=⋬\n+NotLess=≮\n+NotLessEqual=≰\n+NotLessGreater=≸\n+NotLessLess=≪̸\n+NotLessSlantEqual=⩽̸\n+NotLessTilde=≴\n+NotNestedGreaterGreater=⪢̸\n+NotNestedLessLess=⪡̸\n+notni=∌\n+notniva=∌\n+notnivb=⋾\n+notnivc=⋽\n+NotPrecedes=⊀\n+NotPrecedesEqual=⪯̸\n+NotPrecedesSlantEqual=⋠\n+NotReverseElement=∌\n+NotRightTriangleBar=⧐̸\n+NotRightTriangle=⋫\n+NotRightTriangleEqual=⋭\n+NotSquareSubset=⊏̸\n+NotSquareSubsetEqual=⋢\n+NotSquareSuperset=⊐̸\n+NotSquareSupersetEqual=⋣\n+NotSubset=⊂⃒\n+NotSubsetEqual=⊈\n+NotSucceeds=⊁\n+NotSucceedsEqual=⪰̸\n+NotSucceedsSlantEqual=⋡\n+NotSucceedsTilde=≿̸\n+NotSuperset=⊃⃒\n+NotSupersetEqual=⊉\n+NotTilde=≁\n+NotTildeEqual=≄\n+NotTildeFullEqual=≇\n+NotTildeTilde=≉\n+NotVerticalBar=∤\n+nparallel=∦\n+npar=∦\n+nparsl=⫽⃥\n+npart=∂̸\n+npolint=⨔\n+npr=⊀\n+nprcue=⋠\n+nprec=⊀\n+npreceq=⪯̸\n+npre=⪯̸\n+nrarrc=⤳̸\n+nrarr=↛\n+nrArr=⇏\n+nrarrw=↝̸\n+nrightarrow=↛\n+nRightarrow=⇏\n+nrtri=⋫\n+nrtrie=⋭\n+nsc=⊁\n+nsccue=⋡\n+nsce=⪰̸\n+Nscr=𝒩\n+nscr=𝓃\n+nshortmid=∤\n+nshortparallel=∦\n+nsim=≁\n+nsime=≄\n+nsimeq=≄\n+nsmid=∤\n+nspar=∦\n+nsqsube=⋢\n+nsqsupe=⋣\n+nsub=⊄\n+nsubE=⫅̸\n+nsube=⊈\n+nsubset=⊂⃒\n+nsubseteq=⊈\n+nsubseteqq=⫅̸\n+nsucc=⊁\n+nsucceq=⪰̸\n+nsup=⊅\n+nsupE=⫆̸\n+nsupe=⊉\n+nsupset=⊃⃒\n+nsupseteq=⊉\n+nsupseteqq=⫆̸\n+ntgl=≹\n+Ntilde=Ñ\n+ntilde=ñ\n+ntlg=≸\n+ntriangleleft=⋪\n+ntrianglelefteq=⋬\n+ntriangleright=⋫\n+ntrianglerighteq=⋭\n+Nu=Ν\n+nu=ν\n+num=#\n+numero=№\n+numsp= \n+nvap=≍⃒\n+nvdash=⊬\n+nvDash=⊭\n+nVdash=⊮\n+nVDash=⊯\n+nvge=≥⃒\n+nvgt=>⃒\n+nvHarr=⤄\n+nvinfin=⧞\n+nvlArr=⤂\n+nvle=≤⃒\n+nvlt=<⃒\n+nvltrie=⊴⃒\n+nvrArr=⤃\n+nvrtrie=⊵⃒\n+nvsim=∼⃒\n+nwarhk=⤣\n+nwarr=↖\n+nwArr=⇖\n+nwarrow=↖\n+nwnear=⤧\n+Oacute=Ó\n+oacute=ó\n+oast=⊛\n+Ocirc=Ô\n+ocirc=ô\n+ocir=⊚\n+Ocy=О\n+ocy=о\n+odash=⊝\n+Odblac=Ő\n+odblac=ő\n+odiv=⨸\n+odot=⊙\n+odsold=⦼\n+OElig=Œ\n+oelig=œ\n+ofcir=⦿\n+Ofr=𝔒\n+ofr=𝔬\n+ogon=˛\n+Ograve=Ò\n+ograve=ò\n+ogt=⧁\n+ohbar=⦵\n+ohm=Ω\n+oint=∮\n+olarr=↺\n+olcir=⦾\n+olcross=⦻\n+oline=‾\n+olt=⧀\n+Omacr=Ō\n+omacr=ō\n+Omega=Ω\n+omega=ω\n+Omicron=Ο\n+omicron=ο\n+omid=⦶\n+ominus=⊖\n+Oopf=𝕆\n+oopf=𝕠\n+opar=⦷\n+OpenCurlyDoubleQuote=“\n+OpenCurlyQuote=‘\n+operp=⦹\n+oplus=⊕\n+orarr=↻\n+Or=⩔\n+or=∨\n+ord=⩝\n+order=ℴ\n+orderof=ℴ\n+ordf=ª\n+ordm=º\n+origof=⊶\n+oror=⩖\n+orslope=⩗\n+orv=⩛\n+oS=Ⓢ\n+Oscr=𝒪\n+oscr=ℴ\n+Oslash=Ø\n+oslash=ø\n+osol=⊘\n+Otilde=Õ\n+otilde=õ\n+otimesas=⨶\n+Otimes=⨷\n+otimes=⊗\n+Ouml=Ö\n+ouml=ö\n+ovbar=⌽\n+OverBar=‾\n+OverBrace=⏞\n+OverBracket=⎴\n+OverParenthesis=⏜\n+para=¶\n+parallel=∥\n+par=∥\n+parsim=⫳\n+parsl=⫽\n+part=∂\n+PartialD=∂\n+Pcy=П\n+pcy=п\n+percnt=%\n+period=.\n+permil=‰\n+perp=⊥\n+pertenk=‱\n+Pfr=𝔓\n+pfr=𝔭\n+Phi=Φ\n+phi=φ\n+phiv=ϕ\n+phmmat=ℳ\n+phone=☎\n+Pi=Π\n+pi=π\n+pitchfork=⋔\n+piv=ϖ\n+planck=ℏ\n+planckh=ℎ\n+plankv=ℏ\n+plusacir=⨣\n+plusb=⊞\n+pluscir=⨢\n+plus=+\n+plusdo=∔\n+plusdu=⨥\n+pluse=⩲\n+PlusMinus=±\n+plusmn=±\n+plussim=⨦\n+plustwo=⨧\n+pm=±\n+Poincareplane=ℌ\n+pointint=⨕\n+popf=𝕡\n+Popf=ℙ\n+pound=£\n+prap=⪷\n+Pr=⪻\n+pr=≺\n+prcue=≼\n+precapprox=⪷\n+prec=≺\n+preccurlyeq=≼\n+Precedes=≺\n+PrecedesEqual=⪯\n+PrecedesSlantEqual=≼\n+PrecedesTilde=≾\n+preceq=⪯\n+precnapprox=⪹\n+precneqq=⪵\n+precnsim=⋨\n+pre=⪯\n+prE=⪳\n+precsim=≾\n+prime=′\n+Prime=″\n+primes=ℙ\n+prnap=⪹\n+prnE=⪵\n+prnsim=⋨\n+prod=∏\n+Product=∏\n+profalar=⌮\n+profline=⌒\n+profsurf=⌓\n+prop=∝\n+Proportional=∝\n+Proportion=∷\n+propto=∝\n+prsim=≾\n+prurel=⊰\n+Pscr=𝒫\n+pscr=𝓅\n+Psi=Ψ\n+psi=ψ\n+puncsp= \n+Qfr=𝔔\n+qfr=𝔮\n+qint=⨌\n+qopf=𝕢\n+Qopf=ℚ\n+qprime=⁗\n+Qscr=𝒬\n+qscr=𝓆\n+quaternions=ℍ\n+quatint=⨖\n+quest=?\n+questeq=≟\n+quot=\"\n+QUOT=\"\n+rAarr=⇛\n+race=∽̱\n+Racute=Ŕ\n+racute=ŕ\n+radic=√\n+raemptyv=⦳\n+rang=⟩\n+Rang=⟫\n+rangd=⦒\n+range=⦥\n+rangle=⟩\n+raquo=»\n+rarrap=⥵\n+rarrb=⇥\n+rarrbfs=⤠\n+rarrc=⤳\n+rarr=→\n+Rarr=↠\n+rArr=⇒\n+rarrfs=⤞\n+rarrhk=↪\n+rarrlp=↬\n+rarrpl=⥅\n+rarrsim=⥴\n+Rarrtl=⤖\n+rarrtl=↣\n+rarrw=↝\n+ratail=⤚\n+rAtail=⤜\n+ratio=∶\n+rationals=ℚ\n+rbarr=⤍\n+rBarr=⤏\n+RBarr=⤐\n+rbbrk=❳\n+rbrace=}\n+rbrack=]\n+rbrke=⦌\n+rbrksld=⦎\n+rbrkslu=⦐\n+Rcaron=Ř\n+rcaron=ř\n+Rcedil=Ŗ\n+rcedil=ŗ\n+rceil=⌉\n+rcub=}\n+Rcy=Р\n+rcy=р\n+rdca=⤷\n+rdldhar=⥩\n+rdquo=”\n+rdquor=”\n+rdsh=↳\n+real=ℜ\n+realine=ℛ\n+realpart=ℜ\n+reals=ℝ\n+Re=ℜ\n+rect=▭\n+reg=®\n+REG=®\n+ReverseElement=∋\n+ReverseEquilibrium=⇋\n+ReverseUpEquilibrium=⥯\n+rfisht=⥽\n+rfloor=⌋\n+rfr=𝔯\n+Rfr=ℜ\n+rHar=⥤\n+rhard=⇁\n+rharu=⇀\n+rharul=⥬\n+Rho=Ρ\n+rho=ρ\n+rhov=ϱ\n+RightAngleBracket=⟩\n+RightArrowBar=⇥\n+rightarrow=→\n+RightArrow=→\n+Rightarrow=⇒\n+RightArrowLeftArrow=⇄\n+rightarrowtail=↣\n+RightCeiling=⌉\n+RightDoubleBracket=⟧\n+RightDownTeeVector=⥝\n+RightDownVectorBar=⥕\n+RightDownVector=⇂\n+RightFloor=⌋\n+rightharpoondown=⇁\n+rightharpoonup=⇀\n+rightleftarrows=⇄\n+rightleftharpoons=⇌\n+rightrightarrows=⇉\n+rightsquigarrow=↝\n+RightTeeArrow=↦\n+RightTee=⊢\n+RightTeeVector=⥛\n+rightthreetimes=⋌\n+RightTriangleBar=⧐\n+RightTriangle=⊳\n+RightTriangleEqual=⊵\n+RightUpDownVector=⥏\n+RightUpTeeVector=⥜\n+RightUpVectorBar=⥔\n+RightUpVector=↾\n+RightVectorBar=⥓\n+RightVector=⇀\n+ring=˚\n+risingdotseq=≓\n+rlarr=⇄\n+rlhar=⇌\n+rlm=‏\n+rmoustache=⎱\n+rmoust=⎱\n+rnmid=⫮\n+roang=⟭\n+roarr=⇾\n+robrk=⟧\n+ropar=⦆\n+ropf=𝕣\n+Ropf=ℝ\n+roplus=⨮\n+rotimes=⨵\n+RoundImplies=⥰\n+rpar=)\n+rpargt=⦔\n+rppolint=⨒\n+rrarr=⇉\n+Rrightarrow=⇛\n+rsaquo=›\n+rscr=𝓇\n+Rscr=ℛ\n+rsh=↱\n+Rsh=↱\n+rsqb=]\n+rsquo=’\n+rsquor=’\n+rthree=⋌\n+rtimes=⋊\n+rtri=▹\n+rtrie=⊵\n+rtrif=▸\n+rtriltri=⧎\n+RuleDelayed=⧴\n+ruluhar=⥨\n+rx=℞\n+Sacute=Ś\n+sacute=ś\n+sbquo=‚\n+scap=⪸\n+Scaron=Š\n+scaron=š\n+Sc=⪼\n+sc=≻\n+sccue=≽\n+sce=⪰\n+scE=⪴\n+Scedil=Ş\n+scedil=ş\n+Scirc=Ŝ\n+scirc=ŝ\n+scnap=⪺\n+scnE=⪶\n+scnsim=⋩\n+scpolint=⨓\n+scsim=≿\n+Scy=С\n+scy=с\n+sdotb=⊡\n+sdot=⋅\n+sdote=⩦\n+searhk=⤥\n+searr=↘\n+seArr=⇘\n+searrow=↘\n+sect=§\n+semi=;\n+seswar=⤩\n+setminus=∖\n+setmn=∖\n+sext=✶\n+Sfr=𝔖\n+sfr=𝔰\n+sfrown=⌢\n+sharp=♯\n+SHCHcy=Щ\n+shchcy=щ\n+SHcy=Ш\n+shcy=ш\n+ShortDownArrow=↓\n+ShortLeftArrow=←\n+shortmid=∣\n+shortparallel=∥\n+ShortRightArrow=→\n+ShortUpArrow=↑\n+shy=­\n+Sigma=Σ\n+sigma=σ\n+sigmaf=ς\n+sigmav=ς\n+sim=∼\n+simdot=⩪\n+sime=≃\n+simeq=≃\n+simg=⪞\n+simgE=⪠\n+siml=⪝\n+simlE=⪟\n+simne=≆\n+simplus=⨤\n+simrarr=⥲\n+slarr=←\n+SmallCircle=∘\n+smallsetminus=∖\n+smashp=⨳\n+smeparsl=⧤\n+smid=∣\n+smile=⌣\n+smt=⪪\n+smte=⪬\n+smtes=⪬︀\n+SOFTcy=Ь\n+softcy=ь\n+solbar=⌿\n+solb=⧄\n+sol=\/\n+Sopf=𝕊\n+sopf=𝕤\n+spades=♠\n+spadesuit=♠\n+spar=∥\n+sqcap=⊓\n+sqcaps=⊓︀\n+sqcup=⊔\n+sqcups=⊔︀\n+Sqrt=√\n+sqsub=⊏\n+sqsube=⊑\n+sqsubset=⊏\n+sqsubseteq=⊑\n+sqsup=⊐\n+sqsupe=⊒\n+sqsupset=⊐\n+sqsupseteq=⊒\n+square=□\n+Square=□\n+SquareIntersection=⊓\n+SquareSubset=⊏\n+SquareSubsetEqual=⊑\n+SquareSuperset=⊐\n+SquareSupersetEqual=⊒\n+SquareUnion=⊔\n+squarf=▪\n+squ=□\n+squf=▪\n+srarr=→\n+Sscr=𝒮\n+sscr=𝓈\n+ssetmn=∖\n+ssmile=⌣\n+sstarf=⋆\n+Star=⋆\n+star=☆\n+starf=★\n+straightepsilon=ϵ\n+straightphi=ϕ\n+strns=¯\n+sub=⊂\n+Sub=⋐\n+subdot=⪽\n+subE=⫅\n+sube=⊆\n+subedot=⫃\n+submult=⫁\n+subnE=⫋\n+subne=⊊\n+subplus=⪿\n+subrarr=⥹\n+subset=⊂\n+Subset=⋐\n+subseteq=⊆\n+subseteqq=⫅\n+SubsetEqual=⊆\n+subsetneq=⊊\n+subsetneqq=⫋\n+subsim=⫇\n+subsub=⫕\n+subsup=⫓\n+succapprox=⪸\n+succ=≻\n+succcurlyeq=≽\n+Succeeds=≻\n+SucceedsEqual=⪰\n+SucceedsSlantEqual=≽\n+SucceedsTilde=≿\n+succeq=⪰\n+succnapprox=⪺\n+succneqq=⪶\n+succnsim=⋩\n+succsim=≿\n+SuchThat=∋\n+sum=∑\n+Sum=∑\n+sung=♪\n+sup1=¹\n+sup2=²\n+sup3=³\n+sup=⊃\n+Sup=⋑\n+supdot=⪾\n+supdsub=⫘\n+supE=⫆\n+supe=⊇\n+supedot=⫄\n+Superset=⊃\n+SupersetEqual=⊇\n+suphsol=⟉\n+suphsub=⫗\n+suplarr=⥻\n+supmult=⫂\n+supnE=⫌\n+supne=⊋\n+supplus=⫀\n+supset=⊃\n+Supset=⋑\n+supseteq=⊇\n+supseteqq=⫆\n+supsetneq=⊋\n+supsetneqq=⫌\n+supsim=⫈\n+supsub=⫔\n+supsup=⫖\n+swarhk=⤦\n+swarr=↙\n+swArr=⇙\n+swarrow=↙\n+swnwar=⤪\n+szlig=ß\n+Tab=\t\n+target=⌖\n+Tau=Τ\n+tau=τ\n+tbrk=⎴\n+Tcaron=Ť\n+tcaron=ť\n+Tcedil=Ţ\n+tcedil=ţ\n+Tcy=Т\n+tcy=т\n+tdot=⃛\n+telrec=⌕\n+Tfr=𝔗\n+tfr=𝔱\n+there4=∴\n+therefore=∴\n+Therefore=∴\n+Theta=Θ\n+theta=θ\n+thetasym=ϑ\n+thetav=ϑ\n+thickapprox=≈\n+thicksim=∼\n+ThickSpace=  \n+ThinSpace= \n+thinsp= \n+thkap=≈\n+thksim=∼\n+THORN=Þ\n+thorn=þ\n+tilde=˜\n+Tilde=∼\n+TildeEqual=≃\n+TildeFullEqual=≅\n+TildeTilde=≈\n+timesbar=⨱\n+timesb=⊠\n+times=×\n+timesd=⨰\n+tint=∭\n+toea=⤨\n+topbot=⌶\n+topcir=⫱\n+top=⊤\n+Topf=𝕋\n+topf=𝕥\n+topfork=⫚\n+tosa=⤩\n+tprime=‴\n+trade=™\n+TRADE=™\n+triangle=▵\n+triangledown=▿\n+triangleleft=◃\n+trianglelefteq=⊴\n+triangleq=≜\n+triangleright=▹\n+trianglerighteq=⊵\n+tridot=◬\n+trie=≜\n+triminus=⨺\n+TripleDot=⃛\n+triplus=⨹\n+trisb=⧍\n+tritime=⨻\n+trpezium=⏢\n+Tscr=𝒯\n+tscr=𝓉\n+TScy=Ц\n+tscy=ц\n+TSHcy=Ћ\n+tshcy=ћ\n+Tstrok=Ŧ\n+tstrok=ŧ\n+twixt=≬\n+twoheadleftarrow=↞\n+twoheadrightarrow=↠\n+Uacute=Ú\n+uacute=ú\n+uarr=↑\n+Uarr=↟\n+uArr=⇑\n+Uarrocir=⥉\n+Ubrcy=Ў\n+ubrcy=ў\n+Ubreve=Ŭ\n+ubreve=ŭ\n+Ucirc=Û\n+ucirc=û\n+Ucy=У\n+ucy=у\n+udarr=⇅\n+Udblac=Ű\n+udblac=ű\n+udhar=⥮\n+ufisht=⥾\n+Ufr=𝔘\n+ufr=𝔲\n+Ugrave=Ù\n+ugrave=ù\n+uHar=⥣\n+uharl=↿\n+uharr=↾\n+uhblk=▀\n+ulcorn=⌜\n+ulcorner=⌜\n+ulcrop=⌏\n+ultri=◸\n+Umacr=Ū\n+umacr=ū\n+uml=¨\n+UnderBar=_\n+UnderBrace=⏟\n+UnderBracket=⎵\n+UnderParenthesis=⏝\n+Union=⋃\n+UnionPlus=⊎\n+Uogon=Ų\n+uogon=ų\n+Uopf=𝕌\n+uopf=𝕦\n+UpArrowBar=⤒\n+uparrow=↑\n+UpArrow=↑\n+Uparrow=⇑\n+UpArrowDownArrow=⇅\n+updownarrow=↕\n+UpDownArrow=↕\n+Updownarrow=⇕\n+UpEquilibrium=⥮\n+upharpoonleft=↿\n+upharpoonright=↾\n+uplus=⊎\n+UpperLeftArrow=↖\n+UpperRightArrow=↗\n+upsi=υ\n+Upsi=ϒ\n+upsih=ϒ\n+Upsilon=Υ\n+upsilon=υ\n+UpTeeArrow=↥\n+UpTee=⊥\n+upuparrows=⇈\n+urcorn=⌝\n+urcorner=⌝\n+urcrop=⌎\n+Uring=Ů\n+uring=ů\n+urtri=◹\n+Uscr=𝒰\n+uscr=𝓊\n+utdot=⋰\n+Utilde=Ũ\n+utilde=ũ\n+utri=▵\n+utrif=▴\n+uuarr=⇈\n+Uuml=Ü\n+uuml=ü\n+uwangle=⦧\n+vangrt=⦜\n+varepsilon=ϵ\n+varkappa=ϰ\n+varnothing=∅\n+varphi=ϕ\n+varpi=ϖ\n+varpropto=∝\n+varr=↕\n+vArr=⇕\n+varrho=ϱ\n+varsigma=ς\n+varsubsetneq=⊊︀\n+varsubsetneqq=⫋︀\n+varsupsetneq=⊋︀\n+varsupsetneqq=⫌︀\n+vartheta=ϑ\n+vartriangleleft=⊲\n+vartriangleright=⊳\n+vBar=⫨\n+Vbar=⫫\n+vBarv=⫩\n+Vcy=В\n+vcy=в\n+vdash=⊢\n+vDash=⊨\n+Vdash=⊩\n+VDash=⊫\n+Vdashl=⫦\n+veebar=⊻\n+vee=∨\n+Vee=⋁\n+veeeq=≚\n+vellip=⋮\n+verbar=|\n+Verbar=‖\n+vert=|\n+Vert=‖\n+VerticalBar=∣\n+VerticalLine=|\n+VerticalSeparator=❘\n+VerticalTilde=≀\n+VeryThinSpace= \n+Vfr=𝔙\n+vfr=𝔳\n+vltri=⊲\n+vnsub=⊂⃒\n+vnsup=⊃⃒\n+Vopf=𝕍\n+vopf=𝕧\n+vprop=∝\n+vrtri=⊳\n+Vscr=𝒱\n+vscr=𝓋\n+vsubnE=⫋︀\n+vsubne=⊊︀\n+vsupnE=⫌︀\n+vsupne=⊋︀\n+Vvdash=⊪\n+vzigzag=⦚\n+Wcirc=Ŵ\n+wcirc=ŵ\n+wedbar=⩟\n+wedge=∧\n+Wedge=⋀\n+wedgeq=≙\n+weierp=℘\n+Wfr=𝔚\n+wfr=𝔴\n+Wopf=𝕎\n+wopf=𝕨\n+wp=℘\n+wr=≀\n+wreath=≀\n+Wscr=𝒲\n+wscr=𝓌\n+xcap=⋂\n+xcirc=◯\n+xcup=⋃\n+xdtri=▽\n+Xfr=𝔛\n+xfr=𝔵\n+xharr=⟷\n+xhArr=⟺\n+Xi=Ξ\n+xi=ξ\n+xlarr=⟵\n+xlArr=⟸\n+xmap=⟼\n+xnis=⋻\n+xodot=⨀\n+Xopf=𝕏\n+xopf=𝕩\n+xoplus=⨁\n+xotime=⨂\n+xrarr=⟶\n+xrArr=⟹\n+Xscr=𝒳\n+xscr=𝓍\n+xsqcup=⨆\n+xuplus=⨄\n+xutri=△\n+xvee=⋁\n+xwedge=⋀\n+Yacute=Ý\n+yacute=ý\n+YAcy=Я\n+yacy=я\n+Ycirc=Ŷ\n+ycirc=ŷ\n+Ycy=Ы\n+ycy=ы\n+yen=¥\n+Yfr=𝔜\n+yfr=𝔶\n+YIcy=Ї\n+yicy=ї\n+Yopf=𝕐\n+yopf=𝕪\n+Yscr=𝒴\n+yscr=𝓎\n+YUcy=Ю\n+yucy=ю\n+yuml=ÿ\n+Yuml=Ÿ\n+Zacute=Ź\n+zacute=ź\n+Zcaron=Ž\n+zcaron=ž\n+Zcy=З\n+zcy=з\n+Zdot=Ż\n+zdot=ż\n+zeetrf=ℨ\n+ZeroWidthSpace=​\n+Zeta=Ζ\n+zeta=ζ\n+zfr=𝔷\n+Zfr=ℨ\n+ZHcy=Ж\n+zhcy=ж\n+zigrarr=⇝\n+zopf=𝕫\n+Zopf=ℤ\n+Zscr=𝒵\n+zscr=𝓏\n+zwj=‍\n+zwnj=‌\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/entities.txt","additions":2126,"deletions":0,"binary":false,"changes":2126,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * Abstract visitor that visits all children by default.\n+ * <p>\n+ * Can be used to only process certain nodes. If you override a method and want visiting to descend into children,\n+ * call {@link #visitChildren}.\n+ *\/\n+public abstract class AbstractVisitor implements Visitor {\n+\n+    @Override\n+    public void visit(BlockQuote blockQuote) {\n+        visitChildren(blockQuote);\n+    }\n+\n+    @Override\n+    public void visit(BulletList bulletList) {\n+        visitChildren(bulletList);\n+    }\n+\n+    @Override\n+    public void visit(Code code) {\n+        visitChildren(code);\n+    }\n+\n+    @Override\n+    public void visit(Document document) {\n+        visitChildren(document);\n+    }\n+\n+    @Override\n+    public void visit(Emphasis emphasis) {\n+        visitChildren(emphasis);\n+    }\n+\n+    @Override\n+    public void visit(FencedCodeBlock fencedCodeBlock) {\n+        visitChildren(fencedCodeBlock);\n+    }\n+\n+    @Override\n+    public void visit(HardLineBreak hardLineBreak) {\n+        visitChildren(hardLineBreak);\n+    }\n+\n+    @Override\n+    public void visit(Heading heading) {\n+        visitChildren(heading);\n+    }\n+\n+    @Override\n+    public void visit(ThematicBreak thematicBreak) {\n+        visitChildren(thematicBreak);\n+    }\n+\n+    @Override\n+    public void visit(HtmlInline htmlInline) {\n+        visitChildren(htmlInline);\n+    }\n+\n+    @Override\n+    public void visit(HtmlBlock htmlBlock) {\n+        visitChildren(htmlBlock);\n+    }\n+\n+    @Override\n+    public void visit(Image image) {\n+        visitChildren(image);\n+    }\n+\n+    @Override\n+    public void visit(IndentedCodeBlock indentedCodeBlock) {\n+        visitChildren(indentedCodeBlock);\n+    }\n+\n+    @Override\n+    public void visit(Link link) {\n+        visitChildren(link);\n+    }\n+\n+    @Override\n+    public void visit(ListItem listItem) {\n+        visitChildren(listItem);\n+    }\n+\n+    @Override\n+    public void visit(OrderedList orderedList) {\n+        visitChildren(orderedList);\n+    }\n+\n+    @Override\n+    public void visit(Paragraph paragraph) {\n+        visitChildren(paragraph);\n+    }\n+\n+    @Override\n+    public void visit(SoftLineBreak softLineBreak) {\n+        visitChildren(softLineBreak);\n+    }\n+\n+    @Override\n+    public void visit(StrongEmphasis strongEmphasis) {\n+        visitChildren(strongEmphasis);\n+    }\n+\n+    @Override\n+    public void visit(Text text) {\n+        visitChildren(text);\n+    }\n+\n+    @Override\n+    public void visit(LinkReferenceDefinition linkReferenceDefinition) {\n+        visitChildren(linkReferenceDefinition);\n+    }\n+\n+    @Override\n+    public void visit(CustomBlock customBlock) {\n+        visitChildren(customBlock);\n+    }\n+\n+    @Override\n+    public void visit(CustomNode customNode) {\n+        visitChildren(customNode);\n+    }\n+\n+    \/**\n+     * Visit the child nodes.\n+     *\n+     * @param parent the parent node whose children should be visited\n+     *\/\n+    protected void visitChildren(Node parent) {\n+        Node node = parent.getFirstChild();\n+        while (node != null) {\n+            \/\/ A subclass of this visitor might modify the node, resulting in getNext returning a different node or no\n+            \/\/ node after visiting it. So get the next node before visiting.\n+            Node next = node.getNext();\n+            node.accept(this);\n+            node = next;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/AbstractVisitor.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * Block nodes such as paragraphs, list blocks, code blocks etc.\n+ *\/\n+public abstract class Block extends Node {\n+\n+    public Block getParent() {\n+        return (Block) super.getParent();\n+    }\n+\n+    @Override\n+    protected void setParent(Node parent) {\n+        if (!(parent instanceof Block)) {\n+            throw new IllegalArgumentException(\"Parent of block must also be block (can not be inline)\");\n+        }\n+        super.setParent(parent);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Block.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class BlockQuote extends Block {\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/BlockQuote.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class BulletList extends ListBlock {\n+\n+    private char bulletMarker;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public char getBulletMarker() {\n+        return bulletMarker;\n+    }\n+\n+    public void setBulletMarker(char bulletMarker) {\n+        this.bulletMarker = bulletMarker;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/BulletList.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class Code extends Node {\n+\n+    private String literal;\n+\n+    public Code() {\n+    }\n+\n+    public Code(String literal) {\n+        this.literal = literal;\n+    }\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public String getLiteral() {\n+        return literal;\n+    }\n+\n+    public void setLiteral(String literal) {\n+        this.literal = literal;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Code.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public abstract class CustomBlock extends Block {\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/CustomBlock.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public abstract class CustomNode extends Node {\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/CustomNode.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * A node that uses delimiters in the source form (e.g. <code>*bold*<\/code>).\n+ *\/\n+public interface Delimited {\n+\n+    \/**\n+     * @return the opening (beginning) delimiter, e.g. <code>*<\/code>\n+     *\/\n+    String getOpeningDelimiter();\n+\n+    \/**\n+     * @return the closing (ending) delimiter, e.g. <code>*<\/code>\n+     *\/\n+    String getClosingDelimiter();\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Delimited.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class Document extends Block {\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Document.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class Emphasis extends Node implements Delimited {\n+\n+    private String delimiter;\n+\n+    public Emphasis() {\n+    }\n+\n+    public Emphasis(String delimiter) {\n+        this.delimiter = delimiter;\n+    }\n+\n+    public void setDelimiter(String delimiter) {\n+        this.delimiter = delimiter;\n+    }\n+\n+    @Override\n+    public String getOpeningDelimiter() {\n+        return delimiter;\n+    }\n+\n+    @Override\n+    public String getClosingDelimiter() {\n+        return delimiter;\n+    }\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Emphasis.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class FencedCodeBlock extends Block {\n+\n+    private char fenceChar;\n+    private int fenceLength;\n+    private int fenceIndent;\n+\n+    private String info;\n+    private String literal;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public char getFenceChar() {\n+        return fenceChar;\n+    }\n+\n+    public void setFenceChar(char fenceChar) {\n+        this.fenceChar = fenceChar;\n+    }\n+\n+    public int getFenceLength() {\n+        return fenceLength;\n+    }\n+\n+    public void setFenceLength(int fenceLength) {\n+        this.fenceLength = fenceLength;\n+    }\n+\n+    public int getFenceIndent() {\n+        return fenceIndent;\n+    }\n+\n+    public void setFenceIndent(int fenceIndent) {\n+        this.fenceIndent = fenceIndent;\n+    }\n+\n+    \/**\n+     * @see <a href=\"http:\/\/spec.commonmark.org\/0.18\/#info-string\">CommonMark spec<\/a>\n+     *\/\n+    public String getInfo() {\n+        return info;\n+    }\n+\n+    public void setInfo(String info) {\n+        this.info = info;\n+    }\n+\n+    public String getLiteral() {\n+        return literal;\n+    }\n+\n+    public void setLiteral(String literal) {\n+        this.literal = literal;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/FencedCodeBlock.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class HardLineBreak extends Node {\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/HardLineBreak.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class Heading extends Block {\n+\n+    private int level;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public int getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(int level) {\n+        this.level = level;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Heading.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * HTML block\n+ *\n+ * @see <a href=\"http:\/\/spec.commonmark.org\/0.18\/#html-blocks\">CommonMark Spec<\/a>\n+ *\/\n+public class HtmlBlock extends Block {\n+\n+    private String literal;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public String getLiteral() {\n+        return literal;\n+    }\n+\n+    public void setLiteral(String literal) {\n+        this.literal = literal;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/HtmlBlock.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * Inline HTML element.\n+ *\n+ * @see <a href=\"http:\/\/spec.commonmark.org\/0.24\/#raw-html\">CommonMark Spec<\/a>\n+ *\/\n+public class HtmlInline extends Node {\n+\n+    private String literal;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public String getLiteral() {\n+        return literal;\n+    }\n+\n+    public void setLiteral(String literal) {\n+        this.literal = literal;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/HtmlInline.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class Image extends Node {\n+\n+    private String destination;\n+    private String title;\n+\n+    public Image() {\n+    }\n+\n+    public Image(String destination, String title) {\n+        this.destination = destination;\n+        this.title = title;\n+    }\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public String getDestination() {\n+        return destination;\n+    }\n+\n+    public void setDestination(String destination) {\n+        this.destination = destination;\n+    }\n+\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    public void setTitle(String title) {\n+        this.title = title;\n+    }\n+\n+    @Override\n+    protected String toStringAttributes() {\n+        return \"destination=\" + destination + \", title=\" + title;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Image.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class IndentedCodeBlock extends Block {\n+\n+    private String literal;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public String getLiteral() {\n+        return literal;\n+    }\n+\n+    public void setLiteral(String literal) {\n+        this.literal = literal;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/IndentedCodeBlock.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * A link with a destination and an optional title; the link text is in child nodes.\n+ * <p>\n+ * Example for an inline link in a CommonMark document:\n+ * <pre><code>\n+ * [link](\/uri \"title\")\n+ * <\/code><\/pre>\n+ * <p>\n+ * The corresponding Link node would look like this:\n+ * <ul>\n+ * <li>{@link #getDestination()} returns {@code \"\/uri\"}\n+ * <li>{@link #getTitle()} returns {@code \"title\"}\n+ * <li>A {@link Text} child node with {@link Text#getLiteral() getLiteral} that returns {@code \"link\"}<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Note that the text in the link can contain inline formatting, so it could also contain an {@link Image} or\n+ * {@link Emphasis}, etc.\n+ *\n+ * @see <a href=\"http:\/\/spec.commonmark.org\/0.26\/#links\">CommonMark Spec for links<\/a>\n+ *\/\n+public class Link extends Node {\n+\n+    private String destination;\n+    private String title;\n+\n+    public Link() {\n+    }\n+\n+    public Link(String destination, String title) {\n+        this.destination = destination;\n+        this.title = title;\n+    }\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public String getDestination() {\n+        return destination;\n+    }\n+\n+    public void setDestination(String destination) {\n+        this.destination = destination;\n+    }\n+\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    public void setTitle(String title) {\n+        this.title = title;\n+    }\n+\n+    @Override\n+    protected String toStringAttributes() {\n+        return \"destination=\" + destination + \", title=\" + title;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Link.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * A link reference definition, e.g.:\n+ * <pre><code>\n+ * [foo]: \/url \"title\"\n+ * <\/code><\/pre>\n+ * <p>\n+ * They can be referenced anywhere else in the document to produce a link using <code>[foo]<\/code>. The definitions\n+ * themselves are usually not rendered in the final output.\n+ *\n+ * @see <a href=\"https:\/\/spec.commonmark.org\/0.29\/#link-reference-definition\">Link reference definitions<\/a>\n+ *\/\n+public class LinkReferenceDefinition extends Node {\n+\n+    private String label;\n+    private String destination;\n+    private String title;\n+\n+    public LinkReferenceDefinition() {\n+    }\n+\n+    public LinkReferenceDefinition(String label, String destination, String title) {\n+        this.label = label;\n+        this.destination = destination;\n+        this.title = title;\n+    }\n+\n+    public String getLabel() {\n+        return label;\n+    }\n+\n+    public void setLabel(String label) {\n+        this.label = label;\n+    }\n+\n+    public String getDestination() {\n+        return destination;\n+    }\n+\n+    public void setDestination(String destination) {\n+        this.destination = destination;\n+    }\n+\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    public void setTitle(String title) {\n+        this.title = title;\n+    }\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/LinkReferenceDefinition.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public abstract class ListBlock extends Block {\n+\n+    private boolean tight;\n+\n+    \/**\n+     * @return whether this list is tight or loose\n+     * @see <a href=\"https:\/\/spec.commonmark.org\/0.28\/#tight\">CommonMark Spec for tight lists<\/a>\n+     *\/\n+    public boolean isTight() {\n+        return tight;\n+    }\n+\n+    public void setTight(boolean tight) {\n+        this.tight = tight;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/ListBlock.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class ListItem extends Block {\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/ListItem.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+\/**\n+ * The base class of all CommonMark AST nodes ({@link Block} and inlines).\n+ * <p>\n+ * A node can have multiple children, and a parent (except for the root node).\n+ *\/\n+public abstract class Node {\n+\n+    private Node parent = null;\n+    private Node firstChild = null;\n+    private Node lastChild = null;\n+    private Node prev = null;\n+    private Node next = null;\n+    private List<SourceSpan> sourceSpans = null;\n+\n+    public abstract void accept(Visitor visitor);\n+\n+    public Node getNext() {\n+        return next;\n+    }\n+\n+    public Node getPrevious() {\n+        return prev;\n+    }\n+\n+    public Node getFirstChild() {\n+        return firstChild;\n+    }\n+\n+    public Node getLastChild() {\n+        return lastChild;\n+    }\n+\n+    public Node getParent() {\n+        return parent;\n+    }\n+\n+    protected void setParent(Node parent) {\n+        this.parent = parent;\n+    }\n+\n+    public void appendChild(Node child) {\n+        child.unlink();\n+        child.setParent(this);\n+        if (this.lastChild != null) {\n+            this.lastChild.next = child;\n+            child.prev = this.lastChild;\n+            this.lastChild = child;\n+        } else {\n+            this.firstChild = child;\n+            this.lastChild = child;\n+        }\n+    }\n+\n+    public void prependChild(Node child) {\n+        child.unlink();\n+        child.setParent(this);\n+        if (this.firstChild != null) {\n+            this.firstChild.prev = child;\n+            child.next = this.firstChild;\n+            this.firstChild = child;\n+        } else {\n+            this.firstChild = child;\n+            this.lastChild = child;\n+        }\n+    }\n+\n+    public void unlink() {\n+        if (this.prev != null) {\n+            this.prev.next = this.next;\n+        } else if (this.parent != null) {\n+            this.parent.firstChild = this.next;\n+        }\n+        if (this.next != null) {\n+            this.next.prev = this.prev;\n+        } else if (this.parent != null) {\n+            this.parent.lastChild = this.prev;\n+        }\n+        this.parent = null;\n+        this.next = null;\n+        this.prev = null;\n+    }\n+\n+    public void insertAfter(Node sibling) {\n+        sibling.unlink();\n+        sibling.next = this.next;\n+        if (sibling.next != null) {\n+            sibling.next.prev = sibling;\n+        }\n+        sibling.prev = this;\n+        this.next = sibling;\n+        sibling.parent = this.parent;\n+        if (sibling.next == null) {\n+            sibling.parent.lastChild = sibling;\n+        }\n+    }\n+\n+    public void insertBefore(Node sibling) {\n+        sibling.unlink();\n+        sibling.prev = this.prev;\n+        if (sibling.prev != null) {\n+            sibling.prev.next = sibling;\n+        }\n+        sibling.next = this;\n+        this.prev = sibling;\n+        sibling.parent = this.parent;\n+        if (sibling.prev == null) {\n+            sibling.parent.firstChild = sibling;\n+        }\n+    }\n+\n+\n+    \/**\n+     * @return the source spans of this node if included by the parser, an empty list otherwise\n+     * @since 0.16.0\n+     *\/\n+    public List<SourceSpan> getSourceSpans() {\n+        return sourceSpans != null ? Collections.unmodifiableList(sourceSpans) : Collections.<SourceSpan>emptyList();\n+    }\n+\n+    \/**\n+     * Replace the current source spans with the provided list.\n+     *\n+     * @param sourceSpans the new source spans to set\n+     * @since 0.16.0\n+     *\/\n+    public void setSourceSpans(List<SourceSpan> sourceSpans) {\n+        if (sourceSpans.isEmpty()) {\n+            this.sourceSpans = null;\n+        } else {\n+            this.sourceSpans = new ArrayList<>(sourceSpans);\n+        }\n+    }\n+\n+    \/**\n+     * Add a source span to the end of the list.\n+     *\n+     * @param sourceSpan the source span to add\n+     * @since 0.16.0\n+     *\/\n+    public void addSourceSpan(SourceSpan sourceSpan) {\n+        if (sourceSpans == null) {\n+            this.sourceSpans = new ArrayList<>();\n+        }\n+        this.sourceSpans.add(sourceSpan);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return getClass().getSimpleName() + \"{\" + toStringAttributes() + \"}\";\n+    }\n+\n+    protected String toStringAttributes() {\n+        return \"\";\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Node.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+import java.util.Iterator;\n+\n+\/**\n+ * Utility class for working with multiple {@link Node}s.\n+ *\n+ * @since 0.16.0\n+ *\/\n+public class Nodes {\n+\n+    private Nodes() {\n+    }\n+\n+    \/**\n+     * The nodes between (not including) start and end.\n+     *\/\n+    public static Iterable<Node> between(Node start, Node end) {\n+        return new NodeIterable(start.getNext(), end);\n+    }\n+\n+    private static class NodeIterable implements Iterable<Node> {\n+\n+        private final Node first;\n+        private final Node end;\n+\n+        private NodeIterable(Node first, Node end) {\n+            this.first = first;\n+            this.end = end;\n+        }\n+\n+        @Override\n+        public Iterator<Node> iterator() {\n+            return new NodeIterator(first, end);\n+        }\n+    }\n+\n+    private static class NodeIterator implements Iterator<Node> {\n+\n+        private Node node;\n+        private final Node end;\n+\n+        private NodeIterator(Node first, Node end) {\n+            node = first;\n+            this.end = end;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return node != null && node != end;\n+        }\n+\n+        @Override\n+        public Node next() {\n+            Node result = node;\n+            node = node.getNext();\n+            return result;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException(\"remove\");\n+        }\n+    }\n+}\n+\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Nodes.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class OrderedList extends ListBlock {\n+\n+    private int startNumber;\n+    private char delimiter;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public int getStartNumber() {\n+        return startNumber;\n+    }\n+\n+    public void setStartNumber(int startNumber) {\n+        this.startNumber = startNumber;\n+    }\n+\n+    public char getDelimiter() {\n+        return delimiter;\n+    }\n+\n+    public void setDelimiter(char delimiter) {\n+        this.delimiter = delimiter;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/OrderedList.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * A paragraph block, contains inline nodes such as {@link Text}\n+ *\/\n+public class Paragraph extends Block {\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Paragraph.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class SoftLineBreak extends Node {\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/SoftLineBreak.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * A source span references a snippet of text from the source input.\n+ * <p>\n+ * It has a starting position (line and column index) and a length of how many characters it spans.\n+ * <p>\n+ * For example, this CommonMark source text:\n+ * <pre><code>\n+ * &gt; foo\n+ * <\/code><\/pre>\n+ * The {@link BlockQuote} node would have this source span: line 0, column 0, length 5.\n+ * <p>\n+ * The {@link Paragraph} node inside it would have: line 0, column 2, length 3.\n+ * <p>\n+ * If a block has multiple lines, it will have a source span for each line.\n+ * <p>\n+ * Note that the column index and length are measured in Java characters (UTF-16 code units). If you're outputting them\n+ * to be consumed by another programming language, e.g. one that uses UTF-8 strings, you will need to translate them,\n+ * otherwise characters such as emojis will result in incorrect positions.\n+ *\n+ * @since 0.16.0\n+ *\/\n+public class SourceSpan {\n+\n+    private final int lineIndex;\n+    private final int columnIndex;\n+    private final int length;\n+\n+    public static SourceSpan of(int lineIndex, int columnIndex, int length) {\n+        return new SourceSpan(lineIndex, columnIndex, length);\n+    }\n+\n+    private SourceSpan(int lineIndex, int columnIndex, int length) {\n+        this.lineIndex = lineIndex;\n+        this.columnIndex = columnIndex;\n+        this.length = length;\n+    }\n+\n+    \/**\n+     * @return 0-based index of line in source\n+     *\/\n+    public int getLineIndex() {\n+        return lineIndex;\n+    }\n+\n+    \/**\n+     * @return 0-based index of column (character on line) in source\n+     *\/\n+    public int getColumnIndex() {\n+        return columnIndex;\n+    }\n+\n+    \/**\n+     * @return length of the span in characters\n+     *\/\n+    public int getLength() {\n+        return length;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        SourceSpan that = (SourceSpan) o;\n+        return lineIndex == that.lineIndex &&\n+                columnIndex == that.columnIndex &&\n+                length == that.length;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(lineIndex, columnIndex, length);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"SourceSpan{\" +\n+                \"line=\" + lineIndex +\n+                \", column=\" + columnIndex +\n+                \", length=\" + length +\n+                \"}\";\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/SourceSpan.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+\/**\n+ * A list of source spans that can be added to. Takes care of merging adjacent source spans.\n+ *\n+ * @since 0.16.0\n+ *\/\n+public class SourceSpans {\n+\n+    private List<SourceSpan> sourceSpans;\n+\n+    public static SourceSpans empty() {\n+        return new SourceSpans();\n+    }\n+\n+    public List<SourceSpan> getSourceSpans() {\n+        return sourceSpans != null ? sourceSpans : Collections.<SourceSpan>emptyList();\n+    }\n+\n+    public void addAllFrom(Iterable<? extends Node> nodes) {\n+        for (Node node : nodes) {\n+            addAll(node.getSourceSpans());\n+        }\n+    }\n+\n+    public void addAll(List<SourceSpan> other) {\n+        if (other.isEmpty()) {\n+            return;\n+        }\n+\n+        if (sourceSpans == null) {\n+            sourceSpans = new ArrayList<>();\n+        }\n+\n+        if (sourceSpans.isEmpty()) {\n+            sourceSpans.addAll(other);\n+        } else {\n+            int lastIndex = sourceSpans.size() - 1;\n+            SourceSpan a = sourceSpans.get(lastIndex);\n+            SourceSpan b = other.get(0);\n+            if (a.getLineIndex() == b.getLineIndex() && a.getColumnIndex() + a.getLength() == b.getColumnIndex()) {\n+                sourceSpans.set(lastIndex, SourceSpan.of(a.getLineIndex(), a.getColumnIndex(), a.getLength() + b.getLength()));\n+                sourceSpans.addAll(other.subList(1, other.size()));\n+            } else {\n+                sourceSpans.addAll(other);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/SourceSpans.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class StrongEmphasis extends Node implements Delimited {\n+\n+    private String delimiter;\n+\n+    public StrongEmphasis() {\n+    }\n+\n+    public StrongEmphasis(String delimiter) {\n+        this.delimiter = delimiter;\n+    }\n+\n+    public void setDelimiter(String delimiter) {\n+        this.delimiter = delimiter;\n+    }\n+\n+    @Override\n+    public String getOpeningDelimiter() {\n+        return delimiter;\n+    }\n+\n+    @Override\n+    public String getClosingDelimiter() {\n+        return delimiter;\n+    }\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/StrongEmphasis.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class Text extends Node {\n+\n+    private String literal;\n+\n+    public Text() {\n+    }\n+\n+    public Text(String literal) {\n+        this.literal = literal;\n+    }\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public String getLiteral() {\n+        return literal;\n+    }\n+\n+    public void setLiteral(String literal) {\n+        this.literal = literal;\n+    }\n+\n+    @Override\n+    protected String toStringAttributes() {\n+        return \"literal=\" + literal;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Text.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class ThematicBreak extends Block {\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/ThematicBreak.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * Node visitor.\n+ * <p>\n+ * Implementations should subclass {@link AbstractVisitor} instead of implementing this directly.\n+ *\/\n+public interface Visitor {\n+\n+    void visit(BlockQuote blockQuote);\n+\n+    void visit(BulletList bulletList);\n+\n+    void visit(Code code);\n+\n+    void visit(Document document);\n+\n+    void visit(Emphasis emphasis);\n+\n+    void visit(FencedCodeBlock fencedCodeBlock);\n+\n+    void visit(HardLineBreak hardLineBreak);\n+\n+    void visit(Heading heading);\n+\n+    void visit(ThematicBreak thematicBreak);\n+\n+    void visit(HtmlInline htmlInline);\n+\n+    void visit(HtmlBlock htmlBlock);\n+\n+    void visit(Image image);\n+\n+    void visit(IndentedCodeBlock indentedCodeBlock);\n+\n+    void visit(Link link);\n+\n+    void visit(ListItem listItem);\n+\n+    void visit(OrderedList orderedList);\n+\n+    void visit(Paragraph paragraph);\n+\n+    void visit(SoftLineBreak softLineBreak);\n+\n+    void visit(StrongEmphasis strongEmphasis);\n+\n+    void visit(Text text);\n+\n+    void visit(LinkReferenceDefinition linkReferenceDefinition);\n+\n+    void visit(CustomBlock customBlock);\n+\n+    void visit(CustomNode customNode);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Visitor.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * AST node types (see {@link org.commonmark.node.Node}) and visitors (see {@link org.commonmark.node.AbstractVisitor})\n+ *\/\n+package jdk.internal.org.commonmark.node;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/package-info.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * Root package of commonmark-java\n+ * <ul>\n+ * <li>{@link org.commonmark.parser} for parsing input text to AST nodes<\/li>\n+ * <li>{@link org.commonmark.node} for AST node types and visitors<\/li>\n+ * <li>{@link org.commonmark.renderer.html} for HTML rendering<\/li>\n+ * <\/ul>\n+ *\/\n+package jdk.internal.org.commonmark;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/package-info.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+\/**\n+ * Whether to include {@link org.commonmark.node.SourceSpan} or not while parsing,\n+ * see {@link Parser.Builder#includeSourceSpans(IncludeSourceSpans)}.\n+ *\n+ * @since 0.16.0\n+ *\/\n+public enum IncludeSourceSpans {\n+    \/**\n+     * Do not include source spans.\n+     *\/\n+    NONE,\n+    \/**\n+     * Include source spans on {@link org.commonmark.node.Block} nodes.\n+     *\/\n+    BLOCKS,\n+    \/**\n+     * Include source spans on block nodes and inline nodes.\n+     *\/\n+    BLOCKS_AND_INLINES,\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/IncludeSourceSpans.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+\/**\n+ * Parser for inline content (text, links, emphasized text, etc).\n+ *\/\n+public interface InlineParser {\n+\n+    \/**\n+     * @param lines the source content to parse as inline\n+     * @param node the node to append resulting nodes to (as children)\n+     *\/\n+    void parse(SourceLines lines, Node node);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/InlineParser.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+import jdk.internal.org.commonmark.node.LinkReferenceDefinition;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+\n+import java.util.List;\n+\n+\/**\n+ * Context for inline parsing.\n+ *\/\n+public interface InlineParserContext {\n+\n+    \/**\n+     * @return custom delimiter processors that have been configured with {@link Parser.Builder#customDelimiterProcessor(DelimiterProcessor)}\n+     *\/\n+    List<DelimiterProcessor> getCustomDelimiterProcessors();\n+\n+    \/**\n+     * Look up a {@link LinkReferenceDefinition} for a given label.\n+     * <p>\n+     * Note that the label is not normalized yet; implementations are responsible for normalizing before lookup.\n+     *\n+     * @param label the link label to look up\n+     * @return the definition if one exists, {@code null} otherwise\n+     *\/\n+    LinkReferenceDefinition getLinkReferenceDefinition(String label);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/InlineParserContext.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+\/**\n+ * Factory for custom inline parser.\n+ *\/\n+public interface InlineParserFactory {\n+    InlineParser create(InlineParserContext inlineParserContext);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/InlineParserFactory.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,316 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+import jdk.internal.org.commonmark.Extension;\n+import jdk.internal.org.commonmark.internal.DocumentParser;\n+import jdk.internal.org.commonmark.internal.InlineParserContextImpl;\n+import jdk.internal.org.commonmark.internal.InlineParserImpl;\n+import jdk.internal.org.commonmark.internal.LinkReferenceDefinitions;\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.parser.block.BlockParserFactory;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+\n+\/**\n+ * Parses input text to a tree of nodes.\n+ * <p>\n+ * Start with the {@link #builder} method, configure the parser and build it. Example:\n+ * <pre><code>\n+ * Parser parser = Parser.builder().build();\n+ * Node document = parser.parse(\"input text\");\n+ * <\/code><\/pre>\n+ *\/\n+public class Parser {\n+\n+    private final List<BlockParserFactory> blockParserFactories;\n+    private final List<DelimiterProcessor> delimiterProcessors;\n+    private final InlineParserFactory inlineParserFactory;\n+    private final List<PostProcessor> postProcessors;\n+    private final IncludeSourceSpans includeSourceSpans;\n+\n+    private Parser(Builder builder) {\n+        this.blockParserFactories = DocumentParser.calculateBlockParserFactories(builder.blockParserFactories, builder.enabledBlockTypes);\n+        this.inlineParserFactory = builder.getInlineParserFactory();\n+        this.postProcessors = builder.postProcessors;\n+        this.delimiterProcessors = builder.delimiterProcessors;\n+        this.includeSourceSpans = builder.includeSourceSpans;\n+\n+        \/\/ Try to construct an inline parser. Invalid configuration might result in an exception, which we want to\n+        \/\/ detect as soon as possible.\n+        this.inlineParserFactory.create(new InlineParserContextImpl(delimiterProcessors, new LinkReferenceDefinitions()));\n+    }\n+\n+    \/**\n+     * Create a new builder for configuring a {@link Parser}.\n+     *\n+     * @return a builder\n+     *\/\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    \/**\n+     * Parse the specified input text into a tree of nodes.\n+     * <p>\n+     * This method is thread-safe (a new parser state is used for each invocation).\n+     *\n+     * @param input the text to parse - must not be null\n+     * @return the root node\n+     *\/\n+    public Node parse(String input) {\n+        if (input == null) {\n+            throw new NullPointerException(\"input must not be null\");\n+        }\n+        DocumentParser documentParser = createDocumentParser();\n+        Node document = documentParser.parse(input);\n+        return postProcess(document);\n+    }\n+\n+    \/**\n+     * Parse the specified reader into a tree of nodes. The caller is responsible for closing the reader.\n+     * <pre><code>\n+     * Parser parser = Parser.builder().build();\n+     * try (InputStreamReader reader = new InputStreamReader(new FileInputStream(\"file.md\"), StandardCharsets.UTF_8)) {\n+     *     Node document = parser.parseReader(reader);\n+     *     \/\/ ...\n+     * }\n+     * <\/code><\/pre>\n+     * Note that if you have a file with a byte order mark (BOM), you need to skip it before handing the reader to this\n+     * library. There's existing classes that do that, e.g. see {@code BOMInputStream} in Commons IO.\n+     * <p>\n+     * This method is thread-safe (a new parser state is used for each invocation).\n+     *\n+     * @param input the reader to parse - must not be null\n+     * @return the root node\n+     * @throws IOException when reading throws an exception\n+     *\/\n+    public Node parseReader(Reader input) throws IOException {\n+        if (input == null) {\n+            throw new NullPointerException(\"input must not be null\");\n+        }\n+\n+        DocumentParser documentParser = createDocumentParser();\n+        Node document = documentParser.parse(input);\n+        return postProcess(document);\n+    }\n+\n+    private DocumentParser createDocumentParser() {\n+        return new DocumentParser(blockParserFactories, inlineParserFactory, delimiterProcessors, includeSourceSpans);\n+    }\n+\n+    private Node postProcess(Node document) {\n+        for (PostProcessor postProcessor : postProcessors) {\n+            document = postProcessor.process(document);\n+        }\n+        return document;\n+    }\n+\n+    \/**\n+     * Builder for configuring a {@link Parser}.\n+     *\/\n+    public static class Builder {\n+        private final List<BlockParserFactory> blockParserFactories = new ArrayList<>();\n+        private final List<DelimiterProcessor> delimiterProcessors = new ArrayList<>();\n+        private final List<PostProcessor> postProcessors = new ArrayList<>();\n+        private Set<Class<? extends Block>> enabledBlockTypes = DocumentParser.getDefaultBlockParserTypes();\n+        private InlineParserFactory inlineParserFactory;\n+        private IncludeSourceSpans includeSourceSpans = IncludeSourceSpans.NONE;\n+\n+        \/**\n+         * @return the configured {@link Parser}\n+         *\/\n+        public Parser build() {\n+            return new Parser(this);\n+        }\n+\n+        \/**\n+         * @param extensions extensions to use on this parser\n+         * @return {@code this}\n+         *\/\n+        public Builder extensions(Iterable<? extends Extension> extensions) {\n+            if (extensions == null) {\n+                throw new NullPointerException(\"extensions must not be null\");\n+            }\n+            for (Extension extension : extensions) {\n+                if (extension instanceof ParserExtension) {\n+                    ParserExtension parserExtension = (ParserExtension) extension;\n+                    parserExtension.extend(this);\n+                }\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Describe the list of markdown features the parser will recognize and parse.\n+         * <p>\n+         * By default, CommonMark will recognize and parse the following set of \"block\" elements:\n+         * <ul>\n+         * <li>{@link Heading} ({@code #})\n+         * <li>{@link HtmlBlock} ({@code <html><\/html>})\n+         * <li>{@link ThematicBreak} (Horizontal Rule) ({@code ---})\n+         * <li>{@link FencedCodeBlock} ({@code ```})\n+         * <li>{@link IndentedCodeBlock}\n+         * <li>{@link BlockQuote} ({@code >})\n+         * <li>{@link ListBlock} (Ordered \/ Unordered List) ({@code 1. \/ *})\n+         * <\/ul>\n+         * <p>\n+         * To parse only a subset of the features listed above, pass a list of each feature's associated {@link Block} class.\n+         * <p>\n+         * E.g., to only parse headings and lists:\n+         * <pre>\n+         *     {@code\n+         *     Parser.builder().enabledBlockTypes(new HashSet<>(Arrays.asList(Heading.class, ListBlock.class)));\n+         *     }\n+         * <\/pre>\n+         *\n+         * @param enabledBlockTypes A list of block nodes the parser will parse.\n+         * If this list is empty, the parser will not recognize any CommonMark core features.\n+         * @return {@code this}\n+         *\/\n+        public Builder enabledBlockTypes(Set<Class<? extends Block>> enabledBlockTypes) {\n+            if (enabledBlockTypes == null) {\n+                throw new NullPointerException(\"enabledBlockTypes must not be null\");\n+            }\n+            DocumentParser.checkEnabledBlockTypes(enabledBlockTypes);\n+            this.enabledBlockTypes = enabledBlockTypes;\n+            return this;\n+        }\n+\n+        \/**\n+         * Whether to calculate {@link org.commonmark.node.SourceSpan} for {@link Node}.\n+         * <p>\n+         * By default, source spans are disabled.\n+         *\n+         * @param includeSourceSpans which kind of source spans should be included\n+         * @return {@code this}\n+         * @since 0.16.0\n+         *\/\n+        public Builder includeSourceSpans(IncludeSourceSpans includeSourceSpans) {\n+            this.includeSourceSpans = includeSourceSpans;\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a custom block parser factory.\n+         * <p>\n+         * Note that custom factories are applied <em>before<\/em> the built-in factories. This is so that\n+         * extensions can change how some syntax is parsed that would otherwise be handled by built-in factories.\n+         * \"With great power comes great responsibility.\"\n+         *\n+         * @param blockParserFactory a block parser factory implementation\n+         * @return {@code this}\n+         *\/\n+        public Builder customBlockParserFactory(BlockParserFactory blockParserFactory) {\n+            if (blockParserFactory == null) {\n+                throw new NullPointerException(\"blockParserFactory must not be null\");\n+            }\n+            blockParserFactories.add(blockParserFactory);\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a custom delimiter processor.\n+         * <p>\n+         * Note that multiple delimiter processors with the same characters can be added, as long as they have a\n+         * different minimum length. In that case, the processor with the shortest matching length is used. Adding more\n+         * than one delimiter processor with the same character and minimum length is invalid.\n+         *\n+         * @param delimiterProcessor a delimiter processor implementation\n+         * @return {@code this}\n+         *\/\n+        public Builder customDelimiterProcessor(DelimiterProcessor delimiterProcessor) {\n+            if (delimiterProcessor == null) {\n+                throw new NullPointerException(\"delimiterProcessor must not be null\");\n+            }\n+            delimiterProcessors.add(delimiterProcessor);\n+            return this;\n+        }\n+\n+        public Builder postProcessor(PostProcessor postProcessor) {\n+            if (postProcessor == null) {\n+                throw new NullPointerException(\"postProcessor must not be null\");\n+            }\n+            postProcessors.add(postProcessor);\n+            return this;\n+        }\n+\n+        \/**\n+         * Overrides the parser used for inline markdown processing.\n+         * <p>\n+         * Provide an implementation of InlineParserFactory which provides a custom inline parser\n+         * to modify how the following are parsed:\n+         * bold (**)\n+         * italic (*)\n+         * strikethrough (~~)\n+         * backtick quote (`)\n+         * link ([title](http:\/\/))\n+         * image (![alt](http:\/\/))\n+         * <p>\n+         * Note that if this method is not called or the inline parser factory is set to null, then the default\n+         * implementation will be used.\n+         *\n+         * @param inlineParserFactory an inline parser factory implementation\n+         * @return {@code this}\n+         *\/\n+        public Builder inlineParserFactory(InlineParserFactory inlineParserFactory) {\n+            this.inlineParserFactory = inlineParserFactory;\n+            return this;\n+        }\n+\n+        private InlineParserFactory getInlineParserFactory() {\n+            if (inlineParserFactory != null) {\n+                return inlineParserFactory;\n+            }\n+            return new InlineParserFactory() {\n+                @Override\n+                public InlineParser create(InlineParserContext inlineParserContext) {\n+                    return new InlineParserImpl(inlineParserContext);\n+                }\n+            };\n+        }\n+    }\n+\n+    \/**\n+     * Extension for {@link Parser}.\n+     *\/\n+    public interface ParserExtension extends Extension {\n+        void extend(Builder parserBuilder);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/Parser.java","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+public interface PostProcessor {\n+\n+    \/**\n+     * @param node the node to post-process\n+     * @return the result of post-processing, may be a modified {@code node} argument\n+     *\/\n+    Node process(Node node);\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/PostProcessor.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+\n+\/**\n+ * A line or part of a line from the input source.\n+ *\n+ * @since 0.16.0\n+ *\/\n+public class SourceLine {\n+\n+    private final CharSequence content;\n+    private final SourceSpan sourceSpan;\n+\n+    public static SourceLine of(CharSequence content, SourceSpan sourceSpan) {\n+        return new SourceLine(content, sourceSpan);\n+    }\n+\n+    private SourceLine(CharSequence content, SourceSpan sourceSpan) {\n+        if (content == null) {\n+            throw new NullPointerException(\"content must not be null\");\n+        }\n+        this.content = content;\n+        this.sourceSpan = sourceSpan;\n+    }\n+\n+    public CharSequence getContent() {\n+        return content;\n+    }\n+\n+    public SourceSpan getSourceSpan() {\n+        return sourceSpan;\n+    }\n+\n+    public SourceLine substring(int beginIndex, int endIndex) {\n+        CharSequence newContent = content.subSequence(beginIndex, endIndex);\n+        SourceSpan newSourceSpan = null;\n+        if (sourceSpan != null) {\n+            int columnIndex = sourceSpan.getColumnIndex() + beginIndex;\n+            int length = endIndex - beginIndex;\n+            if (length != 0) {\n+                newSourceSpan = SourceSpan.of(sourceSpan.getLineIndex(), columnIndex, length);\n+            }\n+        }\n+        return SourceLine.of(newContent, newSourceSpan);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/SourceLine.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * A set of lines ({@link SourceLine}) from the input source.\n+ *\n+ * @since 0.16.0\n+ *\/\n+public class SourceLines {\n+\n+    private final List<SourceLine> lines = new ArrayList<>();\n+\n+    public static SourceLines empty() {\n+        return new SourceLines();\n+    }\n+\n+    public static SourceLines of(SourceLine sourceLine) {\n+        SourceLines sourceLines = new SourceLines();\n+        sourceLines.addLine(sourceLine);\n+        return sourceLines;\n+    }\n+\n+    public static SourceLines of(List<SourceLine> sourceLines) {\n+        SourceLines result = new SourceLines();\n+        result.lines.addAll(sourceLines);\n+        return result;\n+    }\n+\n+    public void addLine(SourceLine sourceLine) {\n+        lines.add(sourceLine);\n+    }\n+\n+    public List<SourceLine> getLines() {\n+        return lines;\n+    }\n+\n+    public boolean isEmpty() {\n+        return lines.isEmpty();\n+    }\n+\n+    public String getContent() {\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < lines.size(); i++) {\n+            if (i != 0) {\n+                sb.append('\\n');\n+            }\n+            sb.append(lines.get(i).getContent());\n+        }\n+        return sb.toString();\n+    }\n+\n+    public List<SourceSpan> getSourceSpans() {\n+        List<SourceSpan> sourceSpans = new ArrayList<>();\n+        for (SourceLine line : lines) {\n+            SourceSpan sourceSpan = line.getSourceSpan();\n+            if (sourceSpan != null) {\n+                sourceSpans.add(sourceSpan);\n+            }\n+        }\n+        return sourceSpans;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/SourceLines.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.parser.InlineParser;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+\n+public abstract class AbstractBlockParser implements BlockParser {\n+\n+    @Override\n+    public boolean isContainer() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean canHaveLazyContinuationLines() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean canContain(Block childBlock) {\n+        return false;\n+    }\n+\n+    @Override\n+    public void addLine(SourceLine line) {\n+    }\n+\n+    @Override\n+    public void addSourceSpan(SourceSpan sourceSpan) {\n+        getBlock().addSourceSpan(sourceSpan);\n+    }\n+\n+    @Override\n+    public void closeBlock() {\n+    }\n+\n+    @Override\n+    public void parseInlines(InlineParser inlineParser) {\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/AbstractBlockParser.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+public abstract class AbstractBlockParserFactory implements BlockParserFactory {\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/AbstractBlockParserFactory.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+import jdk.internal.org.commonmark.internal.BlockContinueImpl;\n+\n+\/**\n+ * Result object for continuing parsing of a block, see static methods for constructors.\n+ *\/\n+public class BlockContinue {\n+\n+    protected BlockContinue() {\n+    }\n+\n+    public static BlockContinue none() {\n+        return null;\n+    }\n+\n+    public static BlockContinue atIndex(int newIndex) {\n+        return new BlockContinueImpl(newIndex, -1, false);\n+    }\n+\n+    public static BlockContinue atColumn(int newColumn) {\n+        return new BlockContinueImpl(-1, newColumn, false);\n+    }\n+\n+    public static BlockContinue finished() {\n+        return new BlockContinueImpl(-1, -1, true);\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/BlockContinue.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.parser.InlineParser;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+\n+\/**\n+ * Parser for a specific block node.\n+ * <p>\n+ * Implementations should subclass {@link AbstractBlockParser} instead of implementing this directly.\n+ *\/\n+public interface BlockParser {\n+\n+    \/**\n+     * Return true if the block that is parsed is a container (contains other blocks), or false if it's a leaf.\n+     *\/\n+    boolean isContainer();\n+\n+    \/**\n+     * Return true if the block can have lazy continuation lines.\n+     * <p>\n+     * Lazy continuation lines are lines that were rejected by this {@link #tryContinue(ParserState)} but didn't match\n+     * any other block parsers either.\n+     * <p>\n+     * If true is returned here, those lines will get added via {@link #addLine(SourceLine)}. For false, the block is\n+     * closed instead.\n+     *\/\n+    boolean canHaveLazyContinuationLines();\n+\n+    boolean canContain(Block childBlock);\n+\n+    Block getBlock();\n+\n+    BlockContinue tryContinue(ParserState parserState);\n+\n+    void addLine(SourceLine line);\n+\n+    \/**\n+     * Add a source span of the currently parsed block. The default implementation in {@link AbstractBlockParser} adds\n+     * it to the block. Unless you have some complicated parsing where you need to check source positions, you don't\n+     * need to override this.\n+     *\n+     * @since 0.16.0\n+     *\/\n+    void addSourceSpan(SourceSpan sourceSpan);\n+\n+    void closeBlock();\n+\n+    void parseInlines(InlineParser inlineParser);\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/BlockParser.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+\/**\n+ * Parser factory for a block node for determining when a block starts.\n+ * <p>\n+ * Implementations should subclass {@link AbstractBlockParserFactory} instead of implementing this directly.\n+ *\/\n+public interface BlockParserFactory {\n+\n+    BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser);\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/BlockParserFactory.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+import jdk.internal.org.commonmark.internal.BlockStartImpl;\n+\n+\/**\n+ * Result object for starting parsing of a block, see static methods for constructors.\n+ *\/\n+public abstract class BlockStart {\n+\n+    protected BlockStart() {\n+    }\n+\n+    public static BlockStart none() {\n+        return null;\n+    }\n+\n+    public static BlockStart of(BlockParser... blockParsers) {\n+        return new BlockStartImpl(blockParsers);\n+    }\n+\n+    public abstract BlockStart atIndex(int newIndex);\n+\n+    public abstract BlockStart atColumn(int newColumn);\n+\n+    public abstract BlockStart replaceActiveBlockParser();\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/BlockStart.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+\n+\/**\n+ * Open block parser that was last matched during the continue phase. This is different from the currently active\n+ * block parser, as an unmatched block is only closed when a new block is started.\n+ * <p><em>This interface is not intended to be implemented by clients.<\/em><\/p>\n+ *\/\n+public interface MatchedBlockParser {\n+\n+    BlockParser getMatchedBlockParser();\n+\n+    \/**\n+     * Returns the current paragraph lines if the matched block is a paragraph.\n+     *\n+     * @return paragraph content or an empty list\n+     *\/\n+    SourceLines getParagraphLines();\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/MatchedBlockParser.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+\n+\/**\n+ * State of the parser that is used in block parsers.\n+ * <p><em>This interface is not intended to be implemented by clients.<\/em><\/p>\n+ *\/\n+public interface ParserState {\n+\n+    \/**\n+     * @return the current source line being parsed (full line)\n+     *\/\n+    SourceLine getLine();\n+\n+    \/**\n+     * @return the current index within the line (0-based)\n+     *\/\n+    int getIndex();\n+\n+    \/**\n+     * @return the index of the next non-space character starting from {@link #getIndex()} (may be the same) (0-based)\n+     *\/\n+    int getNextNonSpaceIndex();\n+\n+    \/**\n+     * The column is the position within the line after tab characters have been processed as 4-space tab stops.\n+     * If the line doesn't contain any tabs, it's the same as the {@link #getIndex()}. If the line starts with a tab,\n+     * followed by text, then the column for the first character of the text is 4 (the index is 1).\n+     *\n+     * @return the current column within the line (0-based)\n+     *\/\n+    int getColumn();\n+\n+    \/**\n+     * @return the indentation in columns (either by spaces or tab stop of 4), starting from {@link #getColumn()}\n+     *\/\n+    int getIndent();\n+\n+    \/**\n+     * @return true if the current line is blank starting from the index\n+     *\/\n+    boolean isBlank();\n+\n+    \/**\n+     * @return the deepest open block parser\n+     *\/\n+    BlockParser getActiveBlockParser();\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/ParserState.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * Types for extending block parsing\n+ *\/\n+package jdk.internal.org.commonmark.parser.block;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/package-info.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.delimiter;\n+\n+import jdk.internal.org.commonmark.node.Text;\n+\n+\/**\n+ * Custom delimiter processor for additional delimiters besides {@code _} and {@code *}.\n+ * <p>\n+ * Note that implementations of this need to be thread-safe, the same instance may be used by multiple parsers.\n+ *\/\n+public interface DelimiterProcessor {\n+\n+    \/**\n+     * @return the character that marks the beginning of a delimited node, must not clash with any built-in special\n+     * characters\n+     *\/\n+    char getOpeningCharacter();\n+\n+    \/**\n+     * @return the character that marks the the ending of a delimited node, must not clash with any built-in special\n+     * characters. Note that for a symmetric delimiter such as \"*\", this is the same as the opening.\n+     *\/\n+    char getClosingCharacter();\n+\n+    \/**\n+     * Minimum number of delimiter characters that are needed to activate this. Must be at least 1.\n+     *\/\n+    int getMinLength();\n+\n+    \/**\n+     * Process the delimiter runs.\n+     * <p>\n+     * The processor can examine the runs and the nodes and decide if it wants to process or not. If not, it should not\n+     * change any nodes and return 0. If yes, it should do the processing (wrapping nodes, etc) and then return how many\n+     * delimiters were used.\n+     * <p>\n+     * Note that removal (unlinking) of the used delimiter {@link Text} nodes is done by the caller.\n+     *\n+     * @param openingRun the opening delimiter run\n+     * @param closingRun the closing delimiter run\n+     * @return how many delimiters were used; must not be greater than length of either opener or closer\n+     *\/\n+    int process(DelimiterRun openingRun, DelimiterRun closingRun);\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/delimiter\/DelimiterProcessor.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.delimiter;\n+\n+import jdk.internal.org.commonmark.node.Text;\n+\n+\/**\n+ * A delimiter run is one or more of the same delimiter character, e.g. {@code ***}.\n+ *\/\n+public interface DelimiterRun {\n+\n+    \/**\n+     * @return whether this can open a delimiter\n+     *\/\n+    boolean canOpen();\n+\n+    \/**\n+     * @return whether this can close a delimiter\n+     *\/\n+    boolean canClose();\n+\n+    \/**\n+     * @return the number of characters in this delimiter run (that are left for processing)\n+     *\/\n+    int length();\n+\n+    \/**\n+     * @return the number of characters originally in this delimiter run; at the start of processing, this is the same\n+     * as {{@link #length()}}\n+     *\/\n+    int originalLength();\n+\n+    \/**\n+     * @return the innermost opening delimiter, e.g. for {@code ***} this is the last {@code *}\n+     *\/\n+    Text getOpener();\n+\n+    \/**\n+     * @return the innermost closing delimiter, e.g. for {@code ***} this is the first {@code *}\n+     *\/\n+    Text getCloser();\n+\n+    \/**\n+     * Get the opening delimiter nodes for the specified length of delimiters. Length must be between 1 and\n+     * {@link #length()}.\n+     * <p>\n+     * For example, for a delimiter run {@code ***}, calling this with 1 would return the last {@code *}.\n+     * Calling it with 2 would return the second last {@code *} and the last {@code *}.\n+     *\/\n+    Iterable<Text> getOpeners(int length);\n+\n+    \/**\n+     * Get the closing delimiter nodes for the specified length of delimiters. Length must be between 1 and\n+     * {@link #length()}.\n+     * <p>\n+     * For example, for a delimiter run {@code ***}, calling this with 1 would return the first {@code *}.\n+     * Calling it with 2 would return the first {@code *} and the second {@code *}.\n+     *\/\n+    Iterable<Text> getClosers(int length);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/delimiter\/DelimiterRun.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * Parsing input text to AST nodes (see {@link org.commonmark.parser.Parser})\n+ *\/\n+package jdk.internal.org.commonmark.parser;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/package-info.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+import java.util.Set;\n+\n+\/**\n+ * A renderer for a set of node types.\n+ *\/\n+public interface NodeRenderer {\n+\n+    \/**\n+     * @return the types of nodes that this renderer handles\n+     *\/\n+    Set<Class<? extends Node>> getNodeTypes();\n+\n+    \/**\n+     * Render the specified node.\n+     *\n+     * @param node the node to render, will be an instance of one of {@link #getNodeTypes()}\n+     *\/\n+    void render(Node node);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/NodeRenderer.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+public interface Renderer {\n+\n+    \/**\n+     * Render the tree of nodes to output.\n+     *\n+     * @param node the root node\n+     * @param output output for rendering\n+     *\/\n+    void render(Node node, Appendable output);\n+\n+    \/**\n+     * Render the tree of nodes to string.\n+     *\n+     * @param node the root node\n+     * @return the rendered string\n+     *\/\n+    String render(Node node);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/Renderer.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+import java.util.Map;\n+\n+\/**\n+ * Extension point for adding\/changing attributes on HTML tags for a node.\n+ *\/\n+public interface AttributeProvider {\n+\n+    \/**\n+     * Set the attributes for a HTML tag of the specified node by modifying the provided map.\n+     * <p>\n+     * This allows to change or even remove default attributes. With great power comes great responsibility.\n+     * <p>\n+     * The attribute key and values will be escaped (preserving character entities), so don't escape them here,\n+     * otherwise they will be double-escaped.\n+     * <p>\n+     * This method may be called multiple times for the same node, if the node is rendered using multiple nested\n+     * tags (e.g. code blocks).\n+     *\n+     * @param node the node to set attributes for\n+     * @param tagName the HTML tag name that these attributes are for (e.g. {@code h1}, {@code pre}, {@code code}).\n+     * @param attributes the attributes, with any default attributes already set in the map\n+     *\/\n+    void setAttributes(Node node, String tagName, Map<String, String> attributes);\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/AttributeProvider.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+\/**\n+ * The context for attribute providers.\n+ * <p>Note: There are currently no methods here, this is for future extensibility.<\/p>\n+ * <p><em>This interface is not intended to be implemented by clients.<\/em><\/p>\n+ *\/\n+public interface AttributeProviderContext {\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/AttributeProviderContext.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+\/**\n+ * Factory for instantiating new attribute providers when rendering is done.\n+ *\/\n+public interface AttributeProviderFactory {\n+\n+    \/**\n+     * Create a new attribute provider.\n+     *\n+     * @param context for this attribute provider\n+     * @return an AttributeProvider\n+     *\/\n+    AttributeProvider create(AttributeProviderContext context);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/AttributeProviderFactory.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,352 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+\n+import java.util.*;\n+\n+\/**\n+ * The node renderer that renders all the core nodes (comes last in the order of node renderers).\n+ *\/\n+public class CoreHtmlNodeRenderer extends AbstractVisitor implements NodeRenderer {\n+\n+    protected final HtmlNodeRendererContext context;\n+    private final HtmlWriter html;\n+\n+    public CoreHtmlNodeRenderer(HtmlNodeRendererContext context) {\n+        this.context = context;\n+        this.html = context.getWriter();\n+    }\n+\n+    @Override\n+    public Set<Class<? extends Node>> getNodeTypes() {\n+        return new HashSet<>(Arrays.asList(\n+                Document.class,\n+                Heading.class,\n+                Paragraph.class,\n+                BlockQuote.class,\n+                BulletList.class,\n+                FencedCodeBlock.class,\n+                HtmlBlock.class,\n+                ThematicBreak.class,\n+                IndentedCodeBlock.class,\n+                Link.class,\n+                ListItem.class,\n+                OrderedList.class,\n+                Image.class,\n+                Emphasis.class,\n+                StrongEmphasis.class,\n+                Text.class,\n+                Code.class,\n+                HtmlInline.class,\n+                SoftLineBreak.class,\n+                HardLineBreak.class\n+        ));\n+    }\n+\n+    @Override\n+    public void render(Node node) {\n+        node.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(Document document) {\n+        \/\/ No rendering itself\n+        visitChildren(document);\n+    }\n+\n+    @Override\n+    public void visit(Heading heading) {\n+        String htag = \"h\" + heading.getLevel();\n+        html.line();\n+        html.tag(htag, getAttrs(heading, htag));\n+        visitChildren(heading);\n+        html.tag('\/' + htag);\n+        html.line();\n+    }\n+\n+    @Override\n+    public void visit(Paragraph paragraph) {\n+        boolean inTightList = isInTightList(paragraph);\n+        if (!inTightList) {\n+            html.line();\n+            html.tag(\"p\", getAttrs(paragraph, \"p\"));\n+        }\n+        visitChildren(paragraph);\n+        if (!inTightList) {\n+            html.tag(\"\/p\");\n+            html.line();\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BlockQuote blockQuote) {\n+        html.line();\n+        html.tag(\"blockquote\", getAttrs(blockQuote, \"blockquote\"));\n+        html.line();\n+        visitChildren(blockQuote);\n+        html.line();\n+        html.tag(\"\/blockquote\");\n+        html.line();\n+    }\n+\n+    @Override\n+    public void visit(BulletList bulletList) {\n+        renderListBlock(bulletList, \"ul\", getAttrs(bulletList, \"ul\"));\n+    }\n+\n+    @Override\n+    public void visit(FencedCodeBlock fencedCodeBlock) {\n+        String literal = fencedCodeBlock.getLiteral();\n+        Map<String, String> attributes = new LinkedHashMap<>();\n+        String info = fencedCodeBlock.getInfo();\n+        if (info != null && !info.isEmpty()) {\n+            int space = info.indexOf(\" \");\n+            String language;\n+            if (space == -1) {\n+                language = info;\n+            } else {\n+                language = info.substring(0, space);\n+            }\n+            attributes.put(\"class\", \"language-\" + language);\n+        }\n+        renderCodeBlock(literal, fencedCodeBlock, attributes);\n+    }\n+\n+    @Override\n+    public void visit(HtmlBlock htmlBlock) {\n+        html.line();\n+        if (context.shouldEscapeHtml()) {\n+            html.tag(\"p\", getAttrs(htmlBlock, \"p\"));\n+            html.text(htmlBlock.getLiteral());\n+            html.tag(\"\/p\");\n+        } else {\n+            html.raw(htmlBlock.getLiteral());\n+        }\n+        html.line();\n+    }\n+\n+    @Override\n+    public void visit(ThematicBreak thematicBreak) {\n+        html.line();\n+        html.tag(\"hr\", getAttrs(thematicBreak, \"hr\"), true);\n+        html.line();\n+    }\n+\n+    @Override\n+    public void visit(IndentedCodeBlock indentedCodeBlock) {\n+        renderCodeBlock(indentedCodeBlock.getLiteral(), indentedCodeBlock, Collections.<String, String>emptyMap());\n+    }\n+\n+    @Override\n+    public void visit(Link link) {\n+        Map<String, String> attrs = new LinkedHashMap<>();\n+        String url = link.getDestination();\n+\n+        if (context.shouldSanitizeUrls()) {\n+            url = context.urlSanitizer().sanitizeLinkUrl(url);\n+            attrs.put(\"rel\", \"nofollow\");\n+        }\n+\n+        url = context.encodeUrl(url);\n+        attrs.put(\"href\", url);\n+        if (link.getTitle() != null) {\n+            attrs.put(\"title\", link.getTitle());\n+        }\n+        html.tag(\"a\", getAttrs(link, \"a\", attrs));\n+        visitChildren(link);\n+        html.tag(\"\/a\");\n+    }\n+\n+    @Override\n+    public void visit(ListItem listItem) {\n+        html.tag(\"li\", getAttrs(listItem, \"li\"));\n+        visitChildren(listItem);\n+        html.tag(\"\/li\");\n+        html.line();\n+    }\n+\n+    @Override\n+    public void visit(OrderedList orderedList) {\n+        int start = orderedList.getStartNumber();\n+        Map<String, String> attrs = new LinkedHashMap<>();\n+        if (start != 1) {\n+            attrs.put(\"start\", String.valueOf(start));\n+        }\n+        renderListBlock(orderedList, \"ol\", getAttrs(orderedList, \"ol\", attrs));\n+    }\n+\n+    @Override\n+    public void visit(Image image) {\n+        String url = image.getDestination();\n+\n+        AltTextVisitor altTextVisitor = new AltTextVisitor();\n+        image.accept(altTextVisitor);\n+        String altText = altTextVisitor.getAltText();\n+\n+        Map<String, String> attrs = new LinkedHashMap<>();\n+        if (context.shouldSanitizeUrls()) {\n+            url = context.urlSanitizer().sanitizeImageUrl(url);\n+        }\n+\n+        attrs.put(\"src\", context.encodeUrl(url));\n+        attrs.put(\"alt\", altText);\n+        if (image.getTitle() != null) {\n+            attrs.put(\"title\", image.getTitle());\n+        }\n+\n+        html.tag(\"img\", getAttrs(image, \"img\", attrs), true);\n+    }\n+\n+    @Override\n+    public void visit(Emphasis emphasis) {\n+        html.tag(\"em\", getAttrs(emphasis, \"em\"));\n+        visitChildren(emphasis);\n+        html.tag(\"\/em\");\n+    }\n+\n+    @Override\n+    public void visit(StrongEmphasis strongEmphasis) {\n+        html.tag(\"strong\", getAttrs(strongEmphasis, \"strong\"));\n+        visitChildren(strongEmphasis);\n+        html.tag(\"\/strong\");\n+    }\n+\n+    @Override\n+    public void visit(Text text) {\n+        html.text(text.getLiteral());\n+    }\n+\n+    @Override\n+    public void visit(Code code) {\n+        html.tag(\"code\", getAttrs(code, \"code\"));\n+        html.text(code.getLiteral());\n+        html.tag(\"\/code\");\n+    }\n+\n+    @Override\n+    public void visit(HtmlInline htmlInline) {\n+        if (context.shouldEscapeHtml()) {\n+            html.text(htmlInline.getLiteral());\n+        } else {\n+            html.raw(htmlInline.getLiteral());\n+        }\n+    }\n+\n+    @Override\n+    public void visit(SoftLineBreak softLineBreak) {\n+        html.raw(context.getSoftbreak());\n+    }\n+\n+    @Override\n+    public void visit(HardLineBreak hardLineBreak) {\n+        html.tag(\"br\", getAttrs(hardLineBreak, \"br\"), true);\n+        html.line();\n+    }\n+\n+    @Override\n+    protected void visitChildren(Node parent) {\n+        Node node = parent.getFirstChild();\n+        while (node != null) {\n+            Node next = node.getNext();\n+            context.render(node);\n+            node = next;\n+        }\n+    }\n+\n+    private void renderCodeBlock(String literal, Node node, Map<String, String> attributes) {\n+        html.line();\n+        html.tag(\"pre\", getAttrs(node, \"pre\"));\n+        html.tag(\"code\", getAttrs(node, \"code\", attributes));\n+        html.text(literal);\n+        html.tag(\"\/code\");\n+        html.tag(\"\/pre\");\n+        html.line();\n+    }\n+\n+    private void renderListBlock(ListBlock listBlock, String tagName, Map<String, String> attributes) {\n+        html.line();\n+        html.tag(tagName, attributes);\n+        html.line();\n+        visitChildren(listBlock);\n+        html.line();\n+        html.tag('\/' + tagName);\n+        html.line();\n+    }\n+\n+    private boolean isInTightList(Paragraph paragraph) {\n+        Node parent = paragraph.getParent();\n+        if (parent != null) {\n+            Node gramps = parent.getParent();\n+            if (gramps instanceof ListBlock) {\n+                ListBlock list = (ListBlock) gramps;\n+                return list.isTight();\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private Map<String, String> getAttrs(Node node, String tagName) {\n+        return getAttrs(node, tagName, Collections.<String, String>emptyMap());\n+    }\n+\n+    private Map<String, String> getAttrs(Node node, String tagName, Map<String, String> defaultAttributes) {\n+        return context.extendAttributes(node, tagName, defaultAttributes);\n+    }\n+\n+    private static class AltTextVisitor extends AbstractVisitor {\n+\n+        private final StringBuilder sb = new StringBuilder();\n+\n+        String getAltText() {\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public void visit(Text text) {\n+            sb.append(text.getLiteral());\n+        }\n+\n+        @Override\n+        public void visit(SoftLineBreak softLineBreak) {\n+            sb.append('\\n');\n+        }\n+\n+        @Override\n+        public void visit(HardLineBreak hardLineBreak) {\n+            sb.append('\\n');\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/CoreHtmlNodeRenderer.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+\/**\n+ *\n+ * Allows http, https and mailto protocols for url.\n+ * Also allows protocol relative urls, and relative urls.\n+ * Implementation based on https:\/\/github.com\/OWASP\/java-html-sanitizer\/blob\/f07e44b034a45d94d6fd010279073c38b6933072\/src\/main\/java\/org\/owasp\/html\/FilterUrlByProtocolAttributePolicy.java\n+ *\/\n+public class DefaultUrlSanitizer implements UrlSanitizer {\n+    private Set<String> protocols;\n+\n+    public DefaultUrlSanitizer() {\n+        this(Arrays.asList(\"http\", \"https\", \"mailto\"));\n+    }\n+\n+    public DefaultUrlSanitizer(Collection<String> protocols) {\n+        this.protocols = new HashSet<>(protocols);\n+    }\n+\n+    @Override\n+    public String sanitizeLinkUrl(String url) {\n+        url = stripHtmlSpaces(url);\n+        protocol_loop:\n+        for (int i = 0, n = url.length(); i < n; ++i) {\n+            switch (url.charAt(i)) {\n+                case '\/':\n+                case '#':\n+                case '?':  \/\/ No protocol.\n+                    break protocol_loop;\n+                case ':':\n+                    String protocol = url.substring(0, i).toLowerCase();\n+                    if (!protocols.contains(protocol)) {\n+                        return \"\";\n+                    }\n+                    break protocol_loop;\n+            }\n+        }\n+        return url;\n+    }\n+\n+\n+    @Override\n+    public String sanitizeImageUrl(String url) {\n+        return sanitizeLinkUrl(url);\n+    }\n+\n+    private String stripHtmlSpaces(String s) {\n+        int i = 0, n = s.length();\n+        for (; n > i; --n) {\n+            if (!isHtmlSpace(s.charAt(n - 1))) {\n+                break;\n+            }\n+        }\n+        for (; i < n; ++i) {\n+            if (!isHtmlSpace(s.charAt(i))) {\n+                break;\n+            }\n+        }\n+        if (i == 0 && n == s.length()) {\n+            return s;\n+        }\n+        return s.substring(i, n);\n+    }\n+\n+    private boolean isHtmlSpace(int ch) {\n+        switch (ch) {\n+            case ' ':\n+            case '\\t':\n+            case '\\n':\n+            case '\\u000c':\n+            case '\\r':\n+                return true;\n+            default:\n+                return false;\n+\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/DefaultUrlSanitizer.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import jdk.internal.org.commonmark.node.Image;\n+import jdk.internal.org.commonmark.node.Link;\n+import jdk.internal.org.commonmark.node.Node;\n+\n+import java.util.Map;\n+\n+public interface HtmlNodeRendererContext {\n+\n+    \/**\n+     * @param url to be encoded\n+     * @return an encoded URL (depending on the configuration)\n+     *\/\n+    String encodeUrl(String url);\n+\n+    \/**\n+     * Let extensions modify the HTML tag attributes.\n+     *\n+     * @param node the node for which the attributes are applied\n+     * @param tagName the HTML tag name that these attributes are for (e.g. {@code h1}, {@code pre}, {@code code}).\n+     * @param attributes the attributes that were calculated by the renderer\n+     * @return the extended attributes with added\/updated\/removed entries\n+     *\/\n+    Map<String, String> extendAttributes(Node node, String tagName, Map<String, String> attributes);\n+\n+    \/**\n+     * @return the HTML writer to use\n+     *\/\n+    HtmlWriter getWriter();\n+\n+    \/**\n+     * @return HTML that should be rendered for a soft line break\n+     *\/\n+    String getSoftbreak();\n+\n+    \/**\n+     * Render the specified node and its children using the configured renderers. This should be used to render child\n+     * nodes; be careful not to pass the node that is being rendered, that would result in an endless loop.\n+     *\n+     * @param node the node to render\n+     *\/\n+    void render(Node node);\n+\n+    \/**\n+     * @return whether HTML blocks and tags should be escaped or not\n+     *\/\n+    boolean shouldEscapeHtml();\n+\n+    \/**\n+     * @return true if the {@link UrlSanitizer} should be used.\n+     * @since 0.14.0\n+     *\/\n+    boolean shouldSanitizeUrls();\n+\n+    \/**\n+     * @return Sanitizer to use for securing {@link Link} href and {@link Image} src if {@link #shouldSanitizeUrls()} is true.\n+     * @since 0.14.0\n+     *\/\n+    UrlSanitizer urlSanitizer();\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/HtmlNodeRendererContext.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+\n+\/**\n+ * Factory for instantiating new node renderers when rendering is done.\n+ *\/\n+public interface HtmlNodeRendererFactory {\n+\n+    \/**\n+     * Create a new node renderer for the specified rendering context.\n+     *\n+     * @param context the context for rendering (normally passed on to the node renderer)\n+     * @return a node renderer\n+     *\/\n+    NodeRenderer create(HtmlNodeRendererContext context);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/HtmlNodeRendererFactory.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,337 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import jdk.internal.org.commonmark.Extension;\n+import jdk.internal.org.commonmark.internal.renderer.NodeRendererMap;\n+import jdk.internal.org.commonmark.internal.util.Escaping;\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.renderer.Renderer;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * Renders a tree of nodes to HTML.\n+ * <p>\n+ * Start with the {@link #builder} method to configure the renderer. Example:\n+ * <pre><code>\n+ * HtmlRenderer renderer = HtmlRenderer.builder().escapeHtml(true).build();\n+ * renderer.render(node);\n+ * <\/code><\/pre>\n+ *\/\n+public class HtmlRenderer implements Renderer {\n+\n+    private final String softbreak;\n+    private final boolean escapeHtml;\n+    private final boolean sanitizeUrls;\n+    private final UrlSanitizer urlSanitizer;\n+    private final boolean percentEncodeUrls;\n+    private final List<AttributeProviderFactory> attributeProviderFactories;\n+    private final List<HtmlNodeRendererFactory> nodeRendererFactories;\n+\n+    private HtmlRenderer(Builder builder) {\n+        this.softbreak = builder.softbreak;\n+        this.escapeHtml = builder.escapeHtml;\n+        this.sanitizeUrls = builder.sanitizeUrls;\n+        this.percentEncodeUrls = builder.percentEncodeUrls;\n+        this.urlSanitizer = builder.urlSanitizer;\n+        this.attributeProviderFactories = new ArrayList<>(builder.attributeProviderFactories);\n+\n+        this.nodeRendererFactories = new ArrayList<>(builder.nodeRendererFactories.size() + 1);\n+        this.nodeRendererFactories.addAll(builder.nodeRendererFactories);\n+        \/\/ Add as last. This means clients can override the rendering of core nodes if they want.\n+        this.nodeRendererFactories.add(new HtmlNodeRendererFactory() {\n+            @Override\n+            public NodeRenderer create(HtmlNodeRendererContext context) {\n+                return new CoreHtmlNodeRenderer(context);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Create a new builder for configuring an {@link HtmlRenderer}.\n+     *\n+     * @return a builder\n+     *\/\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public void render(Node node, Appendable output) {\n+        if (node == null) {\n+            throw new NullPointerException(\"node must not be null\");\n+        }\n+        RendererContext context = new RendererContext(new HtmlWriter(output));\n+        context.render(node);\n+    }\n+\n+    @Override\n+    public String render(Node node) {\n+        if (node == null) {\n+            throw new NullPointerException(\"node must not be null\");\n+        }\n+        StringBuilder sb = new StringBuilder();\n+        render(node, sb);\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Builder for configuring an {@link HtmlRenderer}. See methods for default configuration.\n+     *\/\n+    public static class Builder {\n+\n+        private String softbreak = \"\\n\";\n+        private boolean escapeHtml = false;\n+        private boolean sanitizeUrls = false;\n+        private UrlSanitizer urlSanitizer = new DefaultUrlSanitizer();\n+        private boolean percentEncodeUrls = false;\n+        private List<AttributeProviderFactory> attributeProviderFactories = new ArrayList<>();\n+        private List<HtmlNodeRendererFactory> nodeRendererFactories = new ArrayList<>();\n+\n+        \/**\n+         * @return the configured {@link HtmlRenderer}\n+         *\/\n+        public HtmlRenderer build() {\n+            return new HtmlRenderer(this);\n+        }\n+\n+        \/**\n+         * The HTML to use for rendering a softbreak, defaults to {@code \"\\n\"} (meaning the rendered result doesn't have\n+         * a line break).\n+         * <p>\n+         * Set it to {@code \"<br>\"} (or {@code \"<br \/>\"} to make them hard breaks.\n+         * <p>\n+         * Set it to {@code \" \"} to ignore line wrapping in the source.\n+         *\n+         * @param softbreak HTML for softbreak\n+         * @return {@code this}\n+         *\/\n+        public Builder softbreak(String softbreak) {\n+            this.softbreak = softbreak;\n+            return this;\n+        }\n+\n+        \/**\n+         * Whether {@link HtmlInline} and {@link HtmlBlock} should be escaped, defaults to {@code false}.\n+         * <p>\n+         * Note that {@link HtmlInline} is only a tag itself, not the text between an opening tag and a closing tag. So\n+         * markup in the text will be parsed as normal and is not affected by this option.\n+         *\n+         * @param escapeHtml true for escaping, false for preserving raw HTML\n+         * @return {@code this}\n+         *\/\n+        public Builder escapeHtml(boolean escapeHtml) {\n+            this.escapeHtml = escapeHtml;\n+            return this;\n+        }\n+\n+        \/**\n+         * Whether {@link Image} src and {@link Link} href should be sanitized, defaults to {@code false}.\n+         *\n+         * @param sanitizeUrls true for sanitization, false for preserving raw attribute\n+         * @return {@code this}\n+         * @since 0.14.0\n+         *\/\n+        public Builder sanitizeUrls(boolean sanitizeUrls) {\n+            this.sanitizeUrls = sanitizeUrls;\n+            return this;\n+        }\n+\n+        \/**\n+         * {@link UrlSanitizer} used to filter URL's if {@link #sanitizeUrls} is true.\n+         *\n+         * @param urlSanitizer Filterer used to filter {@link Image} src and {@link Link}.\n+         * @return {@code this}\n+         * @since 0.14.0\n+         *\/\n+        public Builder urlSanitizer(UrlSanitizer urlSanitizer) {\n+            this.urlSanitizer = urlSanitizer;\n+            return this;\n+        }\n+\n+        \/**\n+         * Whether URLs of link or images should be percent-encoded, defaults to {@code false}.\n+         * <p>\n+         * If enabled, the following is done:\n+         * <ul>\n+         * <li>Existing percent-encoded parts are preserved (e.g. \"%20\" is kept as \"%20\")<\/li>\n+         * <li>Reserved characters such as \"\/\" are preserved, except for \"[\" and \"]\" (see encodeURI in JS)<\/li>\n+         * <li>Unreserved characters such as \"a\" are preserved<\/li>\n+         * <li>Other characters such umlauts are percent-encoded<\/li>\n+         * <\/ul>\n+         *\n+         * @param percentEncodeUrls true to percent-encode, false for leaving as-is\n+         * @return {@code this}\n+         *\/\n+        public Builder percentEncodeUrls(boolean percentEncodeUrls) {\n+            this.percentEncodeUrls = percentEncodeUrls;\n+            return this;\n+        }\n+\n+        \/**\n+         * Add a factory for an attribute provider for adding\/changing HTML attributes to the rendered tags.\n+         *\n+         * @param attributeProviderFactory the attribute provider factory to add\n+         * @return {@code this}\n+         *\/\n+        public Builder attributeProviderFactory(AttributeProviderFactory attributeProviderFactory) {\n+            if (attributeProviderFactory == null) {\n+                throw new NullPointerException(\"attributeProviderFactory must not be null\");\n+            }\n+            this.attributeProviderFactories.add(attributeProviderFactory);\n+            return this;\n+        }\n+\n+        \/**\n+         * Add a factory for instantiating a node renderer (done when rendering). This allows to override the rendering\n+         * of node types or define rendering for custom node types.\n+         * <p>\n+         * If multiple node renderers for the same node type are created, the one from the factory that was added first\n+         * \"wins\". (This is how the rendering for core node types can be overridden; the default rendering comes last.)\n+         *\n+         * @param nodeRendererFactory the factory for creating a node renderer\n+         * @return {@code this}\n+         *\/\n+        public Builder nodeRendererFactory(HtmlNodeRendererFactory nodeRendererFactory) {\n+            if (nodeRendererFactory == null) {\n+                throw new NullPointerException(\"nodeRendererFactory must not be null\");\n+            }\n+            this.nodeRendererFactories.add(nodeRendererFactory);\n+            return this;\n+        }\n+\n+        \/**\n+         * @param extensions extensions to use on this HTML renderer\n+         * @return {@code this}\n+         *\/\n+        public Builder extensions(Iterable<? extends Extension> extensions) {\n+            if (extensions == null) {\n+                throw new NullPointerException(\"extensions must not be null\");\n+            }\n+            for (Extension extension : extensions) {\n+                if (extension instanceof HtmlRendererExtension) {\n+                    HtmlRendererExtension htmlRendererExtension = (HtmlRendererExtension) extension;\n+                    htmlRendererExtension.extend(this);\n+                }\n+            }\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * Extension for {@link HtmlRenderer}.\n+     *\/\n+    public interface HtmlRendererExtension extends Extension {\n+        void extend(Builder rendererBuilder);\n+    }\n+\n+    private class RendererContext implements HtmlNodeRendererContext, AttributeProviderContext {\n+\n+        private final HtmlWriter htmlWriter;\n+        private final List<AttributeProvider> attributeProviders;\n+        private final NodeRendererMap nodeRendererMap = new NodeRendererMap();\n+\n+        private RendererContext(HtmlWriter htmlWriter) {\n+            this.htmlWriter = htmlWriter;\n+\n+            attributeProviders = new ArrayList<>(attributeProviderFactories.size());\n+            for (AttributeProviderFactory attributeProviderFactory : attributeProviderFactories) {\n+                attributeProviders.add(attributeProviderFactory.create(this));\n+            }\n+\n+            \/\/ The first node renderer for a node type \"wins\".\n+            for (int i = nodeRendererFactories.size() - 1; i >= 0; i--) {\n+                HtmlNodeRendererFactory nodeRendererFactory = nodeRendererFactories.get(i);\n+                NodeRenderer nodeRenderer = nodeRendererFactory.create(this);\n+                nodeRendererMap.add(nodeRenderer);\n+            }\n+        }\n+\n+        @Override\n+        public boolean shouldEscapeHtml() {\n+            return escapeHtml;\n+        }\n+\n+        @Override\n+        public boolean shouldSanitizeUrls() {\n+            return sanitizeUrls;\n+        }\n+\n+        @Override\n+        public UrlSanitizer urlSanitizer() {\n+            return urlSanitizer;\n+        }\n+\n+        @Override\n+        public String encodeUrl(String url) {\n+            if (percentEncodeUrls) {\n+                return Escaping.percentEncodeUrl(url);\n+            } else {\n+                return url;\n+            }\n+        }\n+\n+        @Override\n+        public Map<String, String> extendAttributes(Node node, String tagName, Map<String, String> attributes) {\n+            Map<String, String> attrs = new LinkedHashMap<>(attributes);\n+            setCustomAttributes(node, tagName, attrs);\n+            return attrs;\n+        }\n+\n+        @Override\n+        public HtmlWriter getWriter() {\n+            return htmlWriter;\n+        }\n+\n+        @Override\n+        public String getSoftbreak() {\n+            return softbreak;\n+        }\n+\n+        @Override\n+        public void render(Node node) {\n+            nodeRendererMap.render(node);\n+        }\n+\n+        private void setCustomAttributes(Node node, String tagName, Map<String, String> attrs) {\n+            for (AttributeProvider attributeProvider : attributeProviders) {\n+                attributeProvider.setAttributes(node, tagName, attrs);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/HtmlRenderer.java","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import jdk.internal.org.commonmark.internal.util.Escaping;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+public class HtmlWriter {\n+\n+    private static final Map<String, String> NO_ATTRIBUTES = Collections.emptyMap();\n+\n+    private final Appendable buffer;\n+    private char lastChar = 0;\n+\n+    public HtmlWriter(Appendable out) {\n+        if (out == null) {\n+            throw new NullPointerException(\"out must not be null\");\n+        }\n+        this.buffer = out;\n+    }\n+\n+    public void raw(String s) {\n+        append(s);\n+    }\n+\n+    public void text(String text) {\n+        append(Escaping.escapeHtml(text));\n+    }\n+\n+    public void tag(String name) {\n+        tag(name, NO_ATTRIBUTES);\n+    }\n+\n+    public void tag(String name, Map<String, String> attrs) {\n+        tag(name, attrs, false);\n+    }\n+\n+    public void tag(String name, Map<String, String> attrs, boolean voidElement) {\n+        append(\"<\");\n+        append(name);\n+        if (attrs != null && !attrs.isEmpty()) {\n+            for (Map.Entry<String, String> attrib : attrs.entrySet()) {\n+                append(\" \");\n+                append(Escaping.escapeHtml(attrib.getKey()));\n+                append(\"=\\\"\");\n+                append(Escaping.escapeHtml(attrib.getValue()));\n+                append(\"\\\"\");\n+            }\n+        }\n+        if (voidElement) {\n+            append(\" \/\");\n+        }\n+\n+        append(\">\");\n+    }\n+\n+    public void line() {\n+        if (lastChar != 0 && lastChar != '\\n') {\n+            append(\"\\n\");\n+        }\n+    }\n+\n+    protected void append(String s) {\n+        try {\n+            buffer.append(s);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        int length = s.length();\n+        if (length != 0) {\n+            lastChar = s.charAt(length - 1);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/HtmlWriter.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import jdk.internal.org.commonmark.node.Image;\n+import jdk.internal.org.commonmark.node.Link;\n+\n+\/**\n+ * Sanitizes urls for img and a elements by whitelisting protocols.\n+ * This is intended to prevent XSS payloads like [Click this totally safe url](javascript:document.xss=true;)\n+ * <p>\n+ * Implementation based on https:\/\/github.com\/OWASP\/java-html-sanitizer\/blob\/f07e44b034a45d94d6fd010279073c38b6933072\/src\/main\/java\/org\/owasp\/html\/FilterUrlByProtocolAttributePolicy.java\n+ *\n+ * @since 0.14.0\n+ *\/\n+public interface UrlSanitizer {\n+    \/**\n+     * Sanitize a url for use in the href attribute of a {@link Link}.\n+     *\n+     * @param url Link to sanitize\n+     * @return Sanitized link\n+     *\/\n+    String sanitizeLinkUrl(String url);\n+\n+    \/**\n+     * Sanitize a url for use in the src attribute of a {@link Image}.\n+     *\n+     * @param url Link to sanitize\n+     * @return Sanitized link {@link Image}\n+     *\/\n+    String sanitizeImageUrl(String url);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/UrlSanitizer.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * HTML rendering (see {@link org.commonmark.renderer.html.HtmlRenderer})\n+ *\/\n+package jdk.internal.org.commonmark.renderer.html;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/package-info.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,312 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.text;\n+\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.internal.renderer.text.BulletListHolder;\n+import jdk.internal.org.commonmark.internal.renderer.text.ListHolder;\n+import jdk.internal.org.commonmark.internal.renderer.text.OrderedListHolder;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+\/**\n+ * The node renderer that renders all the core nodes (comes last in the order of node renderers).\n+ *\/\n+public class CoreTextContentNodeRenderer extends AbstractVisitor implements NodeRenderer {\n+\n+    protected final TextContentNodeRendererContext context;\n+    private final TextContentWriter textContent;\n+\n+    private ListHolder listHolder;\n+\n+    public CoreTextContentNodeRenderer(TextContentNodeRendererContext context) {\n+        this.context = context;\n+        this.textContent = context.getWriter();\n+    }\n+\n+    @Override\n+    public Set<Class<? extends Node>> getNodeTypes() {\n+        return new HashSet<>(Arrays.asList(\n+                Document.class,\n+                Heading.class,\n+                Paragraph.class,\n+                BlockQuote.class,\n+                BulletList.class,\n+                FencedCodeBlock.class,\n+                HtmlBlock.class,\n+                ThematicBreak.class,\n+                IndentedCodeBlock.class,\n+                Link.class,\n+                ListItem.class,\n+                OrderedList.class,\n+                Image.class,\n+                Emphasis.class,\n+                StrongEmphasis.class,\n+                Text.class,\n+                Code.class,\n+                HtmlInline.class,\n+                SoftLineBreak.class,\n+                HardLineBreak.class\n+        ));\n+    }\n+\n+    @Override\n+    public void render(Node node) {\n+        node.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(Document document) {\n+        \/\/ No rendering itself\n+        visitChildren(document);\n+    }\n+\n+    @Override\n+    public void visit(BlockQuote blockQuote) {\n+        textContent.write('\\u00ab');\n+        visitChildren(blockQuote);\n+        textContent.write('\\u00bb');\n+\n+        writeEndOfLineIfNeeded(blockQuote, null);\n+    }\n+\n+    @Override\n+    public void visit(BulletList bulletList) {\n+        if (listHolder != null) {\n+            writeEndOfLine();\n+        }\n+        listHolder = new BulletListHolder(listHolder, bulletList);\n+        visitChildren(bulletList);\n+        writeEndOfLineIfNeeded(bulletList, null);\n+        if (listHolder.getParent() != null) {\n+            listHolder = listHolder.getParent();\n+        } else {\n+            listHolder = null;\n+        }\n+    }\n+\n+    @Override\n+    public void visit(Code code) {\n+        textContent.write('\\\"');\n+        textContent.write(code.getLiteral());\n+        textContent.write('\\\"');\n+    }\n+\n+    @Override\n+    public void visit(FencedCodeBlock fencedCodeBlock) {\n+        if (context.stripNewlines()) {\n+            textContent.writeStripped(fencedCodeBlock.getLiteral());\n+            writeEndOfLineIfNeeded(fencedCodeBlock, null);\n+        } else {\n+            textContent.write(fencedCodeBlock.getLiteral());\n+        }\n+    }\n+\n+    @Override\n+    public void visit(HardLineBreak hardLineBreak) {\n+        writeEndOfLineIfNeeded(hardLineBreak, null);\n+    }\n+\n+    @Override\n+    public void visit(Heading heading) {\n+        visitChildren(heading);\n+        writeEndOfLineIfNeeded(heading, ':');\n+    }\n+\n+    @Override\n+    public void visit(ThematicBreak thematicBreak) {\n+        if (!context.stripNewlines()) {\n+            textContent.write(\"***\");\n+        }\n+        writeEndOfLineIfNeeded(thematicBreak, null);\n+    }\n+\n+    @Override\n+    public void visit(HtmlInline htmlInline) {\n+        writeText(htmlInline.getLiteral());\n+    }\n+\n+    @Override\n+    public void visit(HtmlBlock htmlBlock) {\n+        writeText(htmlBlock.getLiteral());\n+    }\n+\n+    @Override\n+    public void visit(Image image) {\n+        writeLink(image, image.getTitle(), image.getDestination());\n+    }\n+\n+    @Override\n+    public void visit(IndentedCodeBlock indentedCodeBlock) {\n+        if (context.stripNewlines()) {\n+            textContent.writeStripped(indentedCodeBlock.getLiteral());\n+            writeEndOfLineIfNeeded(indentedCodeBlock, null);\n+        } else {\n+            textContent.write(indentedCodeBlock.getLiteral());\n+        }\n+    }\n+\n+    @Override\n+    public void visit(Link link) {\n+        writeLink(link, link.getTitle(), link.getDestination());\n+    }\n+\n+    @Override\n+    public void visit(ListItem listItem) {\n+        if (listHolder != null && listHolder instanceof OrderedListHolder) {\n+            OrderedListHolder orderedListHolder = (OrderedListHolder) listHolder;\n+            String indent = context.stripNewlines() ? \"\" : orderedListHolder.getIndent();\n+            textContent.write(indent + orderedListHolder.getCounter() + orderedListHolder.getDelimiter() + \" \");\n+            visitChildren(listItem);\n+            writeEndOfLineIfNeeded(listItem, null);\n+            orderedListHolder.increaseCounter();\n+        } else if (listHolder != null && listHolder instanceof BulletListHolder) {\n+            BulletListHolder bulletListHolder = (BulletListHolder) listHolder;\n+            if (!context.stripNewlines()) {\n+                textContent.write(bulletListHolder.getIndent() + bulletListHolder.getMarker() + \" \");\n+            }\n+            visitChildren(listItem);\n+            writeEndOfLineIfNeeded(listItem, null);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(OrderedList orderedList) {\n+        if (listHolder != null) {\n+            writeEndOfLine();\n+        }\n+        listHolder = new OrderedListHolder(listHolder, orderedList);\n+        visitChildren(orderedList);\n+        writeEndOfLineIfNeeded(orderedList, null);\n+        if (listHolder.getParent() != null) {\n+            listHolder = listHolder.getParent();\n+        } else {\n+            listHolder = null;\n+        }\n+    }\n+\n+    @Override\n+    public void visit(Paragraph paragraph) {\n+        visitChildren(paragraph);\n+        \/\/ Add \"end of line\" only if its \"root paragraph.\n+        if (paragraph.getParent() == null || paragraph.getParent() instanceof Document) {\n+            writeEndOfLineIfNeeded(paragraph, null);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(SoftLineBreak softLineBreak) {\n+        writeEndOfLineIfNeeded(softLineBreak, null);\n+    }\n+\n+    @Override\n+    public void visit(Text text) {\n+        writeText(text.getLiteral());\n+    }\n+\n+    @Override\n+    protected void visitChildren(Node parent) {\n+        Node node = parent.getFirstChild();\n+        while (node != null) {\n+            Node next = node.getNext();\n+            context.render(node);\n+            node = next;\n+        }\n+    }\n+\n+    private void writeText(String text) {\n+        if (context.stripNewlines()) {\n+            textContent.writeStripped(text);\n+        } else {\n+            textContent.write(text);\n+        }\n+    }\n+\n+    private void writeLink(Node node, String title, String destination) {\n+        boolean hasChild = node.getFirstChild() != null;\n+        boolean hasTitle = title != null && !title.equals(destination);\n+        boolean hasDestination = destination != null && !destination.equals(\"\");\n+\n+        if (hasChild) {\n+            textContent.write('\"');\n+            visitChildren(node);\n+            textContent.write('\"');\n+            if (hasTitle || hasDestination) {\n+                textContent.whitespace();\n+                textContent.write('(');\n+            }\n+        }\n+\n+        if (hasTitle) {\n+            textContent.write(title);\n+            if (hasDestination) {\n+                textContent.colon();\n+                textContent.whitespace();\n+            }\n+        }\n+\n+        if (hasDestination) {\n+            textContent.write(destination);\n+        }\n+\n+        if (hasChild && (hasTitle || hasDestination)) {\n+            textContent.write(')');\n+        }\n+    }\n+\n+    private void writeEndOfLineIfNeeded(Node node, Character c) {\n+        if (context.stripNewlines()) {\n+            if (c != null) {\n+                textContent.write(c);\n+            }\n+            if (node.getNext() != null) {\n+                textContent.whitespace();\n+            }\n+        } else {\n+            if (node.getNext() != null) {\n+                textContent.line();\n+            }\n+        }\n+    }\n+\n+    private void writeEndOfLine() {\n+        if (context.stripNewlines()) {\n+            textContent.whitespace();\n+        } else {\n+            textContent.line();\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/text\/CoreTextContentNodeRenderer.java","additions":312,"deletions":0,"binary":false,"changes":312,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.text;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+public interface TextContentNodeRendererContext {\n+\n+    \/**\n+     * @return true for stripping new lines and render text as \"single line\",\n+     * false for keeping all line breaks.\n+     *\/\n+    boolean stripNewlines();\n+\n+    \/**\n+     * @return the writer to use\n+     *\/\n+    TextContentWriter getWriter();\n+\n+    \/**\n+     * Render the specified node and its children using the configured renderers. This should be used to render child\n+     * nodes; be careful not to pass the node that is being rendered, that would result in an endless loop.\n+     *\n+     * @param node the node to render\n+     *\/\n+    void render(Node node);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/text\/TextContentNodeRendererContext.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.text;\n+\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+\n+\/**\n+ * Factory for instantiating new node renderers when rendering is done.\n+ *\/\n+public interface TextContentNodeRendererFactory {\n+\n+    \/**\n+     * Create a new node renderer for the specified rendering context.\n+     *\n+     * @param context the context for rendering (normally passed on to the node renderer)\n+     * @return a node renderer\n+     *\/\n+    NodeRenderer create(TextContentNodeRendererContext context);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/text\/TextContentNodeRendererFactory.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.text;\n+\n+import jdk.internal.org.commonmark.Extension;\n+import jdk.internal.org.commonmark.internal.renderer.NodeRendererMap;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.renderer.Renderer;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class TextContentRenderer implements Renderer {\n+\n+    private final boolean stripNewlines;\n+\n+    private final List<TextContentNodeRendererFactory> nodeRendererFactories;\n+\n+    private TextContentRenderer(Builder builder) {\n+        this.stripNewlines = builder.stripNewlines;\n+\n+        this.nodeRendererFactories = new ArrayList<>(builder.nodeRendererFactories.size() + 1);\n+        this.nodeRendererFactories.addAll(builder.nodeRendererFactories);\n+        \/\/ Add as last. This means clients can override the rendering of core nodes if they want.\n+        this.nodeRendererFactories.add(new TextContentNodeRendererFactory() {\n+            @Override\n+            public NodeRenderer create(TextContentNodeRendererContext context) {\n+                return new CoreTextContentNodeRenderer(context);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Create a new builder for configuring an {@link TextContentRenderer}.\n+     *\n+     * @return a builder\n+     *\/\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public void render(Node node, Appendable output) {\n+        RendererContext context = new RendererContext(new TextContentWriter(output));\n+        context.render(node);\n+    }\n+\n+    @Override\n+    public String render(Node node) {\n+        StringBuilder sb = new StringBuilder();\n+        render(node, sb);\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Builder for configuring an {@link TextContentRenderer}. See methods for default configuration.\n+     *\/\n+    public static class Builder {\n+\n+        private boolean stripNewlines = false;\n+        private List<TextContentNodeRendererFactory> nodeRendererFactories = new ArrayList<>();\n+\n+        \/**\n+         * @return the configured {@link TextContentRenderer}\n+         *\/\n+        public TextContentRenderer build() {\n+            return new TextContentRenderer(this);\n+        }\n+\n+        \/**\n+         * Set the value of flag for stripping new lines.\n+         *\n+         * @param stripNewlines true for stripping new lines and render text as \"single line\",\n+         *                      false for keeping all line breaks\n+         * @return {@code this}\n+         *\/\n+        public Builder stripNewlines(boolean stripNewlines) {\n+            this.stripNewlines = stripNewlines;\n+            return this;\n+        }\n+\n+        \/**\n+         * Add a factory for instantiating a node renderer (done when rendering). This allows to override the rendering\n+         * of node types or define rendering for custom node types.\n+         * <p>\n+         * If multiple node renderers for the same node type are created, the one from the factory that was added first\n+         * \"wins\". (This is how the rendering for core node types can be overridden; the default rendering comes last.)\n+         *\n+         * @param nodeRendererFactory the factory for creating a node renderer\n+         * @return {@code this}\n+         *\/\n+        public Builder nodeRendererFactory(TextContentNodeRendererFactory nodeRendererFactory) {\n+            this.nodeRendererFactories.add(nodeRendererFactory);\n+            return this;\n+        }\n+\n+        \/**\n+         * @param extensions extensions to use on this text content renderer\n+         * @return {@code this}\n+         *\/\n+        public Builder extensions(Iterable<? extends Extension> extensions) {\n+            for (Extension extension : extensions) {\n+                if (extension instanceof TextContentRenderer.TextContentRendererExtension) {\n+                    TextContentRenderer.TextContentRendererExtension textContentRendererExtension =\n+                            (TextContentRenderer.TextContentRendererExtension) extension;\n+                    textContentRendererExtension.extend(this);\n+                }\n+            }\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * Extension for {@link TextContentRenderer}.\n+     *\/\n+    public interface TextContentRendererExtension extends Extension {\n+        void extend(TextContentRenderer.Builder rendererBuilder);\n+    }\n+\n+    private class RendererContext implements TextContentNodeRendererContext {\n+        private final TextContentWriter textContentWriter;\n+        private final NodeRendererMap nodeRendererMap = new NodeRendererMap();\n+\n+        private RendererContext(TextContentWriter textContentWriter) {\n+            this.textContentWriter = textContentWriter;\n+\n+            \/\/ The first node renderer for a node type \"wins\".\n+            for (int i = nodeRendererFactories.size() - 1; i >= 0; i--) {\n+                TextContentNodeRendererFactory nodeRendererFactory = nodeRendererFactories.get(i);\n+                NodeRenderer nodeRenderer = nodeRendererFactory.create(this);\n+                nodeRendererMap.add(nodeRenderer);\n+            }\n+        }\n+\n+        @Override\n+        public boolean stripNewlines() {\n+            return stripNewlines;\n+        }\n+\n+        @Override\n+        public TextContentWriter getWriter() {\n+            return textContentWriter;\n+        }\n+\n+        @Override\n+        public void render(Node node) {\n+            nodeRendererMap.render(node);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/text\/TextContentRenderer.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.text;\n+\n+import java.io.IOException;\n+\n+public class TextContentWriter {\n+\n+    private final Appendable buffer;\n+\n+    private char lastChar;\n+\n+    public TextContentWriter(Appendable out) {\n+        buffer = out;\n+    }\n+\n+    public void whitespace() {\n+        if (lastChar != 0 && lastChar != ' ') {\n+            append(' ');\n+        }\n+    }\n+\n+    public void colon() {\n+        if (lastChar != 0 && lastChar != ':') {\n+            append(':');\n+        }\n+    }\n+\n+    public void line() {\n+        if (lastChar != 0 && lastChar != '\\n') {\n+            append('\\n');\n+        }\n+    }\n+\n+    public void writeStripped(String s) {\n+        append(s.replaceAll(\"[\\\\r\\\\n\\\\s]+\", \" \"));\n+    }\n+\n+    public void write(String s) {\n+        append(s);\n+    }\n+\n+    public void write(char c) {\n+        append(c);\n+    }\n+\n+    private void append(String s) {\n+        try {\n+            buffer.append(s);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        int length = s.length();\n+        if (length != 0) {\n+            lastChar = s.charAt(length - 1);\n+        }\n+    }\n+\n+    private void append(char c) {\n+        try {\n+            buffer.append(c);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        lastChar = c;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/text\/TextContentWriter.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * Text content rendering (see {@link org.commonmark.renderer.text.TextContentRenderer})\n+ *\/\n+package jdk.internal.org.commonmark.renderer.text;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/text\/package-info.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Internal support for Markdown.\n+ *\n+ * @since 22\n+ *\/\n+module jdk.internal.md {\n+    requires jdk.compiler;\n+\n+    exports jdk.internal.markdown to\n+            jdk.javadoc,\n+            jdk.jshell;\n+    exports jdk.internal.org.commonmark to\n+            jdk.javadoc,\n+            jdk.jshell;\n+    exports jdk.internal.org.commonmark.ext.gfm.tables to\n+            jdk.javadoc,\n+            jdk.jshell;\n+    exports jdk.internal.org.commonmark.node to\n+            jdk.javadoc,\n+            jdk.jshell;\n+    exports jdk.internal.org.commonmark.parser to\n+            jdk.javadoc,\n+            jdk.jshell;\n+    exports jdk.internal.org.commonmark.renderer to\n+            jdk.javadoc,\n+            jdk.jshell;\n+    exports jdk.internal.org.commonmark.renderer.html to\n+            jdk.javadoc,\n+            jdk.jshell;\n+\n+    provides com.sun.source.util.DocTrees.DocCommentTreeTransformer\n+            with jdk.internal.markdown.MarkdownTransformer;\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/module-info.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+## CommonMark 0.21.0\n+\n+### CommonMark License\n+```\n+Copyright (c) 2015, Atlassian Pty Ltd\n+All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are met:\n+\n+* Redistributions of source code must retain the above copyright notice, this\n+  list of conditions and the following disclaimer.\n+\n+* Redistributions in binary form must reproduce the above copyright notice,\n+  this list of conditions and the following disclaimer in the documentation\n+  and\/or other materials provided with the distribution.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+```\n","filename":"src\/jdk.internal.md\/share\/legal\/commonmark.md","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -161,2 +161,3 @@\n-                    if (Utils.toLowerCase(srcfile.getPath()).endsWith(\".html\")) {\n-                        handleHtmlFile(srcfile, dstDocPath);\n+                    var path = Utils.toLowerCase(srcfile.getPath());\n+                    if (path.endsWith(\".html\") || path.endsWith(\".md\")) {\n+                        handleDocFile(srcfile, dstDocPath);\n@@ -189,1 +190,1 @@\n-    private void handleHtmlFile(DocFile srcFile, DocPath dstPath) throws DocletException {\n+    private void handleDocFile(DocFile srcFile, DocPath dstPath) throws DocletException {\n@@ -192,1 +193,1 @@\n-        var path = dstPath.resolve(srcFile.getName());\n+        var path = dstPath.resolve(srcFile.getName().replaceAll(\"\\\\.[a-z]+$\", \".html\"));\n@@ -247,2 +248,2 @@\n-        private String getWindowTitle(HtmlDocletWriter docletWriter, Element element) {\n-            String t = configuration.utils.getHTMLTitle(element);\n+        private String getWindowTitle(HtmlDocletWriter docletWriter, DocFileElement element) {\n+            var t = docletWriter.getFileTitle(element);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/DocFilesHandler.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.DocFileElement;\n@@ -73,1 +73,1 @@\n-    final Map<Element, String> titles = new WeakHashMap<>();\n+    final Map<DocFileElement, String> titles = new WeakHashMap<>();\n@@ -277,1 +277,1 @@\n-        Element element = i.getElement();\n+        var element = i.getElement();\n@@ -281,5 +281,3 @@\n-        } else if (element instanceof DocletElement e) {\n-            \/\/ Implementations of DocletElement do not override equals and\n-            \/\/ hashCode; putting instances of DocletElement in a map is not\n-            \/\/ incorrect, but might well be inefficient\n-            String t = titles.computeIfAbsent(element, utils::getHTMLTitle);\n+        } else if (element instanceof DocFileElement e) {\n+            var fo = e.getFileObject();\n+            var t = titles.computeIfAbsent(e, this::getFileTitle);\n@@ -289,1 +287,1 @@\n-                Path p = Path.of(e.getFileObject().toUri());\n+                Path p = Path.of(fo.toUri());\n@@ -292,4 +290,4 @@\n-            ContentBuilder b = new ContentBuilder();\n-            b.add(HtmlTree.CODE(Text.of(i.getHolder() + \": \")));\n-            \/\/ non-program elements should be displayed using a normal font\n-            b.add(t);\n+            var b = new ContentBuilder()\n+                    .add(HtmlTree.CODE(Text.of(i.getHolder() + \": \")))\n+                    \/\/ non-program elements should be displayed using a normal font\n+                    .add(t);\n@@ -299,1 +297,1 @@\n-            Content link = links.createLink(pathToRoot.resolve(i.getUrl()), i.getHolder());\n+            var link = links.createLink(pathToRoot.resolve(i.getUrl()), i.getHolder());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ExternalSpecsWriter.java","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import jdk.internal.markdown.MarkdownTransformer;\n@@ -326,0 +327,6 @@\n+        if (doclint == null) {\n+            var trees = docEnv.getDocTrees();\n+            if (trees.getDocCommentTreeTransformer()== null) {\n+                trees.setDocCommentTreeTransformer(new MarkdownTransformer());\n+            }\n+        }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import javax.lang.model.element.ElementKind;\n@@ -77,0 +78,1 @@\n+import com.sun.source.doctree.RawTextTree;\n@@ -82,0 +84,13 @@\n+import jdk.internal.org.commonmark.Extension;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TablesExtension;\n+import jdk.internal.org.commonmark.node.AbstractVisitor;\n+import jdk.internal.org.commonmark.node.Code;\n+import jdk.internal.org.commonmark.node.Heading;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.parser.Parser;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.renderer.html.HtmlNodeRendererContext;\n+import jdk.internal.org.commonmark.renderer.html.HtmlNodeRendererFactory;\n+import jdk.internal.org.commonmark.renderer.html.HtmlRenderer;\n+import jdk.internal.org.commonmark.renderer.html.HtmlWriter;\n+\n@@ -97,0 +112,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.DocFileElement;\n@@ -501,1 +517,4 @@\n-     * Get the window title.\n+     * Returns the window title.\n+     *\n+     * The window title is the composition of the given title and\n+     * any value set by the window-title option.\n@@ -513,0 +532,99 @@\n+    \/**\n+     * {@return the title for a doc-file element}\n+     *\n+     * For an HTML file, the title is as given in the {@code <title>} element,\n+     * as found in the preamble of the doc-comment tree.\n+     *\n+     * For a Markdown file, there is no direct representation of the page title,\n+     * and so the content of the {@code <h1>} heading is used.\n+     *\n+     * @param element the doc-file element\n+     *\/\n+    public String getFileTitle(DocFileElement element) {\n+        var fileName = element.getFileObject().getName();\n+        if (fileName.endsWith(\".html\")) {\n+            return getTextContent(utils.getPreamble(element), \"title\");\n+        } else if (fileName.endsWith(\".md\")) {\n+            var c = commentTagsToContent(element, utils.getBody(element), false);\n+            return getHeadingText(c);\n+        } else {\n+            throw new IllegalArgumentException(fileName);\n+        }\n+    }\n+\n+    \/**\n+     * {@returns the plain-text content of a named HTML element in a list of content}\n+     *\n+     * @param trees the list of content\n+     * @param name the name og the HTML element\n+     *\/\n+    private String getTextContent(List<? extends DocTree> trees, String name) {\n+        var sb = new StringBuilder();\n+        var collectText = false;\n+        loop:\n+        for (DocTree dt : trees) {\n+            switch (dt.getKind()) {\n+                case START_ELEMENT -> {\n+                    var nodeStart = (StartElementTree) dt;\n+                    if (nodeStart.getName().toString().equalsIgnoreCase(name)) {\n+                        collectText = true;\n+                    }\n+                }\n+                case END_ELEMENT -> {\n+                    var nodeEnd = (EndElementTree) dt;\n+                    if (nodeEnd.getName().toString().equalsIgnoreCase(name)) {\n+                        break loop;\n+                    }\n+                }\n+                case TEXT -> {\n+                    var nodeText = (TextTree) dt;\n+                    if (collectText)\n+                        sb.append(nodeText.getBody());\n+                }\n+                default -> {\n+                }\n+                \/\/ do nothing\n+            }\n+        }\n+        return sb.toString().trim();\n+    }\n+\n+    \/**\n+     * {@return the content of the {@code <h1>} heading in the given content,\n+     * or an empty string if there is no such heading}\n+     *\n+     * The heading must be at the beginning of the content.\n+     * It may be represented in either an HTML tree with tag name {@code h1}\n+     * or in a raw HTML node.\n+     *\n+     * @param c the content\n+     *\/\n+    private String getHeadingText(Content c) {\n+        var sb = new StringBuilder();\n+        if (c instanceof ContentBuilder cb) {\n+            var contents = cb.getContents();\n+            if (!contents.isEmpty()) {\n+                var first = contents.get(0);\n+                if (first instanceof HtmlTree htmlTree && htmlTree.tagName.equals(TagName.H1)) {\n+                    for (var c2 : htmlTree.getContents()) {\n+                        if (c2 instanceof Text t) {\n+                            sb.append(t.toString());\n+                        } else if (c2 instanceof TextBuilder tb) {\n+                            sb.append(tb.toString());\n+                        }\n+                    }\n+                    return sb.toString();\n+                } else if (first instanceof RawHtml rawHtml) {\n+                    Pattern h1 = Pattern.compile(\"<h1[^>]*>(.*)<\/h1>\");\n+                    Matcher m = h1.matcher(rawHtml.toString());\n+                    if (m.lookingAt()) {\n+                        var heading = m.group(1);\n+                        var headingText = heading.replaceAll(\"<\/?[^>]+>\", \"\");\n+                        return headingText;\n+                    }\n+                }\n+            }\n+        }\n+        return \"\";\n+    }\n+\n@@ -1234,1 +1352,4 @@\n-        for (ListIterator<? extends DocTree> iterator = trees.listIterator(); iterator.hasNext();) {\n+        var useMarkdown = trees.stream().anyMatch(t -> t.getKind() == Kind.MARKDOWN);\n+        var markdownHandler = useMarkdown ? new MarkdownHandler(element) : null;\n+\n+        for (ListIterator<? extends DocTree> iterator = trees.listIterator(); iterator.hasNext(); ) {\n@@ -1237,1 +1358,1 @@\n-            boolean isLastNode  = !iterator.hasNext();\n+            boolean isLastNode = !iterator.hasNext();\n@@ -1257,1 +1378,82 @@\n-            var docTreeVisitor = new SimpleDocTreeVisitor<Boolean, Content>() {\n+            var docTreeVisitor = new InlineVisitor(element, tag, isLastNode, context, ch, trees);\n+            boolean allDone = useMarkdown\n+                    ? markdownHandler.handle(tag, docTreeVisitor)\n+                    : docTreeVisitor.visit(tag, result);\n+            commentRemoved = false;\n+\n+            if (allDone)\n+                break;\n+        }\n+\n+        if (useMarkdown) {\n+            markdownHandler.addContent(result);\n+        }\n+\n+        return result;\n+    }\n+\n+    private class MarkdownHandler {\n+        private static final char PLACEHOLDER = '\\uFFFC'; \/\/ Unicode Object Replacement Character\n+        private final StringBuilder markdownInput = new StringBuilder() ;\n+        private final ArrayList<Content> fffcObjects = new ArrayList<>();\n+\n+        private final Extension tablesExtn = TablesExtension.create();\n+        private final HtmlNodeRendererFactory headingRendererFactory = HeadingNodeRenderer::new;\n+\n+        private final Element element;\n+\n+        private final Parser parser = Parser.builder()\n+                .extensions(List.of(tablesExtn))\n+                .build();\n+        private final HtmlRenderer renderer = HtmlRenderer.builder()\n+                .nodeRendererFactory(headingRendererFactory)\n+                .extensions(List.of(tablesExtn\/*, headingIdsExtn*\/))\n+                .build();\n+\n+        MarkdownHandler(Element element) {\n+            this.element = element;\n+        }\n+\n+        boolean handle(DocTree tree, InlineVisitor visitor) {\n+            boolean allDone;\n+            if (tree instanceof RawTextTree t) {\n+                if (t.getKind() != Kind.MARKDOWN) {\n+                    throw new IllegalStateException(t.getKind().toString());\n+                }\n+                String code = t.getContent();\n+                \/\/ handle the (unlikely) case of FFFC characters existing in the code\n+                int start = 0;\n+                int pos;\n+                while ((pos = code.indexOf(PLACEHOLDER, start)) != -1) {\n+                    markdownInput.append(code.substring(start, pos));\n+                    markdownInput.append(PLACEHOLDER);\n+                    fffcObjects.add(Text.of(String.valueOf(PLACEHOLDER)));\n+                    start = pos + 1;\n+                }\n+                markdownInput.append(code.substring(start));\n+                allDone = false;\n+            } else {\n+                Content embeddedContent = new ContentBuilder();\n+                allDone = visitor.visit(tree, embeddedContent);\n+                fffcObjects.add(embeddedContent);\n+                markdownInput.append(PLACEHOLDER);\n+            }\n+            return allDone;\n+        }\n+\n+        void addContent(Content result) {\n+            Node document = parser.parse(markdownInput.toString());\n+            String markdownOutput = unwrap(renderer.render(document));\n+\n+            int start = 0;\n+            int pos;\n+            int fffcObjectIndex = 0;\n+            while ((pos = markdownOutput.indexOf(PLACEHOLDER, start)) != -1) {\n+                result.add(RawHtml.markdown(markdownOutput.substring(start, pos)));\n+                result.add(fffcObjects.get(fffcObjectIndex++));\n+                start = pos + 1;\n+            }\n+            if (start < markdownOutput.length()) {\n+                result.add(RawHtml.of(markdownOutput.substring(start)));\n+            }\n+        }\n@@ -1259,2 +1461,16 @@\n-                private boolean inAnAtag() {\n-                    return (tag instanceof StartElementTree st) && equalsIgnoreCase(st.getName(), \"a\");\n+        \/*\n+         * If a string contains a simple HTML paragraph, beginning with <p>\n+         * and ending with <\/p> and optional whitespace, return the content\n+         * of the paragraph between the tags.\n+         * Otherwise, return the string unmodified.\n+         *\/\n+        private static String unwrap(String s) {\n+            var prefix = \"<p>\";\n+            if (s.startsWith(prefix)) {\n+                var suffix = \"<\/p>\";\n+                var suffixPos = s.indexOf(suffix);\n+                if (suffixPos > 0) {\n+                    var endSuffixPos = suffixPos + suffix.length();\n+                    if (isBlank(s, endSuffixPos, s.length())) {\n+                        return s.substring(prefix.length(), suffixPos);\n+                    }\n@@ -1262,0 +1478,3 @@\n+            }\n+            return s;\n+        }\n@@ -1263,4 +1482,63 @@\n-                @Override\n-                public Boolean visitAttribute(AttributeTree node, Content content) {\n-                    if (!content.isEmpty()) {\n-                        content.add(\" \");\n+        \/**\n+         * A renderer for Markdown {@code Heading} nodes, which represent\n+         * both ATX headings (using {@code ####}) and Setext (using underlines).\n+         * The mapping to HTML takes into account the context within the overall\n+         * generated page, and automatically includes an id, to allow the heading\n+         * to be referenced from elsewhere.\n+         *\/\n+        private class HeadingNodeRenderer extends AbstractVisitor implements NodeRenderer {\n+            private final HtmlWriter htmlWriter;\n+            private final HtmlNodeRendererContext context;\n+\n+            HeadingNodeRenderer(HtmlNodeRendererContext context) {\n+                this.htmlWriter = context.getWriter();\n+                this.context = context;\n+            }\n+\n+            @Override\n+            public Set<Class<? extends Node>> getNodeTypes() {\n+                return Set.of(Heading.class);\n+            }\n+\n+            @Override\n+            public void render(Node node) {\n+                node.accept(this);\n+            }\n+\n+            @Override\n+            public void visit(Heading heading) {\n+                var htag = getTag(heading);\n+                var id = getId(heading);\n+\n+                htmlWriter.line();\n+                htmlWriter.tag(htag, Map.of(\"id\", id.name()));\n+                visitChildren(heading);\n+                htmlWriter.tag('\/' + htag);\n+                htmlWriter.line();\n+            }\n+\n+            @Override\n+            protected void visitChildren(Node parent) {\n+                Node node = parent.getFirstChild();\n+                while (node != null) {\n+                    Node next = node.getNext();\n+                    context.render(node);\n+                    node = next;\n+                }\n+            }\n+\n+            private String getTag(Heading heading) {\n+                \/\/ offset the heading level to allow for its position in the overall page\n+                var eKind = element.getKind();\n+                var offset = eKind.isField() || eKind.isExecutable() ? 3 \/\/ members\n+                        : eKind != ElementKind.OTHER ? 1   \/\/ module, package, class, interface\n+                        : 0; \/\/ doc file\n+                return \"h\" + Math.min(heading.getLevel() + offset, 6);\n+            }\n+\n+            private HtmlId getId(Heading heading) {\n+                var list = new ArrayList<String>();\n+                heading.accept(new AbstractVisitor() {\n+                    @Override\n+                    public void visit(jdk.internal.org.commonmark.node.Text text) {\n+                        list.add(text.getLiteral());\n@@ -1268,3 +1546,4 @@\n-                    content.add(node.getName());\n-                    if (node.getValueKind() == ValueKind.EMPTY) {\n-                        return false;\n+\n+                    @Override\n+                    public void visit(Code code) {\n+                        list.add(code.getLiteral());\n@@ -1272,34 +1551,5 @@\n-                    content.add(\"=\");\n-                    String quote = switch (node.getValueKind()) {\n-                        case DOUBLE -> \"\\\"\";\n-                        case SINGLE -> \"'\";\n-                        default -> \"\";\n-                    };\n-                    content.add(quote);\n-\n-                    \/* In the following code for an attribute value:\n-                     * 1. {@docRoot} followed by text beginning \"\/..\" is replaced by the value\n-                     *    of the docrootParent option, followed by the remainder of the text\n-                     * 2. in the value of an \"href\" attribute in a <a> tag, an initial text\n-                     *    value will have a relative link redirected.\n-                     * Note that, realistically, it only makes sense to ever use {@docRoot}\n-                     * at the beginning of a URL in an attribute value, but this is not\n-                     * required or enforced.\n-                     *\/\n-                    boolean isHRef = inAnAtag() && equalsIgnoreCase(node.getName(), \"href\");\n-                    boolean first = true;\n-                    DocRootTree pendingDocRoot = null;\n-                    for (DocTree dt : node.getValue()) {\n-                        if (pendingDocRoot != null) {\n-                            if (dt instanceof TextTree tt) {\n-                                String text = tt.getBody();\n-                                if (text.startsWith(\"\/..\") && !options.docrootParent().isEmpty()) {\n-                                    content.add(options.docrootParent());\n-                                    content.add(textCleanup(text.substring(3), isLastNode));\n-                                    pendingDocRoot = null;\n-                                    continue;\n-                                }\n-                            }\n-                            pendingDocRoot.accept(this, content);\n-                            pendingDocRoot = null;\n-                        }\n+                });\n+                return htmlIds.forHeading(String.join(\" \", list), headingIds);\n+            }\n+        }\n+    }\n@@ -1307,11 +1557,78 @@\n-                        if (dt instanceof TextTree tt) {\n-                            String text = tt.getBody();\n-                            if (first && isHRef) {\n-                                text = redirectRelativeLinks(element, tt);\n-                            }\n-                            content.add(textCleanup(text, isLastNode));\n-                        } else if (dt instanceof DocRootTree drt) {\n-                            \/\/ defer until we see what, if anything, follows this node\n-                            pendingDocRoot = drt;\n-                        } else {\n-                            dt.accept(this, content);\n+    \/*\n+     * Returns whether a substring of a string is blank.\n+     * Avoid creating a substring or using regular expressions.\n+     *\/\n+    private static boolean isBlank(String s, int start, int end) {\n+        for (int i = start; i < end; i++) {\n+            if (!Character.isWhitespace(s.charAt(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private class InlineVisitor extends SimpleDocTreeVisitor<Boolean, Content> {\n+        private final Element element;\n+        private final DocTree tag;\n+        private final boolean isLastNode;\n+        private final TagletWriter.Context context;\n+        private final CommentHelper ch;\n+        private final List<? extends DocTree> trees;\n+\n+        InlineVisitor(Element element,\n+                      DocTree tag,\n+                      boolean isLastNode,\n+                      TagletWriter.Context context,\n+                      CommentHelper ch,\n+                      List<? extends DocTree> trees) {\n+\n+            this.element = element;\n+            this.tag = tag;\n+            this.isLastNode = isLastNode;\n+            this.context = context;\n+            this.ch = ch;\n+            this.trees = trees;\n+        }\n+\n+        private boolean inAnAtag() {\n+            return (tag instanceof StartElementTree st) && equalsIgnoreCase(st.getName(), \"a\");\n+        }\n+\n+        @Override\n+        public Boolean visitAttribute(AttributeTree node, Content content) {\n+            if (!content.isEmpty()) {\n+                content.add(\" \");\n+            }\n+            content.add(node.getName());\n+            if (node.getValueKind() == ValueKind.EMPTY) {\n+                return false;\n+            }\n+            content.add(\"=\");\n+            String quote = switch (node.getValueKind()) {\n+                case DOUBLE -> \"\\\"\";\n+                case SINGLE -> \"'\";\n+                default -> \"\";\n+            };\n+            content.add(quote);\n+\n+            \/* In the following code for an attribute value:\n+             * 1. {@docRoot} followed by text beginning \"\/..\" is replaced by the value\n+             *    of the docrootParent option, followed by the remainder of the text\n+             * 2. in the value of an \"href\" attribute in a <a> tag, an initial text\n+             *    value will have a relative link redirected.\n+             * Note that, realistically, it only makes sense to ever use {@docRoot}\n+             * at the beginning of a URL in an attribute value, but this is not\n+             * required or enforced.\n+             *\/\n+            boolean isHRef = inAnAtag() && equalsIgnoreCase(node.getName(), \"href\");\n+            boolean first = true;\n+            DocRootTree pendingDocRoot = null;\n+            for (DocTree dt : node.getValue()) {\n+                if (pendingDocRoot != null) {\n+                    if (dt instanceof TextTree tt) {\n+                        String text = tt.getBody();\n+                        if (text.startsWith(\"\/..\") && !options.docrootParent().isEmpty()) {\n+                            content.add(options.docrootParent());\n+                            content.add(textCleanup(text.substring(3), isLastNode));\n+                            pendingDocRoot = null;\n+                            continue;\n@@ -1319,4 +1636,0 @@\n-                        first = false;\n-                    }\n-                    if (pendingDocRoot != null) {\n-                        pendingDocRoot.accept(this, content);\n@@ -1324,0 +1637,3 @@\n+                    pendingDocRoot.accept(this, content);\n+                    pendingDocRoot = null;\n+                }\n@@ -1325,2 +1641,11 @@\n-                    content.add(quote);\n-                    return false;\n+                if (dt instanceof TextTree tt) {\n+                    String text = tt.getBody();\n+                    if (first && isHRef) {\n+                        text = redirectRelativeLinks(element, tt);\n+                    }\n+                    content.add(textCleanup(text, isLastNode));\n+                } else if (dt instanceof DocRootTree drt) {\n+                    \/\/ defer until we see what, if anything, follows this node\n+                    pendingDocRoot = drt;\n+                } else {\n+                    dt.accept(this, content);\n@@ -1328,0 +1653,15 @@\n+                first = false;\n+            }\n+            if (pendingDocRoot != null) {\n+                pendingDocRoot.accept(this, content);\n+            }\n+\n+            content.add(quote);\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean visitComment(CommentTree node, Content content) {\n+            content.add(RawHtml.comment(node.getBody()));\n+            return false;\n+        }\n@@ -1330,2 +1670,2 @@\n-                public Boolean visitComment(CommentTree node, Content content) {\n-                    content.add(RawHtml.comment(node.getBody()));\n+                public Boolean visitDocRoot(DocRootTree node, Content content) {\n+                    content.add(getInlineTagOutput(element, node, context));\n@@ -1341,5 +1681,5 @@\n-                @Override\n-                public Boolean visitEntity(EntityTree node, Content content) {\n-                    content.add(Entity.of(node.getName()));\n-                    return false;\n-                }\n+        @Override\n+        public Boolean visitEntity(EntityTree node, Content content) {\n+            content.add(Entity.of(node.getName()));\n+            return false;\n+        }\n@@ -1347,18 +1687,10 @@\n-                @Override\n-                public Boolean visitErroneous(ErroneousTree node, Content content) {\n-                    DocTreePath dtp = ch.getDocTreePath(node);\n-                    if (dtp != null) {\n-                        String body = node.getBody();\n-                        Matcher m = Pattern.compile(\"(?i)\\\\{@([a-z]+).*\").matcher(body);\n-                        String tagName = m.matches() ? m.group(1) : null;\n-                        if (tagName == null) {\n-                            if (!configuration.isDocLintSyntaxGroupEnabled()) {\n-                                messages.warning(dtp, \"doclet.tag.invalid_input\", body);\n-                            }\n-                            content.add(invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", body),\n-                                    Optional.empty()));\n-                        } else {\n-                            messages.warning(dtp, \"doclet.tag.invalid_usage\", body);\n-                            content.add(invalidTagOutput(resources.getText(\"doclet.tag.invalid\", tagName),\n-                                    Optional.of(Text.of(body))));\n-                        }\n+        @Override\n+        public Boolean visitErroneous(ErroneousTree node, Content content) {\n+            DocTreePath dtp = ch.getDocTreePath(node);\n+            if (dtp != null) {\n+                String body = node.getBody();\n+                Matcher m = Pattern.compile(\"(?i)\\\\{@([a-z]+).*\").matcher(body);\n+                String tagName = m.matches() ? m.group(1) : null;\n+                if (tagName == null) {\n+                    if (!configuration.isDocLintSyntaxGroupEnabled()) {\n+                        messages.warning(dtp, \"doclet.tag.invalid_input\", body);\n@@ -1366,1 +1698,6 @@\n-                    return false;\n+                    content.add(invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", body),\n+                            Optional.empty()));\n+                } else {\n+                    messages.warning(dtp, \"doclet.tag.invalid_usage\", body);\n+                    content.add(invalidTagOutput(resources.getText(\"doclet.tag.invalid\", tagName),\n+                            Optional.of(Text.of(body))));\n@@ -1368,0 +1705,3 @@\n+            }\n+            return false;\n+        }\n@@ -1369,5 +1709,5 @@\n-                @Override\n-                public Boolean visitEscape(EscapeTree node, Content content) {\n-                    result.add(node.getBody());\n-                    return false;\n-                }\n+        @Override\n+        public Boolean visitEscape(EscapeTree node, Content content) {\n+            content.add(node.getBody());\n+            return false;\n+        }\n@@ -1375,7 +1715,7 @@\n-                @Override\n-                public Boolean visitInheritDoc(InheritDocTree node, Content content) {\n-                    Content output = getInlineTagOutput(element, node, context);\n-                    content.add(output);\n-                    \/\/ if we obtained the first sentence successfully, nothing more to do\n-                    return (context.isFirstSentence && !output.isEmpty());\n-                }\n+        @Override\n+        public Boolean visitInheritDoc(InheritDocTree node, Content content) {\n+            Content output = getInlineTagOutput(element, node, context);\n+            content.add(output);\n+            \/\/ if we obtained the first sentence successfully, nothing more to do\n+            return (context.isFirstSentence && !output.isEmpty());\n+        }\n@@ -1401,12 +1741,12 @@\n-                private CharSequence textCleanup(String text, boolean isLast, boolean stripLeading) {\n-                    boolean stripTrailing = context.isFirstSentence && isLast;\n-                    if (stripLeading && stripTrailing) {\n-                        text = text.strip();\n-                    } else if (stripLeading) {\n-                        text = text.stripLeading();\n-                    } else if (stripTrailing) {\n-                        text = text.stripTrailing();\n-                    }\n-                    text = utils.replaceTabs(text);\n-                    return Text.normalizeNewlines(text);\n-                }\n+        private CharSequence textCleanup(String text, boolean isLast, boolean stripLeading) {\n+            boolean stripTrailing = context.isFirstSentence && isLast;\n+            if (stripLeading && stripTrailing) {\n+                text = text.strip();\n+            } else if (stripLeading) {\n+                text = text.stripLeading();\n+            } else if (stripTrailing) {\n+                text = text.stripTrailing();\n+            }\n+            text = utils.replaceTabs(text);\n+            return Text.normalizeNewlines(text);\n+        }\n@@ -1414,8 +1754,8 @@\n-                @Override\n-                public Boolean visitText(TextTree node, Content content) {\n-                    String text = node.getBody();\n-                    result.add(text.startsWith(\"<![CDATA[\")\n-                            ? RawHtml.cdata(text)\n-                            : Text.of(textCleanup(text, isLastNode, commentRemoved)));\n-                    return false;\n-                }\n+        @Override\n+        public Boolean visitText(TextTree node, Content content) {\n+            String text = node.getBody();\n+            content.add(text.startsWith(\"<![CDATA[\")\n+                    ? RawHtml.cdata(text)\n+                    : Text.of(textCleanup(text, isLastNode, commentRemoved)));\n+            return false;\n+        }\n@@ -1434,9 +1774,0 @@\n-            };\n-\n-            boolean allDone = docTreeVisitor.visit(tag, result);\n-            commentRemoved = false;\n-\n-            if (allDone)\n-                break;\n-        }\n-        return result;\n@@ -1466,0 +1797,2 @@\n+            } else if (docTree instanceof RawTextTree raw) {\n+                sb.append(raw.getContent().replaceAll(\"[^A-Za-z0-9]+\", \" \"));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":464,"deletions":131,"binary":false,"changes":595,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-import javax.lang.model.element.Element;\n-\n@@ -47,1 +45,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.DocFileElement;\n@@ -63,1 +61,1 @@\n-    final Map<Element, String> titles = new WeakHashMap<>();\n+    final Map<DocFileElement, String> titles = new WeakHashMap<>();\n@@ -136,1 +134,1 @@\n-        Element element = i.getElement();\n+        var element = i.getElement();\n@@ -140,5 +138,3 @@\n-        } else if (element instanceof DocletElement e) {\n-            \/\/ Implementations of DocletElement do not override equals and\n-            \/\/ hashCode; putting instances of DocletElement in a map is not\n-            \/\/ incorrect, but might well be inefficient\n-            String t = titles.computeIfAbsent(element, utils::getHTMLTitle);\n+        } else if (element instanceof DocFileElement e) {\n+            var fo = e.getFileObject();\n+            var t = titles.computeIfAbsent(e, this::getFileTitle);\n@@ -148,1 +144,1 @@\n-                Path p = Path.of(e.getFileObject().toUri());\n+                var p = Path.of(fo.toUri());\n@@ -151,4 +147,3 @@\n-            ContentBuilder b = new ContentBuilder();\n-            b.add(HtmlTree.CODE(Text.of(i.getHolder() + \": \")));\n-            \/\/ non-program elements should be displayed using a normal font\n-            b.add(t);\n+            var b = new ContentBuilder()\n+                    .add(HtmlTree.CODE(Text.of(i.getHolder() + \": \")))\n+                    .add(t);\n@@ -158,1 +153,1 @@\n-            Content link = links.createLink(pathToRoot.resolve(i.getUrl()), i.getHolder());\n+            var link = links.createLink(pathToRoot.resolve(i.getUrl()), i.getHolder());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SystemPropertiesWriter.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,7 @@\n+    \/**\n+     * {@return the contents of this builder}\n+     *\/\n+    public List<Content> getContents() {\n+        return contents;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/ContentBuilder.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -236,0 +236,14 @@\n+    \/**\n+     * {@return the attributes of this node}\n+     *\/\n+    public Map<HtmlAttr, String> getAttrs() {\n+        return attrs;\n+    }\n+\n+    \/**\n+     * {@return the contents of this node}\n+     *\/\n+    public List<Content> getContents() {\n+        return content;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlTree.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,10 @@\n+    \/**\n+     * Creates HTML for a fragment of Markdown output.\n+     *\n+     * @param markdownOutput the fragment\n+     * @return the HTML\n+     *\/\n+    public static RawHtml markdown(CharSequence markdownOutput) {\n+        return of(markdownOutput);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/RawHtml.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-            case TEXT, START_ELEMENT -> {\n+            case TEXT, MARKDOWN, START_ELEMENT -> {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SeeTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -570,1 +570,1 @@\n-    private DocLint doclint;\n+    protected DocLint doclint;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -629,1 +629,1 @@\n-                uri, JavaFileObject.Kind.SOURCE) {\n+                uri, JavaFileObject.Kind.HTML) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/CommentUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.util.Objects;\n+\n@@ -46,1 +48,1 @@\n-     * Creates a pseudo-element that wraps a {@code doc-files} HTML file.\n+     * Creates a pseudo-element that wraps a {@code doc-files} documentation file.\n@@ -92,0 +94,13 @@\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        DocFileElement that = (DocFileElement) o;\n+        return element.equals(that.element) && fo.equals(that.fo);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(element, fo);\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/DocFileElement.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-import com.sun.source.doctree.EndElementTree;\n@@ -109,2 +108,0 @@\n-import com.sun.source.doctree.StartElementTree;\n-import com.sun.source.doctree.TextTree;\n@@ -1372,32 +1369,0 @@\n-    public String getHTMLTitle(Element element) {\n-        List<? extends DocTree> preamble = getPreamble(element);\n-        StringBuilder sb = new StringBuilder();\n-        boolean titleFound = false;\n-        loop:\n-        for (DocTree dt : preamble) {\n-            switch (dt.getKind()) {\n-                case START_ELEMENT -> {\n-                    StartElementTree nodeStart = (StartElementTree) dt;\n-                    if (Utils.toLowerCase(nodeStart.getName().toString()).equals(\"title\")) {\n-                        titleFound = true;\n-                    }\n-                }\n-                case END_ELEMENT -> {\n-                    EndElementTree nodeEnd = (EndElementTree) dt;\n-                    if (Utils.toLowerCase(nodeEnd.getName().toString()).equals(\"title\")) {\n-                        break loop;\n-                    }\n-                }\n-                case TEXT -> {\n-                    TextTree nodeText = (TextTree) dt;\n-                    if (titleFound)\n-                        sb.append(nodeText.getBody());\n-                }\n-                default -> {\n-                }\n-                \/\/ do nothing\n-            }\n-        }\n-        return sb.toString().trim();\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+import com.sun.source.doctree.RawTextTree;\n@@ -313,0 +314,6 @@\n+    @Override\n+    public Void scan(DocTreePath path, Void unused) {\n+        \/\/ interposition point for all scans\n+        return super.scan(path, unused);\n+    }\n+\n@@ -1008,2 +1015,6 @@\n-            DocCommentTree dct = getCurrentPath().getDocComment();\n-            if (dct.getFirstSentence().isEmpty() || tree != dct.getFirstSentence().get(0)) {\n+            var dct = getCurrentPath().getDocComment();\n+            var first = dct.getFirstSentence().stream()\n+                    .filter(t -> !isBlank(t))\n+                    .findFirst();\n+            if (first.isEmpty() || first.get() != tree) {\n+                dct.getFirstSentence().forEach(t -> System.err.println(t.getKind() + \": >>|\" + t + \"|<<\"));\n@@ -1023,0 +1034,8 @@\n+    private static boolean isBlank(DocTree t) {\n+        return switch (t.getKind()) {\n+            case TEXT -> ((TextTree) t).getBody().isBlank();\n+            case MARKDOWN -> ((RawTextTree) t).getContent().isBlank();\n+            default -> false;\n+        };\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-\n@@ -31,1 +30,0 @@\n-import java.util.Collections;\n@@ -66,0 +64,2 @@\n+import jdk.internal.markdown.MarkdownTransformer;\n+\n@@ -163,0 +163,4 @@\n+\n+        if (this.trees.getDocCommentTreeTransformer()== null) {\n+            this.trees.setDocCommentTreeTransformer(new MarkdownTransformer());\n+        }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Env.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+ * @uses com.sun.source.util.DocTrees.DocCommentTreeTransformer\n+ *     By default, this module uses the {@linkplain com.sun.source.util.DocTrees.DocCommentTreeTransformer standard}\n+ *     tree transformer to handle some Markdown constructs.\n@@ -61,0 +64,1 @@\n+    requires jdk.internal.md;\n@@ -79,0 +83,2 @@\n+\n+    uses com.sun.source.util.DocTrees.DocCommentTreeTransformer;\n","filename":"src\/jdk.javadoc\/share\/classes\/module-info.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,732 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestMarkdown\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+\n+public class TestMarkdown extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestMarkdown();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testMinimal(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ Hello, _Markdown_ world!\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">Hello, <em>Markdown<\/em> world!<\/div>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testFirstSentence(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ This is the _first_ sentence.\n+                        \/\/\/ This is the _second_ sentence.\n+                         public void m() { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOrder(\"p\/C.html\",\n+                \"\"\"\n+                    <section class=\"method-summary\" id=\"method-summary\">\"\"\",\n+                \"\"\"\n+                    <div class=\"block\">This is the <em>first<\/em> sentence.<\/div>\"\"\",\n+                \"\"\"\n+                    <section class=\"method-details\" id=\"method-detail\">\"\"\",\n+                \"\"\"\n+                    <div class=\"block\">This is the <em>first<\/em> sentence.\n+                    This is the <em>second<\/em> sentence.<\/div>\"\"\");\n+    }\n+\n+    @Test\n+    public void testMarkdownList(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ Before list.\n+                    \/\/\/\n+                    \/\/\/ * item 1\n+                    \/\/\/ * item 2\n+                    \/\/\/ * item 3\n+                    \/\/\/\n+                    \/\/\/ After list.\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOrder(\"p\/C.html\",\n+                \"\"\"\n+                    <p>Before list.<\/p>\n+                    <ul>\n+                    <li>item 1<\/li>\n+                    <li>item 2<\/li>\n+                    <li>item 3<\/li>\n+                    <\/ul>\n+                    <p>After list.<\/p>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testMarkdownList2(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ Before list.\n+                    \/\/\/\n+                    \/\/\/ - item 1\n+                    \/\/\/ - item 2\n+                    \/\/\/ - item 3\n+                    \/\/\/\n+                    \/\/\/ After list.\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOrder(\"p\/C.html\",\n+                \"\"\"\n+                    <p>Before list.<\/p>\n+                    <ul>\n+                    <li>item 1<\/li>\n+                    <li>item 2<\/li>\n+                    <li>item 3<\/li>\n+                    <\/ul>\n+                    <p>After list.<\/p>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testFont(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ Regular, `Monospace`, _italic_, and **bold** font.\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    Regular, <code>Monospace<\/code>, <em>italic<\/em>, and <strong>bold<\/strong> font.\"\"\");\n+    }\n+\n+    @Test\n+    public void testInherit_md_md(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class Base {\n+                        \/\/\/ Markdown comment.\n+                        \/\/\/ @throws Exception Base _Markdown_\n+                        public void m() throws Exception { }\n+                    }\"\"\",\n+                \"\"\"\n+                    package p;\n+                    public class Derived extends Base {\n+                        \/\/\/ Markdown comment.\n+                        \/\/\/ @throws {@inheritDoc}\n+                        public void m() throws Exception { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/Derived.html\", true,\n+                \"\"\"\n+                    <dt>Throws:<\/dt>\n+                    <dd><code>java.lang.Exception<\/code> - Base <em>Markdown<\/em><\/dd>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testInherit_md_plain(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class Base {\n+                        \/\/\/ Markdown comment.\n+                        \/\/\/ @throws Exception Base _Markdown_\n+                        public void m() throws Exception { }\n+                    }\"\"\",\n+                \"\"\"\n+                    package p;\n+                    public class Derived extends Base {\n+                        \/**\n+                         * Plain comment.\n+                         * @throws {@inheritDoc}\n+                         *\/\n+                         public void m() throws Exception { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/Derived.html\", true,\n+                \"\"\"\n+                    <dt>Throws:<\/dt>\n+                    <dd><code>java.lang.Exception<\/code> - Base <em>Markdown<\/em><\/dd>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testInherit_plain_md(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class Base {\n+                        \/**\n+                         * Plain comment.\n+                         * @throws Exception Base _Not Markdown_\n+                         *\/\n+                         public void m() throws Exception { }\n+                    }\"\"\",\n+                \"\"\"\n+                    package p;\n+                    public class Derived extends Base {\n+                        \/\/\/ Markdown comment.\n+                        \/\/\/ @throws {@inheritDoc}\n+                        public void m() throws Exception { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/Derived.html\", true,\n+                \"\"\"\n+                    <dt>Throws:<\/dt>\n+                    <dd><code>java.lang.Exception<\/code> - Base _Not Markdown_<\/dd>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testSimpleLink(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ Method m1.\n+                        \/\/\/ This is different from {@link #m2()}.\n+                        public void m1() { }\n+                        \/\/\/ Method m2.\n+                        \/\/\/ This is different from {@link #m1()}.\n+                        public void m2() { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    Method m1.\n+                    This is different from <a href=\"#m2()\"><code>m2()<\/code><\/a>.\"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testSimpleRefLink(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ Method m1.\n+                        \/\/\/ This is different from [#m2()].\n+                        public void m1() { }\n+                        \/\/\/ Method m2.\n+                        \/\/\/ This is different from [#m1()].\n+                        public void m2() { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    Method m1.\n+                    This is different from <a href=\"#m2()\"><code>m2()<\/code><\/a>.\"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testLinkWithDescription(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ Method m1.\n+                        \/\/\/ This is different from {@linkplain #m2() _Markdown_ m2}.\n+                        public void m1() { }\n+                        \/\/\/ Method m2.\n+                        \/\/\/ This is different from {@linkplain #m1() _Markdown_ m1}.\n+                        public void m2() { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    Method m1.\n+                    This is different from <a href=\"#m2()\"><em>Markdown<\/em> m2\"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testRefLinkWithDescription(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ Method m1.\n+                        \/\/\/ This is different from [_Markdown_ m2][#m2()].\n+                        public void m1() { }\n+                        \/\/\/ Method m2.\n+                        \/\/\/ This is different from [_Markdown_ m1][#m1()]}.\n+                        public void m2() { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    Method m1.\n+                    This is different from <a href=\"#m2()\"><em>Markdown<\/em> m2\"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testLinkElementKinds(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                        package p;\n+                        \/\/\/ First sentence.\n+                        \/\/\/\n+                        \/\/\/ * module [java.base\/]\n+                        \/\/\/ * package [java.util]\n+                        \/\/\/ * class [String] or interface [Runnable]\n+                        \/\/\/ * a field [String#CASE_INSENSITIVE_ORDER]\n+                        \/\/\/ * a constructor [String#String()]\n+                        \/\/\/ * a method [String#chars()]\n+                        public class C { }\"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        \/\/ in the following carefully avoid checking the URL host, which is of less importance and may vary over time;\n+        \/\/ the interesting part is the tail of the path after the host\n+        new OutputChecker(\"p\/C.html\")\n+                .setExpectOrdered(true)\n+                .check(\"module <a href=\\\"https:\/\/\",\n+                        \"\/api\/java.base\/module-summary.html\\\" class=\\\"external-link\\\"><code>java.base<\/code><\/a>\",\n+\n+                        \"package <a href=\\\"https:\/\/\",\n+                        \"\/api\/java.base\/java\/util\/package-summary.html\\\" class=\\\"external-link\\\"><code>java.util<\/code><\/a>\",\n+\n+                        \"class <a href=\\\"https:\/\/\",\n+                        \"\/api\/java.base\/java\/lang\/String.html\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>String<\/code><\/a>\",\n+\n+                        \"interface <a href=\\\"https:\/\/\",\n+                        \"\/api\/java.base\/java\/lang\/Runnable.html\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>Runnable<\/code><\/a>\",\n+\n+                        \"a field <a href=\\\"https:\/\/\",\n+                        \"\/api\/java.base\/java\/lang\/String.html#CASE_INSENSITIVE_ORDER\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>String.CASE_INSENSITIVE_ORDER<\/code><\/a>\",\n+\n+                        \"a constructor <a href=\\\"https:\/\/\",\n+                        \"\/api\/java.base\/java\/lang\/String.html#%3Cinit%3E()\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>String()<\/code><\/a><\/li>\",\n+\n+                        \"a method <a href=\\\"https:\/\/\",\n+                        \"\/api\/java.base\/java\/lang\/String.html#chars()\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>String.chars()<\/code><\/a>\");\n+    }\n+\n+    @Test\n+    public void testSee(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ First sentence.\n+                    \/\/\/ @see \"A reference\"\n+                    \/\/\/ @see <a href=\"http:\/\/www.example.com\">Example<\/a>\n+                    \/\/\/ @see D a _Markdown_ description\n+                    public class C { }\n+                    \"\"\",\n+                \"\"\"\n+                    package p;\n+                    public class D { }\"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <dt>See Also:<\/dt>\n+                    <dd>\n+                    <ul class=\"tag-list\">\n+                    <li>\"A reference\"<\/li>\n+                    <li><a href=\"http:\/\/www.example.com\">Example<\/a><\/li>\n+                    <li><a href=\"D.html\" title=\"class in p\"><code>a <em>Markdown<\/em> description<\/code><\/a><\/li>\n+                    <\/ul>\n+                    <\/dd>\"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testIndentedInlineReturn(Path base) throws Exception {\n+        \/\/this is a Markdown-specific test, because leading whitespace is ignored in HTML comments\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ Class description.\n+                    public class C {\n+                        \/\/\/    {@return an int}\n+                        \/\/\/ More description.\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <section class=\"detail\" id=\"m()\">\n+                    <h3>m<\/h3>\n+                    <div class=\"horizontal-scroll\">\n+                    <div class=\"member-signature\"><span class=\"modifiers\">public<\/span>&nbsp;<span class=\"return-type\">int<\/span>&nbsp;<span class=\"element-name\">m<\/span>()<\/div>\n+                    <div class=\"block\">Returns an int.\n+                    More description.<\/div>\n+                    <dl class=\"notes\">\n+                    <dt>Returns:<\/dt>\n+                    <dd>an int<\/dd>\n+                    <\/dl>\n+                    <\/div>\n+                    <\/section>\"\"\");\n+    }\n+\n+    @Test\n+    public void testFFFC(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ First sentence. 1{@code 1}1 \\ufffc 2{@code 2}2\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">First sentence. 1<code>1<\/code>1 \\ufffc 2<code>2<\/code>2<\/div>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testDocFile(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package p;\n+                \/\/\/ First sentence.\n+                public class C { }\n+                \"\"\");\n+        tb.writeFile(src.resolve(\"p\").resolve(\"doc-files\").resolve(\"markdown.md\"),\n+                \"\"\"\n+                # This is a _Markdown_ heading\n+\n+                Lorem ipsum\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/doc-files\/markdown.html\", true,\n+                \"\"\"\n+                    <title>This is a Markdown heading<\/title>\n+                    \"\"\",\n+                \"\"\"\n+                    <main role=\"main\"><h1 id=\"this-is-a-markdown-heading-heading1\">This is a <em>Markdown<\/em> heading<\/h1>\n+                    <p>Lorem ipsum<\/p>\n+                    <\/main>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testOverview(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package p;\n+                \/\/\/ First sentence.\n+                public class C { }\n+                \"\"\");\n+        var overviewFile = src.resolve(\"overview.md\");\n+        tb.writeFile(overviewFile,\n+                \"\"\"\n+                This is a _Markdown_ overview.\n+                Lorem ipsum\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"-overview\", overviewFile.toString(),\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"index.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">This is a <em>Markdown<\/em> overview.\n+                    Lorem ipsum<\/div>\"\"\");\n+    }\n+\n+    @Test\n+    public void testHeading_ATX(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/\/\/ First sentence.\n+                    \/\/\/\n+                    \/\/\/ # ATX-style heading for package\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum.\n+                    \/\/\/\n+                    \/\/\/ ## ATX-style subheading for package\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum.\n+                    package p;\n+                    \"\"\",\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ First sentence.\n+                    \/\/\/\n+                    \/\/\/ # ATX-style heading for class\n+                    \/\/\/\n+                    \/\/\/ Lorum ipsum.\n+                    \/\/\/\n+                    \/\/\/ ## ATX-style subheading for class\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum.\n+                    public class C {\n+                        \/\/\/ Constructor.\n+                        \/\/\/\n+                        \/\/\/ # ATX-style heading for executable\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        \/\/\/\n+                        \/\/\/ ## ATX-style subheading for executable\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        public C() { }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/package-summary.html\", true,\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <h2 id=\"atx-style-heading-for-package-heading\">ATX-style heading for package<\/h2>\n+                    <p>Lorem ipsum.<\/p>\n+                    <h3 id=\"atx-style-subheading-for-package-heading\">ATX-style subheading for package<\/h3>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\"\"\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <h2 id=\"atx-style-heading-for-class-heading\">ATX-style heading for class<\/h2>\n+                    <p>Lorum ipsum.<\/p>\n+                    <h3 id=\"atx-style-subheading-for-class-heading\">ATX-style subheading for class<\/h3>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\n+                    \"\"\", \"\"\"\n+                    <div class=\"block\"><p>Constructor.<\/p>\n+                    <h4 id=\"atx-style-heading-for-executable-heading\">ATX-style heading for executable<\/h4>\n+                    <p>Lorem ipsum.<\/p>\n+                    <h5 id=\"atx-style-subheading-for-executable-heading\">ATX-style subheading for executable<\/h5>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\n+                    \"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testHeading_Setext(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/\/\/ First sentence.\n+                    \/\/\/\n+                    \/\/\/ Setext-style heading for package\n+                    \/\/\/ ================================\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum.\n+                    \/\/\/\n+                    \/\/\/ Setext-style subheading for package\n+                    \/\/\/ -----------------------------------\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum.\n+                    package p;\n+                    \"\"\",\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ First sentence.\n+                    \/\/\/\n+                    \/\/\/ Setext-style heading for class\n+                    \/\/\/ ==============================\n+                    \/\/\/\n+                    \/\/\/ Lorum ipsum.\n+                    \/\/\/\n+                    \/\/\/ Setext-style subheading for class\n+                    \/\/\/ ---------------------------------\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum.\n+                    public class C {\n+                        \/\/\/ Constructor.\n+                        \/\/\/\n+                        \/\/\/ Setext-style heading for executable\n+                        \/\/\/ ===================================\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        \/\/\/\n+                        \/\/\/ Setext-style subheading for executable\n+                        \/\/\/ --------------------------------------\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        public C() { }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+\n+        checkOutput(\"p\/package-summary.html\", true,\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <h2 id=\"setext-style-heading-for-package-heading\">Setext-style heading for package<\/h2>\n+                    <p>Lorem ipsum.<\/p>\n+                    <h3 id=\"setext-style-subheading-for-package-heading\">Setext-style subheading for package<\/h3>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\"\"\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <h2 id=\"setext-style-heading-for-class-heading\">Setext-style heading for class<\/h2>\n+                    <p>Lorum ipsum.<\/p>\n+                    <h3 id=\"setext-style-subheading-for-class-heading\">Setext-style subheading for class<\/h3>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\n+                    \"\"\", \"\"\"\n+                    <div class=\"block\"><p>Constructor.<\/p>\n+                    <h4 id=\"setext-style-heading-for-executable-heading\">Setext-style heading for executable<\/h4>\n+                    <p>Lorem ipsum.<\/p>\n+                    <h5 id=\"setext-style-subheading-for-executable-heading\">Setext-style subheading for executable<\/h5>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\n+                    \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdown.java","additions":732,"deletions":0,"binary":false,"changes":732,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,3 +47,0 @@\n-import sampleapi.util.PoorDocCommentTable;\n-\n-import static com.sun.tools.javac.parser.Tokens.Comment.CommentStyle.JAVADOC;\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/sampleapi\/lib\/sampleapi\/generator\/ModuleGenerator.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestTransformer\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.stream.StreamSupport;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.RawTextTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.util.DocTreeFactory;\n+import com.sun.source.util.DocTrees;\n+\n+import javadoc.tester.JavadocTester;\n+import jdk.javadoc.doclet.DocletEnvironment;\n+import jdk.javadoc.doclet.StandardDoclet;\n+import toolbox.ToolBox;\n+\n+public class TestTransformer extends JavadocTester {\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestTransformer();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testFindStandardTransformer_raw() throws Exception {\n+        int count = 0;\n+        var sl = ServiceLoader.load(DocTrees.DocCommentTreeTransformer.class);\n+        for (var t : sl) {\n+            if (t.name().equals(\"standard\")) {\n+                out.println(\"Found \" + t);\n+                count++;\n+            }\n+        }\n+        checking(\"transformer\");\n+        if (count == 1) {\n+            passed(\"expected transformer found\");\n+        } else {\n+            failed(\"expected transformer not found\");\n+        }\n+    }\n+\n+    @Test\n+    public void testFindStandardTransformer_stream() throws Exception {\n+        var dct = getTransformer(\"standard\");\n+        checking(\"transformer\");\n+        if (dct.isPresent()) {\n+            out.println(\"Found \" + dct.get());\n+            passed(\"expected transformer found\");\n+        } else {\n+            failed(\"transformer not found\");\n+        }\n+    }\n+\n+    private Optional<DocTrees.DocCommentTreeTransformer> getTransformer(String name) {\n+        var sl = ServiceLoader.load(DocTrees.DocCommentTreeTransformer.class);\n+        return StreamSupport.stream(sl.spliterator(), false)\n+                .filter(p -> p.name().equals(name))\n+                .findFirst();\n+    }\n+\n+    public static class MyTransformer implements DocTrees.DocCommentTreeTransformer {\n+\n+        private DocTreeFactory m;\n+        @Override\n+        public String name() {\n+            return getClass().getSimpleName();\n+        }\n+\n+        @Override\n+        public DocCommentTree transform(DocTrees trees, DocCommentTree tree) {\n+            m = trees.getDocTreeFactory();\n+            return m.newDocCommentTree(transform(tree.getFullBody()), tree.getBlockTags());\n+        }\n+\n+        private List<? extends DocTree> transform(List<? extends DocTree> list) {\n+            return list.stream().map(this::transform).toList();\n+        }\n+\n+        private DocTree transform(DocTree tree) {\n+            return switch (tree) {\n+                case TextTree tt ->\n+                        m.newTextTree(transform(tt.getBody()));\n+                case RawTextTree rtt ->\n+                        m.newRawTextTree(rtt.getKind(), transform(rtt.getContent()));\n+                default ->\n+                        tree;\n+            };\n+        }\n+\n+        private String transform(String s) {\n+            return s.replace(\"lowercase\", \"UPPERCASE\");\n+        }\n+    }\n+\n+    public static class MyDoclet extends StandardDoclet {\n+        @Override\n+        public boolean run(DocletEnvironment docEnv) {\n+            docEnv.getDocTrees().setDocCommentTreeTransformer(new MyTransformer());\n+            return super.run(docEnv);\n+        }\n+    }\n+\n+    @Test\n+    public void testMyTransformer(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * This traditional comment contains a lowercase word.\n+                 *\/\n+                public class Trad { }\n+                \"\"\", \"\"\"\n+                package p;\n+                \/\/\/ This line comment contains a lowercase word.\n+                public class Line { }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"-doclet\", \"TestTransformer$MyDoclet\",\n+                \"-docletpath\", System.getProperty(\"test.classes\"),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/Line.html\", true, \"\"\"\n+                <div class=\"block\">This line comment contains a UPPERCASE word.<\/div>\"\"\");\n+        checkOutput(\"p\/Trad.html\", true, \"\"\"\n+                <div class=\"block\">This traditional comment contains a UPPERCASE word.<\/div>\"\"\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/testTransformer\/TestTransformer.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8042261\n+ * @bug 8042261 8298405\n@@ -74,0 +74,1 @@\n+                test(PACKAGE_INFO.replaceAll(\"@Deprecated\", \"\/\/\/ @deprecated\\n\"), src);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/deprecated\/DeprecatedPackageTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8042261\n+ * @bug 8042261 8298405\n@@ -230,0 +230,2 @@\n+                test(src.replaceAll(\"deprecated\", \"notDeprecated2\") \/\/ change class name\n+                        .replaceAll(\"@Deprecated\", \"\/\/\/ @deprecated\\n\"));\n@@ -243,3 +245,3 @@\n-            String outerClassName = classes.containsKey(\"deprecated\")\n-                    ? \"deprecated\"\n-                    : \"notDeprecated\";\n+            String outerClassName = classes.keySet().stream()\n+                    .filter(n -> !n.contains(\"$\"))\n+                    .findFirst().orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/deprecated\/DeprecatedTest.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import java.io.File;\n@@ -30,0 +29,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -44,1 +45,41 @@\n-import com.sun.source.doctree.*;\n+import com.sun.source.doctree.AttributeTree;\n+import com.sun.source.doctree.AuthorTree;\n+import com.sun.source.doctree.CommentTree;\n+import com.sun.source.doctree.DeprecatedTree;\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocRootTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.DocTreeVisitor;\n+import com.sun.source.doctree.DocTypeTree;\n+import com.sun.source.doctree.EndElementTree;\n+import com.sun.source.doctree.EntityTree;\n+import com.sun.source.doctree.ErroneousTree;\n+import com.sun.source.doctree.EscapeTree;\n+import com.sun.source.doctree.HiddenTree;\n+import com.sun.source.doctree.IdentifierTree;\n+import com.sun.source.doctree.IndexTree;\n+import com.sun.source.doctree.InheritDocTree;\n+import com.sun.source.doctree.LinkTree;\n+import com.sun.source.doctree.LiteralTree;\n+import com.sun.source.doctree.ParamTree;\n+import com.sun.source.doctree.ProvidesTree;\n+import com.sun.source.doctree.RawTextTree;\n+import com.sun.source.doctree.ReferenceTree;\n+import com.sun.source.doctree.ReturnTree;\n+import com.sun.source.doctree.SeeTree;\n+import com.sun.source.doctree.SerialDataTree;\n+import com.sun.source.doctree.SerialFieldTree;\n+import com.sun.source.doctree.SerialTree;\n+import com.sun.source.doctree.SinceTree;\n+import com.sun.source.doctree.SnippetTree;\n+import com.sun.source.doctree.SpecTree;\n+import com.sun.source.doctree.StartElementTree;\n+import com.sun.source.doctree.SummaryTree;\n+import com.sun.source.doctree.SystemPropertyTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.doctree.ThrowsTree;\n+import com.sun.source.doctree.UnknownBlockTagTree;\n+import com.sun.source.doctree.UnknownInlineTagTree;\n+import com.sun.source.doctree.UsesTree;\n+import com.sun.source.doctree.ValueTree;\n+import com.sun.source.doctree.VersionTree;\n@@ -60,0 +101,1 @@\n+import com.sun.tools.javac.tree.JCTree;\n@@ -91,2 +133,2 @@\n-        List<File> files = args.stream()\n-                .map(arg -> new File(testSrc, arg))\n+        List<Path> files = args.stream()\n+                .map(arg -> Path.of(testSrc, arg))\n@@ -98,1 +140,1 @@\n-        Iterable<? extends JavaFileObject> fos = fm.getJavaFileObjectsFromFiles(files);\n+        Iterable<? extends JavaFileObject> fos = fm.getJavaFileObjectsFromPaths(files);\n@@ -246,0 +288,1 @@\n+            assert start >= 0 : \"start of AST comment not found\";\n@@ -247,0 +290,1 @@\n+            assert end >= 0 : \"end of AST comment not found\";\n@@ -270,2 +314,2 @@\n-            List<File> files = new ArrayList<>();\n-            File o = null;\n+            List<Path> files = new ArrayList<>();\n+            Path o = null;\n@@ -275,1 +319,1 @@\n-                    o = new File(args[++i]);\n+                    o = Path.of(args[++i]);\n@@ -279,1 +323,1 @@\n-                    files.add(new File(arg));\n+                    files.add(Path.of(arg));\n@@ -285,1 +329,1 @@\n-            final File outDir = o;\n+            final Path outDir = o;\n@@ -289,1 +333,1 @@\n-            Iterable<? extends JavaFileObject> fos = fm.getJavaFileObjectsFromFiles(files);\n+            Iterable<? extends JavaFileObject> fos = fm.getJavaFileObjectsFromPaths(files);\n@@ -308,0 +352,1 @@\n+                    assert start >= 0 : \"cannot find initial '{'\";\n@@ -310,0 +355,1 @@\n+                        assert end >= 0 : \"cannot find end of comment\";\n@@ -317,2 +363,2 @@\n-                    File f = new File(tree.getSourceFile().getName());\n-                    File outFile = new File(outDir, f.getName());\n+                    var treeSourceFileName = tree.getSourceFile().getName();\n+                    var outFile = outDir.resolve(treeSourceFileName);\n@@ -320,3 +366,1 @@\n-                        try (FileWriter out = new FileWriter(outFile)) {\n-                            out.write(source);\n-                        }\n+                        Files.writeString(outFile, source);\n@@ -324,1 +368,1 @@\n-                        System.err.println(\"Can't write \" + tree.getSourceFile().getName()\n+                        System.err.println(\"Can't write \" + treeSourceFileName\n@@ -545,0 +589,5 @@\n+            public Void visitRawText(RawTextTree node, Void p) {\n+                header(node, compress(node.getContent()));\n+                return null;\n+            }\n+\n@@ -866,0 +915,2 @@\n+                                System.err.println(\"node: \" + node.getKind());\n+                                System.err.println(\"startPos: \" + startPos + \" \" + showPos(cs, (int) startPos));\n@@ -898,0 +949,11 @@\n+\n+        String showPos(CharSequence cs, int pos) {\n+            String s = cs.toString();\n+            return (s.substring(Math.max(0, pos - 10), pos)\n+                    + \"[\"\n+                    + s.charAt(pos)\n+                    + \"]\"\n+                    + s.substring(pos + 1, Math.min(s.length(), pos + 10)))\n+                    .replace('\\n', '|')\n+                    .replace(' ', '_');\n+        }\n@@ -920,2 +982,4 @@\n-            String raw = trees.getDocComment(path);\n-            String normRaw = normalize(raw, normalizeTags);\n+            DocTrees.CommentKind ck = trees.getDocCommentKind(path);\n+            boolean isLineComment = ck == DocTrees.CommentKind.LINE;\n+            String raw = trees.getDocComment(path).stripTrailing();\n+            String normRaw = normalize(raw, isLineComment, normalizeTags);\n@@ -930,1 +994,3 @@\n-                System.err.println(\"*** expected:\");\n+                System.err.println(\"*** raw: (\" + raw.length() + \")\");\n+                System.err.println(raw.replace(\" \", \"_\"));\n+                System.err.println(\"*** expected: (\" + normRaw.length() + \")\");\n@@ -932,1 +998,1 @@\n-                System.err.println(\"*** found:\");\n+                System.err.println(\"*** found: (\" + pretty.length() + \")\");\n@@ -937,0 +1003,11 @@\n+\/\/        Tokens.Comment getComment(TreePath path) {\n+\/\/            CompilationUnitTree t = path.getCompilationUnit();\n+\/\/            Tree leaf = path.getLeaf();\n+\/\/            if (t instanceof JCTree.JCCompilationUnit compilationUnit && leaf instanceof JCTree tree) {\n+\/\/                if (compilationUnit.docComments != null) {\n+\/\/                    return compilationUnit.docComments.getComment(tree);\n+\/\/                }\n+\/\/            }\n+\/\/            return null;\n+\/\/        }\n+\n@@ -948,2 +1025,3 @@\n-        String normalize(String s, boolean normalizeTags) {\n-            String s2 = s.trim().replaceFirst(\"\\\\.\\\\s*\\\\n *@(?![@*])\", \".\\n@\");\n+        String normalize(String s, boolean isLineComment, boolean normalizeTags) {\n+            String s2 = (isLineComment ? s : s.trim())\n+                    .replaceFirst(\"\\\\.\\\\s*\\\\n *@(?![@*])\", \".\\n@\"); \/\/ Between block tags\n@@ -968,1 +1046,1 @@\n-            return s.replaceAll(\"\\n[ \\t]+@(?![@*])\", \"\\n@\");\n+            return s.replaceAll(\"\\n[ \\t]+@(?!([@*]|dummy))\", \"\\n@\");\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocCommentTester.java","additions":102,"deletions":24,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614 8078320 8247788 8273244\n+ * @bug 7021614 8078320 8247788 8273244 8298405\n@@ -239,0 +239,12 @@\n+\/\/ In Markdown mode, < does not introduce an element\n+    \/\/\/abc < def\n+    public void markdown() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc_<_def]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n","filename":"test\/langtools\/tools\/javac\/doctree\/ElementTest.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614 8273244 8284908\n+ * @bug 7021614 8273244 8284908 8298405\n@@ -167,0 +167,11 @@\n+*\/\n+\n+    \/\/\/abc & def\n+    public void markdown() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc_&_def]\n+  body: empty\n+  block tags: empty\n+]\n","filename":"test\/langtools\/tools\/javac\/doctree\/EntityTest.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -406,0 +406,137 @@\n+*\/\n+    \/\/\/abc.\n+    \/\/\/def.\n+    void simpleMarkdown() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, def.]\n+  block tags: empty\n+]\n+*\/\n+\/*\n+BREAK_ITERATOR\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc.|def.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/abc `p.q` def.\n+    \/\/\/ghi.\n+    void markdownWithCodeSpan() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc_`p.q`_def.]\n+  body: 1\n+    RawText[MARKDOWN, pos:15, ghi.]\n+  block tags: empty\n+]\n+*\/\n+\/*\n+BREAK_ITERATOR\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc_`p.q`_def.|ghi.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/abc {@code p.q} def.\n+    \/\/\/ghi.\n+    void markdownWithCodeTag() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 3\n+    RawText[MARKDOWN, pos:0, abc_]\n+    Literal[CODE, pos:4, p.q]\n+    RawText[MARKDOWN, pos:15, _def.]\n+  body: 1\n+    RawText[MARKDOWN, pos:21, ghi.]\n+  block tags: empty\n+]\n+*\/\n+\/*\n+BREAK_ITERATOR\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 3\n+    RawText[MARKDOWN, pos:0, abc_]\n+    Literal[CODE, pos:4, p.q]\n+    RawText[MARKDOWN, pos:15, _def.|ghi.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/abc <a href=\"example.com\">example<\/a> def.\n+    \/\/\/ghi.\n+    void markdownWithHtml() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc_<a_href=\"example.com\">example<\/a>_def.]\n+  body: 1\n+    RawText[MARKDOWN, pos:43, ghi.]\n+  block tags: empty\n+]\n+*\/\n+\/*\n+BREAK_ITERATOR\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc_<a_href=\"example.com\">example<\/a>_def.|ghi.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/abc [example.com][example] def.\n+    \/\/\/ghi.\n+    void markdownWithLinks() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc_[example.com][example]_def.]\n+  body: 1\n+    RawText[MARKDOWN, pos:32, ghi.]\n+  block tags: empty\n+]\n+*\/\n+\/*\n+BREAK_ITERATOR\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc_[example.com][example]_def.|ghi.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/abc\n+    \/\/\/\n+    \/\/\/def.\n+    void markdownEndParaNoPeriod() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, def.]\n+  block tags: empty\n+]\n+*\/\n+\/*\n+BREAK_ITERATOR\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, def.]\n+  block tags: empty\n+]\n","filename":"test\/langtools\/tools\/javac\/doctree\/FirstSentenceTest.java","additions":138,"deletions":1,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import jdk.internal.org.commonmark.node.BlockQuote;\n+import jdk.internal.org.commonmark.node.BulletList;\n+import jdk.internal.org.commonmark.node.Code;\n+import jdk.internal.org.commonmark.node.CustomBlock;\n+import jdk.internal.org.commonmark.node.CustomNode;\n+import jdk.internal.org.commonmark.node.Document;\n+import jdk.internal.org.commonmark.node.Emphasis;\n+import jdk.internal.org.commonmark.node.FencedCodeBlock;\n+import jdk.internal.org.commonmark.node.HardLineBreak;\n+import jdk.internal.org.commonmark.node.Heading;\n+import jdk.internal.org.commonmark.node.HtmlBlock;\n+import jdk.internal.org.commonmark.node.HtmlInline;\n+import jdk.internal.org.commonmark.node.Image;\n+import jdk.internal.org.commonmark.node.IndentedCodeBlock;\n+import jdk.internal.org.commonmark.node.Link;\n+import jdk.internal.org.commonmark.node.LinkReferenceDefinition;\n+import jdk.internal.org.commonmark.node.ListItem;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.node.OrderedList;\n+import jdk.internal.org.commonmark.node.Paragraph;\n+import jdk.internal.org.commonmark.node.SoftLineBreak;\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.node.StrongEmphasis;\n+import jdk.internal.org.commonmark.node.Text;\n+import jdk.internal.org.commonmark.node.ThematicBreak;\n+import jdk.internal.org.commonmark.node.Visitor;\n+import jdk.internal.org.commonmark.parser.IncludeSourceSpans;\n+import jdk.internal.org.commonmark.parser.Parser;\n+\n+\/**\n+ * Debug printer for CommonMark nodes.\n+ *\n+ * Requires access to {@code jdk.internal.org.commonmark.node.*}.\n+ *\n+ * Conceptually based on javac's {@code DPrinter}.\n+ *\/\n+public class MDPrinter {\n+    static class MDVisitor implements Visitor {\n+\n+        MDVisitor(String source, PrintStream out) {\n+            this.source = source;\n+            lines = source == null ? null : source.lines().toList();\n+            this.out = out;\n+        }\n+\n+        void visit(Node node) {\n+            if (node == null) {\n+                out.print(\"    \".repeat(depth));\n+                out.println(\"*null*\");\n+            } else {\n+                node.accept(this);\n+            }\n+        }\n+\n+        @Override\n+        public void visit(BlockQuote blockQuote) {\n+            defaultAction(blockQuote);\n+        }\n+\n+        @Override\n+        public void visit(BulletList bulletList) {\n+            defaultAction(bulletList);\n+        }\n+\n+        @Override\n+        public void visit(Code code) {\n+            defaultAction(code);\n+        }\n+\n+        @Override\n+        public void visit(Document document) {\n+            defaultAction(document);\n+        }\n+\n+        @Override\n+        public void visit(Emphasis emphasis) {\n+            defaultAction(emphasis);\n+        }\n+\n+        @Override\n+        public void visit(FencedCodeBlock fencedCodeBlock) {\n+            defaultAction(fencedCodeBlock);\n+        }\n+\n+        @Override\n+        public void visit(HardLineBreak hardLineBreak) {\n+            defaultAction(hardLineBreak);\n+        }\n+\n+        @Override\n+        public void visit(Heading heading) {\n+            defaultAction(heading);\n+        }\n+\n+        @Override\n+        public void visit(ThematicBreak thematicBreak) {\n+            defaultAction(thematicBreak);\n+        }\n+\n+        @Override\n+        public void visit(HtmlInline htmlInline) {\n+            defaultAction(htmlInline);\n+        }\n+\n+        @Override\n+        public void visit(HtmlBlock htmlBlock) {\n+            defaultAction(htmlBlock);\n+        }\n+\n+        @Override\n+        public void visit(Image image) {\n+            defaultAction(image);\n+        }\n+\n+        @Override\n+        public void visit(IndentedCodeBlock indentedCodeBlock) {\n+            defaultAction(indentedCodeBlock);\n+        }\n+\n+        @Override\n+        public void visit(Link link) {\n+            defaultAction(link);\n+        }\n+\n+        @Override\n+        public void visit(ListItem listItem) {\n+            defaultAction(listItem);\n+        }\n+\n+        @Override\n+        public void visit(OrderedList orderedList) {\n+            defaultAction(orderedList);\n+        }\n+\n+        @Override\n+        public void visit(Paragraph paragraph) {\n+            defaultAction(paragraph);\n+        }\n+\n+        @Override\n+        public void visit(SoftLineBreak softLineBreak) {\n+            defaultAction(softLineBreak);\n+        }\n+\n+        @Override\n+        public void visit(StrongEmphasis strongEmphasis) {\n+            defaultAction(strongEmphasis);\n+        }\n+\n+        @Override\n+        public void visit(Text text) {\n+            defaultAction(text);\n+        }\n+\n+        @Override\n+        public void visit(LinkReferenceDefinition linkReferenceDefinition) {\n+            defaultAction(linkReferenceDefinition);\n+        }\n+\n+        @Override\n+        public void visit(CustomBlock customBlock) {\n+            defaultAction(customBlock);\n+        }\n+\n+        @Override\n+        public void visit(CustomNode customNode) {\n+            defaultAction(customNode);\n+        }\n+\n+        private final String source;\n+        private final List<String> lines;\n+        private final PrintStream out;\n+\n+        int depth = 0;\n+\n+        protected void defaultAction(Node node) {\n+            out.print(\"    \".repeat(depth));\n+            out.print(node.getClass().getSimpleName());\n+            out.print(\" \");\n+            out.println(abbrev(node.toString(), 64));\n+            int i = 0;\n+            for (var ss : node.getSourceSpans()) {\n+                out.print(\"    \".repeat(depth));\n+                out.print(\"  span[\" + (i++) + \"]: \" + ss);\n+                out.println(abbrev(source(ss).replace(' ', '_').replace('\\n', '|'), 64));\n+            }\n+            depth++;\n+            try {\n+                for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n+                    c.accept(this);\n+                }\n+            } finally {\n+                depth--;\n+            }\n+        }\n+\n+        String source(SourceSpan ss) {\n+            if (source == null) {\n+                return \"no source\";\n+            }\n+            if (ss.getLineIndex() >= lines.size()) {\n+                return \"error: insufficient lines [\" + lines.size() + \"]\";\n+            }\n+            String line = lines.get(ss.getLineIndex());\n+            if (ss.getColumnIndex() + ss.getLength() > line.length()) {\n+                return \"error: bounds\";\n+            }\n+            return line.substring(ss.getColumnIndex(), ss.getColumnIndex() + ss.getLength());\n+        }\n+\n+        String abbrev(String s, int maxLen) {\n+            return s.length() < maxLen ? s\n+                    : s.substring(0, maxLen \/ 2) + \"...\" + s.substring(s.length() - maxLen \/ 2);\n+\n+        }\n+    }\n+\n+    public static void main(String... args) throws IOException {\n+        show(Files.readString(Path.of(args[0])));\n+    }\n+\n+    public static void show(String source) {\n+        Parser parser = Parser.builder()\n+                .includeSourceSpans(IncludeSourceSpans.BLOCKS_AND_INLINES)\n+                .build();\n+        Node document = parser.parse(source);\n+\n+        show(document, source, System.err);\n+    }\n+\n+    public static void show(Node node, String source, PrintStream out) {\n+        new MDVisitor(source, out).visit(node);\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/doctree\/MDPrinter.java","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -0,0 +1,612 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298405\n+ * @summary Markdown support in the standard doclet\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build DocCommentTester\n+ * @run main DocCommentTester MarkdownTest.java\n+ *\/\n+\n+\/*\n+ * Test for handling Markdown content.\n+ *\n+ * In the tests for code spans and code blocks, \"@dummy\" is used as a dummy inline\n+ * or block tag to verify that it is skipped as part of the code span or code block.\n+ * In other words, \"@dummy\" should appear as a literal part of the Markdown content.\n+ * Conversely, standard tags are used to verify that a fragment of text is not being\n+ * skipped as a code span or code block. In other words, they should be recognized as tags\n+ * and not skipped as part of any Markdown content.\n+ *\n+ * \"@dummy\" is also known to DocCommentTester and will not have any preceding whitespace\n+ * removed during normalization.\n+ *\/\n+\n+class MarkdownTest {\n+    \/\/\/abc < def & ghi {@code 123} jkl {@unknown} mno.\n+    void descriptionMix() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 5\n+    RawText[MARKDOWN, pos:0, abc_<_def_&_ghi_]\n+    Literal[CODE, pos:16, 123]\n+    RawText[MARKDOWN, pos:27, _jkl_]\n+    UnknownInlineTag[UNKNOWN_INLINE_TAG, pos:32\n+      tag:unknown\n+      content: 1\n+        Text[TEXT, pos:41]\n+    ]\n+    RawText[MARKDOWN, pos:42, _mno.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/@since abc < def & ghi {@code 123} jkl {@unknown} mno.\n+    void blockTagMix() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: empty\n+  body: empty\n+  block tags: 1\n+    Since[SINCE, pos:0\n+      body: 5\n+        RawText[MARKDOWN, pos:7, abc_<_def_&_ghi_]\n+        Literal[CODE, pos:23, 123]\n+        RawText[MARKDOWN, pos:34, _jkl_]\n+        UnknownInlineTag[UNKNOWN_INLINE_TAG, pos:39\n+          tag:unknown\n+          content: 1\n+            Text[TEXT, pos:48]\n+        ]\n+        RawText[MARKDOWN, pos:49, _mno.]\n+    ]\n+]\n+*\/\n+\n+    \/\/\/123 {@link Object abc < def & ghi {@code 123} jkl {@unknown} mno} 456.\n+    void inlineTagMix() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 3\n+    RawText[MARKDOWN, pos:0, 123_]\n+    Link[LINK, pos:4\n+      reference:\n+        Reference[REFERENCE, pos:11, Object]\n+      body: 5\n+        RawText[MARKDOWN, pos:18, abc_<_def_&_ghi_]\n+        Literal[CODE, pos:34, 123]\n+        RawText[MARKDOWN, pos:45, _jkl_]\n+        UnknownInlineTag[UNKNOWN_INLINE_TAG, pos:50\n+          tag:unknown\n+          content: 1\n+            Text[TEXT, pos:59]\n+        ]\n+        RawText[MARKDOWN, pos:60, _mno]\n+    ]\n+    RawText[MARKDOWN, pos:65, _456.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123 `abc` 456.\n+    void simpleCodeSpan() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123_`abc`_456.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123 `abc`\n+    void simpleCodeSpanAtEndOfInput() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123_`abc`]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123 ```abc``` 456.\n+    void mediumCodeSpan() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123_```abc```_456.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123 ```abc`def``` 456.\n+    void mediumCodeSpanWithBackTicks() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123_```abc`def```_456.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123 ```abc{@dummy ...}def``` 456.\n+    void mediumCodeSpanWithNotInlineTag() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123_```abc{@dummy_...}def```_456.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123 ```abc\n+    \/\/\/@dummy def``` 456.\n+    void mediumCodeSpanWithNotBlockTag() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123_```abc|@dummy_def```_456.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/```\n+    \/\/\/abc\n+    \/\/\/```\n+    \/\/\/456.\n+    void simpleFencedCodeBlock_backtick() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, ```|abc|```|456.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/~~~\n+    \/\/\/abc\n+    \/\/\/{@dummy ...}\n+    \/\/\/~~~\n+    \/\/\/456.\n+    void simpleFencedCodeBlock_tilde() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, ~~~|abc|{@dummy_...}|~~~|456.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/```\n+    \/\/\/abc\n+    \/\/\/```\n+    void simpleFencedCodeBlock_atEndOfInput() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, ```|abc|```]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/```\n+    \/\/\/abc {@dummy def} ghi\n+    \/\/\/```\n+    \/\/\/456.\n+    void fencedCodeBlockWithInlineTag_backtick() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, ```|abc_{@dummy_def}_ghi|```|456.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/```\n+    \/\/\/abc ``` ghi\n+    \/\/\/{@dummy ...}\n+    \/\/\/```\n+    \/\/\/456.\n+    void fencedCodeBlockWithBackTicks_backtick() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, ```|abc_```_ghi|{@dummy_...}|```|456.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/```abc`def``` 456.\n+    void codeSpanNotCodeBlock() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, ```abc`def```_456.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/```\n+    \/\/\/{@code ...}\n+    \/\/\/~~~\n+    \/\/\/456.\n+    void mismatchedFences() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:5, ```|]\n+    Literal[CODE, pos:9, ...]\n+    RawText[MARKDOWN, pos:20, |~~~|456.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/`````\n+    \/\/\/``` ghi\n+    \/\/\/{@dummy ...}\n+    \/\/\/`````\n+    \/\/\/456.\n+    void fencedCodeBlockWithShortFence_backtick() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, `````|```_ghi|{@dummy_...}|`````|456.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/\n+    \/\/\/    abc {@dummy ...}\n+    \/\/\/    @dummy\n+    \/\/\/    def\n+    \/\/\/\n+    \/\/\/456 {@code ...}.\n+    void indentedCodeBlock_afterBlank() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:10, abc_{@dummy_...}|____@dummy|____def||456_]\n+    Literal[CODE, pos:51, ...]\n+    RawText[MARKDOWN, pos:62, .]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/### heading\n+    \/\/\/    abc {@dummy ...}\n+    \/\/\/    @dummy\n+    \/\/\/    def\n+    \/\/\/456 {@code ...}.\n+    void indentedCodeBlock_afterATX() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:5, ###_heading|____abc_{@dummy_...}|____@dummy|____def|456_]\n+    Literal[CODE, pos:61, ...]\n+    RawText[MARKDOWN, pos:72, .]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/Heading\n+    \/\/\/-------\n+    \/\/\/    abc {@dummy ...}\n+    \/\/\/    @dummy\n+    \/\/\/    def\n+    \/\/\/456 {@code ...}.\n+    void indentedCodeBlock_afterSetext() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:5, Heading|-------|____abc_{@dummy_...}|____@dummy|____def|456_]\n+    Literal[CODE, pos:65, ...]\n+    RawText[MARKDOWN, pos:76, .]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/- - - - -\n+    \/\/\/    abc {@dummy ...}\n+    \/\/\/    @dummy\n+    \/\/\/    def\n+    \/\/\/456 {@code ...}.\n+    void indentedCodeBlock_afterThematicBreak() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:5, -_-_-_-_-|____abc_{@dummy_...}|____@dummy|____def|456_]\n+    Literal[CODE, pos:59, ...]\n+    RawText[MARKDOWN, pos:70, .]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/```\n+    \/\/\/abc\n+    \/\/\/{@dummy}\n+    \/\/\/def\n+    \/\/\/```\n+    \/\/\/    abc {@dummy ...}\n+    \/\/\/    @dummy\n+    \/\/\/    def\n+    \/\/\/456 {@code ...}.\n+    void indentedCodeBlock_afterFencedCodeBlock() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:5, ```|abc|{@dummy}|def|```|____abc...mmy_...}|____@dummy|____def|456_]\n+    Literal[CODE, pos:74, ...]\n+    RawText[MARKDOWN, pos:85, .]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/\n+    \/\/\/```\n+    \/\/\/public class HelloWorld {\n+    \/\/\/    @dummy\n+    \/\/\/    public static void main(String... args) {\n+    \/\/\/        System.out.println(\"Hello World\");\n+    \/\/\/    }\n+    \/\/\/}\n+    \/\/\/```\n+    \/\/\/456 {@code ...}.\n+    void fencedHelloWorld() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:6, ```|public_class_HelloWorld_{|__...\"Hello_World\");|____}|}|```|456_]\n+    Literal[CODE, pos:152, ...]\n+    RawText[MARKDOWN, pos:163, .]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/\n+    \/\/\/    public class HelloWorld {\n+    \/\/\/        @dummy\n+    \/\/\/        public static void main(String... args) {\n+    \/\/\/            System.out.println(\"Hello World\");\n+    \/\/\/        }\n+    \/\/\/    }\n+    \/\/\/\n+    \/\/\/456 {@code ...}.\n+    void indentedHelloWorld() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:10, public_class_HelloWorld_{|______...o_World\");|________}|____}||456_]\n+    Literal[CODE, pos:169, ...]\n+    RawText[MARKDOWN, pos:180, .]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/{@summary abc ``code-span {@dummy ...}`` def {@code ...} }\n+    \/\/\/rest.\n+    void codeSpanInInlineTag() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    Summary[SUMMARY, pos:0\n+      summary: 3\n+        RawText[MARKDOWN, pos:10, abc_``code-span_{@dummy_...}``_def_]\n+        Literal[CODE, pos:45, ...]\n+        RawText[MARKDOWN, pos:56, _]\n+    ]\n+  body: 1\n+    RawText[MARKDOWN, pos:58, |rest.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/{@summary abc\n+    \/\/\/```code-block\n+    \/\/\/  {@dummy ...}\n+    \/\/\/```\n+    \/\/\/def {@code ...} }\n+    \/\/\/rest.\n+    void codeBlockInInlineTag() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    Summary[SUMMARY, pos:0\n+      summary: 3\n+        RawText[MARKDOWN, pos:10, abc|```code-block|__{@dummy_...}|```|def_]\n+        Literal[CODE, pos:51, ...]\n+        RawText[MARKDOWN, pos:62, _]\n+    ]\n+  body: 1\n+    RawText[MARKDOWN, pos:64, |rest.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/abc `\n+    \/\/\/def\n+    void unmatchedBackTick() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc_`|def]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/{@summary abc `\n+    \/\/\/def}\n+    \/\/\/rest\n+    void unmatchedBackTickInInline() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    Summary[SUMMARY, pos:0\n+      summary: 1\n+        RawText[MARKDOWN, pos:10, abc_`|def]\n+    ]\n+  body: 1\n+    RawText[MARKDOWN, pos:20, |rest]\n+  block tags: empty\n+]\n+*\/\n+\n+\/\/ While this is an important test case, it is also a negative one.\n+\/\/ Note how the backticks \"match\" across the end of the inline tag.\n+\/\/ That's unfortunate, but cannot reasonably be detected without\n+\/\/ examining the contents of a code span.\n+\/\/ Not surprisingly, most of the checks fail for this (bad) test case.\n+\/\/    \/\/\/\n+\/\/    \/\/\/{@summary abc `\n+\/\/    \/\/\/def}\n+\/\/    \/\/\/rest `more`\n+\/\/    \/\/\/\n+\/\/    void unmatchedBackTickInInline2() { }\n+\/\/\/*\n+\/\/DocComment[DOC_COMMENT, pos:0\n+\/\/  firstSentence: 1\n+\/\/    Summary[SUMMARY, pos:4\n+\/\/      summary: 1\n+\/\/        Erroneous[ERRONEOUS, pos:14, prefPos:37\n+\/\/          code: compiler.err.dc.unterminated.inline.tag\n+\/\/          body: abc_`|_def}|_rest_`more`\n+\/\/        ]\n+\/\/    ]\n+\/\/  body: empty\n+\/\/  block tags: empty\n+\/\/]\n+\/\/*\/\n+\n+    \/\/\/Indented by 0.\n+    \/\/\/\n+    \/\/\/   * list\n+    \/\/\/\n+    \/\/\/    code block\n+    \/\/\/\n+    \/\/\/done.\n+    void indent0() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Indented_by_0.]\n+  body: 1\n+    RawText[MARKDOWN, pos:19, *_list||____code_block||done.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/ Indented by 1.\n+    \/\/\/\n+    \/\/\/    * list\n+    \/\/\/\n+    \/\/\/     code block\n+    \/\/\/\n+    \/\/\/ done.\n+    void indent1() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Indented_by_1.]\n+  body: 1\n+    RawText[MARKDOWN, pos:19, *_list||____code_block||done.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/        Indented by 8.\n+    \/\/\/\n+    \/\/\/           * list\n+    \/\/\/\n+    \/\/\/            code block\n+    \/\/\/\n+    \/\/\/        done.\n+    void indent8() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Indented_by_8.]\n+  body: 1\n+    RawText[MARKDOWN, pos:19, *_list||____code_block||done.]\n+  block tags: empty\n+]\n+*\/\n+\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/doctree\/MarkdownTest.java","additions":612,"deletions":0,"binary":false,"changes":612,"status":"added"},{"patch":"@@ -0,0 +1,525 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8298405\n+ * @summary Proper lexing of comments, especially \/\/\/ comments\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.parser\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.TestRunner\n+ * @run main CommentTest\n+ *\/\n+\n+import java.util.Objects;\n+\n+import com.sun.tools.javac.parser.JavadocTokenizer;\n+import com.sun.tools.javac.parser.ScannerFactory;\n+import com.sun.tools.javac.parser.Tokens;\n+import com.sun.tools.javac.util.Context;\n+\n+import toolbox.TestRunner;\n+\n+public class CommentTest extends TestRunner {\n+    public static void main(String... args) throws Exception {\n+        new CommentTest().runTests();\n+    }\n+\n+    CommentTest() {\n+        super(System.err);\n+    }\n+\n+    \/**\n+     * Control: a simple comment with no blank lines or incidental whitespace.\n+     *\/\n+    @Test\n+    public void testControl() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/abc\n+                \/\/\/def\n+                \/\/\/ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Whitespace before the commennt is completely ignored.\n+     *\/\n+    @Test\n+    public void testRaggedInitialIndent() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/abc\n+                      \/\/\/def\n+                    \/\/\/ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Leading blank lines are preserved.\n+     *\/\n+    @Test\n+    public void testLeadingBlankLine_1() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/\n+                  \/\/\/abc\n+                  \/\/\/def\n+                  \/\/\/ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+\n+                abc\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Leading blank lines do not affect the amount of incidental whitespace.\n+     *\/\n+    @Test\n+    public void testLeadingBlankLine_2() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/\n+                  \/\/\/    abc\n+                  \/\/\/    def\n+                  \/\/\/    ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+\n+                abc\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Inner blank lines are preserved.\n+     *\/\n+    @Test\n+    public void testInnerBlankLine_1() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/abc\n+                  \/\/\/\n+                  \/\/\/def\n+                  \/\/\/ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Inner blank lines do not affect the amount of incidental whitespace.\n+     *\/\n+    @Test\n+    public void testInnerBlankLine_2() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/    abc\n+                  \/\/\/\n+                  \/\/\/    def\n+                  \/\/\/    ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Inner blank lines do not affect the amount of incidental whitespace,\n+     * but may have whitespace removed, perhaps resulting in an empty line.\n+     *\/\n+    @Test\n+    public void testInnerBlankLine_3() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/    abc\n+                  \/\/\/  \\s\n+                  \/\/\/    def\n+                  \/\/\/    ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Inner blank lines do not affect the amount of incidental whitespace,\n+     * but may have whitespace removed.\n+     *\/\n+    @Test\n+    public void testInnerBlankLine_4() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/    abc\n+                  \/\/\/          \\s\n+                  \/\/\/    def\n+                  \/\/\/    ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                      \\s\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Trailing blank lines are preserved.\n+     *\/\n+    @Test\n+    public void testTrailingBlankLine_1() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/abc\n+                  \/\/\/def\n+                  \/\/\/ghi\n+                  \/\/\/\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def\n+                ghi\n+                \"\"\");\n+    }\n+\n+    \/**\n+     * Trailing blank lines do not affect the amount of incidental whitespace.\n+     *\/\n+    @Test\n+    public void testTrailingBlankLine_2() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/    abc\n+                  \/\/\/    def\n+                  \/\/\/    ghi\n+                  \/\/\/\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def\n+                ghi\n+                \"\"\");\n+    }\n+\n+    \/**\n+     * Small amounts of incidental whitespace are removed.\n+     *\/\n+    @Test\n+    public void testIncidental_small() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/ abc\n+                \/\/\/ def\n+                \/\/\/ ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Large amounts of incidental whitespace are removed.\n+     *\/\n+    @Test\n+    public void testIncidental_large() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/        abc\n+                \/\/\/        def\n+                \/\/\/        ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Additional leading whitespace may remain after incidental whitespace is removed.\n+     *\/\n+    @Test\n+    public void testIncidental_mixed() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/        abc\n+                \/\/\/            def\n+                \/\/\/          ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                    def\n+                  ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Tabs and spaces are treated equally, as whitespace characters.\n+     *\/\n+    @Test\n+    public void testIncidental_withTabs() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/        abc\n+                \/\/\/\\t       def\n+                \/\/\/\\t\\t      ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Leading tabs may remain after incidental whitespace is removed.\n+     *\/\n+    @Test\n+    public void testTabAfterIncidental() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/        abc\n+                \/\/\/        \\tdef\n+                \/\/\/        ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                \\tdef\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Trailing spaces are never removed.\n+     *\/\n+    @Test\n+    public void testTrailingSpaces() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/abc\n+                \/\/\/def    \\s\n+                \/\/\/ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def    \\s\n+                ghi\"\"\");\n+\n+    }\n+\n+    \/**\n+     * Trailing tabs are never removed.\n+     *\/\n+    @Test\n+    public void testTrailingTabs() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/abc\n+                \/\/\/def    \\t\n+                \/\/\/ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def    \\t\n+                ghi\"\"\");\n+\n+    }\n+\n+    \/**\n+     * Tabs may appear in incidental whitespace, and may remain in the leading\n+     * whitespace after incidental whitespace is removed.\n+     *\/\n+    @Test\n+    public void testMixedTabs() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/\\t \\t abc\n+                \/\/\/\\t \\t \\tdef\n+                \/\/\/\\t \\t ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                \\tdef\n+                ghi\"\"\");\n+\n+    }\n+\n+    \/**\n+     * A blank line between two \/\/\/ comments is significant, and separates the two comments.\n+     *\/\n+    @Test\n+    public void testMultipleComments() {\n+        \/\/ When there is more than one comment, the most recent comment is first in the list\n+        \/\/ stored in the token.\n+        \/\/\n+        \/\/ (For JavaDoc, only the most recent comment is used; any preceding comments are ignored.)\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/abc\n+\n+                \/\/\/ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                ghi\"\"\", \"\"\"\n+                abc\"\"\");\n+\n+    }\n+\n+    \/**\n+     * An example of pseudo-typical Markdown, containing various Markdown constructs,\n+     * like lists and code blocks.\n+     *\/\n+    @Test\n+    public void testSampleMarkdown() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/ Lorem ipsum dolor sit amet,\n+                \/\/\/ consectetur adipiscing elit.\n+                \/\/\/\n+                \/\/\/ * item 1\n+                \/\/\/ * item 2\n+                \/\/\/\n+                \/\/\/ ```\n+                \/\/\/ fenced code block\n+                \/\/\/ ```\n+                \/\/\/\n+                \/\/\/ Ut enim ad minim veniam, quis nostrud\n+                \/\/\/ exercitation ullamco laboris nisi ut\n+                \/\/\/ aliquip ex ea commodo consequat.\n+                \/\/\/\n+                \/\/\/     indented code block\n+                \/\/\/     ...\n+                \/\/\/\n+                \/\/\/ Duis aute irure dolor in reprehenderit\n+                \/\/\/ in voluptate velit esse cillum dolore\n+                \/\/\/ eu fugiat nulla pariatur.\n+                ]\n+                \"\"\", \"\"\"\n+                Lorem ipsum dolor sit amet,\n+                consectetur adipiscing elit.\n+\n+                * item 1\n+                * item 2\n+\n+                ```\n+                fenced code block\n+                ```\n+\n+                Ut enim ad minim veniam, quis nostrud\n+                exercitation ullamco laboris nisi ut\n+                aliquip ex ea commodo consequat.\n+\n+                    indented code block\n+                    ...\n+\n+                Duis aute irure dolor in reprehenderit\n+                in voluptate velit esse cillum dolore\n+                eu fugiat nulla pariatur.\"\"\");\n+\n+    }\n+\n+    private void test(String input, String... expect) {\n+        var ctx = new Context();\n+        var sf = ScannerFactory.instance(ctx);\n+        var s = sf.newScanner(input, true);\n+        s. nextToken();\n+        var skipToken = s.token();\n+        checkEqual(skipToken.kind, Tokens.TokenKind.LBRACKET);\n+\n+        s.nextToken();\n+        var t = s.token();\n+        var comments = t.comments;\n+        if (comments == null) {\n+            error(\"no comments\");\n+        } else if (comments.size() == expect.length) {\n+            for (var i = 0; i < comments.size(); i++) {\n+                checkEqual(comments.get(i).getText(), expect[i]);\n+            }\n+        } else {\n+            error(\"Unexpected comments: \" + comments);\n+            out.println(\"  expected \" + expect.length + \" comments\");\n+            out.println(\"     found \" + comments.size() + \" comments\");\n+        }\n+    }\n+\n+    private void checkEqual(Object found, Object expect) {\n+        if (!Objects.equals(found, expect)) {\n+            error(\"mismatch\");\n+            out.println(\"  expect: \" + String.valueOf(expect).replace(\"\\n\", \"|\"));\n+            out.println(\"   found: \" + String.valueOf(found).replace(\"\\n\", \"|\"));\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/lexer\/CommentTest.java","additions":525,"deletions":0,"binary":false,"changes":525,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1110,0 +1110,5 @@\n+        public Void visitRawText(RawTextTree node, Void p) {\n+            printLimitedEscapedString(\"content\", node.getContent());\n+            return visitTree(node, null);\n+        }\n+\n","filename":"test\/langtools\/tools\/javac\/lib\/DPrinter.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}