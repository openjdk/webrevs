{"files":[{"patch":"@@ -29,0 +29,2 @@\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n@@ -111,0 +113,1 @@\n+    private final Markdown markdown;\n@@ -165,0 +168,1 @@\n+        markdown = textKind == DocTree.Kind.MARKDOWN ? new Markdown() : null;\n@@ -175,0 +179,26 @@\n+    \/**\n+     * {@return the result of parsing the content given to the constructor}\n+     *\n+     * The parsing rules for \"traditional\" documentation comments are generally incompatible\n+     * with the rules for parsing CommonMark Markdown: traditional comments are parsed\n+     * with a simple recursive-descent parser, while CommonMark is parsed in two \"phases\":\n+     * first identifying blocks, and then subsequently parsing the content of those blocks.\n+     * The conflict shows up most with the rules for inline tags, some of which may contain\n+     * almost arbitrary content, including blank lines in particular.\n+     *\n+     * We do not want to build and maintain a fully-compliant Markdown parser, nor\n+     * can we leverage an existing Markdown parser, such as in commonmark-java,\n+     * which cannot handle arbitrary content in \"inline\" constructs, or the recursive\n+     * nature of some inline tags.\n+     *\n+     * The solution is a compromise. First, we identify inline and block tags,\n+     * so that they may be treated as opaque objects when subsequently using a\n+     * library (such as commonmark-java) to process the enclosing parts of the\n+     * comment. The catch is that while we do not need to provide a full Markdown\n+     * parser, we do need to parse it enough to recognize character sequences of\n+     * literal code (that is, code spans and code blocks), which should not be\n+     * scanned for inline and block tags. Most of this work is handled by the\n+     * nested {@link Markdown} class.\n+     *\n+     * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#blocks-and-inlines\">Blocks and Inlines<\/a>\n+     *\/\n@@ -220,13 +250,0 @@\n-    String peekLine() {\n-        int p = bp;\n-        while (p < buflen) {\n-             switch (buf[p]) {\n-                 case '\\n', '\\r' -> {\n-                     return newString(bp, p);\n-                 }\n-                 default -> p++;\n-             }\n-        }\n-        return newString(bp, buflen);\n-    }\n-\n@@ -272,1 +289,0 @@\n-        LineKind lineKind = textKind == DocTree.Kind.MARKDOWN ? peekLineKind() : null;\n@@ -280,10 +296,3 @@\n-                        int indent = readIndent();\n-                        \/\/ in the following, the evaluation of INDENTED_CODE_BLOCK is\n-                        \/\/ inductively a sequence of indented lines following any\n-                        \/\/ line that is not OTHER\n-                        lineKind = (ch == '\\n' || ch == '\\r') ? LineKind.BLANK\n-                                : (indent <= 3) ? peekLineKind()\n-                                : lineKind != LineKind.OTHER ? LineKind.INDENTED_CODE_BLOCK\n-                                : LineKind.OTHER;\n-                        if (lineKind == LineKind.INDENTED_CODE_BLOCK) {\n-                            skipLine();\n+                        markdown.update();\n+                        if (markdown.isIndentedCodeBlock()) {\n+                            markdown.skipLine();\n@@ -434,2 +443,2 @@\n-                            if (ch == '`' || ch == '~' && lineKind == LineKind.CODE_FENCE) {\n-                                int end = skipMarkdownCode(ch, count(ch), lineKind);\n+                            if (ch == '`' || ch == '~' && markdown.isCodeFence()) {\n+                                int end = markdown.skipCode();\n@@ -1302,8 +1311,107 @@\n-    protected int readIndent() {\n-        int indent = 0;\n-        while (bp < buflen) {\n-            switch (ch) {\n-                case ' ' -> indent++;\n-                case '\\t' -> indent = 4;\n-                default -> {\n-                    return indent;\n+    \/**\n+     * A class to encapsulate the work to detect the boundaries of character\n+     * sequences of literal text, and to skip over such sequences, without\n+     * analyzing the content.\n+     *\n+     * The two primary factors are the current level of indentation,\n+     * used when checking for indented code blocks, and a serial number\n+     * that is incremented when a line is encountered that is not a\n+     * continuation of the previous block.\n+     *\/\n+    class Markdown {\n+        \/**\n+         * The current \"line kind\".\n+         *\/\n+        private LineKind lineKind = LineKind.OTHER;\n+\n+        \/**\n+         * A serial number for the current \"block\".\n+         * It is incremented whenever a line is encountered that indicates\n+         * the beginning of a new block, such that any potential code span\n+         * should be terminated as \"not a span\".\n+         *\/\n+        private int blockId = 0;\n+\n+        \/**\n+         * The current indentation used to determine if a line is part of\n+         * an indented code block. Initially zero, it is increased while\n+         * analysing bulleted or ordered list items,\n+         *\/\n+        private int currIndent = 0;\n+\n+        \/**\n+         * A stack of the indentation values for nested lists.\n+         * Initially empty, entries are pushed when a top-level or\n+         * nested list item is encountered, and removed when a\n+         * less indented line is encountered.\n+         *\/\n+        private final Deque<Integer> indentStack = new ArrayDeque<>();\n+\n+        \/**\n+         * Updates the state after a newline has been read.\n+         * There are two primary goals.\n+         *\n+         * 1. Determine the indentation used to identify indented code blocks.\n+         * 2. Determine if the current line should be considered a continuation\n+         *    of the preceding block, or the beginning of a new block. This is\n+         *    used when determining the end (if any) of a potential code span.\n+         *\/\n+        void update() {\n+            var prevLineKind = lineKind;\n+            int indent = readIndent(0);\n+            if (ch == '\\r' || ch == '\\n') {\n+                lineKind = LineKind.BLANK;\n+                blockId++;\n+            } else if (indent >= currIndent + 4 && !isParagraph(prevLineKind)) {\n+                if (prevLineKind != LineKind.INDENTED_CODE_BLOCK) {\n+                    blockId++;\n+                }\n+                lineKind = LineKind.INDENTED_CODE_BLOCK;\n+            } else {\n+                while (indent < currIndent) {\n+                    currIndent = indentStack.pop();\n+                }\n+\n+                lineKind = peekLineKind();\n+                switch (lineKind) {\n+                    case BLOCK_QUOTE -> {\n+                        if (prevLineKind != LineKind.BLOCK_QUOTE) {\n+                            blockId++;\n+                        }\n+                    }\n+\n+                    case BULLETED_LIST_ITEM, ORDERED_LIST_ITEM -> {\n+                        var count = indent;\n+                        while (ch != ' ' && ch != '\\t') {\n+                            count++;\n+                            nextChar();\n+                        }\n+                        var listItemIndent = readIndent(count);\n+                        if (listItemIndent > count + 4) {\n+                            indentStack.push(currIndent);\n+                            currIndent = count + 4;\n+                            lineKind = LineKind.INDENTED_CODE_BLOCK;\n+                        } else if (indent >= currIndent) {\n+                            indentStack.push(currIndent);\n+                            currIndent = listItemIndent;\n+                        }\n+                        blockId++;\n+                    }\n+\n+                    case OTHER -> {\n+                        switch (prevLineKind) {\n+                            case BLOCK_QUOTE, BULLETED_LIST_ITEM, ORDERED_LIST_ITEM, OTHER -> { }\n+                            default -> {\n+                                blockId++;\n+                            }\n+                        }\n+                    }\n+\n+                    case BLANK, ATX_HEADER, SETEXT_UNDERLINE, THEMATIC_BREAK, CODE_FENCE,\n+                            INDENTED_CODE_BLOCK -> {\n+                        blockId++;\n+                    }\n+\n+                    default -> {\n+                        throw new Error(lineKind.toString());\n+                    }\n@@ -1312,1 +1420,0 @@\n-            nextChar();\n@@ -1314,2 +1421,0 @@\n-        return indent;\n-    }\n@@ -1317,6 +1422,7 @@\n-    int count(char c) {\n-        int n = 1;\n-        nextChar();\n-        while (bp < buflen && ch == c) {\n-            n++;\n-            nextChar();\n+        \/**\n+         * {@return {@code true} if this line should be treated as an indented code block,\n+         *          and {@code false} otherwise}\n+         * Indented code blocks should be treated as literal text and not scanned for tags.\n+         *\/\n+        boolean isIndentedCodeBlock() {\n+            return lineKind == LineKind.INDENTED_CODE_BLOCK;\n@@ -1324,2 +1430,0 @@\n-        return n;\n-    }\n@@ -1327,4 +1431,26 @@\n-    void skipLine() {\n-        while (bp < buflen) {\n-            if (ch == '\\n' || ch == '\\r') {\n-                return;\n+        \/**\n+         * {@return {@code true} if this line should be treated as code fence,\n+         *          and {@code false} otherwise}\n+         * Code fences are used to surround content that should be treated as literal text\n+         * and not scanned for tags.\n+         *\/\n+        boolean isCodeFence() {\n+            return lineKind == LineKind.CODE_FENCE;\n+        }\n+\n+        private boolean isParagraph(LineKind lk) {\n+            return switch (lk) {\n+                case BULLETED_LIST_ITEM, ORDERED_LIST_ITEM, BLOCK_QUOTE, OTHER -> true;\n+                default -> false;\n+            };\n+        }\n+\n+        \/**\n+         * Skips the content of the current line.\n+         *\/\n+        void skipLine() {\n+            while (bp < buflen) {\n+                if (ch == '\\n' || ch == '\\r') {\n+                    return;\n+                }\n+                nextChar();\n@@ -1332,1 +1458,0 @@\n-            nextChar();\n@@ -1334,1 +1459,0 @@\n-    }\n@@ -1336,14 +1460,26 @@\n-    int skipMarkdownCode(char term, int count, LineKind initialLineKind) {\n-        LineKind lineKind = null;\n-        while (bp < buflen) {\n-            switch (ch) {\n-                case '\\n', '\\r' -> {\n-                    nextChar();\n-                    int indent = readIndent();\n-                    lineKind = (ch == '\\n' || ch == '\\r') ? LineKind.BLANK\n-                            : (indent <= 3) ? peekLineKind()\n-                            : LineKind.OTHER;\n-                    switch (initialLineKind) {\n-                        case CODE_FENCE -> {\n-                            if (lineKind == LineKind.CODE_FENCE && ch == term && count(ch) >= count) {\n-                                return bp;\n+        \/**\n+         * Skips literal content.\n+         * The ending delimiter is a function of the repetition count of the current\n+         * character, and whether this is fenced content or not.\n+         * In fenced content, the ending delimiter must appear at the end of a line.\n+         * In other content, the scan may be terminated if the blockId changes,\n+         * meaning the ending delimiter was not found before the block ended.\n+         *\n+         * @return the current position, or {@code -1} to indicate that the ending\n+         *         delimiter was not found\n+         *\/\n+        int skipCode() {\n+            char term = ch;\n+            var count = count(term);\n+            var initialLineKind = lineKind;\n+            var initialBlockId = blockId;\n+            while (bp < buflen) {\n+                switch (ch) {\n+                    case '\\n', '\\r' -> {\n+                        nextChar();\n+                        update();\n+                        switch (initialLineKind) {\n+                            case CODE_FENCE -> {\n+                                if (lineKind == LineKind.CODE_FENCE && ch == term && count(ch) >= count) {\n+                                    return bp;\n+                                }\n@@ -1351,1 +1487,0 @@\n-                        }\n@@ -1353,3 +1488,4 @@\n-                        case OTHER -> {\n-                            if (lineKind != LineKind.OTHER) {\n-                                return -1;\n+                            default -> {\n+                                if (blockId != initialBlockId) {\n+                                    return -1;\n+                                }\n@@ -1358,0 +1494,1 @@\n+                    }\n@@ -1359,2 +1496,5 @@\n-                        default -> {\n-                            return -1;\n+                    default -> {\n+                        if (ch == term && initialLineKind != LineKind.CODE_FENCE ) {\n+                            if (count(ch) == count) {\n+                                return bp;\n+                            }\n@@ -1362,1 +1502,1 @@\n-\n+                        nextChar();\n@@ -1364,0 +1504,5 @@\n+                }\n+            }\n+            \/\/ found end of input\n+            return -1;\n+        }\n@@ -1365,0 +1510,17 @@\n+        \/**\n+         * Reads spaces and tabs, expanding tabs as if they were replaced by spaces\n+         * with a tab stop of 4 characters.\n+         *\n+         * @param initialCount the initial indentation\n+         * @return the indentation after skipping spaces and tabs\n+         *\/\n+        private int readIndent(int initialCount) {\n+            final int TABSTOP = 4;\n+            int indent = initialCount;\n+            while (bp < buflen) {\n+                switch (ch) {\n+                    case ' ' -> indent++;\n+                    case '\\t' -> indent += TABSTOP - indent % TABSTOP;\n+                    default -> {\n+                        return indent;\n+                    }\n@@ -1366,0 +1528,4 @@\n+                nextChar();\n+            }\n+            return indent;\n+        }\n@@ -1367,4 +1533,16 @@\n-                default -> {\n-                    if (ch == term && initialLineKind != LineKind.CODE_FENCE ) {\n-                        if (count(ch) == count) {\n-                            return bp;\n+        \/**\n+         * Peeks ahead at the current line, and matches it against an ordered series\n+         * of regular expressions, to determine the \"kind\" of the line.\n+         *\n+         * @return the \"kind\" of the line\n+         *\/\n+        private LineKind peekLineKind() {\n+            switch (ch) {\n+                case '#', '=', '-', '+', '*', '_', '`', '~', '>',\n+                        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' -> {\n+                    String line = peekLine();\n+                    for (LineKind lk : LineKind.values()) {\n+                        if (lk.pattern != null) {\n+                            if (lk.pattern.matcher(line).matches()) {\n+                                return lk;\n+                            }\n@@ -1373,1 +1551,0 @@\n-                    nextChar();\n@@ -1375,0 +1552,3 @@\n+            }\n+            return LineKind.OTHER;\n+        }\n@@ -1376,0 +1556,13 @@\n+        \/**\n+         * {@return a string obtained by peeking ahead at the current line}\n+         * The current position is unchanged.\n+         *\/\n+        private String peekLine() {\n+            int p = bp;\n+            while (p < buflen) {\n+                switch (buf[p]) {\n+                    case '\\n', '\\r' -> {\n+                        return newString(bp, p);\n+                    }\n+                    default -> p++;\n+                }\n@@ -1377,0 +1570,16 @@\n+            return newString(bp, buflen);\n+        }\n+\n+        \/**\n+         * {@return the number of consecutive occurrences of the given character}\n+         *\n+         * @param c the character\n+         *\/\n+        private int count(char c) {\n+            int n = 1;\n+            nextChar();\n+            while (bp < buflen && ch == c) {\n+                n++;\n+                nextChar();\n+            }\n+            return n;\n@@ -1378,2 +1587,0 @@\n-        \/\/ found end of input\n-        return -1;\n@@ -1402,0 +1609,2 @@\n+    \/\/ This class is only used within the Markdown class, and could be\n+    \/\/ a private nested class there.\n@@ -1471,17 +1680,0 @@\n-    LineKind peekLineKind() {\n-        switch (ch) {\n-            case '#', '=', '-', '+', '*', '_', '`', '~', '>',\n-                    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' -> {\n-                String line = peekLine();\n-                for (LineKind lk : LineKind.values()) {\n-                    if (lk.pattern != null) {\n-                        if (lk.pattern.matcher(line).matches()) {\n-                            return lk;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        return LineKind.OTHER;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":288,"deletions":96,"binary":false,"changes":384,"status":"modified"},{"patch":"@@ -0,0 +1,288 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestMarkdownCodeBlocks\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Tests Markdown code blocks.\n+ *\n+ * Code blocks may be either \"fenced code blocks\" or \"indented code blocks\".\n+ * Within a code block, all text is \"literal text\" and not interpreted as\n+ * Markdown, HTML or javadoc tags.\n+ *\n+ * In the various test cases, javadoc tags are used as a way to determine\n+ * if the parser is correctly interpreting the text in its surrounding context.\n+ * Within a code block, character sequences resembling a tag are treated as\n+ * literal text, and appear \"as is\" in the generated output. Outside a\n+ * code block, character sequences resembling a tag are treated as tags and\n+ * are translated as appropriate in the generated output.\n+ *\n+ * A primary consideration in the test cases is use and handling of indentation,\n+ * especially as it relates to lists and nested lists.\n+ *\/\n+public class TestMarkdownCodeBlocks extends JavadocTester {\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestMarkdownCodeBlocks();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testCodeBlocks(Path base) throws Exception {\n+        \/\/ Test cases provide a fragment of content for a documentation comment\n+        \/\/ and a corresponding fragment of content to be found in the generated output.\n+        \/\/ The name of each member is used to generate the name of a declaration\n+        \/\/ with which the documentation comment is associated.\n+        enum TestCase {\n+            SIMPLE_INDENT(\n+                    \"\"\"\n+\n+                            {@code CODE}\n+                            @Anno\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <pre><code>{@code CODE}\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <p>end<\/p>\"\"\"),\n+\n+            SIMPLE_FENCE_BACKTICK(\n+                    \"\"\"\n+                        ```\n+                        {@code CODE}\n+                        @Anno\n+                        ```\n+                        end\"\"\",\n+                    \"\"\"\n+                        <pre><code>{@code CODE}\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <p>end<\/p>\"\"\"),\n+\n+            SIMPLE_FENCE_TILDE(\n+                    \"\"\"\n+                        ~~~\n+                        {@code CODE}\n+                        @Anno\n+                        ~~~\n+                        end\"\"\",\n+                    \"\"\"\n+                        <pre><code>{@code CODE}\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <p>end<\/p>\"\"\"),\n+            LIST_INDENT(\n+                    \"\"\"\n+                        * list item\n+\n+                              {@code CODE}\n+                              @Anno\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ul>\n+                        <li>\n+                        <p>list item<\/p>\n+                        <pre><code>{@code CODE}\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <\/li>\n+                        <\/ul>\n+                        <p>end<\/p>\"\"\"),\n+\n+            LIST_FENCE_BACKTICK(\n+                    \"\"\"\n+                        * list item\n+                          ```\n+                          {@code CODE}\n+                          @Anno\n+                          ```\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ul>\n+                        <li>list item\n+                        <pre><code>{@code CODE}\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <\/li>\n+                        <\/ul>\n+                        <p>end<\/p>\"\"\"),\n+\n+            LIST_FENCE_TILDE(\n+                    \"\"\"\n+                        1. list item\n+                           ~~~\n+                           {@code CODE}\n+                           @Anno\n+                           ~~~\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ol>\n+                        <li>list item\n+                        <pre><code>{@code CODE}\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <\/li>\n+                        <\/ol>\n+                        <p>end<\/p>\"\"\"),\n+\n+            NOT_INDENT_CONTINUATION(\n+                    \"\"\"\n+\n+                        paragraph\n+                                indented continuation {@code CODE}\n+                                more.\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>paragraph\n+                        indented continuation <code>CODE<\/code>\n+                        more.<\/p>\n+                        <p>end<\/p>\"\"\"\n+            ),\n+\n+            NOT_INDENT_IN_LIST(\n+                    \"\"\"\n+                        1.  list item\n+\n+                            list para, not indented block\n+                            {@code CODE}\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ol>\n+                        <li>\n+                        <p>list item<\/p>\n+                        <p>list para, not indented block\n+                        <code>CODE<\/code><\/p>\n+                        <\/li>\n+                        <\/ol>\n+                        <p>end<\/p>\"\"\"),\n+\n+            COMBO(\n+                    \"\"\"\n+                        1. list item {@code TAG} lorem ipsum\n+\n+                           * nested list {@code TAG} lorem ipsum\n+\n+                               nested list para {@code TAG} lorem ipsum\n+\n+                                 nested indented block {@code TEXT} lorem ipsum\n+\n+                            outer list para {@code TAG} lorem ipsum\n+                            ```\n+                            outer list fenced block {@code TEXT} lorem ipsum\n+                            ```\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ol>\n+                        <li>\n+                        <p>list item <code>TAG<\/code> lorem ipsum<\/p>\n+                        <ul>\n+                        <li>\n+                        <p>nested list <code>TAG<\/code> lorem ipsum<\/p>\n+                        <p>nested list para <code>TAG<\/code> lorem ipsum<\/p>\n+                        <pre><code>nested indented block {@code TEXT} lorem ipsum\n+                        <\/code><\/pre>\n+                        <\/li>\n+                        <\/ul>\n+                        <p>outer list para <code>TAG<\/code> lorem ipsum<\/p>\n+                        <pre><code>outer list fenced block {@code TEXT} lorem ipsum\n+                        <\/code><\/pre>\n+                        <\/li>\n+                        <\/ol>\n+                        <p>end<\/p>\"\"\"\n+            );\n+\n+            final String srcFragment;\n+            final String expect;\n+\n+            TestCase(String srcFragment, String expect) {\n+                this.srcFragment = srcFragment;\n+                this.expect = expect;\n+            }\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"\"\"\n+                    package p;\n+                    \/** Dummy. *\/\n+                    public class C {\n+                    private C() { }\n+                    \"\"\");\n+\n+        for (var tc: TestCase.values()) {\n+            sb.append(\"\"\"\n+                        \/\/\/ First sentence.\n+                        #FRAG#\n+                        public void #NAME#() { }\n+\n+                    \"\"\"\n+                    .replace(\"#FRAG#\", tc.srcFragment.lines()\n+                            .map(l -> \"\/\/\/ \" + l)\n+                            .collect(Collectors.joining(\"\\n    \")))\n+                    .replace(\"#NAME#\", tc.name().toLowerCase(Locale.ROOT)));\n+        }\n+\n+        sb.append(\"}\");\n+\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, sb.toString());\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        for (var tc : TestCase.values()) {\n+            checkOutput(\"p\/C.html\", true,\n+                    \"\"\"\n+                        <span class=\"element-name\">#NAME#<\/span>()<\/div>\n+                        <div class=\"block\"><p>First sentence.<\/p>\n+                        #FRAG#\n+                        <\/div>\"\"\"\n+                            .replace(\"#NAME#\", tc.name().toLowerCase(Locale.ROOT))\n+                            .replace(\"#FRAG#\", tc.expect));\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownCodeBlocks.java","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"},{"patch":"@@ -0,0 +1,389 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestMarkdownCodeSpans\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Tests Markdown code spans.\n+ *\n+ * Code spans are enclosed within a matching sequence of one or more backtick ({@code `})\n+ * characters and provide a way to specify \"literal text\" within a block,\n+ * such as a paragraph, list item, or block quote.  Code spans may span multiple lines\n+ * but not cross block boundaries: if a sequence of backtick characters is not matched within\n+ * a block, the sequence is treated as literal text, even if there is a matching sequence\n+ * in a subsequent block.\n+ *\n+ * In the various test cases, javadoc tags are used as a way to determine\n+ * if the parser is correctly interpreting the text in its surrounding context.\n+ * Within a code span, character sequences resembling a tag are treated as\n+ * literal text, and appear \"as is\" in the generated output. Outside a\n+ * code span, character sequences resembling a tag are treated as tags and\n+ * are translated as appropriate in the generated output.\n+ *\n+ * A primary consideration in the test cases is the use and handling of lines\n+ * that may or may not be part of the same block.  As such, the source for\n+ * each test case can be considered to be in two parts, each containing a backtick,\n+ * and which may or may not represent a code span.  Note that only some kinds\n+ * of lines (for paragraphs, list items and block quotes) may contain code spans.\n+ * All kinds of lines either continue a block or terminate it.\n+ *\/\n+public class TestMarkdownCodeSpans extends JavadocTester {\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestMarkdownCodeSpans();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testCodeSpans(Path base) throws Exception {\n+        \/\/ Test cases provide a fragment of content for a documentation comment\n+        \/\/ and a corresponding fragment of content to be found in the generated output.\n+        \/\/ The name of each member is used to generate the name of a declaration\n+        \/\/ with which the documentation comment is associated.\n+        \/\/\n+        \/\/ In the source fragments:\n+        \/\/ - when \"{@code TEXT}\" appears, it is expected it will appear \"as is\" in the output\n+        \/\/   enclosed within an HTML <code> element\n+        \/\/ - when \"{@code TAG}\" appears, it is expected it will be treated as a tag\n+        \/\/   and will appear in the output as \"<code>TAG<\/code>\"\n+        \/\/ Thus, the character sequence \"{@code TAG}\" should never appear in any output.\n+        \/\/\n+        \/\/ Note: for test cases involving ATX and setext headings, care must be taken to\n+        \/\/ ensure that the content is such that the auto-generated ids are unique,\n+        \/\/ so that we do not depend on the doclet to disambiguate the ids, based on the\n+        \/\/ order in which the headings are generated.\n+        enum TestCase {\n+            SIMPLE_PARA(\n+                    \"\"\"\n+\n+                        abc `p {@code TEXT} q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>abc <code>p {@code TEXT} q<\/code> def<\/p>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ a multi-line code span\n+            PARA_PARA(\n+                    \"\"\"\n+\n+                        abc `p {@code TEXT}\n+                        q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>abc <code>p {@code TEXT} q<\/code> def<\/p>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ a paragraph with a heavily indented continuation line,\n+            \/\/ including a multi-line code span\n+            PARA_INDENT(\n+                    \"\"\"\n+\n+                        abc `p {@code TEXT}\n+                                      q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>abc <code>p {@code TEXT} q<\/code> def<\/p>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ blank line after a paragraph; no code spans, the tag is processed\n+            PARA_BLANK(\n+                    \"\"\"\n+\n+                        abc `p {@code TAG}\n+\n+                        q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>abc `p <code>TAG<\/code><\/p>\n+                        <p>q` def<\/p>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ thematic break after a paragraph; no code spans, the tag is processed\n+            PARA_THEMATIC_BREAK_DASH(\n+                    \"\"\"\n+\n+                        abc `p {@code TAG}\n+                        - - - - - - - - - - - -\n+                        q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>abc `p <code>TAG<\/code><\/p>\n+                        <hr \/>\n+                        <p>q` def<\/p>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ thematic break after a paragraph; no code spans, the tag is processed\n+            PARA_THEMATIC_BREAK_ASTERISK(\n+                    \"\"\"\n+\n+                        abc `p {@code TAG}\n+                        * * * * * * * * * *\n+                        q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>abc `p <code>TAG<\/code><\/p>\n+                        <hr \/>\n+                        <p>q` def<\/p>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ ATX heading after a paragraph; no code spans, the tag is processed\n+            PARA_ATX(\n+                    \"\"\"\n+\n+                        abc `p1 {@code TAG}\n+                        # q1` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>abc `p1 <code>TAG<\/code><\/p>\n+                        <h4 id=\"q1-def-heading\">q1` def<\/h4>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ setext heading; no code spans, the tag is processed\n+            PARA_SETEXT(\n+                    \"\"\"\n+\n+                        abc `p {@code TAG}\n+                        ===================\n+                        q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <h4 id=\"abc-p--heading\">abc `p <code>TAG<\/code><\/h4>\n+                        <p>q` def<\/p>\n+                        <p>end<\/p>\"\"\"),\n+\n+            SIMPLE_LIST(\n+                    \"\"\"\n+\n+                        * abc `p {@code TEXT} q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ul>\n+                        <li>abc <code>p {@code TEXT} q<\/code> def<\/li>\n+                        <\/ul>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ two list items; no code spans, the tag is processed\n+            LIST_LIST(\n+                    \"\"\"\n+\n+                        * abc `p {@code TAG}\n+                        * q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ul>\n+                        <li>abc `p <code>TAG<\/code><\/li>\n+                        <li>q` def<\/li>\n+                        <\/ul>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ a multi-line code span in a multi-line list item\n+            LIST_PARA(\n+                    \"\"\"\n+\n+                        * abc `p {@code TEXT}\n+                        q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                <ul>\n+                <li>abc <code>p {@code TEXT} q<\/code> def<\/li>\n+                <\/ul>\n+                <p>end<\/p>\"\"\"),\n+\n+            \/\/ a list item with a heavily indented continuation line,\n+            \/\/ including a multi-line code span\n+            LIST_INDENT(\n+                    \"\"\"\n+\n+                        * abc `p {@code TEXT}\n+                                      q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                <ul>\n+                <li>abc <code>p {@code TEXT} q<\/code> def<\/li>\n+                <\/ul>\n+                <p>end<\/p>\"\"\"),\n+\n+            SIMPLE_BLOCKQUOTE(\n+                    \"\"\"\n+\n+                        > abc `p {@code TEXT} q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <blockquote>\n+                        <p>abc <code>p {@code TEXT} q<\/code> def<\/p>\n+                        <\/blockquote>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ a multi-line code span in a multi-line block quote\n+            BLOCKQUOTE_BLOCKQUOTE(\n+                    \"\"\"\n+\n+                        > abc `p {@code TEXT}\n+                        > q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <blockquote>\n+                        <p>abc <code>p {@code TEXT} q<\/code> def<\/p>\n+                        <\/blockquote>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ a multi-line code span in a multi-line block quote\n+            BLOCKQUOTE_PARA(\n+                    \"\"\"\n+\n+                        > abc `p {@code TEXT}\n+                          q` def\n+\n+                        end\"\"\",\n+                            \"\"\"\n+                        <blockquote>\n+                        <p>abc <code>p {@code TEXT} q<\/code> def<\/p>\n+                        <\/blockquote>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ a block quote with a heavily indented continuation line,\n+            \/\/ including a multi-line code span\n+            BLOCKQUOTE_INDENT(\n+                    \"\"\"\n+\n+                        > abc `p {@code TEXT}\n+                                    q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                <blockquote>\n+                <p>abc <code>p {@code TEXT} q<\/code> def<\/p>\n+                <\/blockquote>\n+                <p>end<\/p>\"\"\"),\n+\n+            SIMPLE_ATX(\n+                    \"\"\"\n+\n+                        # abc `p2 {@code TEXT} q2` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <h4 id=\"abc-p2-code-text-q2-def-heading\">abc <code>p2 {@code TEXT} q2<\/code> def<\/h4>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ two ATX headings; no code spans, the tag is processed\n+            ATX_ATX(\n+                    \"\"\"\n+\n+                        # abc `p3 {@code TAG}\n+                        # q3` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <h4 id=\"abc-p3--heading\">abc `p3 <code>TAG<\/code><\/h4>\n+                        <h4 id=\"q3-def-heading\">q3` def<\/h4>\n+                        <p>end<\/p>\"\"\");\n+\n+            final String srcFragment;\n+            final String expect;\n+\n+            TestCase(String srcFragment, String expect) {\n+                this.srcFragment = srcFragment;\n+                this.expect = expect;\n+            }\n+        }\n+\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"\"\"\n+                    package p;\n+                    \/** Dummy. *\/\n+                    public class C {\n+                    private C() { }\n+                    \"\"\");\n+\n+        for (var tc: TestCase.values()) {\n+            sb.append(\"\"\"\n+                        \/\/\/ First sentence.\n+                        #FRAG#\n+                        public void #NAME#() { }\n+\n+                    \"\"\"\n+                    .replace(\"#FRAG#\", tc.srcFragment.lines()\n+                            .map(l -> \"\/\/\/ \" + l)\n+                            .collect(Collectors.joining(\"\\n    \")))\n+                    .replace(\"#NAME#\", tc.name().toLowerCase(Locale.ROOT)));\n+        }\n+\n+        sb.append(\"}\");\n+\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, sb.toString());\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        \/\/ any\/all instances of \"{@code TAG}\" should be translated to \"<code>TAG<\/code>\"\n+        checkOutput(\"p\/C.html\", false,\n+                \"{@code TAG}\");\n+\n+        for (var tc : TestCase.values()) {\n+            checkOutput(\"p\/C.html\", true,\n+                    \"\"\"\n+                        <span class=\"element-name\">#NAME#<\/span>()<\/div>\n+                        <div class=\"block\"><p>First sentence.<\/p>\n+                        #FRAG#\n+                        <\/div>\"\"\"\n+                            .replace(\"#NAME#\", tc.name().toLowerCase(Locale.ROOT))\n+                            .replace(\"#FRAG#\", tc.expect));\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownCodeSpans.java","additions":389,"deletions":0,"binary":false,"changes":389,"status":"added"},{"patch":"@@ -1,226 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug      8298405\n- * @summary  Markdown support in the standard doclet\n- * @library  \/tools\/lib ..\/..\/lib\n- * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n- * @build    toolbox.ToolBox javadoc.tester.*\n- * @run main TestMarkdownLineKind\n- *\/\n-\n-import javadoc.tester.JavadocTester;\n-import toolbox.ToolBox;\n-\n-import java.nio.file.Path;\n-import java.util.Locale;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-\/*\n- * These are \"somewhat silly\" tests of extreme corner cases, in which\n- * an unmatched backtick is followed by an inline tag, followed by more\n- * content which also has an unmatched backtick. The test is that\n- * the unmatched backticks are recognized as such, and not as a matched\n- * pair enclosing literal text.  Given how extreme the corner case is,\n- * the tests are basic and minimal and not intended to be exhaustive.\n- *\n- * The use of the inline tag is to detect whether the parser sees the\n- * backticks as a pair enclosing literal text, or as unmatched backticks\n- * leaving the characters, including the inline tag, to be interpreted\n- * appropriately.\n- *\n- * Note that the corner case only applies when there is the potential for\n- * an inline tag. If there is no inline tag, the Markdown parser will\n- * \"do the right thing\" with the backticks in the separate blocks.\n- *\n- * Also note that an author can force the use of an unmatched backtick\n- * by escaping it with a backslash, instead of relying on Markdown to\n- * recognize that a backtick is not matched within the current block.\n- *\/\n-public class TestMarkdownLineKind extends JavadocTester {\n-\n-    public static void main(String... args) throws Exception {\n-        var tester = new TestMarkdownLineKind();\n-        tester.runTests();\n-    }\n-\n-    ToolBox tb = new ToolBox();\n-\n-    enum TestCase {\n-        BLANK(\"\"\"\n-\n-                    abc ` def\"\"\",\n-                \"\"\"\n-                        <p>abc ` def<\/p>\"\"\"),\n-\n-        ATX_HEADER(\"\"\"\n-                    # ATX Heading ` more\n-                    \"\"\",\n-                \"\"\"\n-                    <h4 id=\"atx-heading-more-heading\">ATX Heading ` more<\/h4>\"\"\"),\n-\n-        \/\/ this is an almost redundant test case, since we need a blank line before the\n-        \/\/ setext heading, so that the heading does not get merged with the preceding text\n-        SETEXT_UNDERLINE(\"\"\"\n-\n-                    Setext Heading\n-                    =============\n-                    abc ` def\"\"\",\n-                \"\"\"\n-                    <h4 id=\"setext-heading-heading\">Setext Heading<\/h4>\n-                    <p>abc ` def<\/p>\"\"\"),\n-\n-        THEMATIC_BREAK_DASH(\"\"\"\n-                    - - - - - - - - - -\n-                    abc ` def\n-                    \"\"\",\n-                \"\"\"\n-                    <hr \/>\n-                    <p>abc ` def<\/p>\"\"\"),\n-\n-        THEMATIC_BREAK_ASTERISK(\"\"\"\n-                    * * * * *\n-                    abc ` def\"\"\",\n-                \"\"\"\n-                    <hr \/>\n-                    <p>abc ` def<\/p>\"\"\"),\n-\n-        THEMATIC_BREAK_UNDERLINE(\"\"\"\n-                    ____________\n-                    abc ` def\"\"\",\n-                \"\"\"\n-                    <hr \/>\n-                    <p>abc ` def<\/p>\"\"\"),\n-\n-        CODE_FENCE(\"\"\"\n-                    ```\n-                    code block\n-                    ```\"\"\",\n-                \"\"\"\n-                    <pre><code>code block\n-                    <\/code><\/pre>\"\"\"),\n-\n-        BULLETED_LIST_ITEM_SPACE(\"\"\"\n-                    * list ` item\"\"\",\n-                \"\"\"\n-                    <ul>\n-                    <li>list ` item<\/li>\n-                    <\/ul>\"\"\"),\n-\n-        BULLETED_LIST_ITEM_TAB(\"\"\"\n-                    *\\tlist ` item\"\"\",\n-                \"\"\"\n-                    <ul>\n-                    <li>list ` item<\/li>\n-                    <\/ul>\"\"\"),\n-\n-        ORDERED_LIST_ITEM_SPACE(\"\"\"\n-                    1. list ` item\"\"\",\n-                \"\"\"\n-                    <ol>\n-                    <li>list ` item<\/li>\n-                    <\/ol>\"\"\"),\n-\n-        ORDERED_LIST_ITEM_TAB(\"\"\"\n-                    1.\\tlist ` item\"\"\",\n-                \"\"\"\n-                    <ol>\n-                    <li>list ` item<\/li>\n-                    <\/ol>\"\"\"),\n-\n-        BLOCK_QUOTE(\"\"\"\n-                    > Block ` quote\"\"\",\n-                \"\"\"\n-                    <blockquote>\n-                    <p>Block ` quote<\/p>\n-                    <\/blockquote>\"\"\"),\n-\n-        \/\/ this is an almost redundant test case, since we need a blank line before the\n-        \/\/ code block, so that the content does not get merged with the preceding text\n-        INDENTED_CODE_BLOCK(\"\"\"\n-\n-                        indented code\n-                    abc `def\"\"\",\n-                \"\"\"\n-                        <pre><code>indented code\n-                        <\/code><\/pre>\n-                        <p>abc `def<\/p>\"\"\");\n-\n-        final String srcFragment;\n-        final String expect;\n-\n-        TestCase(String srcFragment, String expect) {\n-            this.srcFragment = srcFragment;\n-            this.expect = expect;\n-        }\n-\n-        String method() {\n-            return \"\"\"\n-                    \/\/\/ First sentence.\n-                    \/\/\/ Lorem ipsum ` {@code CODE}\n-                    #FRAG#\n-                    public void #NAME#() { }\n-                    \"\"\"\n-                    .replace(\"#FRAG#\", srcFragment.lines()\n-                            .map(l -> \"\/\/\/ \" + l + \"\\n\")\n-                            .collect(Collectors.joining()))\n-                    .replace(\"#NAME#\", name().toLowerCase(Locale.ROOT));\n-\n-        }\n-    }\n-\n-    @Test\n-    public void testLineKinds(Path base) throws Exception {\n-        Path src = base.resolve(\"src\");\n-        tb.writeJavaFiles(src, Stream.of(TestCase.values())\n-                .map(TestCase::method)\n-                .collect(Collectors.joining(\"\", \"\"\"\n-                    package p;\n-                    public class C {\n-                    \"\"\", \"\"\"\n-                    }\"\"\")));\n-\n-        javadoc(\"-d\", base.resolve(\"api\").toString(),\n-                \"--no-platform-links\",\n-                \"-Xdoclint:none\",\n-                \"--source-path\", src.toString(),\n-                \"p\");\n-        checkExit(Exit.OK);\n-\n-        for (var tc : TestCase.values()) {\n-            checkOutput(\"p\/C.html\", true,\n-                    \"\"\"\n-                        <span class=\"element-name\">#NAME#<\/span>()<\/div>\n-                        <div class=\"block\"><p>First sentence.\n-                        Lorem ipsum ` <code>CODE<\/code><\/p>\n-                        #FRAG#\n-                        <\/div>\"\"\"\n-                            .replace(\"#NAME#\", tc.name().toLowerCase(Locale.ROOT))\n-                            .replace(\"#FRAG#\", tc.expect));\n-        }\n-\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownLineKind.java","additions":0,"deletions":226,"binary":false,"changes":226,"status":"deleted"}]}