{"files":[{"patch":"@@ -29,2 +29,1 @@\n-import java.util.ArrayDeque;\n-import java.util.Deque;\n+import java.util.ArrayList;\n@@ -450,2 +449,0 @@\n-                                    \/\/ TODO: a fenced code block in a list item or block quote can be terminated\n-                                    \/\/       by end of that block\n@@ -1322,3 +1319,3 @@\n-     * A class to encapsulate the work to detect the boundaries of character\n-     * sequences of literal text, and to skip over such sequences, without\n-     * analyzing the content.\n+     * A class to encapsulate the work to parse Markdown enough to\n+     * detect the boundaries of character sequences of literal text,\n+     * and to skip over such sequences, without analyzing the content.\n@@ -1326,4 +1323,18 @@\n-     * The two primary factors are the current level of indentation,\n-     * used when checking for indented code blocks, and a serial number\n-     * that is incremented when a line is encountered that is not a\n-     * continuation of the previous block.\n+     * The primary factors are:\n+     *   - the content of the current line, including its indentation\n+     *   - the currently open set of container blocks, and any leaf block\n+     *   - a serial number that is incremented when a line is encountered\n+     *     that is not a continuation of the previous block.\n+     *\n+     * There are some limitations when using code blocks containing\n+     * strings that resemble tags, which should be treated as literal text.\n+     * In particular, list items are parsed individually and not as\n+     * part of an overall group of list items. This means that the\n+     * indentation is determined _for each item_, and not for the group\n+     * as a whole. This in turn implies that a list item cannot begin\n+     * with an indented code block. The workaround is to use a fenced code\n+     * block. It is also recommended, as a matter of style, that all\n+     * list items should use the same relative indentation for their content.\n+     *\n+     * The restrictions only apply when indented code blocks contain\n+     * strings resembling tags.\n@@ -1334,4 +1345,7 @@\n-        \/**\n-         * The current \"line kind\".\n-         *\/\n-        private LineKind lineKind = LineKind.OTHER;\n+        \/\/ Container blocks may nested contained blocks and leaf blocks.\n+        \/\/ Note, the code does not model lists, which would require\n+        \/\/ arbitrary multi-line lookahead.\n+        \/\/ https:\/\/spec.commonmark.org\/0.30\/#container-blocks\n+        private enum ContainerBlockKind {\n+            LIST_ITEM, QUOTE\n+        }\n@@ -1340,4 +1354,3 @@\n-         * A serial number for the current \"block\".\n-         * It is incremented whenever a line is encountered that indicates\n-         * the beginning of a new block, such that any potential code span\n-         * should be terminated as \"not a span\".\n+         * Details about a currently open container block.\n+         * @param blockKind the kind of block\n+         * @param indent the indentation for the block's content, for list items\n@@ -1345,1 +1358,1 @@\n-        private int blockId = 0;\n+        private record BlockInfo(ContainerBlockKind blockKind, int indent) { }\n@@ -1348,3 +1361,1 @@\n-         * The current indentation used to determine if a line is part of\n-         * an indented code block. Initially zero, it is increased while\n-         * analysing bulleted or ordered list items,\n+         * A list of the currently open container blocks.\n@@ -1352,1 +1363,11 @@\n-        private int currIndent = 0;\n+        private final java.util.List<BlockInfo> containers = new ArrayList<>();\n+\n+\n+        \/\/ Except for NONE, leaf blocks contain \"textual\" content.\n+        \/\/ Single-line leaf blocks, like ATX headings and thematic breaks are all represented by NONE.\n+        \/\/ See https:\/\/spec.commonmark.org\/0.30\/#leaf-blocks\n+        private enum LeafBlockKind {\n+            NONE, PARAGRAPH, FENCED_CODE, INDENTED_CODE\n+        }\n+\n+        private LeafBlockKind leafKind = LeafBlockKind.NONE;\n@@ -1355,4 +1376,4 @@\n-         * A stack of the indentation values for nested lists.\n-         * Initially empty, entries are pushed when a top-level or\n-         * nested list item is encountered, and removed when a\n-         * less indented line is encountered.\n+         * A serial number for the current \"block\".\n+         * It is updated whenever a line is encountered that indicates\n+         * the beginning of a new block, such that any potential code span\n+         * should be terminated as \"not a span\".\n@@ -1360,1 +1381,1 @@\n-        private final Deque<Integer> indentStack = new ArrayDeque<>();\n+        private int blockId = 0;\n@@ -1366,4 +1387,2 @@\n-         * 1. Determine the indentation used to identify indented code blocks.\n-         * 2. Determine if the current line should be considered a continuation\n-         *    of the preceding block, or the beginning of a new block. This is\n-         *    used when determining the end (if any) of a potential code span.\n+         * 1. Determine any change to the current list of container blocks\n+         * 2. Determine if the current line is part of a code block\n@@ -1372,1 +1391,1 @@\n-            var prevLineKind = lineKind;\n+            var prevLeafKind = leafKind;\n@@ -1374,5 +1393,0 @@\n-            if (ch == '\\r' || ch == '\\n') {\n-                lineKind = LineKind.BLANK;\n-                blockId++;\n-                return;\n-            }\n@@ -1380,3 +1394,39 @@\n-            while (indent < currIndent) {\n-                currIndent = indentStack.pop();\n-            }\n+            final var line = peekLine();\n+            var peekIndex = 0;  \/\/ index into `line`; note it does not include `indent`\n+            var blockIndex = 0; \/\/ index into `blocks`\n+\n+            \/\/ Iterate examining the beginning of the line, left to right,\n+            \/\/ comparing indications of containers (indentation or markers)\n+            \/\/ against the list of currently open container blocks.\n+            \/\/ Side effects may open nested blocks or close existing ones.\n+            while (true) {\n+                if (blockIndex == containers.size()) {\n+                    \/\/ check for an open code block\n+                    if (prevLeafKind == LeafBlockKind.FENCED_CODE) {\n+                        return;\n+                    } else {\n+                        var codeIndent = (containers.isEmpty() ? 0 : containers.getLast().indent) + 4;\n+                        if (indent >= codeIndent && prevLeafKind != LeafBlockKind.PARAGRAPH) {\n+                            leafKind = LeafBlockKind.INDENTED_CODE;\n+                            if (leafKind != prevLeafKind) {\n+                                blockId++;\n+                            }\n+                            return;\n+                        }\n+                    }\n+                    \/\/ examine the remaining part of the lne\n+                    var peekLineKind = getLineKind(line.substring(peekIndex));\n+                    switch (peekLineKind) {\n+                        case BULLETED_LIST_ITEM, ORDERED_LIST_ITEM -> {\n+                            var count = indent;\n+                            \/\/ skip over the list marker\n+                            while (ch != ' ' && ch != '\\t') {\n+                                count++;\n+                                nextChar();\n+                            }\n+                            var listItemIndent = readIndent(count);\n+                            containers.add(new BlockInfo(ContainerBlockKind.LIST_ITEM, listItemIndent));\n+                            blockIndex++;\n+                            peekIndex = listItemIndent - indent;\n+                            blockId++;\n+                        }\n@@ -1384,7 +1434,6 @@\n-            if (indent >= currIndent + 4 && !isParagraph(prevLineKind)) {\n-                if (prevLineKind != LineKind.INDENTED_CODE_BLOCK) {\n-                    blockId++;\n-                }\n-                lineKind = LineKind.INDENTED_CODE_BLOCK;\n-                return;\n-            }\n+                        case BLOCK_QUOTE -> {\n+                            containers.add(new BlockInfo(ContainerBlockKind.QUOTE,  indent + 1));\n+                            blockIndex++;\n+                            peekIndex += 1;\n+                            blockId++;\n+                        }\n@@ -1392,7 +1441,4 @@\n-            lineKind = peekLineKind();\n-            switch (lineKind) {\n-                case BLOCK_QUOTE -> {\n-                    if (prevLineKind != LineKind.BLOCK_QUOTE) {\n-                        blockId++;\n-                    }\n-                }\n+                        case OTHER -> {\n+                            leafKind = LeafBlockKind.PARAGRAPH;\n+                            return;\n+                        }\n@@ -1400,17 +1446,5 @@\n-                case BULLETED_LIST_ITEM, ORDERED_LIST_ITEM -> {\n-                    var count = indent;\n-                    while (ch != ' ' && ch != '\\t') {\n-                        count++;\n-                        nextChar();\n-                    }\n-                    var listItemIndent = readIndent(count);\n-                    if (listItemIndent > count + 4) {\n-                        indentStack.push(currIndent);\n-                        currIndent = count + 4;\n-                        lineKind = LineKind.INDENTED_CODE_BLOCK;\n-                    } else if (indent >= currIndent) {\n-                        indentStack.push(currIndent);\n-                        currIndent = listItemIndent;\n-                    }\n-                    blockId++;\n-                }\n+                        case ATX_HEADER, SETEXT_UNDERLINE, THEMATIC_BREAK, BLANK -> {\n+                            leafKind = LeafBlockKind.NONE;\n+                            blockId++;\n+                            return;\n+                        }\n@@ -1418,4 +1452,2 @@\n-                case OTHER -> {\n-                    switch (prevLineKind) {\n-                        case BLOCK_QUOTE, BULLETED_LIST_ITEM, ORDERED_LIST_ITEM, OTHER -> { }\n-                        default -> {\n+                        case CODE_FENCE -> {\n+                            leafKind = LeafBlockKind.FENCED_CODE;\n@@ -1423,0 +1455,1 @@\n+                            return;\n@@ -1425,1 +1458,21 @@\n-                }\n+                } else {\n+                    var block = containers.get(blockIndex);\n+                    var blockKind = block.blockKind;\n+                    switch (blockKind) {\n+                        case LIST_ITEM -> {\n+                            if (indent >= block.indent) {\n+                                blockIndex++;\n+                            } else {\n+                                var peekLineKind = getLineKind(line.substring(peekIndex));\n+                                if (peekLineKind == LineKind.BLANK) {\n+                                    \/\/ blank lines are considered to be part of a list item\n+                                    blockIndex++;\n+                                } else if (peekLineKind == LineKind.OTHER && prevLeafKind == LeafBlockKind.PARAGRAPH) {\n+                                    \/\/ lazy continuation line: leaf kind and id are unchanged\n+                                    return;\n+                                } else {\n+                                    closeContainer(blockIndex);\n+                                    blockId++;\n+                                }\n+                            }\n+                        }\n@@ -1427,4 +1480,13 @@\n-                case BLANK, ATX_HEADER, SETEXT_UNDERLINE, THEMATIC_BREAK, CODE_FENCE,\n-                        INDENTED_CODE_BLOCK -> {\n-                    blockId++;\n-                }\n+                        case QUOTE -> {\n+                            var peekLineKind = getLineKind(line.substring(peekIndex));\n+                            if (peekLineKind == LineKind.BLOCK_QUOTE) {\n+                                blockIndex++;\n+                                peekIndex++;\n+                            } else if (peekLineKind == LineKind.OTHER && prevLeafKind == LeafBlockKind.PARAGRAPH) {\n+                                \/\/ lazy continuation line: leaf kind and id are unchanged\n+                                return;\n+                            } else {\n+                                closeContainer(blockIndex);\n+                                blockId++;\n+                            }\n+                        }\n@@ -1432,2 +1494,2 @@\n-                default -> {\n-                    throw new Error(lineKind.toString());\n+                        default -> throw new IllegalStateException(blockKind.toString());\n+                    }\n@@ -1439,1 +1501,1 @@\n-         * {@return {@code true} if this line should be treated as an indented code block,\n+         * {@return {@code true} if the current line is part of an indented code block,\n@@ -1444,1 +1506,1 @@\n-            return lineKind == LineKind.INDENTED_CODE_BLOCK;\n+            return leafKind == LeafBlockKind.INDENTED_CODE;\n@@ -1448,1 +1510,1 @@\n-         * {@return {@code true} if this line should be treated as code fence,\n+         * {@return {@code true} if the current line is part of a fenced code block,\n@@ -1454,1 +1516,1 @@\n-            return lineKind == LineKind.CODE_FENCE;\n+            return leafKind == LeafBlockKind.FENCED_CODE;\n@@ -1457,5 +1519,7 @@\n-        private boolean isParagraph(LineKind lk) {\n-            return switch (lk) {\n-                case BULLETED_LIST_ITEM, ORDERED_LIST_ITEM, BLOCK_QUOTE, OTHER -> true;\n-                default -> false;\n-            };\n+        \/**\n+         * Closes a given container block, and any open nested blocks.\n+         *\n+         * @param index the index of the block to be closed\n+         *\/\n+        private void closeContainer(int index) {\n+            containers.subList(index, containers.size()).clear();\n@@ -1478,0 +1542,1 @@\n+         *\n@@ -1480,1 +1545,4 @@\n-         * In fenced content, the ending delimiter must appear at the end of a line.\n+         *\n+         * In fenced content, the ending delimiter must appear at the start of a line;\n+         * the code block may also be terminated implicitly by the end of a containing block.\n+         *\n@@ -1490,1 +1558,2 @@\n-            var initialLineKind = lineKind;\n+            var initialLeafKind = leafKind;\n+            var isFenced = (leafKind == LeafBlockKind.FENCED_CODE);\n@@ -1497,5 +1566,5 @@\n-                        switch (initialLineKind) {\n-                            case CODE_FENCE -> {\n-                                if (lineKind == LineKind.CODE_FENCE && ch == term && count(ch) >= count) {\n-                                    return bp;\n-                                }\n+                        if (isFenced) {\n+                            if (leafKind == LeafBlockKind.FENCED_CODE && ch == term && count(ch) >= count\n+                                    || blockId != initialBlockId) {\n+                                leafKind = LeafBlockKind.NONE;\n+                                return bp;\n@@ -1503,5 +1572,3 @@\n-\n-                            default -> {\n-                                if (blockId != initialBlockId) {\n-                                    return -1;\n-                                }\n+                        } else {\n+                            if (blockId != initialBlockId) {\n+                                return -1;\n@@ -1513,1 +1580,1 @@\n-                        if (ch == term && initialLineKind != LineKind.CODE_FENCE ) {\n+                        if (ch == term && initialLeafKind != LeafBlockKind.FENCED_CODE ) {\n@@ -1550,2 +1617,2 @@\n-         * Peeks ahead at the current line, and matches it against an ordered series\n-         * of regular expressions, to determine the \"kind\" of the line.\n+         * Matches a string against an ordered series of regular expressions,\n+         * to determine the \"kind\" of the string.\n@@ -1555,2 +1622,6 @@\n-        private LineKind peekLineKind() {\n-            switch (ch) {\n+        private LineKind getLineKind(String s) {\n+            if (s.isBlank()) {\n+                return LineKind.BLANK;\n+            }\n+\n+            switch (s.charAt(0)) {\n@@ -1559,1 +1630,0 @@\n-                    String line = peekLine();\n@@ -1561,4 +1631,2 @@\n-                        if (lk.pattern != null) {\n-                            if (lk.pattern.matcher(line).matches()) {\n-                                return lk;\n-                            }\n+                        if (lk.pattern.matcher(s).matches()) {\n+                            return lk;\n@@ -1569,0 +1637,1 @@\n+\n@@ -1603,0 +1672,10 @@\n+\n+        \/\/ unused, but useful when debugging\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName()\n+                    + \"[containers:\" + containers\n+                    + \", leafKind:\" + leafKind\n+                    + \", blockId:\" + blockId\n+                    + \"]\";\n+        }\n@@ -1675,7 +1754,0 @@\n-        \/**\n-         * Indented code blocks are defined by preceding lines and indentation,\n-         * not by any line-specific pattern.\n-         * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#indented-code-block\">Indented Code Block<\/a>\n-         *\/\n-        INDENTED_CODE_BLOCK(null),\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":194,"deletions":122,"binary":false,"changes":316,"status":"modified"},{"patch":"@@ -240,0 +240,62 @@\n+\n+    @Test\n+    public void testAnnos(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+\n+        \/\/ in the following, note that the @ following the backtick\n+        \/\/ is just a literal character and not part of any tag\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ First sentence.\n+                        \/\/\/ 1.  list item\n+                        \/\/\/\n+                        \/\/\/     \\\\@Anno1 plain\n+                        \/\/\/\n+                        \/\/\/     abc `\n+                        \/\/\/     @Anno2 in span\n+                        \/\/\/     `\n+                        \/\/\/\n+                        \/\/\/     ```\n+                        \/\/\/     @Anno3 fenced\n+                        \/\/\/     ```\n+                        \/\/\/\n+                        \/\/\/         @Anno4 indented\n+                        \/\/\/\n+                        \/\/\/     end of list item\n+                        \/\/\/\n+                        \/\/\/ end\n+                        public void m() { }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:syntax\", \/\/ enable check for \"no tag after '@'\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(Output.OUT, false,\n+                \"C.java:4: error: no tag name after '@'\",\n+                \"unknown tag\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <ol>\n+                    <li>\n+                    <p>list item<\/p>\n+                    <p>@Anno1 plain<\/p>\n+                    <p>abc <code>@Anno2 in span<\/code><\/p>\n+                    <pre><code>@Anno3 fenced\n+                    <\/code><\/pre>\n+                    <pre><code>@Anno4 indented\n+                    <\/code><\/pre>\n+                    <p>end of list item<\/p>\n+                    <\/li>\n+                    <\/ol>\n+                    <p>end<\/p>\n+                    \"\"\");\n+\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdown.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -203,0 +203,19 @@\n+            LIST_UNCLOSED_FENCE(\n+                    \"\"\"\n+                        1.  list item\n+                            ```\n+                            fenced-code\n+                            @Anno\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ol>\n+                        <li>list item\n+                        <pre><code>fenced-code\n+                        @Anno\n+\n+                        <\/code><\/pre>\n+                        <\/li>\n+                        <\/ol>\n+                        <p>end<\/p>\"\"\"),\n+\n@@ -227,0 +246,29 @@\n+            BLOCK_FENCE(\n+                    \"\"\"\n+                        > ```\n+                        > fenced code\n+                        > @Anno\n+                        > ```\n+                        end\"\"\",\n+                    \"\"\"\n+                        <blockquote>\n+                        <pre><code>fenced code\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <\/blockquote>\n+                        <p>end<\/p>\"\"\"),\n+\n+            BLOCK_UNCLOSED_FENCE(\n+                    \"\"\"\n+                        > ```\n+                        > fenced code\n+                        > @Anno\n+                        end\"\"\",\n+                    \"\"\"\n+                        <blockquote>\n+                        <pre><code>fenced code\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <\/blockquote>\n+                        <p>end<\/p>\"\"\"),\n+\n@@ -341,0 +389,1 @@\n+            out.println(\"Test case: \" + tc);\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownCodeBlocks.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"}]}