{"files":[{"patch":"@@ -44,0 +44,1 @@\n+    private int width;\n@@ -57,1 +58,1 @@\n-     * @return the cell alignment\n+     * @return the cell alignment or {@code null} if no specific alignment\n@@ -67,0 +68,11 @@\n+    \/**\n+     * @return the cell width (the number of dash and colon characters in the delimiter row of the table for this column)\n+     *\/\n+    public int getWidth() {\n+        return width;\n+    }\n+\n+    public void setWidth(int width) {\n+        this.width = width;\n+    }\n+\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/TableCell.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.org.commonmark.ext.gfm.tables.internal.TableMarkdownNodeRenderer;\n@@ -44,0 +45,3 @@\n+import jdk.internal.org.commonmark.renderer.markdown.MarkdownNodeRendererContext;\n+import jdk.internal.org.commonmark.renderer.markdown.MarkdownNodeRendererFactory;\n+import jdk.internal.org.commonmark.renderer.markdown.MarkdownRenderer;\n@@ -48,0 +52,3 @@\n+import java.util.Collections;\n+import java.util.Set;\n+\n@@ -62,1 +69,1 @@\n-        TextContentRenderer.TextContentRendererExtension {\n+        TextContentRenderer.TextContentRendererExtension, MarkdownRenderer.MarkdownRendererExtension {\n@@ -95,0 +102,15 @@\n+\n+    @Override\n+    public void extend(MarkdownRenderer.Builder rendererBuilder) {\n+        rendererBuilder.nodeRendererFactory(new MarkdownNodeRendererFactory() {\n+            @Override\n+            public NodeRenderer create(MarkdownNodeRendererContext context) {\n+                return new TableMarkdownNodeRenderer(context);\n+            }\n+\n+            @Override\n+            public Set<Character> getSpecialCharacters() {\n+                return Collections.singleton('|');\n+            }\n+        });\n+    }\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/TablesExtension.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.internal.org.commonmark.internal.util.Parsing;\n@@ -44,0 +43,1 @@\n+import jdk.internal.org.commonmark.text.Characters;\n@@ -52,1 +52,1 @@\n-    private final List<TableCell.Alignment> columns;\n+    private final List<TableCellInfo> columns;\n@@ -56,1 +56,1 @@\n-    private TableBlockParser(List<TableCell.Alignment> columns, SourceLine headerLine) {\n+    private TableBlockParser(List<TableCellInfo> columns, SourceLine headerLine) {\n@@ -74,1 +74,1 @@\n-        int pipe = Parsing.find('|', content, state.getNextNonSpaceIndex());\n+        int pipe = Characters.find('|', content, state.getNextNonSpaceIndex());\n@@ -78,1 +78,1 @@\n-                if (Parsing.skipSpaceTab(content, pipe + 1, content.length()) == content.length()) {\n+                if (Characters.skipSpaceTab(content, pipe + 1, content.length()) == content.length()) {\n@@ -155,1 +155,3 @@\n-            tableCell.setAlignment(columns.get(column));\n+            TableCellInfo cellInfo = columns.get(column);\n+            tableCell.setAlignment(cellInfo.getAlignment());\n+            tableCell.setWidth(cellInfo.getWidth());\n@@ -159,2 +161,2 @@\n-        int start = Parsing.skipSpaceTab(content, 0, content.length());\n-        int end = Parsing.skipSpaceTabBackwards(content, content.length() - 1, start);\n+        int start = Characters.skipSpaceTab(content, 0, content.length());\n+        int end = Characters.skipSpaceTabBackwards(content, content.length() - 1, start);\n@@ -168,1 +170,1 @@\n-        int nonSpace = Parsing.skipSpaceTab(row, 0, row.length());\n+        int nonSpace = Characters.skipSpaceTab(row, 0, row.length());\n@@ -175,1 +177,1 @@\n-            int nonSpaceEnd = Parsing.skipSpaceTabBackwards(row, row.length() - 1, cellStart);\n+            int nonSpaceEnd = Characters.skipSpaceTabBackwards(row, row.length() - 1, cellStart);\n@@ -222,2 +224,2 @@\n-    private static List<TableCell.Alignment> parseSeparator(CharSequence s) {\n-        List<TableCell.Alignment> columns = new ArrayList<>();\n+    private static List<TableCellInfo> parseSeparator(CharSequence s) {\n+        List<TableCellInfo> columns = new ArrayList<>();\n@@ -227,0 +229,1 @@\n+        int width = 0;\n@@ -251,0 +254,1 @@\n+                        width++;\n@@ -255,0 +259,1 @@\n+                        width++;\n@@ -264,0 +269,1 @@\n+                        width++;\n@@ -265,1 +271,2 @@\n-                    columns.add(getAlignment(left, right));\n+                    columns.add(new TableCellInfo(getAlignment(left, right), width));\n+                    width = 0;\n@@ -302,1 +309,1 @@\n-            if (paragraphLines.size() == 1 && Parsing.find('|', paragraphLines.get(0).getContent(), 0) != -1) {\n+            if (paragraphLines.size() == 1 && Characters.find('|', paragraphLines.get(0).getContent(), 0) != -1) {\n@@ -305,1 +312,1 @@\n-                List<TableCell.Alignment> columns = parseSeparator(separatorLine.getContent());\n+                List<TableCellInfo> columns = parseSeparator(separatorLine.getContent());\n@@ -319,0 +326,18 @@\n+\n+    private static class TableCellInfo {\n+        private final TableCell.Alignment alignment;\n+        private final int width;\n+\n+        public TableCell.Alignment getAlignment() {\n+            return alignment;\n+        }\n+\n+        public int getWidth() {\n+            return width;\n+        }\n+\n+        public TableCellInfo(TableCell.Alignment alignment, int width) {\n+            this.alignment = alignment;\n+            this.width = width;\n+        }\n+    }\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/internal\/TableBlockParser.java","additions":40,"deletions":15,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables.internal;\n+\n+import jdk.internal.org.commonmark.ext.gfm.tables.*;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.renderer.markdown.MarkdownNodeRendererContext;\n+import jdk.internal.org.commonmark.renderer.markdown.MarkdownWriter;\n+import jdk.internal.org.commonmark.text.AsciiMatcher;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * The Table node renderer that is needed for rendering GFM tables (GitHub Flavored Markdown) to text content.\n+ *\/\n+public class TableMarkdownNodeRenderer extends TableNodeRenderer implements NodeRenderer {\n+    private final MarkdownWriter writer;\n+    private final MarkdownNodeRendererContext context;\n+\n+    private final AsciiMatcher pipe = AsciiMatcher.builder().c('|').build();\n+\n+    private final List<TableCell.Alignment> columns = new ArrayList<>();\n+\n+    public TableMarkdownNodeRenderer(MarkdownNodeRendererContext context) {\n+        this.writer = context.getWriter();\n+        this.context = context;\n+    }\n+\n+    @Override\n+    protected void renderBlock(TableBlock node) {\n+        columns.clear();\n+        writer.pushTight(true);\n+        renderChildren(node);\n+        writer.popTight();\n+        writer.block();\n+    }\n+\n+    @Override\n+    protected void renderHead(TableHead node) {\n+        renderChildren(node);\n+        for (TableCell.Alignment columnAlignment : columns) {\n+            writer.raw('|');\n+            if (columnAlignment == TableCell.Alignment.LEFT) {\n+                writer.raw(\":---\");\n+            } else if (columnAlignment == TableCell.Alignment.RIGHT) {\n+                writer.raw(\"---:\");\n+            } else if (columnAlignment == TableCell.Alignment.CENTER) {\n+                writer.raw(\":---:\");\n+            } else {\n+                writer.raw(\"---\");\n+            }\n+        }\n+        writer.raw(\"|\");\n+        writer.block();\n+    }\n+\n+    @Override\n+    protected void renderBody(TableBody node) {\n+        renderChildren(node);\n+    }\n+\n+    @Override\n+    protected void renderRow(TableRow node) {\n+        renderChildren(node);\n+        \/\/ Trailing | at the end of the line\n+        writer.raw(\"|\");\n+        writer.block();\n+    }\n+\n+    @Override\n+    protected void renderCell(TableCell node) {\n+        if (node.getParent() != null && node.getParent().getParent() instanceof TableHead) {\n+            columns.add(node.getAlignment());\n+        }\n+        writer.raw(\"|\");\n+        writer.pushRawEscape(pipe);\n+        renderChildren(node);\n+        writer.popRawEscape();\n+    }\n+\n+    private void renderChildren(Node parent) {\n+        Node node = parent.getFirstChild();\n+        while (node != null) {\n+            Node next = node.getNext();\n+            context.render(node);\n+            node = next;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/internal\/TableMarkdownNodeRenderer.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.org.commonmark.text.Characters;\n@@ -65,1 +66,1 @@\n-            if (Parsing.isSpaceOrTab(state.getLine().getContent(), nextNonSpace + 1)) {\n+            if (Characters.isSpaceOrTab(state.getLine().getContent(), nextNonSpace + 1)) {\n@@ -85,1 +86,1 @@\n-                if (Parsing.isSpaceOrTab(state.getLine().getContent(), nextNonSpace + 1)) {\n+                if (Characters.isSpaceOrTab(state.getLine().getContent(), nextNonSpace + 1)) {\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/BlockQuoteParser.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.org.commonmark.internal.inline.Position;\n@@ -37,0 +36,1 @@\n+import jdk.internal.org.commonmark.parser.beta.Position;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/Bracket.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.internal.org.commonmark.text.Characters;\n@@ -147,1 +148,1 @@\n-        while ((lineBreak = Parsing.findLineBreak(input, lineStart)) != -1) {\n+        while ((lineBreak = Characters.findLineBreak(input, lineStart)) != -1) {\n@@ -265,1 +266,1 @@\n-            if (isBlank() || (indent < Parsing.CODE_BLOCK_INDENT && Parsing.isLetter(this.line.getContent(), nextNonSpace))) {\n+            if (isBlank() || (indent < Parsing.CODE_BLOCK_INDENT && Characters.isLetter(this.line.getContent(), nextNonSpace))) {\n@@ -350,1 +351,1 @@\n-        CharSequence lineContent = Parsing.prepareLine(ln);\n+        CharSequence lineContent = prepareLine(ln);\n@@ -577,0 +578,29 @@\n+    \/**\n+     * Prepares the input line replacing {@code \\0}\n+     *\/\n+    private static CharSequence prepareLine(CharSequence line) {\n+        \/\/ Avoid building a new string in the majority of cases (no \\0)\n+        StringBuilder sb = null;\n+        int length = line.length();\n+        for (int i = 0; i < length; i++) {\n+            char c = line.charAt(i);\n+            if (c == '\\0') {\n+                if (sb == null) {\n+                    sb = new StringBuilder(length);\n+                    sb.append(line, 0, i);\n+                }\n+                sb.append('\\uFFFD');\n+            } else {\n+                if (sb != null) {\n+                    sb.append(c);\n+                }\n+            }\n+        }\n+\n+        if (sb != null) {\n+            return sb.toString();\n+        } else {\n+            return line;\n+        }\n+    }\n+\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/DocumentParser.java","additions":33,"deletions":3,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.internal.org.commonmark.text.Characters;\n@@ -46,0 +47,2 @@\n+    private final char fenceChar;\n+    private final int openingFenceLength;\n@@ -51,2 +54,4 @@\n-        block.setFenceChar(fenceChar);\n-        block.setFenceLength(fenceLength);\n+        this.fenceChar = fenceChar;\n+        this.openingFenceLength = fenceLength;\n+        block.setFenceCharacter(String.valueOf(fenceChar));\n+        block.setOpeningFenceLength(fenceLength);\n@@ -66,1 +71,1 @@\n-        if (state.getIndent() < Parsing.CODE_BLOCK_INDENT && nextNonSpace < line.length() && line.charAt(nextNonSpace) == block.getFenceChar() && isClosing(line, nextNonSpace)) {\n+        if (state.getIndent() < Parsing.CODE_BLOCK_INDENT && nextNonSpace < line.length() && tryClosing(line, nextNonSpace)) {\n@@ -110,1 +115,1 @@\n-                return BlockStart.of(blockParser).atIndex(nextNonSpace + blockParser.block.getFenceLength());\n+                return BlockStart.of(blockParser).atIndex(nextNonSpace + blockParser.block.getOpeningFenceLength());\n@@ -138,1 +143,1 @@\n-            if (Parsing.find('`', line, index + backticks) != -1) {\n+            if (Characters.find('`', line, index + backticks) != -1) {\n@@ -153,5 +158,3 @@\n-    private boolean isClosing(CharSequence line, int index) {\n-        char fenceChar = block.getFenceChar();\n-        int fenceLength = block.getFenceLength();\n-        int fences = Parsing.skip(fenceChar, line, index, line.length()) - index;\n-        if (fences < fenceLength) {\n+    private boolean tryClosing(CharSequence line, int index) {\n+        int fences = Characters.skip(fenceChar, line, index, line.length()) - index;\n+        if (fences < openingFenceLength) {\n@@ -161,2 +164,6 @@\n-        int after = Parsing.skipSpaceTab(line, index + fences, line.length());\n-        return after == line.length();\n+        int after = Characters.skipSpaceTab(line, index + fences, line.length());\n+        if (after == line.length()) {\n+            block.setClosingFenceLength(fences);\n+            return true;\n+        }\n+        return false;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/FencedCodeBlockParser.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-import jdk.internal.org.commonmark.internal.inline.Position;\n-import jdk.internal.org.commonmark.internal.inline.Scanner;\n@@ -43,0 +41,2 @@\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n@@ -44,0 +44,1 @@\n+import jdk.internal.org.commonmark.text.Characters;\n@@ -183,2 +184,2 @@\n-        int afterMarker = Parsing.skip(marker, line, index, line.length());\n-        int afterSpace = Parsing.skipSpaceTab(line, afterMarker, line.length());\n+        int afterMarker = Characters.skip(marker, line, index, line.length());\n+        int afterSpace = Characters.skipSpaceTab(line, afterMarker, line.length());\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/HeadingParser.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.org.commonmark.internal.util.Parsing;\n@@ -46,0 +45,15 @@\n+    private static final String TAGNAME = \"[A-Za-z][A-Za-z0-9-]*\";\n+    private static final String ATTRIBUTENAME = \"[a-zA-Z_:][a-zA-Z0-9:._-]*\";\n+    private static final String UNQUOTEDVALUE = \"[^\\\"'=<>`\\\\x00-\\\\x20]+\";\n+    private static final String SINGLEQUOTEDVALUE = \"'[^']*'\";\n+    private static final String DOUBLEQUOTEDVALUE = \"\\\"[^\\\"]*\\\"\";\n+    private static final String ATTRIBUTEVALUE = \"(?:\" + UNQUOTEDVALUE + \"|\" + SINGLEQUOTEDVALUE\n+            + \"|\" + DOUBLEQUOTEDVALUE + \")\";\n+    private static final String ATTRIBUTEVALUESPEC = \"(?:\" + \"\\\\s*=\" + \"\\\\s*\" + ATTRIBUTEVALUE\n+            + \")\";\n+    private static final String ATTRIBUTE = \"(?:\" + \"\\\\s+\" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC\n+            + \"?)\";\n+\n+    private static final String OPENTAG = \"<\" + TAGNAME + ATTRIBUTE + \"*\" + \"\\\\s*\/?>\";\n+    private static final String CLOSETAG = \"<\/\" + TAGNAME + \"\\\\s*[>]\";\n+\n@@ -82,1 +96,1 @@\n-                            \"section|source|summary|\" +\n+                            \"search|section|summary|\" +\n@@ -89,1 +103,1 @@\n-                    Pattern.compile(\"^(?:\" + Parsing.OPENTAG + '|' + Parsing.CLOSETAG + \")\\\\s*$\", Pattern.CASE_INSENSITIVE),\n+                    Pattern.compile(\"^(?:\" + OPENTAG + '|' + CLOSETAG + \")\\\\s*$\", Pattern.CASE_INSENSITIVE),\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/HtmlBlockParser.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.internal.org.commonmark.text.Characters;\n@@ -75,1 +76,1 @@\n-            if (!Parsing.isBlank(lines.get(lastNonBlank))) {\n+            if (!Characters.isBlank(lines.get(lastNonBlank))) {\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/IndentedCodeBlockParser.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.org.commonmark.internal.inline.Scanner;\n@@ -39,1 +38,0 @@\n-import jdk.internal.org.commonmark.internal.util.Parsing;\n@@ -44,0 +42,2 @@\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n@@ -45,0 +45,1 @@\n+import jdk.internal.org.commonmark.text.Characters;\n@@ -517,1 +518,1 @@\n-            int end = Parsing.skipBackwards(' ', content, content.length() - 1, 0) + 1;\n+            int end = Characters.skipBackwards(' ', content, content.length() - 1, 0) + 1;\n@@ -522,1 +523,1 @@\n-            int end = Parsing.skipSpaceTabBackwards(content, content.length() - 1, 0) + 1;\n+            int end = Characters.skipSpaceTabBackwards(content, content.length() - 1, 0) + 1;\n@@ -560,4 +561,4 @@\n-        boolean beforeIsPunctuation = before == Scanner.END || Parsing.isPunctuationCodePoint(before);\n-        boolean beforeIsWhitespace = before == Scanner.END || Parsing.isWhitespaceCodePoint(before);\n-        boolean afterIsPunctuation = after == Scanner.END || Parsing.isPunctuationCodePoint(after);\n-        boolean afterIsWhitespace = after == Scanner.END || Parsing.isWhitespaceCodePoint(after);\n+        boolean beforeIsPunctuation = before == Scanner.END || Characters.isPunctuationCodePoint(before);\n+        boolean beforeIsWhitespace = before == Scanner.END || Characters.isWhitespaceCodePoint(before);\n+        boolean afterIsPunctuation = after == Scanner.END || Characters.isPunctuationCodePoint(after);\n+        boolean afterIsWhitespace = after == Scanner.END || Characters.isWhitespaceCodePoint(after);\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/InlineParserImpl.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-import jdk.internal.org.commonmark.internal.inline.Position;\n-import jdk.internal.org.commonmark.internal.inline.Scanner;\n@@ -43,0 +41,2 @@\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n@@ -135,0 +135,4 @@\n+        \/\/ Finish any outstanding references now. We don't do this earlier because we need addSourceSpan to have been\n+        \/\/ called before we do it.\n+        finishReference();\n+\n@@ -240,1 +244,0 @@\n-            finishReference();\n@@ -270,1 +273,0 @@\n-        finishReference();\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/LinkReferenceDefinitionParser.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import java.util.Objects;\n+\n@@ -125,1 +127,1 @@\n-            if (listBlock instanceof OrderedList && ((OrderedList) listBlock).getStartNumber() != 1) {\n+            if (listBlock instanceof OrderedList && ((OrderedList) listBlock).getMarkerStartNumber() != 1) {\n@@ -151,1 +153,1 @@\n-                    bulletList.setBulletMarker(c);\n+                    bulletList.setMarker(String.valueOf(c));\n@@ -189,2 +191,2 @@\n-                        orderedList.setStartNumber(Integer.parseInt(number));\n-                        orderedList.setDelimiter(c);\n+                        orderedList.setMarkerStartNumber(Integer.parseInt(number));\n+                        orderedList.setMarkerDelimiter(String.valueOf(c));\n@@ -223,1 +225,1 @@\n-            return equals(((BulletList) a).getBulletMarker(), ((BulletList) b).getBulletMarker());\n+            return Objects.equals(((BulletList) a).getMarker(), ((BulletList) b).getMarker());\n@@ -225,1 +227,1 @@\n-            return equals(((OrderedList) a).getDelimiter(), ((OrderedList) b).getDelimiter());\n+            return Objects.equals(((OrderedList) a).getMarkerDelimiter(), ((OrderedList) b).getMarkerDelimiter());\n@@ -230,4 +232,0 @@\n-    private static boolean equals(Object a, Object b) {\n-        return (a == null) ? (b == null) : a.equals(b);\n-    }\n-\n@@ -252,1 +250,1 @@\n-            ListItemParser listItemParser = new ListItemParser(newColumn - state.getColumn());\n+            ListItemParser listItemParser = new ListItemParser(state.getIndent(), newColumn - state.getColumn());\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/ListBlockParser.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    public ListItemParser(int contentIndent) {\n+    public ListItemParser(int markerIndent, int contentIndent) {\n@@ -57,0 +57,2 @@\n+        block.setMarkerIndent(markerIndent);\n+        block.setContentIndent(contentIndent);\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/ListItemParser.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,4 @@\n+    public ThematicBreakParser(String literal) {\n+        block.setLiteral(literal);\n+    }\n+\n@@ -64,1 +68,2 @@\n-                return BlockStart.of(new ThematicBreakParser()).atIndex(line.length());\n+                var literal = String.valueOf(line.subSequence(state.getIndex(), line.length()));\n+                return BlockStart.of(new ThematicBreakParser(literal)).atIndex(line.length());\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/ThematicBreakParser.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/AutolinkInlineParser.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.internal.org.commonmark.node.Node;\n@@ -39,0 +38,1 @@\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/BackslashInlineParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.org.commonmark.internal.util.Parsing;\n@@ -39,0 +38,3 @@\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n+import jdk.internal.org.commonmark.text.Characters;\n@@ -66,1 +68,1 @@\n-                        Parsing.hasNonSpace(content)) {\n+                        Characters.hasNonSpace(content)) {\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/BackticksInlineParser.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import jdk.internal.org.commonmark.internal.util.AsciiMatcher;\n+import jdk.internal.org.commonmark.text.AsciiMatcher;\n@@ -38,0 +38,2 @@\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/EntityInlineParser.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import jdk.internal.org.commonmark.internal.util.AsciiMatcher;\n+import jdk.internal.org.commonmark.text.AsciiMatcher;\n@@ -37,0 +37,2 @@\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n@@ -175,2 +177,3 @@\n-        \/\/ spec: An HTML comment consists of <!-- + text + -->, where text does not start with > or ->, does not end\n-        \/\/ with -, and does not contain --. (See the HTML5 spec.)\n+        \/\/ spec: An [HTML comment](@) consists of `<!-->`, `<!--->`, or  `<!--`, a string of\n+        \/\/ characters not including the string `-->`, and `-->` (see the\n+        \/\/ [HTML spec](https:\/\/html.spec.whatwg.org\/multipage\/parsing.html#markup-declaration-open-state)).\n@@ -185,1 +188,1 @@\n-            return false;\n+            return true;\n@@ -189,2 +192,2 @@\n-            if (scanner.next(\"--\")) {\n-                return scanner.next('>');\n+            if (scanner.next(\"-->\")) {\n+                return true;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/HtmlInlineParser.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n+\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/InlineParserState.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.org.commonmark.parser.beta.Position;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/ParsedInline.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.org.commonmark.parser.beta.Position;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/ParsedInlineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    private final char marker;\n+    private final String marker;\n@@ -42,1 +42,1 @@\n-        marker = list.getBulletMarker();\n+        marker = list.getMarker();\n@@ -45,1 +45,1 @@\n-    public char getMarker() {\n+    public String getMarker() {\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/renderer\/text\/BulletListHolder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    private final char delimiter;\n+    private final String delimiter;\n@@ -43,2 +43,2 @@\n-        delimiter = list.getDelimiter();\n-        counter = list.getStartNumber();\n+        delimiter = list.getMarkerDelimiter() != null ? list.getMarkerDelimiter() : \".\";\n+        counter = list.getMarkerStartNumber() != null ? list.getMarkerStartNumber() : 1;\n@@ -47,1 +47,1 @@\n-    public char getDelimiter() {\n+    public String getDelimiter() {\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/renderer\/text\/OrderedListHolder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    private static final String ENTITY_PATH = \"\/jdk\/internal\/org\/commonmark\/internal\/util\/entities.txt\";\n+    private static final String ENTITY_PATH = \"\/org\/commonmark\/internal\/util\/entities.txt\";\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/Html5Entities.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import jdk.internal.org.commonmark.internal.inline.Scanner;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n@@ -49,1 +49,1 @@\n-                    if (Parsing.isEscapable(scanner.peek())) {\n+                    if (isEscapable(scanner.peek())) {\n@@ -79,1 +79,1 @@\n-                        if (Parsing.isEscapable(scanner.peek())) {\n+                        if (isEscapable(scanner.peek())) {\n@@ -135,1 +135,1 @@\n-                if (Parsing.isEscapable(scanner.peek())) {\n+                if (isEscapable(scanner.peek())) {\n@@ -163,1 +163,1 @@\n-                    if (Parsing.isEscapable(scanner.peek())) {\n+                    if (isEscapable(scanner.peek())) {\n@@ -195,0 +195,39 @@\n+\n+    private static boolean isEscapable(char c) {\n+        switch (c) {\n+            case '!':\n+            case '\"':\n+            case '#':\n+            case '$':\n+            case '%':\n+            case '&':\n+            case '\\'':\n+            case '(':\n+            case ')':\n+            case '*':\n+            case '+':\n+            case ',':\n+            case '-':\n+            case '.':\n+            case '\/':\n+            case ':':\n+            case ';':\n+            case '<':\n+            case '=':\n+            case '>':\n+            case '?':\n+            case '@':\n+            case '[':\n+            case '\\\\':\n+            case ']':\n+            case '^':\n+            case '_':\n+            case '`':\n+            case '{':\n+            case '|':\n+            case '}':\n+            case '~':\n+                return true;\n+        }\n+        return false;\n+    }\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/LinkScanner.java","additions":44,"deletions":5,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -36,16 +36,0 @@\n-\n-    private static final String TAGNAME = \"[A-Za-z][A-Za-z0-9-]*\";\n-    private static final String ATTRIBUTENAME = \"[a-zA-Z_:][a-zA-Z0-9:._-]*\";\n-    private static final String UNQUOTEDVALUE = \"[^\\\"'=<>`\\\\x00-\\\\x20]+\";\n-    private static final String SINGLEQUOTEDVALUE = \"'[^']*'\";\n-    private static final String DOUBLEQUOTEDVALUE = \"\\\"[^\\\"]*\\\"\";\n-    private static final String ATTRIBUTEVALUE = \"(?:\" + UNQUOTEDVALUE + \"|\" + SINGLEQUOTEDVALUE\n-            + \"|\" + DOUBLEQUOTEDVALUE + \")\";\n-    private static final String ATTRIBUTEVALUESPEC = \"(?:\" + \"\\\\s*=\" + \"\\\\s*\" + ATTRIBUTEVALUE\n-            + \")\";\n-    private static final String ATTRIBUTE = \"(?:\" + \"\\\\s+\" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC\n-            + \"?)\";\n-\n-    public static final String OPENTAG = \"<\" + TAGNAME + ATTRIBUTE + \"*\" + \"\\\\s*\/?>\";\n-    public static final String CLOSETAG = \"<\/\" + TAGNAME + \"\\\\s*[>]\";\n-\n@@ -58,220 +42,0 @@\n-\n-    public static int find(char c, CharSequence s, int startIndex) {\n-        int length = s.length();\n-        for (int i = startIndex; i < length; i++) {\n-            if (s.charAt(i) == c) {\n-                return i;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    public static int findLineBreak(CharSequence s, int startIndex) {\n-        int length = s.length();\n-        for (int i = startIndex; i < length; i++) {\n-            switch (s.charAt(i)) {\n-                case '\\n':\n-                case '\\r':\n-                    return i;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    public static boolean isBlank(CharSequence s) {\n-        return findNonSpace(s, 0) == -1;\n-    }\n-\n-    public static boolean hasNonSpace(CharSequence s) {\n-        int length = s.length();\n-        int skipped = skip(' ', s, 0, length);\n-        return skipped != length;\n-    }\n-\n-    public static boolean isLetter(CharSequence s, int index) {\n-        int codePoint = Character.codePointAt(s, index);\n-        return Character.isLetter(codePoint);\n-    }\n-\n-    public static boolean isSpaceOrTab(CharSequence s, int index) {\n-        if (index < s.length()) {\n-            switch (s.charAt(index)) {\n-                case ' ':\n-                case '\\t':\n-                    return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    public static boolean isEscapable(char c) {\n-        switch (c) {\n-            case '!':\n-            case '\"':\n-            case '#':\n-            case '$':\n-            case '%':\n-            case '&':\n-            case '\\'':\n-            case '(':\n-            case ')':\n-            case '*':\n-            case '+':\n-            case ',':\n-            case '-':\n-            case '.':\n-            case '\/':\n-            case ':':\n-            case ';':\n-            case '<':\n-            case '=':\n-            case '>':\n-            case '?':\n-            case '@':\n-            case '[':\n-            case '\\\\':\n-            case ']':\n-            case '^':\n-            case '_':\n-            case '`':\n-            case '{':\n-            case '|':\n-            case '}':\n-            case '~':\n-                return true;\n-        }\n-        return false;\n-    }\n-\n-    \/\/ See https:\/\/spec.commonmark.org\/0.29\/#punctuation-character\n-    public static boolean isPunctuationCodePoint(int codePoint) {\n-        switch (Character.getType(codePoint)) {\n-            case Character.CONNECTOR_PUNCTUATION:\n-            case Character.DASH_PUNCTUATION:\n-            case Character.END_PUNCTUATION:\n-            case Character.FINAL_QUOTE_PUNCTUATION:\n-            case Character.INITIAL_QUOTE_PUNCTUATION:\n-            case Character.OTHER_PUNCTUATION:\n-            case Character.START_PUNCTUATION:\n-                return true;\n-            default:\n-                switch (codePoint) {\n-                    case '$':\n-                    case '+':\n-                    case '<':\n-                    case '=':\n-                    case '>':\n-                    case '^':\n-                    case '`':\n-                    case '|':\n-                    case '~':\n-                        return true;\n-                    default:\n-                        return false;\n-                }\n-        }\n-    }\n-\n-    public static boolean isWhitespaceCodePoint(int codePoint) {\n-        switch (codePoint) {\n-            case ' ':\n-            case '\\t':\n-            case '\\r':\n-            case '\\n':\n-            case '\\f':\n-                return true;\n-            default:\n-                return Character.getType(codePoint) == Character.SPACE_SEPARATOR;\n-        }\n-    }\n-\n-    \/**\n-     * Prepares the input line replacing {@code \\0}\n-     *\/\n-    public static CharSequence prepareLine(CharSequence line) {\n-        \/\/ Avoid building a new string in the majority of cases (no \\0)\n-        StringBuilder sb = null;\n-        int length = line.length();\n-        for (int i = 0; i < length; i++) {\n-            char c = line.charAt(i);\n-            if (c == '\\0') {\n-                if (sb == null) {\n-                    sb = new StringBuilder(length);\n-                    sb.append(line, 0, i);\n-                }\n-                sb.append('\\uFFFD');\n-            } else {\n-                if (sb != null) {\n-                    sb.append(c);\n-                }\n-            }\n-        }\n-\n-        if (sb != null) {\n-            return sb.toString();\n-        } else {\n-            return line;\n-        }\n-    }\n-\n-    public static int skip(char skip, CharSequence s, int startIndex, int endIndex) {\n-        for (int i = startIndex; i < endIndex; i++) {\n-            if (s.charAt(i) != skip) {\n-                return i;\n-            }\n-        }\n-        return endIndex;\n-    }\n-\n-    public static int skipBackwards(char skip, CharSequence s, int startIndex, int lastIndex) {\n-        for (int i = startIndex; i >= lastIndex; i--) {\n-            if (s.charAt(i) != skip) {\n-                return i;\n-            }\n-        }\n-        return lastIndex - 1;\n-    }\n-\n-    public static int skipSpaceTab(CharSequence s, int startIndex, int endIndex) {\n-        for (int i = startIndex; i < endIndex; i++) {\n-            switch (s.charAt(i)) {\n-                case ' ':\n-                case '\\t':\n-                    break;\n-                default:\n-                    return i;\n-            }\n-        }\n-        return endIndex;\n-    }\n-\n-    public static int skipSpaceTabBackwards(CharSequence s, int startIndex, int lastIndex) {\n-        for (int i = startIndex; i >= lastIndex; i--) {\n-            switch (s.charAt(i)) {\n-                case ' ':\n-                case '\\t':\n-                    break;\n-                default:\n-                    return i;\n-            }\n-        }\n-        return lastIndex - 1;\n-    }\n-\n-    private static int findNonSpace(CharSequence s, int startIndex) {\n-        int length = s.length();\n-        for (int i = startIndex; i < length; i++) {\n-            switch (s.charAt(i)) {\n-                case ' ':\n-                case '\\t':\n-                case '\\n':\n-                case '\\u000B':\n-                case '\\f':\n-                case '\\r':\n-                    break;\n-                default:\n-                    return i;\n-            }\n-        }\n-        return -1;\n-    }\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/Parsing.java","additions":0,"deletions":236,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    private char bulletMarker;\n+    private String marker;\n@@ -44,0 +44,15 @@\n+    \/**\n+     * @return the bullet list marker that was used, e.g. {@code -}, {@code *} or {@code +}, if available, or null otherwise\n+     *\/\n+    public String getMarker() {\n+        return marker;\n+    }\n+\n+    public void setMarker(String marker) {\n+        this.marker = marker;\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #getMarker()} instead\n+     *\/\n+    @Deprecated\n@@ -45,1 +60,1 @@\n-        return bulletMarker;\n+        return marker != null && !marker.isEmpty() ? marker.charAt(0) : '\\0';\n@@ -48,0 +63,4 @@\n+    \/**\n+     * @deprecated use {@link #getMarker()} instead\n+     *\/\n+    @Deprecated\n@@ -49,1 +68,1 @@\n-        this.bulletMarker = bulletMarker;\n+        this.marker = bulletMarker != '\\0' ? String.valueOf(bulletMarker) : null;\n@@ -51,1 +70,0 @@\n-\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/BulletList.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,2 +37,3 @@\n-    private char fenceChar;\n-    private int fenceLength;\n+    private String fenceCharacter;\n+    private Integer openingFenceLength;\n+    private Integer closingFenceLength;\n@@ -49,2 +50,5 @@\n-    public char getFenceChar() {\n-        return fenceChar;\n+    \/**\n+     * @return the fence character that was used, e.g. {@code `} or {@code ~}, if available, or null otherwise\n+     *\/\n+    public String getFenceCharacter() {\n+        return fenceCharacter;\n@@ -53,2 +57,2 @@\n-    public void setFenceChar(char fenceChar) {\n-        this.fenceChar = fenceChar;\n+    public void setFenceCharacter(String fenceCharacter) {\n+        this.fenceCharacter = fenceCharacter;\n@@ -57,2 +61,6 @@\n-    public int getFenceLength() {\n-        return fenceLength;\n+    \/**\n+     * @return the length of the opening fence (how many of {{@link #getFenceCharacter()}} were used to start the code\n+     * block) if available, or null otherwise\n+     *\/\n+    public Integer getOpeningFenceLength() {\n+        return openingFenceLength;\n@@ -61,2 +69,22 @@\n-    public void setFenceLength(int fenceLength) {\n-        this.fenceLength = fenceLength;\n+    public void setOpeningFenceLength(Integer openingFenceLength) {\n+        if (openingFenceLength != null && openingFenceLength < 3) {\n+            throw new IllegalArgumentException(\"openingFenceLength needs to be >= 3\");\n+        }\n+        checkFenceLengths(openingFenceLength, closingFenceLength);\n+        this.openingFenceLength = openingFenceLength;\n+    }\n+\n+    \/**\n+     * @return the length of the closing fence (how many of {@link #getFenceCharacter()} were used to end the code\n+     * block) if available, or null otherwise\n+     *\/\n+    public Integer getClosingFenceLength() {\n+        return closingFenceLength;\n+    }\n+\n+    public void setClosingFenceLength(Integer closingFenceLength) {\n+        if (closingFenceLength != null && closingFenceLength < 3) {\n+            throw new IllegalArgumentException(\"closingFenceLength needs to be >= 3\");\n+        }\n+        checkFenceLengths(openingFenceLength, closingFenceLength);\n+        this.closingFenceLength = closingFenceLength;\n@@ -91,0 +119,40 @@\n+\n+    \/**\n+     * @deprecated use {@link #getFenceCharacter()} instead\n+     *\/\n+    @Deprecated\n+    public char getFenceChar() {\n+        return fenceCharacter != null && !fenceCharacter.isEmpty() ? fenceCharacter.charAt(0) : '\\0';\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #setFenceCharacter} instead\n+     *\/\n+    @Deprecated\n+    public void setFenceChar(char fenceChar) {\n+        this.fenceCharacter = fenceChar != '\\0' ? String.valueOf(fenceChar) : null;\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #getOpeningFenceLength} instead\n+     *\/\n+    @Deprecated\n+    public int getFenceLength() {\n+        return openingFenceLength != null ? openingFenceLength : 0;\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #setOpeningFenceLength} instead\n+     *\/\n+    @Deprecated\n+    public void setFenceLength(int fenceLength) {\n+        this.openingFenceLength = fenceLength != 0 ? fenceLength : null;\n+    }\n+\n+    private static void checkFenceLengths(Integer openingFenceLength, Integer closingFenceLength) {\n+        if (openingFenceLength != null && closingFenceLength != null) {\n+            if (closingFenceLength < openingFenceLength) {\n+                throw new IllegalArgumentException(\"fence lengths required to be: closingFenceLength >= openingFenceLength\");\n+            }\n+        }\n+    }\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/FencedCodeBlock.java","additions":78,"deletions":10,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+    private Integer markerIndent;\n+    private Integer contentIndent;\n+\n@@ -41,0 +44,43 @@\n+\n+    \/**\n+     * Returns the indent of the marker such as \"-\" or \"1.\" in columns (spaces or tab stop of 4) if available, or null\n+     * otherwise.\n+     * <p>\n+     * Some examples and their marker indent:\n+     * <pre>- Foo<\/pre>\n+     * Marker indent: 0\n+     * <pre> - Foo<\/pre>\n+     * Marker indent: 1\n+     * <pre>  1. Foo<\/pre>\n+     * Marker indent: 2\n+     *\/\n+    public Integer getMarkerIndent() {\n+        return markerIndent;\n+    }\n+\n+    public void setMarkerIndent(Integer markerIndent) {\n+        this.markerIndent = markerIndent;\n+    }\n+\n+    \/**\n+     * Returns the indent of the content in columns (spaces or tab stop of 4) if available, or null otherwise.\n+     * The content indent is counted from the beginning of the line and includes the marker on the first line.\n+     * <p>\n+     * Some examples and their content indent:\n+     * <pre>- Foo<\/pre>\n+     * Content indent: 2\n+     * <pre> - Foo<\/pre>\n+     * Content indent: 3\n+     * <pre>  1. Foo<\/pre>\n+     * Content indent: 5\n+     * <p>\n+     * Note that subsequent lines in the same list item need to be indented by at least the content indent to be counted\n+     * as part of the list item.\n+     *\/\n+    public Integer getContentIndent() {\n+        return contentIndent;\n+    }\n+\n+    public void setContentIndent(Integer contentIndent) {\n+        this.contentIndent = contentIndent;\n+    }\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/ListItem.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    private int startNumber;\n-    private char delimiter;\n+    private String markerDelimiter;\n+    private Integer markerStartNumber;\n@@ -45,0 +45,26 @@\n+    \/**\n+     * @return the start number used in the marker, e.g. {@code 1}, if available, or null otherwise\n+     *\/\n+    public Integer getMarkerStartNumber() {\n+        return markerStartNumber;\n+    }\n+\n+    public void setMarkerStartNumber(Integer markerStartNumber) {\n+        this.markerStartNumber = markerStartNumber;\n+    }\n+\n+    \/**\n+     * @return the delimiter used in the marker, e.g. {@code .} or {@code )}, if available, or null otherwise\n+     *\/\n+    public String getMarkerDelimiter() {\n+        return markerDelimiter;\n+    }\n+\n+    public void setMarkerDelimiter(String markerDelimiter) {\n+        this.markerDelimiter = markerDelimiter;\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #getMarkerStartNumber()} instead\n+     *\/\n+    @Deprecated\n@@ -46,1 +72,1 @@\n-        return startNumber;\n+        return markerStartNumber != null ? markerStartNumber : 0;\n@@ -49,0 +75,4 @@\n+    \/**\n+     * @deprecated use {@link #setMarkerStartNumber} instead\n+     *\/\n+    @Deprecated\n@@ -50,1 +80,1 @@\n-        this.startNumber = startNumber;\n+        this.markerStartNumber = startNumber != 0 ? startNumber : null;\n@@ -53,0 +83,4 @@\n+    \/**\n+     * @deprecated use {@link #getMarkerDelimiter()} instead\n+     *\/\n+    @Deprecated\n@@ -54,1 +88,1 @@\n-        return delimiter;\n+        return markerDelimiter != null && !markerDelimiter.isEmpty() ? markerDelimiter.charAt(0) : '\\0';\n@@ -57,0 +91,4 @@\n+    \/**\n+     * @deprecated use {@link #setMarkerDelimiter} instead\n+     *\/\n+    @Deprecated\n@@ -58,1 +96,1 @@\n-        this.delimiter = delimiter;\n+        this.markerDelimiter = delimiter != '\\0' ? String.valueOf(delimiter) : null;\n@@ -60,1 +98,0 @@\n-\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/OrderedList.java","additions":44,"deletions":7,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+    private String literal;\n+\n@@ -41,0 +43,11 @@\n+\n+    \/**\n+     * @return the source literal that represents this node, if available\n+     *\/\n+    public String getLiteral() {\n+        return literal;\n+    }\n+\n+    public void setLiteral(String literal) {\n+        this.literal = literal;\n+    }\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/ThematicBreak.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+ * <li>{@link org.commonmark.renderer.markdown} for Markdown rendering<\/li>\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/package-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-package jdk.internal.org.commonmark.internal.inline;\n+package jdk.internal.org.commonmark.parser.beta;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/beta\/Position.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/Position.java","status":"copied"},{"patch":"@@ -33,1 +33,1 @@\n-package jdk.internal.org.commonmark.internal.inline;\n+package jdk.internal.org.commonmark.parser.beta;\n@@ -35,1 +35,0 @@\n-import jdk.internal.org.commonmark.internal.util.CharMatcher;\n@@ -39,0 +38,1 @@\n+import jdk.internal.org.commonmark.text.CharMatcher;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/beta\/Scanner.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/Scanner.java","status":"copied"},{"patch":"@@ -34,1 +34,1 @@\n- * Parsing input text to AST nodes (see {@link org.commonmark.parser.Parser})\n+ * Experimental APIs to use for extensions. APIs are subject to change if necessary.\n@@ -36,1 +36,1 @@\n-package jdk.internal.org.commonmark.parser;\n+package jdk.internal.org.commonmark.parser.beta;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/beta\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/package-info.java","status":"copied"},{"patch":"@@ -69,0 +69,4 @@\n+    \/**\n+     * Add the part of a line that belongs to this block parser to parse (i.e. without any container block markers).\n+     * Note that the line will only include a {@link SourceLine#getSourceSpan()} if source spans are enabled for inlines.\n+     *\/\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/BlockParser.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-        int start = orderedList.getStartNumber();\n+        int start = orderedList.getMarkerStartNumber() != null ? orderedList.getMarkerStartNumber() : 1;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/CoreHtmlNodeRenderer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,582 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.markdown;\n+\n+import jdk.internal.org.commonmark.text.AsciiMatcher;\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.text.CharMatcher;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.text.Characters;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * The node renderer that renders all the core nodes (comes last in the order of node renderers).\n+ * <p>\n+ * Note that while sometimes it would be easier to record what kind of syntax was used on parsing (e.g. ATX vs Setext\n+ * heading), this renderer is intended to also work for documents that were created by directly creating\n+ * {@link Node Nodes} instead. So in order to support that, it sometimes needs to do a bit more work.\n+ *\/\n+public class CoreMarkdownNodeRenderer extends AbstractVisitor implements NodeRenderer {\n+\n+    private final AsciiMatcher textEscape;\n+    private final CharMatcher textEscapeInHeading;\n+    private final CharMatcher linkDestinationNeedsAngleBrackets =\n+            AsciiMatcher.builder().c(' ').c('(').c(')').c('<').c('>').c('\\n').c('\\\\').build();\n+    private final CharMatcher linkDestinationEscapeInAngleBrackets =\n+            AsciiMatcher.builder().c('<').c('>').c('\\n').c('\\\\').build();\n+    private final CharMatcher linkTitleEscapeInQuotes =\n+            AsciiMatcher.builder().c('\"').c('\\n').c('\\\\').build();\n+\n+    private final Pattern orderedListMarkerPattern = Pattern.compile(\"^([0-9]{1,9})([.)])\");\n+\n+    protected final MarkdownNodeRendererContext context;\n+    private final MarkdownWriter writer;\n+    \/**\n+     * If we're currently within a {@link BulletList} or {@link OrderedList}, this keeps the context of that list.\n+     * It has a parent field so that it can represent a stack (for nested lists).\n+     *\/\n+    private ListHolder listHolder;\n+\n+    public CoreMarkdownNodeRenderer(MarkdownNodeRendererContext context) {\n+        this.context = context;\n+        this.writer = context.getWriter();\n+\n+        textEscape = AsciiMatcher.builder().anyOf(\"[]<>`*_&\\n\\\\\").anyOf(context.getSpecialCharacters()).build();\n+        textEscapeInHeading = AsciiMatcher.builder(textEscape).anyOf(\"#\").build();\n+    }\n+\n+    @Override\n+    public Set<Class<? extends Node>> getNodeTypes() {\n+        return new HashSet<>(Arrays.asList(\n+                BlockQuote.class,\n+                BulletList.class,\n+                Code.class,\n+                Document.class,\n+                Emphasis.class,\n+                FencedCodeBlock.class,\n+                HardLineBreak.class,\n+                Heading.class,\n+                HtmlBlock.class,\n+                HtmlInline.class,\n+                Image.class,\n+                IndentedCodeBlock.class,\n+                Link.class,\n+                ListItem.class,\n+                OrderedList.class,\n+                Paragraph.class,\n+                SoftLineBreak.class,\n+                StrongEmphasis.class,\n+                Text.class,\n+                ThematicBreak.class\n+        ));\n+    }\n+\n+    @Override\n+    public void render(Node node) {\n+        node.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(Document document) {\n+        \/\/ No rendering itself\n+        visitChildren(document);\n+        writer.line();\n+    }\n+\n+    @Override\n+    public void visit(ThematicBreak thematicBreak) {\n+        \/\/ Let's use ___ as it doesn't introduce ambiguity with * or - list item markers\n+        writer.raw(\"___\");\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(Heading heading) {\n+        if (heading.getLevel() <= 2) {\n+            LineBreakVisitor lineBreakVisitor = new LineBreakVisitor();\n+            heading.accept(lineBreakVisitor);\n+            boolean isMultipleLines = lineBreakVisitor.hasLineBreak();\n+\n+            if (isMultipleLines) {\n+                \/\/ Setext headings: Can have multiple lines, but only level 1 or 2\n+                visitChildren(heading);\n+                writer.line();\n+                if (heading.getLevel() == 1) {\n+                    \/\/ Note that it would be nice to match the length of the contents instead of just using 3, but that's\n+                    \/\/ not easy.\n+                    writer.raw(\"===\");\n+                } else {\n+                    writer.raw(\"---\");\n+                }\n+                writer.block();\n+                return;\n+            }\n+        }\n+\n+        \/\/ ATX headings: Can't have multiple lines, but up to level 6.\n+        for (int i = 0; i < heading.getLevel(); i++) {\n+            writer.raw('#');\n+        }\n+        writer.raw(' ');\n+        visitChildren(heading);\n+\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(IndentedCodeBlock indentedCodeBlock) {\n+        String literal = indentedCodeBlock.getLiteral();\n+        \/\/ We need to respect line prefixes which is why we need to write it line by line (e.g. an indented code block\n+        \/\/ within a block quote)\n+        writer.writePrefix(\"    \");\n+        writer.pushPrefix(\"    \");\n+        List<String> lines = getLines(literal);\n+        for (int i = 0; i < lines.size(); i++) {\n+            String line = lines.get(i);\n+            writer.raw(line);\n+            if (i != lines.size() - 1) {\n+                writer.line();\n+            }\n+        }\n+        writer.popPrefix();\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(FencedCodeBlock codeBlock) {\n+        String literal = codeBlock.getLiteral();\n+        String fenceChar = codeBlock.getFenceCharacter() != null ? codeBlock.getFenceCharacter() : \"`\";\n+        int openingFenceLength;\n+        if (codeBlock.getOpeningFenceLength() != null) {\n+            \/\/ If we have a known fence length, use it\n+            openingFenceLength = codeBlock.getOpeningFenceLength();\n+        } else {\n+            \/\/ Otherwise, calculate the closing fence length pessimistically, e.g. if the code block itself contains a\n+            \/\/ line with ```, we need to use a fence of length 4. If ``` occurs with non-whitespace characters on a\n+            \/\/ line, we technically don't need a longer fence, but it's not incorrect to do so.\n+            int fenceCharsInLiteral = findMaxRunLength(fenceChar, literal);\n+            openingFenceLength = Math.max(fenceCharsInLiteral + 1, 3);\n+        }\n+        int closingFenceLength = codeBlock.getClosingFenceLength() != null ? codeBlock.getClosingFenceLength() : openingFenceLength;\n+\n+        String openingFence = repeat(fenceChar, openingFenceLength);\n+        String closingFence = repeat(fenceChar, closingFenceLength);\n+        int indent = codeBlock.getFenceIndent();\n+\n+        if (indent > 0) {\n+            String indentPrefix = repeat(\" \", indent);\n+            writer.writePrefix(indentPrefix);\n+            writer.pushPrefix(indentPrefix);\n+        }\n+\n+        writer.raw(openingFence);\n+        if (codeBlock.getInfo() != null) {\n+            writer.raw(codeBlock.getInfo());\n+        }\n+        writer.line();\n+        if (!literal.isEmpty()) {\n+            List<String> lines = getLines(literal);\n+            for (String line : lines) {\n+                writer.raw(line);\n+                writer.line();\n+            }\n+        }\n+        writer.raw(closingFence);\n+        if (indent > 0) {\n+            writer.popPrefix();\n+        }\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(HtmlBlock htmlBlock) {\n+        List<String> lines = getLines(htmlBlock.getLiteral());\n+        for (int i = 0; i < lines.size(); i++) {\n+            String line = lines.get(i);\n+            writer.raw(line);\n+            if (i != lines.size() - 1) {\n+                writer.line();\n+            }\n+        }\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(Paragraph paragraph) {\n+        visitChildren(paragraph);\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(BlockQuote blockQuote) {\n+        writer.writePrefix(\"> \");\n+        writer.pushPrefix(\"> \");\n+        visitChildren(blockQuote);\n+        writer.popPrefix();\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(BulletList bulletList) {\n+        writer.pushTight(bulletList.isTight());\n+        listHolder = new BulletListHolder(listHolder, bulletList);\n+        visitChildren(bulletList);\n+        listHolder = listHolder.parent;\n+        writer.popTight();\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(OrderedList orderedList) {\n+        writer.pushTight(orderedList.isTight());\n+        listHolder = new OrderedListHolder(listHolder, orderedList);\n+        visitChildren(orderedList);\n+        listHolder = listHolder.parent;\n+        writer.popTight();\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(ListItem listItem) {\n+        int markerIndent = listItem.getMarkerIndent() != null ? listItem.getMarkerIndent() : 0;\n+        String marker;\n+        if (listHolder instanceof BulletListHolder) {\n+            BulletListHolder bulletListHolder = (BulletListHolder) listHolder;\n+            marker = repeat(\" \", markerIndent) + bulletListHolder.marker;\n+        } else if (listHolder instanceof OrderedListHolder) {\n+            OrderedListHolder orderedListHolder = (OrderedListHolder) listHolder;\n+            marker = repeat(\" \", markerIndent) + orderedListHolder.number + orderedListHolder.delimiter;\n+            orderedListHolder.number++;\n+        } else {\n+            throw new IllegalStateException(\"Unknown list holder type: \" + listHolder);\n+        }\n+        Integer contentIndent = listItem.getContentIndent();\n+        String spaces = contentIndent != null ? repeat(\" \", contentIndent - marker.length()) : \" \";\n+        writer.writePrefix(marker);\n+        writer.writePrefix(spaces);\n+        writer.pushPrefix(repeat(\" \", marker.length() + spaces.length()));\n+\n+        if (listItem.getFirstChild() == null) {\n+            \/\/ Empty list item\n+            writer.block();\n+        } else {\n+            visitChildren(listItem);\n+        }\n+\n+        writer.popPrefix();\n+    }\n+\n+    @Override\n+    public void visit(Code code) {\n+        String literal = code.getLiteral();\n+        \/\/ If the literal includes backticks, we can surround them by using one more backtick.\n+        int backticks = findMaxRunLength(\"`\", literal);\n+        for (int i = 0; i < backticks + 1; i++) {\n+            writer.raw('`');\n+        }\n+        \/\/ If the literal starts or ends with a backtick, surround it with a single space.\n+        \/\/ If it starts and ends with a space (but is not only spaces), add an additional space (otherwise they would\n+        \/\/ get removed on parsing).\n+        boolean addSpace = literal.startsWith(\"`\") || literal.endsWith(\"`\") ||\n+                (literal.startsWith(\" \") && literal.endsWith(\" \") && Characters.hasNonSpace(literal));\n+        if (addSpace) {\n+            writer.raw(' ');\n+        }\n+        writer.raw(literal);\n+        if (addSpace) {\n+            writer.raw(' ');\n+        }\n+        for (int i = 0; i < backticks + 1; i++) {\n+            writer.raw('`');\n+        }\n+    }\n+\n+    @Override\n+    public void visit(Emphasis emphasis) {\n+        String delimiter = emphasis.getOpeningDelimiter();\n+        \/\/ Use delimiter that was parsed if available\n+        if (delimiter == null) {\n+            \/\/ When emphasis is nested, a different delimiter needs to be used\n+            delimiter = writer.getLastChar() == '*' ? \"_\" : \"*\";\n+        }\n+        writer.raw(delimiter);\n+        super.visit(emphasis);\n+        writer.raw(delimiter);\n+    }\n+\n+    @Override\n+    public void visit(StrongEmphasis strongEmphasis) {\n+        writer.raw(\"**\");\n+        super.visit(strongEmphasis);\n+        writer.raw(\"**\");\n+    }\n+\n+    @Override\n+    public void visit(Link link) {\n+        writeLinkLike(link.getTitle(), link.getDestination(), link, \"[\");\n+    }\n+\n+    @Override\n+    public void visit(Image image) {\n+        writeLinkLike(image.getTitle(), image.getDestination(), image, \"![\");\n+    }\n+\n+    @Override\n+    public void visit(HtmlInline htmlInline) {\n+        writer.raw(htmlInline.getLiteral());\n+    }\n+\n+    @Override\n+    public void visit(HardLineBreak hardLineBreak) {\n+        writer.raw(\"  \");\n+        writer.line();\n+    }\n+\n+    @Override\n+    public void visit(SoftLineBreak softLineBreak) {\n+        writer.line();\n+    }\n+\n+    @Override\n+    public void visit(Text text) {\n+        \/\/ Text is tricky. In Markdown special characters (`-`, `#` etc.) can be escaped (`\\-`, `\\#` etc.) so that\n+        \/\/ they're parsed as plain text. Currently, whether a character was escaped or not is not recorded in the Node,\n+        \/\/ so here we don't know. If we just wrote out those characters unescaped, the resulting Markdown would change\n+        \/\/ meaning (turn into a list item, heading, etc.).\n+        \/\/ You might say \"Why not store that in the Node when parsing\", but that wouldn't work for the use case where\n+        \/\/ nodes are constructed directly instead of via parsing. This renderer needs to work for that too.\n+        \/\/ So currently, when in doubt, we escape. For special characters only occurring at the beginning of a line,\n+        \/\/ we only escape them then (we wouldn't want to escape every `.` for example).\n+        String literal = text.getLiteral();\n+        if (writer.isAtLineStart() && !literal.isEmpty()) {\n+            char c = literal.charAt(0);\n+            switch (c) {\n+                case '-': {\n+                    \/\/ Would be ambiguous with a bullet list marker, escape\n+                    writer.raw(\"\\\\-\");\n+                    literal = literal.substring(1);\n+                    break;\n+                }\n+                case '#': {\n+                    \/\/ Would be ambiguous with an ATX heading, escape\n+                    writer.raw(\"\\\\#\");\n+                    literal = literal.substring(1);\n+                    break;\n+                }\n+                case '=': {\n+                    \/\/ Would be ambiguous with a Setext heading, escape\n+                    writer.raw(\"\\\\=\");\n+                    literal = literal.substring(1);\n+                    break;\n+                }\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9': {\n+                    \/\/ Check for ordered list marker\n+                    Matcher m = orderedListMarkerPattern.matcher(literal);\n+                    if (m.find()) {\n+                        writer.raw(m.group(1));\n+                        writer.raw(\"\\\\\" + m.group(2));\n+                        literal = literal.substring(m.end());\n+                    }\n+                    break;\n+                }\n+                case '\\t': {\n+                    writer.raw(\"&#9;\");\n+                    literal = literal.substring(1);\n+                    break;\n+                }\n+                case ' ': {\n+                    writer.raw(\"&#32;\");\n+                    literal = literal.substring(1);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        CharMatcher escape = text.getParent() instanceof Heading ? textEscapeInHeading : textEscape;\n+\n+        if (literal.endsWith(\"!\") && text.getNext() instanceof Link) {\n+            \/\/ If we wrote the `!` unescaped, it would turn the link into an image instead.\n+            writer.text(literal.substring(0, literal.length() - 1), escape);\n+            writer.raw(\"\\\\!\");\n+        } else {\n+            writer.text(literal, escape);\n+        }\n+    }\n+\n+    @Override\n+    protected void visitChildren(Node parent) {\n+        Node node = parent.getFirstChild();\n+        while (node != null) {\n+            Node next = node.getNext();\n+            context.render(node);\n+            node = next;\n+        }\n+    }\n+\n+    private static int findMaxRunLength(String needle, String s) {\n+        int maxRunLength = 0;\n+        int pos = 0;\n+        while (pos < s.length()) {\n+            pos = s.indexOf(needle, pos);\n+            if (pos == -1) {\n+                return maxRunLength;\n+            }\n+            int runLength = 0;\n+            do {\n+                pos += needle.length();\n+                runLength++;\n+            } while (s.startsWith(needle, pos));\n+            maxRunLength = Math.max(runLength, maxRunLength);\n+        }\n+        return maxRunLength;\n+    }\n+\n+    private static boolean contains(String s, CharMatcher charMatcher) {\n+        for (int i = 0; i < s.length(); i++) {\n+            if (charMatcher.matches(s.charAt(i))) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/\/ Keep for Android compat (String.repeat only available on Android 12 and later)\n+    private static String repeat(String s, int count) {\n+        StringBuilder sb = new StringBuilder(s.length() * count);\n+        for (int i = 0; i < count; i++) {\n+            sb.append(s);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static List<String> getLines(String literal) {\n+        \/\/ Without -1, split would discard all trailing empty strings, which is not what we want, e.g. it would\n+        \/\/ return the same result for \"abc\", \"abc\\n\" and \"abc\\n\\n\".\n+        \/\/ With -1, it returns [\"abc\"], [\"abc\", \"\"] and [\"abc\", \"\", \"\"].\n+        String[] parts = literal.split(\"\\n\", -1);\n+        if (parts[parts.length - 1].isEmpty()) {\n+            \/\/ But we don't want the last empty string, as \"\\n\" is used as a line terminator (not a separator),\n+            \/\/ so return without the last element.\n+            return Arrays.asList(parts).subList(0, parts.length - 1);\n+        } else {\n+            return Arrays.asList(parts);\n+        }\n+    }\n+\n+    private void writeLinkLike(String title, String destination, Node node, String opener) {\n+        writer.raw(opener);\n+        visitChildren(node);\n+        writer.raw(']');\n+        writer.raw('(');\n+        if (contains(destination, linkDestinationNeedsAngleBrackets)) {\n+            writer.raw('<');\n+            writer.text(destination, linkDestinationEscapeInAngleBrackets);\n+            writer.raw('>');\n+        } else {\n+            writer.raw(destination);\n+        }\n+        if (title != null) {\n+            writer.raw(' ');\n+            writer.raw('\"');\n+            writer.text(title, linkTitleEscapeInQuotes);\n+            writer.raw('\"');\n+        }\n+        writer.raw(')');\n+    }\n+\n+    private static class ListHolder {\n+        final ListHolder parent;\n+\n+        protected ListHolder(ListHolder parent) {\n+            this.parent = parent;\n+        }\n+    }\n+\n+    private static class BulletListHolder extends ListHolder {\n+        final String marker;\n+\n+        public BulletListHolder(ListHolder parent, BulletList bulletList) {\n+            super(parent);\n+            this.marker = bulletList.getMarker() != null ? bulletList.getMarker() : \"-\";\n+        }\n+    }\n+\n+    private static class OrderedListHolder extends ListHolder {\n+        final String delimiter;\n+        private int number;\n+\n+        protected OrderedListHolder(ListHolder parent, OrderedList orderedList) {\n+            super(parent);\n+            delimiter = orderedList.getMarkerDelimiter() != null ? orderedList.getMarkerDelimiter() : \".\";\n+            number = orderedList.getMarkerStartNumber() != null ? orderedList.getMarkerStartNumber() : 1;\n+        }\n+    }\n+\n+    \/**\n+     * Visits nodes to check if there are any soft or hard line breaks.\n+     *\/\n+    private static class LineBreakVisitor extends AbstractVisitor {\n+        private boolean lineBreak = false;\n+\n+        public boolean hasLineBreak() {\n+            return lineBreak;\n+        }\n+\n+        @Override\n+        public void visit(SoftLineBreak softLineBreak) {\n+            super.visit(softLineBreak);\n+            lineBreak = true;\n+        }\n+\n+        @Override\n+        public void visit(HardLineBreak hardLineBreak) {\n+            super.visit(hardLineBreak);\n+            lineBreak = true;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/markdown\/CoreMarkdownNodeRenderer.java","additions":582,"deletions":0,"binary":false,"changes":582,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.markdown;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+import java.util.Set;\n+\n+\/**\n+ * Context that is passed to custom node renderers, see {@link MarkdownNodeRendererFactory#create}.\n+ *\/\n+public interface MarkdownNodeRendererContext {\n+\n+    \/**\n+     * @return the writer to use\n+     *\/\n+    MarkdownWriter getWriter();\n+\n+    \/**\n+     * Render the specified node and its children using the configured renderers. This should be used to render child\n+     * nodes; be careful not to pass the node that is being rendered, that would result in an endless loop.\n+     *\n+     * @param node the node to render\n+     *\/\n+    void render(Node node);\n+\n+    \/**\n+     * @return additional special characters that need to be escaped if they occur in normal text; currently only ASCII\n+     * characters are allowed\n+     *\/\n+    Set<Character> getSpecialCharacters();\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/markdown\/MarkdownNodeRendererContext.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.markdown;\n+\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+\n+import java.util.Set;\n+\n+\/**\n+ * Factory for instantiating new node renderers for rendering custom nodes.\n+ *\/\n+public interface MarkdownNodeRendererFactory {\n+\n+    \/**\n+     * Create a new node renderer for the specified rendering context.\n+     *\n+     * @param context the context for rendering (normally passed on to the node renderer)\n+     * @return a node renderer\n+     *\/\n+    NodeRenderer create(MarkdownNodeRendererContext context);\n+\n+    \/**\n+     * @return the additional special characters that this factory would like to have escaped in normal text; currently\n+     * only ASCII characters are allowed\n+     *\/\n+    Set<Character> getSpecialCharacters();\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/markdown\/MarkdownNodeRendererFactory.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.markdown;\n+\n+import jdk.internal.org.commonmark.Extension;\n+import jdk.internal.org.commonmark.internal.renderer.NodeRendererMap;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.renderer.Renderer;\n+\n+import java.util.*;\n+\n+\/**\n+ * Renders nodes to Markdown (CommonMark syntax); use {@link #builder()} to create a renderer.\n+ * <p>\n+ * Note that it doesn't currently preserve the exact syntax of the original input Markdown (if any):\n+ * <ul>\n+ *     <li>Headings are output as ATX headings if possible (multi-line headings need Setext headings)<\/li>\n+ *     <li>Links are always rendered as inline links (no support for reference links yet)<\/li>\n+ *     <li>Escaping might be over-eager, e.g. a plain {@code *} might be escaped\n+ *     even though it doesn't need to be in that particular context<\/li>\n+ *     <li>Leading whitespace in paragraphs is not preserved<\/li>\n+ * <\/ul>\n+ * However, it should produce Markdown that is semantically equivalent to the input, i.e. if the Markdown was parsed\n+ * again and compared against the original AST, it should be the same (minus bugs).\n+ *\/\n+public class MarkdownRenderer implements Renderer {\n+\n+    private final List<MarkdownNodeRendererFactory> nodeRendererFactories;\n+\n+    private MarkdownRenderer(Builder builder) {\n+        this.nodeRendererFactories = new ArrayList<>(builder.nodeRendererFactories.size() + 1);\n+        this.nodeRendererFactories.addAll(builder.nodeRendererFactories);\n+        \/\/ Add as last. This means clients can override the rendering of core nodes if they want.\n+        this.nodeRendererFactories.add(new MarkdownNodeRendererFactory() {\n+            @Override\n+            public NodeRenderer create(MarkdownNodeRendererContext context) {\n+                return new CoreMarkdownNodeRenderer(context);\n+            }\n+\n+            @Override\n+            public Set<Character> getSpecialCharacters() {\n+                return Collections.emptySet();\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Create a new builder for configuring a {@link MarkdownRenderer}.\n+     *\n+     * @return a builder\n+     *\/\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public void render(Node node, Appendable output) {\n+        RendererContext context = new RendererContext(new MarkdownWriter(output));\n+        context.render(node);\n+    }\n+\n+    @Override\n+    public String render(Node node) {\n+        StringBuilder sb = new StringBuilder();\n+        render(node, sb);\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Builder for configuring a {@link MarkdownRenderer}. See methods for default configuration.\n+     *\/\n+    public static class Builder {\n+\n+        private final List<MarkdownNodeRendererFactory> nodeRendererFactories = new ArrayList<>();\n+\n+        \/**\n+         * @return the configured {@link MarkdownRenderer}\n+         *\/\n+        public MarkdownRenderer build() {\n+            return new MarkdownRenderer(this);\n+        }\n+\n+        \/**\n+         * Add a factory for instantiating a node renderer (done when rendering). This allows to override the rendering\n+         * of node types or define rendering for custom node types.\n+         * <p>\n+         * If multiple node renderers for the same node type are created, the one from the factory that was added first\n+         * \"wins\". (This is how the rendering for core node types can be overridden; the default rendering comes last.)\n+         *\n+         * @param nodeRendererFactory the factory for creating a node renderer\n+         * @return {@code this}\n+         *\/\n+        public Builder nodeRendererFactory(MarkdownNodeRendererFactory nodeRendererFactory) {\n+            this.nodeRendererFactories.add(nodeRendererFactory);\n+            return this;\n+        }\n+\n+        \/**\n+         * @param extensions extensions to use on this renderer\n+         * @return {@code this}\n+         *\/\n+        public Builder extensions(Iterable<? extends Extension> extensions) {\n+            for (Extension extension : extensions) {\n+                if (extension instanceof MarkdownRendererExtension) {\n+                    MarkdownRendererExtension markdownRendererExtension = (MarkdownRendererExtension) extension;\n+                    markdownRendererExtension.extend(this);\n+                }\n+            }\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * Extension for {@link MarkdownRenderer} for rendering custom nodes.\n+     *\/\n+    public interface MarkdownRendererExtension extends Extension {\n+\n+        \/**\n+         * Extend Markdown rendering, usually by registering custom node renderers using {@link Builder#nodeRendererFactory}.\n+         *\n+         * @param rendererBuilder the renderer builder to extend\n+         *\/\n+        void extend(Builder rendererBuilder);\n+    }\n+\n+    private class RendererContext implements MarkdownNodeRendererContext {\n+        private final MarkdownWriter writer;\n+        private final NodeRendererMap nodeRendererMap = new NodeRendererMap();\n+        private final Set<Character> additionalTextEscapes;\n+\n+        private RendererContext(MarkdownWriter writer) {\n+            \/\/ Set fields that are used by interface\n+            this.writer = writer;\n+            Set<Character> escapes = new HashSet<Character>();\n+            for (MarkdownNodeRendererFactory factory : nodeRendererFactories) {\n+                escapes.addAll(factory.getSpecialCharacters());\n+            }\n+            additionalTextEscapes = Collections.unmodifiableSet(escapes);\n+\n+            \/\/ The first node renderer for a node type \"wins\".\n+            for (int i = nodeRendererFactories.size() - 1; i >= 0; i--) {\n+                MarkdownNodeRendererFactory nodeRendererFactory = nodeRendererFactories.get(i);\n+                \/\/ Pass in this as context here, which uses the fields set above\n+                NodeRenderer nodeRenderer = nodeRendererFactory.create(this);\n+                nodeRendererMap.add(nodeRenderer);\n+            }\n+        }\n+\n+        @Override\n+        public MarkdownWriter getWriter() {\n+            return writer;\n+        }\n+\n+        @Override\n+        public void render(Node node) {\n+            nodeRendererMap.render(node);\n+        }\n+\n+        @Override\n+        public Set<Character> getSpecialCharacters() {\n+            return additionalTextEscapes;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/markdown\/MarkdownRenderer.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,278 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.markdown;\n+\n+import jdk.internal.org.commonmark.text.CharMatcher;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+\n+\/**\n+ * Writer for Markdown (CommonMark) text.\n+ *\/\n+public class MarkdownWriter {\n+\n+    private final Appendable buffer;\n+\n+    private int blockSeparator = 0;\n+    private char lastChar;\n+    private boolean atLineStart = true;\n+\n+    \/\/ Stacks of settings that affect various rendering behaviors. The common pattern here is that callers use \"push\" to\n+    \/\/ change a setting, render some nodes, and then \"pop\" the setting off the stack again to restore previous state.\n+    private final LinkedList<String> prefixes = new LinkedList<>();\n+    private final LinkedList<Boolean> tight = new LinkedList<>();\n+    private final LinkedList<CharMatcher> rawEscapes = new LinkedList<>();\n+\n+    public MarkdownWriter(Appendable out) {\n+        buffer = out;\n+    }\n+\n+    \/**\n+     * Write the supplied string (raw\/unescaped except if {@link #pushRawEscape} was used).\n+     *\/\n+    public void raw(String s) {\n+        flushBlockSeparator();\n+        write(s, null);\n+    }\n+\n+    \/**\n+     * Write the supplied character (raw\/unescaped except if {@link #pushRawEscape} was used).\n+     *\/\n+    public void raw(char c) {\n+        flushBlockSeparator();\n+        write(c);\n+    }\n+\n+    \/**\n+     * Write the supplied string with escaping.\n+     *\n+     * @param s      the string to write\n+     * @param escape which characters to escape\n+     *\/\n+    public void text(String s, CharMatcher escape) {\n+        if (s.isEmpty()) {\n+            return;\n+        }\n+        flushBlockSeparator();\n+        write(s, escape);\n+\n+        lastChar = s.charAt(s.length() - 1);\n+        atLineStart = false;\n+    }\n+\n+    \/**\n+     * Write a newline (line terminator).\n+     *\/\n+    public void line() {\n+        write('\\n');\n+        writePrefixes();\n+        atLineStart = true;\n+    }\n+\n+    \/**\n+     * Enqueue a block separator to be written before the next text is written. Block separators are not written\n+     * straight away because if there are no more blocks to write we don't want a separator (at the end of the document).\n+     *\/\n+    public void block() {\n+        \/\/ Remember whether this should be a tight or loose separator now because tight could get changed in between\n+        \/\/ this and the next flush.\n+        blockSeparator = isTight() ? 1 : 2;\n+        atLineStart = true;\n+    }\n+\n+    \/**\n+     * Push a prefix onto the top of the stack. All prefixes are written at the beginning of each line, until the\n+     * prefix is popped again.\n+     *\n+     * @param prefix the raw prefix string\n+     *\/\n+    public void pushPrefix(String prefix) {\n+        prefixes.addLast(prefix);\n+    }\n+\n+    \/**\n+     * Write a prefix.\n+     *\n+     * @param prefix the raw prefix string to write\n+     *\/\n+    public void writePrefix(String prefix) {\n+        boolean tmp = atLineStart;\n+        raw(prefix);\n+        atLineStart = tmp;\n+    }\n+\n+    \/**\n+     * Remove the last prefix from the top of the stack.\n+     *\/\n+    public void popPrefix() {\n+        prefixes.removeLast();\n+    }\n+\n+    \/**\n+     * Change whether blocks are tight or loose. Loose is the default where blocks are separated by a blank line. Tight\n+     * is where blocks are not separated by a blank line. Tight blocks are used in lists, if there are no blank lines\n+     * within the list.\n+     * <p>\n+     * Note that changing this does not affect block separators that have already been enqueued with {@link #block()},\n+     * only future ones.\n+     *\/\n+    public void pushTight(boolean tight) {\n+        this.tight.addLast(tight);\n+    }\n+\n+    \/**\n+     * Remove the last \"tight\" setting from the top of the stack.\n+     *\/\n+    public void popTight() {\n+        this.tight.removeLast();\n+    }\n+\n+    \/**\n+     * Escape the characters matching the supplied matcher, in all text (text and raw). This might be useful to\n+     * extensions that add another layer of syntax, e.g. the tables extension that uses `|` to separate cells and needs\n+     * all `|` characters to be escaped (even in code spans).\n+     *\n+     * @param rawEscape the characters to escape in raw text\n+     *\/\n+    public void pushRawEscape(CharMatcher rawEscape) {\n+        rawEscapes.add(rawEscape);\n+    }\n+\n+    \/**\n+     * Remove the last raw escape from the top of the stack.\n+     *\/\n+    public void popRawEscape() {\n+        rawEscapes.removeLast();\n+    }\n+\n+    \/**\n+     * @return the last character that was written\n+     *\/\n+    public char getLastChar() {\n+        return lastChar;\n+    }\n+\n+    \/**\n+     * @return whether we're at the line start (not counting any prefixes), i.e. after a {@link #line} or {@link #block}.\n+     *\/\n+    public boolean isAtLineStart() {\n+        return atLineStart;\n+    }\n+\n+    private void write(String s, CharMatcher escape) {\n+        try {\n+            if (rawEscapes.isEmpty() && escape == null) {\n+                \/\/ Normal fast path\n+                buffer.append(s);\n+            } else {\n+                for (int i = 0; i < s.length(); i++) {\n+                    append(s.charAt(i), escape);\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        int length = s.length();\n+        if (length != 0) {\n+            lastChar = s.charAt(length - 1);\n+        }\n+        atLineStart = false;\n+    }\n+\n+    private void write(char c) {\n+        try {\n+            append(c, null);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        lastChar = c;\n+        atLineStart = false;\n+    }\n+\n+    private void writePrefixes() {\n+        if (!prefixes.isEmpty()) {\n+            for (String prefix : prefixes) {\n+                write(prefix, null);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * If a block separator has been enqueued with {@link #block()} but not yet written, write it now.\n+     *\/\n+    private void flushBlockSeparator() {\n+        if (blockSeparator != 0) {\n+            write('\\n');\n+            writePrefixes();\n+            if (blockSeparator > 1) {\n+                write('\\n');\n+                writePrefixes();\n+            }\n+            blockSeparator = 0;\n+        }\n+    }\n+\n+    private void append(char c, CharMatcher escape) throws IOException {\n+        if (needsEscaping(c, escape)) {\n+            if (c == '\\n') {\n+                \/\/ Can't escape this with \\, use numeric character reference\n+                buffer.append(\"&#10;\");\n+            } else {\n+                buffer.append('\\\\');\n+                buffer.append(c);\n+            }\n+        } else {\n+            buffer.append(c);\n+        }\n+    }\n+\n+    private boolean isTight() {\n+        return !tight.isEmpty() && tight.getLast();\n+    }\n+\n+    private boolean needsEscaping(char c, CharMatcher escape) {\n+        return (escape != null && escape.matches(c)) || rawNeedsEscaping(c);\n+    }\n+\n+    private boolean rawNeedsEscaping(char c) {\n+        for (CharMatcher rawEscape : rawEscapes) {\n+            if (rawEscape.matches(c)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/markdown\/MarkdownWriter.java","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n- * Parsing input text to AST nodes (see {@link org.commonmark.parser.Parser})\n+ * Markdown rendering (see {@link org.commonmark.renderer.markdown.MarkdownRenderer})\n@@ -36,1 +36,1 @@\n-package jdk.internal.org.commonmark.parser;\n+package jdk.internal.org.commonmark.renderer.markdown;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/markdown\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/package-info.java","status":"copied"},{"patch":"@@ -44,0 +44,3 @@\n+\/**\n+ * Renders nodes to plain text content with minimal markup-like additions.\n+ *\/\n@@ -65,1 +68,1 @@\n-     * Create a new builder for configuring an {@link TextContentRenderer}.\n+     * Create a new builder for configuring a {@link TextContentRenderer}.\n@@ -87,1 +90,1 @@\n-     * Builder for configuring an {@link TextContentRenderer}. See methods for default configuration.\n+     * Builder for configuring a {@link TextContentRenderer}. See methods for default configuration.\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/text\/TextContentRenderer.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * Text content rendering (see {@link org.commonmark.renderer.text.TextContentRenderer})\n+ * Plain text rendering with minimal markup (see {@link org.commonmark.renderer.text.TextContentRenderer})\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/text\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.text;\n+\n+import java.util.BitSet;\n+import java.util.Set;\n+\n+\/**\n+ * Char matcher that can match ASCII characters efficiently.\n+ *\/\n+public class AsciiMatcher implements CharMatcher {\n+    private final BitSet set;\n+\n+    private AsciiMatcher(Builder builder) {\n+        this.set = builder.set;\n+    }\n+\n+    @Override\n+    public boolean matches(char c) {\n+        return set.get(c);\n+    }\n+\n+    public Builder newBuilder() {\n+        return new Builder((BitSet) set.clone());\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder(new BitSet());\n+    }\n+\n+    public static Builder builder(AsciiMatcher matcher) {\n+        return new Builder((BitSet) matcher.set.clone());\n+    }\n+\n+    public static class Builder {\n+        private final BitSet set;\n+\n+        private Builder(BitSet set) {\n+            this.set = set;\n+        }\n+\n+        public Builder c(char c) {\n+            if (c > 127) {\n+                throw new IllegalArgumentException(\"Can only match ASCII characters\");\n+            }\n+            set.set(c);\n+            return this;\n+        }\n+\n+        public Builder anyOf(String s) {\n+            for (int i = 0; i < s.length(); i++) {\n+                c(s.charAt(i));\n+            }\n+            return this;\n+        }\n+\n+        public Builder anyOf(Set<Character> characters) {\n+            for (Character c : characters) {\n+                c(c);\n+            }\n+            return this;\n+        }\n+\n+        public Builder range(char from, char toInclusive) {\n+            for (char c = from; c <= toInclusive; c++) {\n+                c(c);\n+            }\n+            return this;\n+        }\n+\n+        public AsciiMatcher build() {\n+            return new AsciiMatcher(this);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/text\/AsciiMatcher.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.text;\n+\n+\/**\n+ * Matcher interface for {@code char} values.\n+ * <p>\n+ * Note that because this matches on {@code char} values only (as opposed to {@code int} code points),\n+ * this only operates on the level of code units and doesn't support supplementary characters\n+ * (see {@link Character#isSupplementaryCodePoint(int)}).\n+ *\/\n+public interface CharMatcher {\n+\n+    boolean matches(char c);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/text\/CharMatcher.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.text;\n+\n+\/**\n+ * Functions for finding characters in strings or checking characters.\n+ *\/\n+public class Characters {\n+\n+    public static int find(char c, CharSequence s, int startIndex) {\n+        int length = s.length();\n+        for (int i = startIndex; i < length; i++) {\n+            if (s.charAt(i) == c) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public static int findLineBreak(CharSequence s, int startIndex) {\n+        int length = s.length();\n+        for (int i = startIndex; i < length; i++) {\n+            switch (s.charAt(i)) {\n+                case '\\n':\n+                case '\\r':\n+                    return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    \/**\n+     * @see <a href=\"https:\/\/spec.commonmark.org\/0.31.2\/#blank-line\">blank line<\/a>\n+     *\/\n+    public static boolean isBlank(CharSequence s) {\n+        return skipSpaceTab(s, 0, s.length()) == s.length();\n+    }\n+\n+    public static boolean hasNonSpace(CharSequence s) {\n+        int length = s.length();\n+        int skipped = skip(' ', s, 0, length);\n+        return skipped != length;\n+    }\n+\n+    public static boolean isLetter(CharSequence s, int index) {\n+        int codePoint = Character.codePointAt(s, index);\n+        return Character.isLetter(codePoint);\n+    }\n+\n+    public static boolean isSpaceOrTab(CharSequence s, int index) {\n+        if (index < s.length()) {\n+            switch (s.charAt(index)) {\n+                case ' ':\n+                case '\\t':\n+                    return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * @see <a href=\"https:\/\/spec.commonmark.org\/0.31.2\/#unicode-punctuation-character\">Unicode punctuation character<\/a>\n+     *\/\n+    public static boolean isPunctuationCodePoint(int codePoint) {\n+        switch (Character.getType(codePoint)) {\n+            \/\/ General category \"P\" (punctuation)\n+            case Character.DASH_PUNCTUATION:\n+            case Character.START_PUNCTUATION:\n+            case Character.END_PUNCTUATION:\n+            case Character.CONNECTOR_PUNCTUATION:\n+            case Character.OTHER_PUNCTUATION:\n+            case Character.INITIAL_QUOTE_PUNCTUATION:\n+            case Character.FINAL_QUOTE_PUNCTUATION:\n+                \/\/ General category \"S\" (symbol)\n+            case Character.MATH_SYMBOL:\n+            case Character.CURRENCY_SYMBOL:\n+            case Character.MODIFIER_SYMBOL:\n+            case Character.OTHER_SYMBOL:\n+                return true;\n+            default:\n+                switch (codePoint) {\n+                    case '$':\n+                    case '+':\n+                    case '<':\n+                    case '=':\n+                    case '>':\n+                    case '^':\n+                    case '`':\n+                    case '|':\n+                    case '~':\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+        }\n+    }\n+\n+    \/**\n+     * Check whether the provided code point is a Unicode whitespace character as defined in the spec.\n+     *\n+     * @see <a href=\"https:\/\/spec.commonmark.org\/0.31.2\/#unicode-whitespace-character\">Unicode whitespace character<\/a>\n+     *\/\n+    public static boolean isWhitespaceCodePoint(int codePoint) {\n+        switch (codePoint) {\n+            case ' ':\n+            case '\\t':\n+            case '\\n':\n+            case '\\f':\n+            case '\\r':\n+                return true;\n+            default:\n+                return Character.getType(codePoint) == Character.SPACE_SEPARATOR;\n+        }\n+    }\n+\n+    public static int skip(char skip, CharSequence s, int startIndex, int endIndex) {\n+        for (int i = startIndex; i < endIndex; i++) {\n+            if (s.charAt(i) != skip) {\n+                return i;\n+            }\n+        }\n+        return endIndex;\n+    }\n+\n+    public static int skipBackwards(char skip, CharSequence s, int startIndex, int lastIndex) {\n+        for (int i = startIndex; i >= lastIndex; i--) {\n+            if (s.charAt(i) != skip) {\n+                return i;\n+            }\n+        }\n+        return lastIndex - 1;\n+    }\n+\n+    public static int skipSpaceTab(CharSequence s, int startIndex, int endIndex) {\n+        for (int i = startIndex; i < endIndex; i++) {\n+            switch (s.charAt(i)) {\n+                case ' ':\n+                case '\\t':\n+                    break;\n+                default:\n+                    return i;\n+            }\n+        }\n+        return endIndex;\n+    }\n+\n+    public static int skipSpaceTabBackwards(CharSequence s, int startIndex, int lastIndex) {\n+        for (int i = startIndex; i >= lastIndex; i--) {\n+            switch (s.charAt(i)) {\n+                case ' ':\n+                case '\\t':\n+                    break;\n+                default:\n+                    return i;\n+            }\n+        }\n+        return lastIndex - 1;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/text\/Characters.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n- * Parsing input text to AST nodes (see {@link org.commonmark.parser.Parser})\n+ * Text processing utilities for parsing and rendering, exported for use by extensions\n@@ -36,1 +36,1 @@\n-package jdk.internal.org.commonmark.parser;\n+package jdk.internal.org.commonmark.text;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/text\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/package-info.java","status":"copied"},{"patch":"@@ -1,1 +1,1 @@\n-## CommonMark 0.21.0\n+## CommonMark 0.22.0\n","filename":"src\/jdk.internal.md\/share\/legal\/commonmark.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}