{"files":[{"patch":"@@ -244,0 +244,6 @@\n+\n+  \/\/ Instead of always resetting immediately before the start of a new GC, we can often reset at the end of the\n+  \/\/ previous GC. This allows us to start the next GC cycle more quickly after a trigger condition is detected,\n+  \/\/ reducing the likelihood that GC will degenerate.\n+  entry_reset_after_collect();\n+\n@@ -366,11 +372,0 @@\n-\n-  if (_do_old_gc_bootstrap) {\n-    static const char* msg = \"Concurrent reset (Old)\";\n-    ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_reset_old);\n-    ShenandoahWorkerScope scope(ShenandoahHeap::heap()->workers(),\n-                                ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),\n-                                msg);\n-    EventMark em(\"%s\", msg);\n-\n-    heap->old_generation()->prepare_gc();\n-  }\n@@ -586,0 +581,10 @@\n+void ShenandoahConcurrentGC::entry_reset_after_collect() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+  const char* msg = conc_reset_after_collect_event_message();\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_reset_after_collect);\n+  EventMark em(\"%s\", msg);\n+\n+  op_reset_after_collect();\n+}\n+\n@@ -591,1 +596,8 @@\n-  _generation->prepare_gc();\n+  \/\/ If it is old GC bootstrap cycle, always clear bitmap for global gen\n+  \/\/ to ensure bitmap for old gen is clear for old GC cycle after this.\n+  if (_do_old_gc_bootstrap) {\n+    assert(!heap->is_prepare_for_old_mark_in_progress(), \"Cannot reset old without making it parsable\");\n+    heap->global_generation()->prepare_gc();\n+  } else {\n+    _generation->prepare_gc();\n+  }\n@@ -1214,0 +1226,20 @@\n+void ShenandoahConcurrentGC::op_reset_after_collect() {\n+  ShenandoahWorkerScope scope(ShenandoahHeap::heap()->workers(),\n+                          ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),\n+                          \"reset after collection.\");\n+\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  if (heap->mode()->is_generational()) {\n+    \/\/ Resetting bitmaps of young gen when bootstrap old GC or there is preempted old GC\n+    \/\/ causes crash due to remembered set violation, hence condition is added to fix the crash.\n+    \/\/ Assuming bitmaps of young gen are not used at all after the cycle, the crash should not\n+    \/\/ have happend, it seems to tickle a bug in remembered set scan. Root causing and fixing of the bug\n+    \/\/ will be tracked via ticket https:\/\/bugs.openjdk.org\/browse\/JDK-8347371\n+    if (!_do_old_gc_bootstrap && !heap->is_concurrent_old_mark_in_progress()) {\n+      heap->young_generation()->reset_mark_bitmap<false>();\n+    }\n+  } else {\n+    _generation->reset_mark_bitmap<false>();\n+  }\n+}\n+\n@@ -1263,0 +1295,8 @@\n+const char* ShenandoahConcurrentGC::conc_reset_after_collect_event_message() const {\n+  if (ShenandoahHeap::heap()->unload_classes()) {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent reset after collect\", \" (unload classes)\");\n+  } else {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent reset after collect\", \"\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":52,"deletions":12,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+  void op_reset_after_collect();\n@@ -125,0 +126,3 @@\n+  \/\/ Called when concurrent GC succeeds.\n+  void entry_reset_after_collect();\n+\n@@ -137,0 +141,1 @@\n+  const char* conc_reset_after_collect_event_message() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -200,6 +200,1 @@\n-    \/\/ d. Reset the bitmaps for new marking\n-    heap->global_generation()->reset_mark_bitmap();\n-    assert(heap->marking_context()->is_bitmap_clear(), \"sanity\");\n-    assert(!heap->global_generation()->is_mark_complete(), \"sanity\");\n-\n-    \/\/ e. Abandon reference discovery and clear all discovered references.\n+    \/\/ d. Abandon reference discovery and clear all discovered references.\n@@ -209,1 +204,1 @@\n-    \/\/ f. Sync pinned region status from the CP marks\n+    \/\/ e. Sync pinned region status from the CP marks\n@@ -290,15 +285,0 @@\n-class ShenandoahPrepareForMarkClosure: public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahMarkingContext* const _ctx;\n-\n-public:\n-  ShenandoahPrepareForMarkClosure() : _ctx(ShenandoahHeap::heap()->marking_context()) {}\n-\n-  void heap_region_do(ShenandoahHeapRegion *r) override {\n-    _ctx->capture_top_at_mark_start(r);\n-    r->clear_live_data();\n-  }\n-\n-  bool is_thread_safe() override { return true; }\n-};\n-\n@@ -311,3 +291,3 @@\n-  ShenandoahPrepareForMarkClosure prepare_for_mark;\n-  ShenandoahExcludeRegionClosure<FREE> cl(&prepare_for_mark);\n-  heap->parallel_heap_region_iterate(&cl);\n+  heap->global_generation()->reset_mark_bitmap<true, true>();\n+  assert(heap->marking_context()->is_bitmap_clear(), \"sanity\");\n+  assert(!heap->global_generation()->is_mark_complete(), \"sanity\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":5,"deletions":25,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-\n-class ShenandoahResetUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n+template <bool PREPARE_FOR_CURRENT_CYCLE, bool FULL_GC = false>\n+class ShenandoahResetBitmapClosure final : public ShenandoahHeapRegionClosure {\n@@ -47,2 +47,3 @@\n-  ShenandoahHeap* _heap;\n-  ShenandoahMarkingContext* const _ctx;\n+  ShenandoahHeap*           _heap;\n+  ShenandoahMarkingContext* _ctx;\n+\n@@ -50,3 +51,2 @@\n-  ShenandoahResetUpdateRegionStateClosure() :\n-    _heap(ShenandoahHeap::heap()),\n-    _ctx(_heap->marking_context()) {}\n+  explicit ShenandoahResetBitmapClosure() :\n+    ShenandoahHeapRegionClosure(), _heap(ShenandoahHeap::heap()), _ctx(_heap->marking_context()) {}\n@@ -54,6 +54,22 @@\n-  void heap_region_do(ShenandoahHeapRegion* r) override {\n-    if (r->is_active()) {\n-      \/\/ Reset live data and set TAMS optimistically. We would recheck these under the pause\n-      \/\/ anyway to capture any updates that happened since now.\n-      _ctx->capture_top_at_mark_start(r);\n-      r->clear_live_data();\n+  void heap_region_do(ShenandoahHeapRegion* region) override {\n+    assert(!_heap->is_uncommit_in_progress(), \"Cannot uncommit bitmaps while resetting them.\");\n+    if (PREPARE_FOR_CURRENT_CYCLE) {\n+      if (region->need_bitmap_reset() && _heap->is_bitmap_slice_committed(region)) {\n+        _ctx->clear_bitmap(region);\n+      } else {\n+        region->set_needs_bitmap_reset();\n+      }\n+      \/\/ Capture Top At Mark Start for this generation.\n+      if (FULL_GC || region->is_active()) {\n+        \/\/ Reset live data and set TAMS optimistically. We would recheck these under the pause\n+        \/\/ anyway to capture any updates that happened since now.\n+        _ctx->capture_top_at_mark_start(region);\n+        region->clear_live_data();\n+      }\n+    } else {\n+      if (_heap->is_bitmap_slice_committed(region)) {\n+        _ctx->clear_bitmap(region);\n+        region->unset_needs_bitmap_reset();\n+      } else {\n+        region->set_needs_bitmap_reset();\n+      }\n@@ -66,25 +82,0 @@\n-class ShenandoahResetBitmapTask : public WorkerTask {\n-private:\n-  ShenandoahRegionIterator _regions;\n-  ShenandoahGeneration* _generation;\n-\n-public:\n-  ShenandoahResetBitmapTask(ShenandoahGeneration* generation) :\n-    WorkerTask(\"Shenandoah Reset Bitmap\"), _generation(generation) {}\n-\n-  void work(uint worker_id) {\n-    ShenandoahHeap* heap = ShenandoahHeap::heap();\n-    assert(!heap->is_uncommit_in_progress(), \"Cannot uncommit bitmaps while resetting them.\");\n-    ShenandoahHeapRegion* region = _regions.next();\n-    ShenandoahMarkingContext* const ctx = heap->marking_context();\n-    while (region != nullptr) {\n-      auto const affiliation = region->affiliation();\n-      bool needs_reset = affiliation == FREE || _generation->contains(affiliation);\n-      if (needs_reset && heap->is_bitmap_slice_committed(region)) {\n-        ctx->clear_bitmap(region);\n-      }\n-      region = _regions.next();\n-    }\n-  }\n-};\n-\n@@ -228,0 +219,1 @@\n+template <bool PREPARE_FOR_CURRENT_CYCLE, bool FULL_GC>\n@@ -234,2 +226,2 @@\n-  ShenandoahResetBitmapTask task(this);\n-  heap->workers()->run_task(&task);\n+  ShenandoahResetBitmapClosure<PREPARE_FOR_CURRENT_CYCLE, FULL_GC> closure;\n+  parallel_heap_region_iterate_free(&closure);\n@@ -237,0 +229,4 @@\n+\/\/ Explicit specializations\n+template void ShenandoahGeneration::reset_mark_bitmap<true, false>();\n+template void ShenandoahGeneration::reset_mark_bitmap<true, true>();\n+template void ShenandoahGeneration::reset_mark_bitmap<false, false>();\n@@ -268,6 +264,1 @@\n-\n-  reset_mark_bitmap();\n-\n-  \/\/ Capture Top At Mark Start for this generation (typically young) and reset mark bitmap.\n-  ShenandoahResetUpdateRegionStateClosure cl;\n-  parallel_heap_region_iterate_free(&cl);\n+  reset_mark_bitmap<true>();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":37,"deletions":46,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -162,0 +162,1 @@\n+  template <bool FOR_CURRENT_CYCLE, bool FULL_GC = false>\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  _age(0)\n+  _age(0),\n@@ -81,1 +81,1 @@\n-  , _youth(0)\n+  _youth(0),\n@@ -83,0 +83,1 @@\n+  _needs_bitmap_reset(false)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -269,0 +269,2 @@\n+  bool _needs_bitmap_reset;\n+\n@@ -480,0 +482,12 @@\n+  inline bool need_bitmap_reset() const {\n+    return _needs_bitmap_reset;\n+  }\n+\n+  inline void set_needs_bitmap_reset() {\n+    _needs_bitmap_reset = true;\n+  }\n+\n+  inline void unset_needs_bitmap_reset() {\n+    _needs_bitmap_reset = false;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  f(conc_reset_after_collect,                       \"Concurrent Reset After Collect\")  \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}