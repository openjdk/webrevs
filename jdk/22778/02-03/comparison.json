{"files":[{"patch":"@@ -240,2 +240,3 @@\n-  \/\/ Instead of always reset before collect, some reset can be done after collect to save\n-  \/\/ the time before before the cycle so the cycle can be started as soon as possible.\n+  \/\/ Instead of always resetting immediately before the start of a new GC, we can often reset at the end of the\n+  \/\/ previous GC. This allows us to start the next GC cycle more quickly after a trigger condition is detected,\n+  \/\/ reducing the likelihood that GC will degenerate.\n@@ -1208,0 +1209,5 @@\n+    \/\/ Resetting bitmaps of young gen when bootstrap old GC or there is preempted old GC\n+    \/\/ causes crash due to remembered set violation, hence condition is added to fix the crash.\n+    \/\/ Assuming bitmaps of young gen are not used at all after the cycle, the crash should not\n+    \/\/ have happend, it seems to tickle a bug in remembered set scan. Root causing and fixing of the bug\n+    \/\/ will be tracked via ticket https:\/\/bugs.openjdk.org\/browse\/JDK-8347371\n@@ -1209,2 +1215,0 @@\n-      \/\/ Only reset for young generation, bitmap for old generation must be retained,\n-      \/\/ except there is collection(global\/old\/degen\/full) trigged to collect regions in old gen.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -160,3 +160,0 @@\n-\n-  entry_reset_after_collect();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}