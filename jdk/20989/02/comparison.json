{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/containers\/systemd\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassObjectReference\/reflectedType\/reflectype002\/TEST.properties","status":"copied"},{"patch":"@@ -31,0 +31,1 @@\n+import java.nio.file.StandardOpenOption;\n@@ -95,12 +96,8 @@\n-            try {\n-                if (files.memory() != null) {\n-                    Files.delete(files.memory());\n-                }\n-                if (files.cpu() != null) {\n-                    Files.delete(files.cpu());\n-                }\n-                if (files.sliceDotDDir() != null) {\n-                    FileUtils.deleteFileTreeUnchecked(files.sliceDotDDir());\n-                }\n-            } catch (NoSuchFileException e) {\n-                \/\/ ignore\n+            cleanupFiles(files);\n+        }\n+    }\n+\n+    private static void cleanupFiles(ResultFiles files) throws IOException {\n+        try {\n+            if (files.memory() != null) {\n+                Files.delete(files.memory());\n@@ -108,0 +105,8 @@\n+            if (files.cpu() != null) {\n+                Files.delete(files.cpu());\n+            }\n+            if (files.sliceDotDDir() != null) {\n+                FileUtils.deleteFileTreeUnchecked(files.sliceDotDDir());\n+            }\n+        } catch (NoSuchFileException e) {\n+            \/\/ ignore\n@@ -138,1 +143,3 @@\n-            Files.createDirectory(sliceDotDDir);\n+            \/\/ Using createDirectories since we only need to ensure the directory\n+            \/\/ exists. Ignore it if already existent.\n+            Files.createDirectories(sliceDotDDir);\n@@ -142,1 +149,4 @@\n-                Files.writeString(memoryConfig, getMemoryDSliceContent(runOpts));\n+                Files.writeString(memoryConfig,\n+                                  getMemoryDSliceContent(runOpts),\n+                                  StandardOpenOption.TRUNCATE_EXISTING,\n+                                  StandardOpenOption.CREATE);\n@@ -146,1 +156,4 @@\n-                Files.writeString(cpuConfig, getCPUDSliceContent(runOpts));\n+                Files.writeString(cpuConfig,\n+                                  getCPUDSliceContent(runOpts),\n+                                  StandardOpenOption.TRUNCATE_EXISTING,\n+                                  StandardOpenOption.CREATE);\n@@ -162,1 +175,1 @@\n-        systemdDaemonReload(cpu);\n+        systemdDaemonReload(cpu, memory, sliceDotDDir);\n@@ -178,1 +191,1 @@\n-    private static void systemdDaemonReload(Path cpu) throws Exception {\n+    private static void systemdDaemonReload(Path cpu, Path memory, Path sliceDdir) throws Exception {\n@@ -183,1 +196,14 @@\n-            throw new AssertionError(\"Failed to reload systemd daemon\");\n+            if (RUN_AS_USER) {\n+                cleanupFiles(new ResultFiles(cpu, memory, sliceDdir));\n+                \/\/ When run as user the systemd user manager needs to be\n+                \/\/ accessible and working. This is usually the case when\n+                \/\/ connected via SSH or user login, but may not work for\n+                \/\/ sessions set up via 'su <user>' or similar.\n+                \/\/ In that case, 'systemctl --user status' usually doesn't\n+                \/\/ work. There is no other option than skip the test.\n+                String msg = \"Service user@.service not properly configured. \" +\n+                             \"Skipping the test!\";\n+                throw new SkippedException(msg);\n+            } else {\n+                throw new AssertionError(\"Failed to reload systemd daemon\");\n+            }\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/systemd\/SystemdTestUtils.java","additions":44,"deletions":18,"binary":false,"changes":62,"status":"modified"}]}