{"files":[{"patch":"@@ -173,1 +173,1 @@\n-JVM_ENTRY_NO_ENV(void, jfr_set_cpu_throttle(JNIEnv* env, jclass jvm, jdouble rate, jboolean auto_adapt))\n+JVM_ENTRY_NO_ENV(void, jfr_set_cpu_rate(JNIEnv* env, jclass jvm, jdouble rate))\n@@ -175,1 +175,7 @@\n-  JfrCPUTimeThreadSampling::set_rate(rate, auto_adapt == JNI_TRUE);\n+  JfrCPUTimeThreadSampling::set_rate(rate);\n+JVM_END\n+\n+JVM_ENTRY_NO_ENV(void, jfr_set_cpu_period(JNIEnv* env, jclass jvm, jlong period_nanos))\n+  assert(period_nanos >= 0, \"invariant\");\n+  JfrEventSetting::set_enabled(JfrCPUTimeSampleEvent, period_nanos > 0);\n+  JfrCPUTimeThreadSampling::set_period(period_nanos);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -132,1 +132,3 @@\n-void JNICALL jfr_set_cpu_throttle(JNIEnv* env, jclass jvm, jdouble rate, jboolean auto_adapt);\n+void JNICALL jfr_set_cpu_rate(JNIEnv* env, jclass jvm, jdouble rate);\n+\n+void JNICALL jfr_set_cpu_period(JNIEnv* env, jclass jvm, jlong period_nanos);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,2 @@\n-      (char*)\"setCPUThrottle\", (char*)\"(DZ)V\", (void*)jfr_set_cpu_throttle,\n+      (char*)\"setCPURate\", (char*)\"(D)V\", (void*)jfr_set_cpu_rate,\n+      (char*)\"setCPUPeriod\", (char*)\"(J)V\", (void*)jfr_set_cpu_period,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-static const int64_t AUTOADAPT_INTERVAL_MS = 100;\n+static const int64_t RECOMPUTE_INTERVAL_MS = 100;\n@@ -166,3 +166,13 @@\n-static int64_t compute_sampling_period(double rate) {\n-  if (rate == 0) {\n-    return 0;\n+\/\/ A throttle is either a rate or a fixed period\n+class JfrCPUSamplerThrottle {\n+\n+  union {\n+    double _rate;\n+    u8 _period_nanos;\n+  };\n+  bool _is_rate;\n+\n+public:\n+\n+  JfrCPUSamplerThrottle(double rate) : _rate(rate), _is_rate(true) {\n+    assert(rate >= 0, \"invariant\");\n@@ -170,2 +180,15 @@\n-  return os::active_processor_count() * 1000000000.0 \/ rate;\n-}\n+\n+  JfrCPUSamplerThrottle(u8 period_nanos) : _period_nanos(period_nanos), _is_rate(false) {}\n+\n+  bool enabled() const { return _is_rate ? _rate > 0 : _period_nanos > 0; }\n+\n+  int64_t compute_sampling_period() const {\n+    if (_is_rate) {\n+      if (_rate == 0) {\n+        return 0;\n+      }\n+      return os::active_processor_count() * 1000000000.0 \/ _rate;\n+    }\n+    return _period_nanos;\n+  }\n+};\n@@ -178,2 +201,1 @@\n-  double _rate;\n-  bool _auto_adapt;\n+  JfrCPUSamplerThrottle _throttle;\n@@ -190,1 +212,1 @@\n-  JfrCPUSamplerThread(double rate, bool auto_adapt);\n+  JfrCPUSamplerThread(JfrCPUSamplerThrottle& throttle);\n@@ -198,1 +220,1 @@\n-  void auto_adapt_period_if_needed();\n+  void recompute_period_if_needed();\n@@ -200,1 +222,1 @@\n-  void set_rate(double rate, bool auto_adapt);\n+  void set_throttle(JfrCPUSamplerThrottle& throttle);\n@@ -234,1 +256,1 @@\n-JfrCPUSamplerThread::JfrCPUSamplerThread(double rate, bool auto_adapt) :\n+JfrCPUSamplerThread::JfrCPUSamplerThread(JfrCPUSamplerThrottle& throttle) :\n@@ -237,3 +259,2 @@\n-  _rate(rate),\n-  _auto_adapt(auto_adapt),\n-  _current_sampling_period_ns(compute_sampling_period(rate)),\n+  _throttle(throttle),\n+  _current_sampling_period_ns(throttle.compute_sampling_period()),\n@@ -245,1 +266,0 @@\n-  assert(rate >= 0, \"invariant\");\n@@ -324,1 +344,1 @@\n-  int64_t last_auto_adapt_check = os::javaTimeNanos();\n+  int64_t last_recompute_check = os::javaTimeNanos();\n@@ -332,3 +352,3 @@\n-    if (os::javaTimeNanos() - last_auto_adapt_check > AUTOADAPT_INTERVAL_MS * 1000000) {\n-      auto_adapt_period_if_needed();\n-      last_auto_adapt_check = os::javaTimeNanos();\n+    if (os::javaTimeNanos() - last_recompute_check > RECOMPUTE_INTERVAL_MS * 1000000) {\n+      recompute_period_if_needed();\n+      last_recompute_check = os::javaTimeNanos();\n@@ -445,1 +465,1 @@\n-void JfrCPUTimeThreadSampling::create_sampler(double rate, bool auto_adapt) {\n+void JfrCPUTimeThreadSampling::create_sampler(JfrCPUSamplerThrottle& throttle) {\n@@ -447,1 +467,1 @@\n-  _sampler = new JfrCPUSamplerThread(rate, auto_adapt);\n+  _sampler = new JfrCPUSamplerThread(throttle);\n@@ -452,2 +472,2 @@\n-void JfrCPUTimeThreadSampling::update_run_state(double rate, bool auto_adapt) {\n-  if (rate != 0) {\n+void JfrCPUTimeThreadSampling::update_run_state(JfrCPUSamplerThrottle& throttle) {\n+  if (throttle.enabled()) {\n@@ -455,1 +475,1 @@\n-      create_sampler(rate, auto_adapt);\n+      create_sampler(throttle);\n@@ -457,1 +477,1 @@\n-      _sampler->set_rate(rate, auto_adapt);\n+      _sampler->set_throttle(throttle);\n@@ -463,1 +483,1 @@\n-    _sampler->set_rate(rate \/* 0 *\/, auto_adapt);\n+    _sampler->set_throttle(throttle);\n@@ -468,2 +488,9 @@\n-void JfrCPUTimeThreadSampling::set_rate(double rate, bool auto_adapt) {\n-  assert(rate >= 0, \"invariant\");\n+void JfrCPUTimeThreadSampling::set_rate(double rate) {\n+  if (_instance == nullptr) {\n+    return;\n+  }\n+  JfrCPUSamplerThrottle throttle(rate);\n+  instance().set_throttle_value(throttle);\n+}\n+\n+void JfrCPUTimeThreadSampling::set_period(u8 nanos) {\n@@ -473,1 +500,2 @@\n-  instance().set_rate_value(rate, auto_adapt);\n+  JfrCPUSamplerThrottle throttle(nanos);\n+  instance().set_throttle_value(throttle);\n@@ -476,1 +504,1 @@\n-void JfrCPUTimeThreadSampling::set_rate_value(double rate, bool auto_adapt) {\n+void JfrCPUTimeThreadSampling::set_throttle_value(JfrCPUSamplerThrottle& throttle) {\n@@ -478,1 +506,1 @@\n-    _sampler->set_rate(rate, auto_adapt);\n+    _sampler->set_throttle(throttle);\n@@ -480,1 +508,1 @@\n-  update_run_state(rate, auto_adapt);\n+  update_run_state(throttle);\n@@ -707,1 +735,1 @@\n-void JfrCPUSamplerThread::auto_adapt_period_if_needed() {\n+void JfrCPUSamplerThread::recompute_period_if_needed() {\n@@ -709,6 +737,4 @@\n-  if (_auto_adapt || current_period == -1) {\n-    int64_t period = compute_sampling_period(_rate);\n-    if (period != current_period) {\n-      Atomic::store(&_current_sampling_period_ns, period);\n-      update_all_thread_timers();\n-    }\n+  int64_t period = _throttle.compute_sampling_period();\n+  if (period != current_period) {\n+    Atomic::store(&_current_sampling_period_ns, period);\n+    update_all_thread_timers();\n@@ -718,5 +744,4 @@\n-void JfrCPUSamplerThread::set_rate(double rate, bool auto_adapt) {\n-  _rate = rate;\n-  _auto_adapt = auto_adapt;\n-  if (_rate > 0 && Atomic::load_acquire(&_disenrolled) == false) {\n-    auto_adapt_period_if_needed();\n+void JfrCPUSamplerThread::set_throttle(JfrCPUSamplerThrottle& throttle) {\n+  _throttle = throttle;\n+  if (_throttle.enabled() && Atomic::load_acquire(&_disenrolled) == false) {\n+    recompute_period_if_needed();\n@@ -724,1 +749,1 @@\n-    Atomic::store(&_current_sampling_period_ns, compute_sampling_period(rate));\n+    Atomic::store(&_current_sampling_period_ns, _throttle.compute_sampling_period());\n@@ -768,1 +793,1 @@\n-void JfrCPUTimeThreadSampling::set_rate(double rate, bool auto_adapt) {\n+void JfrCPUTimeThreadSampling::set_rate(double rate) {\n@@ -774,0 +799,6 @@\n+void JfrCPUTimeThreadSampling::set_period(u8 period_nanos) {\n+  if (period_nanos != 0) {\n+    warn();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":78,"deletions":47,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -98,0 +98,2 @@\n+class JfrCPUSamplerThrottle;\n+\n@@ -104,2 +106,2 @@\n-  void create_sampler(double rate, bool auto_adapt);\n-  void set_rate_value(double rate, bool auto_adapt);\n+  void create_sampler(JfrCPUSamplerThrottle& throttle);\n+  void set_throttle_value(JfrCPUSamplerThrottle& throttle);\n@@ -114,1 +116,3 @@\n-  void update_run_state(double rate, bool auto_adapt);\n+  void update_run_state(JfrCPUSamplerThrottle& throttle);\n+\n+  static void set_rate(JfrCPUSamplerThrottle& throttle);\n@@ -117,1 +121,2 @@\n-  static void set_rate(double rate, bool auto_adapt);\n+  static void set_rate(double rate);\n+  static void set_period(u8 nanos);\n@@ -143,1 +148,2 @@\n-  static void set_rate(double rate, bool auto_adapt);\n+  static void set_rate(double rate);\n+  static void set_period(u8 nanos);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -276,0 +276,2 @@\n+     * Use {@link #setCPUPeriod(long)} if you want a fixed sampling period instead.\n+     *\n@@ -279,1 +281,0 @@\n-     * @param autoAdapt true if the rate should be adapted automatically\n@@ -281,1 +282,12 @@\n-    public static native void setCPUThrottle(double rate, boolean autoAdapt);\n+    public static native void setCPURate(double rate);\n+\n+    \/**\n+     * Set the fixed CPU time sampler period.\n+     *\n+     * Use {@link #setCPURate(double)} if you want a fixed rate with an auto-adjusted period instead.\n+     *\n+     * Setting period to 0 turns off the CPU time sampler.\n+     *\n+     * @param periodNanos the new fixed period in nanoseconds\n+     *\/\n+    public static native void setCPUPeriod(long periodNanos);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -207,1 +207,5 @@\n-                JVM.setCPUThrottle(rate.rate(), rate.autoAdapt());\n+                if (rate.isRate()) {\n+                    JVM.setCPURate(rate.rate());\n+                } else {\n+                    JVM.setCPUPeriod(rate.periodNanos());\n+                }\n@@ -273,2 +277,6 @@\n-                TimespanRate r = enabled ? cpuRate : new TimespanRate(0, false);\n-                JVM.setCPUThrottle(r.rate(), r.autoAdapt());\n+                TimespanRate r = enabled ? cpuRate : TimespanRate.OFF;\n+                if (r.isRate()) {\n+                    JVM.setCPURate(r.rate());\n+                } else {\n+                    JVM.setCPUPeriod(r.periodNanos());\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        TimespanRate max = null;\n+        TimespanRate highestRate = null;\n@@ -65,2 +65,4 @@\n-                if (max == null || rate.isHigher(max)) {\n-                    max = rate;\n+                if (highestRate == null) {\n+                    highestRate = rate;\n+                } else {\n+                    highestRate = TimespanRate.selectHigherResolution(highestRate, rate);\n@@ -68,1 +70,0 @@\n-                max = new TimespanRate(max.rate(), max.autoAdapt() || rate.autoAdapt());\n@@ -71,2 +72,1 @@\n-        \/\/ \"off\" is not supported\n-        return Objects.requireNonNullElse(max.toString(), DEFAULT_VALUE);\n+        return Objects.requireNonNullElse(highestRate.toString(), DEFAULT_VALUE);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/CPUThrottleSetting.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-public record TimespanRate(double rate, boolean autoAdapt) {\n+public record TimespanRate(double rate, long periodNanos, boolean isRate) {\n@@ -35,0 +35,11 @@\n+    public static final TimespanRate OFF = new TimespanRate(0, 0, false);\n+\n+    \/**\n+     * Parses the rate string. Supports\n+     *\n+     * <ul>\n+     *  <li>off<\/li>\n+     *  <li>time value like \"1ms\"<\/li>\n+     *  <li>rate value like \"10\/s\"<\/li>\n+     * <\/ul>\n+     *\/\n@@ -37,1 +48,1 @@\n-            text = CPUThrottleSetting.DEFAULT_VALUE;\n+            return OFF;\n@@ -46,1 +57,1 @@\n-                return new TimespanRate(0, false);\n+                return OFF;\n@@ -48,1 +59,1 @@\n-            return new TimespanRate(Runtime.getRuntime().availableProcessors() \/ (period \/ 1_000_000_000.0), false);\n+            return new TimespanRate(0, period, false);\n@@ -54,1 +65,1 @@\n-        return new TimespanRate(r.perSecond(), true);\n+        return new TimespanRate(r.perSecond(), 0, true);\n@@ -57,2 +68,13 @@\n-    public boolean isHigher(TimespanRate that) {\n-        return rate() > that.rate();\n+    public static TimespanRate selectHigherResolution(TimespanRate a, TimespanRate b) {\n+        if (a.isRate && b.isRate) {\n+            return a.rate() > b.rate() ? a : b;\n+        }\n+        if (!a.isRate && !b.isRate) {\n+            return a.periodNanos() < b.periodNanos() ? a : b;\n+        }\n+        if (a.isRate) {\n+            double bRate = Runtime.getRuntime().availableProcessors() * (1_000_000_000.0 \/ b.periodNanos());\n+            return new TimespanRate(Math.max(a.rate(), bRate), 0, true);\n+        }\n+        double aRate = Runtime.getRuntime().availableProcessors() * (1_000_000_000.0 \/ a.periodNanos());\n+        return new TimespanRate(Math.max(aRate, b.rate()), 0, true);\n@@ -63,2 +85,27 @@\n-        if (autoAdapt) {\n-            return String.format(\"%d\/ns\", (long)(rate * 1_000_000_000L));\n+        if (isRate) {\n+            return toRateString();\n+        }\n+        return toPeriodString();\n+    }\n+\n+    private String toRateString() {\n+        \/\/ idea: try to use the smallest unit possible where the rate is still an integer\n+        \/\/ start with seconds, then try minutes, hours, etc.\n+        assert isRate;\n+        if (rate == 0) {\n+            return \"0\/s\";\n+        }\n+        for (TimespanUnit unit : TimespanUnit.values()) {\n+            double value = rate \/ unit.nanos * 1_000_000_000.0;\n+            if (value % 1 == 0) {\n+                return String.format(\"%d\/%s\", (long)value, unit.text);\n+            }\n+        }\n+        \/\/ fallback to days if no smaller unit is found\n+        return String.format(\"%d\/%s\", (long)(rate \/ TimespanUnit.DAYS.nanos * 1_000_000_000.0), TimespanUnit.DAYS.text);\n+    }\n+\n+    private String toPeriodString() {\n+        assert !isRate;\n+        if (periodNanos == 0) {\n+            return \"0ms\";\n@@ -66,1 +113,1 @@\n-        return String.format(\"%dns\", (long)(Runtime.getRuntime().availableProcessors() \/ rate * 1_000_000_000L));\n+        return String.format(\"%dns\", periodNanos);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/TimespanRate.java","additions":57,"deletions":10,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-    static String sampleEvent = EventNames.CPUTimeSample;\n-\n@@ -46,4 +44,4 @@\n-        run(EventNames.ExecutionSample);\n-        run(EventNames.CPUTimeSample);\n-        run(EventNames.ExecutionSample);\n-        run(EventNames.CPUTimeSample);\n+        run(EventNames.CPUTimeSample, \"throttle\", \"1000\/s\");\n+        run(EventNames.ExecutionSample, \"period\", \"1100ms\");\n+        run(EventNames.CPUTimeSample, \"throttle\", \"1100ms\");\n+        run(EventNames.ExecutionSample, \"period\", \"1000ms\");\n@@ -52,1 +50,1 @@\n-    private static void run(String eventType) {\n+    private static void run(String eventType, String attribute, String value) {\n@@ -56,2 +54,2 @@\n-            rs.enable(sampleEvent).with(\"throttle\", \"1000\/s\");\n-            rs.onEvent(sampleEvent, e -> {\n+            rs.enable(eventType).with(attribute, value);\n+            rs.onEvent(eventType, e -> {\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeAndExecutionSample.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"}]}