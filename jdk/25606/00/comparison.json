{"files":[{"patch":"@@ -354,3 +354,3 @@\n-                    long size = CENSIZ(zsrc.cen, pos);\n-                    if (size > 65536) {\n-                        size = 8192;\n+                    long inputBufSize = CENSIZ(zsrc.cen, pos);\n+                    if (inputBufSize > 65536 || inputBufSize <= 0) {\n+                        inputBufSize = 8192;\n@@ -358,1 +358,1 @@\n-                    InputStream is = new ZipFileInflaterInputStream(in, res, (int) size);\n+                    InputStream is = new ZipFileInflaterInputStream(in, res, (int) inputBufSize);\n@@ -419,2 +419,2 @@\n-                                   CleanableResource res, int size) {\n-            this(zfin, res, res.getInflater(), size);\n+                                   CleanableResource res, int inputBufSize) {\n+            this(zfin, res, res.getInflater(), inputBufSize);\n@@ -425,2 +425,2 @@\n-                                           Inflater inf, int size) {\n-            super(zfin, inf, size);\n+                                           Inflater inf, int inputBufSize) {\n+            super(zfin, inf, inputBufSize);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HexFormat;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.junit.jupiter.api.Test;\n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @bug 8358456\n+ * @summary verify that ZipFile.getInputStream(ZipFile) doesn't throw an unspecified exception\n+ *          for invalid compressed size of an entry\n+ * @run junit InvalidCompressedSizeTest\n+ *\/\n+class InvalidCompressedSizeTest {\n+\n+    private static final String ENTRY_NAME = \"foo-bar\";\n+    private static final byte[] ENTRY_CONTENT = new byte[]{0x42, 0x42};\n+\n+    \/\/ created through a call to createZIPContent()\n+    private static final String ZIP_CONTENT_HEX = \"\"\"\n+            504b03041400080808005053c35a00000000000000000000000007000000666f6f2d6261727\n+            3720200504b0708c41f441b0400000002000000504b010214001400080808005053c35ac41f\n+            441b0400000002000000070000000000000000000000000000000000666f6f2d626172504b0\n+            506000000000100010035000000390000000000\n+            \"\"\";\n+\n+\n+    \/\/    0039 CENTRAL HEADER #1     02014B50\n+    \/\/    ...\n+    \/\/    0043 Compression Method    0008 'Deflated'\n+    \/\/    ...\n+    \/\/    004D Compressed Length     00000004\n+    \/\/    0051 Uncompressed Length   00000002\n+    \/\/    ...\n+    \/\/    0067 Filename              'foo-bar'\n+    \/\/ this is the offset in the ZIP content stream for the compressed size field\n+    \/\/ for the entry of interest\n+    private static final int COMP_SIZE_OFFSET = 0x004D;\n+\n+    \/\/ intentionally unused but left here to allow for constructing newer\/updated\n+    \/\/ ZIP_CONTENT_HEX, when necessary\n+    private static String createZIPContent() throws IOException {\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (final ZipOutputStream zos = new ZipOutputStream(baos)) {\n+            final ZipEntry ze = new ZipEntry(ENTRY_NAME);\n+            zos.putNextEntry(ze);\n+            zos.write(ENTRY_CONTENT);\n+            zos.closeEntry();\n+        }\n+        return HexFormat.of().formatHex(baos.toByteArray());\n+    }\n+\n+    \/*\n+     * Calls ZipFile.getInputStream(ZipEntry) on a ZIP entry whose compressed size is\n+     * intentionally set to 0. The test then verifies that the call to getInputStream()\n+     * doesn't throw an unspecified exception.\n+     *\/\n+    @Test\n+    void testInvalidCompressedSize() throws Exception {\n+        final byte[] originalZIPContent = HexFormat.of().parseHex(ZIP_CONTENT_HEX.replace(\"\\n\", \"\"));\n+        final ByteBuffer zipContent = ByteBuffer.wrap(originalZIPContent).order(LITTLE_ENDIAN);\n+\n+        \/\/ overwrite the compressed size value in the entry's CEN to an invalid value of 0\n+        zipContent.position(COMP_SIZE_OFFSET);\n+        final int invalidCompressedSize = 0;\n+        zipContent.putInt(invalidCompressedSize);\n+        zipContent.rewind();\n+\n+        \/\/ write out the ZIP content so that it can be read through ZipFile\n+        final Path zip = Files.createTempFile(Path.of(\".\"), \"8358456-\", \".zip\");\n+        Files.write(zip, zipContent.array());\n+        System.out.println(\"created ZIP \" + zip + \" with an invalid compressed size for entry\");\n+\n+        try (final ZipFile zf = new ZipFile(zip.toFile())) {\n+            final ZipEntry entry = zf.getEntry(ENTRY_NAME);\n+            assertNotNull(entry, \"missing entry \" + ENTRY_NAME + \" in ZIP file \" + zip);\n+            \/\/ verify that we are indeed testing a ZIP file with an invalid\n+            \/\/ compressed size for the entry\n+            assertEquals(0, entry.getCompressedSize(), \"unexpected compressed size\");\n+            \/\/ merely open and close the InputStream to exercise the code which\n+            \/\/ would incorrectly raise an exception. we don't read the contents\n+            \/\/ of the stream because we have (intentionally) corrupted the metadata\n+            \/\/ of the ZIP and that will cause the reading to fail.\n+            try (final InputStream is = zf.getInputStream(entry)) {\n+                System.out.println(\"successfully opened input stream \" + is\n+                        + \" for entry \" + entry.getName());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/InvalidCompressedSizeTest.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"}]}