{"files":[{"patch":"@@ -836,0 +836,3 @@\n+                                                                            \\\n+  develop(bool, StressLoopPeeling, false,                                   \\\n+          \"Randomize peeling decision\")                                     \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -666,0 +666,1 @@\n+      NOT_PRODUCT(_peeling_rounds_of_node(comp_arena(), 8, 0, Pair<node_idx_t, uint>(0, 0)) COMMA)\n@@ -732,1 +733,2 @@\n-      StressIncrementalInlining || StressMacroExpansion || StressUnstableIfTraps || StressBailout) {\n+      StressIncrementalInlining || StressMacroExpansion || StressUnstableIfTraps || StressBailout ||\n+      StressLoopPeeling) {\n@@ -5291,0 +5293,11 @@\n+\n+uint& Compile::peeling_rounds_at_node(const Node* const head) {\n+  for(int i = 0; i < _peeling_rounds_of_node.length(); ++i) {\n+    auto& head_and_round_count = _peeling_rounds_of_node.at(i);\n+    if(head_and_round_count.first == head->_idx) {\n+      return head_and_round_count.second;\n+    }\n+  }\n+  _peeling_rounds_of_node.push(Pair<node_idx_t, uint>(head->_idx, 0));\n+  return _peeling_rounds_of_node.at(_peeling_rounds_of_node.length() - 1).second;\n+}\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"utilities\/pair.hpp\"\n@@ -387,0 +388,1 @@\n+  GrowableArray<Pair<node_idx_t, uint>> _peeling_rounds_of_node;\n@@ -685,0 +687,1 @@\n+  uint& peeling_rounds_at_node(const Node* head);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -494,1 +494,1 @@\n-  if (_body.size() > 255) {\n+  if (_body.size() > 255 && !StressLoopPeeling) {\n@@ -506,0 +506,1 @@\n+  \/\/ Peeling is not legal here, we don't even stress peel!\n@@ -513,0 +514,15 @@\n+#ifndef PRODUCT\n+  \/\/ It is now safe to peel or not.\n+  if (StressLoopPeeling) {\n+    static constexpr uint max_peeling_opportunities = 5;\n+    uint& rounds = phase->C->peeling_rounds_at_node(_head);\n+    if (rounds < max_peeling_opportunities) {\n+      rounds++;\n+      \/\/ In case of stress, let's just pick randomly...\n+      return phase->C->random() % 2 == 0 ? estimate : 0;\n+    }\n+    return 0;\n+  }\n+  \/\/ ...otherwise, let's apply our heuristic.\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"}]}