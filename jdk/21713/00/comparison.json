{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import java.math.BigDecimal;\n@@ -66,1 +67,1 @@\n-                return compareObjects(rowA.getText(index), rowB.getText(index));\n+                return factor * compareObjects(rowA.getText(index), rowB.getText(index));\n@@ -68,1 +69,1 @@\n-                return compareObjects(rowA.getValue(index), rowB.getValue(index));\n+                return factor * compareObjects(rowA.getValue(index), rowB.getValue(index));\n@@ -72,3 +73,3 @@\n-        private int compareObjects(Object a, Object b) {\n-            if (a instanceof Comparable c1 && b instanceof Comparable c2) {\n-                return factor * c1.compareTo(c2);\n+        private static int compareObjects(Object a, Object b) {\n+            if (a == b) {\n+                return 0;\n@@ -76,1 +77,49 @@\n-            return factor;\n+            if (a == null) {\n+                return -1;\n+            }\n+            if (b == null) {\n+                return 1;\n+            }\n+            \/\/ Comparison with the same class\n+            if (a.getClass() == b.getClass() && a instanceof Comparable c1) {\n+                return c1.compareTo((Comparable)b);\n+            }\n+\n+            if (a instanceof Number n1 && b instanceof Number n2) {\n+                if (isIntegralType(n1)) {\n+                    if (isIntegralType(n2)) {\n+                        return Long.compare(n1.longValue(), n2.longValue());\n+                    }\n+                    if (isFractionalType(n2)) {\n+                        return compare(n1.longValue(), n2.doubleValue());\n+                    }\n+                }\n+                if (isFractionalType(n1)) {\n+                    if (isFractionalType(n2)) {\n+                        return Double.compare(n1.doubleValue(), n2.doubleValue());\n+                    }\n+                    if (isIntegralType(n2)) {\n+                        return - compare(n2.longValue(), n1.doubleValue());\n+                    }\n+                }\n+            }\n+            \/\/ Use something that is stable if there is any other type of mix\n+            return Integer.compare(System.identityHashCode(a), System.identityHashCode(b));\n+        }\n+\n+        private static int compare(long integral, double fractional) {\n+            return BigDecimal.valueOf(integral).compareTo(BigDecimal.valueOf(fractional));\n+        }\n+\n+        private static boolean isIntegralType(Number value) {\n+            if (value instanceof Long || value instanceof Integer) {\n+                return true;\n+            }\n+            if (value instanceof Short || value instanceof Byte) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private static boolean isFractionalType(Number number) {\n+            return number instanceof Float || number instanceof Double;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/TableSorter.java","additions":55,"deletions":6,"binary":false,"changes":61,"status":"modified"}]}