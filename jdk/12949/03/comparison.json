{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Collections;\n@@ -42,0 +43,9 @@\n+    \/\/ cache the result of java.util.Collections.emptyIterator(), which\n+    \/\/ explicitly does not guarantee to return the same instance\n+    private static final Iterator<?> EMPTY = Collections.emptyIterator();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Iterator<T> emptyIterator() {\n+        return (Iterator<T>) EMPTY;\n+    }\n+\n@@ -50,2 +60,1 @@\n-        @SuppressWarnings(\"unchecked\")\n-        private Iterator<O> currentIterator = EMPTY;\n+        private Iterator<O> currentIterator = emptyIterator();\n@@ -58,0 +67,1 @@\n+        @Override\n@@ -59,2 +69,9 @@\n-            if (currentIterator != null && !currentIterator.hasNext()) {\n-                update();\n+            \/\/ if there's no element currently available, advance until there\n+            \/\/ is one or the input is exhausted\n+            for (;;) {\n+                if (currentIterator.hasNext())\n+                    return true;\n+                else if (inputs.hasNext())\n+                    currentIterator = converter.apply(inputs.next());\n+                else\n+                    return false;\n@@ -62,1 +79,0 @@\n-            return currentIterator != null;\n@@ -65,0 +81,1 @@\n+        @Override\n@@ -66,12 +83,4 @@\n-            if (currentIterator == EMPTY && !hasNext()) {\n-                throw new NoSuchElementException();\n-            }\n-            return currentIterator.next();\n-        }\n-\n-        public void remove() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        private void update() {\n-            while (inputs.hasNext()) {\n+            \/\/ next() cannot assume hasNext() was called immediately before:\n+            \/\/ next() must itself be able to find the next available element\n+            \/\/ if there is one\n+            while (!currentIterator.hasNext() && inputs.hasNext()) {\n@@ -79,1 +88,0 @@\n-                if (currentIterator.hasNext()) return;\n@@ -81,1 +89,1 @@\n-            currentIterator = null;\n+            return currentIterator.next();\n@@ -85,12 +93,1 @@\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final Iterator EMPTY = new Iterator() {\n-        public boolean hasNext() {\n-            return false;\n-        }\n-\n-        @Override\n-        public Object next() {\n-            return null;\n-        }\n-    };\n-\n+    \/\/ input.next() is assumed to never return null\n@@ -98,1 +95,1 @@\n-        return new Iterator<E>() {\n+        return new Iterator<>() {\n@@ -117,0 +114,3 @@\n+                if (current == null) {\n+                    throw new NoSuchElementException();\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Iterators.java","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -441,17 +441,0 @@\n-    private static final Iterator<?> EMPTYITERATOR = new Iterator<Object>() {\n-            public boolean hasNext() {\n-                return false;\n-            }\n-            public Object next() {\n-                throw new java.util.NoSuchElementException();\n-            }\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-        };\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <A> Iterator<A> emptyIterator() {\n-        return (Iterator<A>)EMPTYITERATOR;\n-    }\n-\n@@ -461,1 +444,1 @@\n-            return emptyIterator();\n+            return Iterators.emptyIterator();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/List.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8303882\n+ * @summary Verify that Iterators method work as expected\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n+ * @run junit IteratorsTest\n+ *\/\n+\n+import com.sun.tools.javac.util.Iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+import org.junit.jupiter.api.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+\n+public class IteratorsTest {\n+\n+    @Test\n+    public void consistentNext() {\n+        Iterator<?> emptyCompoundIterator = Iterators.createCompoundIterator(List.of(), Function.identity());\n+        Assertions.assertThrows(NoSuchElementException.class, emptyCompoundIterator::next);\n+        Assertions.assertThrows(NoSuchElementException.class, emptyCompoundIterator::next);\n+    }\n+\n+    \/\/ different ways of obtaining an empty iterator are used to make sure\n+    \/\/ the compound iterator doesn't depend on (checking) the identity of\n+    \/\/ any one of them\n+    @Test\n+    public void intermediateEmptyIterators() {\n+        List<Iterator<String>> inputs = List.of(\n+                Collections.<String>emptyList().iterator(),\n+                Collections.emptyListIterator(),\n+                Collections.emptyIterator(),\n+                List.of(\"1\").iterator(),\n+                List.of(\"2\", \"3\").iterator(),\n+                List.<String>of().iterator(),\n+                Collections.<String>emptySet().iterator(),\n+                List.of(\"4\", \"5\").iterator(),\n+                com.sun.tools.javac.util.List.<String>nil().iterator());\n+        Iterator<String> emptyCompoundIterator = Iterators.createCompoundIterator(inputs, Function.identity());\n+        var actual = new ArrayList<String>();\n+        emptyCompoundIterator.forEachRemaining(actual::add);\n+        assertEquals(List.of(\"1\", \"2\", \"3\", \"4\", \"5\"), actual);\n+    }\n+\n+    @Test\n+    public void recursiveEmpty() {\n+        Iterable<Iterator<Object>> inner = () -> Iterators.createCompoundIterator(List.of(), i -> Collections.emptyIterator());\n+        Iterator<Object> outer = Iterators.createCompoundIterator(inner, Function.identity());\n+        assertFalse(outer.hasNext());\n+    }\n+\n+    @Test\n+    public void compoundIterator() {\n+        TestConverter<String> c = new TestConverter<>(it -> it);\n+        TestIterator<String> test1 = new TestIterator<>(List.of(\"1\").iterator());\n+        TestIterator<String> test2 = new TestIterator<>(List.of(\"2\").iterator());\n+        Iterator<String> compound = Iterators.createCompoundIterator(List.of(test1, test2), c);\n+\n+        \/\/nothing should be called before the hasNext or next is called:\n+        assertAndResetMaxCalls(c, 0);\n+        assertAndResetMaxCalls(test1, 0, 0);\n+        assertAndResetMaxCalls(test2, 0, 0);\n+\n+        \/\/when hasNext is called, should invoke the hasNext delegate once:\n+        Assertions.assertTrue(compound.hasNext());\n+\n+        assertAndResetMaxCalls(c, 1);\n+        assertAndResetMaxCalls(test1, 1, 0);\n+        assertAndResetMaxCalls(test2, 0, 0);\n+\n+        Assertions.assertTrue(compound.hasNext());\n+\n+        assertAndResetMaxCalls(c, 0);\n+        assertAndResetMaxCalls(test1, 1, 0);\n+        assertAndResetMaxCalls(test2, 0, 0);\n+\n+        \/\/next may invoke hasNext once:\n+        Assertions.assertEquals(\"1\", compound.next());\n+\n+        assertAndResetMaxCalls(c, 0);\n+        assertAndResetMaxCalls(test1, 1, 1);\n+        assertAndResetMaxCalls(test2, 0, 0);\n+\n+        Assertions.assertTrue(compound.hasNext());\n+\n+        assertAndResetMaxCalls(c, 1);\n+        assertAndResetMaxCalls(test1, 1, 0);\n+        assertAndResetMaxCalls(test2, 1, 0);\n+\n+        Assertions.assertTrue(compound.hasNext());\n+\n+        assertAndResetMaxCalls(c, 0);\n+        assertAndResetMaxCalls(test1, 0, 0);\n+        assertAndResetMaxCalls(test2, 1, 0);\n+\n+        Assertions.assertEquals(\"2\", compound.next());\n+\n+        assertAndResetMaxCalls(c, 0);\n+        assertAndResetMaxCalls(test1, 0, 0);\n+        assertAndResetMaxCalls(test2, 1, 1);\n+\n+        Assertions.assertFalse(compound.hasNext());\n+\n+        assertAndResetMaxCalls(c, 0);\n+        assertAndResetMaxCalls(test1, 0, 0);\n+        assertAndResetMaxCalls(test2, 1, 0);\n+    }\n+\n+    private void assertAndResetMaxCalls(TestIterator<?> test, int maxExpectedHasNextCalls, int maxExpectedNextCalls) {\n+        if (test.hasNextCalls > maxExpectedHasNextCalls) {\n+            Assertions.fail(\"too many hasNext invocations: \" + test.hasNextCalls +\n+                            \", expected: \" + maxExpectedHasNextCalls);\n+        }\n+        test.hasNextCalls = 0;\n+        if (test.nextCalls > maxExpectedNextCalls) {\n+            Assertions.fail(\"too many next invocations: \" + test.nextCalls +\n+                            \", expected: \" + maxExpectedNextCalls);\n+        }\n+        test.nextCalls = 0;\n+    }\n+\n+    private void assertAndResetMaxCalls(TestConverter<?> test, int maxExpectedApplyCalls) {\n+        if (test.applyCalls > maxExpectedApplyCalls) {\n+            Assertions.fail(\"too many apply invocations: \" + test.applyCalls +\n+                            \", expected: \" + maxExpectedApplyCalls);\n+        }\n+        test.applyCalls = 0;\n+    }\n+\n+    static class TestIterator<T> implements Iterator<T> {\n+        int hasNextCalls;\n+        int nextCalls;\n+        final Iterator<T> delegate;\n+\n+        public TestIterator(Iterator<T> delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            hasNextCalls++;\n+            return delegate.hasNext();\n+        }\n+\n+        @Override\n+        public T next() {\n+            nextCalls++;\n+            return delegate.next();\n+        }\n+    }\n+\n+    static class TestConverter<T> implements Function<TestIterator<T>, Iterator<T>> {\n+        int applyCalls;\n+        final Function<TestIterator<T>, Iterator<T>> delegate;\n+\n+        public TestConverter(Function<TestIterator<T>, Iterator<T>> delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public Iterator<T> apply(TestIterator<T> t) {\n+            applyCalls++;\n+            return delegate.apply(t);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/util\/IteratorsTest.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"}]}