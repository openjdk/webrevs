{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -850,5 +850,39 @@\n-  \/\/ Check for \"(x>>c0)<<c0\" which just masks off low bits\n-  if( (add1_op == Op_RShiftI || add1_op == Op_URShiftI ) &&\n-      add1->in(2) == in(2) )\n-    \/\/ Convert to \"(x & -(1<<c0))\"\n-    return new AndINode(add1->in(1),phase->intcon( -(1<<con)));\n+  \/\/ Check for \"(x >> C1) << C2\"\n+  if (add1_op == Op_RShiftI || add1_op == Op_URShiftI) {\n+    \/\/ Special case C1 == C2, which just masks off low bits\n+    if (add1->in(2) == in(2)) {\n+      \/\/ Convert to \"(x & -(1 << C2))\"\n+      return new AndINode(add1->in(1), phase->intcon(-(1 << con)));\n+    } else {\n+      int add1Con = 0;\n+      const_shift_count(phase, add1, &add1Con);\n+\n+      \/\/ Wait until the right shift has been sharpened to the correct count\n+      if (add1Con > 0 && add1Con < BitsPerJavaInteger) {\n+        \/\/ As loop parsing can produce LShiftI nodes, we should wait until the graph is fully formed\n+        \/\/ to apply optimizations, otherwise we can inadvertently stop vectorization opportunities.\n+        if (phase->is_IterGVN()) {\n+          if (con > add1Con) {\n+            \/\/ Creates \"(x << (C2 - C1)) & -(1 << C2)\"\n+            Node* lshift = phase->transform(new LShiftINode(add1->in(1), phase->intcon(con - add1Con)));\n+            return new AndINode(lshift, phase->intcon(-(1 << con)));\n+          } else {\n+            assert(con < add1Con, \"must be (%d < %d)\", con, add1Con);\n+            \/\/ Creates \"(x >> (C1 - C2)) & -(1 << C2)\"\n+\n+            \/\/ Handle logical and arithmetic shifts\n+            Node* rshift;\n+            if (add1_op == Op_RShiftI) {\n+              rshift = phase->transform(new RShiftINode(add1->in(1), phase->intcon(add1Con - con)));\n+            } else {\n+              rshift = phase->transform(new URShiftINode(add1->in(1), phase->intcon(add1Con - con)));\n+            }\n+\n+            return new AndINode(rshift, phase->intcon(-(1 << con)));\n+          }\n+        } else {\n+          phase->record_for_igvn(this);\n+        }\n+      }\n+    }\n+  }\n@@ -856,2 +890,2 @@\n-  \/\/ Check for \"((x>>c0) & Y)<<c0\" which just masks off more low bits\n-  if( add1_op == Op_AndI ) {\n+  \/\/ Check for \"((x >> C1) & Y) << C2\"\n+  if (add1_op == Op_AndI) {\n@@ -860,5 +894,24 @@\n-    if( (add2_op == Op_RShiftI || add2_op == Op_URShiftI ) &&\n-        add2->in(2) == in(2) ) {\n-      \/\/ Convert to \"(x & (Y<<c0))\"\n-      Node *y_sh = phase->transform( new LShiftINode( add1->in(2), in(2) ) );\n-      return new AndINode( add2->in(1), y_sh );\n+    if (add2_op == Op_RShiftI || add2_op == Op_URShiftI) {\n+      \/\/ Special case C1 == C2, which just masks off low bits\n+      if (add2->in(2) == in(2)) {\n+        \/\/ Convert to \"(x & (Y << C2))\"\n+        Node* y_sh = phase->transform(new LShiftINode(add1->in(2), phase->intcon(con)));\n+        return new AndINode(add2->in(1), y_sh);\n+      }\n+\n+      int add2Con = 0;\n+      const_shift_count(phase, add2, &add2Con);\n+      if (add2Con > 0 && add2Con < BitsPerJavaInteger) {\n+        if (phase->is_IterGVN()) {\n+          \/\/ Convert to \"((x >> C1) << C2) & (Y << C2)\"\n+\n+          \/\/ Make \"(x >> C1) << C2\", which will get folded away by the rule above\n+          Node* x_sh = phase->transform(new LShiftINode(add2, phase->intcon(con)));\n+          \/\/ Make \"Y << C2\", which will simplify when Y is a constant\n+          Node* y_sh = phase->transform(new LShiftINode(add1->in(2), phase->intcon(con)));\n+\n+          return new AndINode(x_sh, y_sh);\n+        } else {\n+          phase->record_for_igvn(this);\n+        }\n+      }\n@@ -973,5 +1026,39 @@\n-  \/\/ Check for \"(x>>c0)<<c0\" which just masks off low bits\n-  if( (add1_op == Op_RShiftL || add1_op == Op_URShiftL ) &&\n-      add1->in(2) == in(2) )\n-    \/\/ Convert to \"(x & -(1<<c0))\"\n-    return new AndLNode(add1->in(1),phase->longcon( -(CONST64(1)<<con)));\n+  \/\/ Check for \"(x >> C1) << C2\"\n+  if (add1_op == Op_RShiftL || add1_op == Op_URShiftL) {\n+    \/\/ Special case C1 == C2, which just masks off low bits\n+    if (add1->in(2) == in(2)) {\n+      \/\/ Convert to \"(x & -(1 << C2))\"\n+      return new AndLNode(add1->in(1), phase->longcon(-(CONST64(1) << con)));\n+    } else {\n+      int add1Con = 0;\n+      const_shift_count(phase, add1, &add1Con);\n+\n+      \/\/ Wait until the right shift has been sharpened to the correct count\n+      if (add1Con > 0 && add1Con < BitsPerJavaLong) {\n+        \/\/ As loop parsing can produce LShiftI nodes, we should wait until the graph is fully formed\n+        \/\/ to apply optimizations, otherwise we can inadvertently stop vectorization opportunities.\n+        if (phase->is_IterGVN()) {\n+          if (con > add1Con) {\n+            \/\/ Creates \"(x << (C2 - C1)) & -(1 << C2)\"\n+            Node* lshift = phase->transform(new LShiftLNode(add1->in(1), phase->intcon(con - add1Con)));\n+            return new AndLNode(lshift, phase->longcon(-(CONST64(1) << con)));\n+          } else {\n+            assert(con < add1Con, \"must be (%d < %d)\", con, add1Con);\n+            \/\/ Creates \"(x >> (C1 - C2)) & -(1 << C2)\"\n+\n+            \/\/ Handle logical and arithmetic shifts\n+            Node* rshift;\n+            if (add1_op == Op_RShiftL) {\n+              rshift = phase->transform(new RShiftLNode(add1->in(1), phase->intcon(add1Con - con)));\n+            } else {\n+              rshift = phase->transform(new URShiftLNode(add1->in(1), phase->intcon(add1Con - con)));\n+            }\n+\n+            return new AndLNode(rshift, phase->longcon(-(CONST64(1) << con)));\n+          }\n+        } else {\n+          phase->record_for_igvn(this);\n+        }\n+      }\n+    }\n+  }\n@@ -979,3 +1066,3 @@\n-  \/\/ Check for \"((x>>c0) & Y)<<c0\" which just masks off more low bits\n-  if( add1_op == Op_AndL ) {\n-    Node *add2 = add1->in(1);\n+  \/\/ Check for \"((x >> C1) & Y) << C2\"\n+  if (add1_op == Op_AndL) {\n+    Node* add2 = add1->in(1);\n@@ -983,5 +1070,24 @@\n-    if( (add2_op == Op_RShiftL || add2_op == Op_URShiftL ) &&\n-        add2->in(2) == in(2) ) {\n-      \/\/ Convert to \"(x & (Y<<c0))\"\n-      Node *y_sh = phase->transform( new LShiftLNode( add1->in(2), in(2) ) );\n-      return new AndLNode( add2->in(1), y_sh );\n+    if (add2_op == Op_RShiftL || add2_op == Op_URShiftL) {\n+      \/\/ Special case C1 == C2, which just masks off low bits\n+      if (add2->in(2) == in(2)) {\n+        \/\/ Convert to \"(x & (Y << C2))\"\n+        Node* y_sh = phase->transform(new LShiftLNode(add1->in(2), phase->intcon(con)));\n+        return new AndLNode(add2->in(1), y_sh);\n+      }\n+\n+      int add2Con = 0;\n+      const_shift_count(phase, add2, &add2Con);\n+      if (add2Con > 0 && add2Con < BitsPerJavaLong) {\n+        if (phase->is_IterGVN()) {\n+          \/\/ Convert to \"((x >> C1) << C2) & (Y << C2)\"\n+\n+          \/\/ Make \"(x >> C1) << C2\", which will get folded away by the rule above\n+          Node* x_sh = phase->transform(new LShiftLNode(add2, phase->intcon(con)));\n+          \/\/ Make \"Y << C2\", which will simplify when Y is a constant\n+          Node* y_sh = phase->transform(new LShiftLNode(add1->in(2), phase->intcon(con)));\n+\n+          return new AndLNode(x_sh, y_sh);\n+        } else {\n+          phase->record_for_igvn(this);\n+        }\n+      }\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":132,"deletions":26,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    @Run(test = { \"test1\", \"test2\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\" })\n@@ -43,0 +43,3 @@\n+        int b = RunInfo.getRandom().nextInt();\n+        int c = RunInfo.getRandom().nextInt();\n+        int d = RunInfo.getRandom().nextInt();\n@@ -49,0 +52,3 @@\n+        assertResult(b);\n+        assertResult(c);\n+        assertResult(d);\n@@ -57,0 +63,6 @@\n+        Asserts.assertEQ((a >> 4) << 8, test3(a));\n+        Asserts.assertEQ((a >>> 4) << 8, test4(a));\n+        Asserts.assertEQ((a >> 8) << 4, test5(a));\n+        Asserts.assertEQ((a >>> 8) << 4, test6(a));\n+        Asserts.assertEQ(((a >> 4) & 0xFF) << 8, test7(a));\n+        Asserts.assertEQ(((a >>> 4) & 0xFF) << 8, test8(a));\n@@ -74,0 +86,48 @@\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks (x >> 4) << 8 => (x << 4) & -16\n+    public int test3(int x) {\n+        return (x >> 4) << 8;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.URSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks (x >>> 4) << 8 => (x << 4) & -16\n+    public int test4(int x) {\n+        return (x >>> 4) << 8;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.RSHIFT, \"1\" })\n+    \/\/ Checks (x >> 8) << 4 => (x >> 4) & -16\n+    public int test5(int x) {\n+        return (x >> 8) << 4;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.URSHIFT, \"1\" })\n+    \/\/ Checks (x >>> 8) << 4 => (x >>> 4) & -16\n+    public int test6(int x) {\n+        return (x >>> 8) << 4;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks (x >> 4) << 8 => (x << 4) & 0xFF00\n+    public int test7(int x) {\n+        return ((x >> 4) & 0xFF) << 8;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.URSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks (x >> 4) << 8 => (x << 4) & 0xFF00\n+    public int test8(int x) {\n+        return ((x >>> 4) & 0xFF) << 8;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftINodeIdealizationTests.java","additions":62,"deletions":2,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of LShiftLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.LShiftLNodeIdealizationTests\n+ *\/\n+public class LShiftLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = { \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\" })\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+        long c = RunInfo.getRandom().nextLong();\n+        long d = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0);\n+        assertResult(a);\n+        assertResult(b);\n+        assertResult(c);\n+        assertResult(d);\n+        assertResult(min);\n+        assertResult(max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a) {\n+        Asserts.assertEQ((a >> 4L) << 8L, test3(a));\n+        Asserts.assertEQ((a >>> 4L) << 8L, test4(a));\n+        Asserts.assertEQ((a >> 8L) << 4L, test5(a));\n+        Asserts.assertEQ((a >>> 8L) << 4L, test6(a));\n+        Asserts.assertEQ(((a >> 4L) & 0xFFL) << 8L, test7(a));\n+        Asserts.assertEQ(((a >>> 4L) & 0xFFL) << 8L, test8(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks (x >> 4) << 8 => (x << 4) & -16\n+    public long test3(long x) {\n+        return (x >> 4L) << 8L;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.URSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks (x >>> 4) << 8 => (x << 4) & -16\n+    public long test4(long x) {\n+        return (x >>> 4L) << 8L;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.RSHIFT, \"1\" })\n+    \/\/ Checks (x >> 8) << 4 => (x >> 4) & -16\n+    public long test5(long x) {\n+        return (x >> 8L) << 4L;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.URSHIFT, \"1\" })\n+    \/\/ Checks (x >>> 8) << 4 => (x >>> 4) & -16\n+    public long test6(long x) {\n+        return (x >>> 8L) << 4L;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks (x >> 4) << 8 => (x << 4) & 0xFF00\n+    public long test7(long x) {\n+        return ((x >> 4L) & 0xFFL) << 8L;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.URSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks (x >> 4) << 8 => (x << 4) & 0xFF00\n+    public long test8(long x) {\n+        return ((x >>> 4L) & 0xFFL) << 8L;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftLNodeIdealizationTests.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class LShiftNodeIdealize {\n+    private static final int SIZE = 3000;\n+\n+    @Benchmark\n+    public void testShiftInt(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume((i >> 4) << 8);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testShiftInt2(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume((i >> 8) << 4);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testShiftAndInt(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(((i >> 4) & 0x01) << 8);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testShiftLong(Blackhole blackhole) {\n+        for (long i = 0; i < SIZE; i++) {\n+            blackhole.consume((i >> 4L) << 8L);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testShiftLong2(Blackhole blackhole) {\n+        for (long i = 0; i < SIZE; i++) {\n+            blackhole.consume((i >> 8L) << 4L);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testShiftAndLong(Blackhole blackhole) {\n+        for (long i = 0; i < SIZE; i++) {\n+            blackhole.consume(((i >> 4L) & 0x01L) << 8L);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRgbaToAbgr(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 64; i++) {\n+            blackhole.consume(rgbaToAbgr(state.ints[i]));\n+        }\n+    }\n+\n+    private static int rgbaToAbgr(int i) {\n+        int r = i & 0xFF;\n+        int g = (i & 0xFF00) >> 8;\n+        int b = (i & 0xFF0000) >> 16;\n+        int a = (i & 0xFF000000) >> 24;\n+\n+        return (r << 24) | (g << 16) | (b << 8) | a;\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class BenchState {\n+        int[] ints;\n+\n+        public BenchState() {\n+\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            Random random = new Random(1000);\n+            ints = new int[64];\n+            for (int i = 0; i < 64; i++) {\n+                ints[i] = random.nextInt();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/LShiftNodeIdealize.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}