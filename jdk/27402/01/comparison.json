{"files":[{"patch":"@@ -51,0 +51,2 @@\n+  check_aot_annotations(ik);\n+\n@@ -52,0 +54,5 @@\n+    if (ik->has_aot_safe_initializer()) {\n+      ResourceMark rm;\n+      log_info(aot, init)(\"Class %s is annotated with @AOTSafeClassInitializer but has not been initialized\",\n+                          ik->external_name());\n+    }\n@@ -248,0 +255,50 @@\n+template <typename FUNCTION>\n+void require_annotation_for_super_types(InstanceKlass* ik, const char* annotation, FUNCTION func) {\n+  if (log_is_enabled(Info, aot, init)) {\n+    ResourceMark rm;\n+    log_info(aot, init)(\"Found %s class %s\", annotation, ik->external_name());\n+  }\n+\n+  \/\/ Since ik has this annotation, we require that\n+  \/\/   - all super classes must have this annotation\n+  \/\/   - all super interfaces that are interface_needs_clinit_execution_as_super()\n+  \/\/     must have this annotation\n+  \/\/ This avoid the situation where in the production run, we run the <clinit>\n+  \/\/ of a supertype but not the <clinit> of ik\n+\n+  InstanceKlass* super = ik->java_super();\n+  if (super != nullptr && !func(super)) {\n+    ResourceMark rm;\n+    log_error(aot, init)(\"Missing %s in superclass %s for class %s\",\n+                         annotation, super->external_name(), ik->external_name());\n+    AOTMetaspace::unrecoverable_writing_error();\n+  }\n+\n+  int len = ik->local_interfaces()->length();\n+  for (int i = 0; i < len; i++) {\n+    InstanceKlass* intf = ik->local_interfaces()->at(i);\n+    if (intf->interface_needs_clinit_execution_as_super() && !func(intf)) {\n+      ResourceMark rm;\n+      log_error(aot, init)(\"Missing %s in superinterface %s for class %s\",\n+                           annotation, intf->external_name(), ik->external_name());\n+      AOTMetaspace::unrecoverable_writing_error();\n+    }\n+  }\n+}\n+\n+void AOTClassInitializer::check_aot_annotations(InstanceKlass* ik) {\n+  if (ik->has_aot_safe_initializer()) {\n+    require_annotation_for_super_types(ik, \"@AOTSafeClassInitializer\", [&] (const InstanceKlass* supertype) {\n+      return supertype->has_aot_safe_initializer();\n+    });\n+  } else {\n+    \/\/ @AOTRuntimeSetup only meaningful in @AOTSafeClassInitializer\n+    if (ik->is_runtime_setup_required()) {\n+      ResourceMark rm;\n+      log_error(aot, init)(\"@AOTRuntimeSetup meaningless in non-@AOTSafeClassInitializer class %s\",\n+                           ik->external_name());\n+    }\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+\n+  static void check_aot_annotations(InstanceKlass* ik);\n+\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -807,0 +807,17 @@\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    \/\/ - Load and link all classes used in the training run.\n+    \/\/ - Initialize @AOTSafeClassInitializer classes that were\n+    \/\/   initialized in the training run.\n+    \/\/ - Perform per-class optimization such as AOT-resolution of\n+    \/\/   constant pool entries that were resolved during the training run.\n+    FinalImageRecipes::apply_recipes(CHECK);\n+\n+    \/\/ Because the AOT assembly phase does not run the same exact code as in the\n+    \/\/ training run (e.g., we use different lambda form invoker classes;\n+    \/\/ generated lambda form classes are not recorded in FinalImageRecipes),\n+    \/\/ the recipes do not cover all classes that have been loaded so far. As\n+    \/\/ a result, we might have some unlinked classes at this point. Since we\n+    \/\/ require cached classes to be linked, all such classes will be linked\n+    \/\/ by the following step.\n+  }\n+\n@@ -820,4 +837,0 @@\n-\n-  if (CDSConfig::is_dumping_final_static_archive()) {\n-    FinalImageRecipes::apply_recipes(CHECK);\n-  }\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  GrowableArray<int> tmp_cp_flags;\n+  GrowableArray<int> tmp_flags;\n@@ -73,0 +73,4 @@\n+      if (ik->is_initialized()) {\n+        flags |= WAS_INITED;\n+      }\n+\n@@ -78,1 +82,1 @@\n-            flags |= HAS_CLASS;\n+            flags |= CP_RESOLVE_CLASS;\n@@ -91,1 +95,1 @@\n-              flags |= HAS_FIELD_AND_METHOD;\n+              flags |= CP_RESOLVE_FIELD_AND_METHOD;\n@@ -106,1 +110,1 @@\n-              flags |= HAS_FIELD_AND_METHOD;\n+              flags |= CP_RESOLVE_FIELD_AND_METHOD;\n@@ -118,1 +122,1 @@\n-              flags |= HAS_INDY;\n+              flags |= CP_RESOLVE_INDY;\n@@ -130,1 +134,1 @@\n-    tmp_cp_flags.append(flags);\n+    tmp_flags.append(flags);\n@@ -136,2 +140,2 @@\n-  _cp_flags = ArchiveUtils::archive_array(&tmp_cp_flags);\n-  ArchivePtrMarker::mark_pointer(&_cp_flags);\n+  _flags = ArchiveUtils::archive_array(&tmp_flags);\n+  ArchivePtrMarker::mark_pointer(&_flags);\n@@ -145,1 +149,1 @@\n-    int flags = _cp_flags->at(i);\n+    int flags = _flags->at(i);\n@@ -155,1 +159,1 @@\n-        if ((flags & HAS_CLASS) != 0) {\n+        if ((flags & CP_RESOLVE_CLASS) != 0) {\n@@ -158,1 +162,1 @@\n-        if ((flags & HAS_FIELD_AND_METHOD) != 0) {\n+        if ((flags & CP_RESOLVE_FIELD_AND_METHOD) != 0) {\n@@ -161,1 +165,1 @@\n-        if ((flags & HAS_INDY) != 0) {\n+        if ((flags & CP_RESOLVE_INDY) != 0) {\n@@ -174,0 +178,1 @@\n+    int flags = _flags->at(i);\n@@ -191,0 +196,5 @@\n+\n+        if (ik->has_aot_safe_initializer() && (flags & WAS_INITED) != 0) {\n+          assert(ik->class_loader() == nullptr, \"supported only for boot classes for now\");\n+          ik->initialize(CHECK);\n+        }\n","filename":"src\/hotspot\/share\/cds\/finalImageRecipes.cpp","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -45,3 +45,4 @@\n-  static constexpr int HAS_CLASS            = 0x1;\n-  static constexpr int HAS_FIELD_AND_METHOD = 0x2;\n-  static constexpr int HAS_INDY             = 0x4;\n+  static constexpr int CP_RESOLVE_CLASS            = 0x1 << 0; \/\/ CP has preresolved class entries\n+  static constexpr int CP_RESOLVE_FIELD_AND_METHOD = 0x1 << 1; \/\/ CP has preresolved field\/method entries\n+  static constexpr int CP_RESOLVE_INDY             = 0x1 << 2; \/\/ CP has preresolved indy entries\n+  static constexpr int WAS_INITED                  = 0x1 << 3; \/\/ Class was initialized during training run\n@@ -53,2 +54,2 @@\n-  \/\/ For each klass k _all_klasses->at(i), _cp_recipes->at(i) lists all the {klass,field,method,indy}\n-  \/\/ cp indices that were resolved for k during the training run.\n+  \/\/ For each klass k _all_klasses->at(i): _cp_recipes->at(i) lists all the {klass,field,method,indy}\n+  \/\/ cp indices that were resolved for k during the training run; _flags->at(i) has extra info about k.\n@@ -56,1 +57,1 @@\n-  Array<int>* _cp_flags;\n+  Array<int>* _flags;\n@@ -58,1 +59,1 @@\n-  FinalImageRecipes() : _all_klasses(nullptr), _cp_recipes(nullptr), _cp_flags(nullptr) {}\n+  FinalImageRecipes() : _all_klasses(nullptr), _cp_recipes(nullptr), _flags(nullptr) {}\n","filename":"src\/hotspot\/share\/cds\/finalImageRecipes.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -5166,40 +5166,0 @@\n-  \/\/ AOT-related checks.\n-  \/\/ Note we cannot check this in general due to instrumentation or module patching\n-  if (CDSConfig::is_initing_classes_at_dump_time()) {\n-    \/\/ Check the aot initialization safe status.\n-    \/\/ @AOTSafeClassInitializer is used only to support ahead-of-time initialization of classes\n-    \/\/ in the AOT assembly phase.\n-    if (ik->has_aot_safe_initializer()) {\n-      \/\/ If a type is included in the tables inside can_archive_initialized_mirror(), we require that\n-      \/\/   - all super classes must be included\n-      \/\/   - all super interfaces that have <clinit> must be included.\n-      \/\/ This ensures that in the production run, we don't run the <clinit> of a supertype but skips\n-      \/\/ ik's <clinit>.\n-      if (_super_klass != nullptr) {\n-        guarantee_property(_super_klass->has_aot_safe_initializer(),\n-                           \"Missing @AOTSafeClassInitializer in superclass %s for class %s\",\n-                           _super_klass->external_name(),\n-                           CHECK);\n-      }\n-\n-      int len = _local_interfaces->length();\n-      for (int i = 0; i < len; i++) {\n-        InstanceKlass* intf = _local_interfaces->at(i);\n-        guarantee_property(intf->class_initializer() == nullptr || intf->has_aot_safe_initializer(),\n-                           \"Missing @AOTSafeClassInitializer in superinterface %s for class %s\",\n-                           intf->external_name(),\n-                           CHECK);\n-      }\n-\n-      if (log_is_enabled(Info, aot, init)) {\n-        ResourceMark rm;\n-        log_info(aot, init)(\"Found @AOTSafeClassInitializer class %s\", ik->external_name());\n-      }\n-    } else {\n-      \/\/ @AOTRuntimeSetup only meaningful in @AOTClassInitializer\n-      guarantee_property(!ik->is_runtime_setup_required(),\n-                         \"@AOTRuntimeSetup meaningless in non-@AOTSafeClassInitializer class %s\",\n-                         CHECK);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -35,0 +36,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/MathUtils.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,19 +33,28 @@\n-\/\/\/ Indicates that the static initializer of this class or interface\n-\/\/\/ (its `<clinit>` method) is allowed to be _AOT-initialized_,\n-\/\/\/ because its author considers it safe to execute during the AOT\n-\/\/\/ assembly phase.\n-\/\/\/\n-\/\/\/ This annotation directs the VM to expect that normal execution of Java code\n-\/\/\/ during the assembly phase could trigger initialization of this class,\n-\/\/\/ and if that happens, to store the resulting static field values in the\n-\/\/\/ AOT cache.  (These fields happen to be allocated in the `Class` mirror.)\n-\/\/\/\n-\/\/\/ During the production run, the static initializer (`<clinit>`) of\n-\/\/\/ this class or interface will not be executed, if it was already\n-\/\/\/ executed during the assembling of the AOT being used to start the\n-\/\/\/ production run.  In that case the resulting static field states\n-\/\/\/ (within the `Class` mirror) were already stored in the AOT cache.\n-\/\/\/\n-\/\/\/ Currently, this annotation is used mainly for supporting AOT\n-\/\/\/ linking of APIs, including bootstrap methods, in the\n-\/\/\/ `java.lang.invoke` package.\n+\/\/\/ Indicates that the annotated class or interface is allowed to be _AOT-initialized_,\n+\/\/\/ because its author considers it safe to execute the static initializer of\n+\/\/\/ the class or interface during the AOT assembly phase.\n+\/\/\/\n+\/\/\/ For a class or interface _X_ annotated with `@AOTSafeClassInitializer`, it will\n+\/\/\/ be initialized in the AOT assembly phase under two circumstances:\n+\/\/\/\n+\/\/\/ 1. If _X_ was initialized during the AOT training run, the JVM will proactively\n+\/\/\/    initialize _X_ in the assembly phase.\n+\/\/\/ 2. If _X_ was not initialized during the AOT training run, the initialization of\n+\/\/\/    _X_ can still be triggered by normal execution of Java code in the assembly\n+\/\/\/    phase. At present this is usually the result of performing AOT optimizations for\n+\/\/\/    the `java.lang.invoke` package but it may include other cases as well.\n+\/\/\/\n+\/\/\/ If _X_ is initialized during the AOT assembly phase, the VM will store\n+\/\/\/ the values of the static fields of _X_ in the AOT cache. Consequently,\n+\/\/\/ during the production run that uses this AOT cache, the static initializer\n+\/\/\/ (`<clinit>`) of _X_ will not be executed. _X_ will appear to be in the\n+\/\/\/ \"initialized\" state and all the cached values of the static field of _X_\n+\/\/\/ will be available immediately upon the start of the prodcution run.\n+\/\/\/\n+\/\/\/ Currently, this annotation is used mainly for two purposes:\n+\/\/\/\n+\/\/\/ - To AOT-initialize complex static fields whose values are always the same\n+\/\/\/   across JVM lifetimes. One example is the tables of constant values\n+\/\/\/   in the `jdk.internal.math.MathUtils` class.\n+\/\/\/ - To support AOT linking of APIs, including bootstrap methods, in the\n+\/\/\/   `java.lang.invoke` package.\n@@ -65,0 +74,2 @@\n+\/\/\/ 5. In addition, any class\/interface annotated with `@AOTSafeClassInitializer`\n+\/\/\/    that was initialized during the training run is proactively initialized.\n@@ -115,3 +126,1 @@\n-\/\/\/ test.  As noted above, all supertypes of _X_ must also have the\n-\/\/\/ `@AOTSafeClassInitializer` annotation, and must also be safe for AOT\n-\/\/\/ initialization.\n+\/\/\/ test.\n@@ -124,6 +133,5 @@\n-\/\/\/ In the assembly phase, `classFileParser.cpp` performs checks on the annotated\n-\/\/\/ classes, to ensure all supertypes of this class that must be initialized when\n-\/\/\/ this class is initialized have the `@AOTSafeClassInitializer` annotation.\n-\/\/\/ Otherwise, a [ClassFormatError] will be thrown. (This assembly phase restriction\n-\/\/\/ allows module patching and instrumentation to work on annotated classes when\n-\/\/\/ AOT is not enabled)\n+\/\/\/ Before adding this annotation to a class _X_, the author must determine\n+\/\/\/ that it's safe to execute the static initializer of _X_ during the AOT\n+\/\/\/ assembly phase. In addition, all supertypes of _X_ must also have this\n+\/\/\/ annotation. If a supertype of _X_ is found to be missing this annotation,\n+\/\/\/ the AOT assembly phase will fail.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/AOTSafeClassInitializer.java","additions":36,"deletions":28,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -5,0 +5,4 @@\n+# The following tests use very small -Xmx and will not be able to\n+# use the AOT cache generated by \"make test JTREG=AOT_JDK=onestep ...\"\n+gc\/arguments\/TestG1HeapSizeFlags.java                 0000000 generic-all\n+gc\/arguments\/TestParallelHeapSizeFlags.java           0000000 generic-all\n@@ -6,0 +10,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList-AotJdk.txt","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -415,0 +415,1 @@\n+ -runtime\/cds\/appcds\/aotAnnotations \\\n@@ -515,0 +516,1 @@\n+ -runtime\/cds\/appcds\/aotAnnotations \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/*\n+ * @test\n+ * @summary Tests the effect of jdk.internal.vm.annotation.AOTXXX annotations\n+ *          in the core Java library.\n+ * @bug 8317269\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build AOTAnnotationsTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar AOTAnnotationsTestApp\n+ * @run driver AOTAnnotationsTest\n+ *\/\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AOTAnnotationsTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = AOTAnnotationsTestApp.class.getName();\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester tester = new Tester();\n+        tester.run(new String[] {\"AOT\", \"--two-step-training\"} );\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            return new String[] {\n+                \"-Xlog:aot+class=debug\",\n+                \"-Xlog:aot+init\",\n+            };\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] { mainClass};\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) {\n+            if (runMode == RunMode.ASSEMBLY) {\n+                out.shouldMatch(\"jdk.internal.math.MathUtils .*inited\");\n+            }\n+        }\n+    }\n+}\n+\n+class AOTAnnotationsTestApp {\n+    public static void main(String args[]) {\n+        double d = 12.34567;\n+\n+        \/\/ Double.toString() uses jdk.internal.math.MathUtils.\n+        \/\/ Because MathUtils has @AOTSafeClassInitializer and was initialized during\n+        \/\/ the training run, it will be cached in aot-inited state.\n+        System.out.println(Double.toString(d));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotAnnotations\/AOTAnnotationsTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}