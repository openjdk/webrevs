{"files":[{"patch":"@@ -229,0 +229,4 @@\n+    if (CodeCache::is_deopt_pc(sender_pc, \/*strictly_compiled = *\/false, sender_blob)) {\n+      return false;\n+    }\n+\n@@ -231,1 +235,2 @@\n-      if (nm->is_deopt_entry(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n+      assert(!nm->is_deopt_pc(sender_pc), \"should have been rejected above\");\n+      if (nm->method()->is_method_handle_intrinsic()) {\n@@ -244,1 +249,3 @@\n-    \/\/ We should never be able to see anything here except an nmethod. If something in the\n+    \/\/ We should never be able to see anything here except an nmethod or deoptimization blob. It\n+    \/\/ should be the deoptimization blob in case the sender_pc is referring to one of the blob's\n+    \/\/ subentries, with the same outcome as for is_deopt_pc check above. If something in the\n@@ -281,1 +288,8 @@\n-  assert(_cb == CodeCache::find_blob(pc), \"unexpected pc\");\n+#ifdef ASSERT\n+  CodeBlob *code_blob_for_new_pc = CodeCache::find_blob(pc);\n+  if (_cb != code_blob_for_new_pc) {\n+    nmethod* nm = _cb->as_nmethod_or_null();\n+    assert(nm != nullptr && nm->is_deopt_pc(pc), \"unexpected pc\");\n+  }\n+#endif \/\/ ASSERT\n+\n@@ -302,2 +316,3 @@\n-  _pc = pc; \/\/ must be set before call to get_deopt_original_pc\n-  address original_pc = get_deopt_original_pc();\n+  _pc = pc; \/\/ must be set before call to get_deopt_original_pc_and_cb\n+  CodeBlob* out_cb = nullptr;\n+  address original_pc = get_deopt_original_pc_and_cb(out_cb);\n@@ -306,0 +321,1 @@\n+    assert(out_cb == _cb, \"unexpected code blob\");\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -119,1 +119,2 @@\n-  address original_pc = get_deopt_original_pc();\n+  CodeBlob* out_cb = nullptr;\n+  address original_pc = get_deopt_original_pc_and_cb(out_cb);\n@@ -122,0 +123,1 @@\n+    _cb = out_cb;\n@@ -126,5 +128,1 @@\n-    if (_cb == SharedRuntime::deopt_blob()) {\n-      _deopt_state = is_deoptimized;\n-    } else {\n-      _deopt_state = not_deoptimized;\n-    }\n+    _deopt_state = not_deoptimized;\n@@ -189,2 +187,0 @@\n-  _pc = pc;\n-  _cb = CodeCache::find_blob_fast(pc);\n@@ -192,1 +188,0 @@\n-  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(pc), p2i(sp), p2i(unextended_sp), p2i(fp));\n@@ -195,1 +190,2 @@\n-\n+  _pc = pc;\n+  _cb = CodeCache::find_blob_fast(pc);\n@@ -197,0 +193,1 @@\n+  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(pc), p2i(sp), p2i(unextended_sp), p2i(fp));\n@@ -224,9 +221,1 @@\n-\n-  address original_pc = get_deopt_original_pc();\n-  if (original_pc != nullptr) {\n-    _pc = original_pc;\n-    _deopt_state = is_deoptimized;\n-  } else {\n-    _deopt_state = not_deoptimized;\n-  }\n-  _sp_is_trusted = false;\n+  setup(_pc);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":8,"deletions":19,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -2092,1 +2093,5 @@\n-  CodeBuffer buffer(name, 2048+pad, 1024);\n+  constexpr int unpack_subentry_num = DeoptimizationBlob::UNPACK_SUBENTRY_COUNT;\n+  constexpr int instruction_size = NativeInstruction::instruction_size;\n+  constexpr int subentries_section_size = (unpack_subentry_num + 1) * instruction_size;\n+\n+  CodeBuffer buffer(name, 2048+pad+subentries_section_size, 1024);\n@@ -2134,0 +2139,16 @@\n+  int unpack_subentries_offset = __ pc() - start;\n+\n+  Label subentry_correction;\n+\n+  for (int subentry_index = 0; subentry_index < unpack_subentry_num; subentry_index++) {\n+    __ bl(subentry_correction);\n+  }\n+\n+  assert(__ pc() - start - unpack_subentries_offset == unpack_subentry_num * instruction_size,\n+         \"each subentry is one BL\");\n+\n+  __ bind(subentry_correction);\n+  __ sub(lr, lr, NativeInstruction::instruction_size);\n+\n+  int unpack_entry_offset = __ pc() - start;\n+\n@@ -2447,1 +2468,3 @@\n-  _deopt_blob = DeoptimizationBlob::create(&buffer, oop_maps, 0, exception_offset, reexecute_offset, frame_size_in_words);\n+  _deopt_blob = DeoptimizationBlob::create(&buffer, oop_maps,\n+                                           unpack_subentries_offset, instruction_size, unpack_entry_offset,\n+                                           exception_offset, reexecute_offset, frame_size_in_words);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -318,1 +318,1 @@\n-  assert(!is_compiled_frame() || !_cb->as_nmethod()->is_deopt_entry(_pc), \"must be\");\n+  assert(!is_compiled_frame() || !_cb->as_nmethod()->is_deopt_pc(_pc), \"must be\");\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-      if (nm->is_deopt_entry(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n+      if (nm->is_deopt_pc(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -283,1 +283,1 @@\n-  assert(!is_compiled_frame() || !_cb->as_nmethod()->is_deopt_entry(_pc), \"must be\");\n+  assert(!is_compiled_frame() || !_cb->as_nmethod()->is_deopt_pc(_pc), \"must be\");\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-        if (nm->is_deopt_entry(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n+        if (nm->is_deopt_pc(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n@@ -297,1 +297,1 @@\n-  assert(!is_compiled_frame() || !_cb->as_nmethod()->is_deopt_entry(_pc), \"must be\");\n+  assert(!is_compiled_frame() || !_cb->as_nmethod()->is_deopt_pc(_pc), \"must be\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-void Compilation::emit_code_epilog(LIR_Assembler* assembler) {\n+void Compilation::emit_code_epilog(LIR_Assembler* assembler, int frame_size_in_bytes) {\n@@ -309,3 +309,7 @@\n-  \/\/ Generate code for deopt handler.\n-  code_offsets->set_value(CodeOffsets::Deopt, assembler->emit_deopt_handler());\n-  CHECK_BAILOUT();\n+  assert (frame_size_in_bytes == align_up(frame_size_in_bytes, 1u << LogBytesPerWord), \"required to be aligned to words\");\n+  if (AlwaysEmitDeoptStubCode\n+      || (frame_size_in_bytes >> LogBytesPerWord) >= DeoptimizationBlob::UNPACK_SUBENTRY_COUNT) {\n+    \/\/ Generate code for deopt handler.\n+    code_offsets->set_value(CodeOffsets::Deopt, assembler->emit_deopt_handler());\n+    CHECK_BAILOUT();\n+  }\n@@ -337,0 +341,2 @@\n+  int frame_size_in_bytes = in_bytes(frame_map()->framesize_in_bytes());\n+\n@@ -351,1 +357,1 @@\n-  emit_code_epilog(&lir_asm);\n+  emit_code_epilog(&lir_asm, frame_size_in_bytes);\n@@ -363,1 +369,1 @@\n-  return frame_map()->framesize();\n+  return frame_size_in_bytes;\n@@ -413,4 +419,3 @@\n-void Compilation::install_code(int frame_size) {\n-  \/\/ frame_size is in 32-bit words so adjust it intptr_t words\n-  assert(frame_size == frame_map()->framesize(), \"must match\");\n-  assert(in_bytes(frame_map()->framesize_in_bytes()) % sizeof(intptr_t) == 0, \"must be at least pointer aligned\");\n+void Compilation::install_code(ByteSize frame_size) {\n+  assert(frame_size == frame_map()->framesize_in_bytes(), \"must match\");\n+  assert(in_bytes(frame_size) % sizeof(intptr_t) == 0, \"must be at least pointer aligned\");\n@@ -423,1 +428,1 @@\n-    in_bytes(frame_map()->framesize_in_bytes()) \/ sizeof(intptr_t),\n+    in_bytes(frame_size) \/ sizeof(intptr_t),\n@@ -471,1 +476,1 @@\n-  int frame_size = compile_java_method();\n+  ByteSize frame_size = in_ByteSize(compile_java_method());\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  void emit_code_epilog(LIR_Assembler* assembler);\n+  void emit_code_epilog(LIR_Assembler* assembler, int frame_size_in_bytes);\n@@ -108,1 +108,1 @@\n-  void install_code(int frame_size);\n+  void install_code(ByteSize frame_size);\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"code\/codeCache.inline.hpp\"\n@@ -556,2 +557,0 @@\n-  nm = CodeCache::find_nmethod(pc);\n-  assert(nm != nullptr, \"this is not an nmethod\");\n@@ -559,1 +558,2 @@\n-  if (nm->is_deopt_pc(pc)) {\n+  CodeBlob* cb = CodeCache::find_blob(pc);\n+  if (CodeCache::is_deopt_pc(pc, \/*strictly_compiled = *\/true, cb)) {\n@@ -567,0 +567,4 @@\n+\n+    nm = exception_frame.cb()->as_nmethod();\n+    assert(nm->is_deopt_pc(pc), \"unexpected nmethod\");\n+\n@@ -568,0 +572,2 @@\n+  } else {\n+    nm = cb->as_nmethod();\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1059,1 +1059,7 @@\n-    assert(offsets->value(CodeOffsets::Deopt) != -1, \"must have deopt entry\");\n+    if (AlwaysEmitDeoptStubCode\n+        || frame_words >= DeoptimizationBlob::UNPACK_SUBENTRY_COUNT\n+        || compiler->type() == compiler_jvmci) {\n+      assert(offsets->value(CodeOffsets::Deopt) != -1, \"must have deopt entry\");\n+    } else {\n+      assert(offsets->value(CodeOffsets::Deopt) == -1, \"must not have a deopt entry\");\n+    }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -620,1 +620,3 @@\n-  int         unpack_offset,\n+  int         unpack_subentries_offset,\n+  int         unpack_subentry_size,\n+  int         unpack_generic_offset,\n@@ -628,3 +630,5 @@\n-  _unpack_offset           = unpack_offset;\n-  _unpack_with_exception   = unpack_with_exception_offset;\n-  _unpack_with_reexecution = unpack_with_reexecution_offset;\n+  _unpack_subentries_offset = unpack_subentries_offset;\n+  _unpack_subentry_size     = unpack_subentry_size;\n+  _unpack_offset            = unpack_generic_offset;\n+  _unpack_with_exception    = unpack_with_exception_offset;\n+  _unpack_with_reexecution  = unpack_with_reexecution_offset;\n@@ -640,4 +644,18 @@\n-  int        unpack_offset,\n-  int        unpack_with_exception_offset,\n-  int        unpack_with_reexecution_offset,\n-  int        frame_size)\n+  int         unpack_generic_offset,\n+  int         unpack_with_exception_offset,\n+  int         unpack_with_reexecution_offset,\n+  int         frame_size)\n+{\n+  return create(cb, oop_maps, -1, 0, unpack_generic_offset, unpack_with_exception_offset,\n+                unpack_with_reexecution_offset, frame_size);\n+}\n+\n+DeoptimizationBlob* DeoptimizationBlob::create(\n+  CodeBuffer* cb,\n+  OopMapSet*  oop_maps,\n+  int         unpack_subentries_offset,\n+  int         unpack_subentry_size,\n+  int         unpack_generic_offset,\n+  int         unpack_with_exception_offset,\n+  int         unpack_with_reexecution_offset,\n+  int         frame_size)\n@@ -653,1 +671,3 @@\n-                                         unpack_offset,\n+                                         unpack_subentries_offset,\n+                                         unpack_subentry_size,\n+                                         unpack_generic_offset,\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -553,0 +554,2 @@\n+  int _unpack_subentries_offset;\n+  int _unpack_subentry_size;\n@@ -570,0 +573,2 @@\n+    int         unpack_subentries_offset,\n+    int         unpack_subentry_size,\n@@ -578,0 +583,1 @@\n+  static constexpr int UNPACK_SUBENTRY_COUNT = AARCH64_ONLY(1024) NOT_AARCH64(0);\n@@ -582,1 +588,11 @@\n-    int         unpack_offset,\n+    int         unpack_generic_offset,\n+    int         unpack_with_exception_offset,\n+    int         unpack_with_reexecution_offset,\n+    int         frame_size\n+  );\n+  static DeoptimizationBlob* create(\n+    CodeBuffer* cb,\n+    OopMapSet*  oop_maps,\n+    int         unpack_subentries_offset,\n+    int         unpack_subentry_size,\n+    int         unpack_generic_offset,\n@@ -588,1 +604,1 @@\n-  address unpack() const                         { return code_begin() + _unpack_offset;           }\n+  address unpack() const                         { return code_begin() + _unpack_offset;   }\n@@ -592,0 +608,37 @@\n+  address unpack_subentry(int subentry_index) const {\n+    assert(_unpack_subentries_offset >= 0 && _unpack_subentry_size > 0, \"Unsupported mode\");\n+    return code_begin() + _unpack_subentries_offset + subentry_index * _unpack_subentry_size;\n+  }\n+  bool get_unpack_subentry(address pc, int& subentry_index) const {\n+    subentry_index = -1;\n+    if (UNPACK_SUBENTRY_COUNT == 0) {\n+      return false;\n+    }\n+\n+    address unpack_subentries_begin = unpack_subentry(0);\n+    address unpack_subentry_end = unpack_subentry(UNPACK_SUBENTRY_COUNT);\n+    if (pc >= unpack_subentries_begin && pc < unpack_subentry_end) {\n+      uintptr_t offset = pc - unpack_subentries_begin;\n+      assert((offset % _unpack_subentry_size) == 0, \"unaligned PC\");\n+      subentry_index = offset \/ _unpack_subentry_size;\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  bool get_original_pc(intptr_t* unextended_sp, address pc,\n+                       address& out_original_pc) const {\n+    out_original_pc = nullptr;\n+\n+    int subentry_index = -1;\n+    if (!get_unpack_subentry(pc, subentry_index)) {\n+      return false;\n+    }\n+\n+    int orig_pc_offset = (subentry_index << LogBytesPerWord);\n+    address original_pc_slot = (address)unextended_sp + orig_pc_offset;\n+    out_original_pc = *(address*)original_pc_slot;\n+    return true;\n+  }\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -170,0 +170,3 @@\n+  static bool is_deopt_pc(address pc, bool strictly_compiled, CodeBlob* input_cb); \/\/ Returns whether pc is a deoptimization handler entry point\n+  static address get_deopt_original_pc_and_cb(intptr_t* unextended_sp, address pc, CodeBlob* cb, CodeBlob*& out_cb); \/\/ Returns original PC and code blob\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -31,0 +32,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -62,0 +64,77 @@\n+inline bool CodeCache::is_deopt_pc(address pc, bool strictly_compiled,\n+                                   CodeBlob* input_cb) {\n+  const DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();\n+  int subentry_index = -1;\n+  if (deopt_blob->get_unpack_subentry(pc, subentry_index)) {\n+    return true;\n+  }\n+\n+  assert(input_cb == nullptr || input_cb == CodeCache::find_blob(pc),\n+         \"Inconsistent input_cb\");\n+  CodeBlob* cb = (input_cb != nullptr) ? input_cb : CodeCache::find_blob(pc);\n+  nmethod* nm = nullptr;\n+  if (cb != nullptr) {\n+    nm = cb->as_nmethod_or_null();\n+  }\n+\n+  if (nm != nullptr) {\n+    return nm->is_deopt_pc(pc);\n+  } else {\n+    assert(!strictly_compiled, \"this is not an nmethod\");\n+  }\n+\n+  return false;\n+}\n+\n+inline address CodeCache::get_deopt_original_pc_and_cb(intptr_t* unextended_sp,\n+                                                       address pc,\n+                                                       CodeBlob* input_cb,\n+                                                       CodeBlob*& out_cb) {\n+  const DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();\n+\n+  out_cb = nullptr;\n+\n+  address original_pc = nullptr;\n+  if (deopt_blob->get_original_pc(unextended_sp, pc, original_pc)) {\n+    if (input_cb != nullptr && input_cb->is_nmethod()) {\n+      nmethod* nm = input_cb->as_nmethod();\n+      assert(nm->is_deopt_pc(pc), \"mismatched deopt PC\");\n+      out_cb = input_cb;\n+    } else {\n+      assert(input_cb == nullptr || input_cb == deopt_blob,\n+             \"pc is expected to be of the sub entry points\");\n+      out_cb = CodeCache::find_blob_fast(original_pc);\n+    }\n+    assert(out_cb != nullptr, \"corrupted stack frame\");\n+  } else {\n+#ifdef ASSERT\n+    if (input_cb != nullptr) {\n+      assert(input_cb == CodeCache::find_blob_fast(pc),\n+             \"unexpected input_cb\");\n+    }\n+#endif\n+\n+    CodeBlob *cb = (input_cb != nullptr) ?\n+      input_cb : CodeCache::find_blob_fast(pc);\n+    if (cb != nullptr) {\n+      out_cb = cb;\n+\n+      nmethod* nm = cb->as_nmethod_or_null();\n+      if (nm != nullptr && nm->is_deopt_pc(pc)) {\n+        address orig_pc_slot = (address) unextended_sp + nm->orig_pc_offset();\n+        original_pc = *(address*)orig_pc_slot;\n+      }\n+    }\n+  }\n+\n+#ifdef ASSERT\n+  if (original_pc != nullptr) {\n+    nmethod* nm = CodeCache::find_nmethod(original_pc);\n+    assert(nm == out_cb, \"mismatched code blob\");\n+    assert(nm != nullptr && nm->is_deopt_pc(pc), \"mismatched deopt PC\");\n+  }\n+#endif\n+\n+  return original_pc;\n+}\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.inline.hpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -1728,1 +1728,12 @@\n-      assert(offsets->value(CodeOffsets::Deopt     ) != -1, \"must be set\");\n+      if (AlwaysEmitDeoptStubCode\n+          || frame_size >= DeoptimizationBlob::UNPACK_SUBENTRY_COUNT) {\n+        assert(offsets->value(CodeOffsets::Deopt) != -1, \"must have deopt entry\");\n+      } else {\n+        assert(offsets->value(CodeOffsets::Deopt) == -1, \"must not have a deopt entry\");\n+      }\n+\n+      if (offsets->value(CodeOffsets::Deopt) != -1) {\n+        _deopt_handler_entry_offset    = _stub_offset + offsets->value(CodeOffsets::Deopt);\n+      } else {\n+        _deopt_handler_entry_offset    = -1;\n+      }\n@@ -1738,2 +1749,0 @@\n-\n-      _deopt_handler_entry_offset = _stub_offset + offsets->value(CodeOffsets::Deopt);\n@@ -1741,0 +1750,1 @@\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -623,1 +624,0 @@\n-  address deopt_handler_entry   () const { return           header_begin() + _deopt_handler_entry_offset    ; }\n@@ -835,2 +835,3 @@\n-  inline bool is_deopt_pc(address pc);\n-  inline bool is_deopt_entry(address pc);\n+  inline bool is_deopt_pc(address pc) const;\n+  address deopt_handler_entry() const;\n+  int orig_pc_offset() const;\n@@ -1004,2 +1005,0 @@\n-  int orig_pc_offset() { return _orig_pc_offset; }\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,3 +34,1 @@\n-inline bool nmethod::is_deopt_pc(address pc) { return is_deopt_entry(pc); }\n-\n-inline bool nmethod::is_deopt_entry(address pc) {\n+inline bool nmethod::is_deopt_pc(address pc) const {\n@@ -40,0 +38,35 @@\n+inline int nmethod::orig_pc_offset() const {\n+  assert(_orig_pc_offset == align_down(_orig_pc_offset, BytesPerWord),\n+         \"Required to be word-aligned.\");\n+  return _orig_pc_offset;\n+}\n+\n+inline address nmethod::deopt_handler_entry() const {\n+  int frame_size_in_words = frame_size();\n+\n+#ifdef INCLUDE_JVMCI\n+  if (compiler_type() == compiler_jvmci) {\n+    assert(_deopt_handler_entry_offset >= 0, \"JVMCI must provide deoptimization handler\");\n+  }\n+#endif\n+\n+  if (_deopt_handler_entry_offset >= 0) {\n+    if (compiler_type() != compiler_jvmci && !is_native_method()) {\n+      assert(AlwaysEmitDeoptStubCode\n+             || frame_size_in_words >= DeoptimizationBlob::UNPACK_SUBENTRY_COUNT,\n+             \"This does not need nmethod-specific deoptimization handler entry point\");\n+    }\n+    return header_begin() + _deopt_handler_entry_offset;\n+  } else {\n+    assert(!AlwaysEmitDeoptStubCode\n+           && frame_size_in_words < DeoptimizationBlob::UNPACK_SUBENTRY_COUNT,\n+           \"This requires nmethod-specific deoptimization handler entry point\");\n+    assert(_orig_pc_offset >= 0, \"The original PC slot must exist\");\n+\n+    int orig_pc_offset_in_words = orig_pc_offset() >> LogBytesPerWord;\n+    assert(orig_pc_offset_in_words < frame_size_in_words, \"Original PC slot is outside the frame\");\n+\n+    return SharedRuntime::deopt_blob()->unpack_subentry(orig_pc_offset_in_words);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.inline.hpp","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1793,2 +1793,5 @@\n-    \/\/ Emit the deopt handler code.\n-    _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(masm));\n+    \/\/ Emit the deopt handler code if needed.\n+    if (AlwaysEmitDeoptStubCode\n+        || frame_size_in_words() >= DeoptimizationBlob::UNPACK_SUBENTRY_COUNT) {\n+      _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(masm));\n+    }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1904,2 +1904,30 @@\n-  nm = CodeCache::find_nmethod(pc);\n-  assert(nm != nullptr, \"No NMethod found\");\n+  if (JvmtiExport::can_post_on_exceptions()) {\n+    \/\/ \"Full-speed catching\" is not necessary here,\n+    \/\/ since we're notifying the VM on every catch.\n+    \/\/ Force deoptimization and the rest of the lookup\n+    \/\/ will be fine.\n+    deoptimize_caller_frame(current);\n+  }\n+\n+  CodeBlob* cb = CodeCache::find_blob(pc);\n+  bool is_deopt_pc = CodeCache::is_deopt_pc(pc, \/*strictly_compiled = *\/true, cb);\n+  \/\/ Check the stack guard pages.  If enabled, look for handler in this frame;\n+  \/\/ otherwise, forcibly unwind the frame.\n+  \/\/\n+  \/\/ 4826555: use default current sp for reguard_stack instead of &nm: it's more accurate.\n+  bool force_unwind = !current->stack_overflow_state()->reguard_stack();\n+  bool deopting = false;\n+  if (is_deopt_pc) {\n+    deopting = true;\n+    RegisterMap map(current,\n+                    RegisterMap::UpdateMap::skip,\n+                    RegisterMap::ProcessFrames::include,\n+                    RegisterMap::WalkContinuation::skip);\n+    frame deoptee = current->last_frame().sender(&map);\n+    assert(deoptee.is_deoptimized_frame(), \"must be deopted\");\n+    \/\/ Adjust the pc back to the original throwing pc\n+    pc = deoptee.pc();\n+    cb = deoptee.cb();\n+  }\n+  nm = cb->as_nmethod();\n+\n@@ -1912,26 +1940,0 @@\n-    if (JvmtiExport::can_post_on_exceptions()) {\n-      \/\/ \"Full-speed catching\" is not necessary here,\n-      \/\/ since we're notifying the VM on every catch.\n-      \/\/ Force deoptimization and the rest of the lookup\n-      \/\/ will be fine.\n-      deoptimize_caller_frame(current);\n-    }\n-\n-    \/\/ Check the stack guard pages.  If enabled, look for handler in this frame;\n-    \/\/ otherwise, forcibly unwind the frame.\n-    \/\/\n-    \/\/ 4826555: use default current sp for reguard_stack instead of &nm: it's more accurate.\n-    bool force_unwind = !current->stack_overflow_state()->reguard_stack();\n-    bool deopting = false;\n-    if (nm->is_deopt_pc(pc)) {\n-      deopting = true;\n-      RegisterMap map(current,\n-                      RegisterMap::UpdateMap::skip,\n-                      RegisterMap::ProcessFrames::include,\n-                      RegisterMap::WalkContinuation::skip);\n-      frame deoptee = current->last_frame().sender(&map);\n-      assert(deoptee.is_deoptimized_frame(), \"must be deopted\");\n-      \/\/ Adjust the pc back to the original throwing pc\n-      pc = deoptee.pc();\n-    }\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":30,"deletions":28,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1139,0 +1139,1 @@\n+    AARCH64_ONLY(assert(is_compiled_frame(), \"only compiled methods can be deoptimized\");)\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+  address get_deopt_original_pc_and_cb(CodeBlob*& out_cb) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"code\/codeCache.inline.hpp\"\n@@ -75,0 +76,12 @@\n+  assert(DeoptimizationBlob::UNPACK_SUBENTRY_COUNT == 0,\n+         \"Please use get_deopt_original_pc_and_cb when subentries are enabled\");\n+  CodeBlob* out_cb = nullptr;\n+  address original_pc = get_deopt_original_pc_and_cb(out_cb);\n+  if (original_pc != nullptr) {\n+    assert(out_cb == _cb, \"_cb needs to be adjusted)\");\n+  }\n+  return original_pc;\n+}\n+\n+inline address frame::get_deopt_original_pc_and_cb(CodeBlob*& out_cb) const {\n+  out_cb = nullptr;\n@@ -77,3 +90,8 @@\n-  nmethod* nm = _cb->as_nmethod_or_null();\n-  if (nm != nullptr && nm->is_deopt_pc(_pc)) {\n-    address original_pc = nm->get_original_pc(this);\n+  address original_pc = CodeCache::get_deopt_original_pc_and_cb(\n+    unextended_sp(), pc(), cb(), out_cb);\n+  if (original_pc != nullptr) {\n+    assert(out_cb != nullptr, \"out_cb was not set\");\n+\n+    nmethod* nm = out_cb->as_nmethod_or_null();\n+    assert(nm != nullptr, \"not an nmethod\");\n+    assert(nm->is_deopt_pc(_pc), \"mismatch in deopt stub code entry\");\n@@ -82,1 +100,0 @@\n-    return original_pc;\n@@ -84,1 +101,2 @@\n-  return nullptr;\n+\n+  return original_pc;\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1247,0 +1247,4 @@\n+  product(bool, AlwaysEmitDeoptStubCode, false, DIAGNOSTIC,                 \\\n+          \"Emit deoptimization stub code independently \"                    \\\n+          \"of method's stack frame size\")                                   \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"code\/codeCache.hpp\"\n+#include \"code\/codeCache.inline.hpp\"\n@@ -584,0 +584,16 @@\n+  if (CodeCache::is_deopt_pc(return_address, \/* strictly_compiled = *\/false, blob)) {\n+    \/\/ If we come here because of a stack overflow, the stack may be\n+    \/\/ unguarded. Reguard the stack otherwise if we return to the\n+    \/\/ deopt blob and the stack bang causes a stack overflow we\n+    \/\/ crash.\n+    StackOverflow* overflow_state = current->stack_overflow_state();\n+    bool guard_pages_enabled = overflow_state->reguard_stack_if_needed();\n+    if (overflow_state->reserved_stack_activation() != current->stack_base()) {\n+      overflow_state->set_reserved_stack_activation(current->stack_base());\n+    }\n+    assert(guard_pages_enabled, \"stack banging in deopt blob may cause crash\");\n+    \/\/ The deferred StackWatermarkSet::after_unwind check will be performed in\n+    \/\/ Deoptimization::fetch_unroll_info (with exec_mode == Unpack_exception)\n+    return SharedRuntime::deopt_blob()->unpack_with_exception();\n+  }\n+\n@@ -589,18 +605,4 @@\n-    if (nm->is_deopt_pc(return_address)) {\n-      \/\/ If we come here because of a stack overflow, the stack may be\n-      \/\/ unguarded. Reguard the stack otherwise if we return to the\n-      \/\/ deopt blob and the stack bang causes a stack overflow we\n-      \/\/ crash.\n-      StackOverflow* overflow_state = current->stack_overflow_state();\n-      bool guard_pages_enabled = overflow_state->reguard_stack_if_needed();\n-      if (overflow_state->reserved_stack_activation() != current->stack_base()) {\n-        overflow_state->set_reserved_stack_activation(current->stack_base());\n-      }\n-      assert(guard_pages_enabled, \"stack banging in deopt blob may cause crash\");\n-      \/\/ The deferred StackWatermarkSet::after_unwind check will be performed in\n-      \/\/ Deoptimization::fetch_unroll_info (with exec_mode == Unpack_exception)\n-      return SharedRuntime::deopt_blob()->unpack_with_exception();\n-    } else {\n-      \/\/ The deferred StackWatermarkSet::after_unwind check will be performed in\n-      \/\/ * OptoRuntime::handle_exception_C_helper for C2 code\n-      \/\/ * exception_handler_for_pc_helper via Runtime1::handle_exception_from_callee_id for C1 code\n+    assert(!nm->is_deopt_pc(return_address), \"should have been already handled\");\n+    \/\/ The deferred StackWatermarkSet::after_unwind check will be performed in\n+    \/\/ * OptoRuntime::handle_exception_C_helper for C2 code\n+    \/\/ * exception_handler_for_pc_helper via Runtime1::handle_exception_from_callee_id for C1 code\n@@ -608,5 +610,2 @@\n-      if (nm->compiler_type() == compiler_c2) {\n-        return OptoRuntime::exception_blob()->entry_point();\n-      }\n-#endif \/\/ COMPILER2\n-      return nm->exception_begin();\n+    if (nm->compiler_type() == compiler_c2) {\n+      return OptoRuntime::exception_blob()->entry_point();\n@@ -614,0 +613,2 @@\n+#endif \/\/ COMPILER2\n+    return nm->exception_begin();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-  get_cb();\n-\n@@ -67,0 +65,2 @@\n+  get_cb();\n+\n@@ -260,1 +260,4 @@\n-  _cb = CodeCache::find_blob_fast(pc());\n+  CodeBlob* out_cb = nullptr;\n+  (void) CodeCache::get_deopt_original_pc_and_cb(unextended_sp(), pc(), nullptr, out_cb);\n+  assert(out_cb != nullptr, \"out_cb was not set\");\n+  _cb = out_cb;\n@@ -262,1 +265,0 @@\n-  assert(_cb != nullptr, \"\");\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test UnexpectedDeoptimizationAllTest\n+ * @test id=UnexpectedDeoptimizationAllTest\n@@ -62,0 +62,40 @@\n+\/*\n+ * @test id=UnexpectedDeoptimizationAllTest-with-deopt-stub-code\n+ * @key stress\n+ * @summary stressing code cache by forcing unexpected deoptimizations of all methods\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @requires os.arch==\"aarch64\"\n+ *\n+ * @build jdk.test.whitebox.WhiteBox compiler.codecache.stress.Helper compiler.codecache.stress.TestCaseImpl\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode -XX:+WhiteBoxAPI\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-DeoptimizeRandom\n+ *                   -XX:CompileCommand=dontinline,compiler.codecache.stress.Helper$TestCase::method\n+ *                   -XX:-SegmentedCodeCache\n+ *                   compiler.codecache.stress.UnexpectedDeoptimizationAllTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode -XX:+WhiteBoxAPI\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-DeoptimizeRandom\n+ *                   -XX:CompileCommand=dontinline,compiler.codecache.stress.Helper$TestCase::method\n+ *                   -XX:+SegmentedCodeCache\n+ *                   compiler.codecache.stress.UnexpectedDeoptimizationAllTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode -XX:+WhiteBoxAPI\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-DeoptimizeRandom\n+ *                   -XX:CompileCommand=dontinline,compiler.codecache.stress.Helper$TestCase::method\n+ *                   -XX:-SegmentedCodeCache\n+ *                   -DhelperVirtualThread=true\n+ *                   compiler.codecache.stress.UnexpectedDeoptimizationAllTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode -XX:+WhiteBoxAPI\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-DeoptimizeRandom\n+ *                   -XX:CompileCommand=dontinline,compiler.codecache.stress.Helper$TestCase::method\n+ *                   -XX:+SegmentedCodeCache\n+ *                   -DhelperVirtualThread=true\n+ *                   compiler.codecache.stress.UnexpectedDeoptimizationAllTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/stress\/UnexpectedDeoptimizationAllTest.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test UnexpectedDeoptimizationTest\n+ * @test id=UnexpectedDeoptimizationTest\n@@ -56,0 +56,40 @@\n+ *                   -XX:CompileCommand=dontinline,compiler.codecache.stress.Helper$TestCase::method\n+ *                   -XX:+SegmentedCodeCache\n+ *                   -DhelperVirtualThread=true\n+ *                   compiler.codecache.stress.UnexpectedDeoptimizationTest\n+ *\/\n+\n+\/*\n+ * @test id=UnexpectedDeoptimizationTest-with-deopt-stub-code\n+ * @key stress randomness\n+ * @summary stressing code cache by forcing unexpected deoptimizations\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @requires os.arch==\"aarch64\"\n+ *\n+ * @build jdk.test.whitebox.WhiteBox compiler.codecache.stress.Helper compiler.codecache.stress.TestCaseImpl\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode -XX:+WhiteBoxAPI\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-DeoptimizeRandom\n+ *                   -XX:CompileCommand=dontinline,compiler.codecache.stress.Helper$TestCase::method\n+ *                   -XX:-SegmentedCodeCache\n+ *                   compiler.codecache.stress.UnexpectedDeoptimizationTest\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode -XX:+WhiteBoxAPI\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-DeoptimizeRandom\n+ *                   -XX:CompileCommand=dontinline,compiler.codecache.stress.Helper$TestCase::method\n+ *                   -XX:+SegmentedCodeCache\n+ *                   compiler.codecache.stress.UnexpectedDeoptimizationTest\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode -XX:+WhiteBoxAPI\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-DeoptimizeRandom\n+ *                   -XX:CompileCommand=dontinline,compiler.codecache.stress.Helper$TestCase::method\n+ *                   -XX:-SegmentedCodeCache\n+ *                   -DhelperVirtualThread=true\n+ *                   compiler.codecache.stress.UnexpectedDeoptimizationTest\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode -XX:+WhiteBoxAPI\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-DeoptimizeRandom\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/stress\/UnexpectedDeoptimizationTest.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-* @test\n+* @test id=default\n@@ -33,0 +33,10 @@\n+\/**\n+ * @test id=with-deopt-stub-code\n+ * @summary Test exception state used for deoptimization.\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack -XX:+DeoptimizeALot\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AlwaysEmitDeoptStubCode\n+ *      -Xcomp -XX:TieredStopAtLevel=1 -XX:CompileOnly=compiler.exceptions.TestDeoptExceptionState::test\n+ *      compiler.exceptions.TestDeoptExceptionState\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/TestDeoptExceptionState.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestVerifyStackAfterDeopt\n+ * @test id=TestVerifyStackAfterDeopt\n@@ -37,0 +37,12 @@\n+\/*\n+ * @test id=TestVerifyStackAfterDeopt-with-deopt-stub-code\n+ * @summary Checks VerifyStack after deoptimization of array allocation slow call\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:TieredStopAtLevel=1\n+ *                   -XX:AllocatePrefetchLines=1 -XX:AllocateInstancePrefetchLines=1 -XX:AllocatePrefetchStepSize=16 -XX:AllocatePrefetchDistance=1\n+ *                   -XX:MinTLABSize=1k -XX:TLABSize=1k\n+ *                   -XX:+DeoptimizeALot -XX:+VerifyStack\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   compiler.interpreter.TestVerifyStackAfterDeopt\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/interpreter\/TestVerifyStackAfterDeopt.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default\n@@ -32,0 +32,8 @@\n+\/*\n+ * @test id=with-deopt-stub-code\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/othervm\/timeout=200 -XX:+IgnoreUnrecognizedVMOptions -Xcomp -ea -esa -XX:CompileThreshold=100 -XX:+UnlockDiagnosticVMOptions -XX:+AlwaysEmitDeoptStubCode -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+DeoptimizeALot SortingDeoptimizationTest 1e-2 100 50\n+ * @summary Exercise Arrays.parallelSort when -XX:+DeoptimizeALot is enabled\n+ *\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/SortingDeoptimizationTest.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @test\n+ * @test id=default\n@@ -40,0 +40,10 @@\n+\n+\/*\n+ * @test id=with-deopt-stub-code\n+ * @library \/test\/lib \/\n+ *\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/bootclasspath\/othervm -Xbatch -XX:-TieredCompilation\n+ *                                 -XX:+UnlockDiagnosticVMOptions -XX:+AlwaysEmitDeoptStubCode\n+ *                                 compiler.jsr292.MHDeoptTest\n+ *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/MHDeoptTest.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default\n@@ -35,0 +35,5 @@\n+ *\/\n+\n+\/*\n+ * @test id=with-deopt-stub-code\n+ * @library \/test\/lib \/\n@@ -36,0 +41,8 @@\n+ * @requires os.arch==\"aarch64\"\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+WhiteBoxAPI -Xbatch -Xmx100m\n+ *      -XX:CompileCommand=exclude,compiler.uncommontrap.DeoptReallocFailure::main\n+ *      -XX:+AlwaysEmitDeoptStubCode\n+ *      compiler.uncommontrap.DeoptReallocFailure\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/DeoptReallocFailure.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default\n@@ -47,0 +47,26 @@\n+ *\/\n+\n+\/*\n+ * @test id=with-deopt-stub-code\n+ * @summary failed reallocations of scalar replaced objects during deoptimization causes crash\n+ *\n+ * @requires !vm.graal.enabled\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/othervm\/timeout=480 -XX:-BackgroundCompilation -Xmx128M -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AlwaysEmitDeoptStubCode\n+ *      -XX:CompileCommand=exclude,compiler.uncommontrap.TestDeoptOOM::main\n+ *      -XX:CompileCommand=exclude,compiler.uncommontrap.TestDeoptOOM::m9_1\n+ *      compiler.uncommontrap.TestDeoptOOM\n+ *\/\n+\n+\/*\n+ * @test id=Z-with-deopt-stub-code\n+ * @summary Test that ttyLock is ranked above StackWatermark_lock\n+ * @requires !vm.graal.enabled & vm.gc.Z\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/othervm\/timeout=480 -XX:-BackgroundCompilation -Xmx128M -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack\n+ *      -XX:CompileCommand=exclude,compiler.uncommontrap.TestDeoptOOM::main\n+ *      -XX:CompileCommand=exclude,compiler.uncommontrap.TestDeoptOOM::m9_1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AlwaysEmitDeoptStubCode\n+ *      -XX:+UseZGC -XX:+LogCompilation -XX:+PrintDeoptimizationDetails -XX:+TraceDeoptimization -XX:+Verbose\n+ *      compiler.uncommontrap.TestDeoptOOM\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TestDeoptOOM.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default\n@@ -34,0 +34,11 @@\n+\/*\n+ * @test id=with-deopt-stub-code\n+ * @summary -XX:+TraceDeoptimization tries to print realloc'ed objects even when there are none\n+ *\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+TraceDeoptimization\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   compiler.uncommontrap.TraceDeoptimizationNoRealloc\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TraceDeoptimizationNoRealloc.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test DeoptimizeAllTest\n+ * @test id=DeoptimizeAllTest\n@@ -42,0 +42,18 @@\n+\/*\n+ * @test id=DeoptimizeAllTest-with-deopt-stub-code\n+ * @summary testing of WB::deoptimizeAll()\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires os.arch==\"aarch64\"\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode -XX:+WhiteBoxAPI\n+ *                   -XX:CompileCommand=compileonly,compiler.whitebox.SimpleTestCaseHelper::*\n+ *                   compiler.whitebox.DeoptimizeAllTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/DeoptimizeAllTest.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test DeoptimizeFramesTest\n+ * @test id=DeoptimizeFramesTest\n@@ -50,0 +50,28 @@\n+\/*\n+ * @test id=DeoptimizeFramesTest-with-deopt-stub-code\n+ * @summary testing of WB::deoptimizeFrames()\n+ * @requires vm.opt.StressUnstableIfTraps == null | !vm.opt.StressUnstableIfTraps\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires os.arch==\"aarch64\"\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   -XX:+WhiteBoxAPI -Xmixed\n+ *                   -XX:CompileCommand=compileonly,compiler.whitebox.DeoptimizeFramesTest$TestCaseImpl::method\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-DeoptimizeRandom -XX:-DeoptimizeALot\n+ *                   compiler.whitebox.DeoptimizeFramesTest true\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   -XX:+WhiteBoxAPI -Xmixed\n+ *                   -XX:CompileCommand=compileonly,compiler.whitebox.DeoptimizeFramesTest$TestCaseImpl::method\n+ *                   -XX:CompileCommand=dontinline,java.util.concurrent.Phaser::*\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-DeoptimizeRandom -XX:-DeoptimizeALot\n+ *                   compiler.whitebox.DeoptimizeFramesTest false\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/DeoptimizeFramesTest.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test DeoptimizeMethodTest\n+ * @test id=DeoptimizeMethodTest\n@@ -39,0 +39,15 @@\n+\/*\n+ * @test id=DeoptimizeMethodTest-with-deopt-stub-code\n+ * @summary testing of WB::deoptimizeMethod()\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @requires os.arch==\"aarch64\"\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode -XX:+WhiteBoxAPI\n+ *                   -XX:CompileCommand=compileonly,compiler.whitebox.SimpleTestCaseHelper::*\n+ *                   compiler.whitebox.DeoptimizeMethodTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/DeoptimizeMethodTest.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test DeoptimizeMultipleOSRTest\n+ * @test id=DeoptimizeMultipleOSRTest\n@@ -42,0 +42,18 @@\n+\/*\n+ * @test id=DeoptimizeMultipleOSRTest-with-deopt-stub-code\n+ * @summary testing of WB::deoptimizeMethod()\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires os.arch==\"aarch64\"\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   -XX:CompileCommand=compileonly,compiler.whitebox.DeoptimizeMultipleOSRTest::triggerOSR\n+ *                   compiler.whitebox.DeoptimizeMultipleOSRTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/DeoptimizeMultipleOSRTest.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test\n+ * @test id=default\n@@ -39,0 +39,15 @@\n+\/*\n+ * @test id=with-deopt-stub-code\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires !vm.emulatedClient\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:+AlwaysEmitDeoptStubCode\n+ * -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/DeoptimizeRelocatedNMethod.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -55,0 +55,34 @@\n+\/**\n+ * @test id=vthread-deopt-c1-with-deopt-stub-code\n+ * @summary Deoptimization test for virtual threads (C1)\n+ * @requires vm.continuations\n+ * @requires vm.compiler1.enabled\n+ * @requires vm.opt.TieredStopAtLevel != 0\n+ * @requires os.arch==\"aarch64\"\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-BackgroundCompilation\n+ *                   -XX:TieredStopAtLevel=1\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   Deoptimization\n+ *\/\n+\n+\/**\n+ * @test id=vthread-deopt-c2-with-deopt-stub-code\n+ * @summary Deoptimization test for virtual threads (C2)\n+ * @requires vm.continuations\n+ * @requires vm.compiler2.enabled\n+ * @requires os.arch==\"aarch64\"\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-BackgroundCompilation\n+ *                   -XX:-TieredCompilation\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   Deoptimization\n+ *\/\n","filename":"test\/hotspot\/jtreg\/runtime\/vthread\/Deoptimization.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default\n@@ -35,0 +35,12 @@\n+\/*\n+ * @test id=with-deopt-stub-code\n+ *\n+ * @summary Ensure the same works with per-method deoptimization entry point.\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   jit.deoptimization.test01.test01\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/deoptimization\/test01\/test01.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,0 +35,12 @@\n+\/*\n+ * @test id=with-deopt-stub-code\n+ *\n+ * @summary Ensure the same works with per-method deoptimization entry point.\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   jit.deoptimization.test02.test02\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/deoptimization\/test02\/test02.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,12 @@\n+\/*\n+ * @test id=with-deopt-stub-code\n+ *\n+ * @summary Ensure the same works with per-method deoptimization entry point.\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   jit.deoptimization.test03.test03\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/deoptimization\/test03\/test03.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,12 @@\n+\/*\n+ * @test id=with-deopt-stub-code\n+ *\n+ * @summary Ensure the same works with per-method deoptimization entry point.\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   jit.deoptimization.test04.test04\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/deoptimization\/test04\/test04.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,12 @@\n+\/*\n+ * @test id=with-deopt-stub-code\n+ *\n+ * @summary Ensure the same works with per-method deoptimization entry point.\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   jit.deoptimization.test05.test05\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/deoptimization\/test05\/test05.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,12 @@\n+\/*\n+ * @test id=with-deopt-stub-code\n+ *\n+ * @summary Ensure the same works with per-method deoptimization entry point.\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   jit.deoptimization.test06.test06\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/deoptimization\/test06\/test06.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,12 @@\n+\/*\n+ * @test id=with-deopt-stub-code\n+ *\n+ * @summary Ensure the same works with per-method deoptimization entry point.\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   jit.deoptimization.test07.test07\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/deoptimization\/test07\/test07.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,12 @@\n+\/*\n+ * @test id=with-deopt-stub-code\n+ *\n+ * @summary Ensure the same works with per-method deoptimization entry point.\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AlwaysEmitDeoptStubCode\n+ *                   jit.deoptimization.test08.test08\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/deoptimization\/test08\/test08.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}