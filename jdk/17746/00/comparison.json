{"files":[{"patch":"@@ -0,0 +1,349 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @summary Test virtual threads doing selection operations\n+ * @library \/test\/lib\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED SelectorOps\n+ *\/\n+\n+\/*\n+ * @test id=no-vmcontinuations\n+ * @requires vm.continuations\n+ * @library \/test\/lib\n+ * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations\n+ *     --enable-native-access=ALL-UNNAMED SelectorOps\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadPinner;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class SelectorOps {\n+    private static String selectorClassName;  \/\/ platform specific class name\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        try (Selector sel = Selector.open()) {\n+            selectorClassName = sel.getClass().getName();\n+        }\n+    }\n+\n+    \/**\n+     * Test that select wakes up when a channel is ready for I\/O.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    public void testSelect(boolean timed) throws Exception {\n+        VThreadRunner.run(() -> {\n+            Pipe p = Pipe.open();\n+            try (Selector sel = Selector.open()) {\n+                Pipe.SinkChannel sink = p.sink();\n+                Pipe.SourceChannel source = p.source();\n+                source.configureBlocking(false);\n+                SelectionKey key = source.register(sel, SelectionKey.OP_READ);\n+\n+                \/\/ write to sink to ensure source is readable\n+                ByteBuffer buf = ByteBuffer.wrap(\"hello\".getBytes(StandardCharsets.UTF_8));\n+                onSelect(() -> sink.write(buf));\n+\n+                int n = timed ? sel.select(60_000) : sel.select();\n+                assertEquals(1, n);\n+                assertTrue(sel.isOpen());\n+                assertTrue(key.isReadable());\n+            } finally {\n+                closePipe(p);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test that select wakes up when a channel is ready for I\/O and thread is pinned.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    public void testSelectWhenPinned(boolean timed) throws Exception {\n+        VThreadPinner.runPinned(() -> { testSelect(timed); });\n+    }\n+\n+    \/**\n+     * Test that select wakes up when timeout is reached.\n+     *\/\n+    @Test\n+    public void testSelectTimeout() throws Exception {\n+        VThreadRunner.run(() -> {\n+            Pipe p = Pipe.open();\n+            try (Selector sel = Selector.open()) {\n+                Pipe.SourceChannel source = p.source();\n+                source.configureBlocking(false);\n+                SelectionKey key = source.register(sel, SelectionKey.OP_READ);\n+\n+                long start = millisTime();\n+                int n = sel.select(1000);\n+                expectDuration(start, \/*min*\/500, \/*max*\/20_000);\n+\n+                assertEquals(0, n);\n+                assertTrue(sel.isOpen());\n+                assertFalse(key.isReadable());\n+            } finally {\n+                closePipe(p);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test that select wakes up when timeout is reached and thread is pinned.\n+     *\/\n+    @Test\n+    public void testSelectTimeoutWhenPinned() throws Exception {\n+        VThreadPinner.runPinned(() -> { testSelectTimeout(); });\n+    }\n+\n+    \/**\n+     * Test that selectNow is non-blocking.\n+     *\/\n+    @Test\n+    public void testSelectNow() throws Exception {\n+        VThreadRunner.run(() -> {\n+            Pipe p = Pipe.open();\n+            try (Selector sel = Selector.open()) {\n+                Pipe.SinkChannel sink = p.sink();\n+                Pipe.SourceChannel source = p.source();\n+                source.configureBlocking(false);\n+                SelectionKey key = source.register(sel, SelectionKey.OP_READ);\n+\n+                \/\/ selectNow should return immediately\n+                for (int i = 0; i < 3; i++) {\n+                    long start = millisTime();\n+                    int n = sel.selectNow();\n+                    expectDuration(start, -1, \/*max*\/20_000);\n+                    assertEquals(0, n);\n+                }\n+\n+                \/\/ write to sink to ensure source is readable\n+                ByteBuffer buf = ByteBuffer.wrap(\"hello\".getBytes(StandardCharsets.UTF_8));\n+                sink.write(buf);\n+\n+                \/\/ call selectNow until key added to selected key set\n+                int n = 0;\n+                while (n == 0) {\n+                    Thread.sleep(10);\n+                    long start = millisTime();\n+                    n = sel.selectNow();\n+                    expectDuration(start, -1, \/*max*\/20_000);\n+                }\n+                assertEquals(1, n);\n+                assertTrue(sel.isOpen());\n+                assertTrue(key.isReadable());\n+            } finally {\n+                closePipe(p);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test calling wakeup before select.\n+     *\/\n+    @Test\n+    public void testWakeupBeforeSelect() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (Selector sel = Selector.open()) {\n+                sel.wakeup();\n+                int n = sel.select();\n+                assertEquals(0, n);\n+                assertTrue(sel.isOpen());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test calling wakeup before select and thread is pinned.\n+     *\/\n+    @Test\n+    public void testWakeupBeforeSelectWhenPinned() throws Exception {\n+        VThreadPinner.runPinned(() -> { testWakeupBeforeSelect(); });\n+    }\n+\n+    \/**\n+     * Test calling wakeup while a thread is blocked in select.\n+     *\/\n+    @Test\n+    public void testWakeupDuringSelect() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (Selector sel = Selector.open()) {\n+                onSelect(sel::wakeup);\n+                int n = sel.select();\n+                assertEquals(0, n);\n+                assertTrue(sel.isOpen());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test calling wakeup while a thread is blocked in select and the thread is pinned.\n+     *\/\n+    @Test\n+    public void testWakeupDuringSelectWhenPinned() throws Exception {\n+        VThreadPinner.runPinned(() -> { testWakeupDuringSelect(); });\n+    }\n+\n+    \/**\n+     * Test closing selector while a thread is blocked in select.\n+     *\/\n+    @Test\n+    public void testCloseDuringSelect() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (Selector sel = Selector.open()) {\n+                onSelect(sel::close);\n+                int n = sel.select();\n+                assertEquals(0, n);\n+                assertFalse(sel.isOpen());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test closing selector while a thread is blocked in select and the thread is pinned.\n+     *\/\n+    @Test\n+    public void testCloseDuringSelectWhenPinned() throws Exception {\n+        VThreadPinner.runPinned(() -> { testCloseDuringSelect(); });\n+    }\n+\n+    \/**\n+     * Test calling select with interrupt status set.\n+     *\/\n+    @Test\n+    public void testInterruptBeforeSelect() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (Selector sel = Selector.open()) {\n+                Thread me = Thread.currentThread();\n+                me.interrupt();\n+                int n = sel.select();\n+                assertEquals(0, n);\n+                assertTrue(me.isInterrupted());\n+                assertTrue(sel.isOpen());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test calling select with interrupt status set and thread is pinned.\n+     *\/\n+    @Test\n+    public void testInterruptBeforeSelectWhenPinned() throws Exception {\n+        VThreadPinner.runPinned(() -> { testInterruptDuringSelect(); });\n+    }\n+\n+    \/**\n+     * Test interrupting a thread blocked in select.\n+     *\/\n+    @Test\n+    public void testInterruptDuringSelect() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (Selector sel = Selector.open()) {\n+                Thread me = Thread.currentThread();\n+                onSelect(me::interrupt);\n+                int n = sel.select();\n+                assertEquals(0, n);\n+                assertTrue(me.isInterrupted());\n+                assertTrue(sel.isOpen());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test interrupting a thread blocked in select and the thread is pinned.\n+     *\/\n+    @Test\n+    public void testInterruptDuringSelectWhenPinned() throws Exception {\n+        VThreadPinner.runPinned(() -> { testInterruptDuringSelect(); });\n+    }\n+\n+    \/**\n+     * Close a pipe's sink and source channels.\n+     *\/\n+    private void closePipe(Pipe p) {\n+        try { p.sink().close(); } catch (IOException ignore) { }\n+        try { p.source().close(); } catch (IOException ignore) { }\n+    }\n+\n+    \/**\n+     * Runs the given action when the current thread is sampled in a selection operation.\n+     *\/\n+    private void onSelect(VThreadRunner.ThrowingRunnable<Exception> action) {\n+        Thread target = Thread.currentThread();\n+        Thread.ofPlatform().daemon().start(() -> {\n+            try {\n+                boolean found = false;\n+                while (!found) {\n+                    Thread.sleep(20);\n+                    StackTraceElement[] stack = target.getStackTrace();\n+                    found = Arrays.stream(stack)\n+                            .anyMatch(e -> selectorClassName.equals(e.getClassName())\n+                                    && \"doSelect\".equals(e.getMethodName()));\n+                }\n+                action.run();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Returns the current time in milliseconds.\n+     *\/\n+    private static long millisTime() {\n+        long now = System.nanoTime();\n+        return TimeUnit.MILLISECONDS.convert(now, TimeUnit.NANOSECONDS);\n+    }\n+\n+    \/**\n+     * Check the duration of a task\n+     * @param start start time, in milliseconds\n+     * @param min minimum expected duration, in milliseconds\n+     * @param max maximum expected duration, in milliseconds\n+     * @return the duration (now - start), in milliseconds\n+     *\/\n+    private static void expectDuration(long start, long min, long max) {\n+        long duration = millisTime() - start;\n+        assertTrue(duration >= min,\n+                \"Duration \" + duration + \"ms, expected >= \" + min + \"ms\");\n+        assertTrue(duration <= max,\n+                \"Duration \" + duration + \"ms, expected <= \" + max + \"ms\");\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/vthread\/SelectorOps.java","additions":349,"deletions":0,"binary":false,"changes":349,"status":"added"}]}