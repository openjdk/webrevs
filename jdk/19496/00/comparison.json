{"files":[{"patch":"@@ -475,1 +475,1 @@\n-    Node_List nlist;\n+    Node_Stack nstack(0);\n@@ -495,1 +495,1 @@\n-        if (n->dominates(sub, nlist))\n+        if (n->dominates(sub, nstack))\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1252,1 +1252,1 @@\n-bool Node::dominates(Node* sub, Node_List &nlist) {\n+bool Node::dominates(Node* sub, Node_Stack &nstack) {\n@@ -1262,1 +1262,1 @@\n-  nlist.clear();\n+  nstack.clear();\n@@ -1272,1 +1272,21 @@\n-    if (sub->is_top())  break; \/\/ Conservative answer for dead code.\n+    if (sub->is_top()) {\n+      \/\/ We reached a dead code, try another path of the last multi-input Region we met.\n+      bool found = false;\n+      for (uint i = nstack.size(); i > 0; i--) {\n+        Node* n = nstack.node_at(i - 1);\n+        for (uint index = nstack.index_at(i - 1); index < n->req(); index++) {\n+          Node* in = n->in(index);\n+          if (in != nullptr && !in->is_top()) {\n+            found = true;\n+            sub = n->find_exact_control(in);\n+            nstack.set_index_at(i - 1, index + 1);\n+            break;\n+          }\n+        }\n+        if (found) break;\n+      }\n+      if (found) continue;\n+      \/\/ Give a conservative answer if we have no other choices.\n+      break;\n+    }\n+\n@@ -1274,1 +1294,1 @@\n-      if (nlist.size() == 0) {\n+      if (nstack.is_empty()) {\n@@ -1285,1 +1305,1 @@\n-     }\n+      }\n@@ -1293,0 +1313,1 @@\n+\n@@ -1304,3 +1325,1 @@\n-      \/\/ Try both paths for Regions with 2 input paths (it may be a loop head).\n-      \/\/ It could give conservative 'false' answer without information\n-      \/\/ which region's input is the entry path.\n+      \/\/ Try all paths for Regions with multiple input paths (it may be a loop head).\n@@ -1315,4 +1334,2 @@\n-      for (int j = nlist.size() - 1; j >= 0; j--) {\n-        intptr_t ni = (intptr_t)nlist.at(j);\n-        Node* visited = (Node*)(ni & ~1);\n-        bool  visited_twice_already = ((ni & 1) != 0);\n+      for (uint i = nstack.size(); i > 0; i--) {\n+        Node* visited = nstack.node_at(i - 1);\n@@ -1320,2 +1337,12 @@\n-          if (visited_twice_already) {\n-            \/\/ Visited 2 paths, but still stuck in loop body.  Give up.\n+          \/\/ The Region node was visited before, just visit the next input.\n+          for (uint index = nstack.index_at(i - 1); index < sub->req(); index++) {\n+            Node* in = sub->in(index);\n+            if (in != nullptr && !in->is_top() && in != sub) {\n+              region_was_visited_before = true;\n+              up = in;\n+              nstack.set_index_at(i - 1, index + 1);\n+              break;\n+            }\n+          }\n+          if (!region_was_visited_before) {\n+            \/\/ Visited all paths, but still stuck in loop body. Give up.\n@@ -1324,5 +1351,0 @@\n-          \/\/ The Region node was visited before only once.\n-          \/\/ (We will repush with the low bit set, below.)\n-          nlist.remove(j);\n-          \/\/ We will find a new edge and re-insert.\n-          region_was_visited_before = true;\n@@ -1333,7 +1355,5 @@\n-      \/\/ Find an incoming edge which has not been seen yet; walk through it.\n-      assert(up == sub, \"\");\n-      uint skip = region_was_visited_before ? 1 : 0;\n-      for (uint i = 1; i < sub->req(); i++) {\n-        Node* in = sub->in(i);\n-        if (in != nullptr && !in->is_top() && in != sub) {\n-          if (skip == 0) {\n+      \/\/ Record this Region if it's not visited before, and visit its first input.\n+      if (!region_was_visited_before) {\n+        for (uint i = 1; i < sub->req(); i++) {\n+          Node* in = sub->in(i);\n+          if (in != nullptr && !in->is_top() && in != sub) {\n@@ -1341,0 +1361,1 @@\n+            nstack.push(sub, i + 1);\n@@ -1343,1 +1364,0 @@\n-          --skip;               \/\/ skip this nontrivial input\n@@ -1346,3 +1366,0 @@\n-\n-      \/\/ Set 0 bit to indicate that both paths were taken.\n-      nlist.push((Node*)((intptr_t)sub + (region_was_visited_before ? 1 : 0)));\n@@ -1361,1 +1378,2 @@\n-    sub = up;\n+    \/\/ Skip simple pass-through control nodes in chain.\n+    sub = sub->find_exact_control(up);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":49,"deletions":31,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1112,1 +1112,1 @@\n-  bool dominates(Node* sub, Node_List &nlist);\n+  bool dominates(Node* sub, Node_Stack &nstack);\n@@ -1898,0 +1898,4 @@\n+  void set_index_at(uint i, uint index) {\n+    assert(_inodes + i <= _inode_top, \"in range\");\n+    _inodes[i].indx = index;\n+  }\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.Enumeration;\n@@ -130,0 +131,15 @@\n+    @Benchmark\n+    public int testConcurrentHashMapIterators() {\n+        ConcurrentHashMap<Integer, Integer> map = (ConcurrentHashMap<Integer, Integer>) staticMap;\n+        int sum = 0;\n+        Enumeration it = map.elements();\n+        while (it.hasMoreElements()) {\n+            sum += (int) it.nextElement();\n+        }\n+        it = map.keys();\n+        while (it.hasMoreElements()) {\n+            sum += (int) it.nextElement();\n+        }\n+        return sum;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/concurrent\/Maps.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}