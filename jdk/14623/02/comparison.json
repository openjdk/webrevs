{"files":[{"patch":"@@ -58,0 +58,1 @@\n+  bool      _is_linked;\n@@ -59,0 +60,1 @@\n+  bool      is_linked() const        { return _is_linked; }\n@@ -61,18 +63,14 @@\n-  short     get_short()              { short i=Bytes::get_Java_u2(_next_pc); _next_pc+=2; return i; }\n-  int       get_int()                { int i=Bytes::get_Java_u4(_next_pc); _next_pc+=4; return i; }\n-\n-  int       get_index_u1()           { return *(address)_next_pc++; }\n-  int       get_index_u2()           { int i=Bytes::get_Java_u2(_next_pc); _next_pc+=2; return i; }\n-  int       get_index_u1_cpcache()   { return get_index_u1() + ConstantPool::CPCACHE_INDEX_TAG; }\n-  int       get_index_u2_cpcache()   { int i=Bytes::get_native_u2(_next_pc); _next_pc+=2; return i + ConstantPool::CPCACHE_INDEX_TAG; }\n-  int       get_index_u4()           { int i=Bytes::get_native_u4(_next_pc); _next_pc+=4; return i; }\n-  int       get_index_special()      { return (is_wide()) ? get_index_u2() : get_index_u1(); }\n-  Method* method()                 { return _current_method; }\n-  bool      is_wide()                { return _is_wide; }\n-  Bytecodes::Code raw_code()         { return Bytecodes::Code(_code); }\n-\n-\n-  bool      check_index(int i, int& cp_index, outputStream* st);\n-  bool      check_cp_cache_index(int i, int& cp_index, outputStream* st);\n-  bool      check_obj_index(int i, int& cp_index, outputStream* st);\n-  bool      check_invokedynamic_index(int i, int& cp_index, outputStream* st);\n+  int       get_index_u1()           { return *(address)_next_pc++; }  \/\/ returns 0x00 - 0xff as an int\n+  short     get_short()              { short i = Bytes::get_Java_u2  (_next_pc); _next_pc += 2; return i; }\n+  int       get_int()                { int   i = Bytes::get_Java_u4  (_next_pc); _next_pc += 4; return i; }\n+  int       get_native_index_u2()    { int   i = Bytes::get_native_u2(_next_pc); _next_pc += 2; return i; }\n+  int       get_native_index_u4()    { int   i = Bytes::get_native_u4(_next_pc); _next_pc += 4; return i; }\n+  int       get_Java_index_u2()      { int   i = Bytes::get_Java_u2  (_next_pc); _next_pc += 2; return i; }\n+  int       get_Java_index_u4()      { int   i = Bytes::get_Java_u4  (_next_pc); _next_pc += 4; return i; }\n+  int       get_index_special()      { return (is_wide()) ? get_Java_index_u2() : get_index_u1(); }\n+  Method*   method() const           { return _current_method; }\n+  bool      is_wide() const          { return _is_wide; }\n+  Bytecodes::Code raw_code() const   { return Bytecodes::Code(_code); }\n+  ConstantPool* constants() const    { return method()->constants(); }\n+  ConstantPoolCache* cpcache() const { assert(is_linked(), \"must be\"); return constants()->cache(); }\n+\n@@ -80,1 +78,0 @@\n-  void      print_constant_nocheck(int i, outputStream* st);\n@@ -82,4 +79,4 @@\n-  void      print_dynamic(int orig_i, int i, constantTag tag, outputStream* st);\n-  void      print_field_or_method(int i, outputStream* st);\n-  void      print_field_or_method(int orig_i, int i, outputStream* st);\n-  void      print_invoke_handle(int i, outputStream* st);\n+  void      print_invokedynamic(int indy_index, int cp_index, outputStream* st);\n+  void      print_bsm(int cp_index, outputStream* st);\n+  void      print_field_or_method(int cp_index, outputStream* st);\n+  void      print_dynamic(int cp_index, outputStream* st);\n@@ -112,0 +109,2 @@\n+      _is_linked = method->method_holder()->is_linked();\n+      assert(_is_linked, \"this function must be called on methods that are already executing\");\n@@ -136,0 +135,6 @@\n+\n+#ifndef PRODUCT\n+    if (TraceBytecodesStopAt != 0 && BytecodeCounter::counter_value() >= TraceBytecodesStopAt) {\n+      TraceBytecodes = false;\n+    }\n+#endif\n@@ -142,0 +147,1 @@\n+    _is_linked = method->method_holder()->is_linked();\n@@ -193,99 +199,1 @@\n-void print_symbol(Symbol* sym, outputStream* st) {\n-  char buf[40];\n-  int len = sym->utf8_length();\n-  if (len >= (int)sizeof(buf)) {\n-    st->print_cr(\" %s...[%d]\", sym->as_C_string(buf, sizeof(buf)), len);\n-  } else {\n-    st->print(\" \");\n-    sym->print_on(st); st->cr();\n-  }\n-}\n-\n-void print_oop(oop value, outputStream* st) {\n-  if (value == nullptr) {\n-    st->print_cr(\" null\");\n-  } else if (java_lang_String::is_instance(value)) {\n-    char buf[40];\n-    int len = java_lang_String::utf8_length(value);\n-    java_lang_String::as_utf8_string(value, buf, sizeof(buf));\n-    if (len >= (int)sizeof(buf)) {\n-      st->print_cr(\" %s...[%d]\", buf, len);\n-    } else {\n-      st->print_cr(\" %s\", buf);\n-    }\n-  } else {\n-    st->print_cr(\" \" INTPTR_FORMAT, p2i((void *)value));\n-  }\n-}\n-\n-bool BytecodePrinter::check_index(int i, int& cp_index, outputStream* st) {\n-  ConstantPool* constants = method()->constants();\n-  int ilimit = constants->length();\n-  Bytecodes::Code code = raw_code();\n-\n-  if (Bytecodes::uses_cp_cache(code)) {\n-    bool okay = true;\n-    switch (code) {\n-    case Bytecodes::_fast_aldc:\n-    case Bytecodes::_fast_aldc_w:\n-      okay = check_obj_index(i, cp_index, st);\n-      break;\n-    case Bytecodes::_invokedynamic:\n-      okay = check_invokedynamic_index(i, cp_index, st);\n-      break;\n-    default:\n-      okay = check_cp_cache_index(i, cp_index, st);\n-      break;\n-    }\n-    if (!okay) return false;\n-  }\n-\n-\n-  \/\/ check cp index\n-  if (cp_index >= 0 && cp_index < ilimit) {\n-    if (WizardMode)  st->print(\" cp[%d]\", cp_index);\n-    return true;\n-  }\n-\n-  st->print_cr(\" CP[%d] not in CP\", cp_index);\n-  return false;\n-}\n-\n-bool BytecodePrinter::check_cp_cache_index(int i, int& cp_index, outputStream* st) {\n-  ConstantPool* constants = method()->constants();\n-  int climit = 0;\n-\n-  ConstantPoolCache* cache = constants->cache();\n-  \/\/ If rewriter hasn't run, the index is the cp_index\n-  if (cache == nullptr) {\n-    cp_index = i;\n-    return true;\n-  }\n-  \/\/climit = cache->length();  \/\/ %%% private!\n-  size_t size = cache->size() * wordSize;\n-  size -= sizeof(ConstantPoolCache);\n-  size \/= sizeof(ConstantPoolCacheEntry);\n-  climit = (int) size;\n-\n-#ifdef ASSERT\n-  {\n-    const int CPCACHE_INDEX_TAG = ConstantPool::CPCACHE_INDEX_TAG;\n-    if (i >= CPCACHE_INDEX_TAG && i < climit + CPCACHE_INDEX_TAG) {\n-      i -= CPCACHE_INDEX_TAG;\n-    } else {\n-      st->print_cr(\" CP[%d] missing bias?\", i);\n-      return false;\n-    }\n-  }\n-#endif \/\/ASSERT\n-  if (i >= 0 && i < climit) {\n-    cp_index = cache->entry_at(i)->constant_pool_index();\n-  } else {\n-    st->print_cr(\"%d not in CP[*]?\", i);\n-      return false;\n-    }\n-  return true;\n-  }\n-\n-\n-bool BytecodePrinter::check_obj_index(int i, int& cp_index, outputStream* st) {\n+void BytecodePrinter::print_constant(int cp_index, outputStream* st) {\n@@ -293,35 +201,1 @@\n-  i -= ConstantPool::CPCACHE_INDEX_TAG;\n-\n-  if (i >= 0 && i < constants->resolved_references()->length()) {\n-     cp_index = constants->object_to_cp_index(i);\n-     return true;\n-  } else {\n-    st->print_cr(\"%d not in OBJ[*]?\", i);\n-  return false;\n-}\n-}\n-\n-\n-bool BytecodePrinter::check_invokedynamic_index(int i, int& cp_index, outputStream* st) {\n-  ConstantPool* constants = _current_method->constants();\n-  if (constants->cache() == nullptr) {\n-    cp_index = i; \/\/ TODO: This is wrong on little-endian. See JDK-8309811.\n-  } else {\n-    assert(ConstantPool::is_invokedynamic_index(i), \"must be\");\n-    int indy_index = ConstantPool::decode_invokedynamic_index(i);\n-    ResolvedIndyEntry* indy_entry = constants->resolved_indy_entry_at(indy_index);\n-    cp_index = indy_entry->constant_pool_index();\n-  }\n-  return true;\n-}\n-\n-void BytecodePrinter::print_constant(int i, outputStream* st) {\n-  int orig_i = i;\n-  if (!check_index(orig_i, i, st))  return;\n-\n-  print_constant_nocheck(i, st);\n-}\n-\n-void BytecodePrinter::print_constant_nocheck(int i, outputStream* st) {\n-  ConstantPool* constants = method()->constants();\n-  constantTag tag = constants->tag_at(i);\n+  constantTag tag = constants->tag_at(cp_index);\n@@ -330,1 +204,1 @@\n-    st->print_cr(\" \" INT32_FORMAT, constants->int_at(i));\n+    st->print_cr(\" \" INT32_FORMAT, constants->int_at(cp_index));\n@@ -332,1 +206,1 @@\n-    st->print_cr(\" \" INT64_FORMAT, (int64_t)(constants->long_at(i)));\n+    st->print_cr(\" \" INT64_FORMAT, (int64_t)(constants->long_at(cp_index)));\n@@ -334,1 +208,1 @@\n-    st->print_cr(\" %f\", constants->float_at(i));\n+    st->print_cr(\" %f\", constants->float_at(cp_index));\n@@ -336,1 +210,1 @@\n-    st->print_cr(\" %f\", constants->double_at(i));\n+    st->print_cr(\" %f\", constants->double_at(cp_index));\n@@ -338,2 +212,2 @@\n-    const char* string = constants->string_at_noresolve(i);\n-    st->print_cr(\" %s\", string);\n+    const char* string = constants->unresolved_string_at(cp_index)->as_quoted_ascii();\n+    st->print_cr(\" \\\"%s\\\"\", string);\n@@ -341,1 +215,1 @@\n-    st->print_cr(\" %s\", constants->resolved_klass_at(i)->external_name());\n+    st->print_cr(\" %s\", constants->resolved_klass_at(cp_index)->external_name());\n@@ -343,1 +217,1 @@\n-    st->print_cr(\" <unresolved klass at %d>\", i);\n+    st->print_cr(\" %s\", constants->klass_at_noresolve(cp_index)->as_quoted_ascii());\n@@ -345,1 +219,1 @@\n-    int i2 = constants->method_type_index_at(i);\n+    int i2 = constants->method_type_index_at(cp_index);\n@@ -347,1 +221,1 @@\n-    print_symbol(constants->symbol_at(i2), st);\n+    st->print_cr(\" %s\", constants->symbol_at(i2)->as_quoted_ascii());\n@@ -349,2 +223,2 @@\n-    int kind = constants->method_handle_ref_kind_at(i);\n-    int i2 = constants->method_handle_index_at(i);\n+    int kind = constants->method_handle_ref_kind_at(cp_index);\n+    int i2 = constants->method_handle_index_at(cp_index);\n@@ -352,1 +226,6 @@\n-    print_field_or_method(-i, i2, st);\n+    print_field_or_method(i2, st);\n+  } else if (tag.is_dynamic_constant()) {\n+    print_dynamic(cp_index, st);\n+    if (ClassPrinter::has_mode(_flags, ClassPrinter::PRINT_DYNAMIC)) {\n+      print_bsm(cp_index, st);\n+    }\n@@ -354,1 +233,1 @@\n-    st->print_cr(\" bad tag=%d at %d\", tag.value(), i);\n+    st->print_cr(\" bad tag=%d at %d\", tag.value(), cp_index);\n@@ -358,7 +237,2 @@\n-void BytecodePrinter::print_field_or_method(int i, outputStream* st) {\n-  int orig_i = i;\n-  if (!check_index(orig_i, i, st))  return;\n-  print_field_or_method(orig_i, i, st);\n-}\n-\n-void BytecodePrinter::print_field_or_method(int orig_i, int i, outputStream* st) {\n+\/\/ Fieldref, Methodref, or InterfaceMethodref\n+void BytecodePrinter::print_field_or_method(int cp_index, outputStream* st) {\n@@ -366,3 +240,1 @@\n-  constantTag tag = constants->tag_at(i);\n-\n-  bool has_klass = true;\n+  constantTag tag = constants->tag_at(cp_index);\n@@ -371,2 +243,0 @@\n-  case JVM_CONSTANT_InterfaceMethodref:\n-  case JVM_CONSTANT_Methodref:\n@@ -374,0 +244,2 @@\n+  case JVM_CONSTANT_Methodref:\n+  case JVM_CONSTANT_InterfaceMethodref:\n@@ -375,1 +247,18 @@\n-  case JVM_CONSTANT_NameAndType:\n+  default:\n+    st->print_cr(\" bad tag=%d at %d\", tag.value(), cp_index);\n+    return;\n+  }\n+\n+  Symbol* name = constants->uncached_name_ref_at(cp_index);\n+  Symbol* signature = constants->uncached_signature_ref_at(cp_index);\n+  Symbol* klass = constants->klass_name_at(constants->uncached_klass_ref_index_at(cp_index));\n+  const char* sep = (tag.is_field() ? \":\" : \"\");\n+  st->print_cr(\" %d <%s.%s%s%s> \", cp_index, klass->as_C_string(), name->as_C_string(), sep, signature->as_C_string());\n+}\n+\n+\/\/ JVM_CONSTANT_Dynamic or JVM_CONSTANT_InvokeDynamic\n+void BytecodePrinter::print_dynamic(int cp_index, outputStream* st) {\n+  ConstantPool* constants = method()->constants();\n+  constantTag tag = constants->tag_at(cp_index);\n+\n+  switch (tag.value()) {\n@@ -378,1 +267,0 @@\n-    has_klass = false;\n@@ -381,1 +269,1 @@\n-    st->print_cr(\" bad tag=%d at %d\", tag.value(), i);\n+    st->print_cr(\" bad tag=%d at %d\", tag.value(), cp_index);\n@@ -385,13 +273,2 @@\n-  Symbol* name = constants->uncached_name_ref_at(i);\n-  Symbol* signature = constants->uncached_signature_ref_at(i);\n-  const char* sep = (tag.is_field() ? \"\/\" : \"\");\n-  if (has_klass) {\n-    Symbol* klass = constants->klass_name_at(constants->uncached_klass_ref_index_at(i));\n-    st->print_cr(\" %d <%s.%s%s%s> \", i, klass->as_C_string(), name->as_C_string(), sep, signature->as_C_string());\n-  } else {\n-    if (tag.is_dynamic_constant() || tag.is_invoke_dynamic()) {\n-      int bsm = constants->bootstrap_method_ref_index_at(i);\n-      st->print(\" bsm=%d\", bsm);\n-    }\n-    st->print_cr(\" %d <%s%s%s>\", i, name->as_C_string(), sep, signature->as_C_string());\n-  }\n+  int bsm = constants->bootstrap_method_ref_index_at(cp_index);\n+  st->print(\" bsm=%d\", bsm);\n@@ -399,3 +276,17 @@\n-  if (ClassPrinter::has_mode(_flags, ClassPrinter::PRINT_DYNAMIC) &&\n-      (tag.is_dynamic_constant() || tag.is_invoke_dynamic())) {\n-    print_dynamic(orig_i, i, tag, st);\n+  Symbol* name = constants->uncached_name_ref_at(cp_index);\n+  Symbol* signature = constants->uncached_signature_ref_at(cp_index);\n+  const char* sep = tag.is_dynamic_constant() ? \":\" : \"\";\n+  st->print_cr(\" %d <%s%s%s>\", cp_index, name->as_C_string(), sep, signature->as_C_string());\n+}\n+\n+void BytecodePrinter::print_invokedynamic(int indy_index, int cp_index, outputStream* st) {\n+  print_dynamic(cp_index, st);\n+\n+  if (ClassPrinter::has_mode(_flags, ClassPrinter::PRINT_DYNAMIC)) {\n+    print_bsm(cp_index, st);\n+\n+    if (is_linked()) {\n+      ResolvedIndyEntry* indy_entry = constants()->resolved_indy_entry_at(indy_index);\n+      st->print(\"  ResolvedIndyEntry: \");\n+      indy_entry->print_on(st);\n+    }\n@@ -405,3 +296,4 @@\n-void BytecodePrinter::print_dynamic(int orig_i, int bsm_cpindex, constantTag tag, outputStream* st) {\n-  ConstantPool* constants = method()->constants();\n-  int bsm = constants->bootstrap_method_ref_index_at(bsm_cpindex);\n+\/\/ cp_index: must be the cp_index of a JVM_CONSTANT_{Dynamic, DynamicInError, InvokeDynamic}\n+void BytecodePrinter::print_bsm(int cp_index, outputStream* st) {\n+  assert(constants()->tag_at(cp_index).has_bootstrap(), \"must be\");\n+  int bsm = constants()->bootstrap_method_ref_index_at(cp_index);\n@@ -409,1 +301,1 @@\n-  switch (constants->method_handle_ref_kind_at(bsm)) {\n+  switch (constants()->method_handle_ref_kind_at(bsm)) {\n@@ -422,2 +314,2 @@\n-  print_field_or_method(-1, constants->method_handle_index_at(bsm), st);\n-  int argc = constants->bootstrap_argument_count_at(bsm_cpindex);\n+  print_field_or_method(constants()->method_handle_index_at(bsm), st);\n+  int argc = constants()->bootstrap_argument_count_at(cp_index);\n@@ -428,1 +320,1 @@\n-      int arg = constants->bootstrap_argument_index_at(bsm_cpindex, arg_i);\n+      int arg = constants()->bootstrap_argument_index_at(cp_index, arg_i);\n@@ -430,1 +322,1 @@\n-      print_constant_nocheck(arg, st);\n+      print_constant(arg, st);\n@@ -434,12 +326,0 @@\n-  if (tag.is_invoke_dynamic()) {\n-    int indy_index = constants->decode_invokedynamic_index(orig_i);\n-    ResolvedIndyEntry* indy_entry = constants->resolved_indy_entry_at(indy_index);\n-    st->print(\"  ResolvedIndyEntry: \");\n-    indy_entry->print_on(st);\n-  } else {\n-    \/\/ TODO: print info for tag.is_dynamic_constant()\n-  }\n-}\n-\n-void BytecodePrinter::print_invoke_handle(int i, outputStream* st) {\n-  print_cpcache_entry(ConstantPool::decode_cpcache_index(i), st);\n@@ -475,4 +355,10 @@\n-      if (Bytecodes::uses_cp_cache(raw_code())) {\n-        print_constant(get_index_u1_cpcache(), st);\n-      } else {\n-        print_constant(get_index_u1(), st);\n+      {\n+        int cp_index;\n+        if (Bytecodes::uses_cp_cache(raw_code())) {\n+          assert(is_linked(), \"fast ldc bytecode must be in linked classes\");\n+          int obj_index = get_index_u1();\n+          cp_index = constants()->object_to_cp_index(obj_index);\n+        } else {\n+          cp_index = get_index_u1();\n+        }\n+        print_constant(cp_index, st);\n@@ -484,4 +370,10 @@\n-      if (Bytecodes::uses_cp_cache(raw_code())) {\n-        print_constant(get_index_u2_cpcache(), st);\n-      } else {\n-        print_constant(get_index_u2(), st);\n+      {\n+        int cp_index;\n+        if (Bytecodes::uses_cp_cache(raw_code())) {\n+          assert(is_linked(), \"fast ldc bytecode must be in linked classes\");\n+          int obj_index = get_native_index_u2();\n+          cp_index = constants()->object_to_cp_index(obj_index);\n+        } else {\n+          cp_index = get_Java_index_u2();\n+        }\n+        print_constant(cp_index, st);\n@@ -521,1 +413,1 @@\n-        int klass_index = get_index_u2();\n+        int klass_index = get_Java_index_u2();\n@@ -528,1 +420,1 @@\n-        int klass_index = get_index_u2();\n+        int klass_index = get_Java_index_u2();\n@@ -609,1 +501,10 @@\n-      print_field_or_method(get_index_u2_cpcache(), st);\n+      {\n+        int cp_index;\n+        if (is_linked()) {\n+          int cpcache_index = get_native_index_u2();\n+          cp_index = cpcache()->entry_at(cpcache_index)->constant_pool_index();\n+        } else {\n+          cp_index = get_Java_index_u2();\n+        }\n+        print_field_or_method(cp_index, st);\n+      }\n@@ -616,2 +517,10 @@\n-        int i = get_index_u2_cpcache();\n-        print_field_or_method(i, st);\n+        int cp_index;\n+        int cpcache_index;\n+        if (is_linked()) {\n+          cpcache_index = get_native_index_u2();\n+          cp_index = cpcache()->entry_at(cpcache_index)->constant_pool_index();\n+        } else {\n+          cpcache_index = -1;\n+          cp_index = get_Java_index_u2();\n+        }\n+        print_field_or_method(cp_index, st);\n@@ -620,1 +529,3 @@\n-          print_invoke_handle(i, st);\n+          assert(is_linked(), \"invokehandle is only in rewritten methods\");\n+          assert(cpcache_index >= 0, \"must be\");\n+          print_cpcache_entry(cpcache_index, st);\n@@ -626,4 +537,11 @@\n-      { int i = get_index_u2_cpcache();\n-        int n = get_index_u1();\n-        get_byte();            \/\/ ignore zero byte\n-        print_field_or_method(i, st);\n+      {\n+        int cp_index;\n+        if (is_linked()) {\n+          int cpcache_index = get_native_index_u2();\n+          cp_index = cpcache()->entry_at(cpcache_index)->constant_pool_index();\n+        } else {\n+          cp_index = get_Java_index_u2();\n+        }\n+        int count = get_index_u1(); \/\/ TODO: this is not printed.\n+        get_byte();                 \/\/ ignore zero byte\n+        print_field_or_method(cp_index, st);\n@@ -634,1 +552,15 @@\n-      print_field_or_method(get_index_u4(), st);\n+      {\n+        int indy_index;\n+        int cp_index;\n+        if (is_linked()) {\n+          int i = get_native_index_u4();\n+          indy_index = ConstantPool::decode_invokedynamic_index(i);\n+          cp_index = constants()->resolved_indy_entry_at(indy_index)->constant_pool_index();\n+        } else {\n+          indy_index = -1;\n+          cp_index = get_Java_index_u2();\n+          get_byte();            \/\/ ignore zero byte\n+          get_byte();            \/\/ ignore zero byte\n+        }\n+        print_invokedynamic(indy_index, cp_index, st);\n+      }\n@@ -640,1 +572,1 @@\n-      { int i = get_index_u2();\n+      { int i = get_Java_index_u2();\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":174,"deletions":242,"binary":false,"changes":416,"status":"modified"},{"patch":"@@ -1590,0 +1590,3 @@\n+  develop(intx, TraceBytecodesStopAt, 0,                                    \\\n+          \"Stop bytecode tracing at the specified bytecode number\")         \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @build jdk.test.whitebox.WhiteBox\n+ * @build jdk.test.whitebox.WhiteBox Linked2 Unlinked2\n@@ -36,1 +36,1 @@\n-import java.io.Serializable;\n+import java.lang.invoke.MethodHandle;\n@@ -43,0 +43,12 @@\n+    private final static String Linked_className = Linked.class.getName();\n+    private final static String Linked2_className = Linked2.class.getName();\n+\n+    \/\/ This loads the \"Unlinked\" and \"Unlinked2\" classes, but doesn't link them.\n+    private final static String Unlinked_className = Unlinked.class.getName();\n+    private final static String Unlinked2_className = Unlinked2.class.getName();\n+\n+    public static void staticMethod()   { }\n+    public void virtualMethod() { }\n+    int x;\n+    static long y;\n+\n@@ -47,1 +59,15 @@\n-    }\n+        public String test_ldc() {\n+            Class c = Unloaded.class;\n+            return \"Literal\\u5678\";\n+        }\n+        public void test_invoke(BytecodeTracerTest obj) {\n+            obj.virtualMethod();\n+            staticMethod();\n+        }\n+        public void test_field(BytecodeTracerTest obj) {\n+            y = obj.x;\n+        }\n+        public void test_invokehandle(MethodHandle mh) throws Throwable {\n+            mh.invokeExact(4.0f, \"String\", this);\n+        }\n+   }\n@@ -49,1 +75,1 @@\n-    public static class Unlinked implements Serializable {\n+    public static class Unlinked {\n@@ -53,0 +79,14 @@\n+        public String test_ldc() {\n+            Class c = Unloaded.class;\n+            return \"Literal\\u1234\";\n+        }\n+        public void test_invoke(BytecodeTracerTest obj) {\n+            obj.virtualMethod();\n+            staticMethod();\n+        }\n+        public void test_field(BytecodeTracerTest obj) {\n+            y = obj.x;\n+        }\n+        public void test_invokehandle(MethodHandle mh) throws Throwable {\n+            mh.invokeExact(4.0f, \"String\", this);\n+        }\n@@ -55,1 +95,3 @@\n-    static String output;\n+    \/\/ This class is never loaded during the execution of BytecodeTracerTest\n+    public static class Unloaded { }\n+\n@@ -57,0 +99,2 @@\n+    String testNote;\n+    String output;\n@@ -58,1 +102,1 @@\n-    static String nextCase(String testName) {\n+    BytecodeTracerTest(String note) {\n@@ -60,2 +104,2 @@\n-        return \"======================================================================\\nTest case \"\n-            + testCount + \": \" + testName + \"\\n    \";\n+        testNote = \"======================================================================\\nTest case \"\n+            + testCount + \": \" + note + \"\\n    \";\n@@ -64,1 +108,1 @@\n-    static void logOutput() throws Exception {\n+    void logOutput() throws Exception {\n@@ -72,2 +116,2 @@\n-    static void printClasses(String testName, String classNamePattern, int flags) throws Exception {\n-        System.out.println(nextCase(testName) + \"printClasses(\\\"\" + classNamePattern + \"\\\", \" + flags + \")\");\n+    BytecodeTracerTest printClasses(String classNamePattern, int flags) throws Exception {\n+        System.out.println(testNote + \"printClasses(\\\"\" + classNamePattern + \"\\\", \" + flags + \")\");\n@@ -76,0 +120,1 @@\n+        return this;\n@@ -78,2 +123,2 @@\n-    static void printMethods(String testName, String classNamePattern, String methodPattern, int flags) throws Exception {\n-        System.out.println(nextCase(testName) + \"printMethods(\\\"\" + classNamePattern + \"\\\", \\\"\" + methodPattern + \"\\\", \" + flags + \")\");\n+    BytecodeTracerTest printMethods(String classNamePattern, String methodPattern, int flags) throws Exception {\n+        System.out.println(testNote + \"printMethods(\\\"\" + classNamePattern + \"\\\", \\\"\" + methodPattern + \"\\\", \" + flags + \")\");\n@@ -82,0 +127,17 @@\n+        return this;\n+    }\n+\n+    BytecodeTracerTest printLinkedMethods(String methodPattern) throws Exception {\n+        return printMethods(Linked_className, methodPattern, 0xff);\n+    }\n+\n+    BytecodeTracerTest printLinked2Methods(String methodPattern) throws Exception {\n+        return printMethods(Linked2_className, methodPattern, 0xff);\n+    }\n+\n+    BytecodeTracerTest printUnlinkedMethods(String methodPattern) throws Exception {\n+        return printMethods(Unlinked_className, methodPattern, 0xff);\n+    }\n+\n+    BytecodeTracerTest printUnlinked2Methods(String methodPattern) throws Exception {\n+        return printMethods(Unlinked2_className, methodPattern, 0xff);\n@@ -84,1 +146,1 @@\n-    static void mustMatch(String pattern) {\n+    BytecodeTracerTest mustMatch(String pattern) {\n@@ -97,0 +159,1 @@\n+        return this;\n@@ -99,16 +162,2 @@\n-    public static void main(String args[]) throws Exception {\n-        Linked.doit(args); \/\/ Force \"Linked\" class to be linked (and rewritten);\n-\n-        \/\/ ======\n-        printClasses(\"invokedynamic in linked class\",\n-                     \"BytecodeTracerTest$Linked\", 0xff);\n-        mustMatch(\"invokedynamic bsm=[0-9]+ [0-9]+ <makeConcatWithConstants[(]I[)]Ljava\/lang\/String;>\");\n-        mustMatch(\"BSM: REF_invokeStatic [0-9]+ <java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants[(]\");\n-\n-        \/\/ ======\n-        if (false) { \/\/ disabled due to JDK-8309811\n-        printMethods(\"invokedynamic in unlinked class\",\n-                     \"BytecodeTracerTest$Unlinked\", \"toString\", 0xff);\n-        mustMatch(\"invokedynamic bsm=[0-9]+ [0-9]+ <makeConcatWithConstants[(]I[)]Ljava\/lang\/String;>\");\n-        mustMatch(\"BSM: REF_invokeStatic [0-9]+ <java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants[(]\");\n-        }\n+    static BytecodeTracerTest test(String note) {\n+        return new BytecodeTracerTest(note);\n@@ -117,5 +166,66 @@\n-    public Serializable cast(Unlinked f) {\n-        \/\/ Verifying this method causes the \"Unlinked\" class to be loaded. However\n-        \/\/ the \"Unlinked\" class is never used during the execution of\n-        \/\/ BytecodeTracerTest.main(), so it is not linked by HotSpot.\n-        return f;\n+    public static void main(String args[]) throws Exception {\n+        \/\/ Force \"Linked\" and \"Linked2\" classes to be linked (and rewritten);\n+        Linked.doit(args);\n+        Asserts.assertTrue(Linked2.test_ldc() == 12345, \"must be\");\n+\n+        test(\"invokedynamic in linked class\")\n+            .printClasses(\"BytecodeTracerTest$Linked\", 0xff)\n+            .mustMatch(\"invokedynamic bsm=[0-9]+ [0-9]+ <makeConcatWithConstants[(]I[)]Ljava\/lang\/String;>\")\n+            .mustMatch(\"BSM: REF_invokeStatic [0-9]+ <java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants[(]\")\n+            .mustMatch(\"\\\"num args = [\\\\\\\\]u0001\\\"\"); \/\/ static param for string concat\n+\n+        test(\"invokedynamic in unlinked class\")\n+            .printUnlinkedMethods(\"toString\")\n+            .mustMatch(\"invokedynamic bsm=[0-9]+ [0-9]+ <makeConcatWithConstants[(]I[)]Ljava\/lang\/String;>\");\n+\n+        test(\"ldc in linked class\")\n+            .printLinkedMethods(\"test_ldc\")\n+            .mustMatch(\"ldc BytecodeTracerTest[$]Unloaded\")\n+            .mustMatch(\"fast_aldc \\\"Literal[\\\\\\\\]u5678\\\"\"); \/\/ ldc of String has been rewritten during linking\n+\n+        test(\"ldc in unlinked class\")\n+            .printUnlinkedMethods(\"test_ldc\")\n+            .mustMatch(\" ldc BytecodeTracerTest[$]Unloaded\")\n+            .mustMatch(\" ldc \\\"Literal[\\\\\\\\]u1234\\\"\"); \/\/ ldc of String is not rewritten\n+\n+        test(\"More ldc tests in linked class\")\n+            .printLinked2Methods(\"test_ldc\")\n+            .mustMatch(\"ldc_w 2\")\n+            .mustMatch(\"fast_aldc_w \\\"Hello\\\"\")\n+            .mustMatch(\"BSM: REF_invokeStatic [0-9]+ <Linked2.condyBSM[(]Ljava\/lang\/invoke\/MethodHandles\")\n+            .mustMatch(\"fast_aldc <MethodHandle of kind [0-9]+ index at [0-9]+> [0-9]+ <Linked2.test_ldc[(][)]I>\");\n+\n+        test(\"More ldc tests in unlinked class\")\n+            .printUnlinked2Methods(\"test_ldc\")\n+            .mustMatch(\"ldc_w 2\")\n+            .mustMatch(\"ldc_w \\\"Hello\\\"\")\n+            .mustMatch(\"BSM: REF_invokeStatic [0-9]+ <Unlinked2.condyBSM[(]Ljava\/lang\/invoke\/MethodHandles\")\n+            .mustMatch(\"ldc <MethodHandle of kind [0-9]+ index at [0-9]+> [0-9]+ <Unlinked2.test_ldc[(][)]I>\");\n+\n+        test(\"plain old invoke in linked class\")\n+            .printLinkedMethods(\"test_invoke\")\n+            .mustMatch(\"invokevirtual [0-9]+ <BytecodeTracerTest.virtualMethod[(][)]V>\")\n+            .mustMatch(\"invokestatic [0-9]+ <BytecodeTracerTest.staticMethod[(][)]V>\");\n+\n+        test(\"plain old invoke in unlinked class\")\n+            .printUnlinkedMethods(\"test_invoke\")\n+            .mustMatch(\"invokevirtual [0-9]+ <BytecodeTracerTest.virtualMethod[(][)]V>\")\n+            .mustMatch(\"invokestatic [0-9]+ <BytecodeTracerTest.staticMethod[(][)]V>\");\n+\n+        test(\"invokehandle in linked class\")\n+            .printLinkedMethods(\"test_invokehandle\")\n+            .mustMatch(\"invokehandle [0-9]+ <java\/lang\/invoke\/MethodHandle.invokeExact[(]FLjava\/lang\/String;LBytecodeTracerTest[$]Linked;[)]V>\");\n+\n+        test(\"invokehandle in unlinked class\")\n+            .printUnlinkedMethods(\"test_invokehandle\")\n+            .mustMatch(\"invokevirtual [0-9]+ <java\/lang\/invoke\/MethodHandle.invokeExact[(]FLjava\/lang\/String;LBytecodeTracerTest[$]Unlinked;[)]V>\");\n+\n+        test(\"field in linked class\")\n+            .printLinkedMethods(\"test_field\")\n+            .mustMatch(\"getfield [0-9]+ <BytecodeTracerTest.x:I>\")\n+            .mustMatch(\"putstatic [0-9]+ <BytecodeTracerTest.y:J>\");\n+\n+        test(\"field in unlinked class\")\n+            .printUnlinkedMethods(\"test_field\")\n+            .mustMatch(\"getfield [0-9]+ <BytecodeTracerTest.x:I>\")\n+            .mustMatch(\"putstatic [0-9]+ <BytecodeTracerTest.y:J>\");\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/BytecodeTracerTest.java","additions":145,"deletions":35,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Some test for BytecodeTracerTest.java that can't be easily written in Java.\n+\n+public class Linked2\n+  version 55:0\n+{\n+    public static Method main:\"([Ljava\/lang\/String;)V\"\n+         stack 5 locals 1\n+    {\n+        invokestatic   Method Linked2.test_ldc:\"()I\";\n+        return;\n+    }\n+\n+    public static Method test_ldc:\"()I\"\n+        stack 5 locals 1\n+    {\n+        ldc_w           int 2;\n+        pop;\n+\n+        ldc_w           String \"Hello\";\n+        pop;\n+\n+        ldc             MethodHandle REF_invokeStatic : Linked2.test_ldc:\"()I\";\n+        pop;\n+\n+        ldc             Dynamic REF_invokeStatic:Linked2.condyBSM:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)Ljava\/lang\/Object;\":I:\"I\";\n+        pop;\n+\n+        ldc_w           Dynamic REF_invokeStatic:Linked2.condyBSM:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)Ljava\/lang\/Object;\":I:\"I\";\n+\n+        ireturn;\n+    }\n+\n+    public static Method condyBSM:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)Ljava\/lang\/Object;\"\n+        throws java\/lang\/Throwable\n+        stack 4 locals 6\n+    {\n+        sipush          12345;\n+        invokestatic    Method java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        areturn;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/Linked2.jasm","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8309811\n+ * @requires vm.debug\n+ * @summary Test the output of -XX:+TraceBytecodes, -XX:TraceBytecodesAt, and -XX:TraceBytecodesStopAt\n+ * @run main\/othervm -XX:+TraceBytecodes -XX:TraceBytecodesAt=2000 -XX:TraceBytecodesStopAt=3000 TraceBytecodes\n+ *\/\n+\n+\/\/ This is just a very simple sanity test. Trace about 1000 bytecodes. See the .jtr file for the output.\n+\/\/ Consider it OK if the VM doesn't crash. It should test a fair amount of the code in bytecodeTracer.cpp\n+public class TraceBytecodes {\n+    public static void main(String args[]) {\n+        System.out.println(\"Hello TraceBytecodes\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/TraceBytecodes.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Some test for BytecodeTracerTest.java that can't be easily written in Java.\n+\n+public class Unlinked2\n+  version 55:0\n+{\n+    public static Method main:\"([Ljava\/lang\/String;)V\"\n+         stack 5 locals 1\n+    {\n+        invokestatic   Method Unlinked2.test_ldc:\"()I\";\n+        return;\n+    }\n+\n+    public static Method test_ldc:\"()I\"\n+        stack 5 locals 1\n+    {\n+        ldc_w           int 2;\n+        pop;\n+\n+        ldc_w           String \"Hello\";\n+        pop;\n+\n+        ldc             MethodHandle REF_invokeStatic : Unlinked2.test_ldc:\"()I\";\n+        pop;\n+\n+        ldc             Dynamic REF_invokeStatic:Unlinked2.condyBSM:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)Ljava\/lang\/Object;\":I:\"I\";\n+        pop;\n+\n+        ldc_w           Dynamic REF_invokeStatic:Unlinked2.condyBSM:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)Ljava\/lang\/Object;\":I:\"I\";\n+\n+        ireturn;\n+    }\n+\n+    public static Method condyBSM:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)Ljava\/lang\/Object;\"\n+        throws java\/lang\/Throwable\n+        stack 4 locals 6\n+    {\n+        sipush          12345;\n+        invokestatic    Method java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+        areturn;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/Unlinked2.jasm","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}