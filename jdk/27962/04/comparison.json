{"files":[{"patch":"@@ -1093,0 +1093,4 @@\n+  log_info(gc, cset)(\"Concurrent cycle complete, promotions reserved: %zu, promotions expended: %zu, failed count: %zu, failed bytes: %zu\",\n+                     old_generation()->get_promoted_reserve(), old_generation()->get_promoted_expended(),\n+                     old_generation()->get_promotion_failed_count(), old_generation()->get_promotion_failed_words() * HeapWordSize);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -207,0 +207,2 @@\n+    _promotion_failure_count(0),\n+    _promotion_failure_words(0),\n@@ -243,1 +245,3 @@\n-  AtomicAccess::store(&_promoted_expended, (size_t) 0);\n+  AtomicAccess::store(&_promoted_expended, static_cast<size_t>(0));\n+  AtomicAccess::store(&_promotion_failure_count, static_cast<size_t>(0));\n+  AtomicAccess::store(&_promotion_failure_words, static_cast<size_t>(0));\n@@ -672,0 +676,11 @@\n+  AtomicAccess::inc(&_promotion_failure_count);\n+  AtomicAccess::add(&_promotion_failure_words, size);\n+\n+  LogTarget(Debug, gc, plab) lt;\n+  LogStream ls(lt);\n+  if (lt.is_enabled()) {\n+    log_failed_promotion(ls, thread, size);\n+  }\n+}\n+\n+void ShenandoahOldGeneration::log_failed_promotion(LogStream& ls, Thread* thread, size_t size) const {\n@@ -673,1 +688,1 @@\n-  const size_t MaxReportsPerEpoch = 4;\n+  constexpr size_t MaxReportsPerEpoch = 4;\n@@ -676,4 +691,0 @@\n-  auto heap = ShenandoahGenerationalHeap::heap();\n-\n-  size_t promotion_reserve;\n-  size_t promotion_expended;\n@@ -681,0 +692,1 @@\n+  const auto heap = ShenandoahGenerationalHeap::heap();\n@@ -682,1 +694,0 @@\n-\n@@ -684,6 +695,1 @@\n-    {\n-      \/\/ Promotion failures should be very rare.  Invest in providing useful diagnostic info.\n-      ShenandoahHeapLocker locker(heap->lock());\n-      promotion_reserve = get_promoted_reserve();\n-      promotion_expended = get_promoted_expended();\n-    }\n+    \/\/ Promotion failures should be very rare.  Invest in providing useful diagnostic info.\n@@ -694,6 +700,10 @@\n-    log_info(gc, ergo)(\"Promotion failed, size %zu, has plab? %s, PLAB remaining: %zu\"\n-                       \", plab promotions %s, promotion reserve: %zu, promotion expended: %zu\"\n-                       \", old capacity: %zu, old_used: %zu, old unaffiliated regions: %zu\",\n-                       size * HeapWordSize, plab == nullptr? \"no\": \"yes\",\n-                       words_remaining * HeapWordSize, promote_enabled, promotion_reserve, promotion_expended,\n-                       max_capacity(), used(), free_unaffiliated_regions());\n+    \/\/ Promoted reserve is only changed by vm or control thread. Promoted expended is always accessed atomically.\n+    const size_t promotion_reserve = get_promoted_reserve();\n+    const size_t promotion_expended = get_promoted_expended();\n+\n+    ls.print_cr(\"Promotion failed, size %zu, has plab? %s, PLAB remaining: %zu\"\n+                \", plab promotions %s, promotion reserve: %zu, promotion expended: %zu\"\n+                \", old capacity: %zu, old_used: %zu, old unaffiliated regions: %zu\",\n+                size * HeapWordSize, plab == nullptr? \"no\": \"yes\",\n+                words_remaining * HeapWordSize, promote_enabled, promotion_reserve, promotion_expended,\n+                max_capacity(), used(), free_unaffiliated_regions());\n@@ -701,3 +711,1 @@\n-    if ((gc_id == last_report_epoch) && (epoch_report_count >= MaxReportsPerEpoch)) {\n-      log_debug(gc, ergo)(\"Squelching additional promotion failure reports for current epoch\");\n-    } else if (gc_id != last_report_epoch) {\n+    if (gc_id != last_report_epoch) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":30,"deletions":22,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class LogStream;\n@@ -68,2 +69,2 @@\n-  \/\/ Represents the quantity of live bytes we expect to promote in place during the next\n-  \/\/ evacuation cycle. This value is used by the young heuristic to trigger mixed collections.\n+  \/\/ Represents the quantity of live bytes we expect to promote during the next evacuation\n+  \/\/ cycle. This value is used by the young heuristic to trigger mixed collections.\n@@ -75,1 +76,1 @@\n-  \/\/ objects. This field records the total amount of padding used for such regions.\n+  \/\/ objects). This field records the total amount of padding used for such regions.\n@@ -78,0 +79,5 @@\n+  \/\/ Keep track of the number and size of promotions that failed. Perhaps we should use this to increase\n+  \/\/ the size of the old generation for the next collection cycle.\n+  size_t _promotion_failure_count;\n+  size_t _promotion_failure_words;\n+\n@@ -122,0 +128,4 @@\n+  \/\/ Return the count and size (in words) of failed promotions since the last reset\n+  size_t get_promotion_failed_count() const { return AtomicAccess::load(&_promotion_failure_count); }\n+  size_t get_promotion_failed_words() const { return AtomicAccess::load(&_promotion_failure_words); }\n+\n@@ -140,0 +150,1 @@\n+\n@@ -141,2 +152,2 @@\n-  void set_promotion_potential(size_t val) { _promotion_potential = val; };\n-  size_t get_promotion_potential() const { return _promotion_potential; };\n+  void set_promotion_potential(size_t val) { _promotion_potential = val; }\n+  size_t get_promotion_potential() const { return _promotion_potential; }\n@@ -164,1 +175,1 @@\n-  \/\/ This logs that an evacuation to the old generation has failed\n+  \/\/ Increment promotion failure counters, optionally log a more detailed message\n@@ -166,0 +177,1 @@\n+  void log_failed_promotion(LogStream& ls, Thread* thread, size_t size) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"}]}