{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -392,1 +392,6 @@\n-                         in_ByteSize(frame_data_offset));\n+                         in_ByteSize(frame_data_offset),\n+                         \/*\n+                          * frame size should be in words,\n+                          * and also should include both saved FP and return address\n+                          *\/\n+                         (frame_size \/ wordSize) + 2);\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -596,1 +596,1 @@\n-UpcallStub::UpcallStub(const char* name, CodeBuffer* cb, int size, jobject receiver, ByteSize frame_data_offset) :\n+UpcallStub::UpcallStub(const char* name, CodeBuffer* cb, int size, jobject receiver, ByteSize frame_data_offset, int frame_size) :\n@@ -598,1 +598,1 @@\n-              CodeOffsets::frame_never_safe, 0 \/* no frame size *\/,\n+              CodeOffsets::frame_never_safe, frame_size,\n@@ -610,1 +610,1 @@\n-UpcallStub* UpcallStub::create(const char* name, CodeBuffer* cb, jobject receiver, ByteSize frame_data_offset) {\n+UpcallStub* UpcallStub::create(const char* name, CodeBuffer* cb, jobject receiver, ByteSize frame_data_offset, int frame_size) {\n@@ -617,1 +617,1 @@\n-    blob = new (size) UpcallStub(name, cb, size, receiver, frame_data_offset);\n+    blob = new (size) UpcallStub(name, cb, size, receiver, frame_data_offset, frame_size);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-  UpcallStub(const char* name, CodeBuffer* cb, int size, jobject receiver, ByteSize frame_data_offset);\n+  UpcallStub(const char* name, CodeBuffer* cb, int size, jobject receiver, ByteSize frame_data_offset, int frame_size);\n@@ -618,1 +618,1 @@\n-  static UpcallStub* create(const char* name, CodeBuffer* cb, jobject receiver, ByteSize frame_data_offset);\n+  static UpcallStub* create(const char* name, CodeBuffer* cb, jobject receiver, ByteSize frame_data_offset, int frame_size);\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1309,0 +1309,1 @@\n+  declare_type(UpcallStub,               RuntimeBlob)                     \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -146,0 +146,2 @@\n+  public boolean isUpcallStub()         { return false; }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeBlob.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+    virtualConstructor.addMapping(\"UpcallStub\", UpcallStub.class);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeCache.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.code;\n+\n+import java.util.*;\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.types.*;\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+public class UpcallStub extends RuntimeBlob {\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+  }\n+\n+  private static void initialize(TypeDataBase db) {\n+    Type type = db.lookupType(\"UpcallStub\");\n+  }\n+\n+  public UpcallStub(Address addr) {\n+    super(addr);\n+  }\n+\n+  public boolean isUpcallStub()      { return true; }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/UpcallStub.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.Utils;\n+\n+public class LingeredAppWithFFMUpcall extends LingeredApp {\n+\n+    public static final String THREAD_NAME = \"Upcall thread\";\n+\n+    static {\n+        System.loadLibrary(\"upcall\");\n+    }\n+\n+    public static void upcall() {\n+        try {\n+            Thread.sleep(600000);  \/\/ 10 min\n+        } catch(InterruptedException e) {\n+            \/\/ Ignore\n+        }\n+    }\n+\n+    public static long createFunctionPointerForUpcall() throws NoSuchMethodException, IllegalAccessException {\n+        var mh = MethodHandles.lookup()\n+                              .findStatic(LingeredAppWithFFMUpcall.class, \"upcall\", MethodType.methodType(void.class));\n+        var stub = Linker.nativeLinker()\n+                         .upcallStub(mh, FunctionDescriptor.ofVoid(), Arena.global());\n+        return stub.address();\n+    }\n+\n+    public static native void callJNI(long upcallAddr);\n+\n+    public static void main(String[] args) {\n+        try{\n+            long upcallAddr = createFunctionPointerForUpcall();\n+            (new Thread(() -> callJNI(upcallAddr), THREAD_NAME)).start();\n+            LingeredApp.main(args);\n+        } catch(Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/LingeredAppWithFFMUpcall.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.SA.SATestUtils;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @bug 8339307\n+ * @requires vm.hasSA\n+ * @library \/test\/lib\n+ * @run driver TestJhsdbJstackUpcall\n+ *\/\n+public class TestJhsdbJstackUpcall {\n+\n+    private static final int MAX_ITERATIONS = 20;\n+\n+    \/*\n+     * Test should focus JNI call (caller of upcall) because the frame\n+     * prior to the upcall cannot be obtained if some exception happens\n+     * in during to process upcall.\n+     *\/\n+    private static boolean isJNIFrame(List<String> lines) {\n+        return lines.stream()\n+                    .anyMatch(s -> s.startsWith(\" - LingeredAppWithFFMUpcall.callJNI\"));\n+    }\n+\n+    private static void runJstackInLoop(LingeredApp app) throws Exception {\n+        for (int i = 0; i < MAX_ITERATIONS; i++) {\n+            JDKToolLauncher launcher = JDKToolLauncher\n+                    .createUsingTestJDK(\"jhsdb\");\n+            launcher.addVMArgs(Utils.getTestJavaOpts());\n+            launcher.addToolArg(\"jstack\");\n+            launcher.addToolArg(\"--pid\");\n+            launcher.addToolArg(Long.toString(app.getPid()));\n+\n+            ProcessBuilder pb = SATestUtils.createProcessBuilder(launcher);\n+            Process jhsdb = pb.start();\n+            OutputAnalyzer out = new OutputAnalyzer(jhsdb);\n+\n+            jhsdb.waitFor();\n+\n+            System.out.println(out.getStdout());\n+            System.err.println(out.getStderr());\n+\n+            out.shouldContain(LingeredAppWithFFMUpcall.THREAD_NAME);\n+            if (isJNIFrame(out.asLines())) {\n+                System.out.println(\"DEBUG: Test triggered interesting condition.\");\n+                out.shouldNotContain(\"sun.jvm.hotspot.types.WrongTypeException\");\n+                System.out.println(\"DEBUG: Test PASSED.\");\n+                return; \/\/ If we've reached here, all is well.\n+            }\n+            System.out.println(\"DEBUG: Iteration: \" + (i + 1)\n+                                 + \" - Test didn't trigger interesting condition.\");\n+            out.shouldNotContain(\"sun.jvm.hotspot.types.WrongTypeException\");\n+        }\n+        throw new IllegalStateException(\"Could not find expected frame\");\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        SATestUtils.skipIfCannotAttach(); \/\/ throws SkippedException if attach not expected to work.\n+        LingeredApp app = null;\n+\n+        try {\n+            \/\/ Needed for LingeredApp to be able to resolve native library.\n+            String libPath = System.getProperty(\"java.library.path\");\n+            String[] vmArgs = (libPath != null)\n+                ? Utils.prependTestJavaOpts(\"-Djava.library.path=\" + libPath)\n+                : Utils.getTestJavaOpts();\n+\n+            app = new LingeredAppWithFFMUpcall();\n+            LingeredApp.startAppExactJvmOpts(app, vmArgs);\n+            System.out.println(\"Started LingeredApp with pid \" + app.getPid());\n+            runJstackInLoop(app);\n+            System.out.println(\"Test Completed\");\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            throw e;\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackUpcall.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+typedef void (*upcall_func)(void);\n+\n+JNIEXPORT void JNICALL\n+Java_LingeredAppWithFFMUpcall_callJNI(JNIEnv *env, jclass cls, jlong upcallAddr) {\n+  upcall_func upcall = (upcall_func)upcallAddr;\n+  upcall();\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/libupcall.c","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"}]}