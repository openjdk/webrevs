{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2321,1 +2321,1 @@\n-  const Address  dp_mem(rbp, 6 * wordSize);  \/\/ length is on stack on Win64\n+  const Address dp_mem(rbp, 6 * wordSize);  \/\/ length is on stack on Win64\n@@ -2543,0 +2543,1 @@\n+    __ addq(length, start_offset);\n@@ -2547,0 +2548,1 @@\n+    __ subq(length, start_offset);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import java.util.HexFormat;\n@@ -53,0 +54,2 @@\n+import static java.lang.String.format;\n+\n@@ -72,0 +75,2 @@\n+        length_checks();\n+\n@@ -305,0 +310,114 @@\n+\n+    static final int POSITIONS = 30_000;\n+    static final int BASE_LENGTH = 256;\n+    static final HexFormat HEX_FORMAT = HexFormat.of().withUpperCase().withDelimiter(\" \");\n+\n+    static int[] plainOffsets = new int[POSITIONS + 1];\n+    static byte[] plainBytes;\n+    static int[] base64Offsets = new int[POSITIONS + 1];\n+    static byte[] base64Bytes;\n+\n+    static {\n+        \/\/ Set up ByteBuffer with characters to be encoded\n+        int plainLength = 0;\n+        for (int i = 0; i < plainOffsets.length; i++) {\n+            plainOffsets[i] = plainLength;\n+            int positionLength = (BASE_LENGTH + i) % 2048;\n+            plainLength += positionLength;\n+        }\n+        \/\/ Put one of each possible byte value into ByteBuffer\n+        plainBytes = new byte[plainLength];\n+        for (int i = 0; i < plainBytes.length; i++) {\n+            plainBytes[i] = (byte) i;\n+        }\n+\n+        \/\/ Grab various slices of the ByteBuffer and encode them\n+        ByteBuffer plainBuffer = ByteBuffer.wrap(plainBytes);\n+        int base64Length = 0;\n+        for (int i = 0; i < POSITIONS; i++) {\n+            base64Offsets[i] = base64Length;\n+            int offset = plainOffsets[i];\n+            int length = plainOffsets[i + 1] - offset;\n+            ByteBuffer plainSlice = plainBuffer.slice(offset, length);\n+            base64Length += Base64.getEncoder().encode(plainSlice).remaining();\n+        }\n+\n+        \/\/ Decode the slices created above and ensure lengths match\n+        base64Offsets[base64Offsets.length - 1] = base64Length;\n+        base64Bytes = new byte[base64Length];\n+        for (int i = 0; i < POSITIONS; i++) {\n+            int plainOffset = plainOffsets[i];\n+            ByteBuffer plainSlice = plainBuffer.slice(plainOffset, plainOffsets[i + 1] - plainOffset);\n+            ByteBuffer encodedBytes = Base64.getEncoder().encode(plainSlice);\n+            int base64Offset = base64Offsets[i];\n+            int expectedLength = base64Offsets[i + 1] - base64Offset;\n+            if (expectedLength != encodedBytes.remaining()) {\n+                throw new IllegalStateException(format(\"Unexpected length: %s <> %s\", encodedBytes.remaining(), expectedLength));\n+            }\n+            encodedBytes.get(base64Bytes, base64Offset, expectedLength);\n+        }\n+    }\n+\n+    public static void length_checks() {\n+        decodeAndCheck();\n+        encodeDecode();\n+        System.out.println(\"Test complete, no invalid decodes detected\");\n+    }\n+\n+    \/\/ Use ByteBuffer to cause decode() to use the base + offset form of decode\n+    \/\/ Checks for bug reported in JDK-8321599 where padding characters appear\n+    \/\/ within the beginning of the ByteBuffer *before* the offset.  This caused\n+    \/\/ the decoded string length to be off by 1 or 2 bytes.\n+    static void decodeAndCheck() {\n+        for (int i = 0; i < POSITIONS; i++) {\n+            ByteBuffer encodedBytes = base64BytesAtPosition(i);\n+            ByteBuffer decodedBytes = Base64.getDecoder().decode(encodedBytes);\n+\n+            if (!decodedBytes.equals(plainBytesAtPosition(i))) {\n+                String base64String = base64StringAtPosition(i);\n+                String plainHexString = plainHexStringAtPosition(i);\n+                String decodedHexString = HEX_FORMAT.formatHex(decodedBytes.array(), decodedBytes.arrayOffset() + decodedBytes.position(), decodedBytes.arrayOffset() + decodedBytes.limit());\n+                throw new IllegalStateException(format(\"Mismatch for %s\\n\\nExpected:\\n%s\\n\\nActual:\\n%s\", base64String, plainHexString, decodedHexString));\n+            }\n+        }\n+    }\n+\n+    \/\/ Encode strings of lengths 1-1K, decode, and ensure length and contents correct.\n+    \/\/ This checks that padding characters are properly handled by decode.\n+    static void encodeDecode() {\n+        String allAs = \"A(=)\".repeat(128);\n+        for (int i = 1; i <= 512; i++) {\n+            String encStr = Base64.getEncoder().encodeToString(allAs.substring(0, i).getBytes());\n+            String decStr = new String(Base64.getDecoder().decode(encStr));\n+\n+            if ((decStr.length() != allAs.substring(0, i).length()) ||\n+                (!Objects.equals(decStr, allAs.substring(0, i)))\n+               ) {\n+                throw new IllegalStateException(format(\"Mismatch: Expected: %s\\n          Actual: %s\\n\", allAs.substring(0, i), decStr));\n+            }\n+        }\n+    }\n+\n+    static ByteBuffer plainBytesAtPosition(int position) {\n+        int offset = plainOffsets[position];\n+        int length = plainOffsets[position + 1] - offset;\n+        return ByteBuffer.wrap(plainBytes, offset, length);\n+    }\n+\n+    static String plainHexStringAtPosition(int position) {\n+        int offset = plainOffsets[position];\n+        int length = plainOffsets[position + 1] - offset;\n+        return HEX_FORMAT.formatHex(plainBytes, offset, offset + length);\n+    }\n+\n+    static String base64StringAtPosition(int position) {\n+        int offset = base64Offsets[position];\n+        int length = base64Offsets[position + 1] - offset;\n+        return new String(base64Bytes, offset, length, StandardCharsets.UTF_8);\n+    }\n+\n+    static ByteBuffer base64BytesAtPosition(int position) {\n+        int offset = base64Offsets[position];\n+        int length = base64Offsets[position + 1] - offset;\n+        return ByteBuffer.wrap(base64Bytes, offset, length);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/TestBase64.java","additions":120,"deletions":1,"binary":false,"changes":121,"status":"modified"}]}