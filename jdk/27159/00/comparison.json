{"files":[{"patch":"@@ -254,0 +254,37 @@\n+\/\/ Ergonomic construction for creating ad-hoc VMErrorCallback which automatically\n+\/\/ calls the provided invocable f if a VM crash occurs within its lifetime.\n+\/\/ Can be used to instrument a build for more detailed contextual information\n+\/\/ gathering. Especially useful when hunting down intermittent bugs, or issues\n+\/\/ only reproducible in environments where access to a debugger is not readily\n+\/\/ available. Example use:\n+\/*\n+  {\n+    \/\/ Note the lambda is invoked after an error occurs within this thread,\n+    \/\/ and during on_error's lifetime. If state prior to the crash is required,\n+    \/\/ capture a copy of it first.\n+    auto important_value = get_the_value();\n+\n+    OnVMError on_error([&](outputStream* st) {\n+      \/\/ Dump the important bits.\n+      st->print(\"Prior value: \");\n+      important_value.print_on(st);\n+      st->print(\"During crash: \")\n+      get_the_value().print_on(st);\n+      \/\/ Dump whole the whole state.\n+      this->print_on(st);\n+    });\n+\n+    \/\/ Sometimes doing a thing will crash the VM.\n+    do_a_thing();\n+  }\n+*\/\n+template <typename F>\n+class OnVMError : F, public VMErrorCallback, public VMErrorCallbackMark {\n+  void call(outputStream* st) final { this->operator()(st); }\n+\n+public:\n+  OnVMError(F&& f) : F(static_cast<F&&>(f)), VMErrorCallbackMark(this) {}\n+};\n+\n+template <typename F> OnVMError(F) -> OnVMError<F>;\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"}]}