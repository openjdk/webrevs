{"files":[{"patch":"@@ -277,2 +277,2 @@\n-    \/\/ Sometimes doing a thing will crash the VM.\n-    do_a_thing();\n+    \/\/ When VM crashes, the above lambda will be invoked and print relevant info.\n+    might_cause_vm_crash();\n@@ -281,3 +281,6 @@\n-template <typename F>\n-class OnVMError : F, public VMErrorCallback, public VMErrorCallbackMark {\n-  void call(outputStream* st) final { this->operator()(st); }\n+template <typename CallableType>\n+class OnVMError : public VMErrorCallback {\n+  CallableType _callable;\n+  VMErrorCallbackMark _mark;\n+\n+  void call(outputStream* st) final { _callable(st); }\n@@ -286,1 +289,2 @@\n-  OnVMError(F&& f) : F(static_cast<F&&>(f)), VMErrorCallbackMark(this) {}\n+  template <typename Callable>\n+  OnVMError(Callable&& callable) : VMErrorCallback(), _callable(static_cast<Callable&&>(callable)), _mark(this) {}\n@@ -289,1 +293,8 @@\n-template <typename F> OnVMError(F) -> OnVMError<F>;\n+\/\/ This deduction rule enables creating a type with out using auto, decltype\n+\/\/ and\/or helping construction functions. It enables the generic template type\n+\/\/ to be deduced in the following code:\n+\/\/   OnVMError on_error([&](outputStream* st) { ... })\n+\/\/ Rather than having to something along the lines of:\n+\/\/   auto f = [&](outputStream* st) { ... };\n+\/\/   OnVMError<decltype(f)> on_error(f);\n+template <typename CallableType> OnVMError(CallableType) -> OnVMError<CallableType>;\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"}]}