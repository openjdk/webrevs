{"files":[{"patch":"@@ -115,0 +115,11 @@\n+    \/**\n+      * The annotation visitor to which this visitor must delegate method calls. May be {@literal\n+      * null}.\n+      *\n+      * @return the annotation visitor to which this visitor must delegate method calls, or {@literal\n+      *     null}.\n+      *\/\n+    public AnnotationVisitor getDelegate() {\n+        return av;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/AnnotationVisitor.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -406,1 +406,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ByteVector.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -410,1 +410,1 @@\n-      * Returns the internal of name of the super class (see {@link Type#getInternalName()}). For\n+      * Returns the internal name of the super class (see {@link Type#getInternalName()}). For\n@@ -2085,0 +2085,1 @@\n+            readBytecodeInstructionOffset(currentBytecodeOffset);\n@@ -2700,0 +2701,14 @@\n+    \/**\n+      * Handles the bytecode offset of the next instruction to be visited in {@link\n+      * #accept(ClassVisitor,int)}. This method is called just before the instruction and before its\n+      * associated label and stack map frame, if any. The default implementation of this method does\n+      * nothing. Subclasses can override this method to store the argument in a mutable field, for\n+      * instance, so that {@link MethodVisitor} instances can get the bytecode offset of each visited\n+      * instruction (if so, the usual concurrency issues related to mutable data should be addressed).\n+      *\n+      * @param bytecodeOffset the bytecode offset of the next instruction to be visited.\n+      *\/\n+    protected void readBytecodeInstructionOffset(final int bytecodeOffset) {\n+        \/\/ Do nothing by default.\n+    }\n+\n@@ -3885,1 +3900,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -77,1 +77,2 @@\n-      * @param className the internal name of the class.\n+      * @param className the internal name of the class (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -87,1 +88,1 @@\n-      * Returns the internal name of the class.\n+      * Returns the internal name of the class (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -104,1 +105,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassTooLargeException.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -114,0 +114,9 @@\n+    \/**\n+      * The class visitor to which this visitor must delegate method calls. May be {@literal null}.\n+      *\n+      * @return the class visitor to which this visitor must delegate method calls, or {@literal null}.\n+      *\/\n+    public ClassVisitor getDelegate() {\n+        return cv;\n+    }\n+\n@@ -188,1 +197,2 @@\n-      * @param nestHost the internal name of the host class of the nest.\n+      * @param nestHost the internal name of the host class of the nest (see {@link\n+      *     Type#getInternalName()}).\n@@ -200,2 +210,2 @@\n-      * Visits the enclosing class of the class. This method must be called only if the class has an\n-      * enclosing class.\n+      * Visits the enclosing class of the class. This method must be called only if this class is a\n+      * local or anonymous class. See the JVMS 4.7.7 section for more details.\n@@ -203,1 +213,2 @@\n-      * @param owner internal name of the enclosing class of the class.\n+      * @param owner internal name of the enclosing class of the class (see {@link\n+      *     Type#getInternalName()}).\n@@ -205,1 +216,3 @@\n-      *     not enclosed in a method of its enclosing class.\n+      *     not enclosed in a method or constructor of its enclosing class (e.g. if it is enclosed in\n+      *     an instance initializer, static initializer, instance variable initializer, or class\n+      *     variable initializer).\n@@ -207,1 +220,3 @@\n-      *     the class is not enclosed in a method of its enclosing class.\n+      *     the class is not enclosed in a method or constructor of its enclosing class (e.g. if it is\n+      *     enclosed in an instance initializer, static initializer, instance variable initializer, or\n+      *     class variable initializer).\n@@ -274,1 +289,1 @@\n-      * @param nestMember the internal name of a nest member.\n+      * @param nestMember the internal name of a nest member (see {@link Type#getInternalName()}).\n@@ -289,1 +304,2 @@\n-      * @param permittedSubclass the internal name of a permitted subclass.\n+      * @param permittedSubclass the internal name of a permitted subclass (see {@link\n+      *     Type#getInternalName()}).\n@@ -302,1 +318,4 @@\n-      * class being visited.\n+      * class being visited. More precisely, every class or interface C which is referenced by this\n+      * class and which is not a package member must be visited with this method. This class must\n+      * reference its nested class or interface members, and its enclosing class, if any. See the JVMS\n+      * 4.7.6 section for more details.\n@@ -304,7 +323,7 @@\n-      * @param name the internal name of an inner class (see {@link Type#getInternalName()}).\n-      * @param outerName the internal name of the class to which the inner class belongs (see {@link\n-      *     Type#getInternalName()}). May be {@literal null} for not member classes.\n-      * @param innerName the (simple) name of the inner class inside its enclosing class. May be\n-      *     {@literal null} for anonymous inner classes.\n-      * @param access the access flags of the inner class as originally declared in the enclosing\n-      *     class.\n+      * @param name the internal name of C (see {@link Type#getInternalName()}).\n+      * @param outerName the internal name of the class or interface C is a member of (see {@link\n+      *     Type#getInternalName()}). Must be {@literal null} if C is not the member of a class or\n+      *     interface (e.g. for local or anonymous classes).\n+      * @param innerName the (simple) name of C. Must be {@literal null} for anonymous inner classes.\n+      * @param access the access flags of C originally declared in the source code from which this\n+      *     class was compiled.\n@@ -408,1 +427,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassVisitor.java","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -252,0 +252,1 @@\n+      * MethodWriter#COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link\n@@ -877,1 +878,1 @@\n-      * @param value the internal name of the class.\n+      * @param value the internal name of the class (see {@link Type#getInternalName()}).\n@@ -929,1 +930,2 @@\n-      * @param owner the internal name of the field or method owner class.\n+      * @param owner the internal name of the field or method owner class (see {@link\n+      *     Type#getInternalName()}).\n@@ -951,1 +953,2 @@\n-      * @param owner the internal name of the field or method owner class.\n+      * @param owner the internal name of the field or method owner class (see {@link\n+      *     Type#getInternalName()}).\n@@ -1013,1 +1016,1 @@\n-      * @param owner the internal name of the field's owner class.\n+      * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\n@@ -1027,1 +1030,2 @@\n-      * @param owner the internal name of the method's owner class.\n+      * @param owner the internal name of the method's owner class (see {@link\n+      *     Type#getInternalName()}).\n@@ -1063,3 +1067,4 @@\n-      * @param type1 the internal name of a class.\n-      * @param type2 the internal name of another class.\n-      * @return the internal name of the common super class of the two given classes.\n+      * @param type1 the internal name of a class (see {@link Type#getInternalName()}).\n+      * @param type2 the internal name of another class (see {@link Type#getInternalName()}).\n+      * @return the internal name of the common super class of the two given classes (see {@link\n+      *     Type#getInternalName()}).\n@@ -1108,1 +1113,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassWriter.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -211,1 +211,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ConstantDynamic.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -254,1 +254,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Constants.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -169,1 +169,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Context.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/CurrentFrame.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -124,1 +124,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Edge.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -111,0 +111,9 @@\n+    \/**\n+      * The field visitor to which this visitor must delegate method calls. May be {@literal null}.\n+      *\n+      * @return the field visitor to which this visitor must delegate method calls, or {@literal null}.\n+      *\/\n+    public FieldVisitor getDelegate() {\n+        return fv;\n+    }\n+\n@@ -171,1 +180,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/FieldVisitor.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -317,1 +317,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/FieldWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -99,2 +99,2 @@\n- *       #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND}, {@link #LOCAL_KIND}\n- *       or {@link #STACK_KIND}.\n+ *       #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND}, {@link\n+ *       #FORWARD_UNINITIALIZED_KIND},{@link #LOCAL_KIND} or {@link #STACK_KIND}.\n@@ -113,1 +113,4 @@\n- *             table of a SymbolTable, if KIND is equal to {@link #UNINITIALIZED_KIND}.\n+ *             table of a {@link SymbolTable}, if KIND is equal to {@link #UNINITIALIZED_KIND}.\n+ *         <li>the index of a {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG} {@link Symbol} in the\n+ *             type table of a {@link SymbolTable}, if KIND is equal to {@link\n+ *             #FORWARD_UNINITIALIZED_KIND}.\n@@ -123,4 +126,4 @@\n- * abstract type value). Input frames can only contain CONSTANT_KIND, REFERENCE_KIND or\n- * UNINITIALIZED_KIND abstract types of positive or {@literal null} array dimension. In all cases\n- * the type table contains only internal type names (array type descriptors are forbidden - array\n- * dimensions must be represented through the DIM field).\n+ * abstract type value). Input frames can only contain CONSTANT_KIND, REFERENCE_KIND,\n+ * UNINITIALIZED_KIND or FORWARD_UNINITIALIZED_KIND abstract types of positive or {@literal null}\n+ * array dimension. In all cases the type table contains only internal type names (array type\n+ * descriptors are forbidden - array dimensions must be represented through the DIM field).\n@@ -194,2 +197,3 @@\n-    private static final int LOCAL_KIND = 4 << KIND_SHIFT;\n-    private static final int STACK_KIND = 5 << KIND_SHIFT;\n+    private static final int FORWARD_UNINITIALIZED_KIND = 4 << KIND_SHIFT;\n+    private static final int LOCAL_KIND = 5 << KIND_SHIFT;\n+    private static final int STACK_KIND = 6 << KIND_SHIFT;\n@@ -255,7 +259,7 @@\n-      * UNINITIALIZED or UNINITIALIZED_THIS abstract type must replace <i>every occurrence<\/i> of this\n-      * type in the local variables and in the operand stack. This cannot be done during the first step\n-      * of the algorithm since, during this step, the local variables and the operand stack types are\n-      * still abstract. It is therefore necessary to store the abstract types of the constructors which\n-      * are invoked in the basic block, in order to do this replacement during the second step of the\n-      * algorithm, where the frames are fully computed. Note that this array can contain abstract types\n-      * that are relative to the input locals or to the input stack.\n+      * UNINITIALIZED, FORWARD_UNINITIALIZED or UNINITIALIZED_THIS abstract type must replace <i>every\n+      * occurrence<\/i> of this type in the local variables and in the operand stack. This cannot be\n+      * done during the first step of the algorithm since, during this step, the local variables and\n+      * the operand stack types are still abstract. It is therefore necessary to store the abstract\n+      * types of the constructors which are invoked in the basic block, in order to do this replacement\n+      * during the second step of the algorithm, where the frames are fully computed. Note that this\n+      * array can contain abstract types that are relative to the input locals or to the input stack.\n@@ -319,2 +323,6 @@\n-            return UNINITIALIZED_KIND\n-                    | symbolTable.addUninitializedType(\"\", ((Label) type).bytecodeOffset);\n+            Label label = (Label) type;\n+            if ((label.flags & Label.FLAG_RESOLVED) != 0) {\n+                return UNINITIALIZED_KIND | symbolTable.addUninitializedType(\"\", label.bytecodeOffset);\n+            } else {\n+                return FORWARD_UNINITIALIZED_KIND | symbolTable.addForwardUninitializedType(\"\", label);\n+            }\n@@ -402,1 +410,2 @@\n-                        throw new IllegalArgumentException();\n+                        throw new IllegalArgumentException(\n+                                \"Invalid descriptor fragment: \" + buffer.substring(elementDescriptorOffset));\n@@ -406,1 +415,1 @@\n-                throw new IllegalArgumentException();\n+                throw new IllegalArgumentException(\"Invalid descriptor: \" + buffer.substring(offset));\n@@ -614,1 +623,1 @@\n-            outputStackTop -= (short) elements;\n+            outputStackTop -= (short)elements;\n@@ -671,2 +680,3 @@\n-      *     UNINITIALIZED_THIS or an UNINITIALIZED_KIND abstract type for one of the types on which a\n-      *     constructor is invoked in the basic block. Otherwise returns abstractType.\n+      *     UNINITIALIZED_THIS or an UNINITIALIZED_KIND or FORWARD_UNINITIALIZED_KIND abstract type for\n+      *     one of the types on which a constructor is invoked in the basic block. Otherwise returns\n+      *     abstractType.\n@@ -676,1 +686,2 @@\n-                || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND) {\n+                || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND\n+                || (abstractType & (DIM_MASK | KIND_MASK)) == FORWARD_UNINITIALIZED_KIND) {\n@@ -1287,2 +1298,3 @@\n-      *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND} or {@link\n-      *     #UNINITIALIZED_KIND} kind, with positive or {@literal null} array dimensions.\n+      *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link\n+      *     #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND} kind, with positive or\n+      *     {@literal null} array dimensions.\n@@ -1290,2 +1302,2 @@\n-      *     {@link #REFERENCE_KIND} or {@link #UNINITIALIZED_KIND} kind, with positive or {@literal\n-      *     null} array dimensions.\n+      *     {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND}\n+      *     kind, with positive or {@literal null} array dimensions.\n@@ -1434,1 +1446,2 @@\n-      *     Frame#REFERENCE_KIND} or {@link Frame#UNINITIALIZED_KIND} types.\n+      *     Frame#REFERENCE_KIND}, {@link Frame#UNINITIALIZED_KIND} or {@link\n+      *     Frame#FORWARD_UNINITIALIZED_KIND} types.\n@@ -1456,0 +1469,4 @@\n+                case FORWARD_UNINITIALIZED_KIND:\n+                    output.putByte(ITEM_UNINITIALIZED);\n+                    symbolTable.getForwardUninitializedLabel(typeValue).put(output);\n+                    break;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Frame.java","additions":46,"deletions":29,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-      *     handle.\n+      *     handle (see {@link Type#getInternalName()}).\n@@ -119,1 +119,1 @@\n-      *     handle.\n+      *     handle (see {@link Type#getInternalName()}).\n@@ -152,1 +152,2 @@\n-      * @return the internal name of the class that owns the field or method designated by this handle.\n+      * @return the internal name of the class that owns the field or method designated by this handle\n+      *     (see {@link Type#getInternalName()}).\n@@ -221,1 +222,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Handle.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Handler.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -116,0 +116,3 @@\n+    \/** A flag indicating that this label has at least one associated line number. *\/\n+    static final int FLAG_LINE_NUMBER = 128;\n+\n@@ -148,0 +151,7 @@\n+    \/**\n+      * The type of forward references stored in two bytes in the <i>stack map table<\/i>. This is the\n+      * case of the labels of {@link Frame#ITEM_UNINITIALIZED} stack map frame elements, when the NEW\n+      * instruction is after the &lt;init&gt; constructor call (in bytecode offset order).\n+      *\/\n+    static final int FORWARD_REFERENCE_TYPE_STACK_MAP = 0x30000000;\n+\n@@ -180,3 +190,3 @@\n-      * The source line number corresponding to this label, or 0. If there are several source line\n-      * numbers corresponding to this label, the first one is stored in this field, and the remaining\n-      * ones are stored in {@link #otherLineNumbers}.\n+      * The source line number corresponding to this label, if {@link #FLAG_LINE_NUMBER} is set. If\n+      * there are several source line numbers corresponding to this label, the first one is stored in\n+      * this field, and the remaining ones are stored in {@link #otherLineNumbers}.\n@@ -367,1 +377,2 @@\n-        if (this.lineNumber == 0) {\n+        if ((flags & FLAG_LINE_NUMBER) == 0) {\n+            flags |= FLAG_LINE_NUMBER;\n@@ -391,1 +402,1 @@\n-        if (visitLineNumbers && lineNumber != 0) {\n+        if (visitLineNumbers && (flags & FLAG_LINE_NUMBER) != 0) {\n@@ -435,0 +446,14 @@\n+    \/**\n+      * Puts a reference to this label in the <i>stack map table<\/i> of a method. If the bytecode\n+      * offset of the label is known, it is written directly. Otherwise, a null relative offset is\n+      * written and a new forward reference is declared for this label.\n+      *\n+      * @param stackMapTableEntries the stack map table where the label offset must be added.\n+      *\/\n+    final void put(final ByteVector stackMapTableEntries) {\n+        if ((flags & FLAG_RESOLVED) == 0) {\n+            addForwardReference(0, FORWARD_REFERENCE_TYPE_STACK_MAP, stackMapTableEntries.length);\n+        }\n+        stackMapTableEntries.putShort(bytecodeOffset);\n+    }\n+\n@@ -467,1 +492,2 @@\n-      * where left in the bytecode by each forward reference previously added to this label.\n+      * where left in the bytecode (and optionally in the stack map table) by each forward reference\n+      * previously added to this label.\n@@ -470,0 +496,2 @@\n+      * @param stackMapTableEntries the 'entries' array of the StackMapTable code attribute of the\n+      *     method. Maybe {@literal null}.\n@@ -477,1 +505,2 @@\n-    final boolean resolve(final byte[] code, final int bytecodeOffset) {\n+    final boolean resolve(\n+            final byte[] code, final ByteVector stackMapTableEntries, final int bytecodeOffset) {\n@@ -507,1 +536,1 @@\n-            } else {\n+            } else if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_WIDE) {\n@@ -512,0 +541,3 @@\n+            } else {\n+                stackMapTableEntries.data[handle++] = (byte) (bytecodeOffset >>> 8);\n+                stackMapTableEntries.data[handle] = (byte) bytecodeOffset;\n@@ -655,1 +687,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Label.java","additions":40,"deletions":9,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-      * @param className the internal name of the owner class.\n+      * @param className the internal name of the owner class (see {@link Type#getInternalName()}).\n@@ -99,1 +99,1 @@\n-      * @return the internal name of the owner class.\n+      * @return the internal name of the owner class (see {@link Type#getInternalName()}).\n@@ -132,1 +132,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/MethodTooLargeException.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n- * {@code visitAnnotableParameterCount} | {@code visitParameterAnnotation} {@code\n+ * {@code visitAnnotableParameterCount} | {@code visitParameterAnnotation} | {@code\n@@ -127,0 +127,10 @@\n+    \/**\n+      * The method visitor to which this visitor must delegate method calls. May be {@literal null}.\n+      *\n+      * @return the method visitor to which this visitor must delegate method calls, or {@literal\n+      *     null}.\n+      *\/\n+    public MethodVisitor getDelegate() {\n+        return mv;\n+    }\n+\n@@ -153,1 +163,1 @@\n-      *     exacly one visit method must be called on this annotation visitor, followed by visitEnd.\n+      *     exactly one visit method must be called on this annotation visitor, followed by visitEnd.\n@@ -306,1 +316,2 @@\n-      * @param numLocal the number of local variables in the visited frame.\n+      * @param numLocal the number of local variables in the visited frame. Long and double values\n+      *     count for one variable.\n@@ -311,4 +322,5 @@\n-      *     Reference types are represented by String objects (representing internal names), and\n-      *     uninitialized types by Label objects (this label designates the NEW instruction that\n-      *     created this uninitialized value).\n-      * @param numStack the number of operand stack elements in the visited frame.\n+      *     Reference types are represented by String objects (representing internal names, see {@link\n+      *     Type#getInternalName()}), and uninitialized types by Label objects (this label designates\n+      *     the NEW instruction that created this uninitialized value).\n+      * @param numStack the number of operand stack elements in the visited frame. Long and double\n+      *     values count for one stack element.\n@@ -393,1 +405,1 @@\n-      * a class as parameter.\n+      * a class as parameter (see {@link Type#getInternalName()}).\n@@ -676,2 +688,3 @@\n-      * @param type the internal name of the type of exceptions handled by the handler, or {@literal\n-      *     null} to catch any exceptions (for \"finally\" blocks).\n+      * @param type the internal name of the type of exceptions handled by the handler (see {@link\n+      *     Type#getInternalName()}), or {@literal null} to catch any exceptions (for \"finally\"\n+      *     blocks).\n@@ -815,1 +828,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/MethodVisitor.java","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -569,2 +569,3 @@\n-      * but restricted to {@link Frame#CONSTANT_KIND}, {@link Frame#REFERENCE_KIND} or {@link\n-      * Frame#UNINITIALIZED_KIND} abstract types. Long and double types use only one array entry.\n+      * but restricted to {@link Frame#CONSTANT_KIND}, {@link Frame#REFERENCE_KIND}, {@link\n+      * Frame#UNINITIALIZED_KIND} or {@link Frame#FORWARD_UNINITIALIZED_KIND} abstract types. Long and\n+      * double types use only one array entry.\n@@ -728,1 +729,1 @@\n-                        new AnnotationWriter[Type.getArgumentTypes(descriptor).length];\n+                        new AnnotationWriter[Type.getArgumentCount(descriptor)];\n@@ -736,1 +737,1 @@\n-                        new AnnotationWriter[Type.getArgumentTypes(descriptor).length];\n+                        new AnnotationWriter[Type.getArgumentCount(descriptor)];\n@@ -1234,1 +1235,1 @@\n-        hasAsmInstructions |= label.resolve(code.data, code.length);\n+        hasAsmInstructions |= label.resolve(code.data, stackMapTableEntries, code.length);\n@@ -1247,1 +1248,1 @@\n-                    currentBasicBlock.flags |= (short) (label.flags & Label.FLAG_JUMP_TARGET);\n+                    currentBasicBlock.flags |= (short)(label.flags & Label.FLAG_JUMP_TARGET);\n@@ -1263,1 +1264,1 @@\n-                    lastBasicBlock.flags |= (short) (label.flags & Label.FLAG_JUMP_TARGET);\n+                    lastBasicBlock.flags |= (short)(label.flags & Label.FLAG_JUMP_TARGET);\n@@ -1830,1 +1831,1 @@\n-            nextBasicBlock.resolve(code.data, code.length);\n+            nextBasicBlock.resolve(code.data, stackMapTableEntries, code.length);\n@@ -2014,3 +2015,2 @@\n-            stackMapTableEntries\n-                    .putByte(Frame.ITEM_UNINITIALIZED)\n-                    .putShort(((Label) type).bytecodeOffset);\n+            stackMapTableEntries.putByte(Frame.ITEM_UNINITIALIZED);\n+            ((Label) type).put(stackMapTableEntries);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/MethodWriter.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -113,0 +113,10 @@\n+    \/**\n+      * The module visitor to which this visitor must delegate method calls. May be {@literal null}.\n+      *\n+      * @return the module visitor to which this visitor must delegate method calls, or {@literal\n+      *     null}.\n+      *\/\n+    public ModuleVisitor getDelegate() {\n+        return mv;\n+    }\n+\n@@ -116,1 +126,2 @@\n-      * @param mainClass the internal name of the main class of the current module.\n+      * @param mainClass the internal name of the main class of the current module (see {@link\n+      *     Type#getInternalName()}).\n@@ -127,1 +138,1 @@\n-      * @param packaze the internal name of a package.\n+      * @param packaze the internal name of a package (see {@link Type#getInternalName()}).\n@@ -152,1 +163,1 @@\n-      * @param packaze the internal name of the exported package.\n+      * @param packaze the internal name of the exported package (see {@link Type#getInternalName()}).\n@@ -167,1 +178,1 @@\n-      * @param packaze the internal name of the opened package.\n+      * @param packaze the internal name of the opened package (see {@link Type#getInternalName()}).\n@@ -183,1 +194,1 @@\n-      * @param service the internal name of the service.\n+      * @param service the internal name of the service (see {@link Type#getInternalName()}).\n@@ -194,3 +205,3 @@\n-      * @param service the internal name of the service.\n-      * @param providers the internal names of the implementations of the service (there is at least\n-      *     one provider).\n+      * @param service the internal name of the service (see {@link Type#getInternalName()}).\n+      * @param providers the internal names (see {@link Type#getInternalName()}) of the implementations\n+      *     of the service (there is at least one provider).\n@@ -214,1 +225,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ModuleVisitor.java","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -286,1 +286,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ModuleWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -591,1 +591,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    \/*package-private*\/ RecordComponentVisitor delegate;\n+    protected RecordComponentVisitor delegate;\n@@ -116,1 +116,2 @@\n-      * @return the record visitor to which this visitor must delegate method calls or {@literal null}.\n+      * @return the record visitor to which this visitor must delegate method calls, or {@literal\n+      *     null}.\n@@ -181,1 +182,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/RecordComponentVisitor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -258,1 +258,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/RecordComponentWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -138,1 +138,5 @@\n-      * The tag value of an {@link Frame#ITEM_UNINITIALIZED} type entry in the type table of a class.\n+      * The tag value of an uninitialized type entry in the type table of a class. This type is used\n+      * for the normal case where the NEW instruction is before the &lt;init&gt; constructor call (in\n+      * bytecode offset order), i.e. when the label of the NEW instruction is resolved when the\n+      * constructor call is visited. If the NEW instruction is after the constructor call, use the\n+      * {@link #FORWARD_UNINITIALIZED_TYPE_TAG} tag value instead.\n@@ -142,0 +146,9 @@\n+    \/**\n+      * The tag value of an uninitialized type entry in the type table of a class. This type is used\n+      * for the unusual case where the NEW instruction is after the &lt;init&gt; constructor call (in\n+      * bytecode offset order), i.e. when the label of the NEW instruction is not resolved when the\n+      * constructor call is visited. If the NEW instruction is before the constructor call, use the\n+      * {@link #UNINITIALIZED_TYPE_TAG} tag value instead.\n+      *\/\n+    static final int FORWARD_UNINITIALIZED_TYPE_TAG = 130;\n+\n@@ -143,1 +156,1 @@\n-    static final int MERGED_TYPE_TAG = 130;\n+    static final int MERGED_TYPE_TAG = 131;\n@@ -186,2 +199,2 @@\n-      *   <li>an internal class name for {@link #CONSTANT_CLASS_TAG}, {@link #TYPE_TAG} and {@link\n-      *       #UNINITIALIZED_TYPE_TAG} symbols,\n+      *   <li>an internal class name for {@link #CONSTANT_CLASS_TAG}, {@link #TYPE_TAG}, {@link\n+      *       #UNINITIALIZED_TYPE_TAG} and {@link #FORWARD_UNINITIALIZED_TYPE_TAG} symbols,\n@@ -207,0 +220,3 @@\n+      *   <li>the index of the {@link Label} (in the {@link SymbolTable#labelTable} table) of the NEW\n+      *       instruction that created an {@link Frame#ITEM_UNINITIALIZED} type for {@link\n+      *       #FORWARD_UNINITIALIZED_TYPE_TAG} symbols,\n@@ -276,1 +292,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Symbol.java","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -143,2 +143,3 @@\n-      * Symbol#TYPE_TAG} and {@link Symbol#UNINITIALIZED_TYPE_TAG}) Symbol. The type symbol at index\n-      * {@code i} has its {@link Symbol#index} equal to {@code i} (and vice versa).\n+      * Symbol#TYPE_TAG}, {@link Symbol#UNINITIALIZED_TYPE_TAG},{@link\n+      * Symbol#FORWARD_UNINITIALIZED_TYPE_TAG} and {@link Symbol#MERGED_TYPE_TAG} entries. The type\n+      * symbol at index {@code i} has its {@link Symbol#index} equal to {@code i} (and vice versa).\n@@ -148,0 +149,23 @@\n+    \/**\n+      * The actual number of {@link LabelEntry} in {@link #labelTable}. These elements are stored from\n+      * index 0 to labelCount (excluded). The other array entries are empty. These label entries are\n+      * also stored in the {@link #labelEntries} hash set.\n+      *\/\n+    private int labelCount;\n+\n+    \/**\n+      * The labels corresponding to the \"forward uninitialized\" types in the ASM specific {@link\n+      * typeTable} (see {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}). The label entry at index {@code\n+      * i} has its {@link LabelEntry#index} equal to {@code i} (and vice versa).\n+      *\/\n+    private LabelEntry[] labelTable;\n+\n+    \/**\n+      * A hash set of all the {@link LabelEntry} elements in the {@link #labelTable}. Each {@link\n+      * LabelEntry} instance is stored at the array index given by its hash code modulo the array size.\n+      * If several entries must be stored at the same array index, they are linked together via their\n+      * {@link LabelEntry#next} field. The {@link #getOrAddLabelEntry(Label)} method ensures that this\n+      * table does not contain duplicated entries.\n+      *\/\n+    private LabelEntry[] labelEntries;\n+\n@@ -1164,0 +1188,12 @@\n+    \/**\n+      * Returns the label corresponding to the \"forward uninitialized\" type table element whose index\n+      * is given.\n+      *\n+      * @param typeIndex the type table index of a \"forward uninitialized\" type table element.\n+      * @return the label corresponding of the NEW instruction which created this \"forward\n+      *     uninitialized\" type.\n+      *\/\n+    Label getForwardUninitializedLabel(final int typeIndex) {\n+        return labelTable[(int) typeTable[typeIndex].data].label;\n+    }\n+\n@@ -1184,2 +1220,2 @@\n-      * Adds an {@link Frame#ITEM_UNINITIALIZED} type in the type table of this symbol table. Does\n-      * nothing if the type table already contains a similar type.\n+      * Adds an uninitialized type in the type table of this symbol table. Does nothing if the type\n+      * table already contains a similar type.\n@@ -1188,3 +1224,3 @@\n-      * @param bytecodeOffset the bytecode offset of the NEW instruction that created this {@link\n-      *     Frame#ITEM_UNINITIALIZED} type value.\n-      * @return the index of a new or already existing type Symbol with the given value.\n+      * @param bytecodeOffset the bytecode offset of the NEW instruction that created this\n+      *     uninitialized type value.\n+      * @return the index of a new or already existing type #@link Symbol} with the given value.\n@@ -1208,0 +1244,26 @@\n+    \/**\n+      * Adds a \"forward uninitialized\" type in the type table of this symbol table. Does nothing if the\n+      * type table already contains a similar type.\n+      *\n+      * @param value an internal class name.\n+      * @param label the label of the NEW instruction that created this uninitialized type value. If\n+      *     the label is resolved, use the {@link #addUninitializedType} method instead.\n+      * @return the index of a new or already existing type {@link Symbol} with the given value.\n+      *\/\n+    int addForwardUninitializedType(final String value, final Label label) {\n+        int labelIndex = getOrAddLabelEntry(label).index;\n+        int hashCode = hash(Symbol.FORWARD_UNINITIALIZED_TYPE_TAG, value, labelIndex);\n+        Entry entry = get(hashCode);\n+        while (entry != null) {\n+            if (entry.tag == Symbol.FORWARD_UNINITIALIZED_TYPE_TAG\n+                    && entry.hashCode == hashCode\n+                    && entry.data == labelIndex\n+                    && entry.value.equals(value)) {\n+                return entry.index;\n+            }\n+            entry = entry.next;\n+        }\n+        return addTypeInternal(\n+                new Entry(typeCount, Symbol.FORWARD_UNINITIALIZED_TYPE_TAG, value, labelIndex, hashCode));\n+    }\n+\n@@ -1260,0 +1322,53 @@\n+    \/**\n+      * Returns the {@link LabelEntry} corresponding to the given label. Creates a new one if there is\n+      * no such entry.\n+      *\n+      * @param label the {@link Label} of a NEW instruction which created an uninitialized type, in the\n+      *     case where this NEW instruction is after the &lt;init&gt; constructor call (in bytecode\n+      *     offset order). See {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}.\n+      * @return the {@link LabelEntry} corresponding to {@code label}.\n+      *\/\n+    private LabelEntry getOrAddLabelEntry(final Label label) {\n+        if (labelEntries == null) {\n+            labelEntries = new LabelEntry[16];\n+            labelTable = new LabelEntry[16];\n+        }\n+        int hashCode = System.identityHashCode(label);\n+        LabelEntry labelEntry = labelEntries[hashCode % labelEntries.length];\n+        while (labelEntry != null && labelEntry.label != label) {\n+            labelEntry = labelEntry.next;\n+        }\n+        if (labelEntry != null) {\n+            return labelEntry;\n+        }\n+\n+        if (labelCount > (labelEntries.length * 3) \/ 4) {\n+            int currentCapacity = labelEntries.length;\n+            int newCapacity = currentCapacity * 2 + 1;\n+            LabelEntry[] newLabelEntries = new LabelEntry[newCapacity];\n+            for (int i = currentCapacity - 1; i >= 0; --i) {\n+                LabelEntry currentEntry = labelEntries[i];\n+                while (currentEntry != null) {\n+                    int newCurrentEntryIndex = System.identityHashCode(currentEntry.label) % newCapacity;\n+                    LabelEntry nextEntry = currentEntry.next;\n+                    currentEntry.next = newLabelEntries[newCurrentEntryIndex];\n+                    newLabelEntries[newCurrentEntryIndex] = currentEntry;\n+                    currentEntry = nextEntry;\n+                }\n+            }\n+            labelEntries = newLabelEntries;\n+        }\n+        if (labelCount == labelTable.length) {\n+            LabelEntry[] newLabelTable = new LabelEntry[2 * labelTable.length];\n+            System.arraycopy(labelTable, 0, newLabelTable, 0, labelTable.length);\n+            labelTable = newLabelTable;\n+        }\n+\n+        labelEntry = new LabelEntry(labelCount, label);\n+        int index = hashCode % labelEntries.length;\n+        labelEntry.next = labelEntries[index];\n+        labelEntries[index] = labelEntry;\n+        labelTable[labelCount++] = labelEntry;\n+        return labelEntry;\n+    }\n+\n@@ -1310,1 +1425,1 @@\n-    private static class Entry extends Symbol {\n+    private static final class Entry extends Symbol {\n@@ -1354,1 +1469,0 @@\n-}\n@@ -1356,0 +1470,26 @@\n+    \/**\n+      * A label corresponding to a \"forward uninitialized\" type in the ASM specific {@link\n+      * SymbolTable#typeTable} (see {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}).\n+      *\n+      * @author Eric Bruneton\n+      *\/\n+    private static final class LabelEntry {\n+\n+        \/** The index of this label entry in the {@link SymbolTable#labelTable} array. *\/\n+        final int index;\n+\n+        \/** The value of this label entry. *\/\n+        final Label label;\n+\n+        \/**\n+          * Another entry (and so on recursively) having the same hash code (modulo the size of {@link\n+          * SymbolTable#labelEntries}}) as this one.\n+          *\/\n+        LabelEntry next;\n+\n+        LabelEntry(final int index, final Label label) {\n+            this.index = index;\n+            this.label = label;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/SymbolTable.java","additions":149,"deletions":9,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-      * @param internalName an internal name.\n+      * @param internalName an internal name (see {@link Type#getInternalName()}).\n@@ -330,15 +330,1 @@\n-        int numArgumentTypes = 0;\n-        \/\/ Skip the first character, which is always a '('.\n-        int currentOffset = 1;\n-        \/\/ Parse the argument types, one at a each loop iteration.\n-        while (methodDescriptor.charAt(currentOffset) != ')') {\n-            while (methodDescriptor.charAt(currentOffset) == '[') {\n-                currentOffset++;\n-            }\n-            if (methodDescriptor.charAt(currentOffset++) == 'L') {\n-                \/\/ Skip the argument descriptor content.\n-                int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\n-                currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\n-            }\n-            ++numArgumentTypes;\n-        }\n+        int numArgumentTypes = getArgumentCount(methodDescriptor);\n@@ -349,1 +335,1 @@\n-        currentOffset = 1;\n+        int currentOffset = 1;\n@@ -737,0 +723,37 @@\n+    \/**\n+      * Returns the number of arguments of this method type. This method should only be used for method\n+      * types.\n+      *\n+      * @return the number of arguments of this method type. Each argument counts for 1, even long and\n+      *     double ones. The implicit @literal{this} argument is not counted.\n+      *\/\n+    public int getArgumentCount() {\n+        return getArgumentCount(getDescriptor());\n+    }\n+\n+    \/**\n+      * Returns the number of arguments in the given method descriptor.\n+      *\n+      * @param methodDescriptor a method descriptor.\n+      * @return the number of arguments in the given method descriptor. Each argument counts for 1,\n+      *     even long and double ones. The implicit @literal{this} argument is not counted.\n+      *\/\n+    public static int getArgumentCount(final String methodDescriptor) {\n+        int argumentCount = 0;\n+        \/\/ Skip the first character, which is always a '('.\n+        int currentOffset = 1;\n+        \/\/ Parse the argument types, one at a each loop iteration.\n+        while (methodDescriptor.charAt(currentOffset) != ')') {\n+            while (methodDescriptor.charAt(currentOffset) == '[') {\n+                currentOffset++;\n+            }\n+            if (methodDescriptor.charAt(currentOffset++) == 'L') {\n+                \/\/ Skip the argument descriptor content.\n+                int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\n+                currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\n+            }\n+            ++argumentCount;\n+        }\n+        return argumentCount;\n+    }\n+\n@@ -744,1 +767,2 @@\n-      *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}).\n+      *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}). Long and double values have size 2,\n+      *     the others have size 1.\n@@ -757,1 +781,2 @@\n-      *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}).\n+      *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}). Long and double values have size 2,\n+      *     the others have size 1.\n@@ -928,1 +953,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Type.java","additions":44,"deletions":20,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -233,1 +233,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/TypePath.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -468,1 +468,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/TypeReference.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -703,1 +703,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/AdviceAdapter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,3 +95,4 @@\n-      * represented by String objects (representing internal names), and uninitialized types by Label\n-      * objects (this label designates the NEW instruction that created this uninitialized value). This\n-      * field is {@literal null} for unreachable instructions.\n+      * represented by String objects (representing internal names, see {@link\n+      * Type#getInternalName()}), and uninitialized types by Label objects (this label designates the\n+      * NEW instruction that created this uninitialized value). This field is {@literal null} for\n+      * unreachable instructions.\n@@ -106,3 +107,4 @@\n-      * represented by String objects (representing internal names), and uninitialized types by Label\n-      * objects (this label designates the NEW instruction that created this uninitialized value). This\n-      * field is {@literal null} for unreachable instructions.\n+      * represented by String objects (representing internal names, see {@link\n+      * Type#getInternalName()}), and uninitialized types by Label objects (this label designates the\n+      * NEW instruction that created this uninitialized value). This field is {@literal null} for\n+      * unreachable instructions.\n@@ -117,3 +119,3 @@\n-      * Label objects. Each label designates a NEW instruction that created the currently uninitialized\n-      * types, and the associated internal name represents the NEW operand, i.e. the final, initialized\n-      * type value.\n+      * Label objects (see {@link Type#getInternalName()}). Each label designates a NEW instruction\n+      * that created the currently uninitialized types, and the associated internal name represents the\n+      * NEW operand, i.e. the final, initialized type value.\n@@ -341,1 +343,1 @@\n-                    initializedValue = uninitializedTypes.get(value);\n+                    initializedValue = owner;\n@@ -941,1 +943,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/AnalyzerAdapter.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-      * internal name of the annotation is {@literal null}.\n+      * descriptor of the annotation is {@literal null}.\n@@ -242,1 +242,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/AnnotationRemapper.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -332,1 +332,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/ClassRemapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -240,1 +240,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/CodeSizeEvaluator.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -147,1 +147,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/FieldRemapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-      * @return the internal names of the given types.\n+      * @return the internal names of the given types (see {@link Type#getInternalName()}).\n@@ -1389,1 +1389,2 @@\n-      * @param exception internal name of the type of exceptions handled by the handler.\n+      * @param exception internal name of the type of exceptions handled by the handler (see {@link\n+      *     Type#getInternalName()}).\n@@ -1401,1 +1402,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/GeneratorAdapter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1097,1 +1097,2 @@\n-      * @param owner the internal name of the method's owner class.\n+      * @param owner the internal name of the method's owner class (see {@link\n+      *     Type#getInternalName()}).\n@@ -1135,1 +1136,2 @@\n-      * @param owner the internal name of the method's owner class.\n+      * @param owner the internal name of the method's owner class (see {@link\n+      *     Type#getInternalName()}).\n@@ -1173,1 +1175,2 @@\n-      * @param owner the internal name of the method's owner class.\n+      * @param owner the internal name of the method's owner class (see {@link\n+      *     Type#getInternalName()}).\n@@ -1332,1 +1335,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/InstructionAdapter.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -123,1 +123,2 @@\n-      * @param exceptions the internal names of the method's exception classes. May be {@literal null}.\n+      * @param exceptions the internal names of the method's exception classes (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n@@ -158,1 +159,2 @@\n-      * @param exceptions the internal names of the method's exception classes. May be {@literal null}.\n+      * @param exceptions the internal names of the method's exception classes (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n@@ -458,1 +460,1 @@\n-    private class Instantiation extends AbstractMap<LabelNode, LabelNode> {\n+    private final class Instantiation extends AbstractMap<LabelNode, LabelNode> {\n@@ -603,1 +605,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/JSRInlinerAdapter.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -384,1 +384,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/LocalVariablesSorter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -295,1 +295,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/Method.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -322,1 +322,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/MethodRemapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,1 +171,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/ModuleHashesAttribute.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -153,1 +153,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/ModuleRemapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,1 +145,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/ModuleResolutionAttribute.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -119,1 +119,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/ModuleTargetAttribute.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -150,1 +150,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/RecordComponentRemapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-      *     descriptor is returned as is).\n+      *     descriptor is returned as is). See {@link Type#getInternalName()}.\n@@ -97,1 +97,1 @@\n-      *     #mapMethodDesc(String)}.\n+      *     #mapMethodDesc(String)}. See {@link Type#getInternalName()}.\n@@ -121,2 +121,4 @@\n-      * @param internalName the internal name (or array type descriptor) of some (array) class.\n-      * @return the given internal name, remapped with {@link #map(String)}.\n+      * @param internalName the internal name (or array type descriptor) of some (array) class (see\n+      *     {@link Type#getInternalName()}).\n+      * @return the given internal name, remapped with {@link #map(String)} (see {@link\n+      *     Type#getInternalName()}).\n@@ -134,2 +136,4 @@\n-      * @param internalNames the internal names (or array type descriptors) of some (array) classes.\n-      * @return the given internal name, remapped with {@link #map(String)}.\n+      * @param internalNames the internal names (or array type descriptors) of some (array) classes\n+      *     (see {@link Type#getInternalName()}).\n+      * @return the given internal name, remapped with {@link #map(String)} (see {@link\n+      *     Type#getInternalName()}).\n@@ -289,3 +293,5 @@\n-      * @param name the fully-qualified internal name of the inner class.\n-      * @param ownerName the internal name of the owner class of the inner class.\n-      * @param innerName the internal name of the inner class.\n+      * @param name the fully-qualified internal name of the inner class (see {@link\n+      *     Type#getInternalName()}).\n+      * @param ownerName the internal name of the owner class of the inner class (see {@link\n+      *     Type#getInternalName()}).\n+      * @param innerName the internal name of the inner class (see {@link Type#getInternalName()}).\n@@ -297,0 +303,14 @@\n+\n+        if (remappedInnerName.equals(name)) {\n+            return innerName;\n+        } else {\n+            int originSplit = name.lastIndexOf('\/');\n+            int remappedSplit = remappedInnerName.lastIndexOf('\/');\n+            if (originSplit != -1 && remappedSplit != -1) {\n+                if (name.substring(originSplit).equals(remappedInnerName.substring(remappedSplit))) {\n+                    \/\/ class name not changed\n+                    return innerName;\n+                }\n+            }\n+        }\n+\n@@ -313,1 +333,2 @@\n-      * @param owner the internal name of the owner class of the method.\n+      * @param owner the internal name of the owner class of the method (see {@link\n+      *     Type#getInternalName()}).\n@@ -338,1 +359,2 @@\n-      * @param owner the internal name of the owner class of the field.\n+      * @param owner the internal name of the owner class of the field (see {@link\n+      *     Type#getInternalName()}).\n@@ -352,1 +374,2 @@\n-      * @param owner the internal name of the owner class of the field.\n+      * @param owner the internal name of the owner class of the field (see {@link\n+      *     Type#getInternalName()}).\n@@ -387,2 +410,2 @@\n-      * @param internalName the internal name of a class.\n-      * @return the new internal name.\n+      * @param internalName the internal name of a class (see {@link Type#getInternalName()}).\n+      * @return the new internal name (see {@link Type#getInternalName()}).\n@@ -394,1 +417,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/Remapper.java","additions":37,"deletions":15,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -525,1 +525,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/SerialVersionUIDAdder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/SignatureRemapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-      *           internal name.\n+      *           internal name (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -100,1 +100,2 @@\n-      * @param newName the new method, field or internal name.\n+      * @param newName the new method, field or internal name (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -135,1 +136,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/SimpleRemapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -157,1 +157,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/StaticInitMerger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/TableSwitchGenerator.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -158,1 +158,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/TryCatchBlockSorter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -285,1 +285,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/signature\/SignatureReader.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -214,1 +214,2 @@\n-      * @param name the internal name of the class or interface.\n+      * @param name the internal name of the class or interface (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -241,1 +242,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/signature\/SignatureVisitor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    private final StringBuilder stringBuilder = new StringBuilder();\n+    private final StringBuilder stringBuilder;\n@@ -86,2 +86,3 @@\n-      * a boolean encoded in one bit. The top of the stack is the least significant bit. Pushing false\n-      * = *2, pushing true = *2+1, popping = \/2.\n+      * a boolean encoded in one bit. The top of the stack is the least significant bit. The bottom of\n+      * the stack is a sentinel element always equal to 1 (used to detect when the stack is full).\n+      * Pushing false = {@code <<= 1}, pushing true = {@code ( <<= 1) | 1}, popping = {@code >>>= 1}.\n@@ -97,2 +98,2 @@\n-      * <p>we need a stack to properly balance these 'parentheses'. A new element is pushed on this\n-      * stack for each new visited type, and popped when the visit of this type ends (either is\n+      * <p>we need a stack to properly balance these angle brackets. A new element is pushed on this\n+      * stack for each new visited type, and popped when the visit of this type ends (either in\n@@ -101,1 +102,1 @@\n-    private int argumentStack;\n+    private int argumentStack = 1;\n@@ -105,0 +106,4 @@\n+        this(new StringBuilder());\n+    }\n+\n+    private SignatureWriter(final StringBuilder stringBuilder) {\n@@ -106,0 +111,1 @@\n+        this.stringBuilder = stringBuilder;\n@@ -194,1 +200,1 @@\n-        argumentStack *= 2;\n+        argumentStack <<= 1;\n@@ -204,1 +210,1 @@\n-        argumentStack *= 2;\n+        argumentStack <<= 1;\n@@ -212,1 +218,1 @@\n-        if (argumentStack % 2 == 0) {\n+        if ((argumentStack & 1) == 0) {\n@@ -224,1 +230,1 @@\n-        if (argumentStack % 2 == 0) {\n+        if ((argumentStack & 1) == 0) {\n@@ -231,1 +237,2 @@\n-        return this;\n+        \/\/ If the stack is full, start a nested one by returning a new SignatureWriter.\n+        return (argumentStack & (1 << 31)) == 0 ? this : new SignatureWriter(stringBuilder);\n@@ -267,1 +274,1 @@\n-        if (argumentStack % 2 == 1) {\n+        if ((argumentStack & 1) == 1) {\n@@ -270,1 +277,1 @@\n-        argumentStack \/= 2;\n+        argumentStack >>>= 1;\n@@ -273,1 +280,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/signature\/SignatureWriter.java","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -123,1 +123,4 @@\n-    \/** The opcode of this instruction. *\/\n+    \/**\n+      * The opcode of this instruction, or -1 if this is not a JVM instruction (e.g. a label or a line\n+      * number).\n+      *\/\n@@ -166,1 +169,2 @@\n-      * @return the opcode of this instruction.\n+      * @return the opcode of this instruction, or -1 if this is not a JVM instruction (e.g. a label or\n+      *     a line number).\n@@ -298,1 +302,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/AbstractInsnNode.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -263,1 +263,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/AnnotationNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    \/** The internal name of this class (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName}). *\/\n+    \/** The internal name of this class (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}). *\/\n@@ -100,1 +100,1 @@\n-      * The internal of name of the super class (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName}).\n+      * The internal of name of the super class (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -108,1 +108,1 @@\n-      * jdk.internal.org.objectweb.asm.Type#getInternalName}).\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -123,1 +123,5 @@\n-    \/** The internal name of the enclosing class of this class. May be {@literal null}. *\/\n+    \/**\n+      * The internal name of the enclosing class of this class (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}). Must be {@literal null} if this class has no\n+      * enclosing class, or if it is a local or anonymous class.\n+      *\/\n@@ -127,2 +131,4 @@\n-      * The name of the method that contains this class, or {@literal null} if this class is not\n-      * enclosed in a method.\n+      * The name of the method that contains the class, or {@literal null} if the class has no\n+      * enclosing class, or is not enclosed in a method or constructor of its enclosing class (e.g. if\n+      * it is enclosed in an instance initializer, static initializer, instance variable initializer,\n+      * or class variable initializer).\n@@ -133,2 +139,4 @@\n-      * The descriptor of the method that contains this class, or {@literal null} if this class is not\n-      * enclosed in a method.\n+      * The descriptor of the method that contains the class, or {@literal null} if the class has no\n+      * enclosing class, or is not enclosed in a method or constructor of its enclosing class (e.g. if\n+      * it is enclosed in an instance initializer, static initializer, instance variable initializer,\n+      * or class variable initializer).\n@@ -156,1 +164,4 @@\n-    \/** The internal name of the nest host class of this class. May be {@literal null}. *\/\n+    \/**\n+      * The internal name of the nest host class of this class (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *\/\n@@ -159,1 +170,4 @@\n-    \/** The internal names of the nest members of this class. May be {@literal null}. *\/\n+    \/**\n+      * The internal names of the nest members of this class (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *\/\n@@ -162,1 +176,4 @@\n-    \/** The internal names of the permitted subclasses of this class. May be {@literal null}. *\/\n+    \/**\n+      * The internal names of the permitted subclasses of this class (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *\/\n@@ -488,1 +505,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/ClassNode.java","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-      * jdk.internal.org.objectweb.asm.Type#getInternalName}).\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -91,1 +91,1 @@\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName}).\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -129,1 +129,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/FieldInsnNode.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -277,1 +277,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/FieldNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,1 +114,2 @@\n-      * @param numLocal number of local variables of this stack map frame.\n+      * @param numLocal number of local variables of this stack map frame. Long and double values count\n+      *     for one variable.\n@@ -117,2 +118,4 @@\n-      *     types respectively - see {@link MethodVisitor}).\n-      * @param numStack number of operand stack elements of this stack map frame.\n+      *     types respectively - see {@link MethodVisitor}). Long and double values are represented by\n+      *     a single element.\n+      * @param numStack number of operand stack elements of this stack map frame. Long and double\n+      *     values count for one stack element.\n@@ -121,1 +124,2 @@\n-      *     uninitialized types respectively - see {@link MethodVisitor}).\n+      *     uninitialized types respectively - see {@link MethodVisitor}). Long and double values are\n+      *     represented by a single element.\n@@ -221,1 +225,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/FrameNode.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/IincInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,1 +65,5 @@\n- * A node that represents an inner class.\n+ * A node that represents an inner class. This inner class is not necessarily a member of the {@link\n+ * ClassNode} containing this object. More precisely, every class or interface C which is referenced\n+ * by a {@link ClassNode} and which is not a package member must be represented with an {@link\n+ * InnerClassNode}. The {@link ClassNode} must reference its nested class or interface members, and\n+ * its enclosing class, if any. See the JVMS 4.7.6 section for more details.\n@@ -81,2 +85,2 @@\n-      * The (simple) name of the inner class inside its enclosing class. May be {@literal null} for\n-      * anonymous inner classes.\n+      * The (simple) name of the inner class inside its enclosing class. Must be {@literal null} if the\n+      * inner class is not the member of a class or interface (e.g. for local or anonymous classes).\n@@ -86,1 +90,4 @@\n-    \/** The access flags of the inner class as originally declared in the enclosing class. *\/\n+    \/**\n+      * The access flags of the inner class as originally declared in the source code from which the\n+      * class was compiled.\n+      *\/\n@@ -90,1 +97,1 @@\n-      * Constructs a new {@link InnerClassNode}.\n+      * Constructs a new {@link InnerClassNode} for an inner class C.\n@@ -92,8 +99,7 @@\n-      * @param name the internal name of an inner class (see {@link\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n-      * @param outerName the internal name of the class to which the inner class belongs (see {@link\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n-      * @param innerName the (simple) name of the inner class inside its enclosing class. May be\n-      *     {@literal null} for anonymous inner classes.\n-      * @param access the access flags of the inner class as originally declared in the enclosing\n-      *     class.\n+      * @param name the internal name of C (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      * @param outerName the internal name of the class or interface C is a member of (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). Must be {@literal null} if C is not the member\n+      *     of a class or interface (e.g. for local or anonymous classes).\n+      * @param innerName the (simple) name of C. Must be {@literal null} for anonymous inner classes.\n+      * @param access the access flags of C originally declared in the source code from which this\n+      *     class was compiled.\n@@ -118,1 +124,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/InnerClassNode.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -637,1 +637,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/InsnList.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/InsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/IntInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-            final Object... bootstrapMethodArguments) { \/\/ NOPMD(ArrayIsStoredDirectly): public field.\n+            final Object... bootstrapMethodArguments) {\n@@ -106,1 +106,1 @@\n-        this.bsmArgs = bootstrapMethodArguments;\n+        this.bsmArgs = bootstrapMethodArguments; \/\/ NOPMD(ArrayIsStoredDirectly): public field.\n@@ -125,1 +125,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/InvokeDynamicInsnNode.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/JumpInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/LabelNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -116,1 +116,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/LdcInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/LineNumberNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -172,1 +172,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/LocalVariableAnnotationNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -125,1 +125,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/LocalVariableNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/LookupSwitchInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -156,1 +156,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/MethodInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-                int params = Type.getArgumentTypes(desc).length;\n+                int params = Type.getArgumentCount(desc);\n@@ -336,1 +336,1 @@\n-                int params = Type.getArgumentTypes(desc).length;\n+                int params = Type.getArgumentCount(desc);\n@@ -805,1 +805,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/MethodNode.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -72,1 +72,4 @@\n-    \/** The internal name of the exported package. *\/\n+    \/**\n+      * The internal name of the exported package (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      *\/\n@@ -90,1 +93,2 @@\n-      * @param packaze the internal name of the exported package.\n+      * @param packaze the internal name of the exported package (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -112,1 +116,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/ModuleExportNode.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -87,1 +87,4 @@\n-    \/** The internal name of the main class of this module. May be {@literal null}. *\/\n+    \/**\n+      * The internal name of the main class of this module (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *\/\n@@ -90,1 +93,4 @@\n-    \/** The internal name of the packages declared by this module. May be {@literal null}. *\/\n+    \/**\n+      * The internal name of the packages declared by this module (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *\/\n@@ -102,1 +108,4 @@\n-    \/** The internal names of the services used by this module. May be {@literal null}. *\/\n+    \/**\n+      * The internal names of the services used by this module (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *\/\n@@ -141,1 +150,2 @@\n-      * @param uses The internal names of the services used by this module. May be {@literal null}.\n+      * @param uses The internal names of the services used by this module (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n@@ -268,1 +278,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/ModuleNode.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -72,1 +72,3 @@\n-    \/** The internal name of the opened package. *\/\n+    \/**\n+      * The internal name of the opened package (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      *\/\n@@ -90,1 +92,2 @@\n-      * @param packaze the internal name of the opened package.\n+      * @param packaze the internal name of the opened package (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -112,1 +115,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/ModuleOpenNode.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    \/** The internal name of the service. *\/\n+    \/** The internal name of the service (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}). *\/\n@@ -75,1 +75,4 @@\n-    \/** The internal names of the implementations of the service (there is at least one provider). *\/\n+    \/**\n+      * The internal names of the implementations of the service (there is at least one provider). See\n+      * {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}.\n+      *\/\n@@ -83,1 +86,1 @@\n-      *     one provider).\n+      *     one provider). See {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}.\n@@ -99,1 +102,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/ModuleProvideNode.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/ModuleRequireNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/MultiANewArrayInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,1 +101,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/ParameterNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -237,1 +237,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/RecordComponentNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/TableSwitchInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,2 +101,3 @@\n-      * @param type the internal name of the type of exceptions handled by the handler, or {@literal\n-      *     null} to catch any exceptions (for \"finally\" blocks).\n+      * @param type the internal name of the type of exceptions handled by the handler (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}), or {@literal null} to catch any exceptions (for\n+      *     \"finally\" blocks).\n@@ -159,1 +160,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/TryCatchBlockNode.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -118,1 +118,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/TypeAnnotationNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n- * A node that represents a type instruction. A type instruction is an instruction that takes a type\n- * descriptor as parameter.\n+ * A node that represents a type instruction. A type instruction is an instruction which takes an\n+ * internal name as parameter (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -74,2 +74,2 @@\n-      * The operand of this instruction. This operand is an internal name (see {@link\n-      * jdk.internal.org.objectweb.asm.Type}).\n+      * The operand of this instruction. Despite its name (due to historical reasons), this operand is\n+      * an internal name (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -84,2 +84,2 @@\n-      * @param descriptor the operand of the instruction to be constructed. This operand is an internal\n-      *     name (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param type the operand of the instruction to be constructed. This operand is an internal name\n+      *     (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -87,1 +87,1 @@\n-    public TypeInsnNode(final int opcode, final String descriptor) {\n+    public TypeInsnNode(final int opcode, final String type) {\n@@ -89,1 +89,1 @@\n-        this.desc = descriptor;\n+        this.desc = type;\n@@ -118,1 +118,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/TypeInsnNode.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/UnsupportedClassVersionException.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -196,1 +196,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/Util.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -115,1 +115,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/VarInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n- * @param <V> type of the Value used for the analysis.\n+ * @param <V> type of the {@link Value} used for the analysis.\n@@ -127,1 +127,2 @@\n-      * @param owner the internal name of the class to which 'method' belongs.\n+      * @param owner the internal name of the class to which 'method' belongs (see {@link\n+      *     Type#getInternalName()}).\n@@ -157,1 +158,1 @@\n-            for (int j = startIndex; j < endIndex; ++j) {\n+            for (int j = startIndex; j <= endIndex; ++j) {\n@@ -167,26 +168,2 @@\n-        \/\/ For each instruction, compute the subroutine to which it belongs.\n-        \/\/ Follow the main 'subroutine', and collect the jsr instructions to nested subroutines.\n-        Subroutine main = new Subroutine(null, method.maxLocals, null);\n-        List<AbstractInsnNode> jsrInsns = new ArrayList<>();\n-        findSubroutine(0, main, jsrInsns);\n-        \/\/ Follow the nested subroutines, and collect their own nested subroutines, until all\n-        \/\/ subroutines are found.\n-        Map<LabelNode, Subroutine> jsrSubroutines = new HashMap<>();\n-        while (!jsrInsns.isEmpty()) {\n-            JumpInsnNode jsrInsn = (JumpInsnNode) jsrInsns.remove(0);\n-            Subroutine subroutine = jsrSubroutines.get(jsrInsn.label);\n-            if (subroutine == null) {\n-                subroutine = new Subroutine(jsrInsn.label, method.maxLocals, jsrInsn);\n-                jsrSubroutines.put(jsrInsn.label, subroutine);\n-                findSubroutine(insnList.indexOf(jsrInsn.label), subroutine, jsrInsns);\n-            } else {\n-                subroutine.callers.add(jsrInsn);\n-            }\n-        }\n-        \/\/ Clear the main 'subroutine', which is not a real subroutine (and was used only as an\n-        \/\/ intermediate step above to find the real ones).\n-        for (int i = 0; i < insnListSize; ++i) {\n-            if (subroutines[i] != null && subroutines[i].start == null) {\n-                subroutines[i] = null;\n-            }\n-        }\n+        \/\/ Finds the method's subroutines.\n+        findSubroutines(method.maxLocals);\n@@ -195,3 +172,9 @@\n-        Frame<V> currentFrame = computeInitialFrame(owner, method);\n-        merge(0, currentFrame, null);\n-        init(owner, method);\n+        Frame<V> currentFrame;\n+        try {\n+            currentFrame = computeInitialFrame(owner, method);\n+            merge(0, currentFrame, null);\n+            init(owner, method);\n+        } catch (RuntimeException e) {\n+            \/\/ DontCheck(IllegalCatch): can't be fixed, for backward compatibility.\n+            throw new AnalyzerException(insnList.get(0), \"Error at instruction 0: \" + e.getMessage(), e);\n+        }\n@@ -339,1 +322,2 @@\n-      * @param owner the internal name of the class to which 'method' belongs.\n+      * @param owner the internal name of the class to which 'method' belongs (see {@link\n+      *     Type#getInternalName()}).\n@@ -364,0 +348,3 @@\n+        if ((method.access & Opcodes.ACC_STATIC) != 0) {\n+            maxLocals -= 1;\n+        }\n@@ -403,0 +390,36 @@\n+    \/**\n+      * Finds the subroutines of the currently analyzed method and stores them in {@link #subroutines}.\n+      *\n+      * @param maxLocals the maximum number of local variables of the currently analyzed method (long\n+      *     and double values count for two variables).\n+      * @throws AnalyzerException if the control flow graph can fall off the end of the code.\n+      *\/\n+    private void findSubroutines(final int maxLocals) throws AnalyzerException {\n+        \/\/ For each instruction, compute the subroutine to which it belongs.\n+        \/\/ Follow the main 'subroutine', and collect the jsr instructions to nested subroutines.\n+        Subroutine main = new Subroutine(null, maxLocals, null);\n+        List<AbstractInsnNode> jsrInsns = new ArrayList<>();\n+        findSubroutine(0, main, jsrInsns);\n+        \/\/ Follow the nested subroutines, and collect their own nested subroutines, until all\n+        \/\/ subroutines are found.\n+        Map<LabelNode, Subroutine> jsrSubroutines = new HashMap<>();\n+        while (!jsrInsns.isEmpty()) {\n+            JumpInsnNode jsrInsn = (JumpInsnNode) jsrInsns.remove(0);\n+            Subroutine subroutine = jsrSubroutines.get(jsrInsn.label);\n+            if (subroutine == null) {\n+                subroutine = new Subroutine(jsrInsn.label, maxLocals, jsrInsn);\n+                jsrSubroutines.put(jsrInsn.label, subroutine);\n+                findSubroutine(insnList.indexOf(jsrInsn.label), subroutine, jsrInsns);\n+            } else {\n+                subroutine.callers.add(jsrInsn);\n+            }\n+        }\n+        \/\/ Clear the main 'subroutine', which is not a real subroutine (and was used only as an\n+        \/\/ intermediate step above to find the real ones).\n+        for (int i = 0; i < insnListSize; ++i) {\n+            if (subroutines[i] != null && subroutines[i].start == null) {\n+                subroutines[i] = null;\n+            }\n+        }\n+    }\n+\n@@ -488,1 +511,2 @@\n-      * @param owner the internal name of the class to which 'method' belongs.\n+      * @param owner the internal name of the class to which 'method' belongs (see {@link\n+      *     Type#getInternalName()}).\n@@ -545,1 +569,1 @@\n-      * analysis loop in #analyze. The default implementation of this method does nothing.\n+      * analysis loop in {@link #analyze}. The default implementation of this method does nothing.\n@@ -547,1 +571,2 @@\n-      * @param owner the internal name of the class to which the method belongs.\n+      * @param owner the internal name of the class to which the method belongs (see {@link\n+      *     Type#getInternalName()}).\n@@ -705,1 +730,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/Analyzer.java","additions":61,"deletions":37,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/AnalyzerException.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -408,1 +408,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/BasicInterpreter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -162,1 +162,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/BasicValue.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -483,1 +483,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/BasicVerifier.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -707,1 +707,1 @@\n-        for (int i = Type.getArgumentTypes(methodDescriptor).length; i > 0; --i) {\n+        for (int i = Type.getArgumentCount(methodDescriptor); i > 0; --i) {\n@@ -785,1 +785,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/Frame.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -300,1 +300,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/Interpreter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -414,1 +414,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/SimpleVerifier.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/SmallSet.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -253,1 +253,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/SourceInterpreter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,1 +152,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/SourceValue.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -139,1 +139,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/Subroutine.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/Value.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n- * A {@link Printer} that prints the ASM code to generate the classes if visits.\n+ * A {@link Printer} that prints the ASM code to generate the classes it visits.\n@@ -144,0 +144,4 @@\n+        classVersions.put(Opcodes.V20, \"V20\");\n+        classVersions.put(Opcodes.V21, \"V21\");\n+        classVersions.put(Opcodes.V22, \"V22\");\n+        classVersions.put(Opcodes.V23, \"V23\");\n@@ -1644,1 +1648,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/ASMifier.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/ASMifierSupport.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -168,1 +168,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckAnnotationAdapter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -499,1 +499,2 @@\n-                        new CheckMethodAdapter.MethodWriterWrapper(api, (ClassWriter) cv, methodVisitor);\n+                        new CheckMethodAdapter.MethodWriterWrapper(\n+                                api, version, (ClassWriter) cv, methodVisitor);\n@@ -1169,1 +1170,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckClassAdapter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -149,1 +149,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckFieldAdapter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,513 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, the following notice accompanied the original version of this\n+ * file:\n+ *\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2011 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and\/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+package jdk.internal.org.objectweb.asm.util;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+import jdk.internal.org.objectweb.asm.tree.AbstractInsnNode;\n+import jdk.internal.org.objectweb.asm.tree.FrameNode;\n+import jdk.internal.org.objectweb.asm.tree.InsnList;\n+import jdk.internal.org.objectweb.asm.tree.InsnNode;\n+import jdk.internal.org.objectweb.asm.tree.JumpInsnNode;\n+import jdk.internal.org.objectweb.asm.tree.LabelNode;\n+import jdk.internal.org.objectweb.asm.tree.LookupSwitchInsnNode;\n+import jdk.internal.org.objectweb.asm.tree.MethodNode;\n+import jdk.internal.org.objectweb.asm.tree.TableSwitchInsnNode;\n+import jdk.internal.org.objectweb.asm.tree.TryCatchBlockNode;\n+import jdk.internal.org.objectweb.asm.tree.TypeInsnNode;\n+import jdk.internal.org.objectweb.asm.tree.analysis.Analyzer;\n+import jdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException;\n+import jdk.internal.org.objectweb.asm.tree.analysis.Frame;\n+import jdk.internal.org.objectweb.asm.tree.analysis.Interpreter;\n+import jdk.internal.org.objectweb.asm.tree.analysis.Value;\n+\n+\/**\n+ * An {@link Analyzer} subclass which checks that methods provide stack map frames where expected\n+ * (i.e. at jump target and after instructions without immediate successor), and that these stack\n+ * map frames are valid (for the provided interpreter; they may still be invalid for the JVM, if the\n+ * {@link Interpreter} uses a simplified type system compared to the JVM verifier). This is done in\n+ * two steps:\n+ *\n+ * <ul>\n+ *   <li>First, the stack map frames in {@link FrameNode}s are expanded, and stored at their\n+ *       respective instruction offsets. The expansion process uncompresses the APPEND, CHOP and\n+ *       SAME frames to FULL frames. It also converts the stack map frame verification types to\n+ *       {@link Value}s, via the provided {@link Interpreter}. The expansion is done in {@link\n+ *       #expandFrames}, by looking at each {@link FrameNode} in sequence (compressed frames are\n+ *       defined relatively to the previous {@link FrameNode}, or the implicit first frame). The\n+ *       actual decompression is done in {@link #expandFrame}, and the type conversion in {@link\n+ *       #newFrameValue}.\n+ *   <li>Next, the method instructions are checked in sequence. Starting from the implicit initial\n+ *       frame, the execution of each instruction <em>i<\/em> is simulated on the current stack map\n+ *       frame, with the {@link Frame#execute} method. This gives a new stack map frame <em>f<\/em>,\n+ *       representing the stack map frame state after the execution of <em>i<\/em>. Then:\n+ *       <ul>\n+ *         <li>If there is a next instruction and if the control flow cannot continue to it (e.g. if\n+ *             <em>i<\/em> is a RETURN or an ATHROW, for instance): an existing stack map frame\n+ *             <em>f0<\/em> (coming from the first step) is expected after <em>i<\/em>.\n+ *         <li>If there is a next instruction and if the control flow can continue to it (e.g. if\n+ *             <em>i<\/em> is a ALOAD, for instance): either there an existing stack map frame\n+ *             <em>f0<\/em> (coming from the first step) after <em>i<\/em>, or there is none. In the\n+ *             first case <em>f<\/em> and <em>f0<\/em> must be <em>compatible<\/em>: the types in\n+ *             <em>f<\/em> must be sub types of the corresponding types in the existing frame\n+ *             <em>f0<\/em> (otherwise an exception is thrown). In the second case, <em>f0<\/em> is\n+ *             simply set to the value of <em>f<\/em>.\n+ *         <li>If the control flow can continue to some instruction <em>j<\/em> (e.g. if <em>i<\/em>\n+ *             is an IF_EQ, for instance): an existing stack map frame <em>f0<\/em> (coming from the\n+ *             first step) is expected at <em>j<\/em>, which must be compatible with <em>f<\/em> (as\n+ *             defined previously).\n+ *       <\/ul>\n+ *       The sequential loop over the instructions is done in {@link #init}, which is called from\n+ *       the {@link Analyzer#analyze} method. Cases where the control flow cannot continue to the\n+ *       next instruction are handled in {@link #endControlFlow}. Cases where the control flow can\n+ *       continue to the next instruction, or jump to another instruction, are handled in {@link\n+ *       #checkFrame}. This method checks that an existing stack map frame is present when required,\n+ *       and checks the stack map frames compatibility with {@link #checkMerge}.\n+ * <\/ul>\n+ *\n+ * @author Eric Bruneton\n+ * @param <V> type of the {@link Value} used for the analysis.\n+ *\/\n+class CheckFrameAnalyzer<V extends Value> extends Analyzer<V> {\n+\n+    \/** The interpreter to use to symbolically interpret the bytecode instructions. *\/\n+    private final Interpreter<V> interpreter;\n+\n+    \/** The instructions of the currently analyzed method. *\/\n+    private InsnList insnList;\n+\n+    \/**\n+      * The number of locals in the last stack map frame processed by {@link expandFrame}. Long and\n+      * double values are represented with two elements.\n+      *\/\n+    private int currentLocals;\n+\n+    CheckFrameAnalyzer(final Interpreter<V> interpreter) {\n+        super(interpreter);\n+        this.interpreter = interpreter;\n+    }\n+\n+    @Override\n+    protected void init(final String owner, final MethodNode method) throws AnalyzerException {\n+        insnList = method.instructions;\n+        currentLocals = Type.getArgumentsAndReturnSizes(method.desc) >> 2;\n+        if ((method.access & Opcodes.ACC_STATIC) != 0) {\n+            currentLocals -= 1;\n+        }\n+\n+        Frame<V>[] frames = getFrames();\n+        Frame<V> currentFrame = frames[0];\n+        expandFrames(owner, method, currentFrame);\n+        for (int insnIndex = 0; insnIndex < insnList.size(); ++insnIndex) {\n+            Frame<V> oldFrame = frames[insnIndex];\n+\n+            \/\/ Simulate the execution of this instruction.\n+            AbstractInsnNode insnNode = null;\n+            try {\n+                insnNode = method.instructions.get(insnIndex);\n+                int insnOpcode = insnNode.getOpcode();\n+                int insnType = insnNode.getType();\n+\n+                if (insnType == AbstractInsnNode.LABEL\n+                        || insnType == AbstractInsnNode.LINE\n+                        || insnType == AbstractInsnNode.FRAME) {\n+                    checkFrame(insnIndex + 1, oldFrame, \/* requireFrame = *\/ false);\n+                } else {\n+                    currentFrame.init(oldFrame).execute(insnNode, interpreter);\n+\n+                    if (insnNode instanceof JumpInsnNode) {\n+                        if (insnOpcode == JSR) {\n+                            throw new AnalyzerException(insnNode, \"JSR instructions are unsupported\");\n+                        }\n+                        JumpInsnNode jumpInsn = (JumpInsnNode) insnNode;\n+                        int targetInsnIndex = insnList.indexOf(jumpInsn.label);\n+                        checkFrame(targetInsnIndex, currentFrame, \/* requireFrame = *\/ true);\n+                        if (insnOpcode == GOTO) {\n+                            endControlFlow(insnIndex);\n+                        } else {\n+                            checkFrame(insnIndex + 1, currentFrame, \/* requireFrame = *\/ false);\n+                        }\n+                    } else if (insnNode instanceof LookupSwitchInsnNode) {\n+                        LookupSwitchInsnNode lookupSwitchInsn = (LookupSwitchInsnNode) insnNode;\n+                        int targetInsnIndex = insnList.indexOf(lookupSwitchInsn.dflt);\n+                        checkFrame(targetInsnIndex, currentFrame, \/* requireFrame = *\/ true);\n+                        for (int i = 0; i < lookupSwitchInsn.labels.size(); ++i) {\n+                            LabelNode label = lookupSwitchInsn.labels.get(i);\n+                            targetInsnIndex = insnList.indexOf(label);\n+                            currentFrame.initJumpTarget(insnOpcode, label);\n+                            checkFrame(targetInsnIndex, currentFrame, \/* requireFrame = *\/ true);\n+                        }\n+                        endControlFlow(insnIndex);\n+                    } else if (insnNode instanceof TableSwitchInsnNode) {\n+                        TableSwitchInsnNode tableSwitchInsn = (TableSwitchInsnNode) insnNode;\n+                        int targetInsnIndex = insnList.indexOf(tableSwitchInsn.dflt);\n+                        currentFrame.initJumpTarget(insnOpcode, tableSwitchInsn.dflt);\n+                        checkFrame(targetInsnIndex, currentFrame, \/* requireFrame = *\/ true);\n+                        newControlFlowEdge(insnIndex, targetInsnIndex);\n+                        for (int i = 0; i < tableSwitchInsn.labels.size(); ++i) {\n+                            LabelNode label = tableSwitchInsn.labels.get(i);\n+                            currentFrame.initJumpTarget(insnOpcode, label);\n+                            targetInsnIndex = insnList.indexOf(label);\n+                            checkFrame(targetInsnIndex, currentFrame, \/* requireFrame = *\/ true);\n+                        }\n+                        endControlFlow(insnIndex);\n+                    } else if (insnOpcode == RET) {\n+                        throw new AnalyzerException(insnNode, \"RET instructions are unsupported\");\n+                    } else if (insnOpcode != ATHROW && (insnOpcode < IRETURN || insnOpcode > RETURN)) {\n+                        checkFrame(insnIndex + 1, currentFrame, \/* requireFrame = *\/ false);\n+                    } else {\n+                        endControlFlow(insnIndex);\n+                    }\n+                }\n+\n+                List<TryCatchBlockNode> insnHandlers = getHandlers(insnIndex);\n+                if (insnHandlers != null) {\n+                    for (TryCatchBlockNode tryCatchBlock : insnHandlers) {\n+                        Type catchType;\n+                        if (tryCatchBlock.type == null) {\n+                            catchType = Type.getObjectType(\"java\/lang\/Throwable\");\n+                        } else {\n+                            catchType = Type.getObjectType(tryCatchBlock.type);\n+                        }\n+                        Frame<V> handler = newFrame(oldFrame);\n+                        handler.clearStack();\n+                        handler.push(interpreter.newExceptionValue(tryCatchBlock, handler, catchType));\n+                        checkFrame(insnList.indexOf(tryCatchBlock.handler), handler, \/* requireFrame = *\/ true);\n+                    }\n+                }\n+\n+                if (!hasNextJvmInsnOrFrame(insnIndex)) {\n+                    break;\n+                }\n+            } catch (AnalyzerException e) {\n+                throw new AnalyzerException(\n+                        e.node, \"Error at instruction \" + insnIndex + \": \" + e.getMessage(), e);\n+            } catch (RuntimeException e) {\n+                \/\/ DontCheck(IllegalCatch): can't be fixed, for backward compatibility.\n+                throw new AnalyzerException(\n+                        insnNode, \"Error at instruction \" + insnIndex + \": \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+      * Expands the {@link FrameNode} \"instructions\" of the given method into {@link Frame} objects and\n+      * stores them at the corresponding indices of the {@link #frames} array. The expanded frames are\n+      * also associated with the label and line number nodes immediately preceding each frame node.\n+      *\n+      * @param owner the internal name of the class to which 'method' belongs.\n+      * @param method the method whose frames must be expanded.\n+      * @param initialFrame the implicit initial frame of 'method'.\n+      * @throws AnalyzerException if the stack map frames of 'method', i.e. its FrameNode\n+      *     \"instructions\", are invalid.\n+      *\/\n+    private void expandFrames(\n+            final String owner, final MethodNode method, final Frame<V> initialFrame)\n+            throws AnalyzerException {\n+        int lastJvmOrFrameInsnIndex = -1;\n+        Frame<V> currentFrame = initialFrame;\n+        int currentInsnIndex = 0;\n+        for (AbstractInsnNode insnNode : method.instructions) {\n+            if (insnNode instanceof FrameNode) {\n+                try {\n+                    currentFrame = expandFrame(owner, currentFrame, (FrameNode) insnNode);\n+                } catch (AnalyzerException e) {\n+                    throw new AnalyzerException(\n+                            e.node, \"Error at instruction \" + currentInsnIndex + \": \" + e.getMessage(), e);\n+                }\n+                for (int index = lastJvmOrFrameInsnIndex + 1; index <= currentInsnIndex; ++index) {\n+                    getFrames()[index] = currentFrame;\n+                }\n+            }\n+            if (isJvmInsnNode(insnNode) || insnNode instanceof FrameNode) {\n+                lastJvmOrFrameInsnIndex = currentInsnIndex;\n+            }\n+            currentInsnIndex += 1;\n+        }\n+    }\n+\n+    \/**\n+      * Returns the expanded representation of the given {@link FrameNode}.\n+      *\n+      * @param owner the internal name of the class to which 'frameNode' belongs.\n+      * @param previousFrame the frame before 'frameNode', in expanded form.\n+      * @param frameNode a possibly compressed stack map frame.\n+      * @return the expanded version of 'frameNode'.\n+      * @throws AnalyzerException if 'frameNode' is invalid.\n+      *\/\n+    @SuppressWarnings(\"fallthrough\")\n+    private Frame<V> expandFrame(\n+            final String owner, final Frame<V> previousFrame, final FrameNode frameNode)\n+            throws AnalyzerException {\n+        Frame<V> frame = newFrame(previousFrame);\n+        List<Object> locals = frameNode.local == null ? Collections.emptyList() : frameNode.local;\n+        int currentLocal = currentLocals;\n+        switch (frameNode.type) {\n+            case Opcodes.F_NEW:\n+            case Opcodes.F_FULL:\n+                currentLocal = 0;\n+                \/\/ fall through\n+            case Opcodes.F_APPEND:\n+                for (Object type : locals) {\n+                    V value = newFrameValue(owner, frameNode, type);\n+                    if (currentLocal + value.getSize() > frame.getLocals()) {\n+                        throw new AnalyzerException(frameNode, \"Cannot append more locals than maxLocals\");\n+                    }\n+                    frame.setLocal(currentLocal++, value);\n+                    if (value.getSize() == 2) {\n+                        frame.setLocal(currentLocal++, interpreter.newValue(null));\n+                    }\n+                }\n+                break;\n+            case Opcodes.F_CHOP:\n+                for (Object unusedType : locals) {\n+                    if (currentLocal <= 0) {\n+                        throw new AnalyzerException(frameNode, \"Cannot chop more locals than defined\");\n+                    }\n+                    if (currentLocal > 1 && frame.getLocal(currentLocal - 2).getSize() == 2) {\n+                        currentLocal -= 2;\n+                    } else {\n+                        currentLocal -= 1;\n+                    }\n+                }\n+                break;\n+            case Opcodes.F_SAME:\n+            case Opcodes.F_SAME1:\n+                break;\n+            default:\n+                throw new AnalyzerException(frameNode, \"Illegal frame type \" + frameNode.type);\n+        }\n+        currentLocals = currentLocal;\n+        while (currentLocal < frame.getLocals()) {\n+            frame.setLocal(currentLocal++, interpreter.newValue(null));\n+        }\n+\n+        List<Object> stack = frameNode.stack == null ? Collections.emptyList() : frameNode.stack;\n+        frame.clearStack();\n+        for (Object type : stack) {\n+            frame.push(newFrameValue(owner, frameNode, type));\n+        }\n+        return frame;\n+    }\n+\n+    \/**\n+      * Creates a new {@link Value} that represents the given stack map frame type.\n+      *\n+      * @param owner the internal name of the class to which 'frameNode' belongs.\n+      * @param frameNode the stack map frame to which 'type' belongs.\n+      * @param type an Integer, String or LabelNode object representing a primitive, reference or\n+      *     uninitialized a stack map frame type, respectively. See {@link FrameNode}.\n+      * @return a value that represents the given type.\n+      * @throws AnalyzerException if 'type' is an invalid stack map frame type.\n+      *\/\n+    private V newFrameValue(final String owner, final FrameNode frameNode, final Object type)\n+            throws AnalyzerException {\n+        if (type == Opcodes.TOP) {\n+            return interpreter.newValue(null);\n+        } else if (type == Opcodes.INTEGER) {\n+            return interpreter.newValue(Type.INT_TYPE);\n+        } else if (type == Opcodes.FLOAT) {\n+            return interpreter.newValue(Type.FLOAT_TYPE);\n+        } else if (type == Opcodes.LONG) {\n+            return interpreter.newValue(Type.LONG_TYPE);\n+        } else if (type == Opcodes.DOUBLE) {\n+            return interpreter.newValue(Type.DOUBLE_TYPE);\n+        } else if (type == Opcodes.NULL) {\n+            return interpreter.newOperation(new InsnNode(Opcodes.ACONST_NULL));\n+        } else if (type == Opcodes.UNINITIALIZED_THIS) {\n+            return interpreter.newValue(Type.getObjectType(owner));\n+        } else if (type instanceof String) {\n+            return interpreter.newValue(Type.getObjectType((String) type));\n+        } else if (type instanceof LabelNode) {\n+            AbstractInsnNode referencedNode = (LabelNode) type;\n+            while (referencedNode != null && !isJvmInsnNode(referencedNode)) {\n+                referencedNode = referencedNode.getNext();\n+            }\n+            if (referencedNode == null || referencedNode.getOpcode() != Opcodes.NEW) {\n+                throw new AnalyzerException(frameNode, \"LabelNode does not designate a NEW instruction\");\n+            }\n+            return interpreter.newValue(Type.getObjectType(((TypeInsnNode) referencedNode).desc));\n+        }\n+        throw new AnalyzerException(frameNode, \"Illegal stack map frame value \" + type);\n+    }\n+\n+    \/**\n+      * Checks that the given frame is compatible with the frame at the given instruction index, if\n+      * any. If there is no frame at this instruction index and none is required, the frame at\n+      * 'insnIndex' is set to the given frame. Otherwise, if the merge of the two frames is not equal\n+      * to the current frame at 'insnIndex', an exception is thrown.\n+      *\n+      * @param insnIndex an instruction index.\n+      * @param frame a frame. This frame is left unchanged by this method.\n+      * @param requireFrame whether a frame must already exist or not in {@link #frames} at\n+      *     'insnIndex'.\n+      * @throws AnalyzerException if the frames have incompatible sizes or if the frame at 'insnIndex'\n+      *     is missing (if required) or not compatible with 'frame'.\n+      *\/\n+    private void checkFrame(final int insnIndex, final Frame<V> frame, final boolean requireFrame)\n+            throws AnalyzerException {\n+        Frame<V> oldFrame = getFrames()[insnIndex];\n+        if (oldFrame == null) {\n+            if (requireFrame) {\n+                throw new AnalyzerException(null, \"Expected stack map frame at instruction \" + insnIndex);\n+            }\n+            getFrames()[insnIndex] = newFrame(frame);\n+        } else {\n+            String error = checkMerge(frame, oldFrame);\n+            if (error != null) {\n+                throw new AnalyzerException(\n+                        null,\n+                        \"Stack map frame incompatible with frame at instruction \"\n+                                + insnIndex\n+                                + \" (\"\n+                                + error\n+                                + \")\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+      * Checks that merging the two given frames would not produce any change, i.e. that the types in\n+      * the source frame are sub types of the corresponding types in the destination frame.\n+      *\n+      * @param srcFrame a source frame. This frame is left unchanged by this method.\n+      * @param dstFrame a destination frame. This frame is left unchanged by this method.\n+      * @return an error message if the frames have incompatible sizes, or if a type in the source\n+      *     frame is not a sub type of the corresponding type in the destination frame. Returns\n+      *     {@literal null} otherwise.\n+      *\/\n+    private String checkMerge(final Frame<V> srcFrame, final Frame<V> dstFrame) {\n+        int numLocals = srcFrame.getLocals();\n+        if (numLocals != dstFrame.getLocals()) {\n+            throw new AssertionError();\n+        }\n+        for (int i = 0; i < numLocals; ++i) {\n+            V v = interpreter.merge(srcFrame.getLocal(i), dstFrame.getLocal(i));\n+            if (!v.equals(dstFrame.getLocal(i))) {\n+                return \"incompatible types at local \"\n+                        + i\n+                        + \": \"\n+                        + srcFrame.getLocal(i)\n+                        + \" and \"\n+                        + dstFrame.getLocal(i);\n+            }\n+        }\n+        int numStack = srcFrame.getStackSize();\n+        if (numStack != dstFrame.getStackSize()) {\n+            return \"incompatible stack heights\";\n+        }\n+        for (int i = 0; i < numStack; ++i) {\n+            V v = interpreter.merge(srcFrame.getStack(i), dstFrame.getStack(i));\n+            if (!v.equals(dstFrame.getStack(i))) {\n+                return \"incompatible types at stack item \"\n+                        + i\n+                        + \": \"\n+                        + srcFrame.getStack(i)\n+                        + \" and \"\n+                        + dstFrame.getStack(i);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+      * Ends the control flow graph at the given instruction. This method checks that there is an\n+      * existing frame for the next instruction, if any.\n+      *\n+      * @param insnIndex an instruction index.\n+      * @throws AnalyzerException if 'insnIndex' is not the last instruction and there is no frame at\n+      *     'insnIndex' + 1 in {@link #getFrames}.\n+      *\/\n+    private void endControlFlow(final int insnIndex) throws AnalyzerException {\n+        if (hasNextJvmInsnOrFrame(insnIndex) && getFrames()[insnIndex + 1] == null) {\n+            throw new AnalyzerException(\n+                    null, \"Expected stack map frame at instruction \" + (insnIndex + 1));\n+        }\n+    }\n+\n+    \/**\n+      * Returns true if the given instruction is followed by a JVM instruction or a by stack map frame.\n+      *\n+      * @param insnIndex an instruction index.\n+      * @return true if 'insnIndex' is followed by a JVM instruction or a by stack map frame.\n+      *\/\n+    private boolean hasNextJvmInsnOrFrame(final int insnIndex) {\n+        AbstractInsnNode insn = insnList.get(insnIndex).getNext();\n+        while (insn != null) {\n+            if (isJvmInsnNode(insn) || insn instanceof FrameNode) {\n+                return true;\n+            }\n+            insn = insn.getNext();\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+      * Returns true if the given instruction node corresponds to a real JVM instruction.\n+      *\n+      * @param insnNode an instruction node.\n+      * @return true except for label, line number and stack map frame nodes.\n+      *\/\n+    private static boolean isJvmInsnNode(final AbstractInsnNode insnNode) {\n+        return insnNode.getOpcode() >= 0;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckFrameAnalyzer.java","additions":513,"deletions":0,"binary":false,"changes":513,"status":"added"},{"patch":"@@ -65,1 +65,0 @@\n-import java.util.Collections;\n@@ -482,2 +481,6 @@\n-                        Analyzer<BasicValue> analyzer = new Analyzer<>(new BasicVerifier());\n-                        try {\n+                        int originalMaxLocals = maxLocals;\n+                        int originalMaxStack = maxStack;\n+                        boolean checkMaxStackAndLocals = false;\n+                        boolean checkFrames = false;\n+                        if (methodVisitor instanceof MethodWriterWrapper) {\n+                            MethodWriterWrapper methodWriter = (MethodWriterWrapper) methodVisitor;\n@@ -487,5 +490,11 @@\n-                            \/\/ TODO(ebruneton): similarly, check that valid stack map frames are provided if the\n-                            \/\/ class writer has no flags to compute them, and the class version is V1_7 or more.\n-                            boolean checkMaxStackAndLocals =\n-                                    (methodVisitor instanceof MethodWriterWrapper)\n-                                            && !((MethodWriterWrapper) methodVisitor).computesMaxs();\n+                            checkMaxStackAndLocals = !methodWriter.computesMaxs();\n+                            \/\/ If 'methodVisitor' is a MethodWriter of a ClassWriter with no flags to compute the\n+                            \/\/ stack map frames, we know that valid frames must be provided. Otherwise we assume\n+                            \/\/ they are not needed at this stage.\n+                            checkFrames = methodWriter.requiresFrames() && !methodWriter.computesFrames();\n+                        }\n+                        Analyzer<BasicValue> analyzer =\n+                                checkFrames\n+                                        ? new CheckFrameAnalyzer<>(new BasicVerifier())\n+                                        : new Analyzer<>(new BasicVerifier());\n+                        try {\n@@ -501,0 +510,2 @@\n+                            maxLocals = originalMaxLocals;\n+                            maxStack = originalMaxStack;\n@@ -811,1 +822,1 @@\n-        checkLabel(label, false, \"label\");\n+        checkLabel(label, \/* checkVisited = *\/ false, \"label\");\n@@ -813,1 +824,0 @@\n-        referencedLabels.add(label);\n@@ -821,1 +831,1 @@\n-        checkLabel(label, false, \"label\");\n+        checkLabel(label, \/* checkVisited = *\/ false, \"label\");\n@@ -857,1 +867,1 @@\n-        checkLabel(dflt, false, \"default label\");\n+        checkLabel(dflt, \/* checkVisited = *\/ false, \"default label\");\n@@ -862,1 +872,1 @@\n-            checkLabel(labels[i], false, \"label at index \" + i);\n+            checkLabel(labels[i], \/* checkVisited = *\/ false, \"label at index \" + i);\n@@ -865,1 +875,0 @@\n-        Collections.addAll(referencedLabels, labels);\n@@ -873,1 +882,1 @@\n-        checkLabel(dflt, false, \"default label\");\n+        checkLabel(dflt, \/* checkVisited = *\/ false, \"default label\");\n@@ -878,1 +887,1 @@\n-            checkLabel(labels[i], false, \"label at index \" + i);\n+            checkLabel(labels[i], \/* checkVisited = *\/ false, \"label at index \" + i);\n@@ -881,2 +890,0 @@\n-        referencedLabels.add(dflt);\n-        Collections.addAll(referencedLabels, labels);\n@@ -936,3 +943,3 @@\n-        checkLabel(start, false, START_LABEL);\n-        checkLabel(end, false, END_LABEL);\n-        checkLabel(handler, false, \"handler label\");\n+        checkLabel(start, \/* checkVisited = *\/ false, START_LABEL);\n+        checkLabel(end, \/* checkVisited = *\/ false, END_LABEL);\n+        checkLabel(handler, \/* checkVisited = *\/ false, \"handler label\");\n@@ -982,2 +989,2 @@\n-        checkLabel(start, true, START_LABEL);\n-        checkLabel(end, true, END_LABEL);\n+        checkLabel(start, \/* checkVisited = *\/ true, START_LABEL);\n+        checkLabel(end, \/* checkVisited = *\/ true, END_LABEL);\n@@ -1020,2 +1027,2 @@\n-            checkLabel(start[i], true, START_LABEL);\n-            checkLabel(end[i], true, END_LABEL);\n+            checkLabel(start[i], \/* checkVisited = *\/ true, START_LABEL);\n+            checkLabel(end[i], \/* checkVisited = *\/ true, END_LABEL);\n@@ -1039,1 +1046,1 @@\n-        checkLabel(start, true, START_LABEL);\n+        checkLabel(start, \/* checkVisited = *\/ true, START_LABEL);\n@@ -1056,3 +1063,0 @@\n-            if (startInsnIndex == null || endInsnIndex == null) {\n-                throw new IllegalStateException(\"Undefined try catch block labels\");\n-            }\n@@ -1060,1 +1064,1 @@\n-                throw new IllegalStateException(\"Emty try catch block handler range\");\n+                throw new IllegalStateException(\"Empty try catch block handler range\");\n@@ -1119,1 +1123,1 @@\n-            referencedLabels.add((Label) value);\n+            checkLabel((Label) value, \/* checkVisited = *\/ false, \"label\");\n@@ -1132,1 +1136,1 @@\n-        if (opcode < Opcodes.NOP || opcode > Opcodes.IFNONNULL || OPCODE_METHODS[opcode] != method) {\n+        if (opcode < Opcodes.NOP || opcode > Opcodes.IFNONNULL) {\n@@ -1135,0 +1139,4 @@\n+        if (OPCODE_METHODS[opcode] != method) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid combination of opcode and method: \" + opcode + \", \" + method);\n+        }\n@@ -1479,0 +1487,1 @@\n+        referencedLabels.add(label);\n@@ -1483,0 +1492,3 @@\n+        \/** The class version number. *\/\n+        private final int version;\n+\n@@ -1485,1 +1497,5 @@\n-        MethodWriterWrapper(final int api, final ClassWriter owner, final MethodVisitor methodWriter) {\n+        MethodWriterWrapper(\n+                final int api,\n+                final int version,\n+                final ClassWriter owner,\n+                final MethodVisitor methodWriter) {\n@@ -1487,0 +1503,1 @@\n+            this.version = version;\n@@ -1493,0 +1510,8 @@\n+\n+        boolean computesFrames() {\n+            return owner.hasFlags(ClassWriter.COMPUTE_FRAMES);\n+        }\n+\n+        boolean requiresFrames() {\n+            return (version & 0xFFFF) >= Opcodes.V1_7;\n+        }\n@@ -1495,1 +1520,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckMethodAdapter.java","additions":58,"deletions":34,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -245,1 +245,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckModuleAdapter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -154,1 +154,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckRecordComponentAdapter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -392,1 +392,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckSignatureAdapter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -373,2 +373,1 @@\n-      * @param name the internal name of the class (see {@link\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      * @param name the internal name of the class (see {@link Type#getInternalName()}).\n@@ -377,3 +376,3 @@\n-      * @param superName the internal of name of the super class (see {@link\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). For interfaces, the super class is {@link\n-      *     Object}. May be {@literal null}, but only for the {@link Object} class.\n+      * @param superName the internal of name of the super class (see {@link Type#getInternalName()}).\n+      *     For interfaces, the super class is {@link Object}. May be {@literal null}, but only for the\n+      *     {@link Object} class.\n@@ -381,1 +380,1 @@\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *     Type#getInternalName()}). May be {@literal null}.\n@@ -422,1 +421,2 @@\n-      * @param nestHost the internal name of the host class of the nest.\n+      * @param nestHost the internal name of the host class of the nest (see {@link\n+      *     Type#getInternalName()}).\n@@ -431,1 +431,2 @@\n-      * @param owner internal name of the enclosing class of the class.\n+      * @param owner internal name of the enclosing class of the class (see {@link\n+      *     Type#getInternalName()}).\n@@ -452,4 +453,3 @@\n-      *     {@link jdk.internal.org.objectweb.asm.TypeReference#CLASS_TYPE_PARAMETER}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#CLASS_EXTENDS}. See {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference}.\n+      *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link\n+      *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See\n+      *     {@link TypeReference}.\n@@ -482,1 +482,1 @@\n-      * @param nestMember the internal name of a nest member.\n+      * @param nestMember the internal name of a nest member (see {@link Type#getInternalName()}).\n@@ -492,1 +492,2 @@\n-      * @param permittedSubclass the internal name of a permitted subclass.\n+      * @param permittedSubclass the internal name of a permitted subclass (see {@link\n+      *     Type#getInternalName()}).\n@@ -501,2 +502,1 @@\n-      * @param name the internal name of an inner class (see {@link\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      * @param name the internal name of an inner class (see {@link Type#getInternalName()}).\n@@ -504,1 +504,1 @@\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null} for not member classes.\n+      *     Type#getInternalName()}). May be {@literal null} for not member classes.\n@@ -534,1 +534,1 @@\n-      * @param descriptor the field's descriptor (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param descriptor the field's descriptor (see {@link Type}).\n@@ -554,1 +554,1 @@\n-      * @param descriptor the method's descriptor (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param descriptor the method's descriptor (see {@link Type}).\n@@ -558,1 +558,1 @@\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *     Type#getInternalName()}). May be {@literal null}.\n@@ -574,1 +574,2 @@\n-      * @param mainClass the internal name of the main class of the current module.\n+      * @param mainClass the internal name of the main class of the current module (see {@link\n+      *     Type#getInternalName()}).\n@@ -583,1 +584,1 @@\n-      * @param packaze the internal name of a package.\n+      * @param packaze the internal name of a package (see {@link Type#getInternalName()}).\n@@ -604,1 +605,1 @@\n-      * @param packaze the internal name of the exported package.\n+      * @param packaze the internal name of the exported package (see {@link Type#getInternalName()}).\n@@ -617,1 +618,1 @@\n-      * @param packaze the internal name of the opened package.\n+      * @param packaze the internal name of the opened package (see {@link Type#getInternalName()}).\n@@ -630,1 +631,1 @@\n-      * @param service the internal name of the service.\n+      * @param service the internal name of the service (see {@link Type#getInternalName()}).\n@@ -639,1 +640,1 @@\n-      * @param service the internal name of the service.\n+      * @param service the internal name of the service (see {@link Type#getInternalName()}).\n@@ -662,4 +663,4 @@\n-      *     {@link String} or {@link jdk.internal.org.objectweb.asm.Type} of {@link jdk.internal.org.objectweb.asm.Type#OBJECT}\n-      *     or {@link jdk.internal.org.objectweb.asm.Type#ARRAY} sort. This value can also be an array of byte,\n-      *     boolean, short, char, int, long, float or double values (this is equivalent to using {@link\n-      *     #visitArray} and visiting each array element in turn, but is more convenient).\n+      *     {@link String} or {@link Type} of {@link Type#OBJECT} or {@link Type#ARRAY} sort. This\n+      *     value can also be an array of byte, boolean, short, char, int, long, float or double values\n+      *     (this is equivalent to using {@link #visitArray} and visiting each array element in turn,\n+      *     but is more convenient).\n@@ -773,1 +774,1 @@\n-      *     {@link jdk.internal.org.objectweb.asm.TypeReference#FIELD}. See {@link jdk.internal.org.objectweb.asm.TypeReference}.\n+      *     {@link TypeReference#FIELD}. See {@link TypeReference}.\n@@ -831,6 +832,4 @@\n-      *     {@link jdk.internal.org.objectweb.asm.TypeReference#METHOD_TYPE_PARAMETER}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#METHOD_RETURN}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#METHOD_RECEIVER}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#METHOD_FORMAL_PARAMETER} or {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#THROWS}. See {@link jdk.internal.org.objectweb.asm.TypeReference}.\n+      *     {@link TypeReference#METHOD_TYPE_PARAMETER}, {@link\n+      *     TypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link\n+      *     TypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link\n+      *     TypeReference#THROWS}. See {@link TypeReference}.\n@@ -905,3 +904,3 @@\n-      *     Reference types are represented by String objects (representing internal names), and\n-      *     uninitialized types by Label objects (this label designates the NEW instruction that\n-      *     created this uninitialized value).\n+      *     Reference types are represented by String objects (representing internal names, see {@link\n+      *     Type#getInternalName()}), and uninitialized types by Label objects (this label designates\n+      *     the NEW instruction that created this uninitialized value).\n@@ -963,1 +962,1 @@\n-      *     name of an object or array class (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      *     name of an object or array class (see {@link Type#getInternalName()}).\n@@ -972,2 +971,1 @@\n-      * @param owner the internal name of the field's owner class (see {@link\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\n@@ -975,1 +973,1 @@\n-      * @param descriptor the field's descriptor (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param descriptor the field's descriptor (see {@link Type}).\n@@ -985,1 +983,1 @@\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      *     Type#getInternalName()}).\n@@ -987,1 +985,1 @@\n-      * @param descriptor the method's descriptor (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param descriptor the method's descriptor (see {@link Type}).\n@@ -1005,1 +1003,1 @@\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      *     Type#getInternalName()}).\n@@ -1007,1 +1005,1 @@\n-      * @param descriptor the method's descriptor (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param descriptor the method's descriptor (see {@link Type}).\n@@ -1023,1 +1021,1 @@\n-      * @param descriptor the method's descriptor (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param descriptor the method's descriptor (see {@link Type}).\n@@ -1027,2 +1025,2 @@\n-      *     jdk.internal.org.objectweb.asm.Type} or {@link Handle} value. This method is allowed to modify the\n-      *     content of the array so a caller should expect that this array may change.\n+      *     Type} or {@link Handle} value. This method is allowed to modify the content of the array so\n+      *     a caller should expect that this array may change.\n@@ -1098,1 +1096,1 @@\n-      * @param descriptor an array type descriptor (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param descriptor an array type descriptor (see {@link Type}).\n@@ -1107,10 +1105,6 @@\n-      *     {@link jdk.internal.org.objectweb.asm.TypeReference#INSTANCEOF}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#NEW}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#CONSTRUCTOR_REFERENCE}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#METHOD_REFERENCE}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#CAST}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference}.\n+      *     {@link TypeReference#INSTANCEOF}, {@link TypeReference#NEW}, {@link\n+      *     TypeReference#CONSTRUCTOR_REFERENCE}, {@link TypeReference#METHOD_REFERENCE}, {@link\n+      *     TypeReference#CAST}, {@link TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link\n+      *     TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT}, {@link\n+      *     TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link\n+      *     TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link TypeReference}.\n@@ -1135,2 +1129,3 @@\n-      * @param type the internal name of the type of exceptions handled by the handler, or {@literal\n-      *     null} to catch any exceptions (for \"finally\" blocks).\n+      * @param type the internal name of the type of exceptions handled by the handler (see {@link\n+      *     Type#getInternalName()}), or {@literal null} to catch any exceptions (for \"finally\"\n+      *     blocks).\n@@ -1145,2 +1140,1 @@\n-      *     {@link jdk.internal.org.objectweb.asm.TypeReference#EXCEPTION_PARAMETER}. See {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference}.\n+      *     {@link TypeReference#EXCEPTION_PARAMETER}. See {@link TypeReference}.\n@@ -1179,3 +1173,2 @@\n-      *     {@link jdk.internal.org.objectweb.asm.TypeReference#LOCAL_VARIABLE} or {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#RESOURCE_VARIABLE}. See {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference}.\n+      *     {@link TypeReference#LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE}. See {@link\n+      *     TypeReference}.\n@@ -1350,1 +1343,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/Printer.java","additions":62,"deletions":70,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -90,1 +90,3 @@\n-    \/** The type of internal names. See {@link #appendDescriptor}. *\/\n+    \/**\n+      * The type of internal names (see {@link Type#getInternalName()}). See {@link #appendDescriptor}.\n+      *\/\n@@ -1358,1 +1360,2 @@\n-      * @param value an internal name, type descriptor or a type signature. May be {@literal null}.\n+      * @param value an internal name (see {@link Type#getInternalName()}), type descriptor or a type\n+      *     signature. May be {@literal null}.\n@@ -1634,1 +1637,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/Textifier.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/TextifierSupport.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/TraceAnnotationVisitor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -277,1 +277,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/TraceClassVisitor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/TraceFieldVisitor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -345,1 +345,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/TraceMethodVisitor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -129,1 +129,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/TraceRecordComponentVisitor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -377,1 +377,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/TraceSignatureVisitor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-ASM_9_3\n+ASM_9_6\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/version.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## ASM Bytecode Manipulation Framework v9.3\n+## ASM Bytecode Manipulation Framework v9.6\n","filename":"src\/java.base\/share\/legal\/asm.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}