{"files":[{"patch":"@@ -1324,4 +1324,1 @@\n-all-images: product-images test-image all-docs-images\n-ifeq ($(call isTargetOs, linux macosx windows), true)\n-  all-images: static-jdk-image\n-endif\n+all-images: product-images static-jdk-image test-image all-docs-images\n","filename":"make\/Main.gmk","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+include Execute.gmk\n@@ -71,0 +72,4 @@\n+else ifeq ($(call isTargetOs, aix), true)\n+  # libsplashscreen has a name conflict with libawt in the function\n+  # BitmapToYXBandedRectangles, so we exclude it for now.\n+  BROKEN_STATIC_LIBS += splashscreen\n@@ -102,0 +107,12 @@\n+else ifeq ($(call isTargetOs, aix), true)\n+  # on AIX we have to generate export files for all static libs, because we have no whole-archive linker flag\n+  $(foreach lib, $(STATIC_LIB_FILES), \\\n+    $(eval $(call SetupExecute, generate_export_list_$(notdir $(lib)), \\\n+      INFO := Generating export list for $(notdir $(lib)), \\\n+      DEPS :=  $(lib), \\\n+      OUTPUT_FILE := $(lib).exp, \\\n+      COMMAND := ( $(AR) $(ARFLAGS) -w $(lib) | $(GREP) -v '^\\.' | $(AWK) '{print $$1}' | $(SORT) -u > $(lib).exp ), \\\n+    )) \\\n+    $(eval STATIC_LIB_EXPORT_FILES += $(lib).exp) \\\n+  )\n+  STATIC_LIBS := -Wl,-bexpfull $(STATIC_LIB_FILES) $(addprefix -Wl$(COMMA)-bE:, $(STATIC_LIB_EXPORT_FILES))\n@@ -121,0 +138,3 @@\n+ifeq ($(call isTargetOs, aix), true)\n+  $(java): $(STATIC_LIB_EXPORT_FILES)\n+endif\n","filename":"make\/StaticLibs.gmk","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -175,0 +175,8 @@\n+\n+  # This is the object file to provide the dladdr API, which is not\n+  # part of AIX. It occurs several times in the jdk code base.\n+  # Do not include it. When statically linking the java\n+  # launcher with all JDK and VM static libraries, we use the\n+  # --whole-archive linker option. The duplicate objects in different\n+  # static libraries cause linking errors due to duplicate symbols.\n+  LIBJLI_STATIC_EXCLUDE_OBJS += java_md_aix.o\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -98,0 +98,10 @@\n+# This is the object file to provide the dladdr API, which is not\n+# part of AIX. It occurs several times in the jdk code base.\n+# Do not include it. When statically linking the java\n+# launcher with all JDK and VM static libraries, we use the\n+# --whole-archive linker option. The duplicate objects in different\n+# static libraries cause linking errors due to duplicate symbols.\n+ifeq ($(call isTargetOs, aix), true)\n+  LIBAWT_STATIC_EXCLUDE_OBJS := porting_aix.o\n+endif\n+\n@@ -143,0 +153,1 @@\n+    STATIC_LIB_EXCLUDE_OBJS := $(LIBAWT_STATIC_EXCLUDE_OBJS), \\\n","filename":"make\/modules\/java.desktop\/lib\/AwtLibraries.gmk","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+\/\/ For getargs()\n+#include <procinfo.h>\n+\n@@ -208,0 +211,16 @@\n+  \/\/ the entry for the executable itself does not contain a path.\n+  \/\/ instead we retrieve the path of the executable with the getargs API.\n+  static char pgmpath[PATH_MAX+1] = \"\";\n+  static char* pgmbase = nullptr;\n+  if (pgmpath[0] == 0) {\n+    procentry64 PInfo;\n+    PInfo.pi_pid = ::getpid();\n+    if ( 0 == ::getargs(&PInfo, sizeof(PInfo), (char*)pgmpath,PATH_MAX) && *pgmpath ) {\n+      pgmpath[PATH_MAX] = '\\0';\n+      pgmbase = strrchr(pgmpath, '\/');\n+      if (pgmbase) {\n+        pgmbase +=1;\n+      }\n+    }\n+  }\n+\n@@ -226,1 +245,6 @@\n-    lm->path = g_stringlist.add(ldi->ldinfo_filename);\n+    if (pgmbase && 0 == strcmp(pgmbase, ldi->ldinfo_filename)) {\n+      lm->path = g_stringlist.add(pgmpath);\n+    } else {\n+      lm->path = g_stringlist.add(ldi->ldinfo_filename);\n+    }\n+\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"}]}