{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.ByteBuffer;\n@@ -199,2 +198,2 @@\n-    public ByteBuffer asByteBuffer() {\n-        return ByteBuffer.wrap(elems, 0, offset).slice();\n+    public RawBytecodeHelper.CodeRange bytecodeView() {\n+        return RawBytecodeHelper.of(elems, offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,6 +27,9 @@\n-import java.nio.ByteBuffer;\n-import static java.lang.classfile.ClassFile.ASTORE_3;\n-import static java.lang.classfile.ClassFile.ISTORE;\n-import static java.lang.classfile.ClassFile.LOOKUPSWITCH;\n-import static java.lang.classfile.ClassFile.TABLESWITCH;\n-import static java.lang.classfile.ClassFile.WIDE;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.Preconditions;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import static java.lang.classfile.ClassFile.*;\n@@ -36,0 +39,14 @@\n+    public static final BiFunction<String, List<Number>, IllegalArgumentException>\n+            IAE_FORMATTER = Preconditions.outOfBoundsExceptionFormatter(new Function<>() {\n+        @Override\n+        public IllegalArgumentException apply(String s) {\n+            return new IllegalArgumentException(s);\n+        }\n+    });\n+\n+    public record CodeRange(byte[] array, int length) {\n+        public RawBytecodeHelper start() {\n+            return new RawBytecodeHelper(this);\n+        }\n+    }\n+\n@@ -38,6 +55,32 @@\n-    private static final byte[] LENGTHS = new byte[] {\n-        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 2, 3, 3, 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-        2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 | (6 << 4), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2 | (4 << 4), 0, 0, 1, 1, 1,\n-        1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 5, 5, 3, 2, 3, 1, 1, 3, 3, 1, 1, 0, 4, 3, 3, 5, 5, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 4, 4, 4, 2, 4, 3, 3, 0, 0, 1, 3, 2, 3, 3, 3, 1, 2, 1,\n-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n+    \/**\n+     * The length of opcodes, or -1 for no fixed length.\n+     * This is generated as if:\n+     * {@snippet lang=java :\n+     * var lengths = new byte[0x100];\n+     * Arrays.fill(lengths, (byte) -1);\n+     * for (var op : Opcode.values()) {\n+     *     if (!op.isWide()) {\n+     *         lengths[op.bytecode()] = (byte) op.sizeIfFixed();\n+     *     }\n+     * }\n+     * }\n+     * Tested in UtilTest::testOpcodeLengthTable.\n+     *\/\n+    \/\/ Note: Consider distinguishing non-opcode and non-fixed-length opcode\n+    public static final @Stable byte[] LENGTHS = new byte[] {\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            2, 3, 2, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3,\n+            3, 3, 3, 3, 3, 3, 3, 3, 3, 2, -1, -1, 1, 1, 1, 1,\n+            1, 1, 3, 3, 3, 3, 3, 3, 3, 5, 5, 3, 2, 3, 1, 1,\n+            3, 3, 1, 1, -1, 4, 3, 3, 5, 5, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n@@ -54,4 +97,6 @@\n-    private final ByteBuffer bytecode;\n-    public int bci, nextBci, endBci;\n-    public int rawCode;\n-    public boolean isWide;\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    public final CodeRange code;\n+    private int nextBci;\n+    private int bci;\n+    private int opcode;\n+    private boolean isWide;\n@@ -59,5 +104,2 @@\n-    public RawBytecodeHelper(ByteBuffer bytecode) {\n-        this.bytecode = bytecode;\n-        this.bci = 0;\n-        this.nextBci = 0;\n-        this.endBci = bytecode.capacity();\n+    public static CodeRange of(byte[] array) {\n+        return new CodeRange(array, array.length);\n@@ -66,2 +108,2 @@\n-    public boolean isLastBytecode() {\n-        return nextBci >= endBci;\n+    public static CodeRange of(byte[] array, int limit) {\n+        return new CodeRange(array, limit);\n@@ -70,2 +112,2 @@\n-    public int getShort(int bci) {\n-        return bytecode.getShort(bci);\n+    private RawBytecodeHelper(CodeRange range) {\n+        this.code = range;\n@@ -74,2 +116,5 @@\n-    public int dest() {\n-        return bci + getShort(bci + 1);\n+    \/\/ immutable states\n+\n+    \/** {@return the end of the code array} *\/\n+    public int endBci() {\n+        return code.length;\n@@ -78,2 +123,10 @@\n-    public int getInt(int bci) {\n-        return bytecode.getInt(bci);\n+    \/\/ setup\n+\n+    \/**\n+     * Sets the starting bci for bytecode reading. Can be set to\n+     * {@link #endBci} to end scanning. Must be followed by a\n+     * {@link #next} before getter access.\n+     *\/\n+    public void reset(int nextBci) {\n+        Preconditions.checkIndex(nextBci, endBci() + 1, IAE_FORMATTER);\n+        this.nextBci = nextBci;\n@@ -82,2 +135,10 @@\n-    public int destW() {\n-        return bci + getInt(bci + 1);\n+    \/\/ getters after transition\n+\n+    \/**\n+     * Returns the current functional opcode, or {@link #ILLEGAL} if\n+     * the next instruction is invalid in format.\n+     * If this returns a valid opcode, that instruction's format must\n+     * be valid and can be accessed unchecked.\n+     *\/\n+    public int opcode() {\n+        return opcode;\n@@ -86,2 +147,5 @@\n-    public int getIndexU1() {\n-        return bytecode.get(bci + 1) & 0xff;\n+    \/**\n+     * Returns whether the current functional opcode is in wide.\n+     *\/\n+    public boolean isWide() {\n+        return isWide;\n@@ -90,0 +154,9 @@\n+    \/**\n+     * Returns the last validated instruction's index.\n+     *\/\n+    public int bci() {\n+        return bci;\n+    }\n+\n+    \/\/ general utilities\n+\n@@ -91,1 +164,2 @@\n-        return bytecode.get(bci) & 0xff;\n+        Preconditions.checkIndex(bci, endBci(), IAE_FORMATTER);\n+        return getU1Unchecked(bci);\n@@ -94,3 +168,3 @@\n-    public int rawNext(int jumpTo) {\n-        this.nextBci = jumpTo;\n-        return rawNext();\n+    public int getU2(int bci) {\n+        Preconditions.checkFromIndexSize(bci, 2, endBci(), IAE_FORMATTER);\n+        return getU2Unchecked(bci);\n@@ -99,59 +173,18 @@\n-    public int rawNext() {\n-        bci = nextBci;\n-        int code = bytecode.get(bci) & 0xff;\n-        int len = LENGTHS[code] & 0xf;\n-        if (len > 0 && (bci <= endBci - len)) {\n-            isWide = false;\n-            nextBci += len;\n-            if (nextBci <= bci) {\n-                code = ILLEGAL;\n-            }\n-            rawCode = code;\n-            return code;\n-        } else {\n-            len = switch (bytecode.get(bci) & 0xff) {\n-                case WIDE -> {\n-                    if (bci + 1 >= endBci) {\n-                        yield -1;\n-                    }\n-                    yield LENGTHS[bytecode.get(bci + 1) & 0xff] >> 4;\n-                }\n-                case TABLESWITCH -> {\n-                    int aligned_bci = align(bci + 1);\n-                    if (aligned_bci + 3 * 4 >= endBci) {\n-                        yield -1;\n-                    }\n-                    int lo = bytecode.getInt(aligned_bci + 1 * 4);\n-                    int hi = bytecode.getInt(aligned_bci + 2 * 4);\n-                    int l = aligned_bci - bci + (3 + hi - lo + 1) * 4;\n-                    if (l > 0) yield l; else yield -1;\n-                }\n-                case LOOKUPSWITCH -> {\n-                    int aligned_bci = align(bci + 1);\n-                    if (aligned_bci + 2 * 4 >= endBci) {\n-                        yield -1;\n-                    }\n-                    int npairs = bytecode.getInt(aligned_bci + 4);\n-                    int l = aligned_bci - bci + (2 + 2 * npairs) * 4;\n-                    if (l > 0) yield l; else yield -1;\n-                }\n-                default ->\n-                    0;\n-            };\n-            if (len <= 0 || (bci > endBci - len) || (bci - len >= nextBci)) {\n-                code = ILLEGAL;\n-            } else {\n-                nextBci += len;\n-                isWide = false;\n-                if (code == WIDE) {\n-                    if (bci + 1 >= endBci) {\n-                        code = ILLEGAL;\n-                    } else {\n-                        code = bytecode.get(bci + 1) & 0xff;\n-                        isWide = true;\n-                    }\n-                }\n-            }\n-            rawCode = code;\n-            return code;\n-        }\n+    public int getShort(int bci) {\n+        Preconditions.checkFromIndexSize(bci, 2, endBci(), IAE_FORMATTER);\n+        return getShortUnchecked(bci);\n+    }\n+\n+    public int getInt(int bci) {\n+        Preconditions.checkFromIndexSize(bci, 4, endBci(), IAE_FORMATTER);\n+        return getIntUnchecked(bci);\n+    }\n+\n+    \/\/ Unchecked accessors: only if opcode() is validated\n+\n+    public int getU1Unchecked(int bci) {\n+        return Byte.toUnsignedInt(code.array[bci]);\n+    }\n+\n+    public int getU2Unchecked(int bci) {\n+        return UNSAFE.getCharUnaligned(code.array, (long) Unsafe.ARRAY_BYTE_BASE_OFFSET + bci, true);\n@@ -160,0 +193,20 @@\n+    public int getShortUnchecked(int bci) {\n+        return UNSAFE.getShortUnaligned(code.array, (long) Unsafe.ARRAY_BYTE_BASE_OFFSET + bci, true);\n+    }\n+\n+    \/\/ used after switch validation\n+    public int getIntUnchecked(int bci) {\n+        return UNSAFE.getIntUnaligned(code.array, (long) Unsafe.ARRAY_BYTE_BASE_OFFSET + bci, true);\n+    }\n+\n+    \/\/ non-wide branches\n+    public int dest() {\n+        return bci + getShortUnchecked(bci + 1);\n+    }\n+\n+    \/\/ goto_w and jsr_w\n+    public int destW() {\n+        return bci + getIntUnchecked(bci + 1);\n+    }\n+\n+    \/\/ *load, *store, iinc\n@@ -161,1 +214,1 @@\n-        return (isWide) ? getIndexU2Raw(bci + 2) : getIndexU1();\n+        return isWide ? getU2Unchecked(bci + 2) : getIndexU1();\n@@ -164,0 +217,6 @@\n+    \/\/ ldc\n+    public int getIndexU1() {\n+        return getU1Unchecked(bci + 1);\n+    }\n+\n+    \/\/ usually cp entry index\n@@ -165,1 +224,1 @@\n-        return getIndexU2Raw(bci + 1);\n+        return getU2Unchecked(bci + 1);\n@@ -168,2 +227,65 @@\n-    public int getIndexU2Raw(int bci) {\n-        return bytecode.getShort(bci) & 0xffff;\n+    \/\/ Transition methods\n+\n+    \/**\n+     * Transitions to the next instruction and returns whether scanning should\n+     * continue. If the next instruction is malformed, {@link #opcode()} returns\n+     * {@link #ILLEGAL}, so we can perform value access without bound checks if\n+     * we have a valid opcode.\n+     *\/\n+    public boolean next() {\n+        var bci = nextBci;\n+        var end = endBci();\n+        if (bci >= end) {\n+            return false;\n+        }\n+\n+        int code = getU1Unchecked(bci);\n+        int len = LENGTHS[code & 0xFF]; \/\/ & 0xFF eliminates bound check\n+        this.bci = bci;\n+        opcode = code;\n+        isWide = false;\n+        if (len <= 0) {\n+            len = checkSpecialInstruction(bci, end, code); \/\/ sets opcode\n+        }\n+\n+        if (len <= 0 || (nextBci += len) > end) {\n+            opcode = ILLEGAL;\n+        }\n+\n+        return true;\n+    }\n+\n+    \/\/ Put rarely used code in another method to reduce code size\n+    private int checkSpecialInstruction(int bci, int end, int code) {\n+        if (code == WIDE) {\n+            if (bci + 1 >= end) {\n+                return -1;\n+            }\n+            opcode = code = getIndexU1();\n+            isWide = true;\n+            \/\/ Validated in UtilTest.testOpcodeLengthTable\n+            return LENGTHS[code] * 2;\n+        }\n+        if (code == TABLESWITCH) {\n+            int alignedBci = align(bci + 1);\n+            if (alignedBci + 3 * 4 >= end) {\n+                return -1;\n+            }\n+            int lo = getIntUnchecked(alignedBci + 1 * 4);\n+            int hi = getIntUnchecked(alignedBci + 2 * 4);\n+            long l = alignedBci - bci + (3L + (long) hi - lo + 1L) * 4L;\n+            return l > 0 && ((int) l == l) ? (int) l : -1;\n+        }\n+        if (code == LOOKUPSWITCH) {\n+            int alignedBci = align(bci + 1);\n+            if (alignedBci + 2 * 4 >= end) {\n+                return -1;\n+            }\n+            int npairs = getIntUnchecked(alignedBci + 4);\n+            if (npairs < 0) {\n+                return -1;\n+            }\n+            long l = alignedBci - bci + (2L + 2L * npairs) * 4L;\n+            return l > 0 && ((int) l == l) ? (int) l : -1;\n+        }\n+        return -1;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/RawBytecodeHelper.java","additions":223,"deletions":101,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.nio.ByteBuffer;\n@@ -58,1 +57,1 @@\n-                dcb.bytecodesBufWriter.asByteBuffer(),\n+                dcb.bytecodesBufWriter.bytecodeView(),\n@@ -70,1 +69,0 @@\n-    private final ByteBuffer bytecode;\n@@ -94,1 +92,1 @@\n-                bcs.nextBci = en.bci;\n+                bcs.reset(en.bci);\n@@ -99,1 +97,1 @@\n-        bcs.nextBci = bcs.endBci;\n+        bcs.reset(bcs.endBci());\n@@ -109,1 +107,1 @@\n-                     ByteBuffer bytecode,\n+                     RawBytecodeHelper.CodeRange bytecode,\n@@ -116,1 +114,0 @@\n-        this.bytecode = bytecode;\n@@ -135,2 +132,2 @@\n-        bcs = new RawBytecodeHelper(bytecode);\n-        visited = new BitSet(bcs.endBci);\n+        bcs = bytecode.start();\n+        visited = new BitSet(bcs.endBci());\n@@ -139,4 +136,3 @@\n-            while (!bcs.isLastBytecode()) {\n-                bcs.rawNext();\n-                int opcode = bcs.rawCode;\n-                int bci = bcs.bci;\n+            while (bcs.next()) {\n+                int opcode = bcs.opcode();\n+                int bci = bcs.bci();\n@@ -270,1 +266,1 @@\n-                        int defaultOfset = bcs.getInt(alignedBci);\n+                        int defaultOffset = bcs.getIntUnchecked(alignedBci);\n@@ -273,3 +269,3 @@\n-                        if (bcs.rawCode == TABLESWITCH) {\n-                            int low = bcs.getInt(alignedBci + 4);\n-                            int high = bcs.getInt(alignedBci + 2 * 4);\n+                        if (bcs.opcode() == TABLESWITCH) {\n+                            int low = bcs.getIntUnchecked(alignedBci + 4);\n+                            int high = bcs.getIntUnchecked(alignedBci + 2 * 4);\n@@ -285,1 +281,1 @@\n-                            keys = bcs.getInt(alignedBci + 4);\n+                            keys = bcs.getIntUnchecked(alignedBci + 4);\n@@ -291,2 +287,2 @@\n-                                int this_key = bcs.getInt(alignedBci + (2 + 2 * i) * 4);\n-                                int next_key = bcs.getInt(alignedBci + (2 + 2 * i + 2) * 4);\n+                                int this_key = bcs.getIntUnchecked(alignedBci + (2 + 2 * i) * 4);\n+                                int next_key = bcs.getIntUnchecked(alignedBci + (2 + 2 * i + 2) * 4);\n@@ -298,1 +294,1 @@\n-                        int target = bci + defaultOfset;\n+                        int target = bci + defaultOffset;\n@@ -301,2 +297,1 @@\n-                            alignedBci = RawBytecodeHelper.align(bcs.bci + 1);\n-                            target = bci + bcs.getInt(alignedBci + (3 + i * delta) * 4);\n+                            target = bci + bcs.getIntUnchecked(alignedBci + (3 + i * delta) * 4);\n@@ -317,1 +312,1 @@\n-                        switch (bcs.rawCode) {\n+                        switch (bcs.opcode()) {\n@@ -340,1 +335,1 @@\n-                        addStackSlot(1 - bcs.getU1(bcs.bci + 3));\n+                        addStackSlot(1 - bcs.getU1Unchecked(bcs.bci() + 3));\n@@ -398,1 +393,1 @@\n-                bcs.bci,\n+                bcs.bci(),\n@@ -401,1 +396,1 @@\n-        Util.dumpMethod(cp, thisClass, methodName, methodDesc, isStatic ? ACC_STATIC : 0, bytecode, sb::append);\n+        Util.dumpMethod(cp, thisClass, methodName, methodDesc, isStatic ? ACC_STATIC : 0, bcs.code, sb::append);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":22,"deletions":27,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.nio.ByteBuffer;\n@@ -49,0 +48,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -155,1 +155,1 @@\n-                dcb.bytecodesBufWriter.asByteBuffer(),\n+                dcb.bytecodesBufWriter.bytecodeView(),\n@@ -191,1 +191,1 @@\n-    private final ByteBuffer bytecode;\n+    private final RawBytecodeHelper.CodeRange bytecode;\n@@ -225,1 +225,1 @@\n-                     ByteBuffer bytecode,\n+                     RawBytecodeHelper.CodeRange bytecode,\n@@ -292,1 +292,1 @@\n-        exMin = bytecode.capacity();\n+        exMin = bytecode.length();\n@@ -329,1 +329,1 @@\n-                int blockSize = (i < framesCount - 1 ? frames.get(i + 1).offset : bytecode.limit()) - frame.offset;\n+                int end = (i < framesCount - 1 ? frames.get(i + 1).offset : bytecode.length()) - 1;\n@@ -331,5 +331,3 @@\n-                bytecode.position(frame.offset);\n-                for (int n=1; n<blockSize; n++) {\n-                    bytecode.put((byte) NOP);\n-                }\n-                bytecode.put((byte) ATHROW);\n+                var arr = bytecode.array();\n+                Arrays.fill(arr, frame.offset, end, (byte) NOP);\n+                arr[end] = (byte) ATHROW;\n@@ -337,1 +335,1 @@\n-                removeRangeFromExcTable(frame.offset, frame.offset + blockSize);\n+                removeRangeFromExcTable(frame.offset, end + 1);\n@@ -410,1 +408,1 @@\n-        RawBytecodeHelper bcs = new RawBytecodeHelper(bytecode);\n+        var bcs = bytecode.start();\n@@ -412,3 +410,2 @@\n-        while (!bcs.isLastBytecode()) {\n-            bcs.rawNext();\n-            currentFrame.offset = bcs.bci;\n+        while (bcs.next()) {\n+            currentFrame.offset = bcs.bci();\n@@ -417,1 +414,1 @@\n-                if (ncf && thisOffset > bcs.bci) {\n+                if (ncf && thisOffset > bcs.bci()) {\n@@ -420,1 +417,1 @@\n-                if (thisOffset == bcs.bci) {\n+                if (thisOffset == bcs.bci()) {\n@@ -429,2 +426,3 @@\n-                    bcs.rawNext(nextFrame.offset); \/\/skip code up-to the next frame\n-                    currentFrame.offset = bcs.bci;\n+                    bcs.reset(nextFrame.offset); \/\/skip code up-to the next frame\n+                    bcs.next();\n+                    currentFrame.offset = bcs.bci();\n@@ -433,1 +431,1 @@\n-                } else if (thisOffset < bcs.bci) {\n+                } else if (thisOffset < bcs.bci()) {\n@@ -444,1 +442,1 @@\n-        int opcode = bcs.rawCode;\n+        int opcode = bcs.opcode();\n@@ -448,1 +446,1 @@\n-        int bci = bcs.bci;\n+        int bci = bcs.bci();\n@@ -654,1 +652,1 @@\n-                int dim = bcs.getU1(bcs.bci + 3);\n+                int dim = bcs.getU1Unchecked(bcs.bci() + 3);\n@@ -711,1 +709,1 @@\n-        int bci = bcs.bci;\n+        int bci = bcs.bci();\n@@ -713,1 +711,1 @@\n-        int defaultOfset = bcs.getInt(alignedBci);\n+        int defaultOffset = bcs.getIntUnchecked(alignedBci);\n@@ -716,3 +714,3 @@\n-        if (bcs.rawCode == TABLESWITCH) {\n-            int low = bcs.getInt(alignedBci + 4);\n-            int high = bcs.getInt(alignedBci + 2 * 4);\n+        if (bcs.opcode() == TABLESWITCH) {\n+            int low = bcs.getIntUnchecked(alignedBci + 4);\n+            int high = bcs.getIntUnchecked(alignedBci + 2 * 4);\n@@ -728,1 +726,1 @@\n-            keys = bcs.getInt(alignedBci + 4);\n+            keys = bcs.getIntUnchecked(alignedBci + 4);\n@@ -734,2 +732,2 @@\n-                int this_key = bcs.getInt(alignedBci + (2 + 2 * i) * 4);\n-                int next_key = bcs.getInt(alignedBci + (2 + 2 * i + 2) * 4);\n+                int this_key = bcs.getIntUnchecked(alignedBci + (2 + 2 * i) * 4);\n+                int next_key = bcs.getIntUnchecked(alignedBci + (2 + 2 * i + 2) * 4);\n@@ -741,1 +739,1 @@\n-        int target = bci + defaultOfset;\n+        int target = bci + defaultOffset;\n@@ -744,2 +742,1 @@\n-            alignedBci = RawBytecodeHelper.align(bcs.bci + 1);\n-            target = bci + bcs.getInt(alignedBci + (3 + i * delta) * 4);\n+            target = bci + bcs.getIntUnchecked(alignedBci + (3 + i * delta) * 4);\n@@ -752,1 +749,1 @@\n-        switch (bcs.rawCode) {\n+        switch (bcs.opcode()) {\n@@ -774,1 +771,1 @@\n-        int opcode = bcs.rawCode;\n+        int opcode = bcs.opcode();\n@@ -780,1 +777,1 @@\n-        int bci = bcs.bci;\n+        int bci = bcs.bci();\n@@ -793,1 +790,1 @@\n-                    int new_class_index = bcs.getIndexU2Raw(new_offset + 1);\n+                    int new_class_index = bcs.getU2(new_offset + 1);\n@@ -852,1 +849,1 @@\n-                if (i < 0 || i >= bytecode.capacity()) throw new IllegalArgumentException();\n+                Preconditions.checkIndex(i, bytecode.length(), RawBytecodeHelper.IAE_FORMATTER);\n@@ -856,1 +853,1 @@\n-        RawBytecodeHelper bcs = new RawBytecodeHelper(bytecode);\n+        var bcs = bytecode.start();\n@@ -859,3 +856,3 @@\n-        while (!bcs.isLastBytecode()) try {\n-            opcode = bcs.rawNext();\n-            bci = bcs.bci;\n+        while (bcs.next()) try {\n+            opcode = bcs.opcode();\n+            bci = bcs.bci();\n@@ -883,1 +880,1 @@\n-                            int default_ofset = bcs.getInt(aligned_bci);\n+                            int default_ofset = bcs.getIntUnchecked(aligned_bci);\n@@ -885,3 +882,3 @@\n-                            if (bcs.rawCode == TABLESWITCH) {\n-                                int low = bcs.getInt(aligned_bci + 4);\n-                                int high = bcs.getInt(aligned_bci + 2 * 4);\n+                            if (bcs.opcode() == TABLESWITCH) {\n+                                int low = bcs.getIntUnchecked(aligned_bci + 4);\n+                                int high = bcs.getIntUnchecked(aligned_bci + 2 * 4);\n@@ -891,1 +888,1 @@\n-                                keys = bcs.getInt(aligned_bci + 4);\n+                                keys = bcs.getIntUnchecked(aligned_bci + 4);\n@@ -896,1 +893,1 @@\n-                                offsets.set(bci + bcs.getInt(aligned_bci + (3 + i * delta) * 4));\n+                                offsets.set(bci + bcs.getIntUnchecked(aligned_bci + (3 + i * delta) * 4));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":47,"deletions":50,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-import java.nio.ByteBuffer;\n@@ -273,1 +272,1 @@\n-                                  ByteBuffer bytecode,\n+                                  RawBytecodeHelper.CodeRange bytecode,\n@@ -286,2 +285,2 @@\n-                                    b.writeInt(bytecode.limit());\n-                                    b.writeBytes(bytecode.array(), 0, bytecode.limit());\n+                                    b.writeInt(bytecode.length());\n+                                    b.writeBytes(bytecode.array(), 0, bytecode.length());\n@@ -295,6 +294,8 @@\n-            bytecode.rewind();\n-            while (bytecode.position() < bytecode.limit()) {\n-                dump.accept(\"%n%04x:\".formatted(bytecode.position()));\n-                for (int i = 0; i < 16 && bytecode.position() < bytecode.limit(); i++) {\n-                    dump.accept(\" %02x\".formatted(bytecode.get()));\n-                }\n+            dumpBytesHex(dump, bytecode.array(), bytecode.length());\n+        }\n+    }\n+\n+    public static void dumpBytesHex(Consumer<String> dump, byte[] bytes, int length) {\n+        for (int i = 0; i < length; i++) {\n+            if (i % 16 == 0) {\n+                dump.accept(\"%n%04x:\".formatted(i));\n@@ -302,0 +303,1 @@\n+            dump.accept(\" %02x\".formatted(bytes[i]));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.nio.ByteBuffer;\n-\n@@ -30,0 +28,1 @@\n+\n@@ -86,4 +85,0 @@\n-    static int wide_length_for(int code) {\n-        return is_valid(code) ? _lengths[code] >> 4 : -1;\n-    }\n-\n@@ -96,32 +91,0 @@\n-    static int special_length_at(int code, byte bytecode[], int bci, int end) {\n-        switch (code) {\n-            case ClassFile.WIDE:\n-                if (bci + 1 >= end) {\n-                    return -1;\n-                }\n-                return wide_length_for(bytecode[bci + 1] & 0xff);\n-            case ClassFile.TABLESWITCH:\n-                int aligned_bci = align(bci + 1);\n-                if (aligned_bci + 3 * 4 >= end) {\n-                    return -1;\n-                }\n-                ByteBuffer bb = ByteBuffer.wrap(bytecode, aligned_bci + 1 * 4, 2 * 4);\n-                int lo = bb.getInt();\n-                int hi = bb.getInt();\n-                int len = aligned_bci - bci + (3 + hi - lo + 1) * 4;\n-                return len > 0 ? len : -1;\n-            case ClassFile.LOOKUPSWITCH:\n-            case _fast_binaryswitch:\n-            case _fast_linearswitch:\n-                aligned_bci = align(bci + 1);\n-                if (aligned_bci + 2 * 4 >= end) {\n-                    return -1;\n-                }\n-                int npairs = ByteBuffer.wrap(bytecode, aligned_bci + 4, 4).getInt();\n-                len = aligned_bci - bci + (2 + 2 * npairs) * 4;\n-                return len > 0 ? len : -1;\n-            default:\n-                return 0;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationBytecodes.java","additions":1,"deletions":38,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -319,2 +318,2 @@\n-        var code = ByteBuffer.wrap(codeArray, 0, _method.codeLength());\n-        byte[] code_data = generate_code_data(code, code_length);\n+        var code = RawBytecodeHelper.of(codeArray);\n+        byte[] code_data = generate_code_data(code);\n@@ -327,1 +326,1 @@\n-        var bcs = new RawBytecodeHelper(code);\n+        var bcs = code.start();\n@@ -330,3 +329,3 @@\n-        while (!bcs.isLastBytecode()) {\n-            opcode = bcs.rawNext();\n-            bci = bcs.bci;\n+        while (bcs.next()) {\n+            opcode = bcs.opcode();\n+            bci = bcs.bci();\n@@ -343,1 +342,1 @@\n-                if (bcs.isWide) {\n+                if (bcs.isWide()) {\n@@ -1198,1 +1197,1 @@\n-                        int dim = _method.codeArray()[bcs.bci+3] & 0xff;\n+                        int dim = _method.codeArray()[bcs.bci() +3] & 0xff;\n@@ -1233,7 +1232,7 @@\n-    private byte[] generate_code_data(ByteBuffer code, int code_length) {\n-        byte code_data[] = new byte[code_length];\n-        var bcs = new RawBytecodeHelper(code);\n-        while (!bcs.isLastBytecode()) {\n-            if (bcs.rawNext() != ILLEGAL) {\n-                int bci = bcs.bci;\n-                if (bcs.rawCode == ClassFile.NEW) {\n+    private byte[] generate_code_data(RawBytecodeHelper.CodeRange code) {\n+        byte[] code_data = new byte[code.length()];\n+        var bcs = code.start();\n+        while (bcs.next()) {\n+            if (bcs.opcode() != ILLEGAL) {\n+                int bci = bcs.bci();\n+                if (bcs.opcode() == ClassFile.NEW) {\n@@ -1413,1 +1412,1 @@\n-        int bci = bcs.bci;\n+        int bci = bcs.bci();\n@@ -1425,1 +1424,1 @@\n-        int default_ofset = bcs.getInt(aligned_bci);\n+        int default_offset = bcs.getIntUnchecked(aligned_bci);\n@@ -1428,3 +1427,3 @@\n-        if (bcs.rawCode == ClassFile.TABLESWITCH) {\n-            int low = bcs.getInt(aligned_bci + 4);\n-            int high = bcs.getInt(aligned_bci + 2*4);\n+        if (bcs.opcode() == ClassFile.TABLESWITCH) {\n+            int low = bcs.getIntUnchecked(aligned_bci + 4);\n+            int high = bcs.getIntUnchecked(aligned_bci + 2*4);\n@@ -1441,1 +1440,1 @@\n-            keys = bcs.getInt(aligned_bci + 4);\n+            keys = bcs.getIntUnchecked(aligned_bci + 4);\n@@ -1447,2 +1446,2 @@\n-                int this_key = bcs.getInt(aligned_bci + (2+2*i)*4);\n-                int next_key = bcs.getInt(aligned_bci + (2+2*i+2)*4);\n+                int this_key = bcs.getIntUnchecked(aligned_bci + (2+2*i)*4);\n+                int next_key = bcs.getIntUnchecked(aligned_bci + (2+2*i+2)*4);\n@@ -1454,1 +1453,1 @@\n-        int target = bci + default_ofset;\n+        int target = bci + default_offset;\n@@ -1457,2 +1456,2 @@\n-            aligned_bci = VerificationBytecodes.align(bcs.bci + 1);\n-            target = bci + bcs.getInt(aligned_bci + (3+i*delta)*4);\n+            aligned_bci = VerificationBytecodes.align(bcs.bci() + 1);\n+            target = bci + bcs.getIntUnchecked(aligned_bci + (3+i*delta)*4);\n@@ -1465,1 +1464,1 @@\n-        verify_cp_type(bcs.bci, index, cp, 1 << JVM_CONSTANT_Fieldref);\n+        verify_cp_type(bcs.bci(), index, cp, 1 << JVM_CONSTANT_Fieldref);\n@@ -1480,1 +1479,1 @@\n-        switch (bcs.rawCode) {\n+        switch (bcs.opcode()) {\n@@ -1527,1 +1526,1 @@\n-        int bci = bcs.bci;\n+        int bci = bcs.bci();\n@@ -1555,1 +1554,1 @@\n-            int new_class_index = bcs.getIndexU2Raw(new_offset + 1);\n+            int new_class_index = bcs.getU2(new_offset + 1);\n@@ -1586,1 +1585,1 @@\n-        int opcode = bcs.rawCode;\n+        int opcode = bcs.opcode();\n@@ -1604,1 +1603,1 @@\n-        verify_cp_type(bcs.bci, index, cp, types);\n+        verify_cp_type(bcs.bci(), index, cp, types);\n@@ -1622,1 +1621,1 @@\n-        int bci = bcs.bci;\n+        int bci = bcs.bci();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":33,"deletions":34,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Opcode;\n@@ -30,0 +32,5 @@\n+import java.lang.invoke.MethodHandles;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+\n+import jdk.internal.classfile.impl.RawBytecodeHelper;\n@@ -79,0 +86,17 @@\n+\n+    @Test\n+    void testOpcodeLengthTable() {\n+        var lengths = new byte[0x100];\n+        Arrays.fill(lengths, (byte) -1);\n+        for (var op : Opcode.values()) {\n+            if (!op.isWide()) {\n+                lengths[op.bytecode()] = (byte) op.sizeIfFixed();\n+            } else {\n+                \/\/ Wide pseudo-opcodes have double the length as normal variants\n+                \/\/ Must match logic in checkSpecialInstruction()\n+                assertEquals(op.sizeIfFixed(), lengths[op.bytecode() & 0xFF] * 2, op + \" size\");\n+            }\n+        }\n+\n+        assertArrayEquals(lengths, RawBytecodeHelper.LENGTHS);\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.classfile.Attributes;\n@@ -28,1 +29,0 @@\n-import java.nio.ByteBuffer;\n@@ -31,1 +31,0 @@\n-import java.util.Iterator;\n@@ -36,2 +35,0 @@\n-import java.lang.classfile.MethodModel;\n-import java.lang.classfile.constantpool.ConstantPool;\n@@ -41,1 +38,0 @@\n-import jdk.internal.classfile.impl.CodeImpl;\n@@ -44,0 +40,1 @@\n+import jdk.internal.classfile.impl.RawBytecodeHelper;\n@@ -73,1 +70,1 @@\n-                    ByteBuffer bytecode,\n+                    RawBytecodeHelper.CodeRange bytecode,\n@@ -88,2 +85,1 @@\n-                    m.code().ifPresent(com -> {\n-                        var bb = ByteBuffer.wrap(((CodeImpl)com).contents());\n+                    m.findAttribute(Attributes.code()).ifPresent(com -> {\n@@ -96,1 +92,1 @@\n-                                bb.slice(8, bb.getInt(4)),\n+                                RawBytecodeHelper.of(com.codeArray()),\n@@ -115,1 +111,1 @@\n-                d.bytecode().rewind(),\n+                d.bytecode(),\n@@ -130,1 +126,1 @@\n-                d.bytecode().rewind(),\n+                d.bytecode(),\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/CodeAttributeTools.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"}]}