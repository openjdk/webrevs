{"files":[{"patch":"@@ -385,5 +385,6 @@\n-\/\/ Because non-objArray objs can be imprecisely-marked (only obj-start card is\n-\/\/ dirty instead of the part containing old-to-young pointers), if the\n-\/\/ obj-start of a non-objArray is dirty, all cards that obj completely resides\n-\/\/ on are considered as dirty, since that obj will be iterated (scanned for\n-\/\/ old-to-young pointers) as a whole.\n+\/\/ Because non-objArray objs can be imprecisely marked (only the obj-start card\n+\/\/ is dirty instead of the part containing old-to-young pointers), if the\n+\/\/ obj-start of a non-objArray is dirty, all cards that the obj resides on,\n+\/\/ except the final one, are unconditionally considered as dirty. This is\n+\/\/ because that obj will be iterated (scanned for old-to-young pointers) as a\n+\/\/ whole.\n@@ -395,4 +396,0 @@\n-\n-  \/\/ end_card might be just beyond the heap, so need to use the _raw variant.\n-  HeapWord* end_address = ct->addr_for_raw(end_card);\n-\n@@ -421,11 +418,4 @@\n-    \/\/ This might be the last object in this area, avoid trying to access the\n-    \/\/ card beyond the allowed area.\n-    HeapWord* next_address = obj_start_addr + obj->size();\n-    if (next_address >= end_address) {\n-      break;\n-    }\n-\n-    \/\/ Card occupied by next obj.\n-    CardValue* next_obj_card = ct->byte_for(next_address);\n-    if (is_clean(next_obj_card)) {\n-      return next_obj_card;\n+    \/\/ Final card occupied by obj.\n+    CardValue* obj_final_card = ct->byte_for(obj_start_addr + obj->size() - 1);\n+    if (is_clean(obj_final_card)) {\n+      return obj_final_card;\n@@ -435,1 +425,1 @@\n-    current_card = next_obj_card + 1;\n+    current_card = obj_final_card + 1;\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -86,8 +86,0 @@\n-  \/\/ Mapping from card marking array entry to address of first word without checks.\n-  HeapWord* addr_for_raw(const CardValue* p) const {\n-    \/\/ As _byte_map_base may be \"negative\" (the card table has been allocated before\n-    \/\/ the heap in memory), do not use pointer_delta() to avoid the assertion failure.\n-    size_t delta = p - _byte_map_base;\n-    return (HeapWord*) (delta << _card_shift);\n-  }\n-\n@@ -155,1 +147,1 @@\n-  \/\/ Mapping from card marking array entry to address of first word.\n+  \/\/ Mapping from card marking array entry to address of first word\n@@ -161,1 +153,4 @@\n-    HeapWord* result = addr_for_raw(p);\n+    \/\/ As _byte_map_base may be \"negative\" (the card table has been allocated before\n+    \/\/ the heap in memory), do not use pointer_delta() to avoid the assertion failure.\n+    size_t delta = p - _byte_map_base;\n+    HeapWord* result = (HeapWord*) (delta << _card_shift);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"}]}