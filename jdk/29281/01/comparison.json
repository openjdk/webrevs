{"files":[{"patch":"@@ -571,0 +571,3 @@\n+    XSCMPEQDP_OPCODE=(60u << OPCODE_SHIFT |   3u <<  3),\n+    XSCMPGEDP_OPCODE=(60u << OPCODE_SHIFT |  19u <<  3),\n+    XSCMPGTDP_OPCODE=(60u << OPCODE_SHIFT |  11u <<  3),\n@@ -2427,0 +2430,3 @@\n+  inline void xscmpeqdp(VectorSRegister t, VectorSRegister a, VectorSRegister b); \/\/ Requires Power9\n+  inline void xscmpgedp(VectorSRegister t, VectorSRegister a, VectorSRegister b); \/\/ Requires Power9\n+  inline void xscmpgtdp(VectorSRegister t, VectorSRegister a, VectorSRegister b); \/\/ Requires Power9\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -926,0 +926,4 @@\n+inline void Assembler::xscmpeqdp(VectorSRegister t, VectorSRegister a, VectorSRegister b) { emit_int32( XSCMPEQDP_OPCODE | vsrt(t) | vsra(a) | vsrb(b) );}\n+inline void Assembler::xscmpgedp(VectorSRegister t, VectorSRegister a, VectorSRegister b) { emit_int32( XSCMPGEDP_OPCODE | vsrt(t) | vsra(a) | vsrb(b) );}\n+inline void Assembler::xscmpgtdp(VectorSRegister t, VectorSRegister a, VectorSRegister b) { emit_int32( XSCMPGTDP_OPCODE | vsrt(t) | vsra(a) | vsrb(b) );}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -667,0 +667,31 @@\n+\/\/ Works for single and double precision floats.\n+\/\/ dst = (op1 cmp(cc) op2) ? src1 : src2;\n+void C2_MacroAssembler::cmovF(int cc, VectorSRegister dst, VectorSRegister op1, VectorSRegister op2,\n+                              VectorSRegister src1, VectorSRegister src2, VectorSRegister tmp) {\n+  VectorSRegister first  = src1;\n+  VectorSRegister second = src2;\n+  int exchange = (~cc) & 8;\n+  if (exchange) {\n+    first  = src2;\n+    second = src1;\n+  }\n+\n+  auto cmp = (Assembler::Condition)(cc & 3);\n+  switch(cmp) {\n+  case Assembler::Condition::equal:\n+    xscmpeqdp(tmp, op1, op2);\n+    xxsel(dst, first, second, tmp);\n+    break;\n+  case Assembler::Condition::less:\n+    xscmpgedp(tmp, op1, op2);\n+    xxsel(dst, second, first, tmp);\n+    break;\n+  case Assembler::Condition::greater:\n+    xscmpgtdp(tmp, op1, op2);\n+    xxsel(dst, first, second, tmp);\n+    break;\n+  default:\n+    assert(false, \"unsupported compare condition: %d\", cc);\n+    ShouldNotReachHere();\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+  void cmovF(int cc, VectorSRegister dst, VectorSRegister op1, VectorSRegister op2,\n+             VectorSRegister src1, VectorSRegister src2, VectorSRegister tmp);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-  \/\/ Use conditional move (CMOVL) on Power7.\n@@ -70,3 +69,2 @@\n-  \/\/ Suppress CMOVF. Conditional move available (sort of) on PPC64 only from P7 onwards. Not exploited yet.\n-  \/\/ fsel doesn't accept a condition register as input, so this would be slightly different.\n-  static int float_cmove_cost() { return ConditionalMoveLimit; }\n+  \/\/ Suppress CMOVF for Power8 because there are no fast nodes.\n+  static int float_cmove_cost() { return (PowerArchitecturePPC64 >= 9) ? 0 : ConditionalMoveLimit; }\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3027,1 +3027,0 @@\n-    \/\/ use isel instruction with Power 7\n@@ -3102,1 +3101,0 @@\n-    \/\/ use isel instruction with Power 7\n@@ -6621,1 +6619,0 @@\n-\/\/ Power 7 can use isel instruction\n@@ -7296,1 +7293,0 @@\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n@@ -7316,1 +7312,0 @@\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n@@ -7329,0 +7324,60 @@\n+instruct cmovF_cmpF(cmpOp cop, regF dst, regF src1, regF src2, regF op1, regF op2, regD tmp) %{\n+  match(Set dst (CMoveF (Binary cop (CmpF op1 op2)) (Binary src1 src2)));\n+  predicate(PowerArchitecturePPC64 >= 9);\n+  effect(TEMP tmp);\n+  ins_cost(2*DEFAULT_COST);\n+  size(8);\n+  ins_encode %{\n+    __ cmovF($cop$$cmpcode, $dst$$FloatRegister->to_vsr(),\n+             $op1$$FloatRegister->to_vsr(), $op2$$FloatRegister->to_vsr(),\n+             $src1$$FloatRegister->to_vsr(), $src2$$FloatRegister->to_vsr(),\n+             $tmp$$FloatRegister->to_vsr());\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct cmovF_cmpD(cmpOp cop, regF dst, regF src1, regF src2, regD op1, regD op2, regD tmp) %{\n+  match(Set dst (CMoveF (Binary cop (CmpD op1 op2)) (Binary src1 src2)));\n+  predicate(PowerArchitecturePPC64 >= 9);\n+  effect(TEMP tmp);\n+  ins_cost(2*DEFAULT_COST);\n+  size(8);\n+  ins_encode %{\n+    __ cmovF($cop$$cmpcode, $dst$$FloatRegister->to_vsr(),\n+             $op1$$FloatRegister->to_vsr(), $op2$$FloatRegister->to_vsr(),\n+             $src1$$FloatRegister->to_vsr(), $src2$$FloatRegister->to_vsr(),\n+             $tmp$$FloatRegister->to_vsr());\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct cmovD_cmpD(cmpOp cop, regD dst, regD src1, regD src2, regD op1, regD op2, regD tmp) %{\n+  match(Set dst (CMoveD (Binary cop (CmpD op1 op2)) (Binary src1 src2)));\n+  predicate(PowerArchitecturePPC64 >= 9);\n+  effect(TEMP tmp);\n+  ins_cost(2*DEFAULT_COST);\n+  size(8);\n+  ins_encode %{\n+    __ cmovF($cop$$cmpcode, $dst$$FloatRegister->to_vsr(),\n+             $op1$$FloatRegister->to_vsr(), $op2$$FloatRegister->to_vsr(),\n+             $src1$$FloatRegister->to_vsr(), $src2$$FloatRegister->to_vsr(),\n+             $tmp$$FloatRegister->to_vsr());\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct cmovD_cmpF(cmpOp cop, regD dst, regD src1, regD src2, regF op1, regF op2, regD tmp) %{\n+  match(Set dst (CMoveD (Binary cop (CmpF op1 op2)) (Binary src1 src2)));\n+  predicate(PowerArchitecturePPC64 >= 9);\n+  effect(TEMP tmp);\n+  ins_cost(2*DEFAULT_COST);\n+  size(8);\n+  ins_encode %{\n+    __ cmovF($cop$$cmpcode, $dst$$FloatRegister->to_vsr(),\n+             $op1$$FloatRegister->to_vsr(), $op2$$FloatRegister->to_vsr(),\n+             $src1$$FloatRegister->to_vsr(), $src2$$FloatRegister->to_vsr(),\n+             $tmp$$FloatRegister->to_vsr());\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -8495,1 +8550,0 @@\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n@@ -8554,1 +8608,0 @@\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n@@ -10265,1 +10318,0 @@\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n@@ -10279,1 +10331,0 @@\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n@@ -10442,1 +10493,0 @@\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n@@ -10456,1 +10506,0 @@\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n@@ -11083,1 +11132,0 @@\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":60,"deletions":12,"binary":false,"changes":72,"status":"modified"}]}