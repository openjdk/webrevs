{"files":[{"patch":"@@ -600,4 +600,6 @@\n-  ContinuationEntry* ce = current->last_continuation();\n-  if (ce != nullptr && ce->is_virtual_thread()) {\n-    assert(result != freeze_ok, \"sanity check\");\n-    current->post_vthread_pinned_event(&vthread_pinned_event, \"Contended monitor enter\", result);\n+  if (current->current_waiting_monitor() == nullptr) {\n+    ContinuationEntry* ce = current->last_continuation();\n+    if (ce != nullptr && ce->is_virtual_thread()) {\n+      assert(result != freeze_ok, \"sanity check\");\n+      current->post_vthread_pinned_event(&vthread_pinned_event, \"Contended monitor enter\", result);\n+    }\n@@ -1822,5 +1824,0 @@\n-    if (ce != nullptr && ce->is_virtual_thread()) {\n-      assert(result != freeze_ok, \"sanity check\");\n-      current->post_vthread_pinned_event(&vthread_pinned_event, \"Object.wait\", result);\n-    }\n-\n@@ -1866,0 +1863,5 @@\n+  if (ce != nullptr && ce->is_virtual_thread()) {\n+    assert(result != freeze_ok, \"sanity check\");\n+    current->post_vthread_pinned_event(&vthread_pinned_event, \"Object.wait\", result);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,476 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test JFR jdk.VirtualThreadPinned event recorded for contended monitor enter\n+ *     and Object.wait when pinned\n+ * @requires vm.continuations\n+ * @modules jdk.jfr jdk.management\n+ * @library \/test\/lib\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED MonitorPinnedEvents\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+import jdk.test.lib.thread.VThreadPinner;\n+import jdk.test.lib.thread.VThreadRunner;   \/\/ ensureParallelism requires jdk.management\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class MonitorPinnedEvents {\n+    \/\/ log to System.err so inlined with JUnit output\n+    private static final PrintStream log = System.err;\n+\n+    \/\/ expected values for \"blockingOperation\" field in event\n+    private static final String CONTENDED_MONITOR_ENTER = \"Contended monitor enter\";\n+    private static final String OBJECT_WAIT = \"Object.wait\";\n+\n+    \/\/ expected value for \"pinnedReason\" field in event\n+    private static final String NATIVE_FRAME = \"Native or VM frame on stack\";\n+\n+    \/\/ block or wait for 2s to allow minimum event duration be tested\n+    private static final int DELAY = 2000;\n+\n+    @BeforeAll\n+    static void setup() {\n+        \/\/ need at least two carriers to test pinning\n+        VThreadRunner.ensureParallelism(2);\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for a contended monitor enter.\n+     *\/\n+    @Test\n+    void testContentedMonitorEnter() throws Exception {\n+        try (Recording recording = new Recording()) {\n+            recording.enable(\"jdk.VirtualThreadPinned\");\n+            recording.start();\n+\n+            Thread vthread;\n+            try {\n+                Object lock = new Object();\n+\n+                synchronized (lock) {\n+                    \/\/ start virtual thread that blocks trying to acquire monitor while pinned\n+                    var ready = new AtomicBoolean();\n+                    vthread = Thread.ofVirtual().start(() -> {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            synchronized (lock) {   \/\/ <--- blocks here while pinned\n+                            }\n+                        });\n+                    });\n+                    await(ready, vthread, Thread.State.BLOCKED);\n+\n+                    \/\/ sleep before releasing to ensure virtual thread is blocked for >= 2s\n+                    Thread.sleep(DELAY);\n+                }\n+                vthread.join();\n+            } finally {\n+                recording.stop();\n+            }\n+\n+            \/\/ jdk.VirtualThreadPinned event should be recorded\n+            RecordedEvent event = findPinnedEvent(recording);\n+            testEvent(event, vthread, CONTENDED_MONITOR_ENTER, NATIVE_FRAME, DELAY);\n+        }\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for a contended monitor enter where\n+     * another thread may acquire the monitor when the main thread releases it. If\n+     * the other thread acquires the monitor before the virtual thread then the event\n+     * duration should include the time blocked until the other thread releases it.\n+     *\/\n+    @Test\n+    void testContentedMonitorEnter2() throws Exception {\n+        try (Recording recording = new Recording()) {\n+            recording.enable(\"jdk.VirtualThreadPinned\");\n+            recording.start();\n+\n+            \/\/ the thread that acquires the monitor after the main thread releases it\n+            var nextOwner = new AtomicReference<Thread>();\n+\n+            Thread vthread;\n+            try {\n+                Object lock = new Object();\n+                Thread thread2;\n+                synchronized (lock) {\n+\n+                    \/\/ start virtual thread that blocks trying to acquire monitor while pinned\n+                    var ready1 = new AtomicBoolean();\n+                    vthread = Thread.ofVirtual().start(() -> {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready1.set(true);\n+                            synchronized (lock) {   \/\/ <--- blocks here while pinned\n+                                nextOwner.compareAndSet(null, Thread.currentThread());\n+                            }\n+                        });\n+                    });\n+                    await(ready1, vthread, Thread.State.BLOCKED);\n+\n+                    \/\/ start platform thread that blocks trying to acquire monitor\n+                    thread2 = Thread.ofPlatform().start(() -> {\n+                        synchronized (lock) {\n+                            if (nextOwner.compareAndSet(null, Thread.currentThread())) {\n+                                \/\/ delayed release of monitor if acquired before virtual thread\n+                                try {\n+                                    Thread.sleep(DELAY);\n+                                } catch (InterruptedException e) {\n+                                }\n+                            }\n+                        }\n+                    });\n+\n+                }  \/\/ release lock, vthread or thread2 will acquire\n+\n+                vthread.join();\n+                thread2.join();\n+            } finally {\n+                recording.stop();\n+            }\n+\n+            \/\/ jdk.VirtualThreadPinned event should be recorded. If the platform thread\n+            \/\/ acquired the monitor before the virtual thread then the event duration\n+            \/\/ should be >= DELAY.\n+            RecordedEvent event = findPinnedEvent(recording);\n+            Thread winner = nextOwner.get();\n+            assertNotNull(winner);\n+            int minDuration = winner.isVirtual() ? 0 : DELAY;\n+            testEvent(event, vthread, CONTENDED_MONITOR_ENTER, NATIVE_FRAME, minDuration);\n+        }\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for Object.wait when notified.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testObjectWaitNotify(boolean timed) throws Exception {\n+        testObjectWait(timed, false);\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for Object.wait when interrupted.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testObjectWaitInterrupt(boolean timed) throws Exception {\n+        testObjectWait(timed, true);\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for Object.wait.\n+     * @param timed true for a timed-wait, false for an untimed-wait\n+     * @param interrupt true to interrupt the thread, false to notify\n+     *\/\n+    private void testObjectWait(boolean timed, boolean interrupt) throws Exception {\n+        try (Recording recording = new Recording()) {\n+            recording.enable(\"jdk.VirtualThreadPinned\");\n+            recording.start();\n+\n+            Thread vthread;\n+            try {\n+                Object lock = new Object();\n+\n+                \/\/ start virtual thread that waits in Object.wait while pinned\n+                var ready = new AtomicBoolean();\n+                vthread = Thread.ofVirtual().start(() -> {\n+                    VThreadPinner.runPinned(() -> {\n+                        synchronized (lock) {\n+                            ready.set(true);\n+                            try {\n+                                \/\/ wait while pinned\n+                                if (timed) {\n+                                    lock.wait(Long.MAX_VALUE);\n+                                } else {\n+                                    lock.wait();\n+                                }\n+                            } catch (InterruptedException e) {\n+                            }\n+                        }\n+                    });\n+                });\n+                await(ready, vthread, timed ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n+\n+                \/\/ sleep to ensure virtual thread waits for >= 2s\n+                Thread.sleep(DELAY);\n+\n+                \/\/ interrupt or notify thread so it resumes execution\n+                if (interrupt) {\n+                    vthread.interrupt();\n+                } else {\n+                    synchronized (lock) {\n+                        lock.notify();\n+                    }\n+                }\n+                vthread.join();\n+            } finally {\n+                recording.stop();\n+            }\n+\n+            \/\/ jdk.VirtualThreadPinned event should be recorded\n+            RecordedEvent event = findPinnedEvent(recording);\n+            testEvent(event, vthread, OBJECT_WAIT, NATIVE_FRAME, DELAY);\n+        }\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for Object.wait where the virtual thread\n+     * is notified but may block when attempting to reenter. One event should be\n+     * recorded. The event duration should include both the waiting time and the time\n+     * blocked to reenter.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testObjectWaitNotify2(boolean timed) throws Exception {\n+        testObjectWait2(timed, false);\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for Object.wait where the virtual thread\n+     * is interrupted but may block when attempting to reenter. One event should be\n+     * recorded. The event duration should include both the waiting time and the time\n+     * blocked to reenter.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testObjectWaitInterrupt2(boolean timed) throws Exception {\n+        testObjectWait2(timed, true);\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for Object.wait where the virtual thread\n+     * blocks when attempting to reenter.\n+     * @param timed true for a timed-wait, false for an untimed-wait\n+     * @param interrupt true to interrupt the thread, false to notify\n+     *\/\n+    private void testObjectWait2(boolean timed, boolean interrupt) throws Exception {\n+        try (Recording recording = new Recording()) {\n+            recording.enable(\"jdk.VirtualThreadPinned\");\n+            recording.start();\n+\n+            \/\/ the thread that acquires the monitor after the main thread releases it\n+            var nextOwner = new AtomicReference<Thread>();\n+\n+            Thread vthread;\n+            try {\n+                Object lock = new Object();\n+\n+                \/\/ start virtual thread that waits in Object.wait while pinned\n+                var ready1 = new AtomicBoolean();\n+                vthread = Thread.ofVirtual().start(() -> {\n+                    VThreadPinner.runPinned(() -> {\n+                        boolean notify = !interrupt;\n+                        synchronized (lock) {\n+                            ready1.set(true);\n+                            try {\n+                                \/\/ wait while pinned\n+                                if (timed) {\n+                                    lock.wait(Long.MAX_VALUE);\n+                                } else {\n+                                    lock.wait();\n+                                }\n+                                if (notify) {\n+                                    nextOwner.compareAndSet(null, Thread.currentThread());\n+                                }\n+                            } catch (InterruptedException e) {\n+                                if (interrupt) {\n+                                    nextOwner.compareAndSet(null, Thread.currentThread());\n+                                }\n+                            }\n+                        }\n+                    });\n+                });\n+                await(ready1, vthread, timed ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n+\n+                \/\/ platform thread that blocks on monitor enter\n+                Thread thread2;\n+                synchronized (lock) {\n+                    thread2 = Thread.ofPlatform().start(() -> {\n+                        synchronized (lock) {   \/\/ <--- blocks here\n+                            if (nextOwner.compareAndSet(null, Thread.currentThread())) {\n+                                \/\/ delayed release of monitor if acquired before virtual thread\n+                                try {\n+                                    Thread.sleep(DELAY);\n+                                } catch (InterruptedException e) {\n+                                }\n+                            }\n+                        }\n+                    });\n+\n+                    \/\/ interrupt\/notify and release monitor to allow one of the threads to acquire\n+                    if (interrupt) {\n+                        vthread.interrupt();\n+                    } else {\n+                        lock.notify();\n+                    }\n+                }\n+\n+                vthread.join();\n+                thread2.join();\n+\n+            } finally {\n+                recording.stop();\n+            }\n+\n+            \/\/ jdk.VirtualThreadPinned event should be recorded. If the platform thread\n+            \/\/ acquired the monitor before the virtual thread re-entered then the event\n+            \/\/ duration should be >= DELAY.\n+            RecordedEvent event = findPinnedEvent(recording);\n+            Thread winner = nextOwner.get();\n+            assertNotNull(winner);\n+            int minDuration = winner.isVirtual() ? 0 : DELAY;\n+            testEvent(event, vthread, OBJECT_WAIT, NATIVE_FRAME, minDuration);\n+        }\n+    }\n+\n+    \/**\n+     * Test that the event was recorded by the expected virtual thread, the event has a\n+     * \"carrierThread\", the \"blockingOperation\", and \"pinnedReason\" fields have the\n+     * expected values, and the event duration is >= minDuration.\n+     *\/\n+    private void testEvent(RecordedEvent event,\n+                           Thread vthread,\n+                           String expectedBlockingOp,\n+                           String expectedPinnedReason,\n+                           int minDuration) {\n+        assertTrue(vthread.isVirtual());\n+        assertEquals(vthread.threadId(), event.getThread().getId());\n+\n+        RecordedThread carrier = event.getValue(\"carrierThread\");\n+        assertFalse(carrier.isVirtual());\n+\n+        assertEquals(expectedBlockingOp, event.getString(\"blockingOperation\"));\n+        assertEquals(expectedPinnedReason, event.getString(\"pinnedReason\"));\n+\n+        long duration = event.getDuration().toMillis();\n+        assertTrue(duration >= (minDuration - 100),\n+                \"Duration \" + duration + \"ms, expected >= \" + minDuration + \"ms\");\n+    }\n+\n+    \/**\n+     * Find the expected jdk.VirtualThreadPinned event in the recording. There may be\n+     * several pinned events recorded by other parts of the system that need to be\n+     * filtered out.\n+     *\/\n+    private RecordedEvent findPinnedEvent(Recording recording) throws IOException {\n+        Map<Boolean, List<RecordedEvent>> events = find(recording, \"jdk.VirtualThreadPinned\")\n+                .collect(Collectors.partitioningBy(e -> filtered(topFrameMethod(e)), Collectors.toList()));\n+        List<RecordedEvent> filteredEvents = events.get(Boolean.TRUE);\n+        List<RecordedEvent> pinnedEvents = events.get(Boolean.FALSE);\n+        log.format(\"%d event(s) recorded%n\", filteredEvents.size() + pinnedEvents.size());\n+        log.println(\"-- filtered events --\");\n+        log.println(filteredEvents);\n+        log.println(\"-- remaining pinned events --\");\n+        log.println(pinnedEvents);\n+        assertEquals(1, pinnedEvents.size());\n+        return pinnedEvents.get(0);\n+    }\n+\n+    \/**\n+     * Pinned events recorded at the following classes\/methods should be ignored.\n+     *\/\n+    private final Set<String> FILTERED = Set.of(\n+            \"java.lang.VirtualThread.*\",\n+            \"java.lang.ref.ReferenceQueue.poll\",\n+            \"java.lang.invoke.*\",\n+            \"jdk.internal.ref.*\"\n+    );\n+\n+    \/**\n+     * Returns true if the given top-frame {@code class.method} should be ignored.\n+     *\/\n+    private boolean filtered(String topFrameMethod) {\n+        for (String s : FILTERED) {\n+            if (s.endsWith(\"*\")) {\n+                String prefix = s.substring(0, s.length()-1);\n+                if (topFrameMethod.startsWith(prefix)) {\n+                    return true;\n+                }\n+            } else if (s.equals(topFrameMethod)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns the {@code class.method} of the top frame in the event's stack trace.\n+     *\/\n+    private String topFrameMethod(RecordedEvent event) {\n+        RecordedFrame topFrame = event.getStackTrace().getFrames().get(0);\n+        RecordedMethod method = topFrame.getMethod();\n+        return method.getType().getName() + \".\" + method.getName();\n+    }\n+\n+    \/**\n+     * Returns the events with the given name in the recording.\n+     *\/\n+    private Stream<RecordedEvent> find(Recording recording, String name) throws IOException {\n+        Path recordingFile = recording.getDestination();\n+        if (recordingFile == null) {\n+            ProcessHandle h = ProcessHandle.current();\n+            recordingFile = Path.of(\"recording-\" + recording.getId() + \"-pid\" + h.pid() + \".jfr\");\n+            recording.dump(recordingFile);\n+        }\n+        return RecordingFile.readAllEvents(recordingFile)\n+                .stream()\n+                .filter(e -> e.getEventType().getName().equals(name));\n+    }\n+\n+    \/**\n+     * Waits for ready to become true, then waits for the thread to get to the given state.\n+     *\/\n+    private void await(AtomicBoolean ready,\n+                       Thread thread,\n+                       Thread.State expectedState) throws InterruptedException {\n+        while (!ready.get()) {\n+            Thread.sleep(10);\n+        }\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorPinnedEvents.java","additions":476,"deletions":0,"binary":false,"changes":476,"status":"added"}]}