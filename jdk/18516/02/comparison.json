{"files":[{"patch":"@@ -90,0 +90,27 @@\n+\/\/ A helper class for caching a Method* when the user of the cache\n+\/\/ only cares about the latest version of the Method*.  This cache safely\n+\/\/ interacts with the RedefineClasses API.\n+class LatestMethodCache {\n+  \/\/ We save the Klass* and the idnum of Method* in order to get\n+  \/\/ the current cached Method*.\n+ private:\n+  Klass*                _klass;\n+  int                   _method_idnum;\n+\n+ public:\n+  LatestMethodCache()   { _klass = nullptr; _method_idnum = -1; }\n+\n+  void   init(JavaThread* current, InstanceKlass* ik, const char* method,\n+              Symbol* signature, bool is_static);\n+  Klass* klass() const           { return _klass; }\n+  int    method_idnum() const    { return _method_idnum; }\n+\n+  Method* get_method();\n+};\n+\n+static LatestMethodCache _finalizer_register_cache; \/\/ static method for registering finalizable objects\n+static LatestMethodCache _loader_addClass_cache;    \/\/ method for registering loaded classes in class loader vector\n+static LatestMethodCache _throw_illegal_access_error_cache; \/\/ Unsafe.throwIllegalAccessError() method\n+static LatestMethodCache _throw_no_such_method_error_cache; \/\/ Unsafe.throwNoSuchMethodError() method\n+static LatestMethodCache _do_stack_walk_cache;      \/\/ method for stack walker callback\n+\n@@ -136,5 +163,0 @@\n-LatestMethodCache* Universe::_finalizer_register_cache = nullptr;\n-LatestMethodCache* Universe::_loader_addClass_cache    = nullptr;\n-LatestMethodCache* Universe::_throw_illegal_access_error_cache = nullptr;\n-LatestMethodCache* Universe::_throw_no_such_method_error_cache = nullptr;\n-LatestMethodCache* Universe::_do_stack_walk_cache     = nullptr;\n@@ -217,4 +239,0 @@\n-void LatestMethodCache::metaspace_pointers_do(MetaspaceClosure* it) {\n-  it->push(&_klass);\n-}\n-\n@@ -234,6 +252,0 @@\n-\n-  _finalizer_register_cache->metaspace_pointers_do(it);\n-  _loader_addClass_cache->metaspace_pointers_do(it);\n-  _throw_illegal_access_error_cache->metaspace_pointers_do(it);\n-  _throw_no_such_method_error_cache->metaspace_pointers_do(it);\n-  _do_stack_walk_cache->metaspace_pointers_do(it);\n@@ -286,5 +298,0 @@\n-  _finalizer_register_cache->serialize(f);\n-  _loader_addClass_cache->serialize(f);\n-  _throw_illegal_access_error_cache->serialize(f);\n-  _throw_no_such_method_error_cache->serialize(f);\n-  _do_stack_walk_cache->serialize(f);\n@@ -813,8 +820,0 @@\n-  \/\/ We have a heap so create the Method* caches before\n-  \/\/ Metaspace::initialize_shared_spaces() tries to populate them.\n-  Universe::_finalizer_register_cache = new LatestMethodCache();\n-  Universe::_loader_addClass_cache    = new LatestMethodCache();\n-  Universe::_throw_illegal_access_error_cache = new LatestMethodCache();\n-  Universe::_throw_no_such_method_error_cache = new LatestMethodCache();\n-  Universe::_do_stack_walk_cache = new LatestMethodCache();\n-\n@@ -927,5 +926,2 @@\n-static void initialize_known_method(LatestMethodCache* method_cache,\n-                                    InstanceKlass* ik,\n-                                    const char* method,\n-                                    Symbol* signature,\n-                                    bool is_static, TRAPS)\n+void LatestMethodCache::init(JavaThread* current, InstanceKlass* ik,\n+                             const char* method, Symbol* signature, bool is_static)\n@@ -936,1 +932,1 @@\n-  if (!ik->link_class_or_fail(THREAD) ||\n+  if (!ik->link_class_or_fail(current) ||\n@@ -939,1 +935,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -945,1 +941,12 @@\n-  method_cache->init(ik, m);\n+\n+  _klass = ik;\n+  _method_idnum = m->method_idnum();\n+  assert(_method_idnum >= 0, \"sanity check\");\n+}\n+\n+Method* LatestMethodCache::get_method() {\n+  if (klass() == nullptr) return nullptr;\n+  InstanceKlass* ik = InstanceKlass::cast(klass());\n+  Method* m = ik->method_with_idnum(method_idnum());\n+  assert(m != nullptr, \"sanity check\");\n+  return m;\n@@ -948,1 +955,7 @@\n-void Universe::initialize_known_methods(TRAPS) {\n+Method* Universe::finalizer_register_method()     { return _finalizer_register_cache.get_method(); }\n+Method* Universe::loader_addClass_method()        { return _loader_addClass_cache.get_method(); }\n+Method* Universe::throw_illegal_access_error()    { return _throw_illegal_access_error_cache.get_method(); }\n+Method* Universe::throw_no_such_method_error()    { return _throw_no_such_method_error_cache.get_method(); }\n+Method* Universe::do_stack_walk_method()          { return _do_stack_walk_cache.get_method(); }\n+\n+void Universe::initialize_known_methods(JavaThread* current) {\n@@ -950,1 +963,1 @@\n-  initialize_known_method(_finalizer_register_cache,\n+  _finalizer_register_cache.init(current,\n@@ -953,1 +966,1 @@\n-                          vmSymbols::object_void_signature(), true, CHECK);\n+                          vmSymbols::object_void_signature(), true);\n@@ -955,1 +968,1 @@\n-  initialize_known_method(_throw_illegal_access_error_cache,\n+  _throw_illegal_access_error_cache.init(current,\n@@ -958,1 +971,1 @@\n-                          vmSymbols::void_method_signature(), true, CHECK);\n+                          vmSymbols::void_method_signature(), true);\n@@ -960,1 +973,1 @@\n-  initialize_known_method(_throw_no_such_method_error_cache,\n+  _throw_no_such_method_error_cache.init(current,\n@@ -963,1 +976,1 @@\n-                          vmSymbols::void_method_signature(), true, CHECK);\n+                          vmSymbols::void_method_signature(), true);\n@@ -966,1 +979,1 @@\n-  initialize_known_method(_loader_addClass_cache,\n+  _loader_addClass_cache.init(current,\n@@ -969,1 +982,1 @@\n-                          vmSymbols::class_void_signature(), false, CHECK);\n+                          vmSymbols::class_void_signature(), false);\n@@ -972,1 +985,1 @@\n-  initialize_known_method(_do_stack_walk_cache,\n+  _do_stack_walk_cache.init(current,\n@@ -975,1 +988,1 @@\n-                          vmSymbols::doStackWalk_signature(), false, CHECK);\n+                          vmSymbols::doStackWalk_signature(), false);\n@@ -1043,1 +1056,1 @@\n-  Universe::initialize_known_methods(CHECK_false);\n+  Universe::initialize_known_methods(THREAD);\n@@ -1258,29 +1271,0 @@\n-\n-void LatestMethodCache::init(Klass* k, Method* m) {\n-  if (!UseSharedSpaces) {\n-    _klass = k;\n-  }\n-#ifndef PRODUCT\n-  else {\n-    \/\/ sharing initialization should have already set up _klass\n-    assert(_klass != nullptr, \"just checking\");\n-  }\n-#endif\n-\n-  _method_idnum = m->method_idnum();\n-  assert(_method_idnum >= 0, \"sanity check\");\n-}\n-\n-\n-Method* LatestMethodCache::get_method() {\n-  if (klass() == nullptr) return nullptr;\n-  InstanceKlass* ik = InstanceKlass::cast(klass());\n-  Method* m = ik->method_with_idnum(method_idnum());\n-  assert(m != nullptr, \"sanity check\");\n-  return m;\n-}\n-\n-void LatestMethodCache::serialize(SerializeClosure* f) {\n-  f->do_ptr(&_klass);\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":61,"deletions":77,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,27 +48,0 @@\n-\/\/ A helper class for caching a Method* when the user of the cache\n-\/\/ only cares about the latest version of the Method*.  This cache safely\n-\/\/ interacts with the RedefineClasses API.\n-\n-class LatestMethodCache : public CHeapObj<mtClass> {\n-  \/\/ We save the Klass* and the idnum of Method* in order to get\n-  \/\/ the current cached Method*.\n- private:\n-  Klass*                _klass;\n-  int                   _method_idnum;\n-\n- public:\n-  LatestMethodCache()   { _klass = nullptr; _method_idnum = -1; }\n-  ~LatestMethodCache()  { _klass = nullptr; _method_idnum = -1; }\n-\n-  void   init(Klass* k, Method* m);\n-  Klass* klass() const           { return _klass; }\n-  int    method_idnum() const    { return _method_idnum; }\n-\n-  Method* get_method();\n-\n-  \/\/ CDS support.  Replace the klass in this with the archive version\n-  \/\/ could use this for Enhanced Class Redefinition also.\n-  void serialize(SerializeClosure* f);\n-  void metaspace_pointers_do(MetaspaceClosure* it);\n-};\n-\n@@ -118,6 +91,0 @@\n-  static LatestMethodCache* _finalizer_register_cache; \/\/ static method for registering finalizable objects\n-  static LatestMethodCache* _loader_addClass_cache;    \/\/ method for registering loaded classes in class loader vector\n-  static LatestMethodCache* _throw_illegal_access_error_cache; \/\/ Unsafe.throwIllegalAccessError() method\n-  static LatestMethodCache* _throw_no_such_method_error_cache; \/\/ Unsafe.throwNoSuchMethodError() method\n-  static LatestMethodCache* _do_stack_walk_cache;      \/\/ method for stack walker callback\n-\n@@ -269,5 +236,0 @@\n-  static Method*      finalizer_register_method()     { return _finalizer_register_cache->get_method(); }\n-  static Method*      loader_addClass_method()        { return _loader_addClass_cache->get_method(); }\n-\n-  static Method*      throw_illegal_access_error()    { return _throw_illegal_access_error_cache->get_method(); }\n-  static Method*      throw_no_such_method_error()    { return _throw_no_such_method_error_cache->get_method(); }\n@@ -275,1 +237,5 @@\n-  static Method*      do_stack_walk_method()          { return _do_stack_walk_cache->get_method(); }\n+  static Method*      finalizer_register_method();\n+  static Method*      loader_addClass_method();\n+  static Method*      throw_illegal_access_error();\n+  static Method*      throw_no_such_method_error();\n+  static Method*      do_stack_walk_method();\n@@ -281,1 +247,1 @@\n-  static void initialize_known_methods(TRAPS);\n+  static void initialize_known_methods(JavaThread* current);\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":7,"deletions":41,"binary":false,"changes":48,"status":"modified"}]}