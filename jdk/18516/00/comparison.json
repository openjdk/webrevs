{"files":[{"patch":"@@ -90,0 +90,21 @@\n+\/\/ A helper class for caching a Method* when the user of the cache\n+\/\/ only cares about the latest version of the Method*.  This cache safely\n+\/\/ interacts with the RedefineClasses API.\n+class LatestMethodCache {\n+  \/\/ We save the Klass* and the idnum of Method* in order to get\n+  \/\/ the current cached Method*.\n+ private:\n+  Klass*                _klass;\n+  int                   _method_idnum;\n+\n+ public:\n+  LatestMethodCache()   { _klass = nullptr; _method_idnum = -1; }\n+\n+  void   init(JavaThread* current, InstanceKlass* ik, const char* method,\n+              Symbol* signature, bool is_static);\n+  Klass* klass() const           { return _klass; }\n+  int    method_idnum() const    { return _method_idnum; }\n+\n+  Method* get_method();\n+};\n+\n@@ -136,5 +157,5 @@\n-LatestMethodCache* Universe::_finalizer_register_cache = nullptr;\n-LatestMethodCache* Universe::_loader_addClass_cache    = nullptr;\n-LatestMethodCache* Universe::_throw_illegal_access_error_cache = nullptr;\n-LatestMethodCache* Universe::_throw_no_such_method_error_cache = nullptr;\n-LatestMethodCache* Universe::_do_stack_walk_cache     = nullptr;\n+LatestMethodCache Universe::_finalizer_register_cache;\n+LatestMethodCache Universe::_loader_addClass_cache;\n+LatestMethodCache Universe::_throw_illegal_access_error_cache;\n+LatestMethodCache Universe::_throw_no_such_method_error_cache;\n+LatestMethodCache Universe::_do_stack_walk_cache;\n@@ -217,4 +238,0 @@\n-void LatestMethodCache::metaspace_pointers_do(MetaspaceClosure* it) {\n-  it->push(&_klass);\n-}\n-\n@@ -234,6 +251,0 @@\n-\n-  _finalizer_register_cache->metaspace_pointers_do(it);\n-  _loader_addClass_cache->metaspace_pointers_do(it);\n-  _throw_illegal_access_error_cache->metaspace_pointers_do(it);\n-  _throw_no_such_method_error_cache->metaspace_pointers_do(it);\n-  _do_stack_walk_cache->metaspace_pointers_do(it);\n@@ -286,5 +297,0 @@\n-  _finalizer_register_cache->serialize(f);\n-  _loader_addClass_cache->serialize(f);\n-  _throw_illegal_access_error_cache->serialize(f);\n-  _throw_no_such_method_error_cache->serialize(f);\n-  _do_stack_walk_cache->serialize(f);\n@@ -813,8 +819,0 @@\n-  \/\/ We have a heap so create the Method* caches before\n-  \/\/ Metaspace::initialize_shared_spaces() tries to populate them.\n-  Universe::_finalizer_register_cache = new LatestMethodCache();\n-  Universe::_loader_addClass_cache    = new LatestMethodCache();\n-  Universe::_throw_illegal_access_error_cache = new LatestMethodCache();\n-  Universe::_throw_no_such_method_error_cache = new LatestMethodCache();\n-  Universe::_do_stack_walk_cache = new LatestMethodCache();\n-\n@@ -927,20 +925,5 @@\n-static void initialize_known_method(LatestMethodCache* method_cache,\n-                                    InstanceKlass* ik,\n-                                    const char* method,\n-                                    Symbol* signature,\n-                                    bool is_static, TRAPS)\n-{\n-  TempNewSymbol name = SymbolTable::new_symbol(method);\n-  Method* m = nullptr;\n-  \/\/ The klass must be linked before looking up the method.\n-  if (!ik->link_class_or_fail(THREAD) ||\n-      ((m = ik->find_method(name, signature)) == nullptr) ||\n-      is_static != m->is_static()) {\n-    ResourceMark rm(THREAD);\n-    \/\/ NoSuchMethodException doesn't actually work because it tries to run the\n-    \/\/ <init> function before java_lang_Class is linked. Print error and exit.\n-    vm_exit_during_initialization(err_msg(\"Unable to link\/verify %s.%s method\",\n-                                 ik->name()->as_C_string(), method));\n-  }\n-  method_cache->init(ik, m);\n-}\n+Method* Universe::finalizer_register_method()     { return _finalizer_register_cache.get_method(); }\n+Method* Universe::loader_addClass_method()        { return _loader_addClass_cache.get_method(); }\n+Method* Universe::throw_illegal_access_error()    { return _throw_illegal_access_error_cache.get_method(); }\n+Method* Universe::throw_no_such_method_error()    { return _throw_no_such_method_error_cache.get_method(); }\n+Method* Universe::do_stack_walk_method()          { return _do_stack_walk_cache.get_method(); }\n@@ -948,1 +931,1 @@\n-void Universe::initialize_known_methods(TRAPS) {\n+void Universe::initialize_known_methods(JavaThread* current) {\n@@ -950,1 +933,1 @@\n-  initialize_known_method(_finalizer_register_cache,\n+  _finalizer_register_cache.init(current,\n@@ -953,1 +936,1 @@\n-                          vmSymbols::object_void_signature(), true, CHECK);\n+                          vmSymbols::object_void_signature(), true);\n@@ -955,1 +938,1 @@\n-  initialize_known_method(_throw_illegal_access_error_cache,\n+  _throw_illegal_access_error_cache.init(current,\n@@ -958,1 +941,1 @@\n-                          vmSymbols::void_method_signature(), true, CHECK);\n+                          vmSymbols::void_method_signature(), true);\n@@ -960,1 +943,1 @@\n-  initialize_known_method(_throw_no_such_method_error_cache,\n+  _throw_no_such_method_error_cache.init(current,\n@@ -963,1 +946,1 @@\n-                          vmSymbols::void_method_signature(), true, CHECK);\n+                          vmSymbols::void_method_signature(), true);\n@@ -966,1 +949,1 @@\n-  initialize_known_method(_loader_addClass_cache,\n+  _loader_addClass_cache.init(current,\n@@ -969,1 +952,1 @@\n-                          vmSymbols::class_void_signature(), false, CHECK);\n+                          vmSymbols::class_void_signature(), false);\n@@ -972,1 +955,1 @@\n-  initialize_known_method(_do_stack_walk_cache,\n+  _do_stack_walk_cache.init(current,\n@@ -975,1 +958,1 @@\n-                          vmSymbols::doStackWalk_signature(), false, CHECK);\n+                          vmSymbols::doStackWalk_signature(), false);\n@@ -1043,1 +1026,1 @@\n-  Universe::initialize_known_methods(CHECK_false);\n+  Universe::initialize_known_methods(THREAD);\n@@ -1258,9 +1241,14 @@\n-\n-void LatestMethodCache::init(Klass* k, Method* m) {\n-  if (!UseSharedSpaces) {\n-    _klass = k;\n-  }\n-#ifndef PRODUCT\n-  else {\n-    \/\/ sharing initialization should have already set up _klass\n-    assert(_klass != nullptr, \"just checking\");\n+void LatestMethodCache::init(JavaThread* current, InstanceKlass* ik,\n+                             const char* method, Symbol* signature, bool is_static)\n+{\n+  TempNewSymbol name = SymbolTable::new_symbol(method);\n+  Method* m = nullptr;\n+  \/\/ The klass must be linked before looking up the method.\n+  if (!ik->link_class_or_fail(current) ||\n+      ((m = ik->find_method(name, signature)) == nullptr) ||\n+      is_static != m->is_static()) {\n+    ResourceMark rm(current);\n+    \/\/ NoSuchMethodException doesn't actually work because it tries to run the\n+    \/\/ <init> function before java_lang_Class is linked. Print error and exit.\n+    vm_exit_during_initialization(err_msg(\"Unable to link\/verify %s.%s method\",\n+                                 ik->name()->as_C_string(), method));\n@@ -1268,1 +1256,0 @@\n-#endif\n@@ -1270,0 +1257,1 @@\n+  _klass = ik;\n@@ -1274,1 +1262,0 @@\n-\n@@ -1283,4 +1270,0 @@\n-void LatestMethodCache::serialize(SerializeClosure* f) {\n-  f->do_ptr(&_klass);\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":58,"deletions":75,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+class LatestMethodCache;\n@@ -48,27 +49,0 @@\n-\/\/ A helper class for caching a Method* when the user of the cache\n-\/\/ only cares about the latest version of the Method*.  This cache safely\n-\/\/ interacts with the RedefineClasses API.\n-\n-class LatestMethodCache : public CHeapObj<mtClass> {\n-  \/\/ We save the Klass* and the idnum of Method* in order to get\n-  \/\/ the current cached Method*.\n- private:\n-  Klass*                _klass;\n-  int                   _method_idnum;\n-\n- public:\n-  LatestMethodCache()   { _klass = nullptr; _method_idnum = -1; }\n-  ~LatestMethodCache()  { _klass = nullptr; _method_idnum = -1; }\n-\n-  void   init(Klass* k, Method* m);\n-  Klass* klass() const           { return _klass; }\n-  int    method_idnum() const    { return _method_idnum; }\n-\n-  Method* get_method();\n-\n-  \/\/ CDS support.  Replace the klass in this with the archive version\n-  \/\/ could use this for Enhanced Class Redefinition also.\n-  void serialize(SerializeClosure* f);\n-  void metaspace_pointers_do(MetaspaceClosure* it);\n-};\n-\n@@ -118,5 +92,5 @@\n-  static LatestMethodCache* _finalizer_register_cache; \/\/ static method for registering finalizable objects\n-  static LatestMethodCache* _loader_addClass_cache;    \/\/ method for registering loaded classes in class loader vector\n-  static LatestMethodCache* _throw_illegal_access_error_cache; \/\/ Unsafe.throwIllegalAccessError() method\n-  static LatestMethodCache* _throw_no_such_method_error_cache; \/\/ Unsafe.throwNoSuchMethodError() method\n-  static LatestMethodCache* _do_stack_walk_cache;      \/\/ method for stack walker callback\n+  static LatestMethodCache _finalizer_register_cache; \/\/ static method for registering finalizable objects\n+  static LatestMethodCache _loader_addClass_cache;    \/\/ method for registering loaded classes in class loader vector\n+  static LatestMethodCache _throw_illegal_access_error_cache; \/\/ Unsafe.throwIllegalAccessError() method\n+  static LatestMethodCache _throw_no_such_method_error_cache; \/\/ Unsafe.throwNoSuchMethodError() method\n+  static LatestMethodCache _do_stack_walk_cache;      \/\/ method for stack walker callback\n@@ -269,5 +243,0 @@\n-  static Method*      finalizer_register_method()     { return _finalizer_register_cache->get_method(); }\n-  static Method*      loader_addClass_method()        { return _loader_addClass_cache->get_method(); }\n-\n-  static Method*      throw_illegal_access_error()    { return _throw_illegal_access_error_cache->get_method(); }\n-  static Method*      throw_no_such_method_error()    { return _throw_no_such_method_error_cache->get_method(); }\n@@ -275,1 +244,5 @@\n-  static Method*      do_stack_walk_method()          { return _do_stack_walk_cache->get_method(); }\n+  static Method*      finalizer_register_method();\n+  static Method*      loader_addClass_method();\n+  static Method*      throw_illegal_access_error();\n+  static Method*      throw_no_such_method_error();\n+  static Method*      do_stack_walk_method();\n@@ -281,1 +254,1 @@\n-  static void initialize_known_methods(TRAPS);\n+  static void initialize_known_methods(JavaThread* current);\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":13,"deletions":40,"binary":false,"changes":53,"status":"modified"}]}