{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,0 +87,8 @@\n+\n+    \/**\n+     * In rare cases, methods may not be compilable because of a compilation bailout. By default, this leads to a\n+     * test failure. However, if such cases are expected in a specific test, this flag can be set to true, which\n+     * allows the test to pass even if there is no compilation. Any associated {@link IR} rule is only executed\n+     * if the test method was compiled, and else it is ignored silently.\n+     *\/\n+    boolean allowNotCompilable() default false;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Test.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+    private boolean isAllowNotCompilable = false;\n@@ -412,0 +413,13 @@\n+    \/**\n+     * In rare cases, methods may not be compilable because of a compilation bailout. By default, this leads to a\n+     * test failure. However, if such cases are expected in multiple methods in a test class, this flag can be set to\n+     * true, which allows any test to pass even if there is a compilation bailout. If only selected methods are prone\n+     * to bail out, it is preferred to use {@link Test#allowNotCompilable()} instead for more fine-grained control.\n+     * By setting this flag, any associated {@link IR} rule of a test is only executed if the test method was compiled,\n+     * and else it is ignored silently.\n+     *\/\n+    public TestFramework allowNotCompilable() {\n+        this.isAllowNotCompilable = true;\n+        return this;\n+    }\n+\n@@ -776,1 +790,1 @@\n-                                                        testClassesOnBootClassPath);\n+                                                        isAllowNotCompilable, testClassesOnBootClassPath);\n@@ -779,1 +793,1 @@\n-                TestClassParser testClassParser = new TestClassParser(testClass);\n+                TestClassParser testClassParser = new TestClassParser(testClass, isAllowNotCompilable);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-                         boolean testClassesOnBootClassPath) {\n+                         boolean allowNotCompilable, boolean testClassesOnBootClassPath) {\n@@ -72,1 +72,2 @@\n-            prepareTestVMFlags(additionalFlags, socket, testClass, helperClasses, defaultWarmup, testClassesOnBootClassPath);\n+            prepareTestVMFlags(additionalFlags, socket, testClass, helperClasses, defaultWarmup,\n+                               allowNotCompilable, testClassesOnBootClassPath);\n@@ -96,1 +97,2 @@\n-                                    Set<Class<?>> helperClasses, int defaultWarmup, boolean testClassesOnBootClassPath) {\n+                                    Set<Class<?>> helperClasses, int defaultWarmup, boolean allowNotCompilable,\n+                                    boolean testClassesOnBootClassPath) {\n@@ -131,0 +133,4 @@\n+        if (allowNotCompilable) {\n+            cmds.add(\"-DAllowNotCompilable=true\");\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMProcess.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.RunMode;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * This class represents a special IR method which was not compiled by the IR framework, but this was explicitly allowed\n+ * by \"allowNotCompilable\". This happens when the compiler bails out of a compilation (i.e. no compilation) but we treat\n+ * this as valid case. Any associated IR rules pass silently.\n+ *\n+ * @see IR\n+ * @see Test\n+ *\/\n+public class NotCompilableIRMethod implements IRMethodMatchable {\n+    private final Method method;\n+    private final int ruleCount;\n+\n+    public NotCompilableIRMethod(Method method, int ruleCount) {\n+        this.method = method;\n+        this.ruleCount = ruleCount;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return method.getName();\n+    }\n+\n+    \/**\n+     * Directly return a {@link NotCompilableIRMethodMatchResult} as we do not need to match IR rules individually.\n+     *\/\n+    @Override\n+    public NotCompilableIRMethodMatchResult match() {\n+        return new NotCompilableIRMethodMatchResult(method, ruleCount);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/NotCompilableIRMethod.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.RunMode;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * This class represents a special matching result of an IR method where the compilation output was completely empty,\n+ * but this was exlicitly allowed by \"allowNotCompilable\". This happens when the compiler bails out of a compilation\n+ * (i.e. no compilation) but we treat this as valid case. Any associated IR rules pass silently.\n+ *\n+ * @see NotCompilableIRMethod\n+ * @see Test\n+ *\/\n+public class NotCompilableIRMethodMatchResult implements MatchResult {\n+    private final Method method;\n+    private final int failedIRRules;\n+\n+    public NotCompilableIRMethodMatchResult(Method method, int failedIRRules) {\n+        this.method = method;\n+        this.failedIRRules = failedIRRules;\n+    }\n+\n+    @Override\n+    public boolean fail() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void accept(MatchResultVisitor visitor) {\n+        visitor.visitMethodNotCompilable(method, failedIRRules);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/NotCompilableIRMethodMatchResult.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n@@ -30,0 +32,1 @@\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.NotCompilableIRMethod;\n@@ -44,0 +47,1 @@\n+    private final boolean allowNotCompilable;\n@@ -45,1 +49,1 @@\n-    public IRMethodBuilder(TestMethods testMethods, LoggedMethods loggedMethods) {\n+    public IRMethodBuilder(TestMethods testMethods, LoggedMethods loggedMethods, boolean allowNotCompilable) {\n@@ -48,0 +52,1 @@\n+        this.allowNotCompilable = allowNotCompilable;\n@@ -67,1 +72,7 @@\n-            return new NotCompiledIRMethod(testMethod.method(), testMethod.irRuleIds().length);\n+            Test[] testAnnos = testMethod.method().getAnnotationsByType(Test.class);\n+            boolean allowMethodNotCompilable = allowNotCompilable || testAnnos[0].allowNotCompilable();\n+            if (allowMethodNotCompilable) {\n+                return new NotCompilableIRMethod(testMethod.method(), testMethod.irRuleIds().length);\n+            } else {\n+                return new NotCompiledIRMethod(testMethod.method(), testMethod.irRuleIds().length);\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/IRMethodBuilder.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+    private final boolean allowNotCompilable;\n@@ -46,1 +47,1 @@\n-    public TestClassParser(Class<?> testClass) {\n+    public TestClassParser(Class<?> testClass, boolean allowNotCompilable) {\n@@ -48,0 +49,1 @@\n+        this.allowNotCompilable = allowNotCompilable;\n@@ -71,1 +73,1 @@\n-        IRMethodBuilder irMethodBuilder = new IRMethodBuilder(testMethods, loggedMethods);\n+        IRMethodBuilder irMethodBuilder = new IRMethodBuilder(testMethods, loggedMethods, allowNotCompilable);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/TestClassParser.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n@@ -124,0 +125,5 @@\n+    @Override\n+    public void visitMethodNotCompilable(Method method, int failedIRRules) {\n+        throw new TestFrameworkException(\"Sould not reach here\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/report\/CompilationOutputBuilder.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,5 @@\n+    @Override\n+    public void visitMethodNotCompilable(Method method, int failedIRRules) {\n+        irMethodCount++;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/report\/FailCountVisitor.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n@@ -100,0 +101,4 @@\n+    public void visitMethodNotCompilable(Method method, int failedIRRules) {\n+        throw new TestFrameworkException(\"Sould not reach here\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/report\/FailureMessageBuilder.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+    void visitMethodNotCompilable(Method method, int failedIRRules);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/visitor\/MatchResultVisitor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    public static final String NOT_COMPILABLE_TAG = \"[NOT_COMPILABLE]\";\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFrameworkSocket.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import compiler.lib.ir_framework.shared.TestFrameworkSocket;\n+\n@@ -112,0 +114,2 @@\n+    private class MethodNotCompilableException extends Exception {}\n+\n@@ -113,0 +117,12 @@\n+        try {\n+            tryCompileMethod(test);\n+        } catch (MethodNotCompilableException e) {\n+            final Method testMethod = test.getTestMethod();\n+            TestFrameworkSocket.write(\"Method not compilable: \" + testMethod, TestFrameworkSocket.NOT_COMPILABLE_TAG, true);\n+            TestRun.check(test.isAllowNotCompilable(),\n+                          \"Method \" + testMethod + \" not compilable (anymore) at level \" + test.getCompLevel() +\n+                          \". Most likely, this is not expected, but if it is, you can use 'allowNotCompilable'.\");\n+        }\n+    }\n+\n+    private void tryCompileMethod(DeclaredTest test) throws MethodNotCompilableException {\n@@ -154,1 +170,1 @@\n-    private void enqueueMethodForCompilation(DeclaredTest test) {\n+    private void enqueueMethodForCompilation(DeclaredTest test) throws MethodNotCompilableException {\n@@ -156,2 +172,3 @@\n-        TestRun.check(WHITE_BOX.isMethodCompilable(testMethod, test.getCompLevel().getValue(), false),\n-                      \"Method \" + testMethod + \" not compilable (anymore) at level \" + test.getCompLevel());\n+        if (!WHITE_BOX.isMethodCompilable(testMethod, test.getCompLevel().getValue(), false)) {\n+            throw new MethodNotCompilableException();\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/AbstractTest.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+    private final boolean allowNotCompilable;\n@@ -41,1 +42,1 @@\n-    public DeclaredTest(Method testMethod, ArgumentsProvider argumentsProvider, CompLevel compLevel, int warmupIterations) {\n+    public DeclaredTest(Method testMethod, ArgumentsProvider argumentsProvider, CompLevel compLevel, int warmupIterations, boolean allowNotCompilable) {\n@@ -46,0 +47,1 @@\n+        this.allowNotCompilable = allowNotCompilable;\n@@ -63,0 +65,4 @@\n+    public boolean isAllowNotCompilable() {\n+        return allowNotCompilable;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/DeclaredTest.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+    private static final boolean ALLOW_METHOD_NOT_COMPILABLE = Boolean.getBoolean(\"AllowNotCompilable\");\n@@ -582,0 +583,1 @@\n+        boolean allowNotCompilable = testAnno.allowNotCompilable() || ALLOW_METHOD_NOT_COMPILABLE;\n@@ -583,1 +585,1 @@\n-        DeclaredTest test = new DeclaredTest(m, argumentsProvider, compLevel, warmupIterations);\n+        DeclaredTest test = new DeclaredTest(m, argumentsProvider, compLevel, warmupIterations, allowNotCompilable);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import compiler.lib.ir_framework.driver.TestVMException;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n+\n+\/*\n+ * @test\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ * @summary Test the functionality of allowNotCompilable.\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.tests.TestNotCompilable\n+ *\/\n+\n+public class TestNotCompilable {\n+    public static void main(String[] args) throws Exception {\n+        runTests(false);\n+        runTests(true);\n+    }\n+\n+    private static void runTests(boolean noWarmup) {\n+        \/\/ Run without any flags -> should pass.\n+        runNormal(TestClassA.class, noWarmup);\n+        runNormal(TestClassB.class, noWarmup);\n+        runNormal(TestClassC.class, noWarmup);\n+        runNormal(TestClassD.class, noWarmup);\n+        runNormal(TestClassE.class, noWarmup);\n+        runNormal(TestClassF.class, noWarmup);\n+\n+        \/\/ Forbid compilation -> should throw exception, because \"not compilable\".\n+        runWithExcludeExpectFailure(TestClassA.class, noWarmup);\n+        runWithExcludeExpectFailure(TestClassB.class, noWarmup);\n+        \/\/ Note: @Run does not fail, but the @IR detects that there is no compilation, and fails.\n+        runWithExcludeExpectFailure(TestClassE.class, noWarmup);\n+        runOptoNoExecuteExpectFailure(TestClassA.class, noWarmup);\n+        runOptoNoExecuteExpectFailure(TestClassB.class, noWarmup);\n+\n+        \/\/ Forbid compilation -> annotation allows not compilable -> should pass.\n+        runWithExcludeExpectSuccess(TestClassC.class, noWarmup);\n+        runWithExcludeExpectSuccess(TestClassD.class, noWarmup);\n+        runWithExcludeExpectSuccess(TestClassF.class, noWarmup);\n+        runOptoNoExecuteExpectSuccess(TestClassC.class, noWarmup);\n+        runOptoNoExecuteExpectSuccess(TestClassD.class, noWarmup);\n+        \/\/ Note: @Run does not fail because of missing compilation. And OptoNoExecute does still\n+        \/\/       print IR before it bails out, and we can successfully match it.\n+        runOptoNoExecuteExpectSuccess(TestClassE.class, noWarmup);\n+        runOptoNoExecuteExpectSuccess(TestClassF.class, noWarmup);\n+\n+        \/\/ Forbid compilation, but allow methods not to compile -> should pass.\n+        runWithExcludeAndGlobalAllowNotCompilable(TestClassA.class, noWarmup);\n+        runWithExcludeAndGlobalAllowNotCompilable(TestClassB.class, noWarmup);\n+        runWithExcludeAndGlobalAllowNotCompilable(TestClassC.class, noWarmup);\n+        runWithExcludeAndGlobalAllowNotCompilable(TestClassD.class, noWarmup);\n+        runWithExcludeAndGlobalAllowNotCompilable(TestClassE.class, noWarmup);\n+        runWithExcludeAndGlobalAllowNotCompilable(TestClassF.class, noWarmup);\n+        runOptoNoExecuteAndGlobalAllowNotCompilable(TestClassA.class, noWarmup);\n+        runOptoNoExecuteAndGlobalAllowNotCompilable(TestClassB.class, noWarmup);\n+        runOptoNoExecuteAndGlobalAllowNotCompilable(TestClassC.class, noWarmup);\n+        runOptoNoExecuteAndGlobalAllowNotCompilable(TestClassD.class, noWarmup);\n+        runOptoNoExecuteAndGlobalAllowNotCompilable(TestClassE.class, noWarmup);\n+        runOptoNoExecuteAndGlobalAllowNotCompilable(TestClassF.class, noWarmup);\n+    }\n+\n+    private static void runNormal(Class c, boolean noWarmup) {\n+        TestFramework framework = new TestFramework(c);\n+        if (noWarmup) { framework.setDefaultWarmup(0); }\n+        framework.start();\n+    }\n+\n+    private static void runWithExcludeExpectFailure(Class c, boolean noWarmup) {\n+        TestFramework framework = new TestFramework(c);\n+        framework.addFlags(\"-XX:CompileCommand=exclude,*TestClass*::test*\");\n+        if (noWarmup) { framework.setDefaultWarmup(0); }\n+        try {\n+            framework.start();\n+            throw new RuntimeException(\"should have thrown TestRunException\/TestVMException or IRViolationException\");\n+        } catch (TestVMException e) {\n+            \/\/ Happens when we hit the issue during explicit compilation by the Framework.\n+        } catch (IRViolationException e) {\n+            \/\/ Happens in STANDALONE Run case, where the user is responsible for ensuring\n+            \/\/ compilation. The failure happens during IR matching.\n+        }\n+    }\n+\n+    private static void runWithExcludeExpectSuccess(Class c, boolean noWarmup) {\n+        TestFramework framework = new TestFramework(c);\n+        framework.addFlags(\"-XX:CompileCommand=exclude,*TestClass*::test*\");\n+        if (noWarmup) { framework.setDefaultWarmup(0); }\n+        framework.start();\n+    }\n+\n+    private static void runOptoNoExecuteExpectFailure(Class c, boolean noWarmup) {\n+        System.out.println(\"runOptoNoExecuteExpectFailure: \" + c + \", noWarmup: \" + noWarmup);\n+        TestFramework framework = new TestFramework(c);\n+        framework.addFlags(\"-XX:CompileCommand=compileonly,*TestClass*::test*\", \"-XX:+OptoNoExecute\");\n+        if (noWarmup) { framework.setDefaultWarmup(0); }\n+        try {\n+            framework.start();\n+            throw new RuntimeException(\"should have thrown TestRunException\/TestVMException\");\n+        } catch (TestVMException e) {}\n+    }\n+\n+    private static void runOptoNoExecuteExpectSuccess(Class c, boolean noWarmup) {\n+        TestFramework framework = new TestFramework(c);\n+        framework.addFlags(\"-XX:CompileCommand=compileonly,*TestClass*::test*\", \"-XX:+OptoNoExecute\");\n+        if (noWarmup) { framework.setDefaultWarmup(0); }\n+        framework.start();\n+    }\n+\n+    private static void runWithExcludeAndGlobalAllowNotCompilable(Class c, boolean noWarmup) {\n+        TestFramework framework = new TestFramework(c);\n+        framework.addFlags(\"-XX:CompileCommand=exclude,*TestClass*::test*\");\n+        if (noWarmup) { framework.setDefaultWarmup(0); }\n+        framework.allowNotCompilable();\n+        framework.start();\n+    }\n+\n+    private static void runOptoNoExecuteAndGlobalAllowNotCompilable(Class c, boolean noWarmup) {\n+        TestFramework framework = new TestFramework(c);\n+        framework.addFlags(\"-XX:CompileCommand=compileonly,*TestClass*::test*\", \"-XX:+OptoNoExecute\");\n+        if (noWarmup) { framework.setDefaultWarmup(0); }\n+        framework.allowNotCompilable();\n+        framework.start();\n+    }\n+}\n+\n+class TestClassA {\n+    @Test\n+    public void test() {}\n+}\n+\n+class TestClassB {\n+    @Test\n+    @IR(failOn = IRNode.LOAD)\n+    public void test() {}\n+}\n+\n+class TestClassC {\n+    @Test(allowNotCompilable = true)\n+    public void test() {}\n+}\n+\n+class TestClassD {\n+    @Test(allowNotCompilable = true)\n+    @IR(failOn = IRNode.LOAD)\n+    public void test() {}\n+}\n+\n+class TestClassE {\n+    @Run(test = {\"test1\", \"test2\"}, mode = RunMode.STANDALONE)\n+    public void run() {\n+        for (int i = 0; i < 10_000; i++) {\n+            test1(i);\n+            test2(i);\n+        }\n+    }\n+\n+    @Test\n+    public void test1(int i) {}\n+\n+    @Test\n+    @IR(failOn = IRNode.LOAD)\n+    public void test2(int i) {}\n+}\n+\n+class TestClassF {\n+    @Run(test = {\"test1\", \"test2\"}, mode = RunMode.STANDALONE)\n+    public void run() {\n+        for (int i = 0; i < 10_000; i++) {\n+            test1(i);\n+            test2(i);\n+        }\n+    }\n+\n+    @Test(allowNotCompilable = true)\n+    public void test1(int i) {}\n+\n+    @Test(allowNotCompilable = true)\n+    @IR(failOn = IRNode.LOAD)\n+    public void test2(int i) {}\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestNotCompilable.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,2 +69,2 @@\n-        TestVMProcess testVMProcess = new TestVMProcess(testVMFlags, testClass, null, -1, false);\n-        TestClassParser testClassParser = new TestClassParser(testClass);\n+        TestVMProcess testVMProcess = new TestVMProcess(testVMFlags, testClass, null, -1, false, false);\n+        TestClassParser testClassParser = new TestClassParser(testClass, false);\n@@ -400,0 +400,5 @@\n+\n+    @Override\n+    public void visitMethodNotCompilable(Method method, int failedIRRules) {\n+        throw new RuntimeException(\"No test should bailout from compilation\");\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPhaseIRMatching.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"}]}