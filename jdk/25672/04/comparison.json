{"files":[{"patch":"@@ -78,1 +78,1 @@\n-        return new HookAnchorToken(this, Token.parse(tokens));\n+        return new HookAnchorToken(this, TokenParser.parse(tokens));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Hook.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -618,1 +618,1 @@\n-        return new TemplateBody(Token.parse(tokens));\n+        return new TemplateBody(TokenParser.parse(tokens));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Template.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,4 +26,0 @@\n-import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n@@ -32,3 +28,1 @@\n- * {@link Token}s or {@link String}s or some permitted boxed primitives. These are then parsed\n- * and all non-{@link Token}s are converted to {@link StringToken}s. The parsing also flattens\n- * {@link List}s.\n+ * {@link Token}s or {@link String}s or some permitted boxed primitives.\n@@ -36,1 +30,1 @@\n-sealed interface Token permits StringToken,\n+public sealed interface Token permits StringToken,\n@@ -45,34 +39,1 @@\n-                               NothingToken\n-{\n-    static List<Token> parse(Object[] objects) {\n-        if (objects == null) {\n-            throw new IllegalArgumentException(\"Unexpected tokens: null\");\n-        }\n-        List<Token> outputList = new ArrayList<>();\n-        parseToken(Arrays.asList(objects), outputList);\n-        return outputList;\n-    }\n-\n-    private static void parseList(List<?> inputList, List<Token> outputList) {\n-        for (Object o : inputList) {\n-            parseToken(o, outputList);\n-        }\n-    }\n-\n-    private static void parseToken(Object o, List<Token> outputList) {\n-        if (o == null) {\n-            throw new IllegalArgumentException(\"Unexpected token: null\");\n-        }\n-        switch (o) {\n-            case Token t   -> outputList.add(t);\n-            case String s  -> outputList.add(new StringToken(Renderer.format(s)));\n-            case Integer s -> outputList.add(new StringToken(Renderer.format(s)));\n-            case Long s    -> outputList.add(new StringToken(Renderer.format(s)));\n-            case Double s  -> outputList.add(new StringToken(Renderer.format(s)));\n-            case Float s   -> outputList.add(new StringToken(Renderer.format(s)));\n-            case Boolean s -> outputList.add(new StringToken(Renderer.format(s)));\n-            case List<?> l -> parseList(l, outputList);\n-            default -> throw new IllegalArgumentException(\"Unexpected token: \" + o);\n-        }\n-    }\n-}\n+                               NothingToken {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Token.java","additions":3,"deletions":42,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Helper class for {@link Token}, to keep the parsing methods package private.\n+ *\n+ * <p>\n+ * The {@link Template#body} and {@link Hook#anchor} are given a list of tokens, which are either\n+ * {@link Token}s or {@link String}s or some permitted boxed primitives. These are then parsed\n+ * and all non-{@link Token}s are converted to {@link StringToken}s. The parsing also flattens\n+ * {@link List}s.\n+ *\/\n+final class TokenParser {\n+    static List<Token> parse(Object[] objects) {\n+        if (objects == null) {\n+            throw new IllegalArgumentException(\"Unexpected tokens: null\");\n+        }\n+        List<Token> outputList = new ArrayList<>();\n+        parseToken(Arrays.asList(objects), outputList);\n+        return outputList;\n+    }\n+\n+    private static void parseList(List<?> inputList, List<Token> outputList) {\n+        for (Object o : inputList) {\n+            parseToken(o, outputList);\n+        }\n+    }\n+\n+    private static void parseToken(Object o, List<Token> outputList) {\n+        if (o == null) {\n+            throw new IllegalArgumentException(\"Unexpected token: null\");\n+        }\n+        switch (o) {\n+            case Token t   -> outputList.add(t);\n+            case String s  -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Integer s -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Long s    -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Double s  -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Float s   -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Boolean s -> outputList.add(new StringToken(Renderer.format(s)));\n+            case List<?> l -> parseList(l, outputList);\n+            default -> throw new IllegalArgumentException(\"Unexpected token: \" + o);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TokenParser.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import java.util.List;\n+\n+import compiler.lib.template_framework.DataName;\n+import compiler.lib.template_framework.Template;\n+\n+\/**\n+ * The {@link CodeGenerationDataNameType} extends the {@link DataName.Type} with\n+ * additional functionality for code generation. These types with their extended\n+ * functionality can be used with many other code generation facilities in the\n+ * library, such as generating random {@code Expression}s.\n+ *\/\n+public interface CodeGenerationDataNameType extends DataName.Type {\n+\n+    \/**\n+     * This method provides a random constant value for the type, which can\n+     * be used as a token inside a {@link Template}.\n+     *\n+     * @return A random constant value.\n+     *\/\n+    Object con();\n+\n+    \/**\n+     * The byte {@link PrimitiveType}.\n+     *\n+     * @return The byte {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType bytes()    { return PrimitiveType.BYTES; }\n+\n+    \/**\n+     * The short {@link PrimitiveType}.\n+     *\n+     * @return The short {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType shorts()   { return PrimitiveType.SHORTS; }\n+\n+    \/**\n+     * The char {@link PrimitiveType}.\n+     *\n+     * @return The char {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType chars()    { return PrimitiveType.CHARS; }\n+\n+    \/**\n+     * The int {@link PrimitiveType}.\n+     *\n+     * @return The int {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType ints()     { return PrimitiveType.INTS; }\n+\n+    \/**\n+     * The long {@link PrimitiveType}.\n+     *\n+     * @return The long {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType longs()    { return PrimitiveType.LONGS; }\n+\n+    \/**\n+     * The float {@link PrimitiveType}.\n+     *\n+     * @return The float {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType floats()   { return PrimitiveType.FLOATS; }\n+\n+    \/**\n+     * The double {@link PrimitiveType}.\n+     *\n+     * @return The double {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType doubles()  { return PrimitiveType.DOUBLES; }\n+\n+    \/**\n+     * The boolean {@link PrimitiveType}.\n+     *\n+     * @return The boolean {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType booleans() { return PrimitiveType.BOOLEANS; }\n+\n+    \/**\n+     * List of all {@link PrimitiveType}s.\n+     *\/\n+    List<PrimitiveType> PRIMITIVE_TYPES = List.of(\n+        bytes(),\n+        chars(),\n+        shorts(),\n+        ints(),\n+        longs(),\n+        floats(),\n+        doubles(),\n+        booleans()\n+    );\n+\n+    \/**\n+     * List of all integral {@link PrimitiveType}s (byte, char, short, int, long).\n+     *\/\n+    List<PrimitiveType> INTEGRAL_TYPES = List.of(\n+        bytes(),\n+        chars(),\n+        shorts(),\n+        ints(),\n+        longs()\n+    );\n+\n+    \/**\n+     * List of all subword {@link PrimitiveType}s (byte, char, short).\n+     *\/\n+    List<PrimitiveType> SUBWORD_TYPES = List.of(\n+        bytes(),\n+        chars(),\n+        shorts()\n+    );\n+\n+    \/**\n+     * List of all floating {@link PrimitiveType}s (float, double).\n+     *\/\n+    List<PrimitiveType> FLOATING_TYPES = List.of(\n+        floats(),\n+        doubles()\n+    );\n+\n+    \/**\n+     * List of all integral and floating {@link PrimitiveType}s.\n+     *\/\n+    List<PrimitiveType> INTEGRAL_AND_FLOATING_TYPES = List.of(\n+        bytes(),\n+        chars(),\n+        shorts(),\n+        ints(),\n+        longs(),\n+        floats(),\n+        doubles()\n+    );\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/CodeGenerationDataNameType.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.RestrictableGenerator;\n+\n+import compiler.lib.template_framework.DataName;\n+\n+\/**\n+ * The {@link PrimitiveType} models Java's primitive types, and provides a set\n+ * of useful methods for code generation, such as the {@link #byteSize} and\n+ * {@link #boxedTypeName}.\n+ *\/\n+public final class PrimitiveType implements CodeGenerationDataNameType {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+    private static final RestrictableGenerator<Integer> GEN_BYTE = Generators.G.safeRestrict(Generators.G.ints(), Byte.MIN_VALUE, Byte.MAX_VALUE);\n+    private static final RestrictableGenerator<Integer> GEN_CHAR = Generators.G.safeRestrict(Generators.G.ints(), Character.MIN_VALUE, Character.MAX_VALUE);\n+    private static final RestrictableGenerator<Integer> GEN_SHORT = Generators.G.safeRestrict(Generators.G.ints(), Short.MIN_VALUE, Short.MAX_VALUE);\n+    private static final RestrictableGenerator<Integer> GEN_INT = Generators.G.ints();\n+    private static final RestrictableGenerator<Long> GEN_LONG = Generators.G.longs();\n+    private static final Generator<Double> GEN_DOUBLE = Generators.G.doubles();\n+    private static final Generator<Float> GEN_FLOAT = Generators.G.floats();\n+\n+    private static enum Kind { BYTE, SHORT, CHAR, INT, LONG, FLOAT, DOUBLE, BOOLEAN };\n+\n+    \/\/ We have one static instance each, so we do not have duplicated instances.\n+    static final PrimitiveType BYTES    = new PrimitiveType(Kind.BYTE   );\n+    static final PrimitiveType SHORTS   = new PrimitiveType(Kind.SHORT  );\n+    static final PrimitiveType CHARS    = new PrimitiveType(Kind.CHAR   );\n+    static final PrimitiveType INTS     = new PrimitiveType(Kind.INT    );\n+    static final PrimitiveType LONGS    = new PrimitiveType(Kind.LONG   );\n+    static final PrimitiveType FLOATS   = new PrimitiveType(Kind.FLOAT  );\n+    static final PrimitiveType DOUBLES  = new PrimitiveType(Kind.DOUBLE );\n+    static final PrimitiveType BOOLEANS = new PrimitiveType(Kind.BOOLEAN);\n+\n+    final Kind kind;\n+\n+    \/\/ Private constructor so nobody can create duplicate instances.\n+    private PrimitiveType(Kind kind) {\n+        this.kind = kind;\n+    }\n+\n+    @Override\n+    public boolean isSubtypeOf(DataName.Type other) {\n+        return (other instanceof PrimitiveType pt) && pt.kind == kind;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return switch (kind) {\n+            case BYTE    -> \"byte\";\n+            case SHORT   -> \"short\";\n+            case CHAR    -> \"char\";\n+            case INT     -> \"int\";\n+            case LONG    -> \"long\";\n+            case FLOAT   -> \"float\";\n+            case DOUBLE  -> \"double\";\n+            case BOOLEAN -> \"boolean\";\n+        };\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name();\n+    }\n+\n+    public Object con() {\n+        return switch (kind) {\n+            case BYTE    -> \"(byte)\" + GEN_BYTE.next();\n+            case SHORT   -> \"(short)\" + GEN_SHORT.next();\n+            case CHAR    -> \"(char)\" + GEN_CHAR.next();\n+            case INT     -> GEN_INT.next();\n+            case LONG    -> GEN_LONG.next();\n+            case FLOAT   -> GEN_FLOAT.next();\n+            case DOUBLE  -> GEN_DOUBLE.next();\n+            case BOOLEAN -> RANDOM.nextBoolean();\n+        };\n+    }\n+\n+    \/**\n+     * Provides the size of the type in bytes.\n+     *\n+     * @return Size of the type in bytes.\n+     * @throws UnsupportedOperationException for boolean which has no defined size.\n+     *\/\n+    public int byteSize() {\n+        return switch (kind) {\n+            case BYTE    -> 1;\n+            case SHORT, CHAR -> 2;\n+            case INT, FLOAT -> 4;\n+            case LONG, DOUBLE -> 8;\n+            case BOOLEAN -> { throw new UnsupportedOperationException(\"boolean does not have a defined 'size'\"); }\n+        };\n+    }\n+\n+    \/**\n+     * Provides the name of the boxed type.\n+     *\n+     * @return the name of the boxed type.\n+     *\/\n+    public String boxedTypeName() {\n+        return switch (kind) {\n+            case BYTE    -> \"Byte\";\n+            case SHORT   -> \"Short\";\n+            case CHAR    -> \"Character\";\n+            case INT     -> \"Integer\";\n+            case LONG    -> \"Long\";\n+            case FLOAT   -> \"Float\";\n+            case DOUBLE  -> \"Double\";\n+            case BOOLEAN -> \"Boolean\";\n+        };\n+    }\n+\n+    \/**\n+     * Indicates if the type is a floating point type.\n+     *\n+     * @return true iff the type is a floating point type.\n+     *\/\n+    public boolean isFloating() {\n+        return switch (kind) {\n+            case BYTE, SHORT, CHAR, INT, LONG, BOOLEAN -> false;\n+            case FLOAT, DOUBLE -> true;\n+        };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/PrimitiveType.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8358772\n+ * @summary Demonstrate the use of PrimitiveTypes form the Template Library.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run main template_framework.examples.TestPrimitiveTypes\n+ *\/\n+\n+package template_framework.examples;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.HashMap;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.dataNames;\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.$;\n+import static compiler.lib.template_framework.Template.addDataName;\n+import static compiler.lib.template_framework.DataName.Mutability.MUTABLE;\n+\n+import compiler.lib.template_framework.library.Hooks;\n+import compiler.lib.template_framework.library.CodeGenerationDataNameType;\n+import compiler.lib.template_framework.library.PrimitiveType;\n+\n+\/**\n+ * This test shows the use of {@link PrimitiveType}.\n+ *\/\n+public class TestPrimitiveTypes {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate());\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ p.xyz.InnerTest.main();\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {});\n+    }\n+\n+    \/\/ Generate a Java source file as String\n+    public static String generate() {\n+        \/\/ Generate a list of test methods.\n+        Map<String, TemplateToken> tests = new HashMap<>();\n+\n+        \/\/ The boxing tests check if we can autobox with \"boxedTypeName\".\n+        var boxingTemplate = Template.make(\"name\", \"type\", (String name, PrimitiveType type) -> body(\n+            let(\"CON1\", type.con()),\n+            let(\"CON2\", type.con()),\n+            let(\"Boxed\", type.boxedTypeName()),\n+            \"\"\"\n+            public static void #name() {\n+                #type c1 = #CON1;\n+                #type c2 = #CON2;\n+                #Boxed b1 = c1;\n+                #Boxed b2 = c2;\n+                Verify.checkEQ(c1, b1);\n+                Verify.checkEQ(c2, b2);\n+            }\n+            \"\"\"\n+        ));\n+\n+        for (PrimitiveType type : CodeGenerationDataNameType.PRIMITIVE_TYPES) {\n+            String name = \"test_boxing_\" + type.name();\n+            tests.put(name, boxingTemplate.asToken(name, type));\n+        }\n+\n+        \/\/ Integral and Float types have a size. Also test if \"isFloating\" is correct.\n+        var integralFloatTemplate = Template.make(\"name\", \"type\", (String name, PrimitiveType type) -> body(\n+            let(\"size\", type.byteSize()),\n+            let(\"isFloating\", type.isFloating()),\n+            \"\"\"\n+            public static void #name() {\n+                \/\/ Test byteSize via creation of array.\n+                #type[] array = new #type[1];\n+                MemorySegment ms = MemorySegment.ofArray(array);\n+                if (#size != ms.byteSize()) {\n+                    throw new RuntimeException(\"byteSize mismatch #type\");\n+                }\n+\n+                \/\/ Test isFloating via rounding.\n+                double value = 1.5;\n+                #type rounded = (#type)value;\n+                boolean isFloating = value != rounded;\n+                if (isFloating == #isFloating) {\n+                    throw new RuntimeException(\"isFloating mismatch #type\");\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        for (PrimitiveType type : CodeGenerationDataNameType.INTEGRAL_AND_FLOATING_TYPES) {\n+            String name = \"test_integral_floating_\" + type.name();\n+            tests.put(name, integralFloatTemplate.asToken(name, type));\n+        }\n+\n+        \/\/ Finally, test the type by creating some DataNames (variables), and sampling\n+        \/\/ from them. There should be no cross-over between the types.\n+        var variableTemplate = Template.make(\"type\", (PrimitiveType type) -> body(\n+            let(\"CON\", type.con()),\n+            addDataName($(\"var\"), type, MUTABLE),\n+            \"\"\"\n+            #type $var = #CON;\n+            \"\"\"\n+        ));\n+\n+        var sampleTemplate = Template.make(\"type\", (PrimitiveType type) -> body(\n+            let(\"var\", dataNames(MUTABLE).exactOf(type).sample().name()),\n+            let(\"CON\", type.con()),\n+            \"\"\"\n+            #var = #CON;\n+            \"\"\"\n+        ));\n+\n+        var namesTemplate = Template.make(() -> body(\n+            \"\"\"\n+            public static void test_names() {\n+            \"\"\",\n+            Hooks.METHOD_HOOK.anchor(\n+                Collections.nCopies(10,\n+                    CodeGenerationDataNameType.PRIMITIVE_TYPES.stream().map(type ->\n+                        Hooks.METHOD_HOOK.insert(variableTemplate.asToken(type))\n+                    ).toList()\n+                ),\n+                \"\"\"\n+                \/\/ Now sample:\n+                \"\"\",\n+                Collections.nCopies(10,\n+                    CodeGenerationDataNameType.PRIMITIVE_TYPES.stream().map(sampleTemplate::asToken).toList()\n+                )\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        tests.put(\"test_names\", namesTemplate.asToken());\n+\n+        \/\/ Finally, put all the tests together in a class, and invoke all\n+        \/\/ tests from the main method.\n+        var template = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            import compiler.lib.verify.*;\n+            import java.lang.foreign.MemorySegment;\n+\n+            public class InnerTest {\n+                public static void main() {\n+            \"\"\",\n+            \/\/ Call all test methods from main.\n+            tests.keySet().stream().map(\n+                n -> List.of(n, \"();\\n\")\n+            ).toList(),\n+            \"\"\"\n+                }\n+            \"\"\",\n+            \/\/ Now add all the test methods.\n+            tests.values().stream().toList(),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render the template to a String.\n+        return template.render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestPrimitiveTypes.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"}]}