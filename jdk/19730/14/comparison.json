{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -888,5 +888,3 @@\n-        try {\n-            FloatToDecimal.appendTo(f, this);\n-        } catch (IOException e) {\n-            throw new AssertionError(e);\n-        }\n+        ensureCapacityInternal(count + FloatToDecimal.MAX_CHARS);\n+        FloatToDecimal toDecimal = isLatin1() ? FloatToDecimal.LATIN1 : FloatToDecimal.UTF16;\n+        count = toDecimal.putDecimal(value, count, f);\n@@ -894,1 +892,0 @@\n-\n@@ -910,5 +907,3 @@\n-        try {\n-            DoubleToDecimal.appendTo(d, this);\n-        } catch (IOException e) {\n-            throw new AssertionError(e);\n-        }\n+        ensureCapacityInternal(count + DoubleToDecimal.MAX_CHARS);\n+        DoubleToDecimal toDecimal = isLatin1() ? DoubleToDecimal.LATIN1 : DoubleToDecimal.UTF16;\n+        count = toDecimal.putDecimal(value, count, d);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -35,0 +36,2 @@\n+import sun.nio.cs.ISO_8859_1;\n+\n@@ -38,1 +41,13 @@\n-public final class DoubleToDecimal {\n+public final class DoubleToDecimal extends ToDecimal {\n+    \/**\n+     * Use LATIN1 encoding to process the in-out byte[] str\n+     *\n+     *\/\n+    public static final DoubleToDecimal LATIN1 = new DoubleToDecimal(ToDecimal.LATIN1);\n+\n+    \/**\n+     * Use UTF16 encoding to process the in-out byte[] str\n+     *\n+     *\/\n+    public static final DoubleToDecimal UTF16  = new DoubleToDecimal(ToDecimal.UTF16);\n+\n@@ -94,10 +109,0 @@\n-    \/* Used for left-to-tight digit extraction *\/\n-    private static final int MASK_28 = (1 << 28) - 1;\n-\n-    private static final int NON_SPECIAL    = 0;\n-    private static final int PLUS_ZERO      = 1;\n-    private static final int MINUS_ZERO     = 2;\n-    private static final int PLUS_INF       = 3;\n-    private static final int MINUS_INF      = 4;\n-    private static final int NAN            = 5;\n-\n@@ -113,7 +118,2 @@\n-    private final byte[] bytes;\n-\n-    \/* Index into bytes of rightmost valid character *\/\n-    private int index;\n-\n-    private DoubleToDecimal(boolean noChars) {\n-        bytes = noChars ? null : new byte[MAX_CHARS];\n+    private DoubleToDecimal(byte coder) {\n+        super(coder);\n@@ -131,1 +131,8 @@\n-        return new DoubleToDecimal(false).toDecimalString(v);\n+        byte[] str = new byte[MAX_CHARS];\n+        int pair = LATIN1.toDecimal(str, 0, v, null);\n+        int type = pair & 0xFF00;\n+        if (type == NON_SPECIAL) {\n+            int size = pair & 0xFF;\n+            return new String(str, 0, size, ISO_8859_1.INSTANCE);\n+        }\n+        return special(type);\n@@ -152,1 +159,2 @@\n-        new DoubleToDecimal(true).toDecimal(v, fd);\n+        byte[] str = new byte[MAX_CHARS];\n+        LATIN1.toDecimal(str, 0, v, fd);\n@@ -156,1 +164,1 @@\n-     * Appends the rendering of the {@code v} to {@code app}.\n+     * Appends the rendering of the {@code v} to {@code str}.\n@@ -160,1 +168,0 @@\n-     * {@link Appendable#append(CharSequence) appended} to {@code app}.\n@@ -162,2 +169,3 @@\n-     * @param v the {@code double} whose rendering is appended.\n-     * @param app the {@link Appendable} to append to.\n+     * @param str the String byte array to append to\n+     * @param index the index into str\n+     * @param v the {@code double} whose rendering is into str.\n@@ -166,4 +174,2 @@\n-    public static Appendable appendTo(double v, Appendable app)\n-            throws IOException {\n-        return new DoubleToDecimal(false).appendDecimalTo(v, app);\n-    }\n+    public int putDecimal(byte[] str, int index, double v) {\n+        assert 0 <= index && index <= length(str) - MAX_CHARS : \"Trusted caller missed bounds check\";\n@@ -171,34 +177,4 @@\n-    private String toDecimalString(double v) {\n-        return switch (toDecimal(v, null)) {\n-            case NON_SPECIAL -> charsToString();\n-            case PLUS_ZERO -> \"0.0\";\n-            case MINUS_ZERO -> \"-0.0\";\n-            case PLUS_INF -> \"Infinity\";\n-            case MINUS_INF -> \"-Infinity\";\n-            default -> \"NaN\";\n-        };\n-    }\n-\n-    private Appendable appendDecimalTo(double v, Appendable app)\n-            throws IOException {\n-        switch (toDecimal(v, null)) {\n-            case NON_SPECIAL:\n-                char[] chars = new char[index + 1];\n-                for (int i = 0; i < chars.length; ++i) {\n-                    chars[i] = (char) bytes[i];\n-                }\n-                if (app instanceof StringBuilder builder) {\n-                    return builder.append(chars);\n-                }\n-                if (app instanceof StringBuffer buffer) {\n-                    return buffer.append(chars);\n-                }\n-                for (char c : chars) {\n-                    app.append(c);\n-                }\n-                return app;\n-            case PLUS_ZERO: return app.append(\"0.0\");\n-            case MINUS_ZERO: return app.append(\"-0.0\");\n-            case PLUS_INF: return app.append(\"Infinity\");\n-            case MINUS_INF: return app.append(\"-Infinity\");\n-            default: return app.append(\"NaN\");\n+        int pair = toDecimal(str, index, v, null);\n+        int type = pair & 0xFF00;\n+        if (type == NON_SPECIAL) {\n+            return index + (pair & 0xFF);\n@@ -206,0 +182,1 @@\n+        return putSpecial(str, index, type);\n@@ -209,1 +186,1 @@\n-     * Returns\n+     *  Returns size in the lower byte, type in the high byte, where type is\n@@ -215,0 +192,1 @@\n+     *     otherwise NON_SPECIAL\n@@ -216,1 +194,1 @@\n-    private int toDecimal(double v, FormattedFPDecimal fd) {\n+    private int toDecimal(byte[] str, int index, double v, FormattedFPDecimal fd) {\n@@ -230,1 +208,1 @@\n-            index = -1;\n+            int start = index;\n@@ -233,1 +211,1 @@\n-                 * fd != null implies bytes == null and bits >= 0\n+                 * fd != null implies str == null and bits >= 0\n@@ -236,1 +214,1 @@\n-                append('-');\n+                putChar(str, index++, '-');\n@@ -246,1 +224,1 @@\n-                        return toChars(f, 0, fd);\n+                        return toChars(str, index, f, 0, fd) - start;\n@@ -249,1 +227,1 @@\n-                return toDecimal(-mq, c, 0, fd);\n+                return toDecimal(str, index, -mq, c, 0, fd) - start;\n@@ -253,3 +231,6 @@\n-                return t < C_TINY\n-                       ? toDecimal(Q_MIN, 10 * t, -1, fd)\n-                       : toDecimal(Q_MIN, t, 0, fd);\n+                int dk = 0;\n+                if (t < C_TINY) {\n+                    t *= 10;\n+                    dk = -1;\n+                }\n+                return toDecimal(str, index, Q_MIN, t, dk, fd) - start;\n@@ -265,1 +246,1 @@\n-    private int toDecimal(int q, long c, int dk, FormattedFPDecimal fd) {\n+    private int toDecimal(byte[] str, int index, int q, long c, int dk, FormattedFPDecimal fd) {\n@@ -330,1 +311,1 @@\n-                return toChars(upin ? sp10 : tp10, k, fd);\n+                return toChars(str, index, upin ? sp10 : tp10, k, fd);\n@@ -345,1 +326,1 @@\n-            return toChars(uin ? s : t, k + dk, fd);\n+            return toChars(str, index, uin ? s : t, k + dk, fd);\n@@ -352,1 +333,1 @@\n-        return toChars(cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk, fd);\n+        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk, fd);\n@@ -371,1 +352,1 @@\n-    private int toChars(long f, int e, FormattedFPDecimal fd) {\n+    private int toChars(byte[] str, int index, long f, int e, FormattedFPDecimal fd) {\n@@ -384,1 +365,1 @@\n-            return NON_SPECIAL;\n+            return index;\n@@ -416,1 +397,1 @@\n-            return toChars1(h, m, l, e);\n+            return toChars1(str, index, h, m, l, e);\n@@ -419,1 +400,1 @@\n-            return toChars2(h, m, l, e);\n+            return toChars2(str, index, h, m, l, e);\n@@ -421,1 +402,1 @@\n-        return toChars3(h, m, l, e);\n+        return toChars3(str, index, h, m, l, e);\n@@ -424,1 +405,1 @@\n-    private int toChars1(int h, int m, int l, int e) {\n+    private int toChars1(byte[] str, int index, int h, int m, int l, int e) {\n@@ -430,1 +411,1 @@\n-        appendDigit(h);\n+        putDigit(str, index++, h);\n@@ -436,1 +417,1 @@\n-            appendDigit(t >>> 28);\n+            putDigit(str, index++, t >>> 28);\n@@ -439,1 +420,1 @@\n-        append('.');\n+        putChar(str, index++, '.');\n@@ -442,1 +423,1 @@\n-            appendDigit(t >>> 28);\n+            putDigit(str, index++, t >>> 28);\n@@ -445,2 +426,1 @@\n-        lowDigits(l);\n-        return NON_SPECIAL;\n+        return lowDigits(str, index, l);\n@@ -449,1 +429,1 @@\n-    private int toChars2(int h, int m, int l, int e) {\n+    private int toChars2(byte[] str, int index, int h, int m, int l, int e) {\n@@ -451,2 +431,2 @@\n-        appendDigit(0);\n-        append('.');\n+        putCharsAt(str, index, '0', '.');\n+        index += 2;\n@@ -454,1 +434,1 @@\n-            appendDigit(0);\n+            putDigit(str, index++, 0);\n@@ -456,4 +436,3 @@\n-        appendDigit(h);\n-        append8Digits(m);\n-        lowDigits(l);\n-        return NON_SPECIAL;\n+        putDigit(str, index, h);\n+        put8Digits(str, index + 1, m);\n+        return lowDigits(str, index + 9, l);\n@@ -462,1 +441,1 @@\n-    private int toChars3(int h, int m, int l, int e) {\n+    private int toChars3(byte[] str, int index, int h, int m, int l, int e) {\n@@ -464,6 +443,4 @@\n-        appendDigit(h);\n-        append('.');\n-        append8Digits(m);\n-        lowDigits(l);\n-        exponent(e - 1);\n-        return NON_SPECIAL;\n+        putCharsAt(str, index, '0' + h, '.');\n+        put8Digits(str, index + 2, m);\n+        index = lowDigits(str, index + 10, l);\n+        return exponent(str, index, e - 1);\n@@ -472,1 +449,1 @@\n-    private void lowDigits(int l) {\n+    private int lowDigits(byte[] str, int index, int l) {\n@@ -474,25 +451,2 @@\n-            append8Digits(l);\n-        }\n-        removeTrailingZeroes();\n-    }\n-\n-    private void append8Digits(int m) {\n-        \/*\n-         * Left-to-right digits extraction:\n-         * algorithm 1 in [3], with b = 10, k = 8, n = 28.\n-         *\/\n-        int y = y(m);\n-        for (int i = 0; i < 8; ++i) {\n-            int t = 10 * y;\n-            appendDigit(t >>> 28);\n-            y = t & MASK_28;\n-        }\n-    }\n-\n-    private void removeTrailingZeroes() {\n-        while (bytes[index] == '0') {\n-            --index;\n-        }\n-        \/* ... but do not remove the one directly to the right of '.' *\/\n-        if (bytes[index] == '.') {\n-            ++index;\n+            put8Digits(str, index, l);\n+            index += 8;\n@@ -500,0 +454,1 @@\n+        return removeTrailingZeroes(str, index);\n@@ -502,16 +457,2 @@\n-    private int y(int a) {\n-        \/*\n-         * Algorithm 1 in [3] needs computation of\n-         *     floor((a + 1) 2^n \/ b^k) - 1\n-         * with a < 10^8, b = 10, k = 8, n = 28.\n-         * Noting that\n-         *     (a + 1) 2^n <= 10^8 2^28 < 10^17\n-         * For n = 17, m = 8 the table in section 10 of [1] leads to:\n-         *\/\n-        return (int) (multiplyHigh(\n-                (long) (a + 1) << 28,\n-                193_428_131_138_340_668L) >>> 20) - 1;\n-    }\n-\n-    private void exponent(int e) {\n-        append('E');\n+    private int exponent(byte[] str, int index, int e) {\n+        putChar(str, index++, 'E');\n@@ -519,1 +460,1 @@\n-            append('-');\n+            putChar(str, index++, '-');\n@@ -523,2 +464,2 @@\n-            appendDigit(e);\n-            return;\n+            putDigit(str, index, e);\n+            return index + 1;\n@@ -533,1 +474,1 @@\n-            appendDigit(d);\n+            putDigit(str, index++, d);\n@@ -541,6 +482,2 @@\n-        appendDigit(d);\n-        appendDigit(e - 10 * d);\n-    }\n-\n-    private void append(int c) {\n-        bytes[++index] = (byte) c;\n+        putCharsAt(str, index, '0' + d, '0' + e - 10 * d);\n+        return index + 2;\n@@ -548,11 +485,0 @@\n-\n-    private void appendDigit(int d) {\n-        bytes[++index] = (byte) ('0' + d);\n-    }\n-\n-    \/* Using the deprecated constructor enhances performance *\/\n-    @SuppressWarnings(\"deprecation\")\n-    private String charsToString() {\n-        return new String(bytes, 0, 0, index + 1);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleToDecimal.java","additions":93,"deletions":167,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -35,0 +36,2 @@\n+import sun.nio.cs.ISO_8859_1;\n+\n@@ -38,1 +41,13 @@\n-public final class FloatToDecimal {\n+public final class FloatToDecimal extends ToDecimal {\n+    \/**\n+     * Use LATIN1 encoding to process the input byte[] str\n+     *\n+     *\/\n+    public static final FloatToDecimal LATIN1 = new FloatToDecimal(ToDecimal.LATIN1);\n+\n+    \/**\n+     * Use UTF16 encoding to process the input byte[] str\n+     *\n+     *\/\n+    public static final FloatToDecimal UTF16  = new FloatToDecimal(ToDecimal.UTF16);\n+\n@@ -94,10 +109,0 @@\n-    \/* Used for left-to-tight digit extraction *\/\n-    private static final int MASK_28 = (1 << 28) - 1;\n-\n-    private static final int NON_SPECIAL    = 0;\n-    private static final int PLUS_ZERO      = 1;\n-    private static final int MINUS_ZERO     = 2;\n-    private static final int PLUS_INF       = 3;\n-    private static final int MINUS_INF      = 4;\n-    private static final int NAN            = 5;\n-\n@@ -113,6 +118,2 @@\n-    private final byte[] bytes = new byte[MAX_CHARS];\n-\n-    \/* Index into bytes of rightmost valid character *\/\n-    private int index;\n-\n-    private FloatToDecimal() {\n+    private FloatToDecimal(byte coder) {\n+        super(coder);\n@@ -130,1 +131,8 @@\n-        return new FloatToDecimal().toDecimalString(v);\n+        byte[] str = new byte[MAX_CHARS];\n+        int pair = LATIN1.toDecimal(str, 0, v);\n+        int type = pair & 0xFF00;\n+        if (type == NON_SPECIAL) {\n+            int size = pair & 0xFF;\n+            return new String(str, 0, size, ISO_8859_1.INSTANCE);\n+        }\n+        return special(type);\n@@ -134,1 +142,1 @@\n-     * Appends the rendering of the {@code v} to {@code app}.\n+     * Appends the rendering of the {@code v} to {@code str}.\n@@ -137,2 +145,1 @@\n-     * {@link #toString(float) rendered} and the resulting string were then\n-     * {@link Appendable#append(CharSequence) appended} to {@code app}.\n+     * {@link #toString(double) rendered} and the resulting string were then\n@@ -140,2 +147,3 @@\n-     * @param v the {@code float} whose rendering is appended.\n-     * @param app the {@link Appendable} to append to.\n+     * @param str the String byte array to append to\n+     * @param index the index into str\n+     * @param v the {@code float} whose rendering is into str.\n@@ -144,4 +152,2 @@\n-    public static Appendable appendTo(float v, Appendable app)\n-            throws IOException {\n-        return new FloatToDecimal().appendDecimalTo(v, app);\n-    }\n+    public int putDecimal(byte[] str, int index, float v) {\n+        assert index >= 0 && index + MAX_CHARS <= length(str) : \"Trusted caller missed bounds check\";\n@@ -149,34 +155,4 @@\n-    private String toDecimalString(float v) {\n-        return switch (toDecimal(v)) {\n-            case NON_SPECIAL -> charsToString();\n-            case PLUS_ZERO -> \"0.0\";\n-            case MINUS_ZERO -> \"-0.0\";\n-            case PLUS_INF -> \"Infinity\";\n-            case MINUS_INF -> \"-Infinity\";\n-            default -> \"NaN\";\n-        };\n-    }\n-\n-    private Appendable appendDecimalTo(float v, Appendable app)\n-            throws IOException {\n-        switch (toDecimal(v)) {\n-            case NON_SPECIAL:\n-                char[] chars = new char[index + 1];\n-                for (int i = 0; i < chars.length; ++i) {\n-                    chars[i] = (char) bytes[i];\n-                }\n-                if (app instanceof StringBuilder builder) {\n-                    return builder.append(chars);\n-                }\n-                if (app instanceof StringBuffer buffer) {\n-                    return buffer.append(chars);\n-                }\n-                for (char c : chars) {\n-                    app.append(c);\n-                }\n-                return app;\n-            case PLUS_ZERO: return app.append(\"0.0\");\n-            case MINUS_ZERO: return app.append(\"-0.0\");\n-            case PLUS_INF: return app.append(\"Infinity\");\n-            case MINUS_INF: return app.append(\"-Infinity\");\n-            default: return app.append(\"NaN\");\n+        int pair = toDecimal(str, index, v);\n+        int type = pair & 0xFF00;\n+        if (type == NON_SPECIAL) {\n+            return index + (pair & 0xFF);\n@@ -184,0 +160,1 @@\n+        return putSpecial(str, index, type);\n@@ -188,0 +165,2 @@\n+     *     Combine type and size, the first byte is size, the second byte is type\n+     *\n@@ -194,1 +173,1 @@\n-    private int toDecimal(float v) {\n+    private int toDecimal(byte[] str, int index, float v) {\n@@ -208,1 +187,1 @@\n-            index = -1;\n+            int start = index;\n@@ -210,1 +189,1 @@\n-                append('-');\n+                putChar(str, index++, '-');\n@@ -220,1 +199,1 @@\n-                        return toChars(f, 0);\n+                        return toChars(str, index, f, 0) - start;\n@@ -223,1 +202,1 @@\n-                return toDecimal(-mq, c, 0);\n+                return toDecimal(str, index, -mq, c, 0) - start;\n@@ -227,3 +206,6 @@\n-                return t < C_TINY\n-                       ? toDecimal(Q_MIN, 10 * t, -1)\n-                       : toDecimal(Q_MIN, t, 0);\n+                int dk = 0;\n+                if (t < C_TINY) {\n+                    t *= 10;\n+                    dk = -1;\n+                }\n+                return toDecimal(str, index, Q_MIN, t, dk) - start;\n@@ -239,1 +221,1 @@\n-    private int toDecimal(int q, int c, int dk) {\n+    private int toDecimal(byte[] str, int index, int q, int c, int dk) {\n@@ -303,1 +285,1 @@\n-                return toChars(upin ? sp10 : tp10, k);\n+                return toChars(str, index, upin ? sp10 : tp10, k);\n@@ -318,1 +300,1 @@\n-            return toChars(uin ? s : t, k + dk);\n+            return toChars(str, index, uin ? s : t, k + dk);\n@@ -325,1 +307,1 @@\n-        return toChars(cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n+        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n@@ -341,1 +323,1 @@\n-    private int toChars(int f, int e) {\n+    private int toChars(byte[] str, int index, int f, int e) {\n@@ -376,1 +358,1 @@\n-            return toChars1(h, l, e);\n+            return toChars1(str, index, h, l, e);\n@@ -379,1 +361,1 @@\n-            return toChars2(h, l, e);\n+            return toChars2(str, index, h, l, e);\n@@ -381,1 +363,1 @@\n-        return toChars3(h, l, e);\n+        return toChars3(str, index, h, l, e);\n@@ -384,1 +366,1 @@\n-    private int toChars1(int h, int l, int e) {\n+    private int toChars1(byte[] str, int index, int h, int l, int e) {\n@@ -390,1 +372,1 @@\n-        appendDigit(h);\n+        putDigit(str, index++, h);\n@@ -396,1 +378,1 @@\n-            appendDigit(t >>> 28);\n+            putDigit(str, index++, t >>> 28);\n@@ -399,1 +381,1 @@\n-        append('.');\n+        putChar(str, index++, '.');\n@@ -402,1 +384,1 @@\n-            appendDigit(t >>> 28);\n+            putDigit(str, index++, t >>> 28);\n@@ -405,2 +387,1 @@\n-        removeTrailingZeroes();\n-        return NON_SPECIAL;\n+        return removeTrailingZeroes(str, index);\n@@ -409,1 +390,1 @@\n-    private int toChars2(int h, int l, int e) {\n+    private int toChars2(byte[] str, int index, int h, int l, int e) {\n@@ -411,2 +392,2 @@\n-        appendDigit(0);\n-        append('.');\n+        putCharsAt(str, index, '0', '.');\n+        index += 2;\n@@ -414,1 +395,1 @@\n-          appendDigit(0);\n+            putDigit(str, index++, 0);\n@@ -416,4 +397,3 @@\n-        appendDigit(h);\n-        append8Digits(l);\n-        removeTrailingZeroes();\n-        return NON_SPECIAL;\n+        putDigit(str, index, h);\n+        put8Digits(str, index + 1, l);\n+        return removeTrailingZeroes(str, index + 9);\n@@ -422,1 +402,1 @@\n-    private int toChars3(int h, int l, int e) {\n+    private int toChars3(byte[] str, int index, int h, int l, int e) {\n@@ -424,6 +404,4 @@\n-        appendDigit(h);\n-        append('.');\n-        append8Digits(l);\n-        removeTrailingZeroes();\n-        exponent(e - 1);\n-        return NON_SPECIAL;\n+        putCharsAt(str, index, '0' + h, '.');\n+        put8Digits(str, index + 2     , l  );\n+        index = removeTrailingZeroes(str, index + 10);\n+        return exponent(str, index, e - 1);\n@@ -432,39 +410,2 @@\n-    private void append8Digits(int m) {\n-        \/*\n-         * Left-to-right digits extraction:\n-         * algorithm 1 in [3], with b = 10, k = 8, n = 28.\n-         *\/\n-        int y = y(m);\n-        for (int i = 0; i < 8; ++i) {\n-            int t = 10 * y;\n-            appendDigit(t >>> 28);\n-            y = t & MASK_28;\n-        }\n-    }\n-\n-    private void removeTrailingZeroes() {\n-        while (bytes[index] == '0') {\n-            --index;\n-        }\n-        \/* ... but do not remove the one directly to the right of '.' *\/\n-        if (bytes[index] == '.') {\n-            ++index;\n-        }\n-    }\n-\n-    private int y(int a) {\n-        \/*\n-         * Algorithm 1 in [3] needs computation of\n-         *     floor((a + 1) 2^n \/ b^k) - 1\n-         * with a < 10^8, b = 10, k = 8, n = 28.\n-         * Noting that\n-         *     (a + 1) 2^n <= 10^8 2^28 < 10^17\n-         * For n = 17, m = 8 the table in section 10 of [1] leads to:\n-         *\/\n-        return (int) (multiplyHigh(\n-                (long) (a + 1) << 28,\n-                193_428_131_138_340_668L) >>> 20) - 1;\n-    }\n-\n-    private void exponent(int e) {\n-        append('E');\n+    private int exponent(byte[] str, int index, int e) {\n+        putChar(str, index++, 'E');\n@@ -472,1 +413,1 @@\n-            append('-');\n+            putChar(str, index++, '-');\n@@ -476,2 +417,2 @@\n-            appendDigit(e);\n-            return;\n+            putDigit(str, index, e);\n+            return index + 1;\n@@ -484,6 +425,2 @@\n-        appendDigit(d);\n-        appendDigit(e - 10 * d);\n-    }\n-\n-    private void append(int c) {\n-        bytes[++index] = (byte) c;\n+        putCharsAt(str, index, '0' + d, '0' + e - 10 * d);\n+        return index + 2;\n@@ -491,11 +428,0 @@\n-\n-    private void appendDigit(int d) {\n-        bytes[++index] = (byte) ('0' + d);\n-    }\n-\n-    \/* Using the deprecated constructor enhances performance *\/\n-    @SuppressWarnings(\"deprecation\")\n-    private String charsToString() {\n-        return new String(bytes, 0, 0, index + 1);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatToDecimal.java","additions":85,"deletions":159,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.math;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+import static java.lang.Math.multiplyHigh;\n+\n+abstract sealed class ToDecimal permits DoubleToDecimal, FloatToDecimal {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    \/* Used for left-to-tight digit extraction *\/\n+    static final int MASK_28 = (1 << 28) - 1;\n+\n+    static final int NON_SPECIAL = 0;\n+    static final int PLUS_ZERO   = 0x100;\n+    static final int MINUS_ZERO  = 0x200;\n+    static final int PLUS_INF    = 0x300;\n+    static final int MINUS_INF   = 0x400;\n+    static final int NAN         = 0x500;\n+\n+    static final byte LATIN1 = 0;\n+    static final byte UTF16  = 1;\n+\n+    \/**\n+     * The identifier of the encoding used to encode the bytes. The supported values in this implementation are\n+     *\n+     * LATIN1\n+     * UTF16\n+     *\n+     *\/\n+    private final byte coder;\n+\n+    ToDecimal(byte coder) {\n+        this.coder = coder;\n+    }\n+\n+    final void putChar(byte[] str, int index, int c) {\n+        if (coder == LATIN1) {\n+            str[index] = (byte) c;\n+        } else {\n+            JLA.putCharUTF16(str, index, (char) c);\n+        }\n+    }\n+\n+    final void putCharsAt(byte[] str, int index, int c1, int c2) {\n+        if (coder == LATIN1) {\n+            str[index    ] = (byte) c1;\n+            str[index + 1] = (byte) c2;\n+        } else {\n+            JLA.putCharUTF16(str, index    , c1);\n+            JLA.putCharUTF16(str, index + 1, c2);\n+        }\n+    }\n+\n+    final void putDigit(byte[] str, int index, int d) {\n+        putChar(str, index, (byte) ('0' + d));\n+    }\n+\n+    final void put8Digits(byte[] str, int index, int m) {\n+        \/*\n+         * Left-to-right digits extraction:\n+         * algorithm 1 in [3], with b = 10, k = 8, n = 28.\n+         *\/\n+        if (coder == LATIN1) {\n+            put8DigitsLatin1(str, index, m);\n+        } else {\n+            put8DigitsUTF16 (str, index, m);\n+        }\n+    }\n+\n+    private static void put8DigitsLatin1(byte[] str, int index, int m) {\n+        int y = y(m);\n+        for (int i = 0; i < 8; ++i) {\n+            int t = 10 * y;\n+            str[index + i] = (byte) ('0' + (t >>> 28));\n+            y = t & MASK_28;\n+        }\n+    }\n+\n+    private static void put8DigitsUTF16(byte[] str, int index, int m) {\n+        int y = y(m);\n+        for (int i = 0; i < 8; ++i) {\n+            int t = 10 * y;\n+            JLA.putCharUTF16(str, index + i, '0' + (t >>> 28));\n+            y = t & MASK_28;\n+        }\n+    }\n+\n+    static int y(int a) {\n+        \/*\n+         * Algorithm 1 in [3] needs computation of\n+         *     floor((a + 1) 2^n \/ b^k) - 1\n+         * with a < 10^8, b = 10, k = 8, n = 28.\n+         * Noting that\n+         *     (a + 1) 2^n <= 10^8 2^28 < 10^17\n+         * For n = 17, m = 8 the table in section 10 of [1] leads to:\n+         *\/\n+        return (int) (multiplyHigh(\n+                (long) (a + 1) << 28,\n+                193_428_131_138_340_668L) >>> 20) - 1;\n+    }\n+\n+    final int removeTrailingZeroes(byte[] str, int index) {\n+        if (coder == LATIN1) {\n+            while (str[index - 1] == '0') {\n+                --index;\n+            }\n+            \/* ... but do not remove the one directly to the right of '.' *\/\n+            if (str[index - 1] == '.') {\n+                ++index;\n+            }\n+        } else {\n+            while (JLA.getUTF16Char(str, index - 1) == '0') {\n+                --index;\n+            }\n+            \/* ... but do not remove the one directly to the right of '.' *\/\n+            if (JLA.getUTF16Char(str, index - 1) == '.') {\n+                ++index;\n+            }\n+        }\n+        return index;\n+    }\n+\n+    final int putSpecial(byte[] str, int index, int type) {\n+        String s = special(type);\n+        int length = s.length();\n+        if (coder == LATIN1) {\n+            for (int i = 0; i < length; ++i) {\n+                str[index + i] = (byte) s.charAt(i);\n+            }\n+        } else {\n+            for (int i = 0; i < length; ++i) {\n+                putChar(str, index + i, s.charAt(i));\n+            }\n+        }\n+        return index + length;\n+    }\n+\n+    final int length(byte[] str) {\n+        return str.length >> coder;\n+    }\n+\n+    static String special(int type) {\n+        return switch (type) {\n+            case PLUS_ZERO  -> \"0.0\";\n+            case MINUS_ZERO -> \"-0.0\";\n+            case PLUS_INF   -> \"Infinity\";\n+            case MINUS_INF  -> \"-Infinity\";\n+            default         -> \"NaN\";\n+        };\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/ToDecimal.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -244,11 +244,60 @@\n-    public String toStringCharWithFloat8() {\n-        StringBuilder result = new StringBuilder();\n-        result.append(113.110F);\n-        result.append(156456.36435637F);\n-        result.append(65436434.64632F);\n-        result.append(42654634.64540F);\n-        result.append(63464351.64537F);\n-        result.append(634564.645711F);\n-        result.append(64547.64311F);\n-        result.append(4763456341.64531F);\n-        return result.toString();\n+    public int appendWithFloat8Latin1() {\n+        StringBuilder buf = sbLatin1;\n+        buf.setLength(0);\n+        buf.append(113.110F);\n+        buf.append(156456.36435637F);\n+        buf.append(65436434.64632F);\n+        buf.append(42654634.64540F);\n+        buf.append(63464351.64537F);\n+        buf.append(634564.645711F);\n+        buf.append(64547.64311F);\n+        buf.append(4763456341.64531F);\n+        return buf.length();\n+    }\n+\n+\n+    @Benchmark\n+    public int appendWithFloat8Utf16() {\n+        StringBuilder buf = sbUtf16;\n+        buf.setLength(0);\n+        buf.append(113.110F);\n+        buf.append(156456.36435637F);\n+        buf.append(65436434.64632F);\n+        buf.append(42654634.64540F);\n+        buf.append(63464351.64537F);\n+        buf.append(634564.645711F);\n+        buf.append(64547.64311F);\n+        buf.append(4763456341.64531F);\n+        return buf.length();\n+    }\n+\n+\n+    @Benchmark\n+    public int appendWithDouble8Latin1() {\n+        StringBuilder buf = sbLatin1;\n+        buf.setLength(0);\n+        buf.append(0.3005216476500575D);\n+        buf.append(0.39727691577802204D);\n+        buf.append(0.9869700323149287D);\n+        buf.append(42654634.645403256D);\n+        buf.append(63464351.645371353D);\n+        buf.append(634564.645711246D);\n+        buf.append(64547.6431172363D);\n+        buf.append(4763456341.64531675D);\n+        return buf.length();\n+    }\n+\n+\n+    @Benchmark\n+    public int appendWithDouble8Utf16() {\n+        StringBuilder buf = sbUtf16;\n+        buf.setLength(0);\n+        buf.append(0.3005216476500575D);\n+        buf.append(0.39727691577802204D);\n+        buf.append(0.9869700323149287D);\n+        buf.append(42654634.645403256D);\n+        buf.append(63464351.645371353D);\n+        buf.append(634564.645711246D);\n+        buf.append(64547.6431172363D);\n+        buf.append(4763456341.64531675D);\n+        return buf.length();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringBuilders.java","additions":60,"deletions":11,"binary":false,"changes":71,"status":"modified"}]}