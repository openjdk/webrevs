{"files":[{"patch":"@@ -25,2 +25,1 @@\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n@@ -31,1 +30,1 @@\n-import java.net.Authenticator;\n+import java.net.InetAddress;\n@@ -33,1 +32,0 @@\n-import java.net.PasswordAuthentication;\n@@ -42,1 +40,0 @@\n-import static java.net.InetAddress.getLoopbackAddress;\n@@ -50,1 +47,1 @@\n- * @bug 8343791 8346017\n+ * @bug 8343791\n@@ -52,2 +49,1 @@\n- * @library \/test\/lib \/java\/net\/Socks\n- * @build SocksServer\n+ * @library \/test\/lib\n@@ -65,30 +61,3 @@\n-    private static final String SOCKS_AUTH_USERNAME = \"foo\";\n-\n-    private static final String SOCKS_AUTH_PASSWORD = \"bar\";\n-\n-    private static SocksServer SOCKS_SERVER;\n-\n-    private static Proxy SOCKS_PROXY;\n-\n-    @BeforeAll\n-    static void initAuthenticator() {\n-        Authenticator.setDefault(new Authenticator() {\n-            @Override\n-            protected PasswordAuthentication getPasswordAuthentication() {\n-                return new PasswordAuthentication(SOCKS_AUTH_USERNAME, SOCKS_AUTH_PASSWORD.toCharArray());\n-            }\n-        });\n-    }\n-\n-    @BeforeAll\n-    static void initSocksServer() throws IOException {\n-        SOCKS_SERVER = new SocksServer(0);\n-        SOCKS_SERVER.addUser(SOCKS_AUTH_USERNAME, SOCKS_AUTH_PASSWORD);\n-        SOCKS_SERVER.start();\n-        InetSocketAddress proxyAddress = new InetSocketAddress(getLoopbackAddress(), SOCKS_SERVER.getPort());\n-        SOCKS_PROXY = new Proxy(Proxy.Type.SOCKS, proxyAddress);\n-    }\n-\n-    @AfterAll\n-    static void stopSocksServer() {\n-        SOCKS_SERVER.close();\n+    @Test\n+    void testUnresolvedAddress() {\n+        assertTrue(UNRESOLVED_ADDRESS.isUnresolved());\n@@ -102,2 +71,2 @@\n-    void testUnboundSocket(SocketArg socketArg) throws IOException {\n-        try (Socket socket = socketArg.socket) {\n+    void testUnboundSocket(Socket socket) throws IOException {\n+        try (socket) {\n@@ -116,2 +85,2 @@\n-    void testBoundSocket(SocketArg socketArg) throws IOException {\n-        try (Socket socket = socketArg.socket) {\n+    void testBoundSocket(Socket socket) throws IOException {\n+        try (socket) {\n@@ -131,3 +100,2 @@\n-    void testConnectedSocket(SocketArg socketArg) throws Throwable {\n-        try (Socket socket = socketArg.socket;\n-             ServerSocket serverSocket = createEphemeralServerSocket()) {\n+    void testConnectedSocket(Socket socket) throws Throwable {\n+        try (socket; ServerSocket serverSocket = createEphemeralServerSocket()) {\n@@ -148,1 +116,1 @@\n-     * Delegates to {@link #testUnconnectedSocketWithUnresolvedAddress(boolean, SocketArg)} using an unbound socket.\n+     * Verifies that an unbound socket is closed when {@code connect()} is invoked using an unresolved address.\n@@ -152,2 +120,2 @@\n-    void testUnboundSocketWithUnresolvedAddress(SocketArg socketArg) throws IOException {\n-        try (Socket socket = socketArg.socket) {\n+    void testUnboundSocketWithUnresolvedAddress(Socket socket) throws IOException {\n+        try (socket) {\n@@ -156,1 +124,2 @@\n-            testUnconnectedSocketWithUnresolvedAddress(false, socketArg);\n+            assertThrows(UnknownHostException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+            assertTrue(socket.isClosed());\n@@ -161,1 +130,1 @@\n-     * Delegates to {@link #testUnconnectedSocketWithUnresolvedAddress(boolean, SocketArg)} using a bound socket.\n+     * Verifies that a bound socket is closed when {@code connect()} is invoked using an unresolved address.\n@@ -165,2 +134,2 @@\n-    void testBoundSocketWithUnresolvedAddress(SocketArg socketArg) throws IOException {\n-        try (Socket socket = socketArg.socket) {\n+    void testBoundSocketWithUnresolvedAddress(Socket socket) throws IOException {\n+        try (socket) {\n@@ -168,23 +137,2 @@\n-            testUnconnectedSocketWithUnresolvedAddress(true, socketArg);\n-        }\n-    }\n-\n-    \/**\n-     * Verifies the behaviour of an unconnected socket when {@code connect()} is invoked using an unresolved address.\n-     *\/\n-    private static void testUnconnectedSocketWithUnresolvedAddress(boolean bound, SocketArg socketArg) throws IOException {\n-        Socket socket = socketArg.socket;\n-        assertEquals(bound, socket.isBound());\n-        assertFalse(socket.isConnected());\n-        if (socketArg.proxied) {\n-            try (ServerSocket serverSocket = createEphemeralServerSocket()) {\n-                InetSocketAddress unresolvedAddress =\n-                        InetSocketAddress.createUnresolved(\"localhost\", serverSocket.getLocalPort());\n-                socket.connect(unresolvedAddress);\n-                try (Socket _ = serverSocket.accept()) {\n-                    assertTrue(socket.isBound());\n-                    assertTrue(socket.isConnected());\n-                    assertFalse(socket.isClosed());\n-                }\n-            }\n-        } else {\n+            assertTrue(socket.isBound());\n+            assertFalse(socket.isConnected());\n@@ -201,3 +149,2 @@\n-    void testConnectedSocketWithUnresolvedAddress(SocketArg socketArg) throws Throwable {\n-        try (Socket socket = socketArg.socket;\n-             ServerSocket serverSocket = createEphemeralServerSocket()) {\n+    void testConnectedSocketWithUnresolvedAddress(Socket socket) throws Throwable {\n+        try (socket; ServerSocket serverSocket = createEphemeralServerSocket()) {\n@@ -208,4 +155,1 @@\n-                SocketException exception = assertThrows(\n-                        SocketException.class,\n-                        () -> socket.connect(UNRESOLVED_ADDRESS));\n-                assertEquals(\"Already connected\", exception.getMessage());\n+                assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n@@ -217,1 +161,1 @@\n-    static List<SocketArg> sockets() throws Exception {\n+    static List<Socket> sockets() throws Exception {\n@@ -219,1 +163,0 @@\n-        Socket proxiedSocket = new Socket(SOCKS_PROXY);\n@@ -222,4 +165,2 @@\n-        return List.of(\n-                new SocketArg(socket, false),\n-                new SocketArg(proxiedSocket, true),\n-                new SocketArg(channelSocket, false));\n+        Socket proxiedSocket = new Socket(Proxy.NO_PROXY);\n+        return List.of(socket, channelSocket, proxiedSocket);\n@@ -228,2 +169,0 @@\n-    private record SocketArg(Socket socket, boolean proxied) {}\n-\n@@ -231,1 +170,1 @@\n-        return new ServerSocket(0, 0, getLoopbackAddress());\n+        return new ServerSocket(0, 0, InetAddress.getLoopbackAddress());\n","filename":"test\/jdk\/java\/net\/Socket\/ConnectFailTest.java","additions":30,"deletions":91,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.net.Authenticator;\n+import java.net.InetSocketAddress;\n+import java.net.PasswordAuthentication;\n+import java.net.Proxy;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketException;\n+\n+import static java.net.InetAddress.getLoopbackAddress;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8346017\n+ * @summary Verifies the `connect()` behaviour of a SOCKS proxy socket. In particular, that passing a resolvable\n+ *          unresolved address doesn't throw an exception.\n+ * @library \/test\/lib \/java\/net\/Socks\n+ * @build SocksServer\n+ * @run junit ConnectSocksProxyTest\n+ *\/\n+class ConnectSocksProxyTest {\n+\n+    private static final int DEAD_SERVER_PORT = 0xDEAD;\n+\n+    private static final InetSocketAddress REFUSING_SOCKET_ADDRESS = Utils.refusingEndpoint();\n+\n+    private static final InetSocketAddress UNRESOLVED_ADDRESS =\n+            InetSocketAddress.createUnresolved(\"no.such.host\", DEAD_SERVER_PORT);\n+\n+    private static final String PROXY_AUTH_USERNAME = \"foo\";\n+\n+    private static final String PROXY_AUTH_PASSWORD = \"bar\";\n+\n+    private static SocksServer PROXY_SERVER;\n+\n+    private static Proxy PROXY;\n+\n+    @BeforeAll\n+    static void initAuthenticator() {\n+        Authenticator.setDefault(new Authenticator() {\n+            @Override\n+            protected PasswordAuthentication getPasswordAuthentication() {\n+                return new PasswordAuthentication(PROXY_AUTH_USERNAME, PROXY_AUTH_PASSWORD.toCharArray());\n+            }\n+        });\n+    }\n+\n+    @BeforeAll\n+    static void initProxyServer() throws IOException {\n+        PROXY_SERVER = new SocksServer(0);\n+        PROXY_SERVER.addUser(PROXY_AUTH_USERNAME, PROXY_AUTH_PASSWORD);\n+        PROXY_SERVER.start();\n+        InetSocketAddress proxyAddress = new InetSocketAddress(getLoopbackAddress(), PROXY_SERVER.getPort());\n+        PROXY = new Proxy(Proxy.Type.SOCKS, proxyAddress);\n+    }\n+\n+    @AfterAll\n+    static void stopProxyServer() {\n+        PROXY_SERVER.close();\n+    }\n+\n+    @Test\n+    void testUnresolvedAddress() {\n+        assertTrue(UNRESOLVED_ADDRESS.isUnresolved());\n+    }\n+\n+    \/**\n+     * Verifies that an unbound socket is closed when {@code connect()} fails.\n+     *\/\n+    @Test\n+    void testUnboundSocket() throws IOException {\n+        try (Socket socket = createProxiedSocket()) {\n+            assertFalse(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that a bound socket is closed when {@code connect()} fails.\n+     *\/\n+    @Test\n+    void testBoundSocket() throws IOException {\n+        try (Socket socket = createProxiedSocket()) {\n+            socket.bind(new InetSocketAddress(0));\n+            assertTrue(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that a connected socket is not closed when {@code connect()} fails.\n+     *\/\n+    @Test\n+    void testConnectedSocket() throws Throwable {\n+        try (Socket socket = createProxiedSocket();\n+             ServerSocket serverSocket = createEphemeralServerSocket()) {\n+            socket.connect(serverSocket.getLocalSocketAddress());\n+            try (Socket _ = serverSocket.accept()) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                SocketException exception = assertThrows(\n+                        SocketException.class,\n+                        () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+                assertEquals(\"Already connected\", exception.getMessage());\n+                assertFalse(socket.isClosed());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Delegates to {@link #testUnconnectedSocketWithUnresolvedAddress(boolean, Socket)} using an unbound socket.\n+     *\/\n+    @Test\n+    void testUnboundSocketWithUnresolvedAddress() throws IOException {\n+        try (Socket socket = createProxiedSocket()) {\n+            assertFalse(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            testUnconnectedSocketWithUnresolvedAddress(false, socket);\n+        }\n+    }\n+\n+    \/**\n+     * Delegates to {@link #testUnconnectedSocketWithUnresolvedAddress(boolean, Socket)} using a bound socket.\n+     *\/\n+    @Test\n+    void testBoundSocketWithUnresolvedAddress() throws IOException {\n+        try (Socket socket = createProxiedSocket()) {\n+            socket.bind(new InetSocketAddress(0));\n+            testUnconnectedSocketWithUnresolvedAddress(true, socket);\n+        }\n+    }\n+\n+    \/**\n+     * Verifies the behaviour of an unconnected socket when {@code connect()} is invoked using an unresolved address.\n+     *\/\n+    private static void testUnconnectedSocketWithUnresolvedAddress(boolean bound, Socket socket) throws IOException {\n+        assertEquals(bound, socket.isBound());\n+        assertFalse(socket.isConnected());\n+        try (ServerSocket serverSocket = createEphemeralServerSocket()) {\n+            InetSocketAddress unresolvedAddress =\n+                    InetSocketAddress.createUnresolved(\"localhost\", serverSocket.getLocalPort());\n+            socket.connect(unresolvedAddress);\n+            try (Socket _ = serverSocket.accept()) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                assertFalse(socket.isClosed());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that a connected socket is not closed when {@code connect()} is invoked using an unresolved address.\n+     *\/\n+    @Test\n+    void testConnectedSocketWithUnresolvedAddress() throws Throwable {\n+        try (Socket socket = createProxiedSocket();\n+             ServerSocket serverSocket = createEphemeralServerSocket()) {\n+            socket.connect(serverSocket.getLocalSocketAddress());\n+            try (Socket _ = serverSocket.accept()) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                SocketException exception = assertThrows(\n+                        SocketException.class,\n+                        () -> socket.connect(UNRESOLVED_ADDRESS));\n+                assertEquals(\"Already connected\", exception.getMessage());\n+                assertFalse(socket.isClosed());\n+            }\n+        }\n+    }\n+\n+    private static Socket createProxiedSocket() {\n+        return new Socket(PROXY);\n+    }\n+\n+    private static ServerSocket createEphemeralServerSocket() throws IOException {\n+        return new ServerSocket(0, 0, getLoopbackAddress());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/ConnectSocksProxyTest.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"}]}