{"files":[{"patch":"@@ -572,3 +572,2 @@\n-     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, or the\n-     * connection cannot be established, then the socket is closed, and an\n-     * {@link IOException} is thrown.\n+     * <p> If the connection cannot be established, then the socket is closed,\n+     * and an {@link IOException} is thrown.\n@@ -594,2 +593,2 @@\n-     * @throws  UnknownHostException if the endpoint is an unresolved\n-     *          {@link InetSocketAddress}\n+     * @throws  UnknownHostException if the connection could not be established\n+     *          because the endpoint is an unresolved {@link InetSocketAddress}\n@@ -612,3 +611,2 @@\n-     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, the\n-     * connection cannot be established, or the timeout expires before the\n-     * connection is established, then the socket is closed, and an\n+     * <p> If the connection cannot be established, or the timeout expires\n+     * before the connection is established, then the socket is closed, and an\n@@ -637,2 +635,2 @@\n-     * @throws  UnknownHostException if the endpoint is an unresolved\n-     *          {@link InetSocketAddress}\n+     * @throws  UnknownHostException if the connection could not be established\n+     *          because the endpoint is an unresolved {@link InetSocketAddress}\n@@ -663,6 +661,0 @@\n-        if (epoint.isUnresolved()) {\n-            var uhe = new UnknownHostException(epoint.getHostName());\n-            closeSuppressingExceptions(uhe);\n-            throw uhe;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.net.Proxy;\n@@ -164,1 +165,2 @@\n-        return List.of(socket, channelSocket);\n+        Socket proxiedSocket = new Socket(Proxy.NO_PROXY);\n+        return List.of(socket, channelSocket, proxiedSocket);\n","filename":"test\/jdk\/java\/net\/Socket\/ConnectFailTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.net.Authenticator;\n+import java.net.InetSocketAddress;\n+import java.net.PasswordAuthentication;\n+import java.net.Proxy;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketException;\n+\n+import static java.net.InetAddress.getLoopbackAddress;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8346017\n+ * @summary Verifies the `connect()` behaviour of a SOCKS proxy socket. In particular, that passing a resolvable\n+ *          unresolved address doesn't throw an exception.\n+ * @library \/test\/lib \/java\/net\/Socks\n+ * @build SocksServer\n+ * @run junit ConnectSocksProxyTest\n+ *\/\n+class ConnectSocksProxyTest {\n+\n+    private static final int DEAD_SERVER_PORT = 0xDEAD;\n+\n+    private static final InetSocketAddress REFUSING_SOCKET_ADDRESS = Utils.refusingEndpoint();\n+\n+    private static final InetSocketAddress UNRESOLVED_ADDRESS =\n+            InetSocketAddress.createUnresolved(\"no.such.host\", DEAD_SERVER_PORT);\n+\n+    private static final String PROXY_AUTH_USERNAME = \"foo\";\n+\n+    private static final String PROXY_AUTH_PASSWORD = \"bar\";\n+\n+    private static SocksServer PROXY_SERVER;\n+\n+    private static Proxy PROXY;\n+\n+    @BeforeAll\n+    static void initAuthenticator() {\n+        Authenticator.setDefault(new Authenticator() {\n+            @Override\n+            protected PasswordAuthentication getPasswordAuthentication() {\n+                return new PasswordAuthentication(PROXY_AUTH_USERNAME, PROXY_AUTH_PASSWORD.toCharArray());\n+            }\n+        });\n+    }\n+\n+    @BeforeAll\n+    static void initProxyServer() throws IOException {\n+        PROXY_SERVER = new SocksServer(0);\n+        PROXY_SERVER.addUser(PROXY_AUTH_USERNAME, PROXY_AUTH_PASSWORD);\n+        PROXY_SERVER.start();\n+        InetSocketAddress proxyAddress = new InetSocketAddress(getLoopbackAddress(), PROXY_SERVER.getPort());\n+        PROXY = new Proxy(Proxy.Type.SOCKS, proxyAddress);\n+    }\n+\n+    @AfterAll\n+    static void stopProxyServer() {\n+        PROXY_SERVER.close();\n+    }\n+\n+    @Test\n+    void testUnresolvedAddress() {\n+        assertTrue(UNRESOLVED_ADDRESS.isUnresolved());\n+    }\n+\n+    \/**\n+     * Verifies that an unbound socket is closed when {@code connect()} fails.\n+     *\/\n+    @Test\n+    void testUnboundSocket() throws IOException {\n+        try (Socket socket = createProxiedSocket()) {\n+            assertFalse(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that a bound socket is closed when {@code connect()} fails.\n+     *\/\n+    @Test\n+    void testBoundSocket() throws IOException {\n+        try (Socket socket = createProxiedSocket()) {\n+            socket.bind(new InetSocketAddress(0));\n+            assertTrue(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that a connected socket is not closed when {@code connect()} fails.\n+     *\/\n+    @Test\n+    void testConnectedSocket() throws Throwable {\n+        try (Socket socket = createProxiedSocket();\n+             ServerSocket serverSocket = createEphemeralServerSocket()) {\n+            socket.connect(serverSocket.getLocalSocketAddress());\n+            try (Socket _ = serverSocket.accept()) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                SocketException exception = assertThrows(\n+                        SocketException.class,\n+                        () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+                assertEquals(\"Already connected\", exception.getMessage());\n+                assertFalse(socket.isClosed());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Delegates to {@link #testUnconnectedSocketWithUnresolvedAddress(boolean, Socket)} using an unbound socket.\n+     *\/\n+    @Test\n+    void testUnboundSocketWithUnresolvedAddress() throws IOException {\n+        try (Socket socket = createProxiedSocket()) {\n+            assertFalse(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            testUnconnectedSocketWithUnresolvedAddress(false, socket);\n+        }\n+    }\n+\n+    \/**\n+     * Delegates to {@link #testUnconnectedSocketWithUnresolvedAddress(boolean, Socket)} using a bound socket.\n+     *\/\n+    @Test\n+    void testBoundSocketWithUnresolvedAddress() throws IOException {\n+        try (Socket socket = createProxiedSocket()) {\n+            socket.bind(new InetSocketAddress(0));\n+            testUnconnectedSocketWithUnresolvedAddress(true, socket);\n+        }\n+    }\n+\n+    \/**\n+     * Verifies the behaviour of an unconnected socket when {@code connect()} is invoked using an unresolved address.\n+     *\/\n+    private static void testUnconnectedSocketWithUnresolvedAddress(boolean bound, Socket socket) throws IOException {\n+        assertEquals(bound, socket.isBound());\n+        assertFalse(socket.isConnected());\n+        try (ServerSocket serverSocket = createEphemeralServerSocket()) {\n+            InetSocketAddress unresolvedAddress =\n+                    InetSocketAddress.createUnresolved(\"localhost\", serverSocket.getLocalPort());\n+            socket.connect(unresolvedAddress);\n+            try (Socket _ = serverSocket.accept()) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                assertFalse(socket.isClosed());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that a connected socket is not closed when {@code connect()} is invoked using an unresolved address.\n+     *\/\n+    @Test\n+    void testConnectedSocketWithUnresolvedAddress() throws Throwable {\n+        try (Socket socket = createProxiedSocket();\n+             ServerSocket serverSocket = createEphemeralServerSocket()) {\n+            socket.connect(serverSocket.getLocalSocketAddress());\n+            try (Socket _ = serverSocket.accept()) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                SocketException exception = assertThrows(\n+                        SocketException.class,\n+                        () -> socket.connect(UNRESOLVED_ADDRESS));\n+                assertEquals(\"Already connected\", exception.getMessage());\n+                assertFalse(socket.isClosed());\n+            }\n+        }\n+    }\n+\n+    private static Socket createProxiedSocket() {\n+        return new Socket(PROXY);\n+    }\n+\n+    private static ServerSocket createEphemeralServerSocket() throws IOException {\n+        return new ServerSocket(0, 0, getLoopbackAddress());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/ConnectSocksProxyTest.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"}]}