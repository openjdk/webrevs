{"files":[{"patch":"@@ -42,3 +42,1 @@\n-  \", parent \" PTR_FORMAT \\\n-  \", left \" PTR_FORMAT \\\n-  \", right \" PTR_FORMAT \\\n+  \", tree \" PTR_FORMAT \\\n@@ -51,3 +49,1 @@\n-  p2i((n)->_parent), \\\n-  p2i((n)->_left), \\\n-  p2i((n)->_right), \\\n+  p2i(&(n)->_tree_node), \\\n@@ -77,9 +73,0 @@\n-\/\/ walkinfo keeps a node plus the size corridor it and its children\n-\/\/  are supposed to be in.\n-struct BlockTree::walkinfo {\n-  BlockTree::Node* n;\n-  int depth;\n-  size_t lim1; \/\/ (\n-  size_t lim2; \/\/ )\n-};\n-\n@@ -101,1 +88,0 @@\n-\n@@ -103,10 +89,0 @@\n-  if (_root != nullptr) {\n-\n-    ResourceMark rm;\n-    GrowableArray<walkinfo> stack;\n-\n-    walkinfo info;\n-    info.n = _root;\n-    info.lim1 = 0;\n-    info.lim2 = SIZE_MAX;\n-    info.depth = 0;\n@@ -114,1 +90,4 @@\n-    stack.push(info);\n+  \/\/ Verifies node ordering (n1 < n2 => word_size1 < word_size2),\n+  \/\/ node vadility, and that the tree is balanced and not ill-formed.\n+  _tree.verify_self([&](const TreeNode* tree_node) {\n+    const Node* n = Node::cast_to_node(tree_node);\n@@ -116,3 +95,1 @@\n-    while (stack.length() > 0) {\n-      info = stack.pop();\n-      const Node* n = info.n;\n+    verify_node_pointer(n);\n@@ -120,1 +97,1 @@\n-      verify_node_pointer(n);\n+    counter.add(n->_word_size);\n@@ -122,4 +99,2 @@\n-      \/\/ Assume a (ridiculously large) edge limit to catch cases\n-      \/\/  of badly degenerated or circular trees.\n-      tree_assert(info.depth < 10000, \"too deep (%d)\", info.depth);\n-      counter.add(n->_word_size);\n+    tree_assert_invalid_node(n->_word_size >= MinWordSize, n);\n+    tree_assert_invalid_node(n->_word_size <= chunklevel::MAX_CHUNK_WORD_SIZE, n);\n@@ -127,46 +102,8 @@\n-      if (n == _root) {\n-        tree_assert_invalid_node(n->_parent == nullptr, n);\n-      } else {\n-        tree_assert_invalid_node(n->_parent != nullptr, n);\n-      }\n-\n-      \/\/ check size and ordering\n-      tree_assert_invalid_node(n->_word_size >= MinWordSize, n);\n-      tree_assert_invalid_node(n->_word_size <= chunklevel::MAX_CHUNK_WORD_SIZE, n);\n-      tree_assert_invalid_node(n->_word_size > info.lim1, n);\n-      tree_assert_invalid_node(n->_word_size < info.lim2, n);\n-\n-      \/\/ Check children\n-      if (n->_left != nullptr) {\n-        tree_assert_invalid_node(n->_left != n, n);\n-        tree_assert_invalid_node(n->_left->_parent == n, n);\n-\n-        walkinfo info2;\n-        info2.n = n->_left;\n-        info2.lim1 = info.lim1;\n-        info2.lim2 = n->_word_size;\n-        info2.depth = info.depth + 1;\n-        stack.push(info2);\n-      }\n-\n-      if (n->_right != nullptr) {\n-        tree_assert_invalid_node(n->_right != n, n);\n-        tree_assert_invalid_node(n->_right->_parent == n, n);\n-\n-        walkinfo info2;\n-        info2.n = n->_right;\n-        info2.lim1 = n->_word_size;\n-        info2.lim2 = info.lim2;\n-        info2.depth = info.depth + 1;\n-        stack.push(info2);\n-      }\n-\n-      \/\/ If node has same-sized siblings check those too.\n-      const Node* n2 = n->_next;\n-      while (n2 != nullptr) {\n-        verify_node_pointer(n2);\n-        tree_assert_invalid_node(n2 != n, n2); \/\/ catch simple circles\n-        tree_assert_invalid_node(n2->_word_size == n->_word_size, n2);\n-        counter.add(n2->_word_size);\n-        n2 = n2->_next;\n-      }\n+    \/\/ If node has same-sized siblings check those too.\n+    const Node* n2 = n->_next;\n+    while (n2 != nullptr) {\n+      verify_node_pointer(n2);\n+      tree_assert_invalid_node(n2 != n, n2); \/\/ catch simple circles\n+      tree_assert_invalid_node(n2->_word_size == n->_word_size, n2);\n+      counter.add(n2->_word_size);\n+      n2 = n2->_next;\n@@ -174,1 +111,3 @@\n-  }\n+\n+    return true;\n+  });\n@@ -192,4 +131,4 @@\n-  if (_root != nullptr) {\n-\n-    ResourceMark rm;\n-    GrowableArray<walkinfo> stack;\n+  if (is_empty()) {\n+    st->print_cr(\"<no nodes>\");\n+    return;\n+  }\n@@ -197,3 +136,2 @@\n-    walkinfo info;\n-    info.n = _root;\n-    info.depth = 0;\n+  _tree.print_on(st, [&](outputStream *st, const TreeNode *tree_node, int depth) {\n+    const Node* n = Node::cast_to_node(tree_node);\n@@ -201,4 +139,8 @@\n-    stack.push(info);\n-    while (stack.length() > 0) {\n-      info = stack.pop();\n-      const Node* n = info.n;\n+    \/\/ Print node.\n+    st->print(\"%4d + \", depth);\n+    if (os::is_readable_pointer(n)) {\n+      st->print_cr(NODE_FORMAT, NODE_FORMAT_ARGS(n));\n+    } else {\n+      st->print_cr(\"@\" PTR_FORMAT \": unreadable\", p2i(n));\n+      return;\n+    }\n@@ -206,4 +148,5 @@\n-      \/\/ Print node.\n-      st->print(\"%4d + \", info.depth);\n-      if (os::is_readable_pointer(n)) {\n-        st->print_cr(NODE_FORMAT, NODE_FORMAT_ARGS(n));\n+    \/\/ Print same-sized-nodes stacked under this node\n+    for (Node* n2 = n->_next; n2 != nullptr; n2 = n2->_next) {\n+      st->print_raw(\"       \");\n+      if (os::is_readable_pointer(n2)) {\n+        st->print_cr(NODE_FORMAT, NODE_FORMAT_ARGS(n2));\n@@ -211,33 +154,2 @@\n-        st->print_cr(\"@\" PTR_FORMAT \": unreadable (skipping subtree)\", p2i(n));\n-        continue; \/\/ don't print this subtree\n-      }\n-\n-      \/\/ Print same-sized-nodes stacked under this node\n-      for (Node* n2 = n->_next; n2 != nullptr; n2 = n2->_next) {\n-        st->print_raw(\"       \");\n-        if (os::is_readable_pointer(n2)) {\n-          st->print_cr(NODE_FORMAT, NODE_FORMAT_ARGS(n2));\n-        } else {\n-          st->print_cr(\"@\" PTR_FORMAT \": unreadable (skipping rest of chain).\", p2i(n2));\n-          break; \/\/ stop printing this chain.\n-        }\n-      }\n-\n-      \/\/ Handle simple circularities\n-      if (n == n->_right || n == n->_left || n == n->_next) {\n-        st->print_cr(\"@\" PTR_FORMAT \": circularity detected.\", p2i(n));\n-        return; \/\/ stop printing\n-      }\n-\n-      \/\/ Handle children.\n-      if (n->_right != nullptr) {\n-        walkinfo info2;\n-        info2.n = n->_right;\n-        info2.depth = info.depth + 1;\n-        stack.push(info2);\n-      }\n-      if (n->_left != nullptr) {\n-        walkinfo info2;\n-        info2.n = n->_left;\n-        info2.depth = info.depth + 1;\n-        stack.push(info2);\n+        st->print_cr(\"@\" PTR_FORMAT \": unreadable (skipping rest of chain).\", p2i(n2));\n+        break; \/\/ stop printing this chain.\n@@ -246,4 +158,1 @@\n-\n-  } else {\n-    st->print_cr(\"<no nodes>\");\n-  }\n+  });\n","filename":"src\/hotspot\/share\/memory\/metaspace\/blockTree.cpp","additions":43,"deletions":134,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/rbTree.inline.hpp\"\n@@ -38,2 +39,2 @@\n-\/\/ BlockTree is a rather simple binary search tree. It is used to\n-\/\/  manage medium to large free memory blocks.\n+\/\/ BlockTree is tree built on an intrusive red-black tree.\n+\/\/  It is used to manage medium to large free memory blocks.\n@@ -56,3 +57,3 @@\n-\/\/           +-----+\n-\/\/           | 80  |\n-\/\/           +-----+\n+\/\/           +-----+         +-----+\n+\/\/           | 80  |         | 120 |\n+\/\/           +-----+         +-----+\n@@ -68,7 +69,0 @@\n-\/\/\n-\/\/ Todo: This tree is unbalanced. It would be a good fit for a red-black tree.\n-\/\/  In order to make this a red-black tree, we need an algorithm which can deal\n-\/\/  with nodes which are their own payload (most red-black tree implementations\n-\/\/  swap payloads of their nodes at some point, see e.g. j.u.TreeSet).\n-\/\/ A good example is the Linux kernel rbtree, which is a clean, easy-to-read\n-\/\/  implementation.\n@@ -78,0 +72,2 @@\n+  using TreeNode = IntrusiveRBNode;\n+\n@@ -89,5 +85,2 @@\n-    \/\/ Normal tree node stuff...\n-    \/\/  (Note: all null if this is a stacked node)\n-    Node* _parent;\n-    Node* _left;\n-    Node* _right;\n+    \/\/ Tree node for linking blocks in the intrusive tree.\n+    TreeNode _tree_node;\n@@ -105,3 +98,1 @@\n-      _parent(nullptr),\n-      _left(nullptr),\n-      _right(nullptr),\n+      _tree_node{},\n@@ -112,0 +103,4 @@\n+    static Node* cast_to_node(const TreeNode* tree_node) {\n+      return (Node*)((uintptr_t)tree_node - offset_of(Node, _tree_node));\n+    }\n+\n@@ -121,2 +116,17 @@\n-  \/\/ Needed for verify() and print_tree()\n-  struct walkinfo;\n+  struct TreeComparator {\n+    static RBTreeOrdering cmp(const size_t a, const TreeNode* b) {\n+      const size_t node_word_size = Node::cast_to_node(b)->_word_size;\n+\n+      if (a < node_word_size) { return RBTreeOrdering::LT; }\n+      if (a > node_word_size) { return RBTreeOrdering::GT; }\n+      return RBTreeOrdering::EQ;\n+    }\n+\n+    static bool less_than(const TreeNode* a, const TreeNode* b) {\n+      const size_t a_word_size = Node::cast_to_node(a)->_word_size;\n+      const size_t b_word_size = Node::cast_to_node(b)->_word_size;\n+\n+      if (a_word_size < b_word_size) { return true; }\n+      return false;\n+    }\n+  };\n@@ -137,1 +147,1 @@\n-  Node* _root;\n+  IntrusiveRBTree<const size_t, TreeComparator> _tree;\n@@ -146,1 +156,1 @@\n-    DEBUG_ONLY(n->_left = n->_right = n->_parent = nullptr;)\n+    DEBUG_ONLY(n->_tree_node = TreeNode());\n@@ -160,177 +170,0 @@\n-  \/\/ Given a node c and a node p, wire up c as left child of p.\n-  static void set_left_child(Node* p, Node* c) {\n-    p->_left = c;\n-    if (c != nullptr) {\n-      assert(c->_word_size < p->_word_size, \"sanity\");\n-      c->_parent = p;\n-    }\n-  }\n-\n-  \/\/ Given a node c and a node p, wire up c as right child of p.\n-  static void set_right_child(Node* p, Node* c) {\n-    p->_right = c;\n-    if (c != nullptr) {\n-      assert(c->_word_size > p->_word_size, \"sanity\");\n-      c->_parent = p;\n-    }\n-  }\n-\n-  \/\/ Given a node n, return its successor in the tree\n-  \/\/ (node with the next-larger size).\n-  static Node* successor(Node* n) {\n-    Node* succ = nullptr;\n-    if (n->_right != nullptr) {\n-      \/\/ If there is a right child, search the left-most\n-      \/\/ child of that child.\n-      succ = n->_right;\n-      while (succ->_left != nullptr) {\n-        succ = succ->_left;\n-      }\n-    } else {\n-      succ = n->_parent;\n-      Node* n2 = n;\n-      \/\/ As long as I am the right child of my parent, search upward\n-      while (succ != nullptr && n2 == succ->_right) {\n-        n2 = succ;\n-        succ = succ->_parent;\n-      }\n-    }\n-    return succ;\n-  }\n-\n-  \/\/ Given a node, replace it with a replacement node as a child for its parent.\n-  \/\/ If the node is root and has no parent, sets it as root.\n-  void replace_node_in_parent(Node* child, Node* replace) {\n-    Node* parent = child->_parent;\n-    if (parent != nullptr) {\n-      if (parent->_left == child) { \/\/ Child is left child\n-        set_left_child(parent, replace);\n-      } else {\n-        set_right_child(parent, replace);\n-      }\n-    } else {\n-      assert(child == _root, \"must be root\");\n-      _root = replace;\n-      if (replace != nullptr) {\n-        replace->_parent = nullptr;\n-      }\n-    }\n-    return;\n-  }\n-\n-  \/\/ Given a node n and an insertion point, insert n under insertion point.\n-  void insert(Node* insertion_point, Node* n) {\n-    assert(n->_parent == nullptr, \"Sanity\");\n-    for (;;) {\n-      DEBUG_ONLY(check_node(insertion_point);)\n-      if (n->_word_size == insertion_point->_word_size) {\n-        add_to_list(n, insertion_point); \/\/ parent stays null in this case.\n-        break;\n-      } else if (n->_word_size > insertion_point->_word_size) {\n-        if (insertion_point->_right == nullptr) {\n-          set_right_child(insertion_point, n);\n-          break;\n-        } else {\n-          insertion_point = insertion_point->_right;\n-        }\n-      } else {\n-        if (insertion_point->_left == nullptr) {\n-          set_left_child(insertion_point, n);\n-          break;\n-        } else {\n-          insertion_point = insertion_point->_left;\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Given a node and a wish size, search this node and all children for\n-  \/\/ the node closest (equal or larger sized) to the size s.\n-  Node* find_closest_fit(Node* n, size_t s) {\n-    Node* best_match = nullptr;\n-    while (n != nullptr) {\n-      DEBUG_ONLY(check_node(n);)\n-      if (n->_word_size >= s) {\n-        best_match = n;\n-        if (n->_word_size == s) {\n-          break; \/\/ perfect match or max depth reached\n-        }\n-        n = n->_left;\n-      } else {\n-        n = n->_right;\n-      }\n-    }\n-    return best_match;\n-  }\n-\n-  \/\/ Given a wish size, search the whole tree for a\n-  \/\/ node closest (equal or larger sized) to the size s.\n-  Node* find_closest_fit(size_t s) {\n-    if (_root != nullptr) {\n-      return find_closest_fit(_root, s);\n-    }\n-    return nullptr;\n-  }\n-\n-  \/\/ Given a node n, remove it from the tree and repair tree.\n-  void remove_node_from_tree(Node* n) {\n-    assert(n->_next == nullptr, \"do not delete a node which has a non-empty list\");\n-\n-    if (n->_left == nullptr && n->_right == nullptr) {\n-      replace_node_in_parent(n, nullptr);\n-\n-    } else if (n->_left == nullptr && n->_right != nullptr) {\n-      replace_node_in_parent(n, n->_right);\n-\n-    } else if (n->_left != nullptr && n->_right == nullptr) {\n-      replace_node_in_parent(n, n->_left);\n-\n-    } else {\n-      \/\/ Node has two children.\n-\n-      \/\/ 1) Find direct successor (the next larger node).\n-      Node* succ = successor(n);\n-\n-      \/\/ There has to be a successor since n->right was != null...\n-      assert(succ != nullptr, \"must be\");\n-\n-      \/\/ ... and it should not have a left child since successor\n-      \/\/     is supposed to be the next larger node, so it must be the mostleft node\n-      \/\/     in the sub tree rooted at n->right\n-      assert(succ->_left == nullptr, \"must be\");\n-      assert(succ->_word_size > n->_word_size, \"sanity\");\n-\n-      Node* successor_parent = succ->_parent;\n-      Node* successor_right_child = succ->_right;\n-\n-      \/\/ Remove successor from its parent.\n-      if (successor_parent == n) {\n-\n-        \/\/ special case: successor is a direct child of n. Has to be the right child then.\n-        assert(n->_right == succ, \"sanity\");\n-\n-        \/\/ Just replace n with this successor.\n-        replace_node_in_parent(n, succ);\n-\n-        \/\/ Take over n's old left child, too.\n-        \/\/ We keep the successor's right child.\n-        set_left_child(succ, n->_left);\n-      } else {\n-        \/\/ If the successors parent is not n, we are deeper in the tree,\n-        \/\/  the successor has to be the left child of its parent.\n-        assert(successor_parent->_left == succ, \"sanity\");\n-\n-        \/\/ The right child of the successor (if there was one) replaces\n-        \/\/  the successor at its parent's left child.\n-        set_left_child(successor_parent, succ->_right);\n-\n-        \/\/ and the successor replaces n at its parent\n-        replace_node_in_parent(n, succ);\n-\n-        \/\/ and takes over n's old children\n-        set_left_child(succ, n->_left);\n-        set_right_child(succ, n->_right);\n-      }\n-    }\n-  }\n-\n@@ -345,1 +178,1 @@\n-  BlockTree() : _root(nullptr) {}\n+  BlockTree() {}\n@@ -353,4 +186,6 @@\n-    if (_root == nullptr) {\n-      _root = n;\n-    } else {\n-      insert(_root, n);\n+    IntrusiveRBTree<const size_t, TreeComparator>::Cursor cursor = _tree.cursor(word_size);\n+    if (cursor.found()) {\n+      add_to_list(n, Node::cast_to_node(cursor.node()));\n+    }\n+    else {\n+      _tree.insert_at_cursor(&n->_tree_node, cursor);\n@@ -367,1 +202,1 @@\n-    Node* n = find_closest_fit(word_size);\n+    TreeNode* tree_node = _tree.closest_ge(word_size);\n@@ -369,1 +204,2 @@\n-    if (n != nullptr) {\n+    if (tree_node != nullptr) {\n+      Node* n = Node::cast_to_node(tree_node);\n@@ -380,1 +216,1 @@\n-        remove_node_from_tree(n);\n+        _tree.remove(tree_node);\n@@ -398,1 +234,1 @@\n-  bool is_empty() const { return _root == nullptr; }\n+  bool is_empty() const { return _tree.size() == 0; }\n","filename":"src\/hotspot\/share\/memory\/metaspace\/blockTree.hpp","additions":46,"deletions":210,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-  ASSERT_LE(BlockTree::MinWordSize, (size_t)6); \/\/ Sanity check. Adjust if Node is changed.\n+  ASSERT_LE(BlockTree::MinWordSize, (size_t)7); \/\/ Sanity check. Adjust if Node is changed.\n","filename":"test\/hotspot\/gtest\/metaspace\/test_blocktree.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}