{"files":[{"patch":"@@ -1104,6 +1104,3 @@\n-      SuperWord sw(phase);\n-      sw.transform_loop(this, false);\n-\n-      \/\/ If the loop is slp canonical analyze it\n-      if (sw.early_return() == false) {\n-        sw.unrolling_analysis(_local_loop_unroll_factor);\n+      VLoop vloop(this, true);\n+      if (vloop.check_preconditions()) {\n+        SuperWord::unrolling_analysis(vloop, _local_loop_unroll_factor);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"opto\/superword.hpp\"\n@@ -4866,1 +4865,1 @@\n-  \/\/ Convert scalar to superword operations at the end of all loop opts.\n+  \/\/ Auto-vectorize main-loop\n@@ -4868,2 +4867,1 @@\n-    \/\/ SuperWord transform\n-    SuperWord sw(this);\n+    ResourceArea autovectorization_arena;\n@@ -4872,13 +4870,1 @@\n-      if (lpt->is_counted()) {\n-        CountedLoopNode *cl = lpt->_head->as_CountedLoop();\n-        if (cl->is_main_loop()) {\n-          if (!sw.transform_loop(lpt, true)) {\n-            \/\/ Instigate more unrolling for optimization when vectorization fails.\n-            if (cl->has_passed_slp()) {\n-              C->set_major_progress();\n-              cl->set_notpassed_slp();\n-              cl->mark_do_unroll_only();\n-            }\n-          }\n-        }\n-      }\n+      autovectorize(lpt, &autovectorization_arena);\n@@ -4888,1 +4874,1 @@\n-  \/\/ Move UnorderedReduction out of counted loop. Can be introduced by SuperWord.\n+  \/\/ Move UnorderedReduction out of counted loop. Can be introduced by AutoVectorization.\n@@ -5965,24 +5951,0 @@\n-  CountedLoopNode* CountedLoopNode::pre_loop_head() const {\n-    assert(is_main_loop(), \"Only main loop has pre loop\");\n-    assert(_pre_loop_end != nullptr && _pre_loop_end->loopnode() != nullptr,\n-           \"should find head from pre loop end\");\n-    return _pre_loop_end->loopnode();\n-  }\n-\n-  CountedLoopEndNode* CountedLoopNode::pre_loop_end() {\n-#ifdef ASSERT\n-    assert(is_main_loop(), \"Only main loop has pre loop\");\n-    assert(_pre_loop_end != nullptr, \"should be set when fetched\");\n-    Node* found_pre_end = find_pre_loop_end();\n-    assert(_pre_loop_end == found_pre_end && _pre_loop_end == pre_loop_head()->loopexit(),\n-           \"should find the pre loop end and must be the same result\");\n-#endif\n-    return _pre_loop_end;\n-  }\n-\n-  void CountedLoopNode::set_pre_loop_end(CountedLoopEndNode* pre_loop_end) {\n-    assert(is_main_loop(), \"Only main loop has pre loop\");\n-    assert(pre_loop_end, \"must be valid\");\n-    _pre_loop_end = pre_loop_end;\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":4,"deletions":42,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -234,3 +234,0 @@\n-  \/\/ Cached CountedLoopEndNode of pre loop for main loops\n-  CountedLoopEndNode* _pre_loop_end;\n-\n@@ -241,1 +238,1 @@\n-      _slp_maximum_unroll_factor(0), _pre_loop_end(nullptr) {\n+      _slp_maximum_unroll_factor(0) {\n@@ -333,3 +330,0 @@\n-  CountedLoopNode* pre_loop_head() const;\n-  CountedLoopEndNode* pre_loop_end();\n-  void set_pre_loop_end(CountedLoopEndNode* pre_loop_end);\n@@ -1440,0 +1434,3 @@\n+  \/\/ Apply autovectorization if possible\n+  bool autovectorize(IdealLoopTree* lpt, ResourceArea* arena);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"opto\/superword.hpp\"\n@@ -4212,0 +4213,28 @@\n+bool PhaseIdealLoop::autovectorize(IdealLoopTree* lpt, ResourceArea* arena) {\n+  \/\/ Counted loop only\n+  if (!lpt->is_counted()) { return false; }\n+  CountedLoopNode* cl = lpt->_head->as_CountedLoop();\n+\n+  \/\/ Main-loop only\n+  if (!cl->is_main_loop()) { return false; }\n+\n+  VLoop vloop(lpt, false);\n+  if (vloop.check_preconditions()) {\n+    \/\/ Ensure that all data structures from autovectorization are deallocated later.\n+    ResourceMark rm(arena);\n+    SuperWord sw(arena, vloop);\n+    if (sw.transform_loop()) {\n+      return true;\n+    }\n+  }\n+\n+  \/\/ This counted main-loop either failed preconditions,\n+  \/\/ or in SuperWord. From now on only unroll the loop.\n+  if (cl->has_passed_slp()) {\n+    C->set_major_progress();\n+    cl->set_notpassed_slp();\n+    cl->mark_do_unroll_only();\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -41,17 +41,11 @@\n-\/\/\n-\/\/                  S U P E R W O R D   T R A N S F O R M\n-\/\/=============================================================================\n-\n-\/\/------------------------------SuperWord---------------------------\n-SuperWord::SuperWord(PhaseIdealLoop* phase) :\n-  _phase(phase),\n-  _arena(phase->C->comp_arena()),\n-  _igvn(phase->_igvn),\n-  _packset(arena(), 8,  0, nullptr),                        \/\/ packs for the current block\n-  _bb_idx(arena(), (int)(1.10 * phase->C->unique()), 0, 0), \/\/ node idx to index in bb\n-  _block(arena(), 8,  0, nullptr),                          \/\/ nodes in current block\n-  _data_entry(arena(), 8,  0, nullptr),                     \/\/ nodes with all inputs from outside\n-  _mem_slice_head(arena(), 8,  0, nullptr),                 \/\/ memory slice heads\n-  _mem_slice_tail(arena(), 8,  0, nullptr),                 \/\/ memory slice tails\n-  _node_info(arena(), 8,  0, SWNodeInfo::initial),          \/\/ info needed per node\n-  _clone_map(phase->C->clone_map()),                        \/\/ map of nodes created in cloning\n+SuperWord::SuperWord(Arena* arena, const VLoop &vloop) :\n+  _vloop(vloop),\n+  _arena(arena),\n+  _packset(arena, 8,  0, nullptr),                          \/\/ packs for the current block\n+  _bb_idx(arena, vloop.estimated_node_count(), 0, 0),       \/\/ node idx to index in bb\n+  _block(arena, vloop.estimated_body_length(), 0, nullptr), \/\/ nodes in current block\n+  _data_entry(arena, 8,  0, nullptr),                       \/\/ nodes with all inputs from outside\n+  _mem_slice_head(arena, 8,  0, nullptr),                   \/\/ memory slice heads\n+  _mem_slice_tail(arena, 8,  0, nullptr),                   \/\/ memory slice tails\n+  _node_info(arena, vloop.estimated_body_length(), 0, SWNodeInfo::initial), \/\/ info needed per node\n+  _clone_map(phase()->C->clone_map()),                      \/\/ map of nodes created in cloning\n@@ -59,7 +53,3 @@\n-  _dg(_arena),                                              \/\/ dependence graph\n-  _nlist(arena(), 8, 0, nullptr),                           \/\/ scratch list of nodes\n-  _lpt(nullptr),                                            \/\/ loop tree node\n-  _lp(nullptr),                                             \/\/ CountedLoopNode\n-  _loop_reductions(arena()),                                \/\/ reduction nodes in the current loop\n-  _bb(nullptr),                                             \/\/ basic block\n-  _iv(nullptr),                                             \/\/ induction var\n+  _dg(arena),                                               \/\/ dependence graph\n+  _nlist(arena, vloop.estimated_body_length(), 0, nullptr), \/\/ scratch list of nodes\n+  _loop_reductions(arena),                                  \/\/ reduction nodes in the current loop\n@@ -67,2 +57,1 @@\n-  _early_return(true),                                      \/\/ analysis evaluations routine\n-  _do_vector_loop(phase->C->do_vector_loop()),              \/\/ whether to do vectorization\/simd style\n+  _do_vector_loop(phase()->C->do_vector_loop()),            \/\/ whether to do vectorization\/simd style\n@@ -74,84 +63,5 @@\n-\/\/------------------------------transform_loop---------------------------\n-bool SuperWord::transform_loop(IdealLoopTree* lpt, bool do_optimization) {\n-  assert(_phase->C->do_superword(), \"SuperWord option should be enabled\");\n-  \/\/ SuperWord only works with power of two vector sizes.\n-  int vector_width = Matcher::vector_width_in_bytes(T_BYTE);\n-  if (vector_width < 2 || !is_power_of_2(vector_width)) {\n-    return false;\n-  }\n-\n-  assert(lpt->_head->is_CountedLoop(), \"must be\");\n-  CountedLoopNode *cl = lpt->_head->as_CountedLoop();\n-\n-  if (!cl->is_valid_counted_loop(T_INT)) {\n-    return false; \/\/ skip malformed counted loop\n-  }\n-\n-  \/\/ Initialize simple data used by reduction marking early.\n-  set_lpt(lpt);\n-  set_lp(cl);\n-  \/\/ For now, define one block which is the entire loop body.\n-  set_bb(cl);\n-\n-  if (SuperWordReductions) {\n-    mark_reductions();\n-  }\n-\n-  \/\/ skip any loop that has not been assigned max unroll by analysis\n-  if (do_optimization) {\n-    if (SuperWordLoopUnrollAnalysis && cl->slp_max_unroll() == 0) {\n-      return false;\n-    }\n-  }\n-\n-  \/\/ Check for no control flow in body (other than exit)\n-  Node *cl_exit = cl->loopexit();\n-  if (cl->is_main_loop() && (cl_exit->in(0) != lpt->_head)) {\n-    #ifndef PRODUCT\n-      if (is_trace_superword_precondition()) {\n-        tty->print_cr(\"SuperWord::transform_loop: loop too complicated, cl_exit->in(0) != lpt->_head\");\n-        tty->print(\"cl_exit %d\", cl_exit->_idx); cl_exit->dump();\n-        tty->print(\"cl_exit->in(0) %d\", cl_exit->in(0)->_idx); cl_exit->in(0)->dump();\n-        tty->print(\"lpt->_head %d\", lpt->_head->_idx); lpt->_head->dump();\n-        lpt->dump_head();\n-      }\n-    #endif\n-    return false;\n-  }\n-\n-  \/\/ Make sure the are no extra control users of the loop backedge\n-  if (cl->back_control()->outcnt() != 1) {\n-    return false;\n-  }\n-\n-  \/\/ Skip any loops already optimized by slp\n-  if (cl->is_vectorized_loop()) {\n-    return false;\n-  }\n-\n-  if (cl->is_unroll_only()) {\n-    return false;\n-  }\n-\n-  if (cl->is_main_loop()) {\n-    \/\/ Check for pre-loop ending with CountedLoopEnd(Bool(Cmp(x,Opaque1(limit))))\n-    CountedLoopEndNode* pre_end = cl->find_pre_loop_end();\n-    if (pre_end == nullptr) {\n-      return false;\n-    }\n-    Node* pre_opaq1 = pre_end->limit();\n-    if (pre_opaq1->Opcode() != Op_Opaque1) {\n-      return false;\n-    }\n-    cl->set_pre_loop_end(pre_end);\n-  }\n-\n-  init(); \/\/ initialize data structures\n-\n-  bool success = true;\n-  if (do_optimization) {\n-    assert(_packset.length() == 0, \"packset must be empty\");\n-    success = SLP_extract();\n-  }\n-  return success;\n-}\n+void SuperWord::unrolling_analysis(const VLoop &vloop, int &local_loop_unroll_factor) {\n+  IdealLoopTree* lpt    = vloop.lpt();\n+  CountedLoopNode* cl   = vloop.cl();\n+  Node* cl_exit         = vloop.cl_exit();\n+  PhaseIdealLoop* phase = vloop.phase();\n@@ -159,2 +69,0 @@\n-\/\/------------------------------early unrolling analysis------------------------------\n-void SuperWord::unrolling_analysis(int &local_loop_unroll_factor) {\n@@ -162,1 +70,1 @@\n-  size_t ignored_size = lpt()->_body.size();\n+  size_t ignored_size = lpt->_body.size();\n@@ -165,2 +73,0 @@\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  Node *cl_exit = cl->loopexit_or_null();\n@@ -169,1 +75,1 @@\n-  for (uint i = 0; i < lpt()->_body.size(); i++) {\n+  for (uint i = 0; i < lpt->_body.size(); i++) {\n@@ -177,2 +83,2 @@\n-  for (uint i = 0; i < lpt()->_body.size(); i++) {\n-    Node* n = lpt()->_body.at(i);\n+  for (uint i = 0; i < lpt->_body.size(); i++) {\n+    Node* n = lpt->_body.at(i);\n@@ -193,1 +99,1 @@\n-        if (lpt()->is_loop_exit(iff)) {\n+        if (lpt->is_loop_exit(iff)) {\n@@ -237,1 +143,1 @@\n-      Node* n_ctrl = _phase->get_ctrl(adr);\n+      Node* n_ctrl = phase->get_ctrl(adr);\n@@ -240,1 +146,1 @@\n-      if (n_ctrl != nullptr && lpt()->is_member(_phase->get_loop(n_ctrl))) {\n+      if (n_ctrl != nullptr && lpt->is_member(phase->get_loop(n_ctrl))) {\n@@ -248,1 +154,1 @@\n-          VPointer p1(current, phase(), lpt(), &nstack, true);\n+          VPointer p1(current, vloop, &nstack);\n@@ -255,2 +161,2 @@\n-          for (uint j = 0; j < lpt()->_body.size(); j++) {\n-            Node* cur_node = lpt()->_body.at(j);\n+          for (uint j = 0; j < lpt->_body.size(); j++) {\n+            Node* cur_node = lpt->_body.at(j);\n@@ -273,1 +179,1 @@\n-    for (uint i = 0; i < lpt()->_body.size(); i++) {\n+    for (uint i = 0; i < lpt->_body.size(); i++) {\n@@ -277,1 +183,1 @@\n-      Node* n = lpt()->_body.at(i);\n+      Node* n = lpt->_body.at(i);\n@@ -317,1 +223,1 @@\n-              if (!in->is_Mem() && in_bb(in) && in->bottom_type()->basic_type() == T_INT) {\n+              if (!in->is_Mem() && vloop.in_bb(in) && in->bottom_type()->basic_type() == T_INT) {\n@@ -321,1 +227,1 @@\n-                  if (!in_bb(use) && use->bottom_type()->basic_type() != bt) {\n+                  if (!vloop.in_bb(use) && use->bottom_type()->basic_type() != bt) {\n@@ -407,2 +313,2 @@\n-  for (DUIterator_Fast imax, i = lp()->fast_outs(imax); i < imax; i++) {\n-    const Node* phi = lp()->fast_out(i);\n+  for (DUIterator_Fast imax, i = cl()->fast_outs(imax); i < imax; i++) {\n+    const Node* phi = cl()->fast_out(i);\n@@ -486,0 +392,38 @@\n+bool SuperWord::transform_loop() {\n+  assert(phase()->C->do_superword(), \"SuperWord option should be enabled\");\n+  assert(cl()->is_main_loop(), \"SLP should only work on main loops\");\n+#ifndef PRODUCT\n+  if (is_trace_superword_any()) {\n+    tty->print_cr(\"\\nSuperWord::transform_loop:\");\n+    lpt()->dump_head();\n+    cl()->dump();\n+  }\n+#endif\n+\n+  \/\/ Skip any loop that has not been assigned max unroll by analysis\n+  if (SuperWordLoopUnrollAnalysis && vloop().cl()->slp_max_unroll() == 0) {\n+#ifndef PRODUCT\n+    if (is_trace_superword_any()) {\n+      tty->print_cr(\"\\nSuperWord::transform_loop failed: slp max unroll analysis was not already done\");\n+    }\n+#endif\n+    return false;\n+  }\n+\n+  if (!SLP_extract()) {\n+#ifndef PRODUCT\n+    if (is_trace_superword_any()) {\n+      tty->print_cr(\"\\nSuperWord::transform_loop failed: SuperWord::SLP_extract did not vectorize\");\n+    }\n+#endif\n+    return false;\n+  }\n+\n+#ifndef PRODUCT\n+  if (is_trace_superword_any()) {\n+    tty->print_cr(\"\\nSuperWord::transform_loop: success\");\n+  }\n+#endif\n+  return true;\n+}\n+\n@@ -521,2 +465,5 @@\n-  CountedLoopNode* cl = lpt()->_head->as_CountedLoop();\n-  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n+  assert(cl()->is_main_loop(), \"SLP should only work on main loops\");\n+\n+  if (SuperWordReductions) {\n+    mark_reductions();\n+  }\n@@ -610,1 +557,1 @@\n-    VPointer align_to_ref_p(mem_ref, phase(), lpt(), nullptr, false);\n+    VPointer align_to_ref_p(mem_ref, vloop());\n@@ -616,1 +563,1 @@\n-        VPointer p2(s, phase(), lpt(), nullptr, false);\n+        VPointer p2(s, vloop());\n@@ -675,1 +622,1 @@\n-    VPointer p1(s1, phase(), lpt(), nullptr, false);\n+    VPointer p1(s1, vloop());\n@@ -679,1 +626,1 @@\n-        VPointer p2(s2, phase(), lpt(), nullptr, false);\n+        VPointer p2(s2, vloop());\n@@ -700,1 +647,1 @@\n-      VPointer p(s, phase(), lpt(), nullptr, false);\n+      VPointer p(s, vloop());\n@@ -723,1 +670,1 @@\n-        VPointer p(s, phase(), lpt(), nullptr, false);\n+        VPointer p(s, vloop());\n@@ -796,1 +743,1 @@\n-  VPointer align_to_ref_p(mem_ref, phase(), lpt(), nullptr, false);\n+  VPointer align_to_ref_p(mem_ref, vloop());\n@@ -865,1 +812,1 @@\n-      VPointer p1(s1->as_Mem(), phase(), lpt(), nullptr, false);\n+      VPointer p1(s1->as_Mem(), vloop());\n@@ -871,1 +818,1 @@\n-        VPointer p2(s2->as_Mem(), phase(), lpt(), nullptr, false);\n+        VPointer p2(s2->as_Mem(), vloop());\n@@ -1011,2 +958,2 @@\n-  VPointer p1(s1->as_Mem(), phase(), lpt(), nullptr, false);\n-  VPointer p2(s2->as_Mem(), phase(), lpt(), nullptr, false);\n+  VPointer p1(s1->as_Mem(), vloop());\n+  VPointer p2(s2->as_Mem(), vloop());\n@@ -1303,1 +1250,1 @@\n-      if (t2->Opcode() == Op_AddI && t2 == _lp->as_CountedLoop()->incr()) continue; \/\/ don't mess with the iv\n+      if (t2->Opcode() == Op_AddI && t2 == cl()->incr()) continue; \/\/ don't mess with the iv\n@@ -1602,2 +1549,2 @@\n-  VPointer mem_ref_p(mem_ref, phase(), lpt(), nullptr, false);\n-  const CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n+  VPointer mem_ref_p(mem_ref, vloop());\n+  const CountedLoopEndNode* pre_end = vloop().pre_loop_end();\n@@ -1922,2 +1869,2 @@\n-                ((use->is_Phi() && use->in(0) == _lpt->_head) ||\n-                 (!_lpt->is_member(_phase->get_loop(_phase->ctrl_or_self(use))) && i == p->size()-1))) {\n+                ((use->is_Phi() && use->in(0) == lpt()->_head) ||\n+                 (!lpt()->is_member(phase()->get_loop(phase()->ctrl_or_self(use))) && i == p->size()-1))) {\n@@ -2278,1 +2225,1 @@\n-  _phase->C->print_method(PHASE_SUPERWORD1_BEFORE_SCHEDULE, 4, cl);\n+  phase()->C->print_method(PHASE_SUPERWORD1_BEFORE_SCHEDULE, 4, cl);\n@@ -2288,1 +2235,1 @@\n-  int max_slices = _phase->C->num_alias_types();\n+  int max_slices = phase()->C->num_alias_types();\n@@ -2300,1 +2247,1 @@\n-    int alias_idx = _phase->C->get_alias_index(phi->adr_type());\n+    int alias_idx = phase()->C->get_alias_index(phi->adr_type());\n@@ -2313,1 +2260,1 @@\n-    int alias_idx = _phase->C->get_alias_index(n->adr_type());\n+    int alias_idx = phase()->C->get_alias_index(n->adr_type());\n@@ -2322,1 +2269,1 @@\n-      _igvn.replace_input_of(n, MemNode::Memory, current_state);\n+      igvn().replace_input_of(n, MemNode::Memory, current_state);\n@@ -2335,1 +2282,1 @@\n-    int alias_idx = _phase->C->get_alias_index(phi->adr_type());\n+    int alias_idx = phase()->C->get_alias_index(phi->adr_type());\n@@ -2340,1 +2287,1 @@\n-    _igvn.replace_input_of(phi, 2, current_state);\n+    igvn().replace_input_of(phi, 2, current_state);\n@@ -2359,1 +2306,1 @@\n-          _igvn.replace_input_of(use, j, current_state);\n+          igvn().replace_input_of(use, j, current_state);\n@@ -2376,1 +2323,1 @@\n-  Compile* C = _phase->C;\n+  Compile* C = phase()->C;\n@@ -2387,1 +2334,1 @@\n-  _phase->C->print_method(PHASE_SUPERWORD2_BEFORE_OUTPUT, 4, cl);\n+  phase()->C->print_method(PHASE_SUPERWORD2_BEFORE_OUTPUT, 4, cl);\n@@ -2415,1 +2362,1 @@\n-          VPointer p_store(mem->as_Mem(), phase(), lpt(), nullptr, false);\n+          VPointer p_store(mem->as_Mem(), vloop());\n@@ -2549,1 +2496,1 @@\n-        ConINode* bol_test_node  = _igvn.intcon((int)bol_test);\n+        ConINode* bol_test_node  = igvn().intcon((int)bol_test);\n@@ -2553,3 +2500,3 @@\n-        _igvn.register_new_node_with_optimizer(mask);\n-        _phase->set_ctrl(mask, _phase->get_ctrl(p->at(0)));\n-        _igvn._worklist.push(mask);\n+        igvn().register_new_node_with_optimizer(mask);\n+        phase()->set_ctrl(mask, phase()->get_ctrl(p->at(0)));\n+        igvn()._worklist.push(mask);\n@@ -2628,2 +2575,2 @@\n-        _igvn.register_new_node_with_optimizer(longval);\n-        _phase->set_ctrl(longval, _phase->get_ctrl(first));\n+        igvn().register_new_node_with_optimizer(longval);\n+        phase()->set_ctrl(longval, phase()->get_ctrl(first));\n@@ -2670,2 +2617,2 @@\n-      _igvn.register_new_node_with_optimizer(vn);\n-      _phase->set_ctrl(vn, _phase->get_ctrl(first));\n+      igvn().register_new_node_with_optimizer(vn);\n+      phase()->set_ctrl(vn, phase()->get_ctrl(first));\n@@ -2674,1 +2621,1 @@\n-        _igvn.replace_node(pm, vn);\n+        igvn().replace_node(pm, vn);\n@@ -2676,1 +2623,1 @@\n-      _igvn._worklist.push(vn);\n+      igvn()._worklist.push(vn);\n@@ -2715,1 +2662,1 @@\n-  _phase->C->print_method(PHASE_SUPERWORD3_AFTER_OUTPUT, 4, cl);\n+  phase()->C->print_method(PHASE_SUPERWORD3_AFTER_OUTPUT, 4, cl);\n@@ -2738,1 +2685,1 @@\n-    Node* vn = new PopulateIndexNode(iv(), _igvn.intcon(1), vt);\n+    Node* vn = new PopulateIndexNode(iv(), igvn().intcon(1), vt);\n@@ -2740,2 +2687,2 @@\n-    _igvn.register_new_node_with_optimizer(vn);\n-    _phase->set_ctrl(vn, _phase->get_ctrl(opd));\n+    igvn().register_new_node_with_optimizer(vn);\n+    phase()->set_ctrl(vn, phase()->get_ctrl(opd));\n@@ -2762,1 +2709,1 @@\n-          _igvn.register_new_node_with_optimizer(cnt);\n+          igvn().register_new_node_with_optimizer(cnt);\n@@ -2767,1 +2714,1 @@\n-          _igvn.register_new_node_with_optimizer(cnt);\n+          igvn().register_new_node_with_optimizer(cnt);\n@@ -2769,2 +2716,2 @@\n-          _igvn.register_new_node_with_optimizer(cnt);\n-          _phase->set_ctrl(cnt, _phase->get_ctrl(opd));\n+          igvn().register_new_node_with_optimizer(cnt);\n+          phase()->set_ctrl(cnt, phase()->get_ctrl(opd));\n@@ -2779,2 +2726,2 @@\n-      _igvn.register_new_node_with_optimizer(cnt);\n-      _phase->set_ctrl(cnt, _phase->get_ctrl(opd));\n+      igvn().register_new_node_with_optimizer(cnt);\n+      phase()->set_ctrl(cnt, phase()->get_ctrl(opd));\n@@ -2798,2 +2745,2 @@\n-         _igvn.register_new_node_with_optimizer(conv);\n-         _phase->set_ctrl(conv, _phase->get_ctrl(opd));\n+         igvn().register_new_node_with_optimizer(conv);\n+         phase()->set_ctrl(conv, phase()->get_ctrl(opd));\n@@ -2807,2 +2754,2 @@\n-    _igvn.register_new_node_with_optimizer(vn);\n-    _phase->set_ctrl(vn, _phase->get_ctrl(opd));\n+    igvn().register_new_node_with_optimizer(vn);\n+    phase()->set_ctrl(vn, phase()->get_ctrl(opd));\n@@ -2837,2 +2784,2 @@\n-  _igvn.register_new_node_with_optimizer(pk);\n-  _phase->set_ctrl(pk, _phase->get_ctrl(opd));\n+  igvn().register_new_node_with_optimizer(pk);\n+  phase()->set_ctrl(pk, phase()->get_ctrl(opd));\n@@ -2953,1 +2900,1 @@\n-  Node* entry = bb();\n+  Node* entry = cl();\n@@ -2994,2 +2941,2 @@\n-  for (DUIterator_Fast imax, i = lp()->fast_outs(imax); i < imax; i++) {\n-    Node *n = lp()->fast_out(i);\n+  for (DUIterator_Fast imax, i = cl()->fast_outs(imax); i < imax; i++) {\n+    Node *n = cl()->fast_out(i);\n@@ -3315,1 +3262,1 @@\n-  VPointer p(s, phase(), lpt(), nullptr, false);\n+  VPointer p(s, vloop());\n@@ -3356,1 +3303,1 @@\n-  const Type* t = _igvn.type(n);\n+  const Type* t = igvn().type(n);\n@@ -3376,1 +3323,1 @@\n-  return _phase->C->get_alias_index(mem_ref->adr_type()) == _phase->C->get_alias_index(best_align_to_mem_ref->adr_type());\n+  return phase()->C->get_alias_index(mem_ref->adr_type()) == phase()->C->get_alias_index(best_align_to_mem_ref->adr_type());\n@@ -3456,1 +3403,1 @@\n-  assert(lp()->is_main_loop(), \"can only do alignment for main loop\");\n+  assert(cl()->is_main_loop(), \"can only do alignment for main loop\");\n@@ -3459,1 +3406,1 @@\n-  Opaque1Node* pre_opaq = lp()->pre_loop_end()->limit()->as_Opaque1();\n+  Opaque1Node* pre_opaq = vloop().pre_loop_end()->limit()->as_Opaque1();\n@@ -3465,1 +3412,1 @@\n-  Node* pre_ctrl = lp()->pre_loop_head()->in(LoopNode::EntryControl);\n+  Node* pre_ctrl = vloop().pre_loop_head()->in(LoopNode::EntryControl);\n@@ -3469,1 +3416,1 @@\n-  assert(orig_limit != nullptr && _igvn.type(orig_limit) != Type::TOP, \"\");\n+  assert(orig_limit != nullptr && igvn().type(orig_limit) != Type::TOP, \"\");\n@@ -3471,1 +3418,1 @@\n-  VPointer align_to_ref_p(align_to_ref, phase(), lpt(), nullptr, false);\n+  VPointer align_to_ref_p(align_to_ref, vloop());\n@@ -3665,1 +3612,1 @@\n-  Node* xboi = _igvn.intcon(is_sub ? -offset : offset);\n+  Node* xboi = igvn().intcon(is_sub ? -offset : offset);\n@@ -3670,1 +3617,1 @@\n-    if (_igvn.type(invar)->isa_long()) {\n+    if (igvn().type(invar)->isa_long()) {\n@@ -3675,1 +3622,1 @@\n-      _igvn.register_new_node_with_optimizer(invar);\n+      igvn().register_new_node_with_optimizer(invar);\n@@ -3683,2 +3630,2 @@\n-    _igvn.register_new_node_with_optimizer(xboi);\n-    _phase->set_ctrl(xboi, pre_ctrl);\n+    igvn().register_new_node_with_optimizer(xboi);\n+    phase()->set_ctrl(xboi, pre_ctrl);\n@@ -3694,1 +3641,1 @@\n-    _igvn.register_new_node_with_optimizer(xbase);\n+    igvn().register_new_node_with_optimizer(xbase);\n@@ -3698,1 +3645,1 @@\n-    _igvn.register_new_node_with_optimizer(xbase);\n+    igvn().register_new_node_with_optimizer(xbase);\n@@ -3706,2 +3653,2 @@\n-    _igvn.register_new_node_with_optimizer(xboi);\n-    _phase->set_ctrl(xboi, pre_ctrl);\n+    igvn().register_new_node_with_optimizer(xboi);\n+    phase()->set_ctrl(xboi, pre_ctrl);\n@@ -3714,1 +3661,1 @@\n-  Node* log2_abs_scale = _igvn.intcon(exact_log2(abs(scale)));\n+  Node* log2_abs_scale = igvn().intcon(exact_log2(abs(scale)));\n@@ -3716,2 +3663,2 @@\n-  _igvn.register_new_node_with_optimizer(XBOI);\n-  _phase->set_ctrl(XBOI, pre_ctrl);\n+  igvn().register_new_node_with_optimizer(XBOI);\n+  phase()->set_ctrl(XBOI, pre_ctrl);\n@@ -3731,2 +3678,2 @@\n-  _igvn.register_new_node_with_optimizer(XBOI_OP_old_limit);\n-  _phase->set_ctrl(XBOI_OP_old_limit, pre_ctrl);\n+  igvn().register_new_node_with_optimizer(XBOI_OP_old_limit);\n+  phase()->set_ctrl(XBOI_OP_old_limit, pre_ctrl);\n@@ -3741,1 +3688,1 @@\n-  Node* mask_AW = _igvn.intcon(AW-1);\n+  Node* mask_AW = igvn().intcon(AW-1);\n@@ -3743,2 +3690,2 @@\n-  _igvn.register_new_node_with_optimizer(adjust_pre_iter);\n-  _phase->set_ctrl(adjust_pre_iter, pre_ctrl);\n+  igvn().register_new_node_with_optimizer(adjust_pre_iter);\n+  phase()->set_ctrl(adjust_pre_iter, pre_ctrl);\n@@ -3757,2 +3704,2 @@\n-  _igvn.register_new_node_with_optimizer(new_limit);\n-  _phase->set_ctrl(new_limit, pre_ctrl);\n+  igvn().register_new_node_with_optimizer(new_limit);\n+  phase()->set_ctrl(new_limit, pre_ctrl);\n@@ -3766,2 +3713,2 @@\n-  _igvn.register_new_node_with_optimizer(constrained_limit);\n-  _phase->set_ctrl(constrained_limit, pre_ctrl);\n+  igvn().register_new_node_with_optimizer(constrained_limit);\n+  phase()->set_ctrl(constrained_limit, pre_ctrl);\n@@ -3771,17 +3718,1 @@\n-  _igvn.replace_input_of(pre_opaq, 1, constrained_limit);\n-}\n-\n-\/\/------------------------------init---------------------------\n-void SuperWord::init() {\n-  _dg.init();\n-  _packset.clear();\n-  _block.clear();\n-  _data_entry.clear();\n-  _mem_slice_head.clear();\n-  _mem_slice_tail.clear();\n-  _node_info.clear();\n-  _align_to_ref = nullptr;\n-  _race_possible = 0;\n-  _early_return = false;\n-  _num_work_vecs = 0;\n-  _num_reductions = 0;\n+  igvn().replace_input_of(pre_opaq, 1, constrained_limit);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":165,"deletions":234,"binary":false,"changes":399,"status":"modified"},{"patch":"@@ -142,2 +142,0 @@\n-  void init() { _map.clear(); } \/\/ initialize\n-\n@@ -203,2 +201,0 @@\n- friend class VPointer;\n- friend class CMoveKit;\n@@ -206,3 +202,2 @@\n-  PhaseIdealLoop* _phase;\n-  Arena*          _arena;\n-  PhaseIterGVN   &_igvn;\n+  const VLoop& _vloop;\n+  Arena* _arena;\n@@ -230,3 +225,1 @@\n-  SuperWord(PhaseIdealLoop* phase);\n-\n-  bool transform_loop(IdealLoopTree* lpt, bool do_optimization);\n+  SuperWord(Arena* arena, const VLoop &vloop);\n@@ -234,1 +227,2 @@\n-  void unrolling_analysis(int &local_loop_unroll_factor);\n+  \/\/ Attempt to run the SuperWord algorithm on the loop. Return true if we succeed.\n+  bool transform_loop();\n@@ -236,4 +230,2 @@\n-  \/\/ Accessors for VPointer\n-  PhaseIdealLoop* phase() const    { return _phase; }\n-  IdealLoopTree* lpt() const       { return _lpt; }\n-  PhiNode* iv() const              { return _iv; }\n+  \/\/ Decide if loop can eventually be vectorized, and what unrolling factor is required.\n+  static void unrolling_analysis(const VLoop &vloop, int &local_loop_unroll_factor);\n@@ -241,1 +233,9 @@\n-  bool early_return() const        { return _early_return; }\n+  \/\/ VLoop Accessors\n+  const VLoop& vloop()        const { return _vloop; }\n+  PhaseIdealLoop* phase()     const { return vloop().phase(); }\n+  PhaseIterGVN& igvn()        const { return vloop().phase()->igvn(); }\n+  IdealLoopTree* lpt()        const { return vloop().lpt(); }\n+  CountedLoopNode* cl()       const { return vloop().cl(); }\n+  PhiNode* iv()               const { return vloop().iv(); }\n+  int iv_stride()             const { return cl()->stride_con(); }\n+  bool in_bb(const Node* n)   const { return vloop().in_bb(n); }\n@@ -245,5 +245,0 @@\n-  bool is_trace_superword_precondition() const {\n-    return TraceSuperWord ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PRECONDITION);\n-  }\n-\n@@ -252,1 +247,1 @@\n-    return _vtrace.is_trace(TraceAutoVectorizationTag::SW_TYPES);\n+    return vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_TYPES);\n@@ -257,1 +252,1 @@\n-    return _vtrace.is_trace(TraceAutoVectorizationTag::SW_ALIGNMENT);\n+    return vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_ALIGNMENT);\n@@ -262,1 +257,1 @@\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_MEMORY_SLICES);\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_MEMORY_SLICES);\n@@ -267,1 +262,1 @@\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_DEPENDENCE_GRAPH);\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_DEPENDENCE_GRAPH);\n@@ -272,1 +267,1 @@\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_ADJACENT_MEMOPS);\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_ADJACENT_MEMOPS);\n@@ -277,1 +272,1 @@\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_REJECTIONS);\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_REJECTIONS);\n@@ -282,1 +277,1 @@\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PACKSET);\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_PACKSET);\n@@ -287,1 +282,1 @@\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_INFO);\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_INFO);\n@@ -292,1 +287,1 @@\n-    return _vtrace.is_trace(TraceAutoVectorizationTag::SW_VERBOSE);\n+    return vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_VERBOSE);\n@@ -298,10 +293,9 @@\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PRECONDITION) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_TYPES) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_ALIGNMENT) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_MEMORY_SLICES) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_DEPENDENCE_GRAPH) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_ADJACENT_MEMOPS) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_REJECTIONS) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PACKSET) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_INFO) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_VERBOSE);\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_TYPES) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_ALIGNMENT) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_MEMORY_SLICES) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_DEPENDENCE_GRAPH) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_ADJACENT_MEMOPS) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_REJECTIONS) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_PACKSET) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_INFO) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_VERBOSE);\n@@ -311,1 +305,1 @@\n-    return _vtrace.is_trace(TraceAutoVectorizationTag::ALIGN_VECTOR) ||\n+    return vloop().vtrace().is_trace(TraceAutoVectorizationTag::ALIGN_VECTOR) ||\n@@ -322,2 +316,0 @@\n-  IdealLoopTree* _lpt;             \/\/ Current loop tree node\n-  CountedLoopNode* _lp;            \/\/ Current CountedLoopNode\n@@ -325,2 +317,0 @@\n-  Node*          _bb;              \/\/ Current basic block\n-  PhiNode*       _iv;              \/\/ Induction var\n@@ -328,1 +318,0 @@\n-  bool           _early_return;    \/\/ True if we do not initialize\n@@ -332,1 +321,0 @@\n-  NOT_PRODUCT(VTrace _vtrace);\n@@ -337,10 +325,0 @@\n-  Node* bb()                       { return _bb; }\n-  void set_bb(Node* bb)            { _bb = bb; }\n-  void set_lpt(IdealLoopTree* lpt) { _lpt = lpt; }\n-  CountedLoopNode* lp() const      { return _lp; }\n-  void set_lp(CountedLoopNode* lp) {\n-    _lp = lp;\n-    _iv = lp->as_CountedLoop()->phi()->as_Phi();\n-  }\n-  int iv_stride() const            { return lp()->stride_con(); }\n-\n@@ -359,2 +337,0 @@\n-  const Node* ctrl(const Node* n) const { return _phase->has_ctrl(n) ? _phase->get_ctrl(n) : n; }\n-\n@@ -363,1 +339,0 @@\n-  bool in_bb(const Node* n) const  { return n != nullptr && n->outcnt() > 0 && ctrl(n) == _bb; }\n@@ -564,1 +539,0 @@\n-  void init();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":35,"deletions":61,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  flags(SW_PRECONDITION,      \"Trace SuperWord precondition\") \\\n+  flags(PRECONDITIONS,        \"Trace VLoop::check_preconditions\") \\\n@@ -115,1 +115,0 @@\n-        _tags.at_put(SW_PRECONDITION, set_bit);\n@@ -126,1 +125,0 @@\n-        _tags.at_put(SW_PRECONDITION, set_bit);\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,83 @@\n+bool VLoop::check_preconditions() {\n+#ifndef PRODUCT\n+  if (is_trace_preconditions()) {\n+    tty->print_cr(\"\\nVLoop::check_preconditions\");\n+    lpt()->dump_head();\n+    lpt()->head()->dump();\n+  }\n+#endif\n+\n+  const char* return_state = check_preconditions_helper();\n+  assert(return_state != nullptr, \"must have return state\");\n+  if (return_state == VLoop::SUCCESS) {\n+    return true; \/\/ success\n+  }\n+\n+#ifndef PRODUCT\n+  if (is_trace_preconditions()) {\n+    tty->print_cr(\"VLoop::check_preconditions: failed: %s\", return_state);\n+  }\n+#endif\n+  return false; \/\/ failure\n+}\n+\n+const char* VLoop::check_preconditions_helper() {\n+  \/\/ Only accept vector width that is power of 2\n+  int vector_width = Matcher::vector_width_in_bytes(T_BYTE);\n+  if (vector_width < 2 || !is_power_of_2(vector_width)) {\n+    return VLoop::FAILURE_VECTOR_WIDTH;\n+  }\n+\n+  \/\/ Only accept valid counted loops (int)\n+  if (!_lpt->_head->as_Loop()->is_valid_counted_loop(T_INT)) {\n+    return VLoop::FAILURE_VALID_COUNTED_LOOP;\n+  }\n+  _cl = _lpt->_head->as_CountedLoop();\n+  _iv = _cl->phi()->as_Phi();\n+\n+  if (_cl->is_vectorized_loop()) {\n+    return VLoop::FAILURE_ALREADY_VECTORIZED;\n+  }\n+\n+  if (_cl->is_unroll_only()) {\n+    return VLoop::FAILURE_UNROLL_ONLY;\n+  }\n+\n+  \/\/ Check for control flow in the body\n+  _cl_exit = _cl->loopexit();\n+  bool has_cfg = _cl_exit->in(0) != _cl;\n+  if (has_cfg && !is_allow_cfg()) {\n+#ifndef PRODUCT\n+    if (is_trace_preconditions()) {\n+      tty->print_cr(\"VLoop::check_preconditions: fails because of control flow.\");\n+      tty->print(\"  cl_exit %d\", _cl_exit->_idx); _cl_exit->dump();\n+      tty->print(\"  cl_exit->in(0) %d\", _cl_exit->in(0)->_idx); _cl_exit->in(0)->dump();\n+      tty->print(\"  lpt->_head %d\", _cl->_idx); _cl->dump();\n+      _lpt->dump_head();\n+    }\n+#endif\n+    return VLoop::FAILURE_CONTROL_FLOW;\n+  }\n+\n+  \/\/ Make sure the are no extra control users of the loop backedge\n+  if (_cl->back_control()->outcnt() != 1) {\n+    return VLoop::FAILURE_BACKEDGE;\n+  }\n+\n+  \/\/ To align vector memory accesses in the main-loop, we will have to adjust\n+  \/\/ the pre-loop limit.\n+  if (_cl->is_main_loop()) {\n+    CountedLoopEndNode* pre_end = _cl->find_pre_loop_end();\n+    if (pre_end == nullptr) {\n+      return VLoop::FAILURE_PRE_LOOP_LIMIT;\n+    }\n+    Node* pre_opaq1 = pre_end->limit();\n+    if (pre_opaq1->Opcode() != Op_Opaque1) {\n+      return VLoop::FAILURE_PRE_LOOP_LIMIT;\n+    }\n+    _pre_loop_end = pre_end;\n+  }\n+\n+  return VLoop::SUCCESS;\n+}\n+\n@@ -38,2 +121,1 @@\n-VPointer::VPointer(const MemNode* mem,\n-                   PhaseIdealLoop* phase, IdealLoopTree* lpt,\n+VPointer::VPointer(const MemNode* mem, const VLoop& vloop,\n@@ -41,2 +123,1 @@\n-  _mem(mem), _phase(phase), _lpt(lpt),\n-  _iv(lpt->_head->as_CountedLoop()->phi()->as_Phi()),\n+  _mem(mem), _vloop(vloop),\n@@ -49,1 +130,1 @@\n-  , _tracer(phase->C->directive()->trace_auto_vectorization_tags().at(TraceAutoVectorizationTag::POINTER_ANALYSIS))\n+  , _tracer(vloop.is_trace_pointer_analysis())\n@@ -112,1 +193,1 @@\n-  _mem(p->_mem), _phase(p->_phase), _lpt(p->_lpt), _iv(p->_iv),\n+  _mem(p->_mem), _vloop(p->_vloop),\n@@ -156,1 +237,1 @@\n-      return phase()->is_dominator(n_c, cl->pre_loop_head());\n+      return phase()->is_dominator(n_c, vloop().pre_loop_head());\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":88,"deletions":7,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -51,0 +51,83 @@\n+\/\/ Basic loop structure accessors and vectorization preconditions checking\n+class VLoop : public StackObj {\n+private:\n+  PhaseIdealLoop* const _phase;\n+  IdealLoopTree* const _lpt;\n+  const bool _allow_cfg;\n+  CountedLoopNode* _cl;\n+  Node* _cl_exit;\n+  PhiNode* _iv;\n+  CountedLoopEndNode* _pre_loop_end; \/\/ cache access to pre-loop for main loops only\n+\n+  NOT_PRODUCT(VTrace _vtrace;)\n+\n+  static constexpr char const* SUCCESS                    = \"success\";\n+  static constexpr char const* FAILURE_ALREADY_VECTORIZED = \"loop already vectorized\";\n+  static constexpr char const* FAILURE_UNROLL_ONLY        = \"loop only wants to be unrolled\";\n+  static constexpr char const* FAILURE_VECTOR_WIDTH       = \"vector_width must be power of 2\";\n+  static constexpr char const* FAILURE_VALID_COUNTED_LOOP = \"must be valid counted loop (int)\";\n+  static constexpr char const* FAILURE_CONTROL_FLOW       = \"control flow in loop not allowed\";\n+  static constexpr char const* FAILURE_BACKEDGE           = \"nodes on backedge not allowed\";\n+  static constexpr char const* FAILURE_PRE_LOOP_LIMIT     = \"main-loop must be able to adjust pre-loop-limit (not found)\";\n+\n+public:\n+  VLoop(IdealLoopTree* lpt, bool allow_cfg) :\n+    _phase     (lpt->_phase),\n+    _lpt       (lpt),\n+    _allow_cfg (allow_cfg),\n+    _cl        (nullptr),\n+    _cl_exit   (nullptr),\n+    _iv        (nullptr) {}\n+  NONCOPYABLE(VLoop);\n+\n+  IdealLoopTree* lpt()        const { return _lpt; };\n+  PhaseIdealLoop* phase()     const { return _phase; }\n+  CountedLoopNode* cl()       const { return _cl; };\n+  Node* cl_exit()             const { return _cl_exit; };\n+  PhiNode* iv()               const { return _iv; };\n+  int iv_stride()             const { return cl()->stride_con(); };\n+  bool is_allow_cfg()         const { return _allow_cfg; }\n+\n+  CountedLoopEndNode* pre_loop_end() const {\n+    assert(cl()->is_main_loop(), \"only main loop can reference pre-loop\");\n+    assert(_pre_loop_end != nullptr, \"must have found it\");\n+    return _pre_loop_end;\n+  };\n+\n+  CountedLoopNode* pre_loop_head() const {\n+    CountedLoopNode* head = pre_loop_end()->loopnode();\n+    assert(head != nullptr, \"must find head\");\n+    return head;\n+  };\n+\n+  \/\/ Estimate maximum size for data structures, to avoid repeated reallocation\n+  int estimated_body_length() const { return lpt()->_body.size(); };\n+  int estimated_node_count()  const { return (int)(1.10 * phase()->C->unique()); };\n+\n+#ifndef PRODUCT\n+  const VTrace& vtrace()      const { return _vtrace; }\n+\n+  bool is_trace_preconditions() const {\n+    return vtrace().is_trace(TraceAutoVectorizationTag::PRECONDITIONS);\n+  }\n+\n+  bool is_trace_pointer_analysis() const {\n+    return vtrace().is_trace(TraceAutoVectorizationTag::POINTER_ANALYSIS);\n+  }\n+#endif\n+\n+  \/\/ Is the node in the basic block of the loop?\n+  \/\/ We only accept any nodes which have the loop head as their ctrl.\n+  bool in_bb(const Node* n) const {\n+    const Node* ctrl = _phase->has_ctrl(n) ? _phase->get_ctrl(n) : n;\n+    return n != nullptr && n->outcnt() > 0 && ctrl == _cl;\n+  }\n+\n+  \/\/ Check if the loop passes some basic preconditions for vectorization.\n+  \/\/ Return indicates if analysis succeeded.\n+  bool check_preconditions();\n+\n+private:\n+  const char* check_preconditions_helper();\n+};\n+\n@@ -57,3 +140,1 @@\n-  PhaseIdealLoop* _phase;    \/\/ PhaseIdealLoop handle\n-  IdealLoopTree*  _lpt;      \/\/ Current IdealLoopTree\n-  PhiNode*        _iv;       \/\/ The loop induction variable\n+  const VLoop&    _vloop;\n@@ -77,3 +158,4 @@\n-  PhaseIdealLoop* phase() const { return _phase; }\n-  IdealLoopTree*  lpt() const   { return _lpt; }\n-  PhiNode*        iv() const    { return _iv; }\n+  const VLoop&    vloop() const { return _vloop; }\n+  PhaseIdealLoop* phase() const { return vloop().phase(); }\n+  IdealLoopTree*  lpt() const   { return vloop().lpt(); }\n+  PhiNode*        iv() const    { return vloop().iv(); }\n@@ -100,2 +182,6 @@\n-  VPointer(const MemNode* mem,\n-           PhaseIdealLoop* phase, IdealLoopTree* lpt,\n+  VPointer(const MemNode* mem, const VLoop& vloop) :\n+    VPointer(mem, vloop, nullptr, false) {}\n+  VPointer(const MemNode* mem, const VLoop& vloop, Node_Stack* nstack) :\n+    VPointer(mem, vloop, nstack, true) {}\n+ private:\n+  VPointer(const MemNode* mem, const VLoop& vloop,\n@@ -106,0 +192,1 @@\n+  NONCOPYABLE(VPointer);\n@@ -107,0 +194,1 @@\n+ public:\n@@ -146,1 +234,1 @@\n-      VPointer p_mem(mem, phase(), lpt(), nullptr, false);\n+      VPointer p_mem(mem, vloop());\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":97,"deletions":9,"binary":false,"changes":106,"status":"modified"}]}