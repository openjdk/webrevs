{"files":[{"patch":"@@ -48,0 +48,1 @@\n+#include \"opto\/vectorization.hpp\"\n@@ -4869,1 +4870,3 @@\n-    ResourceArea autovectorization_arena;\n+    \/\/ Shared data structures for all AutoVectorizations, to reduce allocations\n+    \/\/ of large arrays.\n+    VSharedData vshared;\n@@ -4872,1 +4875,1 @@\n-      AutoVectorizeStatus status = autovectorize(lpt, &autovectorization_arena);\n+      AutoVectorizeStatus status = auto_vectorize(lpt, vshared);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+class VSharedData;\n@@ -1440,1 +1441,1 @@\n-  AutoVectorizeStatus autovectorize(IdealLoopTree* lpt, ResourceArea* arena);\n+  AutoVectorizeStatus auto_vectorize(IdealLoopTree* lpt, VSharedData &vshared);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4215,1 +4215,1 @@\n-PhaseIdealLoop::autovectorize(IdealLoopTree* lpt, ResourceArea* arena) {\n+PhaseIdealLoop::auto_vectorize(IdealLoopTree* lpt, VSharedData &vshared) {\n@@ -4232,3 +4232,1 @@\n-  \/\/ Ensure that all data structures from autovectorization are deallocated later.\n-  ResourceMark rm(arena);\n-  SuperWord sw(arena, vloop);\n+  SuperWord sw(vloop, vshared);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-SuperWord::SuperWord(Arena* arena, const VLoop &vloop) :\n+SuperWord::SuperWord(const VLoop &vloop, VSharedData &vshared) :\n@@ -43,8 +43,8 @@\n-  _arena(arena),\n-  _packset(arena, 8,  0, nullptr),                          \/\/ packs for the current block\n-  _bb_idx(arena, vloop.estimated_node_count(), 0, 0),       \/\/ node idx to index in bb\n-  _block(arena, vloop.estimated_body_length(), 0, nullptr), \/\/ nodes in current block\n-  _data_entry(arena, 8,  0, nullptr),                       \/\/ nodes with all inputs from outside\n-  _mem_slice_head(arena, 8,  0, nullptr),                   \/\/ memory slice heads\n-  _mem_slice_tail(arena, 8,  0, nullptr),                   \/\/ memory slice tails\n-  _node_info(arena, vloop.estimated_body_length(), 0, SWNodeInfo::initial), \/\/ info needed per node\n+  _arena(mtCompiler),\n+  _packset(arena(), 8,  0, nullptr),                        \/\/ packs for the current block\n+  _bb_idx(vshared.node_idx_to_loop_body_idx()),             \/\/ node idx to index in bb\n+  _block(arena(), vloop.estimated_body_length(), 0, nullptr), \/\/ nodes in current block\n+  _data_entry(arena(), 8,  0, nullptr),                     \/\/ nodes with all inputs from outside\n+  _mem_slice_head(arena(), 8,  0, nullptr),                 \/\/ memory slice heads\n+  _mem_slice_tail(arena(), 8,  0, nullptr),                 \/\/ memory slice tails\n+  _node_info(arena(), vloop.estimated_body_length(), 0, SWNodeInfo::initial), \/\/ info needed per node\n@@ -53,3 +53,3 @@\n-  _dg(arena),                                               \/\/ dependence graph\n-  _nlist(arena, vloop.estimated_body_length(), 0, nullptr), \/\/ scratch list of nodes\n-  _loop_reductions(arena),                                  \/\/ reduction nodes in the current loop\n+  _dg(arena()),                                             \/\/ dependence graph\n+  _nlist(arena(), vloop.estimated_body_length(), 0, nullptr), \/\/ scratch list of nodes\n+  _loop_reductions(arena()),                                \/\/ reduction nodes in the current loop\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -203,1 +203,4 @@\n-  Arena* _arena;\n+\n+  \/\/ Arena for small data structures. Large data structures are allocated in\n+  \/\/ VSharedData, and reused over many AutoVectorizations.\n+  Arena _arena;\n@@ -209,1 +212,1 @@\n-  GrowableArray<int> _bb_idx;            \/\/ Map from Node _idx to index within block\n+  GrowableArray<int> &_bb_idx;           \/\/ Map from Node _idx to index within block\n@@ -225,1 +228,1 @@\n-  SuperWord(Arena* arena, const VLoop &vloop);\n+  SuperWord(const VLoop &vloop, VSharedData &vshared);\n@@ -323,1 +326,1 @@\n-  Arena* arena()                   { return _arena; }\n+  Arena* arena()                   { return &_arena; }\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -134,0 +134,32 @@\n+\/\/ Optimization to keep allocation of large arrays in AutoVectorization low.\n+\/\/ We allocate the arrays once, and reuse them for multiple loops that we\n+\/\/ AutoVectorize, clearing them before every new use.\n+class VSharedData : public StackObj {\n+private:\n+  \/\/ Arena, used to allocate all arrays from.\n+  Arena _arena;\n+\n+  \/\/ An array that maps node->_idx to a much smaller idx, which is at most the\n+  \/\/ size of a loop body. This allow us to have smaller arrays for other data\n+  \/\/ structures, since we are using smaller indices.\n+  GrowableArray<int> _node_idx_to_loop_body_idx;\n+\n+public:\n+  VSharedData() :\n+    _arena(mtCompiler),\n+    _node_idx_to_loop_body_idx(&_arena, estimated_node_count(), 0, 0)\n+  {\n+  }\n+\n+  GrowableArray<int>& node_idx_to_loop_body_idx() {\n+    \/\/ Since this is a shared resource, we clear before every individual use.\n+    _node_idx_to_loop_body_idx.clear();\n+    return _node_idx_to_loop_body_idx;\n+  }\n+\n+private:\n+  static int estimated_node_count() {\n+    return (int)(1.10 * Compile::current()->unique());\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"}]}