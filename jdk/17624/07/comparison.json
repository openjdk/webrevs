{"files":[{"patch":"@@ -1107,6 +1107,3 @@\n-      SuperWord sw(phase);\n-      sw.transform_loop(this, false);\n-\n-      \/\/ If the loop is slp canonical analyze it\n-      if (sw.early_return() == false) {\n-        sw.unrolling_analysis(_local_loop_unroll_factor);\n+      VLoop vloop(this, true);\n+      if (vloop.check_preconditions()) {\n+        SuperWord::unrolling_analysis(vloop, _local_loop_unroll_factor);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-#include \"opto\/superword.hpp\"\n+#include \"opto\/vectorization.hpp\"\n@@ -4866,1 +4866,1 @@\n-  \/\/ Convert scalar to superword operations at the end of all loop opts.\n+  \/\/ Auto-vectorize main-loop\n@@ -4869,2 +4869,4 @@\n-    \/\/ SuperWord transform\n-    SuperWord sw(this);\n+\n+    \/\/ Shared data structures for all AutoVectorizations, to reduce allocations\n+    \/\/ of large arrays.\n+    VSharedData vshared;\n@@ -4873,11 +4875,9 @@\n-      if (lpt->is_counted()) {\n-        CountedLoopNode *cl = lpt->_head->as_CountedLoop();\n-        if (cl->is_main_loop()) {\n-          if (!sw.transform_loop(lpt, true)) {\n-            \/\/ Instigate more unrolling for optimization when vectorization fails.\n-            if (cl->has_passed_slp()) {\n-              C->set_major_progress();\n-              cl->set_notpassed_slp();\n-              cl->mark_do_unroll_only();\n-            }\n-          }\n+      AutoVectorizeStatus status = auto_vectorize(lpt, vshared);\n+\n+      if (status == AutoVectorizeStatus::TriedAndFailed) {\n+        \/\/ We tried vectorization, but failed. From now on only unroll the loop.\n+        CountedLoopNode* cl = lpt->_head->as_CountedLoop();\n+        if (cl->has_passed_slp()) {\n+          C->set_major_progress();\n+          cl->set_notpassed_slp();\n+          cl->mark_do_unroll_only();\n@@ -4889,1 +4889,1 @@\n-  \/\/ Move UnorderedReduction out of counted loop. Can be introduced by SuperWord.\n+  \/\/ Move UnorderedReduction out of counted loop. Can be introduced by AutoVectorization.\n@@ -5966,24 +5966,0 @@\n-  CountedLoopNode* CountedLoopNode::pre_loop_head() const {\n-    assert(is_main_loop(), \"Only main loop has pre loop\");\n-    assert(_pre_loop_end != nullptr && _pre_loop_end->loopnode() != nullptr,\n-           \"should find head from pre loop end\");\n-    return _pre_loop_end->loopnode();\n-  }\n-\n-  CountedLoopEndNode* CountedLoopNode::pre_loop_end() {\n-#ifdef ASSERT\n-    assert(is_main_loop(), \"Only main loop has pre loop\");\n-    assert(_pre_loop_end != nullptr, \"should be set when fetched\");\n-    Node* found_pre_end = find_pre_loop_end();\n-    assert(_pre_loop_end == found_pre_end && _pre_loop_end == pre_loop_head()->loopexit(),\n-           \"should find the pre loop end and must be the same result\");\n-#endif\n-    return _pre_loop_end;\n-  }\n-\n-  void CountedLoopNode::set_pre_loop_end(CountedLoopEndNode* pre_loop_end) {\n-    assert(is_main_loop(), \"Only main loop has pre loop\");\n-    assert(pre_loop_end, \"must be valid\");\n-    _pre_loop_end = pre_loop_end;\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":16,"deletions":40,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+class VSharedData;\n@@ -234,3 +235,0 @@\n-  \/\/ Cached CountedLoopEndNode of pre loop for main loops\n-  CountedLoopEndNode* _pre_loop_end;\n-\n@@ -241,1 +239,1 @@\n-      _slp_maximum_unroll_factor(0), _pre_loop_end(nullptr) {\n+      _slp_maximum_unroll_factor(0) {\n@@ -333,3 +331,0 @@\n-  CountedLoopNode* pre_loop_head() const;\n-  CountedLoopEndNode* pre_loop_end();\n-  void set_pre_loop_end(CountedLoopEndNode* pre_loop_end);\n@@ -1440,0 +1435,8 @@\n+  \/\/ AutoVectorize the loop: replace scalar ops with vector ops.\n+  enum AutoVectorizeStatus {\n+    Impossible,      \/\/ This loop has the wrong shape to even try vectorization.\n+    Success,         \/\/ We just successfully vectorized the loop.\n+    TriedAndFailed,  \/\/ We tried to vectorize, but failed.\n+  };\n+  AutoVectorizeStatus auto_vectorize(IdealLoopTree* lpt, VSharedData &vshared);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"opto\/superword.hpp\"\n@@ -4212,0 +4213,27 @@\n+\/\/ AutoVectorize the loop: replace scalar ops with vector ops.\n+PhaseIdealLoop::AutoVectorizeStatus\n+PhaseIdealLoop::auto_vectorize(IdealLoopTree* lpt, VSharedData &vshared) {\n+  \/\/ Counted loop only\n+  if (!lpt->is_counted()) {\n+    return AutoVectorizeStatus::Impossible;\n+  }\n+\n+  \/\/ Main-loop only\n+  CountedLoopNode* cl = lpt->_head->as_CountedLoop();\n+  if (!cl->is_main_loop()) {\n+    return AutoVectorizeStatus::Impossible;\n+  }\n+\n+  VLoop vloop(lpt, false);\n+  if (!vloop.check_preconditions()) {\n+    return AutoVectorizeStatus::TriedAndFailed;\n+  }\n+\n+  SuperWord sw(vloop, vshared);\n+  if (!sw.transform_loop()) {\n+    return AutoVectorizeStatus::TriedAndFailed;\n+  }\n+\n+  return AutoVectorizeStatus::Success;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -41,9 +41,3 @@\n-\/\/\n-\/\/                  S U P E R W O R D   T R A N S F O R M\n-\/\/=============================================================================\n-\n-\/\/------------------------------SuperWord---------------------------\n-SuperWord::SuperWord(PhaseIdealLoop* phase) :\n-  _phase(phase),\n-  _arena(phase->C->comp_arena()),\n-  _igvn(phase->_igvn),\n+SuperWord::SuperWord(const VLoop &vloop, VSharedData &vshared) :\n+  _vloop(vloop),\n+  _arena(mtCompiler),\n@@ -51,2 +45,2 @@\n-  _bb_idx(arena(), (int)(1.10 * phase->C->unique()), 0, 0), \/\/ node idx to index in bb\n-  _block(arena(), 8,  0, nullptr),                          \/\/ nodes in current block\n+  _bb_idx(vshared.node_idx_to_loop_body_idx()),             \/\/ node idx to index in bb\n+  _block(arena(), vloop.estimated_body_length(), 0, nullptr), \/\/ nodes in current block\n@@ -55,2 +49,2 @@\n-  _node_info(arena(), 8,  0, SWNodeInfo::initial),          \/\/ info needed per node\n-  _clone_map(phase->C->clone_map()),                        \/\/ map of nodes created in cloning\n+  _node_info(arena(), vloop.estimated_body_length(), 0, SWNodeInfo::initial), \/\/ info needed per node\n+  _clone_map(phase()->C->clone_map()),                      \/\/ map of nodes created in cloning\n@@ -58,4 +52,2 @@\n-  _dg(_arena),                                              \/\/ dependence graph\n-  _nlist(arena(), 8, 0, nullptr),                           \/\/ scratch list of nodes\n-  _lpt(nullptr),                                            \/\/ loop tree node\n-  _lp(nullptr),                                             \/\/ CountedLoopNode\n+  _dg(arena()),                                             \/\/ dependence graph\n+  _nlist(arena(), vloop.estimated_body_length(), 0, nullptr), \/\/ scratch list of nodes\n@@ -63,2 +55,0 @@\n-  _bb(nullptr),                                             \/\/ basic block\n-  _iv(nullptr),                                             \/\/ induction var\n@@ -66,2 +56,1 @@\n-  _early_return(true),                                      \/\/ analysis evaluations routine\n-  _do_vector_loop(phase->C->do_vector_loop()),              \/\/ whether to do vectorization\/simd style\n+  _do_vector_loop(phase()->C->do_vector_loop()),            \/\/ whether to do vectorization\/simd style\n@@ -73,47 +62,5 @@\n-\/\/------------------------------transform_loop---------------------------\n-bool SuperWord::transform_loop(IdealLoopTree* lpt, bool do_optimization) {\n-  assert(_phase->C->do_superword(), \"SuperWord option should be enabled\");\n-  \/\/ SuperWord only works with power of two vector sizes.\n-  int vector_width = Matcher::vector_width_in_bytes(T_BYTE);\n-  if (vector_width < 2 || !is_power_of_2(vector_width)) {\n-    return false;\n-  }\n-\n-  assert(lpt->_head->is_CountedLoop(), \"must be\");\n-  CountedLoopNode *cl = lpt->_head->as_CountedLoop();\n-\n-  if (!cl->is_valid_counted_loop(T_INT)) {\n-    return false; \/\/ skip malformed counted loop\n-  }\n-\n-  \/\/ Initialize simple data used by reduction marking early.\n-  set_lpt(lpt);\n-  set_lp(cl);\n-  \/\/ For now, define one block which is the entire loop body.\n-  set_bb(cl);\n-\n-  if (SuperWordReductions) {\n-    mark_reductions();\n-  }\n-\n-  \/\/ skip any loop that has not been assigned max unroll by analysis\n-  if (do_optimization) {\n-    if (SuperWordLoopUnrollAnalysis && cl->slp_max_unroll() == 0) {\n-      return false;\n-    }\n-  }\n-\n-  \/\/ Check for no control flow in body (other than exit)\n-  Node *cl_exit = cl->loopexit();\n-  if (cl->is_main_loop() && (cl_exit->in(0) != lpt->_head)) {\n-    #ifndef PRODUCT\n-      if (is_trace_superword_precondition()) {\n-        tty->print_cr(\"SuperWord::transform_loop: loop too complicated, cl_exit->in(0) != lpt->_head\");\n-        tty->print(\"cl_exit %d\", cl_exit->_idx); cl_exit->dump();\n-        tty->print(\"cl_exit->in(0) %d\", cl_exit->in(0)->_idx); cl_exit->in(0)->dump();\n-        tty->print(\"lpt->_head %d\", lpt->_head->_idx); lpt->_head->dump();\n-        lpt->dump_head();\n-      }\n-    #endif\n-    return false;\n-  }\n+void SuperWord::unrolling_analysis(const VLoop &vloop, int &local_loop_unroll_factor) {\n+  IdealLoopTree* lpt    = vloop.lpt();\n+  CountedLoopNode* cl   = vloop.cl();\n+  Node* cl_exit         = vloop.cl_exit();\n+  PhaseIdealLoop* phase = vloop.phase();\n@@ -121,39 +68,0 @@\n-  \/\/ Make sure the are no extra control users of the loop backedge\n-  if (cl->back_control()->outcnt() != 1) {\n-    return false;\n-  }\n-\n-  \/\/ Skip any loops already optimized by slp\n-  if (cl->is_vectorized_loop()) {\n-    return false;\n-  }\n-\n-  if (cl->is_unroll_only()) {\n-    return false;\n-  }\n-\n-  if (cl->is_main_loop()) {\n-    \/\/ Check for pre-loop ending with CountedLoopEnd(Bool(Cmp(x,Opaque1(limit))))\n-    CountedLoopEndNode* pre_end = cl->find_pre_loop_end();\n-    if (pre_end == nullptr) {\n-      return false;\n-    }\n-    Node* pre_opaq1 = pre_end->limit();\n-    if (pre_opaq1->Opcode() != Op_Opaque1) {\n-      return false;\n-    }\n-    cl->set_pre_loop_end(pre_end);\n-  }\n-\n-  init(); \/\/ initialize data structures\n-\n-  bool success = true;\n-  if (do_optimization) {\n-    assert(_packset.length() == 0, \"packset must be empty\");\n-    success = SLP_extract();\n-  }\n-  return success;\n-}\n-\n-\/\/------------------------------early unrolling analysis------------------------------\n-void SuperWord::unrolling_analysis(int &local_loop_unroll_factor) {\n@@ -161,1 +69,1 @@\n-  size_t ignored_size = lpt()->_body.size();\n+  size_t ignored_size = lpt->_body.size();\n@@ -164,2 +72,0 @@\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  Node *cl_exit = cl->loopexit_or_null();\n@@ -168,1 +74,1 @@\n-  for (uint i = 0; i < lpt()->_body.size(); i++) {\n+  for (uint i = 0; i < lpt->_body.size(); i++) {\n@@ -176,2 +82,2 @@\n-  for (uint i = 0; i < lpt()->_body.size(); i++) {\n-    Node* n = lpt()->_body.at(i);\n+  for (uint i = 0; i < lpt->_body.size(); i++) {\n+    Node* n = lpt->_body.at(i);\n@@ -192,1 +98,1 @@\n-        if (lpt()->is_loop_exit(iff)) {\n+        if (lpt->is_loop_exit(iff)) {\n@@ -236,1 +142,1 @@\n-      Node* n_ctrl = _phase->get_ctrl(adr);\n+      Node* n_ctrl = phase->get_ctrl(adr);\n@@ -239,1 +145,1 @@\n-      if (n_ctrl != nullptr && lpt()->is_member(_phase->get_loop(n_ctrl))) {\n+      if (n_ctrl != nullptr && lpt->is_member(phase->get_loop(n_ctrl))) {\n@@ -247,1 +153,1 @@\n-          VPointer p1(current, phase(), lpt(), &nstack, true);\n+          VPointer p1(current, vloop, &nstack);\n@@ -254,2 +160,2 @@\n-          for (uint j = 0; j < lpt()->_body.size(); j++) {\n-            Node* cur_node = lpt()->_body.at(j);\n+          for (uint j = 0; j < lpt->_body.size(); j++) {\n+            Node* cur_node = lpt->_body.at(j);\n@@ -272,1 +178,1 @@\n-    for (uint i = 0; i < lpt()->_body.size(); i++) {\n+    for (uint i = 0; i < lpt->_body.size(); i++) {\n@@ -276,1 +182,1 @@\n-      Node* n = lpt()->_body.at(i);\n+      Node* n = lpt->_body.at(i);\n@@ -316,1 +222,1 @@\n-              if (!in->is_Mem() && in_bb(in) && in->bottom_type()->basic_type() == T_INT) {\n+              if (!in->is_Mem() && vloop.in_bb(in) && in->bottom_type()->basic_type() == T_INT) {\n@@ -320,1 +226,1 @@\n-                  if (!in_bb(use) && use->bottom_type()->basic_type() != bt) {\n+                  if (!vloop.in_bb(use) && use->bottom_type()->basic_type() != bt) {\n@@ -406,2 +312,2 @@\n-  for (DUIterator_Fast imax, i = lp()->fast_outs(imax); i < imax; i++) {\n-    const Node* phi = lp()->fast_out(i);\n+  for (DUIterator_Fast imax, i = cl()->fast_outs(imax); i < imax; i++) {\n+    const Node* phi = cl()->fast_out(i);\n@@ -485,0 +391,38 @@\n+bool SuperWord::transform_loop() {\n+  assert(phase()->C->do_superword(), \"SuperWord option should be enabled\");\n+  assert(cl()->is_main_loop(), \"SLP should only work on main loops\");\n+#ifndef PRODUCT\n+  if (is_trace_superword_any()) {\n+    tty->print_cr(\"\\nSuperWord::transform_loop:\");\n+    lpt()->dump_head();\n+    cl()->dump();\n+  }\n+#endif\n+\n+  \/\/ Skip any loop that has not been assigned max unroll by analysis\n+  if (SuperWordLoopUnrollAnalysis && vloop().cl()->slp_max_unroll() == 0) {\n+#ifndef PRODUCT\n+    if (is_trace_superword_any()) {\n+      tty->print_cr(\"\\nSuperWord::transform_loop failed: slp max unroll analysis was not already done\");\n+    }\n+#endif\n+    return false;\n+  }\n+\n+  if (!SLP_extract()) {\n+#ifndef PRODUCT\n+    if (is_trace_superword_any()) {\n+      tty->print_cr(\"\\nSuperWord::transform_loop failed: SuperWord::SLP_extract did not vectorize\");\n+    }\n+#endif\n+    return false;\n+  }\n+\n+#ifndef PRODUCT\n+  if (is_trace_superword_any()) {\n+    tty->print_cr(\"\\nSuperWord::transform_loop: success\");\n+  }\n+#endif\n+  return true;\n+}\n+\n@@ -520,2 +464,5 @@\n-  CountedLoopNode* cl = lpt()->_head->as_CountedLoop();\n-  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n+  assert(cl()->is_main_loop(), \"SLP should only work on main loops\");\n+\n+  if (SuperWordReductions) {\n+    mark_reductions();\n+  }\n@@ -632,1 +579,1 @@\n-    VPointer align_to_ref_p(mem_ref, phase(), lpt(), nullptr, false);\n+    VPointer align_to_ref_p(mem_ref, vloop());\n@@ -638,1 +585,1 @@\n-        VPointer p2(s, phase(), lpt(), nullptr, false);\n+        VPointer p2(s, vloop());\n@@ -697,1 +644,1 @@\n-    VPointer p1(s1, phase(), lpt(), nullptr, false);\n+    VPointer p1(s1, vloop());\n@@ -701,1 +648,1 @@\n-        VPointer p2(s2, phase(), lpt(), nullptr, false);\n+        VPointer p2(s2, vloop());\n@@ -722,1 +669,1 @@\n-      VPointer p(s, phase(), lpt(), nullptr, false);\n+      VPointer p(s, vloop());\n@@ -745,1 +692,1 @@\n-        VPointer p(s, phase(), lpt(), nullptr, false);\n+        VPointer p(s, vloop());\n@@ -818,1 +765,1 @@\n-  VPointer align_to_ref_p(mem_ref, phase(), lpt(), nullptr, false);\n+  VPointer align_to_ref_p(mem_ref, vloop());\n@@ -887,1 +834,1 @@\n-      VPointer p1(s1->as_Mem(), phase(), lpt(), nullptr, false);\n+      VPointer p1(s1->as_Mem(), vloop());\n@@ -893,1 +840,1 @@\n-        VPointer p2(s2->as_Mem(), phase(), lpt(), nullptr, false);\n+        VPointer p2(s2->as_Mem(), vloop());\n@@ -926,2 +873,2 @@\n-  for (DUIterator_Fast imax, i = lp()->fast_outs(imax); i < imax; i++) {\n-    PhiNode* phi = lp()->fast_out(i)->isa_Phi();\n+  for (DUIterator_Fast imax, i = cl()->fast_outs(imax); i < imax; i++) {\n+    PhiNode* phi = cl()->fast_out(i)->isa_Phi();\n@@ -1063,2 +1010,2 @@\n-  VPointer p1(s1->as_Mem(), phase(), lpt(), nullptr, false);\n-  VPointer p2(s2->as_Mem(), phase(), lpt(), nullptr, false);\n+  VPointer p1(s1->as_Mem(), vloop());\n+  VPointer p2(s2->as_Mem(), vloop());\n@@ -1355,1 +1302,1 @@\n-      if (t2->Opcode() == Op_AddI && t2 == _lp->as_CountedLoop()->incr()) continue; \/\/ don't mess with the iv\n+      if (t2->Opcode() == Op_AddI && t2 == cl()->incr()) continue; \/\/ don't mess with the iv\n@@ -1654,2 +1601,2 @@\n-  VPointer mem_ref_p(mem_ref, phase(), lpt(), nullptr, false);\n-  const CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n+  VPointer mem_ref_p(mem_ref, vloop());\n+  const CountedLoopEndNode* pre_end = vloop().pre_loop_end();\n@@ -1974,2 +1921,2 @@\n-                ((use->is_Phi() && use->in(0) == _lpt->_head) ||\n-                 (!_lpt->is_member(_phase->get_loop(_phase->ctrl_or_self(use))) && i == p->size()-1))) {\n+                ((use->is_Phi() && use->in(0) == lpt()->_head) ||\n+                 (!lpt()->is_member(phase()->get_loop(phase()->ctrl_or_self(use))) && i == p->size()-1))) {\n@@ -2330,1 +2277,1 @@\n-  _phase->C->print_method(PHASE_SUPERWORD1_BEFORE_SCHEDULE, 4, cl);\n+  phase()->C->print_method(PHASE_SUPERWORD1_BEFORE_SCHEDULE, 4, cl);\n@@ -2340,1 +2287,1 @@\n-  int max_slices = _phase->C->num_alias_types();\n+  int max_slices = phase()->C->num_alias_types();\n@@ -2352,1 +2299,1 @@\n-    int alias_idx = _phase->C->get_alias_index(phi->adr_type());\n+    int alias_idx = phase()->C->get_alias_index(phi->adr_type());\n@@ -2365,1 +2312,1 @@\n-    int alias_idx = _phase->C->get_alias_index(n->adr_type());\n+    int alias_idx = phase()->C->get_alias_index(n->adr_type());\n@@ -2374,1 +2321,1 @@\n-      _igvn.replace_input_of(n, MemNode::Memory, current_state);\n+      igvn().replace_input_of(n, MemNode::Memory, current_state);\n@@ -2387,1 +2334,1 @@\n-    int alias_idx = _phase->C->get_alias_index(phi->adr_type());\n+    int alias_idx = phase()->C->get_alias_index(phi->adr_type());\n@@ -2392,1 +2339,1 @@\n-    _igvn.replace_input_of(phi, 2, current_state);\n+    igvn().replace_input_of(phi, 2, current_state);\n@@ -2411,1 +2358,1 @@\n-          _igvn.replace_input_of(use, j, current_state);\n+          igvn().replace_input_of(use, j, current_state);\n@@ -2428,1 +2375,1 @@\n-  Compile* C = _phase->C;\n+  Compile* C = phase()->C;\n@@ -2439,1 +2386,1 @@\n-  _phase->C->print_method(PHASE_SUPERWORD2_BEFORE_OUTPUT, 4, cl);\n+  phase()->C->print_method(PHASE_SUPERWORD2_BEFORE_OUTPUT, 4, cl);\n@@ -2467,1 +2414,1 @@\n-          VPointer p_store(mem->as_Mem(), phase(), lpt(), nullptr, false);\n+          VPointer p_store(mem->as_Mem(), vloop());\n@@ -2601,1 +2548,1 @@\n-        ConINode* bol_test_node  = _igvn.intcon((int)bol_test);\n+        ConINode* bol_test_node  = igvn().intcon((int)bol_test);\n@@ -2605,3 +2552,3 @@\n-        _igvn.register_new_node_with_optimizer(mask);\n-        _phase->set_ctrl(mask, _phase->get_ctrl(p->at(0)));\n-        _igvn._worklist.push(mask);\n+        igvn().register_new_node_with_optimizer(mask);\n+        phase()->set_ctrl(mask, phase()->get_ctrl(p->at(0)));\n+        igvn()._worklist.push(mask);\n@@ -2680,2 +2627,2 @@\n-        _igvn.register_new_node_with_optimizer(longval);\n-        _phase->set_ctrl(longval, _phase->get_ctrl(first));\n+        igvn().register_new_node_with_optimizer(longval);\n+        phase()->set_ctrl(longval, phase()->get_ctrl(first));\n@@ -2722,2 +2669,2 @@\n-      _igvn.register_new_node_with_optimizer(vn);\n-      _phase->set_ctrl(vn, _phase->get_ctrl(first));\n+      igvn().register_new_node_with_optimizer(vn);\n+      phase()->set_ctrl(vn, phase()->get_ctrl(first));\n@@ -2726,1 +2673,1 @@\n-        _igvn.replace_node(pm, vn);\n+        igvn().replace_node(pm, vn);\n@@ -2728,1 +2675,1 @@\n-      _igvn._worklist.push(vn);\n+      igvn()._worklist.push(vn);\n@@ -2767,1 +2714,1 @@\n-  _phase->C->print_method(PHASE_SUPERWORD3_AFTER_OUTPUT, 4, cl);\n+  phase()->C->print_method(PHASE_SUPERWORD3_AFTER_OUTPUT, 4, cl);\n@@ -2790,1 +2737,1 @@\n-    Node* vn = new PopulateIndexNode(iv(), _igvn.intcon(1), vt);\n+    Node* vn = new PopulateIndexNode(iv(), igvn().intcon(1), vt);\n@@ -2792,2 +2739,2 @@\n-    _igvn.register_new_node_with_optimizer(vn);\n-    _phase->set_ctrl(vn, _phase->get_ctrl(opd));\n+    igvn().register_new_node_with_optimizer(vn);\n+    phase()->set_ctrl(vn, phase()->get_ctrl(opd));\n@@ -2814,1 +2761,1 @@\n-          _igvn.register_new_node_with_optimizer(cnt);\n+          igvn().register_new_node_with_optimizer(cnt);\n@@ -2819,1 +2766,1 @@\n-          _igvn.register_new_node_with_optimizer(cnt);\n+          igvn().register_new_node_with_optimizer(cnt);\n@@ -2821,2 +2768,2 @@\n-          _igvn.register_new_node_with_optimizer(cnt);\n-          _phase->set_ctrl(cnt, _phase->get_ctrl(opd));\n+          igvn().register_new_node_with_optimizer(cnt);\n+          phase()->set_ctrl(cnt, phase()->get_ctrl(opd));\n@@ -2831,2 +2778,2 @@\n-      _igvn.register_new_node_with_optimizer(cnt);\n-      _phase->set_ctrl(cnt, _phase->get_ctrl(opd));\n+      igvn().register_new_node_with_optimizer(cnt);\n+      phase()->set_ctrl(cnt, phase()->get_ctrl(opd));\n@@ -2850,2 +2797,2 @@\n-         _igvn.register_new_node_with_optimizer(conv);\n-         _phase->set_ctrl(conv, _phase->get_ctrl(opd));\n+         igvn().register_new_node_with_optimizer(conv);\n+         phase()->set_ctrl(conv, phase()->get_ctrl(opd));\n@@ -2859,2 +2806,2 @@\n-    _igvn.register_new_node_with_optimizer(vn);\n-    _phase->set_ctrl(vn, _phase->get_ctrl(opd));\n+    igvn().register_new_node_with_optimizer(vn);\n+    phase()->set_ctrl(vn, phase()->get_ctrl(opd));\n@@ -2889,2 +2836,2 @@\n-  _igvn.register_new_node_with_optimizer(pk);\n-  _phase->set_ctrl(pk, _phase->get_ctrl(opd));\n+  igvn().register_new_node_with_optimizer(pk);\n+  phase()->set_ctrl(pk, phase()->get_ctrl(opd));\n@@ -3053,2 +3000,2 @@\n-  visited.set(bb_idx(bb()));\n-  stack.push(bb());\n+  visited.set(bb_idx(cl()));\n+  stack.push(cl());\n@@ -3069,1 +3016,1 @@\n-            (!use->is_Phi() || n == bb())) {\n+            (!use->is_Phi() || n == cl())) {\n@@ -3300,1 +3247,1 @@\n-  VPointer p(s, phase(), lpt(), nullptr, false);\n+  VPointer p(s, vloop());\n@@ -3341,1 +3288,1 @@\n-  const Type* t = _igvn.type(n);\n+  const Type* t = igvn().type(n);\n@@ -3361,1 +3308,1 @@\n-  return _phase->C->get_alias_index(mem_ref->adr_type()) == _phase->C->get_alias_index(best_align_to_mem_ref->adr_type());\n+  return phase()->C->get_alias_index(mem_ref->adr_type()) == phase()->C->get_alias_index(best_align_to_mem_ref->adr_type());\n@@ -3441,1 +3388,1 @@\n-  assert(lp()->is_main_loop(), \"can only do alignment for main loop\");\n+  assert(cl()->is_main_loop(), \"can only do alignment for main loop\");\n@@ -3444,1 +3391,1 @@\n-  Opaque1Node* pre_opaq = lp()->pre_loop_end()->limit()->as_Opaque1();\n+  Opaque1Node* pre_opaq = vloop().pre_loop_end()->limit()->as_Opaque1();\n@@ -3450,1 +3397,1 @@\n-  Node* pre_ctrl = lp()->pre_loop_head()->in(LoopNode::EntryControl);\n+  Node* pre_ctrl = vloop().pre_loop_head()->in(LoopNode::EntryControl);\n@@ -3454,1 +3401,1 @@\n-  assert(orig_limit != nullptr && _igvn.type(orig_limit) != Type::TOP, \"\");\n+  assert(orig_limit != nullptr && igvn().type(orig_limit) != Type::TOP, \"\");\n@@ -3456,1 +3403,1 @@\n-  VPointer align_to_ref_p(align_to_ref, phase(), lpt(), nullptr, false);\n+  VPointer align_to_ref_p(align_to_ref, vloop());\n@@ -3650,1 +3597,1 @@\n-  Node* xboi = _igvn.intcon(is_sub ? -offset : offset);\n+  Node* xboi = igvn().intcon(is_sub ? -offset : offset);\n@@ -3655,1 +3602,1 @@\n-    if (_igvn.type(invar)->isa_long()) {\n+    if (igvn().type(invar)->isa_long()) {\n@@ -3660,1 +3607,1 @@\n-      _igvn.register_new_node_with_optimizer(invar);\n+      igvn().register_new_node_with_optimizer(invar);\n@@ -3668,2 +3615,2 @@\n-    _igvn.register_new_node_with_optimizer(xboi);\n-    _phase->set_ctrl(xboi, pre_ctrl);\n+    igvn().register_new_node_with_optimizer(xboi);\n+    phase()->set_ctrl(xboi, pre_ctrl);\n@@ -3679,1 +3626,1 @@\n-    _igvn.register_new_node_with_optimizer(xbase);\n+    igvn().register_new_node_with_optimizer(xbase);\n@@ -3683,1 +3630,1 @@\n-    _igvn.register_new_node_with_optimizer(xbase);\n+    igvn().register_new_node_with_optimizer(xbase);\n@@ -3691,2 +3638,2 @@\n-    _igvn.register_new_node_with_optimizer(xboi);\n-    _phase->set_ctrl(xboi, pre_ctrl);\n+    igvn().register_new_node_with_optimizer(xboi);\n+    phase()->set_ctrl(xboi, pre_ctrl);\n@@ -3699,1 +3646,1 @@\n-  Node* log2_abs_scale = _igvn.intcon(exact_log2(abs(scale)));\n+  Node* log2_abs_scale = igvn().intcon(exact_log2(abs(scale)));\n@@ -3701,2 +3648,2 @@\n-  _igvn.register_new_node_with_optimizer(XBOI);\n-  _phase->set_ctrl(XBOI, pre_ctrl);\n+  igvn().register_new_node_with_optimizer(XBOI);\n+  phase()->set_ctrl(XBOI, pre_ctrl);\n@@ -3716,2 +3663,2 @@\n-  _igvn.register_new_node_with_optimizer(XBOI_OP_old_limit);\n-  _phase->set_ctrl(XBOI_OP_old_limit, pre_ctrl);\n+  igvn().register_new_node_with_optimizer(XBOI_OP_old_limit);\n+  phase()->set_ctrl(XBOI_OP_old_limit, pre_ctrl);\n@@ -3726,1 +3673,1 @@\n-  Node* mask_AW = _igvn.intcon(AW-1);\n+  Node* mask_AW = igvn().intcon(AW-1);\n@@ -3728,2 +3675,2 @@\n-  _igvn.register_new_node_with_optimizer(adjust_pre_iter);\n-  _phase->set_ctrl(adjust_pre_iter, pre_ctrl);\n+  igvn().register_new_node_with_optimizer(adjust_pre_iter);\n+  phase()->set_ctrl(adjust_pre_iter, pre_ctrl);\n@@ -3742,2 +3689,2 @@\n-  _igvn.register_new_node_with_optimizer(new_limit);\n-  _phase->set_ctrl(new_limit, pre_ctrl);\n+  igvn().register_new_node_with_optimizer(new_limit);\n+  phase()->set_ctrl(new_limit, pre_ctrl);\n@@ -3751,2 +3698,2 @@\n-  _igvn.register_new_node_with_optimizer(constrained_limit);\n-  _phase->set_ctrl(constrained_limit, pre_ctrl);\n+  igvn().register_new_node_with_optimizer(constrained_limit);\n+  phase()->set_ctrl(constrained_limit, pre_ctrl);\n@@ -3756,16 +3703,1 @@\n-  _igvn.replace_input_of(pre_opaq, 1, constrained_limit);\n-}\n-\n-\/\/------------------------------init---------------------------\n-void SuperWord::init() {\n-  _dg.init();\n-  _packset.clear();\n-  _block.clear();\n-  _mem_slice_head.clear();\n-  _mem_slice_tail.clear();\n-  _node_info.clear();\n-  _align_to_ref = nullptr;\n-  _race_possible = 0;\n-  _early_return = false;\n-  _num_work_vecs = 0;\n-  _num_reductions = 0;\n+  igvn().replace_input_of(pre_opaq, 1, constrained_limit);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":162,"deletions":230,"binary":false,"changes":392,"status":"modified"},{"patch":"@@ -142,2 +142,0 @@\n-  void init() { _map.clear(); } \/\/ initialize\n-\n@@ -203,2 +201,0 @@\n- friend class VPointer;\n- friend class CMoveKit;\n@@ -206,3 +202,5 @@\n-  PhaseIdealLoop* _phase;\n-  Arena*          _arena;\n-  PhaseIterGVN   &_igvn;\n+  const VLoop& _vloop;\n+\n+  \/\/ Arena for small data structures. Large data structures are allocated in\n+  \/\/ VSharedData, and reused over many AutoVectorizations.\n+  Arena _arena;\n@@ -214,1 +212,1 @@\n-  GrowableArray<int> _bb_idx;            \/\/ Map from Node _idx to index within block\n+  GrowableArray<int> &_bb_idx;           \/\/ Map from Node _idx to index within block\n@@ -229,1 +227,1 @@\n-  SuperWord(PhaseIdealLoop* phase);\n+  SuperWord(const VLoop &vloop, VSharedData &vshared);\n@@ -231,1 +229,2 @@\n-  bool transform_loop(IdealLoopTree* lpt, bool do_optimization);\n+  \/\/ Attempt to run the SuperWord algorithm on the loop. Return true if we succeed.\n+  bool transform_loop();\n@@ -233,1 +232,2 @@\n-  void unrolling_analysis(int &local_loop_unroll_factor);\n+  \/\/ Decide if loop can eventually be vectorized, and what unrolling factor is required.\n+  static void unrolling_analysis(const VLoop &vloop, int &local_loop_unroll_factor);\n@@ -235,6 +235,9 @@\n-  \/\/ Accessors for VPointer\n-  PhaseIdealLoop* phase() const    { return _phase; }\n-  IdealLoopTree* lpt() const       { return _lpt; }\n-  PhiNode* iv() const              { return _iv; }\n-\n-  bool early_return() const        { return _early_return; }\n+  \/\/ VLoop Accessors\n+  const VLoop& vloop()        const { return _vloop; }\n+  PhaseIdealLoop* phase()     const { return vloop().phase(); }\n+  PhaseIterGVN& igvn()        const { return vloop().phase()->igvn(); }\n+  IdealLoopTree* lpt()        const { return vloop().lpt(); }\n+  CountedLoopNode* cl()       const { return vloop().cl(); }\n+  PhiNode* iv()               const { return vloop().iv(); }\n+  int iv_stride()             const { return cl()->stride_con(); }\n+  bool in_bb(const Node* n)   const { return vloop().in_bb(n); }\n@@ -244,5 +247,0 @@\n-  bool is_trace_superword_precondition() const {\n-    return TraceSuperWord ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PRECONDITION);\n-  }\n-\n@@ -251,1 +249,1 @@\n-    return _vtrace.is_trace(TraceAutoVectorizationTag::SW_TYPES);\n+    return vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_TYPES);\n@@ -256,1 +254,1 @@\n-    return _vtrace.is_trace(TraceAutoVectorizationTag::SW_ALIGNMENT);\n+    return vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_ALIGNMENT);\n@@ -261,1 +259,1 @@\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_MEMORY_SLICES);\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_MEMORY_SLICES);\n@@ -266,1 +264,1 @@\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_DEPENDENCE_GRAPH);\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_DEPENDENCE_GRAPH);\n@@ -271,1 +269,1 @@\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_ADJACENT_MEMOPS);\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_ADJACENT_MEMOPS);\n@@ -276,1 +274,1 @@\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_REJECTIONS);\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_REJECTIONS);\n@@ -281,1 +279,1 @@\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PACKSET);\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_PACKSET);\n@@ -286,1 +284,1 @@\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_INFO);\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_INFO);\n@@ -291,1 +289,1 @@\n-    return _vtrace.is_trace(TraceAutoVectorizationTag::SW_VERBOSE);\n+    return vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_VERBOSE);\n@@ -297,10 +295,9 @@\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PRECONDITION) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_TYPES) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_ALIGNMENT) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_MEMORY_SLICES) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_DEPENDENCE_GRAPH) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_ADJACENT_MEMOPS) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_REJECTIONS) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PACKSET) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_INFO) ||\n-           _vtrace.is_trace(TraceAutoVectorizationTag::SW_VERBOSE);\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_TYPES) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_ALIGNMENT) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_MEMORY_SLICES) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_DEPENDENCE_GRAPH) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_ADJACENT_MEMOPS) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_REJECTIONS) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_PACKSET) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_INFO) ||\n+           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_VERBOSE);\n@@ -310,1 +307,1 @@\n-    return _vtrace.is_trace(TraceAutoVectorizationTag::ALIGN_VECTOR) ||\n+    return vloop().vtrace().is_trace(TraceAutoVectorizationTag::ALIGN_VECTOR) ||\n@@ -321,2 +318,0 @@\n-  IdealLoopTree* _lpt;             \/\/ Current loop tree node\n-  CountedLoopNode* _lp;            \/\/ Current CountedLoopNode\n@@ -324,2 +319,0 @@\n-  Node*          _bb;              \/\/ Current basic block\n-  PhiNode*       _iv;              \/\/ Induction var\n@@ -327,1 +320,0 @@\n-  bool           _early_return;    \/\/ True if we do not initialize\n@@ -331,1 +323,0 @@\n-  NOT_PRODUCT(VTrace _vtrace);\n@@ -334,11 +325,1 @@\n-  Arena* arena()                   { return _arena; }\n-\n-  Node* bb()                       { return _bb; }\n-  void set_bb(Node* bb)            { _bb = bb; }\n-  void set_lpt(IdealLoopTree* lpt) { _lpt = lpt; }\n-  CountedLoopNode* lp() const      { return _lp; }\n-  void set_lp(CountedLoopNode* lp) {\n-    _lp = lp;\n-    _iv = lp->as_CountedLoop()->phi()->as_Phi();\n-  }\n-  int iv_stride() const            { return lp()->stride_con(); }\n+  Arena* arena()                   { return &_arena; }\n@@ -358,2 +339,0 @@\n-  const Node* ctrl(const Node* n) const { return _phase->has_ctrl(n) ? _phase->get_ctrl(n) : n; }\n-\n@@ -362,1 +341,0 @@\n-  bool in_bb(const Node* n) const  { return n != nullptr && n->outcnt() > 0 && ctrl(n) == _bb; }\n@@ -566,1 +544,0 @@\n-  void init();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":40,"deletions":63,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  flags(SW_PRECONDITION,      \"Trace SuperWord precondition\") \\\n+  flags(PRECONDITIONS,        \"Trace VLoop::check_preconditions\") \\\n@@ -115,1 +115,0 @@\n-        _tags.at_put(SW_PRECONDITION, set_bit);\n@@ -126,1 +125,0 @@\n-        _tags.at_put(SW_PRECONDITION, set_bit);\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,83 @@\n+bool VLoop::check_preconditions() {\n+#ifndef PRODUCT\n+  if (is_trace_preconditions()) {\n+    tty->print_cr(\"\\nVLoop::check_preconditions\");\n+    lpt()->dump_head();\n+    lpt()->head()->dump();\n+  }\n+#endif\n+\n+  const char* return_state = check_preconditions_helper();\n+  assert(return_state != nullptr, \"must have return state\");\n+  if (return_state == VLoop::SUCCESS) {\n+    return true; \/\/ success\n+  }\n+\n+#ifndef PRODUCT\n+  if (is_trace_preconditions()) {\n+    tty->print_cr(\"VLoop::check_preconditions: failed: %s\", return_state);\n+  }\n+#endif\n+  return false; \/\/ failure\n+}\n+\n+const char* VLoop::check_preconditions_helper() {\n+  \/\/ Only accept vector width that is power of 2\n+  int vector_width = Matcher::vector_width_in_bytes(T_BYTE);\n+  if (vector_width < 2 || !is_power_of_2(vector_width)) {\n+    return VLoop::FAILURE_VECTOR_WIDTH;\n+  }\n+\n+  \/\/ Only accept valid counted loops (int)\n+  if (!_lpt->_head->as_Loop()->is_valid_counted_loop(T_INT)) {\n+    return VLoop::FAILURE_VALID_COUNTED_LOOP;\n+  }\n+  _cl = _lpt->_head->as_CountedLoop();\n+  _iv = _cl->phi()->as_Phi();\n+\n+  if (_cl->is_vectorized_loop()) {\n+    return VLoop::FAILURE_ALREADY_VECTORIZED;\n+  }\n+\n+  if (_cl->is_unroll_only()) {\n+    return VLoop::FAILURE_UNROLL_ONLY;\n+  }\n+\n+  \/\/ Check for control flow in the body\n+  _cl_exit = _cl->loopexit();\n+  bool has_cfg = _cl_exit->in(0) != _cl;\n+  if (has_cfg && !is_allow_cfg()) {\n+#ifndef PRODUCT\n+    if (is_trace_preconditions()) {\n+      tty->print_cr(\"VLoop::check_preconditions: fails because of control flow.\");\n+      tty->print(\"  cl_exit %d\", _cl_exit->_idx); _cl_exit->dump();\n+      tty->print(\"  cl_exit->in(0) %d\", _cl_exit->in(0)->_idx); _cl_exit->in(0)->dump();\n+      tty->print(\"  lpt->_head %d\", _cl->_idx); _cl->dump();\n+      _lpt->dump_head();\n+    }\n+#endif\n+    return VLoop::FAILURE_CONTROL_FLOW;\n+  }\n+\n+  \/\/ Make sure the are no extra control users of the loop backedge\n+  if (_cl->back_control()->outcnt() != 1) {\n+    return VLoop::FAILURE_BACKEDGE;\n+  }\n+\n+  \/\/ To align vector memory accesses in the main-loop, we will have to adjust\n+  \/\/ the pre-loop limit.\n+  if (_cl->is_main_loop()) {\n+    CountedLoopEndNode* pre_end = _cl->find_pre_loop_end();\n+    if (pre_end == nullptr) {\n+      return VLoop::FAILURE_PRE_LOOP_LIMIT;\n+    }\n+    Node* pre_opaq1 = pre_end->limit();\n+    if (pre_opaq1->Opcode() != Op_Opaque1) {\n+      return VLoop::FAILURE_PRE_LOOP_LIMIT;\n+    }\n+    _pre_loop_end = pre_end;\n+  }\n+\n+  return VLoop::SUCCESS;\n+}\n+\n@@ -38,2 +121,1 @@\n-VPointer::VPointer(const MemNode* mem,\n-                   PhaseIdealLoop* phase, IdealLoopTree* lpt,\n+VPointer::VPointer(const MemNode* mem, const VLoop& vloop,\n@@ -41,2 +123,1 @@\n-  _mem(mem), _phase(phase), _lpt(lpt),\n-  _iv(lpt->_head->as_CountedLoop()->phi()->as_Phi()),\n+  _mem(mem), _vloop(vloop),\n@@ -49,1 +130,1 @@\n-  , _tracer(phase->C->directive()->trace_auto_vectorization_tags().at(TraceAutoVectorizationTag::POINTER_ANALYSIS))\n+  , _tracer(vloop.is_trace_pointer_analysis())\n@@ -112,1 +193,1 @@\n-  _mem(p->_mem), _phase(p->_phase), _lpt(p->_lpt), _iv(p->_iv),\n+  _mem(p->_mem), _vloop(p->_vloop),\n@@ -156,1 +237,1 @@\n-      return phase()->is_dominator(n_c, cl->pre_loop_head());\n+      return phase()->is_dominator(n_c, vloop().pre_loop_head());\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":88,"deletions":7,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -51,0 +51,115 @@\n+\/\/ Basic loop structure accessors and vectorization preconditions checking\n+class VLoop : public StackObj {\n+private:\n+  PhaseIdealLoop* const _phase;\n+  IdealLoopTree* const _lpt;\n+  const bool _allow_cfg;\n+  CountedLoopNode* _cl;\n+  Node* _cl_exit;\n+  PhiNode* _iv;\n+  CountedLoopEndNode* _pre_loop_end; \/\/ cache access to pre-loop for main loops only\n+\n+  NOT_PRODUCT(VTrace _vtrace;)\n+\n+  static constexpr char const* SUCCESS                    = \"success\";\n+  static constexpr char const* FAILURE_ALREADY_VECTORIZED = \"loop already vectorized\";\n+  static constexpr char const* FAILURE_UNROLL_ONLY        = \"loop only wants to be unrolled\";\n+  static constexpr char const* FAILURE_VECTOR_WIDTH       = \"vector_width must be power of 2\";\n+  static constexpr char const* FAILURE_VALID_COUNTED_LOOP = \"must be valid counted loop (int)\";\n+  static constexpr char const* FAILURE_CONTROL_FLOW       = \"control flow in loop not allowed\";\n+  static constexpr char const* FAILURE_BACKEDGE           = \"nodes on backedge not allowed\";\n+  static constexpr char const* FAILURE_PRE_LOOP_LIMIT     = \"main-loop must be able to adjust pre-loop-limit (not found)\";\n+\n+public:\n+  VLoop(IdealLoopTree* lpt, bool allow_cfg) :\n+    _phase     (lpt->_phase),\n+    _lpt       (lpt),\n+    _allow_cfg (allow_cfg),\n+    _cl        (nullptr),\n+    _cl_exit   (nullptr),\n+    _iv        (nullptr) {}\n+  NONCOPYABLE(VLoop);\n+\n+  IdealLoopTree* lpt()        const { return _lpt; };\n+  PhaseIdealLoop* phase()     const { return _phase; }\n+  CountedLoopNode* cl()       const { return _cl; };\n+  Node* cl_exit()             const { return _cl_exit; };\n+  PhiNode* iv()               const { return _iv; };\n+  int iv_stride()             const { return cl()->stride_con(); };\n+  bool is_allow_cfg()         const { return _allow_cfg; }\n+\n+  CountedLoopEndNode* pre_loop_end() const {\n+    assert(cl()->is_main_loop(), \"only main loop can reference pre-loop\");\n+    assert(_pre_loop_end != nullptr, \"must have found it\");\n+    return _pre_loop_end;\n+  };\n+\n+  CountedLoopNode* pre_loop_head() const {\n+    CountedLoopNode* head = pre_loop_end()->loopnode();\n+    assert(head != nullptr, \"must find head\");\n+    return head;\n+  };\n+\n+  \/\/ Estimate maximum size for data structures, to avoid repeated reallocation\n+  int estimated_body_length() const { return lpt()->_body.size(); };\n+  int estimated_node_count()  const { return (int)(1.10 * phase()->C->unique()); };\n+\n+#ifndef PRODUCT\n+  const VTrace& vtrace()      const { return _vtrace; }\n+\n+  bool is_trace_preconditions() const {\n+    return vtrace().is_trace(TraceAutoVectorizationTag::PRECONDITIONS);\n+  }\n+\n+  bool is_trace_pointer_analysis() const {\n+    return vtrace().is_trace(TraceAutoVectorizationTag::POINTER_ANALYSIS);\n+  }\n+#endif\n+\n+  \/\/ Is the node in the basic block of the loop?\n+  \/\/ We only accept any nodes which have the loop head as their ctrl.\n+  bool in_bb(const Node* n) const {\n+    const Node* ctrl = _phase->has_ctrl(n) ? _phase->get_ctrl(n) : n;\n+    return n != nullptr && n->outcnt() > 0 && ctrl == _cl;\n+  }\n+\n+  \/\/ Check if the loop passes some basic preconditions for vectorization.\n+  \/\/ Return indicates if analysis succeeded.\n+  bool check_preconditions();\n+\n+private:\n+  const char* check_preconditions_helper();\n+};\n+\n+\/\/ Optimization to keep allocation of large arrays in AutoVectorization low.\n+\/\/ We allocate the arrays once, and reuse them for multiple loops that we\n+\/\/ AutoVectorize, clearing them before every new use.\n+class VSharedData : public StackObj {\n+private:\n+  \/\/ Arena, used to allocate all arrays from.\n+  Arena _arena;\n+\n+  \/\/ An array that maps node->_idx to a much smaller idx, which is at most the\n+  \/\/ size of a loop body. This allow us to have smaller arrays for other data\n+  \/\/ structures, since we are using smaller indices.\n+  GrowableArray<int> _node_idx_to_loop_body_idx;\n+\n+public:\n+  VSharedData() :\n+    _arena(mtCompiler),\n+    _node_idx_to_loop_body_idx(&_arena, estimated_node_count(), 0, 0)\n+  {\n+  }\n+\n+  GrowableArray<int>& node_idx_to_loop_body_idx() {\n+    \/\/ Since this is a shared resource, we clear before every individual use.\n+    _node_idx_to_loop_body_idx.clear();\n+    return _node_idx_to_loop_body_idx;\n+  }\n+\n+private:\n+  static int estimated_node_count() {\n+    return (int)(1.10 * Compile::current()->unique());\n+  }\n+};\n+\n@@ -57,3 +172,1 @@\n-  PhaseIdealLoop* _phase;    \/\/ PhaseIdealLoop handle\n-  IdealLoopTree*  _lpt;      \/\/ Current IdealLoopTree\n-  PhiNode*        _iv;       \/\/ The loop induction variable\n+  const VLoop&    _vloop;\n@@ -77,3 +190,4 @@\n-  PhaseIdealLoop* phase() const { return _phase; }\n-  IdealLoopTree*  lpt() const   { return _lpt; }\n-  PhiNode*        iv() const    { return _iv; }\n+  const VLoop&    vloop() const { return _vloop; }\n+  PhaseIdealLoop* phase() const { return vloop().phase(); }\n+  IdealLoopTree*  lpt() const   { return vloop().lpt(); }\n+  PhiNode*        iv() const    { return vloop().iv(); }\n@@ -100,2 +214,6 @@\n-  VPointer(const MemNode* mem,\n-           PhaseIdealLoop* phase, IdealLoopTree* lpt,\n+  VPointer(const MemNode* mem, const VLoop& vloop) :\n+    VPointer(mem, vloop, nullptr, false) {}\n+  VPointer(const MemNode* mem, const VLoop& vloop, Node_Stack* nstack) :\n+    VPointer(mem, vloop, nstack, true) {}\n+ private:\n+  VPointer(const MemNode* mem, const VLoop& vloop,\n@@ -106,0 +224,1 @@\n+  NONCOPYABLE(VPointer);\n@@ -107,0 +226,1 @@\n+ public:\n@@ -146,1 +266,1 @@\n-      VPointer p_mem(mem, phase(), lpt(), nullptr, false);\n+      VPointer p_mem(mem, vloop());\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":129,"deletions":9,"binary":false,"changes":138,"status":"modified"}]}