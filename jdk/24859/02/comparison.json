{"files":[{"patch":"@@ -38,0 +38,2 @@\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n@@ -93,0 +95,1 @@\n+    private static final String STOP_CHECK = \"stopCheck\";\n@@ -99,12 +102,1 @@\n-                            CodeTransform.ofStateful(() -> {\n-                                Set<Label> priorLabels = new HashSet<>();\n-                                return (builder, element) -> {\n-                                    switch (element) {\n-                                        case LabelTarget target -> priorLabels.add(target.label());\n-                                        case BranchInstruction branch when priorLabels.contains(branch.target())\n-                                            -> builder.invokestatic(CD_Cancel, \"stopCheck\", ConstantDescs.MTD_void);\n-                                        default -> { }\n-                                    }\n-                                    builder.with(element);\n-                                };\n-                            })));\n+                            CodeTransform.ofStateful(StopCheckWeaver::new)));\n@@ -117,1 +109,1 @@\n-                .withMethodBody(\"stopCheck\", ConstantDescs.MTD_void, ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC, cob ->\n+                .withMethodBody(STOP_CHECK, ConstantDescs.MTD_void, ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC, cob ->\n@@ -126,0 +118,25 @@\n+    \/\/ This inserts calls to REPL.$Cancel$.stopCheck() at method start and prior to any backward branch\n+    private static class StopCheckWeaver implements CodeTransform {\n+\n+        private final Set<Label> priorLabels = new HashSet<>();\n+\n+        @Override\n+        public void atStart(CodeBuilder builder) {\n+            stopCheck(builder);\n+        }\n+\n+        @Override\n+        public void accept(CodeBuilder builder, CodeElement element) {\n+            switch (element) {\n+                case LabelTarget target -> priorLabels.add(target.label());\n+                case BranchInstruction branch when priorLabels.contains(branch.target()) -> stopCheck(builder);\n+                default -> { }\n+            }\n+            builder.with(element);\n+        };\n+\n+        private void stopCheck(CodeBuilder builder) {\n+            builder.invokestatic(CD_Cancel, STOP_CHECK, ConstantDescs.MTD_void);\n+        }\n+    }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/LocalExecutionControl.java","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+\n+import jdk.jshell.JShell;\n+\n+import static org.testng.Assert.fail;\n+\n+public abstract class AbstractStopExecutionTest extends KullaTesting {\n+\n+    private final Object lock = new Object();\n+    private boolean isStopped;\n+\n+    protected void scheduleStop(String src) throws InterruptedException {\n+        JShell state = getState();\n+        isStopped = false;\n+        StringWriter writer = new StringWriter();\n+        PrintWriter out = new PrintWriter(writer);\n+        Thread t = new Thread(() -> {\n+            int i = 1;\n+            int n = 30;\n+            synchronized (lock) {\n+                do {\n+                    state.stop();\n+                    if (!isStopped) {\n+                        out.println(\"Not stopped. Try again: \" + i);\n+                        try {\n+                            lock.wait(1000);\n+                        } catch (InterruptedException ignored) {\n+                        }\n+                    }\n+                } while (i++ < n && !isStopped);\n+                if (!isStopped) {\n+                    System.err.println(writer.toString());\n+                    fail(\"Evaluation was not stopped: '\" + src + \"'\");\n+                }\n+            }\n+        });\n+        t.start();\n+        assertEval(src);\n+        synchronized (lock) {\n+            out.println(\"Evaluation was stopped successfully: '\" + src + \"'\");\n+            isStopped = true;\n+            lock.notify();\n+        }\n+        \/\/ wait until the background thread finishes to prevent from calling 'stop' on closed state.\n+        t.join();\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/AbstractStopExecutionTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8355323\n+ * @summary Verify local execution can stop execution when there are no backward branches\n+ * @modules jdk.jshell\/jdk.internal.jshell.tool\n+ * @build KullaTesting TestingInputStream\n+ * @run testng LocalStopExecutionTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.internal.jshell.tool.StopDetectingInputStream;\n+import jdk.internal.jshell.tool.StopDetectingInputStream.State;\n+import jdk.jshell.JShell;\n+\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class LocalStopExecutionTest extends AbstractStopExecutionTest {\n+\n+    @BeforeMethod\n+    @Override\n+    public void setUp() {\n+        setUp(b -> b.executionEngine(\"local\"));\n+    }\n+\n+    @Test\n+    public void testVeryLongRecursion() throws InterruptedException {\n+        scheduleStop(\n+            \"\"\"\n+            \/\/ Note: there are no backward branches in this class\n+            new Runnable() {\n+                public void run() {\n+                    recurse(1);\n+                    recurse(10);\n+                    recurse(100);\n+                    recurse(1000);\n+                    recurse(10000);\n+                    recurse(100000);\n+                    recurse(1000000);\n+                }\n+                public void recurse(int depth) {\n+                    if (depth == 0)\n+                        return;\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                }\n+            }.run();\n+            \"\"\"\n+        );\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/LocalStopExecutionTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,0 @@\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n@@ -44,1 +42,0 @@\n-import jdk.jshell.JShell;\n@@ -48,1 +45,0 @@\n-import static org.testng.Assert.fail;\n@@ -51,4 +47,1 @@\n-public class StopExecutionTest extends KullaTesting {\n-\n-    private final Object lock = new Object();\n-    private boolean isStopped;\n+public class StopExecutionTest extends AbstractStopExecutionTest {\n@@ -71,36 +64,0 @@\n-    private void scheduleStop(String src) throws InterruptedException {\n-        JShell state = getState();\n-        isStopped = false;\n-        StringWriter writer = new StringWriter();\n-        PrintWriter out = new PrintWriter(writer);\n-        Thread t = new Thread(() -> {\n-            int i = 1;\n-            int n = 30;\n-            synchronized (lock) {\n-                do {\n-                    state.stop();\n-                    if (!isStopped) {\n-                        out.println(\"Not stopped. Try again: \" + i);\n-                        try {\n-                            lock.wait(1000);\n-                        } catch (InterruptedException ignored) {\n-                        }\n-                    }\n-                } while (i++ < n && !isStopped);\n-                if (!isStopped) {\n-                    System.err.println(writer.toString());\n-                    fail(\"Evaluation was not stopped: '\" + src + \"'\");\n-                }\n-            }\n-        });\n-        t.start();\n-        assertEval(src);\n-        synchronized (lock) {\n-            out.println(\"Evaluation was stopped successfully: '\" + src + \"'\");\n-            isStopped = true;\n-            lock.notify();\n-        }\n-        \/\/ wait until the background thread finishes to prevent from calling 'stop' on closed state.\n-        t.join();\n-    }\n-\n","filename":"test\/langtools\/jdk\/jshell\/StopExecutionTest.java","additions":2,"deletions":45,"binary":false,"changes":47,"status":"modified"}]}