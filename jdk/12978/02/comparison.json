{"files":[{"patch":"@@ -141,0 +141,1 @@\n+class OverflowNode;\n@@ -754,3 +755,4 @@\n-        DEFINE_CLASS_ID(FastLock,   Cmp, 0)\n-        DEFINE_CLASS_ID(FastUnlock, Cmp, 1)\n-        DEFINE_CLASS_ID(SubTypeCheck,Cmp, 2)\n+        DEFINE_CLASS_ID(FastLock,     Cmp, 0)\n+        DEFINE_CLASS_ID(FastUnlock,   Cmp, 1)\n+        DEFINE_CLASS_ID(SubTypeCheck, Cmp, 2)\n+        DEFINE_CLASS_ID(Overflow,     Cmp, 3)\n@@ -946,0 +948,1 @@\n+  DEFINE_CLASS_QUERY(Overflow)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -624,0 +624,17 @@\n+\/\/ Get reverse comparison(b == a) of a == b\n+Node* CmpNode::get_reverse_cmp() {\n+  Node* cmp1 = in(1);\n+  Node* cmp2 = in(2);\n+  if (cmp1 == nullptr) {\n+    return nullptr;\n+  }\n+\n+  for (DUIterator_Fast imax, i = cmp1->fast_outs(imax); i < imax; i++) {\n+    Node* u = cmp1->fast_out(i);\n+    if (u->Opcode() == Opcode() && u->in(1) == cmp2 && u->in(2) == cmp1) {\n+      return u;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -1470,0 +1487,42 @@\n+static bool is_arithmetic_cmp(Node* cmp) {\n+  if (!cmp->is_Cmp()) {\n+    return false;\n+  }\n+  const int cop = cmp->Opcode();\n+  if (cop == Op_FastLock || cop == Op_FastUnlock ||\n+      cop == Op_SubTypeCheck || cop == Op_VectorTest ||\n+      cmp->is_Overflow()) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+Node* BoolNode::Identity(PhaseGVN* phase) {\n+  Node* cmp = in(1);\n+  if (!is_arithmetic_cmp(cmp)) {\n+    return this;\n+  }\n+  if (phase->is_IterGVN() && outcnt() == 0) {\n+    \/\/ It is likely that bool is created but not immediately used during\n+    \/\/ parsing(PhaseGVN), it can be optimized out. Otherwise(PhaseIterGVN),\n+    \/\/ it's really a dead bool.\n+    return this;\n+  }\n+  \/\/ \"Bool (CmpX a b)\" is equivalent to \"Bool (CmpX b a)\"\n+  Node* reverse_cmp = NULL;\n+  if ((_test._test == BoolTest::eq || _test._test == BoolTest::ne) &&\n+      (reverse_cmp = cmp->as_Cmp()->get_reverse_cmp()) != nullptr) {\n+    for (DUIterator_Fast imax, i = reverse_cmp->fast_outs(imax); i < imax; i++) {\n+      Node* out = reverse_cmp->fast_out(i);\n+      \/\/ There is a cyclic case\n+      \/\/ Apply PhaseGVN for Bool A -> Generate Bool B in BoolNode::Ideal-> Apply Identity for B -> Find A.\n+      \/\/ In such case, type of A is not set, we can break such cyclic by checking the type of A.\n+      if (out->is_Bool() && out->as_Bool()->_test._test == _test._test &&\n+          phase->type_or_null(out) != nullptr) {\n+        return out;\n+      }\n+    }\n+  }\n+  return this;\n+}\n+\n@@ -1474,5 +1533,2 @@\n-  Node *cmp = in(1);\n-  if( !cmp->is_Sub() ) return nullptr;\n-  int cop = cmp->Opcode();\n-  if( cop == Op_FastLock || cop == Op_FastUnlock ||\n-      cmp->is_SubTypeCheck() || cop == Op_VectorTest ) {\n+  Node* cmp = in(1);\n+  if (!is_arithmetic_cmp(cmp)) {\n@@ -1483,1 +1539,3 @@\n-  if( !cmp1 ) return nullptr;\n+  if (!cmp1) {\n+    return nullptr;\n+  }\n@@ -1491,0 +1549,1 @@\n+  const int cop = cmp->Opcode();\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":65,"deletions":6,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+  Node* get_reverse_cmp();\n@@ -349,0 +350,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -32,1 +33,1 @@\n- * @bug 8278228\n+ * @bug 8278228 8303970\n@@ -60,1 +61,31 @@\n-    @Run(test = \"test\")\n+    @Test\n+    @IR(counts = { IRNode.IF, \"1\" })\n+    public static void test1(int a, int b) {\n+        if (a == b) {\n+            int_field = 0x42;\n+        } else {\n+            int_field = 42;\n+        }\n+        if (b == a) {\n+            int_field = 0x42;\n+        } else {\n+            int_field = 42;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.IF, \"1\" })\n+    public static void test2(int a, int b) {\n+        if (a != b) {\n+            int_field = 0x42;\n+        } else {\n+            int_field = 42;\n+        }\n+        if (b != a) {\n+            int_field = 0x42;\n+        } else {\n+            int_field = 42;\n+        }\n+    }\n+\n+    @Run(test = {\"test\", \"test1\", \"test2\"})\n@@ -64,0 +95,4 @@\n+        test1(42, 0x42);\n+        test1(0x42, 0x42);\n+        test2(42, 0x42);\n+        test2(0x42, 0x42);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestBackToBackIfs.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"}]}