{"files":[{"patch":"@@ -141,0 +141,1 @@\n+class OverflowNode;\n@@ -754,3 +755,4 @@\n-        DEFINE_CLASS_ID(FastLock,   Cmp, 0)\n-        DEFINE_CLASS_ID(FastUnlock, Cmp, 1)\n-        DEFINE_CLASS_ID(SubTypeCheck,Cmp, 2)\n+        DEFINE_CLASS_ID(FastLock,     Cmp, 0)\n+        DEFINE_CLASS_ID(FastUnlock,   Cmp, 1)\n+        DEFINE_CLASS_ID(SubTypeCheck, Cmp, 2)\n+        DEFINE_CLASS_ID(Overflow,     Cmp, 3)\n@@ -946,0 +948,1 @@\n+  DEFINE_CLASS_QUERY(Overflow)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1470,0 +1470,50 @@\n+static Node* get_reverse_cmp(int cmp_op, Node* cmp1, Node* cmp2) {\n+  for (DUIterator_Fast imax, i = cmp1->fast_outs(imax); i < imax; i++) {\n+    Node* u = cmp1->fast_out(i);\n+    if (u->Opcode() == cmp_op && u->in(1) == cmp2 && u->in(2) == cmp1) {\n+      return u;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+static bool is_arithmetic_cmp(Node* cmp) {\n+  if (!cmp->is_Cmp()) {\n+    return false;\n+  }\n+  const int cop = cmp->Opcode();\n+  if (cop == Op_FastLock || cop == Op_FastUnlock ||\n+      cop == Op_SubTypeCheck || cop == Op_VectorTest ||\n+      cmp->is_Overflow()) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+Node* BoolNode::Identity(PhaseGVN* phase) {\n+  \/\/ \"Bool (CmpX a b)\" is equivalent to \"Bool (CmpX b a)\"\n+  Node *cmp = in(1);\n+  if (!is_arithmetic_cmp(cmp)) {\n+    return this;\n+  }\n+  if (phase->is_IterGVN() && outcnt() == 0) {\n+    \/\/ During parsing, empty uses of bool is tolerable. During iterative GVN,\n+    \/\/ we don't aggressively replace bool whose use is empty with existing node.\n+    return this;\n+  }\n+  Node* cmp1 = cmp->in(1);\n+  Node* cmp2 = cmp->in(2);\n+  Node* reverse_cmp = NULL;\n+  if ((_test._test == BoolTest::eq || _test._test == BoolTest::ne) &&\n+      (reverse_cmp = get_reverse_cmp(cmp->Opcode(), cmp1, cmp2)) != nullptr) {\n+    for (DUIterator_Fast imax, i = reverse_cmp->fast_outs(imax); i < imax; i++) {\n+      Node* out = reverse_cmp->fast_out(i);\n+      if (out->is_Bool() && out->as_Bool()->_test._test == _test._test &&\n+          phase->type_or_null(out) != nullptr) {\n+        return out;\n+      }\n+    }\n+  }\n+  return this;\n+}\n+\n@@ -1474,5 +1524,2 @@\n-  Node *cmp = in(1);\n-  if( !cmp->is_Sub() ) return nullptr;\n-  int cop = cmp->Opcode();\n-  if( cop == Op_FastLock || cop == Op_FastUnlock ||\n-      cmp->is_SubTypeCheck() || cop == Op_VectorTest ) {\n+  Node* cmp = in(1);\n+  if (!is_arithmetic_cmp(cmp)) {\n@@ -1483,1 +1530,3 @@\n-  if( !cmp1 ) return nullptr;\n+  if (!cmp1) {\n+    return nullptr;\n+  }\n@@ -1491,0 +1540,1 @@\n+  const int cop = cmp->Opcode();\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":56,"deletions":6,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -349,0 +349,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -60,1 +61,16 @@\n-    @Run(test = \"test\")\n+    @Test\n+    @IR(counts = { IRNode.IF, \"1\" })\n+    public static void test1(int a, int b) {\n+        if (a == b) {\n+            int_field = 0x42;\n+        } else {\n+            int_field = 42;\n+        }\n+        if (b == a) {\n+            int_field = 0x42;\n+        } else {\n+            int_field = 42;\n+        }\n+    }\n+\n+    @Run(test = {\"test\", \"test1\"})\n@@ -64,0 +80,2 @@\n+        test1(42, 0x42);\n+        test1(0x42, 0x42);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestBackToBackIfs.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"}]}