{"files":[{"patch":"@@ -624,0 +624,17 @@\n+\/\/ Get reverse comparison(b == a) of a == b\n+Node* CmpNode::get_reverse_cmp() {\n+  Node* cmp1 = in(1);\n+  Node* cmp2 = in(2);\n+  if (cmp1 == nullptr) {\n+    return nullptr;\n+  }\n+\n+  for (DUIterator_Fast imax, i = cmp1->fast_outs(imax); i < imax; i++) {\n+    Node* u = cmp1->fast_out(i);\n+    if (u->Opcode() == Opcode() && u->in(1) == cmp2 && u->in(2) == cmp1) {\n+      return u;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -1470,10 +1487,0 @@\n-static Node* get_reverse_cmp(int cmp_op, Node* cmp1, Node* cmp2) {\n-  for (DUIterator_Fast imax, i = cmp1->fast_outs(imax); i < imax; i++) {\n-    Node* u = cmp1->fast_out(i);\n-    if (u->Opcode() == cmp_op && u->in(1) == cmp2 && u->in(2) == cmp1) {\n-      return u;\n-    }\n-  }\n-  return nullptr;\n-}\n-\n@@ -1494,2 +1501,1 @@\n-  \/\/ \"Bool (CmpX a b)\" is equivalent to \"Bool (CmpX b a)\"\n-  Node *cmp = in(1);\n+  Node* cmp = in(1);\n@@ -1500,2 +1506,3 @@\n-    \/\/ During parsing, empty uses of bool is tolerable. During iterative GVN,\n-    \/\/ we don't aggressively replace bool whose use is empty with existing node.\n+    \/\/ It is likely that bool is created but not immediately used during\n+    \/\/ parsing(PhaseGVN), it can be optimized out. Otherwise(PhaseIterGVN),\n+    \/\/ it's really a dead bool.\n@@ -1504,2 +1511,1 @@\n-  Node* cmp1 = cmp->in(1);\n-  Node* cmp2 = cmp->in(2);\n+  \/\/ \"Bool (CmpX a b)\" is equivalent to \"Bool (CmpX b a)\"\n@@ -1508,1 +1514,1 @@\n-      (reverse_cmp = get_reverse_cmp(cmp->Opcode(), cmp1, cmp2)) != nullptr) {\n+      (reverse_cmp = cmp->as_Cmp()->get_reverse_cmp()) != nullptr) {\n@@ -1511,0 +1517,3 @@\n+      \/\/ There is a cyclic case\n+      \/\/ Apply PhaseGVN for Bool A -> Generate Bool B in BoolNode::Ideal-> Apply Identity for B -> Find A.\n+      \/\/ In such case, type of A is not set, we can break such cyclic by checking the type of A.\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+  Node* get_reverse_cmp();\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @bug 8278228\n+ * @bug 8278228 8303970\n@@ -76,1 +76,16 @@\n-    @Run(test = {\"test\", \"test1\"})\n+    @Test\n+    @IR(counts = { IRNode.IF, \"1\" })\n+    public static void test2(int a, int b) {\n+        if (a != b) {\n+            int_field = 0x42;\n+        } else {\n+            int_field = 42;\n+        }\n+        if (b != a) {\n+            int_field = 0x42;\n+        } else {\n+            int_field = 42;\n+        }\n+    }\n+\n+    @Run(test = {\"test\", \"test1\", \"test2\"})\n@@ -82,0 +97,2 @@\n+        test2(42, 0x42);\n+        test2(0x42, 0x42);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestBackToBackIfs.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"}]}