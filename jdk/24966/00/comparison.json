{"files":[{"patch":"@@ -2360,0 +2360,298 @@\n+\n+uint PureCallNode::size_of() const { return sizeof(*this); }\n+bool PureCallNode::cmp(const Node& n) const {\n+  const PureCallNode& call = static_cast<const PureCallNode&>(n);\n+  return Opcode() == call.Opcode() && _tf->eq(call._tf) && _addr == call._addr && _name == call._name;\n+}\n+uint PureCallNode::hash() const {\n+  return Node::hash() + _tf->hash() + reinterpret_cast<uintptr_t>(_addr) + reinterpret_cast<uintptr_t>(_name);\n+}\n+PureCallNode::PureCallNode(Compile* C, uint required, const TypeFunc* tf, address addr, const char* name) : Node(required) {\n+  init_class_id(Class_PureCall);\n+  add_flag(Flag_is_macro);\n+  C->add_macro_node(this);\n+  _tf = tf;\n+  _addr = addr;\n+  _name = name;\n+}\n+PureFloatingModuloNode::PureFloatingModuloNode(Compile* C, uint required, const TypeFunc* tf, address addr, const char* name)\n+    : PureCallNode(C, required, tf, addr, name) {\n+  init_class_id(Class_PureFloatingModulo);\n+}\n+PureModFNode::PureModFNode(Compile* C, Node* ctrl, Node* lhs, Node* rhs)\n+    : PureFloatingModuloNode(C, 3, OptoRuntime::modf_Type(), CAST_FROM_FN_PTR(address, SharedRuntime::frem), \"frem\") {\n+  init_class_id(Class_PureModF);\n+}\n+PureModDNode::PureModDNode(Compile* C, Node* ctrl, Node* lhs, Node* rhs)\n+    : PureFloatingModuloNode(C, 5, OptoRuntime::Math_DD_D_Type(), CAST_FROM_FN_PTR(address, SharedRuntime::drem), \"drem\") {\n+  init_class_id(Class_PureModF);\n+}\n+PureModFNode* PureModFNode::make(Compile* C, Node* ctrl, Node* lhs, Node* rhs) {\n+  auto* node = new PureModFNode(C, ctrl, lhs, rhs);\n+  node->init_req(Control, ctrl);\n+  node->init_req(Parms, lhs);\n+  node->init_req(Parms + 1, rhs);\n+  return node;\n+}\n+PureModDNode* PureModDNode::make(Compile* C, Node* ctrl, Node* lhs, Node* rhs) {\n+  auto* node = new PureModDNode(C, ctrl, lhs, rhs);\n+  node->init_req(Control, ctrl);\n+  node->init_req(Parms, lhs);\n+  node->init_req(Parms + 1, C->top());\n+  node->init_req(Parms + 2, rhs);\n+  node->init_req(Parms + 3, C->top());\n+  return node;\n+}\n+\n+ProjNode* PureCallNode::proj_out_or_null(uint which_proj) const {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* p = fast_out(i);\n+    if (p->is_Proj()) {\n+      ProjNode* proj = p->as_Proj();\n+      if (proj->_con == which_proj) {\n+        return proj;\n+      }\n+    } else {\n+      assert(p == this && is_Start(), \"else must be proj\");\n+      continue;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+void PureCallNode::extract_projections(Node*& ctrl_proj, Node*& data_proj) const {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    ProjNode* pn = fast_out(i)->as_Proj();\n+    if (pn->outcnt() == 0) {\n+      continue;\n+    }\n+    switch (pn->_con) {\n+    case TypeFunc::Control:\n+      ctrl_proj = pn;\n+      break;\n+    case TypeFunc::Parms:\n+      data_proj = pn;\n+      break;\n+    default:\n+      assert(false, \"unexpected projection type for a pure function\");\n+    }\n+  }\n+}\n+\n+void PureCallNode::replace_with_con(PhaseIterGVN* phase, const Type* con) {\n+  Compile* C = phase->C;\n+  Node* con_node = phase->makecon(con);\n+  Node* ctrl_proj = nullptr;\n+  Node* data_proj = nullptr;\n+  extract_projections(ctrl_proj, data_proj);\n+  if (ctrl_proj == nullptr) {\n+    return;\n+  }\n+  phase->replace_node(ctrl_proj, in(Control));\n+  if (data_proj != nullptr) {\n+    phase->replace_node(data_proj, con_node);\n+  }\n+  phase->replace_node(this, C->top());\n+  C->remove_macro_node(this);\n+}\n+\n+void PureCallNode::remove_unused_node(PhaseIterGVN* phase) {\n+  Compile* C = phase->C;\n+  Node* ctrl_proj = nullptr;\n+  Node* data_proj = nullptr;\n+  extract_projections(ctrl_proj, data_proj);\n+  assert(data_proj == nullptr, \"result is not unused\");\n+  if (ctrl_proj == nullptr) {\n+    return;\n+  }\n+  phase->replace_node(ctrl_proj, in(Control));\n+  phase->replace_node(this, C->top());\n+  C->remove_macro_node(this);\n+}\n+\n+Node* PureCallNode::expand_macro(Compile* C) const {\n+  CallNode* call = new CallLeafNode(tf(), addr(), name(), TypeRawPtr::BOTTOM);\n+  call->init_req(TypeFunc::Control, in(Control));\n+  call->init_req(TypeFunc::I_O, C->top());\n+  call->init_req(TypeFunc::Memory, C->top());\n+  call->init_req(TypeFunc::ReturnAdr, C->top());\n+  call->init_req(TypeFunc::FramePtr, C->top());\n+  for (uint i = 0; i < tf()->domain()->cnt() - TypeFunc::Parms; i++) {\n+    call->init_req(TypeFunc::Parms + i, in(Parms + i));\n+  }\n+  return call;\n+}\n+\n+const Type* PureCallNode::bottom_type() const {\n+  return tf()->range();\n+}\n+const Type* PureCallNode::Value(PhaseGVN* phase) const {\n+  if (in(0) == nullptr || phase->type(in(0)) == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  return bottom_type();\n+}\n+bool PureCallNode::remove_if_result_is_unused(PhaseIterGVN* igvn) {\n+  bool result_is_unused = proj_out_or_null(TypeFunc::Parms) == nullptr;\n+  bool not_dead = proj_out_or_null(TypeFunc::Control) != nullptr;\n+  if (result_is_unused && not_dead) {\n+    remove_unused_node(igvn);\n+    return true;\n+  }\n+  return false;\n+}\n+Node* PureCallNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (!can_reshape) {\n+    return nullptr;\n+  }\n+\n+  remove_if_result_is_unused(phase->is_IterGVN());\n+  return nullptr;\n+}\n+\n+#ifndef PRODUCT\n+void PureCallNode::dump_spec(outputStream* st) const {\n+  st->print(\"# %s\", name());\n+}\n+#endif\n+\n+Node* PureModFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (!can_reshape) {\n+    return nullptr;\n+  }\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+\n+  if (remove_if_result_is_unused(igvn)) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type(dividend());\n+  const Type* t2 = phase->type(divisor());\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return phase->C->top();\n+  }\n+\n+  \/\/ If either number is not a constant, we know nothing.\n+  if ((t1->base() != Type::FloatCon) || (t2->base() != Type::FloatCon)) {\n+    return nullptr; \/\/ note: x%x can be either NaN or 0\n+  }\n+\n+  float f1 = t1->getf();\n+  float f2 = t2->getf();\n+  jint x1 = jint_cast(f1); \/\/ note:  *(int*)&f1, not just (int)f1\n+  jint x2 = jint_cast(f2);\n+\n+  \/\/ If either is a NaN, return an input NaN\n+  if (g_isnan(f1)) {\n+    replace_with_con(igvn, t1);\n+    return nullptr;\n+  }\n+  if (g_isnan(f2)) {\n+    replace_with_con(igvn, t2);\n+    return nullptr;\n+  }\n+\n+  \/\/ If an operand is infinity or the divisor is +\/- zero, punt.\n+  if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jint) {\n+    return nullptr;\n+  }\n+\n+  \/\/ We must be modulo'ing 2 float constants.\n+  \/\/ Make sure that the sign of the fmod is equal to the sign of the dividend\n+  jint xr = jint_cast(fmod(f1, f2));\n+  if ((x1 ^ xr) < 0) {\n+    xr ^= min_jint;\n+  }\n+\n+  replace_with_con(igvn, TypeF::make(jfloat_cast(xr)));\n+  return nullptr;\n+}\n+\n+Node* PureModDNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (!can_reshape) {\n+    return nullptr;\n+  }\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+\n+  if (remove_if_result_is_unused(igvn)) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type(dividend());\n+  const Type* t2 = phase->type(divisor());\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return nullptr;\n+  }\n+\n+  \/\/ If either number is not a constant, we know nothing.\n+  if ((t1->base() != Type::DoubleCon) || (t2->base() != Type::DoubleCon)) {\n+    return nullptr; \/\/ note: x%x can be either NaN or 0\n+  }\n+\n+  double f1 = t1->getd();\n+  double f2 = t2->getd();\n+  jlong x1 = jlong_cast(f1); \/\/ note:  *(long*)&f1, not just (long)f1\n+  jlong x2 = jlong_cast(f2);\n+\n+  \/\/ If either is a NaN, return an input NaN\n+  if (g_isnan(f1)) {\n+    replace_with_con(igvn, t1);\n+    return nullptr;\n+  }\n+  if (g_isnan(f2)) {\n+    replace_with_con(igvn, t2);\n+    return nullptr;\n+  }\n+\n+  \/\/ If an operand is infinity or the divisor is +\/- zero, punt.\n+  if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jlong) {\n+    return nullptr;\n+  }\n+\n+  \/\/ We must be modulo'ing 2 double constants.\n+  \/\/ Make sure that the sign of the fmod is equal to the sign of the dividend\n+  jlong xr = jlong_cast(fmod(f1, f2));\n+  if ((x1 ^ xr) < 0) {\n+    xr ^= min_jlong;\n+  }\n+\n+  replace_with_con(igvn, TypeD::make(jdouble_cast(xr)));\n+  return nullptr;\n+}\n+\n+Node* PureModFNode::dividend() const { return in(Parms); }\n+Node* PureModFNode::divisor() const { return in(Parms + 1); }\n+Node* PureModDNode::dividend() const { return in(Parms); }\n+Node* PureModDNode::divisor() const { return in(Parms + 2); }\n+\n+PureNativeMathNode::PureNativeMathNode(Compile* C, uint required, const TypeFunc* tf, address addr, const char* name)\n+    : PureCallNode(C, required, tf, addr, name) {\n+  init_class_id(Class_PureNativeMath);\n+}\n+PureUnaryNativeMathNode::PureUnaryNativeMathNode(Compile* C, address addr, const char* name)\n+    : PureNativeMathNode(C, 3, OptoRuntime::Math_D_D_Type(), addr, name) {\n+  init_class_id(Class_PureUnaryNativeMath);\n+}\n+PureBinaryNativeMathNode::PureBinaryNativeMathNode(Compile* C, address addr, const char* name)\n+    : PureNativeMathNode(C, 5, OptoRuntime::Math_DD_D_Type(), addr, name) {\n+  init_class_id(Class_PureBinaryNativeMath);\n+}\n+\n+PureUnaryNativeMathNode* PureUnaryNativeMathNode::make(Compile* C, address addr, const char* name, Node* ctrl, Node* arg) {\n+  auto* node = new PureUnaryNativeMathNode(C, addr, name);\n+  node->init_req(Control, ctrl);\n+  node->init_req(Parms, arg);\n+  node->init_req(Parms + 1, C->top());\n+  return node;\n+}\n+PureBinaryNativeMathNode* PureBinaryNativeMathNode::make(Compile* C, address addr, const char* name, Node* ctrl, Node* lhs, Node* rhs) {\n+  auto* node = new PureBinaryNativeMathNode(C, addr, name);\n+  node->init_req(Control, ctrl);\n+  node->init_req(Parms, lhs);\n+  node->init_req(Parms + 1, C->top());\n+  node->init_req(Parms + 2, rhs);\n+  node->init_req(Parms + 3, C->top());\n+  return node;\n+}\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":298,"deletions":0,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -58,0 +58,7 @@\n+class PureCallNode;\n+class   PureFloatingModuloNode;\n+class     PureModFNode;\n+class     PureModDNode;\n+class   PureNativeMathNode;\n+class     PureUnaryNativeMathNode;\n+class     PureBinaryNativeMathNode;\n@@ -1265,0 +1272,98 @@\n+\n+\/\/------------------------------PureCall-----------------------------------\n+class PureCallNode : public Node {\n+  uint size_of() const override; \/\/ Size is bigger\n+  bool cmp(const Node& n) const override;\n+  uint hash() const override;\n+\n+protected:\n+  const TypeFunc* _tf;\n+  address _addr;\n+  const char* _name;\n+\n+  PureCallNode(Compile* C, uint required, const TypeFunc* tf, address addr, const char* name);\n+\n+  bool remove_if_result_is_unused(PhaseIterGVN* phase);\n+\n+public:\n+  enum {\n+    Control = 0,\n+    Parms = 1,\n+  };\n+\n+  int Opcode() const override;\n+\n+  const Type* bottom_type() const override;\n+  const Type* Value(PhaseGVN* phase) const override;\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape) override;\n+  Node* Identity(PhaseGVN* phase) override { return this; }\n+\n+  const TypeFunc* tf() const { return _tf; }\n+  address addr() const { return _addr; }\n+  const char* name() const { return _name; }\n+  bool is_CFG() const override { return true; }\n+  bool depends_only_on_test() const override { return false; }\n+\n+  ProjNode* proj_out_or_null(uint which_proj) const;\n+  void remove_unused_node(PhaseIterGVN* phase);\n+  void replace_with_con(PhaseIterGVN* phase, const Type* con);\n+  void extract_projections(Node*& ctrl_proj, Node*& data_proj) const;\n+\n+  Node* expand_macro(Compile* C) const;\n+\n+  NOT_PRODUCT(void dump_spec(outputStream* st) const override;)\n+};\n+\n+class PureFloatingModuloNode : public PureCallNode {\n+protected:\n+  PureFloatingModuloNode(Compile* C, uint required, const TypeFunc* tf, address addr, const char* name);\n+  virtual Node* dividend() const = 0;\n+  virtual Node* divisor() const = 0;\n+\n+public:\n+  virtual int Opcode() const;\n+};\n+\n+class PureModFNode : public PureFloatingModuloNode {\n+  PureModFNode(Compile* C, Node* ctrl, Node* lhs, Node* rhs);\n+  Node* dividend() const override;\n+  Node* divisor() const override;\n+\n+public:\n+  static PureModFNode* make(Compile* C, Node* ctrl, Node* lhs, Node* rhs);\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape) override;\n+  int Opcode() const override;\n+};\n+class PureModDNode : public PureFloatingModuloNode {\n+  PureModDNode(Compile* C, Node* ctrl, Node* lhs, Node* rhs);\n+  Node* dividend() const override;\n+  Node* divisor() const override;\n+\n+public:\n+  static PureModDNode* make(Compile* C, Node* ctrl, Node* lhs, Node* rhs);\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape) override;\n+  int Opcode() const override;\n+};\n+class PureNativeMathNode : public PureCallNode {\n+protected:\n+  PureNativeMathNode(Compile* C, uint required, const TypeFunc* tf, address addr, const char* name);\n+\n+public:\n+  int Opcode() const override;\n+};\n+class PureUnaryNativeMathNode : public PureNativeMathNode {\n+protected:\n+  PureUnaryNativeMathNode(Compile* C, address addr, const char* name);\n+\n+public:\n+  int Opcode() const override;\n+  static PureUnaryNativeMathNode* make(Compile* C, address addr, const char* name, Node* ctrl, Node* arg);\n+};\n+class PureBinaryNativeMathNode : public PureNativeMathNode {\n+protected:\n+  PureBinaryNativeMathNode(Compile* C, address addr, const char* name);\n+\n+public:\n+  int Opcode() const override;\n+  static PureBinaryNativeMathNode* make(Compile* C, address addr, const char* name, Node* ctrl, Node* lhs, Node* rhs);\n+};\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":105,"deletions":0,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -249,2 +249,0 @@\n-macro(ModD)\n-macro(ModF)\n@@ -307,0 +305,7 @@\n+macro(PureBinaryNativeMath)\n+macro(PureCall)\n+macro(PureFloatingModulo)\n+macro(PureModD)\n+macro(PureModF)\n+macro(PureNativeMath)\n+macro(PureUnaryNativeMath)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3241,1 +3241,0 @@\n-  case Op_ModF:\n@@ -3264,1 +3263,0 @@\n-  case Op_ModD:\n@@ -3285,1 +3283,1 @@\n-  case Op_CallLeaf:\n+  case Op_CallLeaf: \/\/ including expanded PureCallNode\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,17 +45,0 @@\n-ModFloatingNode::ModFloatingNode(Compile* C, const TypeFunc* tf, const char* name) : CallLeafNode(tf, nullptr, name, TypeRawPtr::BOTTOM) {\n-  add_flag(Flag_is_macro);\n-  C->add_macro_node(this);\n-}\n-\n-ModDNode::ModDNode(Compile* C, Node* a, Node* b) : ModFloatingNode(C, OptoRuntime::Math_DD_D_Type(), \"drem\") {\n-  init_req(TypeFunc::Parms + 0, a);\n-  init_req(TypeFunc::Parms + 1, C->top());\n-  init_req(TypeFunc::Parms + 2, b);\n-  init_req(TypeFunc::Parms + 3, C->top());\n-}\n-\n-ModFNode::ModFNode(Compile* C, Node* a, Node* b) : ModFloatingNode(C, OptoRuntime::modf_Type(), \"frem\") {\n-  init_req(TypeFunc::Parms + 0, a);\n-  init_req(TypeFunc::Parms + 1, b);\n-}\n-\n@@ -1519,133 +1502,0 @@\n-Node* ModFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  if (!can_reshape) {\n-    return nullptr;\n-  }\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n-\n-  bool result_is_unused = proj_out_or_null(TypeFunc::Parms) == nullptr;\n-  bool not_dead = proj_out_or_null(TypeFunc::Control) != nullptr;\n-  if (result_is_unused && not_dead) {\n-    return replace_with_con(igvn, TypeF::make(0.));\n-  }\n-\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type* t1 = phase->type(dividend());\n-  const Type* t2 = phase->type(divisor());\n-  if (t1 == Type::TOP || t2 == Type::TOP) {\n-    return phase->C->top();\n-  }\n-\n-  \/\/ If either number is not a constant, we know nothing.\n-  if ((t1->base() != Type::FloatCon) || (t2->base() != Type::FloatCon)) {\n-    return nullptr; \/\/ note: x%x can be either NaN or 0\n-  }\n-\n-  float f1 = t1->getf();\n-  float f2 = t2->getf();\n-  jint x1 = jint_cast(f1); \/\/ note:  *(int*)&f1, not just (int)f1\n-  jint x2 = jint_cast(f2);\n-\n-  \/\/ If either is a NaN, return an input NaN\n-  if (g_isnan(f1)) {\n-    return replace_with_con(igvn, t1);\n-  }\n-  if (g_isnan(f2)) {\n-    return replace_with_con(igvn, t2);\n-  }\n-\n-  \/\/ If an operand is infinity or the divisor is +\/- zero, punt.\n-  if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jint) {\n-    return nullptr;\n-  }\n-\n-  \/\/ We must be modulo'ing 2 float constants.\n-  \/\/ Make sure that the sign of the fmod is equal to the sign of the dividend\n-  jint xr = jint_cast(fmod(f1, f2));\n-  if ((x1 ^ xr) < 0) {\n-    xr ^= min_jint;\n-  }\n-\n-  return replace_with_con(igvn, TypeF::make(jfloat_cast(xr)));\n-}\n-\n-Node* ModDNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  if (!can_reshape) {\n-    return nullptr;\n-  }\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n-\n-  bool result_is_unused = proj_out_or_null(TypeFunc::Parms) == nullptr;\n-  bool not_dead = proj_out_or_null(TypeFunc::Control) != nullptr;\n-  if (result_is_unused && not_dead) {\n-    return replace_with_con(igvn, TypeD::make(0.));\n-  }\n-\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type* t1 = phase->type(dividend());\n-  const Type* t2 = phase->type(divisor());\n-  if (t1 == Type::TOP || t2 == Type::TOP) {\n-    return nullptr;\n-  }\n-\n-  \/\/ If either number is not a constant, we know nothing.\n-  if ((t1->base() != Type::DoubleCon) || (t2->base() != Type::DoubleCon)) {\n-    return nullptr; \/\/ note: x%x can be either NaN or 0\n-  }\n-\n-  double f1 = t1->getd();\n-  double f2 = t2->getd();\n-  jlong x1 = jlong_cast(f1); \/\/ note:  *(long*)&f1, not just (long)f1\n-  jlong x2 = jlong_cast(f2);\n-\n-  \/\/ If either is a NaN, return an input NaN\n-  if (g_isnan(f1)) {\n-    return replace_with_con(igvn, t1);\n-  }\n-  if (g_isnan(f2)) {\n-    return replace_with_con(igvn, t2);\n-  }\n-\n-  \/\/ If an operand is infinity or the divisor is +\/- zero, punt.\n-  if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jlong) {\n-    return nullptr;\n-  }\n-\n-  \/\/ We must be modulo'ing 2 double constants.\n-  \/\/ Make sure that the sign of the fmod is equal to the sign of the dividend\n-  jlong xr = jlong_cast(fmod(f1, f2));\n-  if ((x1 ^ xr) < 0) {\n-    xr ^= min_jlong;\n-  }\n-\n-  return replace_with_con(igvn, TypeD::make(jdouble_cast(xr)));\n-}\n-\n-Node* ModFloatingNode::replace_with_con(PhaseIterGVN* phase, const Type* con) {\n-  Compile* C = phase->C;\n-  Node* con_node = phase->makecon(con);\n-  CallProjections projs;\n-  extract_projections(&projs, false, false);\n-  phase->replace_node(projs.fallthrough_proj, in(TypeFunc::Control));\n-  if (projs.fallthrough_catchproj != nullptr) {\n-    phase->replace_node(projs.fallthrough_catchproj, in(TypeFunc::Control));\n-  }\n-  if (projs.fallthrough_memproj != nullptr) {\n-    phase->replace_node(projs.fallthrough_memproj, in(TypeFunc::Memory));\n-  }\n-  if (projs.catchall_memproj != nullptr) {\n-    phase->replace_node(projs.catchall_memproj, C->top());\n-  }\n-  if (projs.fallthrough_ioproj != nullptr) {\n-    phase->replace_node(projs.fallthrough_ioproj, in(TypeFunc::I_O));\n-  }\n-  assert(projs.catchall_ioproj == nullptr, \"no exceptions from floating mod\");\n-  assert(projs.catchall_catchproj == nullptr, \"no exceptions from floating mod\");\n-  if (projs.resproj != nullptr) {\n-    phase->replace_node(projs.resproj, con_node);\n-  }\n-  phase->replace_node(this, C->top());\n-  C->remove_macro_node(this);\n-  disconnect_inputs(C);\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":0,"deletions":150,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -158,37 +158,0 @@\n-\/\/ Base class for float and double modulus\n-class ModFloatingNode : public CallLeafNode {\n-protected:\n-  Node* replace_with_con(PhaseIterGVN* phase, const Type* con);\n-\n-public:\n-  ModFloatingNode(Compile* C, const TypeFunc* tf, const char *name);\n-};\n-\n-\/\/ Float Modulus\n-class ModFNode : public ModFloatingNode {\n-private:\n-  Node* dividend() const { return in(TypeFunc::Parms + 0); }\n-  Node* divisor() const { return in(TypeFunc::Parms + 1); }\n-\n-public:\n-  ModFNode(Compile* C, Node* a, Node* b);\n-  virtual int Opcode() const;\n-  virtual uint ideal_reg() const { return Op_RegF; }\n-  virtual uint size_of() const { return sizeof(*this); }\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-};\n-\n-\/\/ Double Modulus\n-class ModDNode : public ModFloatingNode {\n-private:\n-  Node* dividend() const { return in(TypeFunc::Parms + 0); }\n-  Node* divisor() const { return in(TypeFunc::Parms + 2); }\n-\n-public:\n-  ModDNode(Compile* C, Node* a, Node* b);\n-  virtual int Opcode() const;\n-  virtual uint ideal_reg() const { return Op_RegD; }\n-  virtual uint size_of() const { return sizeof(*this); }\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1790,13 +1790,1 @@\n-  \/\/ Inputs\n-  Node* a = argument(0);\n-  Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? argument(2) : nullptr;\n-\n-  const TypePtr* no_memory_effects = nullptr;\n-  Node* trig = make_runtime_call(RC_LEAF, call_type, funcAddr, funcName,\n-                                 no_memory_effects,\n-                                 a, top(), b, b ? top() : nullptr);\n-  Node* value = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+0));\n-#ifdef ASSERT\n-  Node* value_top = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+1));\n-  assert(value_top == top(), \"second value must be top\");\n-#endif\n+  Node* lhs = argument(0);\n@@ -1804,1 +1792,10 @@\n-  set_result(value);\n+  Node* call;\n+  if (call_type == OptoRuntime::Math_DD_D_Type()) {\n+    Node* rhs = argument(2);\n+    call = PureBinaryNativeMathNode::make(C, funcAddr, funcName, control(), lhs, rhs);\n+  } else {\n+    call = PureUnaryNativeMathNode::make(C, funcAddr, funcName, control(), lhs);\n+  }\n+  call = _gvn.transform(call);\n+  set_control(_gvn.transform(new ProjNode(call, TypeFunc::Control)));\n+  set_result(_gvn.transform(new ProjNode(call, TypeFunc::Parms + 0)));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-        assert(parent_ctl->is_Start() || parent_ctl->is_MemBar() || parent_ctl->is_Call() ||\n+        assert(parent_ctl->is_Start() || parent_ctl->is_MemBar() || parent_ctl->is_Call() || parent_ctl->is_PureCall() ||\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2436,2 +2436,1 @@\n-               n->Opcode() == Op_ModD ||\n-               n->Opcode() == Op_ModF ||\n+               n->is_PureCall()            ||\n@@ -2589,19 +2588,5 @@\n-      switch (n->Opcode()) {\n-      case Op_ModD:\n-      case Op_ModF: {\n-        bool is_drem = n->Opcode() == Op_ModD;\n-        CallNode* mod_macro = n->as_Call();\n-        CallNode* call = new CallLeafNode(mod_macro->tf(),\n-                                          is_drem ? CAST_FROM_FN_PTR(address, SharedRuntime::drem)\n-                                                  : CAST_FROM_FN_PTR(address, SharedRuntime::frem),\n-                                          is_drem ? \"drem\" : \"frem\", TypeRawPtr::BOTTOM);\n-        call->init_req(TypeFunc::Control, mod_macro->in(TypeFunc::Control));\n-        call->init_req(TypeFunc::I_O, mod_macro->in(TypeFunc::I_O));\n-        call->init_req(TypeFunc::Memory, mod_macro->in(TypeFunc::Memory));\n-        call->init_req(TypeFunc::ReturnAdr, mod_macro->in(TypeFunc::ReturnAdr));\n-        call->init_req(TypeFunc::FramePtr, mod_macro->in(TypeFunc::FramePtr));\n-        for (unsigned int i = 0; i < mod_macro->tf()->domain()->cnt() - TypeFunc::Parms; i++) {\n-          call->init_req(TypeFunc::Parms + i, mod_macro->in(TypeFunc::Parms + i));\n-        }\n-        _igvn.replace_node(mod_macro, call);\n-        transform_later(call);\n+      if (n->is_PureCall()) {\n+        PureCallNode* pure_call = n->as_PureCall();\n+        Node* new_node = pure_call->expand_macro(C);\n+        _igvn.replace_node(pure_call, new_node);\n+        transform_later(new_node);\n@@ -2609,2 +2594,1 @@\n-      }\n-      default:\n+      } else {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":7,"deletions":23,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2938,7 +2938,1 @@\n-  switch (Opcode()) {\n-  case Op_ModD:\n-  case Op_ModF:\n-    return true;\n-  default:\n-    return false;\n-  }\n+  return is_PureCall();\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -167,0 +167,7 @@\n+class PureBinaryNativeMathNode;\n+class PureCallNode;\n+class PureFloatingModuloNode;\n+class PureModDNode;\n+class PureModFNode;\n+class PureNativeMathNode;\n+class PureUnaryNativeMathNode;\n@@ -814,0 +821,7 @@\n+    DEFINE_CLASS_ID(PureCall, Node, 23)\n+      DEFINE_CLASS_ID(PureFloatingModulo, PureCall, 0)\n+        DEFINE_CLASS_ID(PureModF, PureFloatingModulo, 0)\n+        DEFINE_CLASS_ID(PureModD, PureFloatingModulo, 1)\n+      DEFINE_CLASS_ID(PureNativeMath, PureCall, 1)\n+        DEFINE_CLASS_ID(PureUnaryNativeMath, PureNativeMath, 0)\n+        DEFINE_CLASS_ID(PureBinaryNativeMath, PureNativeMath, 1)\n@@ -999,0 +1013,7 @@\n+  DEFINE_CLASS_QUERY(PureBinaryNativeMath)\n+  DEFINE_CLASS_QUERY(PureCall)\n+  DEFINE_CLASS_QUERY(PureFloatingModulo)\n+  DEFINE_CLASS_QUERY(PureModD)\n+  DEFINE_CLASS_QUERY(PureModF)\n+  DEFINE_CLASS_QUERY(PureNativeMath)\n+  DEFINE_CLASS_QUERY(PureUnaryNativeMath)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1100,1 +1100,6 @@\n-  CallNode* mod = type == BasicType::T_DOUBLE ? static_cast<CallNode*>(new ModDNode(C, a, b)) : new ModFNode(C, a, b);\n+  PureCallNode* call;\n+  if (type == T_DOUBLE) {\n+    call = PureModDNode::make(C, control(), a, b);\n+  } else {\n+    call = PureModFNode::make(C, control(), a, b);\n+  }\n@@ -1102,5 +1107,4 @@\n-  Node* prev_mem = set_predefined_input_for_runtime_call(mod);\n-  mod = _gvn.transform(mod)->as_Call();\n-  set_predefined_output_for_runtime_call(mod, prev_mem, TypeRawPtr::BOTTOM);\n-  Node* result = _gvn.transform(new ProjNode(mod, TypeFunc::Parms + 0));\n-  record_for_igvn(mod);\n+  call = _gvn.transform(call)->as_PureCall();\n+  set_control(_gvn.transform(new ProjNode(call, TypeFunc::Control)));\n+  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms + 0));\n+  record_for_igvn(call);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1931,0 +1931,1 @@\n+public:\n@@ -1933,0 +1934,1 @@\n+private:\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+editProperty(matches(\"name\", \"PureUnaryNativeMath|PureBinaryNativeMath\"), [\"dump_spec\"], \"extra_label\",\n+             function(dump_spec) {return callLeafInfo(dump_spec[0], 1);});\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/customNodeInfo.filter","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2720,1 +2720,1 @@\n-        String regex = START + \"ModF\" + MID + END;\n+        String regex = START + \"PureModF\" + MID + END;\n@@ -2726,1 +2726,1 @@\n-        String regex = START + \"ModD\" + MID + END;\n+        String regex = START + \"PureModD\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}