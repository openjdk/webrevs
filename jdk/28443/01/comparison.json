{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,4 @@\n- * @summary round trip test NumberFormat\n+ * @bug 4266589 8031145 8164791 8316696 8368001\n+ * @summary NumberFormat round trip testing of parsing and formatting.\n+ *      This test checks 4 factory instances per locale against ~20 numeric inputs.\n+ *      Samples ~1\/4 of the available locales from NumberFormat SPI.\n@@ -28,0 +31,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n@@ -33,2 +38,4 @@\n-import java.text.ParseException;\n-import java.util.Locale;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Stream;\n@@ -36,3 +43,5 @@\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.fail;\n+import jdk.test.lib.RandomFactory;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -47,1 +56,0 @@\n- * \/\/bug472\n@@ -50,20 +58,0 @@\n-    static final boolean STRING_COMPARE = true;\n-    static final boolean EXACT_NUMERIC_COMPARE = false;\n-    static final double MAX_ERROR = 1e-14;\n-    static double max_numeric_error = 0;\n-    static double min_numeric_error = 1;\n-\n-    String localeName, formatName;\n-\n-    @Test\n-    public void TestNumberFormatRoundTrip() {\n-        System.out.println(\"Default Locale\");\n-        localeName = \"Default Locale\";\n-        formatName = \"getInstance\";\n-        doTest(NumberFormat.getInstance());\n-        formatName = \"getNumberInstance\";\n-        doTest(NumberFormat.getNumberInstance());\n-        formatName = \"getCurrencyInstance\";\n-        doTest(NumberFormat.getCurrencyInstance());\n-        formatName = \"getPercentInstance\";\n-        doTest(NumberFormat.getPercentInstance());\n@@ -71,13 +59,1 @@\n-        Locale[] loc = NumberFormat.getAvailableLocales();\n-        for (int i=0; i<loc.length; ++i) {\n-            System.out.println(loc[i].getDisplayName());\n-            localeName = loc[i].toString();\n-            formatName = \"getInstance\";\n-            doTest(NumberFormat.getInstance(loc[i]));\n-            formatName = \"getNumberInstance\";\n-            doTest(NumberFormat.getNumberInstance(loc[i]));\n-            formatName = \"getCurrencyInstance\";\n-            doTest(NumberFormat.getCurrencyInstance(loc[i]));\n-            formatName = \"getPercentInstance\";\n-            doTest(NumberFormat.getPercentInstance(loc[i]));\n-        }\n+    private static final Random RND = RandomFactory.getRandom();\n@@ -85,3 +61,6 @@\n-        System.out.println(\"Numeric error \" +\n-              min_numeric_error + \" to \" +\n-              max_numeric_error);\n+    @ParameterizedTest\n+    @MethodSource\n+    void testNumberFormatRoundTrip(NumberFormat fmt) {\n+        fmt.setMaximumFractionDigits(Integer.MAX_VALUE);\n+        Stream.concat(numbers.stream(), randomNumbers())\n+                .forEach(num -> test(fmt, num));\n@@ -90,27 +69,16 @@\n-    public void doTest(NumberFormat fmt) {\n-        doTest(fmt, Double.NaN);\n-        doTest(fmt, Double.POSITIVE_INFINITY);\n-        doTest(fmt, Double.NEGATIVE_INFINITY);\n-\n-        doTest(fmt, 500);\n-        doTest(fmt, 0);\n-        doTest(fmt, 5555555555555555L);\n-        doTest(fmt, 55555555555555555L);\n-        doTest(fmt, 9223372036854775807L);\n-        doTest(fmt, 9223372036854775808.0);\n-        doTest(fmt, -9223372036854775808L);\n-        doTest(fmt, -9223372036854775809.0);\n-\n-        for (int i=0; i<2; ++i) {\n-            doTest(fmt, randomDouble(1));\n-            doTest(fmt, randomDouble(10000));\n-            doTest(fmt, Math.floor(randomDouble(10000)));\n-            doTest(fmt, randomDouble(1e50));\n-            doTest(fmt, randomDouble(1e-50));\n-            doTest(fmt, randomDouble(1e100));\n-            \/\/ The use of double d such that isInfinite(100d) causes the\n-            \/\/ numeric test to fail with percent formats (bug 4266589).\n-            \/\/ Largest double s.t. 100d < Inf: d=1.7976931348623156E306\n-            doTest(fmt, randomDouble(1e306));\n-            doTest(fmt, randomDouble(1e-323));\n-            doTest(fmt, randomDouble(1e-100));\n+    private void test(NumberFormat fmt, Number num) {\n+        String originalFormatted = fmt.format(num);\n+        Number parsedNum = Assertions.assertDoesNotThrow(() -> fmt.parse(originalFormatted),\n+                \"Failed parse(format(%s))\".formatted(num));\n+        String parsedFormatted = fmt.format(parsedNum);\n+        var equal = originalFormatted.equals(parsedFormatted);\n+        \/\/ Try BigDecimal parsing, if not equal\n+        if (!equal) {\n+            var df = Assertions.assertInstanceOf(DecimalFormat.class, fmt);\n+            df.setParseBigDecimal(true);\n+            parsedNum = Assertions.assertDoesNotThrow(() -> fmt.parse(originalFormatted),\n+                    \"Failed BigDecimal parse(format(%s))\".formatted(num));\n+            parsedFormatted = fmt.format(parsedNum);\n+            df.setParseBigDecimal(false);\n+            Assertions.assertEquals(originalFormatted, parsedFormatted,\n+                    \"Failed to round-trip format(parse(format(%s)))\".formatted(num));\n@@ -118,0 +86,4 @@\n+        \/\/ Numeric mismatch to the amount of 1e-14 is tolerable\n+        var error = proportionalError(num, parsedNum);\n+        Assertions.assertFalse(error > 1e-14,\n+                \"Round tripping %s caused numeric error: %s\".formatted(num, error));\n@@ -120,6 +92,20 @@\n-    \/**\n-     * Return a random value from -range..+range.\n-     *\/\n-    public double randomDouble(double range) {\n-        double a = Math.random();\n-        return (2.0 * range * a) - range;\n+    \/\/ Regular, number, currency, and percent instance per locale\n+    private static Stream<Arguments> testNumberFormatRoundTrip() {\n+        return Stream.concat(\n+                \/\/ Default Locale\n+                Stream.of(\n+                        Arguments.of(NumberFormat.getInstance()),\n+                        Arguments.of(NumberFormat.getNumberInstance()),\n+                        Arguments.of(NumberFormat.getCurrencyInstance()),\n+                        Arguments.of(NumberFormat.getPercentInstance())),\n+                \/\/ ~1000 locales returned from provider.\n+                \/\/ Too expensive to test all locales, so sample a reasonable amount\n+                Arrays.stream(NumberFormat.getAvailableLocales())\n+                        .filter(_ -> RND.nextDouble() < .25)\n+                        .flatMap(loc -> Stream.of(\n+                        Arguments.of(NumberFormat.getInstance(loc)),\n+                        Arguments.of(NumberFormat.getNumberInstance(loc)),\n+                        Arguments.of(NumberFormat.getCurrencyInstance(loc)),\n+                        Arguments.of(NumberFormat.getPercentInstance(loc)))\n+                )\n+        );\n@@ -128,2 +114,31 @@\n-    public void doTest(NumberFormat fmt, double value) {\n-        doTest(fmt, Double.valueOf(value));\n+    \/\/ Fixed set of numbers to test each locale against\n+    private static final List<Number> numbers = List.of(\n+            Double.NaN,\n+            Double.POSITIVE_INFINITY,\n+            Double.NEGATIVE_INFINITY,\n+            500,\n+            0,\n+            5555555555555555L,\n+            55555555555555555L,\n+            9223372036854775807L,\n+            9223372036854775808.0,\n+            -9223372036854775808L,\n+            -9223372036854775809.0\n+    );\n+\n+    \/\/ Compute fresh batch of random numbers per locale\n+    private Stream<Number> randomNumbers() {\n+        return Stream.of(\n+                randomDouble(1),\n+                randomDouble(10000),\n+                Math.floor(randomDouble(10000)),\n+                randomDouble(1e50),\n+                randomDouble(1e-50),\n+                randomDouble(1e100),\n+                \/\/ The use of double d such that isInfinite(100d) causes the\n+                \/\/ numeric test to fail with percent formats (bug 4266589).\n+                \/\/ Largest double s.t. 100d < Inf: d=1.7976931348623156E306\n+                randomDouble(1e306),\n+                randomDouble(1e-323),\n+                randomDouble(1e-100)\n+        );\n@@ -132,2 +147,3 @@\n-    public void doTest(NumberFormat fmt, long value) {\n-        doTest(fmt, Long.valueOf(value));\n+    \/\/ Return a random value from -range..+range.\n+    private static double randomDouble(double range) {\n+        return RND.nextDouble(-range, range);\n@@ -136,1 +152,1 @@\n-    static double proportionalError(Number a, Number b) {\n+    private static double proportionalError(Number a, Number b) {\n@@ -142,88 +158,0 @@\n-\n-    public void doTest(NumberFormat fmt, Number value) {\n-        fmt.setMaximumFractionDigits(Integer.MAX_VALUE);\n-        String s = fmt.format(value), s2 = null;\n-        Number n = null;\n-        String err = \"\";\n-        try {\n-            System.out.println(\"  \" + value + \" F> \" + escape(s));\n-            n = fmt.parse(s);\n-            System.out.println(\"  \" + escape(s) + \" P> \" + n);\n-            s2 = fmt.format(n);\n-            System.out.println(\"  \" + n + \" F> \" + escape(s2));\n-\n-            if (STRING_COMPARE) {\n-                if (!s.equals(s2)) {\n-                    if (fmt instanceof DecimalFormat) {\n-                        System.out.println(\"Text mismatch: expected: \" + s + \", got: \" + s2 + \" --- Try BigDecimal parsing.\");\n-                        ((DecimalFormat)fmt).setParseBigDecimal(true);\n-                        n = fmt.parse(s);\n-                        System.out.println(\"  \" + escape(s) + \" P> \" + n);\n-                        s2 = fmt.format(n);\n-                        System.out.println(\"  \" + n + \" F> \" + escape(s2));\n-                        ((DecimalFormat)fmt).setParseBigDecimal(false);\n-\n-                        if (!s.equals(s2)) {\n-                            err = \"STRING ERROR(DecimalFormat): \";\n-                        }\n-                    } else {\n-                        err = \"STRING ERROR(NumberFormat): \";\n-                    }\n-                }\n-            }\n-\n-            if (EXACT_NUMERIC_COMPARE) {\n-                if (value.doubleValue() != n.doubleValue()) {\n-                    err += \"NUMERIC ERROR: \";\n-                }\n-            } else {\n-                \/\/ Compute proportional error\n-                double error = proportionalError(value, n);\n-\n-                if (error > MAX_ERROR) {\n-                    err += \"NUMERIC ERROR \" + error + \": \";\n-                }\n-\n-                if (error > max_numeric_error) max_numeric_error = error;\n-                if (error < min_numeric_error) min_numeric_error = error;\n-            }\n-\n-            String message = value + typeOf(value) + \" F> \" +\n-                escape(s) + \" P> \" +\n-                n + typeOf(n) + \" F> \" +\n-                escape(s2);\n-            if (err.length() > 0) {\n-                fail(\"*** \" + err + \" with \" +\n-                      formatName + \" in \" + localeName +\n-                      \" \" + message);\n-            } else {\n-                System.out.println(message);\n-            }\n-        } catch (ParseException e) {\n-            fail(\"*** \" + e.toString() + \" with \" +\n-                  formatName + \" in \" + localeName);\n-        }\n-    }\n-\n-    static String typeOf(Number n) {\n-        if (n instanceof Long) return \" Long\";\n-        if (n instanceof Double) return \" Double\";\n-        return \" Number\";\n-    }\n-\n-    static String escape(String s) {\n-        StringBuffer buf = new StringBuffer();\n-        for (int i=0; i<s.length(); ++i) {\n-            char c = s.charAt(i);\n-            if (c < (char)0xFF) {\n-                buf.append(c);\n-            } else {\n-                buf.append(\"\\\\U\");\n-                buf.append(Integer.toHexString((c & 0xF000) >> 12));\n-                buf.append(Integer.toHexString((c & 0x0F00) >> 8));\n-                buf.append(Integer.toHexString((c & 0x00F0) >> 4));\n-                buf.append(Integer.toHexString(c & 0x000F));\n-            }\n-        }\n-        return buf.toString();\n-    }\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/NumberRoundTrip.java","additions":98,"deletions":170,"binary":false,"changes":268,"status":"modified"}]}