{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-  static CTP int_type_union(CTP t1, CTP t2) {\n+  static auto int_type_union(CTP t1, CTP t2) {\n@@ -212,1 +212,1 @@\n-  static TypeIntMirror make(const TypeIntPrototype<S, U>& t, int widen) {\n+  static TypeIntMirror make(const TypeIntPrototype<S, U>& t, int widen = 0) {\n@@ -220,0 +220,4 @@\n+  TypeIntMirror meet(const TypeIntMirror& o) const {\n+    return TypeIntHelper::int_type_union(this, &o);\n+  }\n+\n@@ -223,0 +227,1 @@\n+  static TypeIntMirror make(const TypeIntMirror& t, int widen);\n@@ -224,1 +229,0 @@\n-  TypeIntMirror meet(const TypeIntMirror& o) const;\n@@ -325,1 +329,1 @@\n-    CTP res;\n+    TypeIntMirror<S<CTP>, U<CTP>> res;\n@@ -333,1 +337,1 @@\n-        CTP current = infer(st1, st2);\n+        TypeIntMirror<S<CTP>, U<CTP>> current = infer(st1, st2);\n@@ -336,1 +340,1 @@\n-          res = res->meet(current)->template cast<CT<CTP>>();\n+          res = res.meet(current);\n@@ -345,1 +349,16 @@\n-    return res;\n+    \/\/ It is important that widen is computed on the whole result instead of during each step. This\n+    \/\/ is because we normalize the widen of small Type instances to 0, so computing the widen value\n+    \/\/ for each step and taking the union of them may return a widen value that conflicts with\n+    \/\/ other computations, trigerring the monotonicity assert during CCP.\n+    \/\/\n+    \/\/ For example, let us consider the operation r = x ^ y:\n+    \/\/ - During the first step of CCP, type(x) = {0}, type(y) = [-2, 2], w = 3.\n+    \/\/   Since x is a constant that is the identity element of the xor operation, type(r) = type(y) = [-2, 2], w = 3\n+    \/\/ - During the second step, type(x) is widened to [0, 2], w = 0.\n+    \/\/   We then compute the range for:\n+    \/\/   r1 = x ^ y1, type(x) = [0, 2], w = 0, type(y1) = [0, 2], w = 0\n+    \/\/   r2 = x ^ y2, type(x) = [0, 2], w = 0, type(y2) = [-2, -1], w = 0\n+    \/\/   This results in type(r1) = [0, 3], w = 0, and type(r2) = [-4, -1], w = 0\n+    \/\/   So the union of type(r1) and type(r2) is [-4, 3], w = 0. This widen value is smaller than\n+    \/\/   that of the previous step, triggering the monotonicity assert.\n+    return CT<CTP>::make(res, MAX2(t1->_widen, t2->_widen));\n@@ -360,1 +379,1 @@\n-      return CT<CTP>::make(TypeIntPrototype<S<CTP>, U<CTP>>{{lo, hi}, {ulo, uhi}, {zeros, ones}}, MAX2(t1->_widen, t2->_widen));\n+      return TypeIntMirror<S<CTP>, U<CTP>>::make(TypeIntPrototype<S<CTP>, U<CTP>>{{lo, hi}, {ulo, uhi}, {zeros, ones}});\n@@ -375,1 +394,1 @@\n-      return CT<CTP>::make(TypeIntPrototype<S<CTP>, U<CTP>>{{lo, hi}, {ulo, uhi}, {zeros, ones}}, MAX2(t1->_widen, t2->_widen));\n+      return TypeIntMirror<S<CTP>, U<CTP>>::make(TypeIntPrototype<S<CTP>, U<CTP>>{{lo, hi}, {ulo, uhi}, {zeros, ones}});\n@@ -388,1 +407,1 @@\n-      return CT<CTP>::make(TypeIntPrototype<S<CTP>, U<CTP>>{{lo, hi}, {ulo, uhi}, {zeros, ones}}, MAX2(t1->_widen, t2->_widen));\n+      return TypeIntMirror<S<CTP>, U<CTP>>::make(TypeIntPrototype<S<CTP>, U<CTP>>{{lo, hi}, {ulo, uhi}, {zeros, ones}});\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":30,"deletions":11,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -802,0 +802,3 @@\n+  static const TypeInt* make(const TypeIntMirror<jint, juint>& t, int widen) {\n+    return (new TypeInt(TypeIntPrototype<jint, juint>{{t._lo, t._hi}, {t._ulo, t._uhi}, t._bits}, widen, false))->hashcons()->is_int();\n+  }\n@@ -884,0 +887,3 @@\n+  static const TypeLong* make(const TypeIntMirror<jlong, julong>& t, int widen) {\n+    return (new TypeLong(TypeIntPrototype<jlong, julong>{{t._lo, t._hi}, {t._ulo, t._uhi}, t._bits}, widen, false))->hashcons()->is_long();\n+  }\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -219,2 +219,2 @@\n-const TypeIntMirror<S, U>* TypeIntMirror<S, U>::operator->() const {\n-  return this;\n+TypeIntMirror<S, U> TypeIntMirror<S, U>::make(const TypeIntMirror<S, U>& t, int widen) {\n+  return t;\n@@ -224,2 +224,2 @@\n-TypeIntMirror<S, U> TypeIntMirror<S, U>::meet(const TypeIntMirror& o) const {\n-  return TypeIntHelper::int_type_union(*this, o);\n+const TypeIntMirror<S, U>* TypeIntMirror<S, U>::operator->() const {\n+  return this;\n","filename":"test\/hotspot\/gtest\/opto\/test_rangeinference.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.ccp;\n+\n+\/*\n+ * @test\n+ * @bug 8374180\n+ * @summary Test that _widen is set correctly in XorI::add_ring() to ensure monotonicity.\n+ * @run main\/othervm -XX:CompileCommand=compileonly,${test.main.class}::* -Xcomp ${test.main.class}\n+ *\/\n+public class TestWrongXorIWiden {\n+    static byte byFld;\n+\n+    public static void main(String[] strArr) {\n+        test();\n+    }\n+\n+    static void test() {\n+        int k, i17 = 0;\n+        long lArr[] = new long[400];\n+        for (int i = 9; i < 54; ++i) {\n+            for (int j = 7; j > 1; j--) {\n+                for (k = 1; k < 2; k++) {\n+                    i17 >>= i;\n+                }\n+                byFld += j ^ i17;\n+                for (int a = 1; a < 2; a++) {\n+                    i17 = k;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ccp\/TestWrongXorIWiden.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"}]}