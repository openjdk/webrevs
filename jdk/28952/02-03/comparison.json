{"files":[{"patch":"@@ -349,0 +349,15 @@\n+    \/\/ It is important that widen is computed on the whole result instead of during each step. This\n+    \/\/ is because we normalize the widen of small Type instances to 0, so computing the widen value\n+    \/\/ for each step and taking the union of them may return a widen value that conflicts with\n+    \/\/ other computations, trigerring the monotonicity assert during CCP.\n+    \/\/\n+    \/\/ For example, let us consider the operation r = x ^ y:\n+    \/\/ - During the first step of CCP, type(x) = {0}, type(y) = [-2, 2], w = 3.\n+    \/\/   Since x is a constant that is the identity element of the xor operation, type(r) = type(y) = [-2, 2], w = 3\n+    \/\/ - During the second step, type(x) is widen to [0, 2], w = 0.\n+    \/\/   We then compute the range for:\n+    \/\/   r1 = x ^ y1, type(x) = [0, 2], w = 0, type(y1) = [0, 2], w = 0\n+    \/\/   r2 = x ^ y2, type(x) = [0, 2], w = 0, type(y2) = [-2, -1], w = 0\n+    \/\/   This results in type(r1) = [0, 3], w = 0, and type(r2) = [-4, -1], w = 0\n+    \/\/   So the union of type(r1) and type(r2) is [-4, 3], w = 0. This widen value is smaller than\n+    \/\/   that of the previous step, triggering the monotonicity assert.\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}