{"files":[{"patch":"@@ -220,0 +220,6 @@\n+    \/**\n+     * A table to hold the access flags of the method parameters,\n+     * for all parameters including synthetic and mandated ones.\n+     *\/\n+    int[] allParameterAccessFlags;\n+\n@@ -1148,0 +1154,1 @@\n+                        allParameterAccessFlags = new int[numEntries];\n@@ -1150,0 +1157,1 @@\n+                        int allParamIndex = 0;\n@@ -1154,0 +1162,1 @@\n+                            allParameterAccessFlags[allParamIndex++] = flags;\n@@ -1595,1 +1604,10 @@\n-            throw badClassFile(\"bad.runtime.invisible.param.annotations\", meth);\n+            \/\/the RuntimeVisibleParameterAnnotations and RuntimeInvisibleParameterAnnotations\n+            \/\/provide annotations for a different number of parameters, ignore:\n+            if (lintClassfile) {\n+                log.warning(LintCategory.CLASSFILE, Warnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n+            }\n+            for (int pnum = 0; pnum < numParameters; pnum++) {\n+                readAnnotations();\n+            }\n+            parameterAnnotations = null;\n+            return ;\n@@ -2640,1 +2658,2 @@\n-        Type type = poolReader.getType(nextChar());\n+        Type descriptorType = poolReader.getType(nextChar());\n+        Type type = descriptorType;\n@@ -2685,0 +2704,1 @@\n+        adjustParameterAnnotations(m, descriptorType);\n@@ -2812,3 +2832,2 @@\n-        if (parameterAnnotations != null && parameterAnnotations.length != annotationIndex) {\n-            throw badClassFile(\"bad.runtime.invisible.param.annotations\", sym);\n-        }\n+        Assert.check(parameterAnnotations == null ||\n+                     parameterAnnotations.length == annotationIndex);\n@@ -2820,0 +2839,1 @@\n+        allParameterAccessFlags = null;\n@@ -2823,0 +2843,123 @@\n+    void adjustParameterAnnotations(MethodSymbol sym, Type methodDescriptor) {\n+        if (parameterAnnotations == null) {\n+            return ;\n+        }\n+\n+        \/\/the specification for Runtime(In)VisibleParameterAnnotations does not\n+        \/\/enforce any mapping between the method parameters and the recorded\n+        \/\/parameter annotation. Attempt a number of heuristics to adjust the\n+        \/\/adjust parameterAnnotations to the percieved number of parameters:\n+\n+        int methodParameterCount = sym.type.getParameterTypes().size();\n+\n+        if (methodParameterCount == parameterAnnotations.length) {\n+            \/\/we've got exactly as many parameter annotations as are parameters\n+            \/\/of the method (after considering a possible Signature attribute),\n+            \/\/no need to do anything. the parameter creation code will use\n+            \/\/the 1-1 mapping to restore the annotations:\n+            return ;\n+        }\n+\n+        if (allParameterAccessFlags != null) {\n+            \/\/MethodParameters attribute present, use it:\n+\n+            \/\/count the number of non-synthetic and non-mandatory parameters:\n+            int realParameters = 0;\n+\n+            for (int i = 0; i < allParameterAccessFlags.length; i++) {\n+                if ((allParameterAccessFlags[i] & (SYNTHETIC | MANDATED)) == 0) {\n+                    realParameters++;\n+                }\n+            }\n+\n+            int methodDescriptorParameterCount = methodDescriptor.getParameterTypes().size();\n+\n+            if (realParameters == parameterAnnotations.length &&\n+                allParameterAccessFlags.length == methodDescriptorParameterCount) {\n+                \/\/if we have parameter annotations for each non-synthetic\/mandatory parameter,\n+                \/\/and if Signature was not present, expand the parameterAnnotations to cover\n+                \/\/all the method descriptor's parameters:\n+                if (sym.type == methodDescriptor) {\n+                    ParameterAnnotations[] newParameterAnnotations =\n+                            new ParameterAnnotations[methodParameterCount];\n+                    int srcIndex = 0;\n+\n+                    for (int i = 0; i < methodParameterCount; i++) {\n+                        if ((allParameterAccessFlags[i] & (SYNTHETIC | MANDATED)) == 0) {\n+                            newParameterAnnotations[i] = parameterAnnotations[srcIndex++];\n+                        }\n+                    }\n+\n+                    parameterAnnotations = newParameterAnnotations;\n+                } else {\n+                    dropParameterAnnotations();\n+                }\n+            } else if (realParameters == methodParameterCount &&\n+                       methodDescriptorParameterCount == parameterAnnotations.length &&\n+                       allParameterAccessFlags.length == methodDescriptorParameterCount) {\n+                \/\/if there are as many parameter annotations as parameters in\n+                \/\/the method descriptor, and as many real parameters as parameters\n+                \/\/in the method's type (after accounting for Signature), shrink\n+                \/\/the parameterAnnotations to only cover the parameters from\n+                \/\/the method's type:\n+                ParameterAnnotations[] newParameterAnnotations =\n+                        new ParameterAnnotations[methodParameterCount];\n+                int targetIndex = 0;\n+\n+                for (int i = 0; i < parameterAnnotations.length; i++) {\n+                    if ((allParameterAccessFlags[i] & (SYNTHETIC | MANDATED)) == 0) {\n+                        newParameterAnnotations[targetIndex++] = parameterAnnotations[i];\n+                    }\n+                }\n+\n+                parameterAnnotations = newParameterAnnotations;\n+            } else {\n+                dropParameterAnnotations();\n+            }\n+            return ;\n+        }\n+\n+        if (!sym.isConstructor()) {\n+            \/\/if the number of parameter annotations and the number of parameters\n+            \/\/don't match, we don't have any heuristics to map one to the other\n+            \/\/unless the method is a constructor:\n+            dropParameterAnnotations();\n+            return ;\n+        }\n+\n+        if (sym.owner.isEnum()) {\n+            if (methodParameterCount == parameterAnnotations.length + 2 &&\n+                sym.type == methodDescriptor) {\n+                \/\/handle constructors of enum types without the Signature attribute -\n+                \/\/there are the two synthetic parameters (name and ordinal) in the\n+                \/\/constructor, but there may be only parameter annotations for the\n+                \/\/real non-synthetic parameters:\n+                ParameterAnnotations[] newParameterAnnotations = new ParameterAnnotations[parameterAnnotations.length + 2];\n+                System.arraycopy(parameterAnnotations, 0, newParameterAnnotations, 2, parameterAnnotations.length);\n+                parameterAnnotations = newParameterAnnotations;\n+                return ;\n+            }\n+        } else if (sym.owner.isDirectlyOrIndirectlyLocal()) {\n+            \/\/local class may capture the enclosing instance (as the first parameter),\n+            \/\/and local variables (as trailing parameters)\n+            \/\/if there are less parameter annotations than parameters, put the existing\n+            \/\/ones starting with offset:\n+            if (methodParameterCount > parameterAnnotations.length &&\n+                sym.type == methodDescriptor) {\n+                ParameterAnnotations[] newParameterAnnotations = new ParameterAnnotations[methodParameterCount];\n+                System.arraycopy(parameterAnnotations, 0, newParameterAnnotations, 1, parameterAnnotations.length);\n+                parameterAnnotations = newParameterAnnotations;\n+                return ;\n+            }\n+        }\n+\n+        \/\/no heuristics worked, drop the annotations:\n+        dropParameterAnnotations();\n+    }\n+\n+    private void dropParameterAnnotations() {\n+        parameterAnnotations = null;\n+        if (lintClassfile) {\n+            log.warning(LintCategory.CLASSFILE, Warnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":148,"deletions":5,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -2539,2 +2539,11 @@\n-compiler.misc.bad.runtime.invisible.param.annotations=\\\n-    bad RuntimeInvisibleParameterAnnotations attribute: {0}\n+# 0: file name\n+compiler.warn.runtime.visible.invisible.param.annotations.mismatch=\\\n+    the length of parameters in RuntimeVisibleParameterAnnotations attribute and \\\n+    RuntimeInvisibleParameterAnnotations attribute in: {0} \\\n+    do not match, ignoring both attributes\n+\n+# 0: file name\n+compiler.warn.runtime.invisible.parameter.annotations=\\\n+    the RuntimeVisibleParameterAnnotations and RuntimeInvisibleParameterAnnotations attributes \\\n+    in: {0} \\\n+    cannot be mapped to the method''s parameters\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,320 +0,0 @@\n-class T {\n-  0xCAFEBABE;\n-  0; \/\/ minor version\n-  49; \/\/ version\n-  [73] { \/\/ Constant Pool\n-    ; \/\/ first element is empty\n-    Utf8 \"T\"; \/\/ #1     at 0x0A\n-    class #1; \/\/ #2     at 0x1A\n-    Utf8 \"Ljava\/lang\/Enum<LT;>;\"; \/\/ #3     at 0x1D\n-    Utf8 \"java\/lang\/Enum\"; \/\/ #4     at 0x41\n-    class #4; \/\/ #5     at 0x52\n-    Utf8 \"T.java\"; \/\/ #6     at 0x55\n-    Utf8 \"T1\"; \/\/ #7     at 0x61\n-    Utf8 \"LT;\"; \/\/ #8     at 0x66\n-    Utf8 \"T2\"; \/\/ #9     at 0x78\n-    Utf8 \"T3\"; \/\/ #10     at 0x7D\n-    Utf8 \"myName\"; \/\/ #11     at 0x82\n-    Utf8 \"Ljava\/lang\/String;\"; \/\/ #12     at 0x8B\n-    Utf8 \"$VALUES\"; \/\/ #13     at 0xA0\n-    Utf8 \"[LT;\"; \/\/ #14     at 0xAA\n-    Utf8 \"values\"; \/\/ #15     at 0xBD\n-    Utf8 \"()[LT;\"; \/\/ #16     at 0xC6\n-    NameAndType #13 #14; \/\/ #17     at 0xDB\n-    Field #2 #17; \/\/ #18     at 0xE0\n-    class #14; \/\/ #19     at 0xE5\n-    Utf8 \"clone\"; \/\/ #20     at 0xE8\n-    Utf8 \"()Ljava\/lang\/Object;\"; \/\/ #21     at 0xF0\n-    NameAndType #20 #21; \/\/ #22     at 0x0107\n-    Method #19 #22; \/\/ #23     at 0x010C\n-    Utf8 \"valueOf\"; \/\/ #24     at 0x0111\n-    Utf8 \"(Ljava\/lang\/String;)LT;\"; \/\/ #25     at 0x011B\n-    Utf8 \"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/Enum;\"; \/\/ #26     at 0x0141\n-    NameAndType #24 #26; \/\/ #27     at 0x0179\n-    Method #5 #27; \/\/ #28     at 0x017E\n-    Utf8 \"name\"; \/\/ #29     at 0x0183\n-    Utf8 \"getName\"; \/\/ #30     at 0x018A\n-    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #31     at 0x0194\n-    NameAndType #11 #12; \/\/ #32     at 0x01AB\n-    Field #2 #32; \/\/ #33     at 0x01B0\n-    Utf8 \"this\"; \/\/ #34     at 0x01B5\n-    Utf8 \"<init>\"; \/\/ #35     at 0x01BC\n-    Utf8 \"(Ljava\/lang\/String;ILjava\/lang\/String;)V\"; \/\/ #36     at 0x01C5\n-    Utf8 \"LNotNull;\"; \/\/ #37     at 0x01F0\n-    Utf8 \"java\/lang\/IllegalArgumentException\"; \/\/ #38     at 0x0216\n-    class #38; \/\/ #39     at 0x023B\n-    Utf8 \"Argument 0 for @NotNull parameter of T.<init> must not be null\"; \/\/ #40     at 0x023E\n-    String #40; \/\/ #41     at 0x028B\n-    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #42     at 0x028E\n-    NameAndType #35 #42; \/\/ #43     at 0x02A6\n-    Method #39 #43; \/\/ #44     at 0x02AB\n-    Utf8 \"(Ljava\/lang\/String;I)V\"; \/\/ #45     at 0x02B0\n-    NameAndType #35 #45; \/\/ #46     at 0x02C9\n-    Method #5 #46; \/\/ #47     at 0x02CE\n-    Utf8 \"<clinit>\"; \/\/ #48     at 0x02D3\n-    Utf8 \"()V\"; \/\/ #49     at 0x02DE\n-    String #7; \/\/ #50     at 0x02E4\n-    Utf8 \"type1\"; \/\/ #51     at 0x02E7\n-    String #51; \/\/ #52     at 0x02EF\n-    NameAndType #35 #36; \/\/ #53     at 0x02F2\n-    Method #2 #53; \/\/ #54     at 0x02F7\n-    NameAndType #7 #8; \/\/ #55     at 0x02FC\n-    Field #2 #55; \/\/ #56     at 0x0301\n-    String #9; \/\/ #57     at 0x0306\n-    Utf8 \"type2\"; \/\/ #58     at 0x0309\n-    String #58; \/\/ #59     at 0x0311\n-    NameAndType #9 #8; \/\/ #60     at 0x0314\n-    Field #2 #60; \/\/ #61     at 0x0319\n-    String #10; \/\/ #62     at 0x031E\n-    Utf8 \"type3\"; \/\/ #63     at 0x0321\n-    String #63; \/\/ #64     at 0x0329\n-    NameAndType #10 #8; \/\/ #65     at 0x032C\n-    Field #2 #65; \/\/ #66     at 0x0331\n-    Utf8 \"Code\"; \/\/ #67     at 0x0336\n-    Utf8 \"LineNumberTable\"; \/\/ #68     at 0x033D\n-    Utf8 \"LocalVariableTable\"; \/\/ #69     at 0x034F\n-    Utf8 \"Signature\"; \/\/ #70     at 0x0364\n-    Utf8 \"RuntimeInvisibleParameterAnnotations\"; \/\/ #71     at 0x0370\n-    Utf8 \"SourceFile\"; \/\/ #72     at 0x0397\n-  } \/\/ Constant Pool\n-\n-  0x4031; \/\/ access\n-  #2;\/\/ this_cpx\n-  #5;\/\/ super_cpx\n-\n-  [0] { \/\/ Interfaces\n-  } \/\/ Interfaces\n-\n-  [5] { \/\/ fields\n-    { \/\/ Member at 0x03AE\n-      0x4019; \/\/ access\n-      #7; \/\/ name_cpx\n-      #8; \/\/ sig_cpx\n-      [0] { \/\/ Attributes\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x03B6\n-      0x4019; \/\/ access\n-      #9; \/\/ name_cpx\n-      #8; \/\/ sig_cpx\n-      [0] { \/\/ Attributes\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x03BE\n-      0x4019; \/\/ access\n-      #10; \/\/ name_cpx\n-      #8; \/\/ sig_cpx\n-      [0] { \/\/ Attributes\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x03C6\n-      0x0012; \/\/ access\n-      #11; \/\/ name_cpx\n-      #12; \/\/ sig_cpx\n-      [0] { \/\/ Attributes\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x03CE\n-      0x101A; \/\/ access\n-      #13; \/\/ name_cpx\n-      #14; \/\/ sig_cpx\n-      [0] { \/\/ Attributes\n-      } \/\/ Attributes\n-    } \/\/ Member\n-  } \/\/ fields\n-\n-  [5] { \/\/ methods\n-    { \/\/ Member at 0x03D8\n-      0x0019; \/\/ access\n-      #15; \/\/ name_cpx\n-      #16; \/\/ sig_cpx\n-      [1] { \/\/ Attributes\n-        Attr(#67, 34) { \/\/ Code at 0x03E0\n-          1; \/\/ max_stack\n-          0; \/\/ max_locals\n-          Bytes[10]{\n-            0xB20012B60017C000;\n-            0x13B0;\n-          };\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [1] { \/\/ Attributes\n-            Attr(#68, 6) { \/\/ LineNumberTable at 0x03FC\n-              [1] { \/\/ LineNumberTable\n-                0  9; \/\/  at 0x0408\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x0408\n-      0x0009; \/\/ access\n-      #24; \/\/ name_cpx\n-      #25; \/\/ sig_cpx\n-      [1] { \/\/ Attributes\n-        Attr(#67, 52) { \/\/ Code at 0x0410\n-          2; \/\/ max_stack\n-          1; \/\/ max_locals\n-          Bytes[10]{\n-            0x12022AB8001CC000;\n-            0x02B0;\n-          };\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [2] { \/\/ Attributes\n-            Attr(#69, 12) { \/\/ LocalVariableTable at 0x042C\n-              [1] { \/\/ LocalVariableTable\n-                0 10 29 12 0; \/\/  at 0x043E\n-              }\n-            } \/\/ end LocalVariableTable\n-            ;\n-            Attr(#68, 6) { \/\/ LineNumberTable at 0x043E\n-              [1] { \/\/ LineNumberTable\n-                0  9; \/\/  at 0x044A\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x044A\n-      0x0001; \/\/ access\n-      #30; \/\/ name_cpx\n-      #31; \/\/ sig_cpx\n-      [1] { \/\/ Attributes\n-        Attr(#67, 47) { \/\/ Code at 0x0452\n-          1; \/\/ max_stack\n-          1; \/\/ max_locals\n-          Bytes[5]{\n-            0x2AB40021B0;\n-          };\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [2] { \/\/ Attributes\n-            Attr(#69, 12) { \/\/ LocalVariableTable at 0x0469\n-              [1] { \/\/ LocalVariableTable\n-                0 5 34 8 0; \/\/  at 0x047B\n-              }\n-            } \/\/ end LocalVariableTable\n-            ;\n-            Attr(#68, 6) { \/\/ LineNumberTable at 0x047B\n-              [1] { \/\/ LineNumberTable\n-                0  17; \/\/  at 0x0487\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x0487\n-      0x0002; \/\/ access\n-      #35; \/\/ name_cpx\n-      #36; \/\/ sig_cpx\n-      [3] { \/\/ Attributes\n-        Attr(#67, 86) { \/\/ Code at 0x048F\n-          3; \/\/ max_stack\n-          4; \/\/ max_locals\n-          Bytes[26]{\n-            0x2BC7000DBB002759;\n-            0x1229B7002CBF2A2B;\n-            0x1CB7002F2A2DB500;\n-            0x21B1;\n-          };\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [2] { \/\/ Attributes\n-            Attr(#69, 22) { \/\/ LocalVariableTable at 0x04BB\n-              [2] { \/\/ LocalVariableTable\n-                14 12 34 8 0; \/\/  at 0x04CD\n-                14 12 29 12 3; \/\/  at 0x04D7\n-              }\n-            } \/\/ end LocalVariableTable\n-            ;\n-            Attr(#68, 14) { \/\/ LineNumberTable at 0x04D7\n-              [3] { \/\/ LineNumberTable\n-                14  20; \/\/  at 0x04E3\n-                20  21; \/\/  at 0x04E7\n-                25  22; \/\/  at 0x04EB\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-        ;\n-        Attr(#70, 2) { \/\/ Signature at 0x04EB\n-          #42;\n-        } \/\/ end Signature\n-        ;\n-        Attr(#71, 11) { \/\/ RuntimeInvisibleParameterAnnotations at 0x04F3\n-          [3]b { \/\/ parameters\n-            [1] { \/\/ annotations\n-              {  \/\/  annotation\n-                #37;\n-                [0] { \/\/ element_value_pairs\n-                }  \/\/  element_value_pairs\n-              }  \/\/  annotation\n-            }\n-            ;\n-            [0] { \/\/ annotations\n-            }\n-            ;\n-            [0] { \/\/ annotations\n-            }\n-          }\n-        } \/\/ end RuntimeInvisibleParameterAnnotations\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x0504\n-      0x0008; \/\/ access\n-      #48; \/\/ name_cpx\n-      #49; \/\/ sig_cpx\n-      [1] { \/\/ Attributes\n-        Attr(#67, 107) { \/\/ Code at 0x050C\n-          5; \/\/ max_stack\n-          0; \/\/ max_locals\n-          Bytes[71]{\n-            0xBB00025912320312;\n-            0x34B70036B30038BB;\n-            0x000259123904123B;\n-            0xB70036B3003DBB00;\n-            0x0259123E051240B7;\n-            0x0036B3004206BD00;\n-            0x025903B200385359;\n-            0x04B2003D535905B2;\n-            0x004253B30012B1;\n-          };\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [1] { \/\/ Attributes\n-            Attr(#68, 18) { \/\/ LineNumberTable at 0x0565\n-              [4] { \/\/ LineNumberTable\n-                0  10; \/\/  at 0x0571\n-                15  11; \/\/  at 0x0575\n-                30  12; \/\/  at 0x0579\n-                45  9; \/\/  at 0x057D\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    } \/\/ Member\n-  } \/\/ methods\n-\n-  [2] { \/\/ Attributes\n-    Attr(#70, 2) { \/\/ Signature at 0x057F\n-      #3;\n-    } \/\/ end Signature\n-    ;\n-    Attr(#72, 2) { \/\/ SourceFile at 0x0587\n-      #6;\n-    } \/\/ end SourceFile\n-  } \/\/ Attributes\n-} \/\/ end class T\n","filename":"test\/langtools\/tools\/javac\/T6435291\/T.jcod","additions":0,"deletions":320,"binary":false,"changes":320,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug     6435291\n- * @summary javac shouldn't throw NPE while compiling invalid RuntimeInvisibleParameterAnnotations\n- * @author  Wei Tao\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.code\n- *          jdk.compiler\/com.sun.tools.javac.comp\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.javac.util\n- * @build T\n- * @run main\/othervm T6435291\n- *\/\n-\n-import com.sun.tools.javac.api.JavacTaskImpl;\n-import com.sun.tools.javac.code.ClassFinder.BadClassFile;\n-import com.sun.tools.javac.code.Symtab;\n-import com.sun.tools.javac.util.Names;\n-import javax.tools.ToolProvider;\n-\n-public class T6435291 {\n-    public static void main(String... args) {\n-        javax.tools.JavaCompiler tool = ToolProvider.getSystemJavaCompiler();\n-        JavacTaskImpl task = (JavacTaskImpl)tool.getTask(null, null, null, null, null, null);\n-        Symtab syms = Symtab.instance(task.getContext());\n-        Names names = Names.instance(task.getContext());\n-        task.ensureEntered();\n-        try {\n-            syms.enterClass(syms.unnamedModule, names.fromString(\"T\")).complete();\n-        } catch (BadClassFile e) {\n-            System.err.println(\"Passed: expected completion failure \" + e.getClass().getName());\n-            return;\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"Failed: unexpected exception\");\n-        }\n-        throw new RuntimeException(\"Failed: no error reported\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/T6435291\/T6435291.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -0,0 +1,544 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8024694 8334870\n+ * @summary Check javac can handle various Runtime(In)VisibleParameterAnnotations attribute combinations\n+ * @enablePreview\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ParameterAnnotations\n+*\/\n+\n+import java.io.OutputStream;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.MethodBuilder;\n+import java.lang.classfile.MethodElement;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.attribute.MethodParametersAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import java.lang.classfile.attribute.SignatureAttribute;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.ElementFilter;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class ParameterAnnotations extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new ParameterAnnotations().runTests();\n+    }\n+\n+    ParameterAnnotations() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testEnum(Path base) throws Exception {\n+        \/\/not parameterized:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public enum E {\n+                   A(0);\n+                   E(@Visible @Invisible long i) {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"E\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"@Invisible @Visible long\");\n+        \/\/parameterized:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public enum E {\n+                   A(0);\n+                   <T> E(@Visible @Invisible long i) {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"E\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"@Invisible @Visible long\");\n+        \/\/not parameterized, and no Signature attribute:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public enum E {\n+                   A(0);\n+                   E(@Visible @Invisible long i) {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"E\",\n+               NO_SIGNATURE,\n+               \"java.lang.String, int, @Invisible @Visible long\");\n+        \/\/not parameterized, and no Signature and MethodParameters attribute:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public enum E {\n+                   A(0);\n+                   E(@Visible @Invisible long i) {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"E\",\n+               NO_SIGNATURE_NO_METHOD_PARAMETERS,\n+               \"java.lang.String, int, @Invisible @Visible long\");\n+    }\n+\n+    @Test\n+    public void testInnerClass(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public class I {\n+                       public I(@Visible @Invisible long l) {}\n+                       public String toString() {\n+                           return T.this.toString(); \/\/force outer this capture\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$I\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"@Invisible @Visible long\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public class I {\n+                       public <T> I(@Visible @Invisible long l) {}\n+                       public String toString() {\n+                           return T.this.toString(); \/\/force outer this capture\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$I\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"@Invisible @Visible long\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public class I {\n+                       public I(@Visible @Invisible long l) {}\n+                       public String toString() {\n+                           return T.this.toString(); \/\/force outer this capture\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$I\",\n+               NO_SIGNATURE,\n+               \"@Invisible @Visible long\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public class I {\n+                       public I(@Visible @Invisible long l) {}\n+                       public String toString() {\n+                           return T.this.toString(); \/\/force outer this capture\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$I\",\n+               NO_SIGNATURE_NO_METHOD_PARAMETERS,\n+               \"@Invisible @Visible long\");\n+    }\n+\n+    @Test\n+    public void testCapturingLocal(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public void test(int i) {\n+                       class I {\n+                           public I(@Visible @Invisible long l) {}\n+                           public String toString() {\n+                               return T.this.toString() + i; \/\/force outer this capture\n+                           }\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$1I\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"@Invisible @Visible long\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public void test(int i) {\n+                       class I {\n+                           public <T> I(@Visible @Invisible long l) {}\n+                           public String toString() {\n+                               return T.this.toString() + i; \/\/force outer this capture\n+                           }\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$1I\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"@Invisible @Visible long\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public void test(int i) {\n+                       class I {\n+                           public I(@Visible @Invisible long l) {}\n+                           public String toString() {\n+                               return T.this.toString() + i; \/\/force outer this capture\n+                           }\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$1I\",\n+                NO_SIGNATURE,\n+               \"T, @Invisible @Visible long, int\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public void test(int i) {\n+                       class I {\n+                           public I(@Visible @Invisible long l) {}\n+                           public String toString() {\n+                               return T.this.toString() + i; \/\/force outer this capture\n+                           }\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$1I\",\n+                NO_SIGNATURE_NO_METHOD_PARAMETERS,\n+               \"T, @Invisible @Visible long, int\");\n+    }\n+\n+    @Test\n+    public void testSyntheticTests(Path base) throws Exception {\n+        \/\/Signature attribute will defined one parameter, but the\n+        \/\/Runtime(In)VisibleParameterAnnotations will define 3 parameters:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public void test(int i) {\n+                       class I {\n+                           public I(@Visible @Invisible long l) {}\n+                           public String toString() {\n+                               return T.this.toString() + i; \/\/force outer this capture\n+                           }\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$1I\",\n+                new MethodTransform() {\n+                    @Override\n+                    public void accept(MethodBuilder builder, MethodElement element) {\n+                        if (element instanceof RuntimeInvisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 1;\n+                            builder.accept(RuntimeInvisibleParameterAnnotationsAttribute.of(List.of(List.of(), annos.parameterAnnotations().get(0), List.of())));\n+                        } else if (element instanceof RuntimeVisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 1;\n+                            builder.accept(RuntimeVisibleParameterAnnotationsAttribute.of(List.of(List.of(), annos.parameterAnnotations().get(0), List.of())));\n+                        } else {\n+                            builder.accept(element);\n+                        }\n+                    }\n+                },\n+               \"@Invisible @Visible long\");\n+        \/\/no Signature attribute, no synthetic parameters,\n+        \/\/but less entries in Runtime(In)VisibleParameterAnnotations than parameters\n+        \/\/no way to map anything:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public T(int i, @Visible @Invisible long l, String s) {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T\",\n+                new MethodTransform() {\n+                    @Override\n+                    public void accept(MethodBuilder builder, MethodElement element) {\n+                        if (element instanceof RuntimeInvisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 3;\n+                            builder.accept(RuntimeInvisibleParameterAnnotationsAttribute.of(List.of(annos.parameterAnnotations().get(1))));\n+                        } else if (element instanceof RuntimeVisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 3;\n+                            builder.accept(RuntimeVisibleParameterAnnotationsAttribute.of(List.of(annos.parameterAnnotations().get(1))));\n+                        } else {\n+                            builder.accept(element);\n+                        }\n+                    }\n+                },\n+               \"int, long, java.lang.String\",\n+               \"- compiler.warn.runtime.invisible.parameter.annotations: T.class\",\n+               \"1 warning\");\n+        \/\/no Signature attribute, no synthetic parameters,\n+        \/\/but more entries in Runtime(In)VisibleParameterAnnotations than parameters\n+        \/\/no way to map anything:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public T(@Visible @Invisible long l) {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T\",\n+                new MethodTransform() {\n+                    @Override\n+                    public void accept(MethodBuilder builder, MethodElement element) {\n+                        if (element instanceof RuntimeInvisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 1;\n+                            builder.accept(RuntimeInvisibleParameterAnnotationsAttribute.of(List.of(List.of(), annos.parameterAnnotations().get(0), List.of())));\n+                        } else if (element instanceof RuntimeVisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 1;\n+                            builder.accept(RuntimeVisibleParameterAnnotationsAttribute.of(List.of(List.of(), annos.parameterAnnotations().get(0), List.of())));\n+                        } else {\n+                            builder.accept(element);\n+                        }\n+                    }\n+                },\n+               \"long\",\n+               \"- compiler.warn.runtime.invisible.parameter.annotations: T.class\",\n+               \"1 warning\");\n+        \/\/mismatched lengths on RuntimeVisibleParameterAnnotations and\n+        \/\/RuntimeInvisibleParameterAnnotations:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public T(@Visible @Invisible long l) {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T\",\n+                new MethodTransform() {\n+                    @Override\n+                    public void accept(MethodBuilder builder, MethodElement element) {\n+                        if (element instanceof RuntimeInvisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 1;\n+                            builder.accept(annos); \/\/keep intact\n+                        } else if (element instanceof RuntimeVisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 1;\n+                            builder.accept(RuntimeVisibleParameterAnnotationsAttribute.of(List.of(List.of(), annos.parameterAnnotations().get(0), List.of())));\n+                        } else {\n+                            builder.accept(element);\n+                        }\n+                    }\n+                },\n+               \"long\",\n+               \"- compiler.warn.runtime.visible.invisible.param.annotations.mismatch: T.class\",\n+               \"1 warning\");\n+    }\n+\n+    private MethodTransform NO_SIGNATURE = (builder, element) -> {\n+        if (element instanceof SignatureAttribute) {\n+            \/\/ignore\n+        } else {\n+            builder.with(element);\n+        }\n+    };\n+\n+    private MethodTransform NO_SIGNATURE_NO_METHOD_PARAMETERS = (builder, element) -> {\n+        if (element instanceof SignatureAttribute ||\n+            element instanceof MethodParametersAttribute) {\n+            \/\/ignore\n+        } else {\n+            builder.with(element);\n+        }\n+    };\n+\n+    private void doTest(Path base, String code, String binaryNameToCheck,\n+                        MethodTransform changeConstructor, String expectedOutput,\n+                        String... expectedDiagnostics) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src, code);\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+\n+        Path classfile = classes.resolve(binaryNameToCheck + \".class\");\n+        ClassFile cf = ClassFile.of();\n+\n+        ClassModel model = cf.parse(classfile);\n+\n+        byte[] newClassFile = cf.transform(model,\n+                                           ClassTransform.transformingMethods(m -> m.methodName()\n+                                                                                    .equalsString(\"<init>\"),\n+                                                                              changeConstructor));\n+\n+        try (OutputStream out = Files.newOutputStream(classfile)) {\n+            out.write(newClassFile);\n+        }\n+\n+        Task.Result result = new JavacTask(tb)\n+                .options(\"-classpath\", classes.toString(),\n+                        \"-processor\", TestAP.class.getName(),\n+                        \"-XDrawDiagnostics\",\n+                        \"-Xlint:classfile\")\n+                .outdir(classes)\n+                .classes(binaryNameToCheck)\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll();\n+        List<String> out = result.getOutputLines(Task.OutputKind.STDOUT);\n+        if (!out.equals(List.of(expectedOutput))) {\n+            throw new AssertionError(\"Expected: \" + List.of(expectedOutput) + \", but got: \" + out);\n+        }\n+        List<String> diagnostics =\n+                new ArrayList<>(result.getOutputLines(Task.OutputKind.DIRECT));\n+        diagnostics.remove(\"\");\n+        if (!diagnostics.equals(List.of(expectedDiagnostics))) {\n+            throw new AssertionError(\"Expected: \" + List.of(expectedDiagnostics) + \", but got: \" + diagnostics);\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    public static final class TestAP extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            for (TypeElement clazz : ElementFilter.typesIn(roundEnv.getRootElements())) {\n+                for (ExecutableElement el : ElementFilter.constructorsIn(clazz.getEnclosedElements())) {\n+                    String sep = \"\";\n+\n+                    for (VariableElement p : el.getParameters()) {\n+                        System.out.print(sep);\n+                        if (!p.getAnnotationMirrors().isEmpty()) {\n+                            System.out.print(p.getAnnotationMirrors()\n+                                              .stream()\n+                                              .map(m -> m.toString())\n+                                              .collect(Collectors.joining(\" \")));\n+                            System.out.print(\" \");\n+                        }\n+                        System.out.print(p.asType());\n+                        sep = \", \";\n+                    }\n+\n+                    System.out.println();\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latest();\n+        }\n+\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/parameter\/ParameterAnnotations.java","additions":544,"deletions":0,"binary":false,"changes":544,"status":"added"},{"patch":"@@ -57,1 +57,2 @@\n-compiler.misc.bad.runtime.invisible.param.annotations   # bad class file\n+compiler.warn.runtime.invisible.parameter.annotations   # bad class file\n+compiler.warn.runtime.visible.invisible.param.annotations.mismatch   # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}