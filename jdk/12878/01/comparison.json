{"files":[{"patch":"@@ -579,0 +579,19 @@\n+C2V_VMENTRY_NULL(jobject, lookupJClass, (JNIEnv* env, jobject, jlong jclass_value))\n+    if (jclass_value == 0L) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"jclass must not be zero\");\n+    }\n+    jclass mirror = reinterpret_cast<jclass>(jclass_value);\n+    \/\/ Since the jclass_value is passed as a jlong, we perform additional checks to prevent the caller from accidentally\n+    \/\/ sending a value that is not a JNI handle.\n+    if (JNIHandles::handle_type(thread, mirror) == JNIInvalidRefType) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"jclass is not a valid JNI reference\");\n+    }\n+    oop obj = JNIHandles::resolve(mirror);\n+    if (!java_lang_Class::is_instance(obj)) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"jclass must be a reference to the Class object\");\n+    }\n+    JVMCIKlassHandle klass(THREAD, java_lang_Class::as_Klass(obj));\n+    JVMCIObject result = JVMCIENV->get_jvmci_type(klass, JVMCI_CHECK_NULL);\n+    return JVMCIENV->get_jobject(result);\n+C2V_END\n+\n@@ -2829,0 +2848,1 @@\n+  {CC \"lookupJClass\",                                 CC \"(J)\" HS_RESOLVED_TYPE,                                                            FN_PTR(lookupJClass)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -252,0 +252,2 @@\n+    native HotSpotResolvedJavaType lookupJClass(long jclass);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -839,0 +839,20 @@\n+    \/**\n+     * Converts a HotSpot heap JNI {@code hotspot_jclass_value} to a {@link ResolvedJavaType},\n+     * provided that the {@code hotspot_jclass_value} is a valid JNI reference to a Java Class. If\n+     * this requirement is not met, {@link IllegalArgumentException} is thrown.\n+     *\n+     * @param hotspot_jclass_value a JNI reference to a {@link Class} value in the HotSpot heap\n+     * @return a {@link ResolvedJavaType} for the referenced type\n+     * @throws IllegalArgumentException if {@code hotspot_jclass_value} is not a valid JNI reference\n+     *             to a {@link Class} object in the HotSpot heap. It is the responsibility of the\n+     *             caller to make sure the argument is valid. The checks performed by this method\n+     *             are best effort. Hence, the caller must not rely on the checks and corresponding\n+     *             exceptions!\n+     *\/\n+    public HotSpotResolvedJavaType asResolvedJavaType(long hotspot_jclass_value) {\n+        if (hotspot_jclass_value == 0L) {\n+            return null;\n+        }\n+        return compilerToVm.lookupJClass(hotspot_jclass_value);\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}