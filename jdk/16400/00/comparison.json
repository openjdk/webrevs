{"files":[{"patch":"@@ -610,1 +610,1 @@\n-      java.base-copy jdk.jdeps-launchers\n+      java.base-copy jdk.jdeps-launchers jdk.compiler-launchers\n@@ -613,2 +613,2 @@\n-BUILDJDK_MODULES := $(sort $(foreach m, jdk.jlink $(INTERIM_IMAGE_MODULES), \\\n-    $(call FindTransitiveDepsForModule, $m) $m))\n+BUILDJDK_MODULES := $(sort $(foreach m, jdk.jlink jdk.compiler \\\n+    $(INTERIM_IMAGE_MODULES), $(call FindTransitiveDepsForModule, $m) $m))\n@@ -973,1 +973,8 @@\n-  jdk.compiler-gendata: $(GENSRC_MODULEINFO_TARGETS)\n+  jdk.compiler-gendata: $(GENSRC_MODULEINFO_TARGETS) $(JAVA_TARGETS)\n+  ifeq ($(CREATE_BUILDJDK), true)\n+    ifneq ($(CREATING_BUILDJDK), true)\n+      jdk.compiler-gendata: create-buildjdk\n+    endif\n+  else\n+    jdk.compiler-gendata: jdk.compiler-launchers\n+  endif\n","filename":"make\/Main.gmk","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -153,0 +153,1 @@\n+import java.nio.file.DirectoryStream;\n@@ -154,0 +155,1 @@\n+import java.util.function.Consumer;\n@@ -231,1 +233,1 @@\n-                              long timestamp, String currentVersion, String systemModules) throws IOException {\n+                              long timestamp, String currentVersion, String moduleClasses) throws IOException {\n@@ -236,0 +238,14 @@\n+        int currentVersionParsed = Integer.parseInt(currentVersion);\n+\n+        currentVersion = Integer.toString(currentVersionParsed, Character.MAX_RADIX);\n+        currentVersion = currentVersion.toUpperCase(Locale.ROOT);\n+\n+        String previousVersion = Integer.toString(currentVersionParsed - 1, Character.MAX_RADIX);\n+\n+        previousVersion = previousVersion.toUpperCase(Locale.ROOT);\n+\n+        \/\/load current version classes:\n+        Path moduleClassPath = Paths.get(moduleClasses);\n+\n+        loadVersionClassesFromDirectory(data.classes, data.modules, moduleClassPath, currentVersion, previousVersion);\n+\n@@ -244,2 +260,0 @@\n-                List<String> versionsList =\n-                        Collections.singletonList(mhd.versions);\n@@ -249,1 +263,1 @@\n-                                        versionsList);\n+                                        mhd.versions);\n@@ -296,7 +310,0 @@\n-        currentVersion = Integer.toString(Integer.parseInt(currentVersion), Character.MAX_RADIX);\n-        currentVersion = currentVersion.toUpperCase(Locale.ROOT);\n-\n-        openDirectory(directory2FileData, currentVersion + \"\/\")\n-                .add(new FileData(currentVersion + \"\/system-modules\",\n-                                  Files.readAllBytes(Paths.get(systemModules))));\n-\n@@ -791,1 +798,1 @@\n-                                 Iterable<String> versions)\n+                                 String versions)\n@@ -793,1 +800,3 @@\n-        for (String ver : versions) {\n+        \/\/ensure every module-info.class is written separatelly,\n+        \/\/so that the correct version is used for it:\n+        for (char ver : versions.toCharArray()) {\n@@ -802,1 +811,1 @@\n-                    String version) throws IOException {\n+                    char version) throws IOException {\n@@ -810,1 +819,3 @@\n-        addAttributes(moduleDescription, header, constantPool, attributesMap);\n+        String versionString = Character.toString(version);\n+        int versionNumber = Integer.parseInt(versionString, Character.MAX_RADIX);\n+        addAttributes(moduleDescription, header, constantPool, attributesMap, versionNumber);\n@@ -826,1 +837,1 @@\n-        doWrite(directory2FileData, version, moduleDescription.name, \"module-info\" + EXTENSION, classFile);\n+        doWrite(directory2FileData, versionString, moduleDescription.name, \"module-info\" + EXTENSION, classFile);\n@@ -927,1 +938,2 @@\n-                               Map<String, Attribute> attributes) {\n+                               Map<String, Attribute> attributes,\n+                               int version) {\n@@ -948,0 +960,1 @@\n+        int versionIdx = addString(cp, Integer.toString(version));\n@@ -953,1 +966,1 @@\n-                             0,\n+                             versionIdx,\n@@ -1126,2 +1139,3 @@\n-                        .map(p -> new MethodParameters_attribute.Entry(addString(constantPool, p.name),\n-                                                                        p.flags))\n+                        .map(p -> new MethodParameters_attribute.Entry(p.name == null || p.name.isEmpty() ? 0\n+                                                                                                          : addString(constantPool, p.name),\n+                                                                       p.flags))\n@@ -1495,1 +1509,1 @@\n-        ExcludeIncludeList currentEIList = excludesIncludes;\n+        ExcludeIncludeList currentEIList;\n@@ -1512,0 +1526,2 @@\n+        } else {\n+            currentEIList = excludesIncludes;\n@@ -1515,0 +1531,1 @@\n+        Map<String, String> extraModulesPackagesToDerive = new HashMap<>();\n@@ -1519,1 +1536,20 @@\n-                                 currentEIList, version);\n+                                 currentEIList, version,\n+                                 cf -> {\n+                                     PermittedSubclasses_attribute permitted = (PermittedSubclasses_attribute) cf.getAttribute(Attribute.PermittedSubclasses);\n+                                     if (permitted != null) {\n+                                         try {\n+                                             String currentPack = cf.getName().substring(0, cf.getName().lastIndexOf('\/'));\n+\n+                                             for (int i = 0; i < permitted.subtypes.length; i++) {\n+                                                 String permittedClassName = cf.constant_pool.getClassInfo(permitted.subtypes[i]).getName();\n+                                                 if (!currentEIList.accepts(permittedClassName, false)) {\n+                                                     String permittedPack = permittedClassName.substring(0, permittedClassName.lastIndexOf('\/'));\n+\n+                                                     extraModulesPackagesToDerive.put(permittedPack, currentPack);\n+                                                 }\n+                                             }\n+                                         } catch (ConstantPoolException ex) {\n+                                             throw new IllegalStateException(ex);\n+                                         }\n+                                     }\n+                                 });\n@@ -1525,0 +1561,141 @@\n+        \/\/derive extra module packages for permitted types based on on their supertypes:\n+        boolean modified;\n+\n+        do {\n+            modified = false;\n+\n+            for (Iterator<Entry<String, String>> it = extraModulesPackagesToDerive.entrySet().iterator(); it.hasNext();) {\n+                Entry<String, String> e = it.next();\n+                Optional<ModuleHeaderDescription> module = currentVersionModules.values().stream().map(md -> md.header.get(0)).filter(d -> containsPackage(d, e.getValue())).findAny();\n+                if (module.isPresent()) {\n+                    if (!module.get().extraModulePackages.contains(e.getKey())) {\n+                        module.get().extraModulePackages.add(e.getKey());\n+                    }\n+                    it.remove();\n+                    modified = true;\n+                }\n+            }\n+        } while (modified);\n+\n+        if (!extraModulesPackagesToDerive.isEmpty()) {\n+            throw new AssertionError(\"Cannot derive some owning modules: \" + extraModulesPackagesToDerive);\n+        }\n+\n+        finishClassLoading(classes, modules, currentVersionModules, currentVersionClasses, currentEIList, version, baseline);\n+    }\n+\n+    private boolean containsPackage(ModuleHeaderDescription module, String pack) {\n+        return module.exports.stream().filter(ed -> ed.packageName().equals(pack)).findAny().isPresent() ||\n+               module.extraModulePackages.contains(pack);\n+    }\n+\n+    private void loadVersionClassesFromDirectory(ClassList classes,\n+                                    Map<String, ModuleDescription> modules,\n+                                    Path modulesDirectory,\n+                                    String version,\n+                                    String baseline) {\n+        Map<String, ModuleDescription> currentVersionModules =\n+                new HashMap<>();\n+        ClassList currentVersionClasses = new ClassList();\n+        Set<String> privateIncludes = new HashSet<>();\n+        Set<String> includes = new HashSet<>();\n+        ExcludeIncludeList currentEIList = new ExcludeIncludeList(includes,\n+                privateIncludes,\n+                Collections.emptySet());\n+\n+        try {\n+            Map<Path, ModuleHeaderDescription> modulePath2Header = new HashMap<>();\n+            List<Path> pendingExportedDirectories = new ArrayList<>();\n+\n+            try (DirectoryStream<Path> ds = Files.newDirectoryStream(modulesDirectory)) {\n+                for (Path p : ds) {\n+                    Path moduleInfo = p.resolve(\"module-info.class\");\n+\n+                    if (Files.isReadable(moduleInfo)) {\n+                        ModuleDescription md;\n+\n+                        try (InputStream in = Files.newInputStream(moduleInfo)) {\n+                            md = inspectModuleInfoClassFile(in,\n+                                    currentVersionModules, version);\n+                        }\n+                        if (md == null) {\n+                            continue;\n+                        }\n+\n+                        modulePath2Header.put(p, md.header.get(0));\n+\n+                        Set<String> currentModuleExports =\n+                                md.header.get(0).exports.stream()\n+                                                        .filter(e -> !e.isQualified())\n+                                                        .map(e -> e.packageName + '\/')\n+                                                        .collect(Collectors.toSet());\n+\n+                        for (String dir : currentModuleExports) {\n+                            includes.add(dir);\n+                            pendingExportedDirectories.add(p.resolve(dir));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            List<String> pendingExtraClasses = new ArrayList<>();\n+\n+            for (Path exported : pendingExportedDirectories) {\n+                try (DirectoryStream<Path> ds = Files.newDirectoryStream(exported)) {\n+                    for (Path p2 : ds) {\n+                        if (!Files.isRegularFile(p2) || !p2.getFileName().toString().endsWith(\".class\")) {\n+                            continue;\n+                        }\n+\n+                        loadFromDirectoryHandleClassFile(p2, currentVersionClasses,\n+                                                         currentEIList, version,\n+                                                         pendingExtraClasses);\n+                    }\n+                }\n+            }\n+\n+            while (!pendingExtraClasses.isEmpty()) {\n+                String current = pendingExtraClasses.remove(pendingExtraClasses.size() - 1);\n+\n+                if (currentVersionClasses.find(current, true) != null) {\n+                    continue;\n+                }\n+\n+                for (Entry<Path, ModuleHeaderDescription> e : modulePath2Header.entrySet()) {\n+                    Path currentPath = e.getKey().resolve(current + \".class\");\n+\n+                    if (Files.isReadable(currentPath)) {\n+                        String pack = current.substring(0, current.lastIndexOf('\/'));\n+\n+                        e.getValue().extraModulePackages.add(pack);\n+\n+                        loadFromDirectoryHandleClassFile(currentPath, currentVersionClasses,\n+                                                         currentEIList, version,\n+                                                         pendingExtraClasses);\n+                    }\n+                }\n+            }\n+        } catch (IOException | ConstantPoolException ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+\n+        finishClassLoading(classes, modules, currentVersionModules, currentVersionClasses, currentEIList, version, baseline);\n+    }\n+\n+    private void loadFromDirectoryHandleClassFile(Path path, ClassList currentVersionClasses,\n+                                                  ExcludeIncludeList currentEIList, String version,\n+                                                  List<String> todo) throws IOException, ConstantPoolException {\n+        try (InputStream in = Files.newInputStream(path)) {\n+            inspectClassFile(in, currentVersionClasses,\n+                             currentEIList, version,\n+                             cf -> {\n+                                 Set<String> superTypes = otherRelevantTypesWithOwners(cf);\n+\n+                                 currentEIList.privateIncludeList.addAll(superTypes);\n+                                 todo.addAll(superTypes);\n+                             });\n+        }\n+    }\n+\n+    private void finishClassLoading(ClassList classes, Map<String, ModuleDescription> modules, Map<String, ModuleDescription> currentVersionModules, ClassList currentVersionClasses, ExcludeIncludeList currentEIList, String version,\n+                                    String baseline) {\n@@ -1566,0 +1743,5 @@\n+                    if (header.permittedSubclasses != null) {\n+                        for (String i : header.permittedSubclasses) {\n+                            modified |= include(includedClasses, currentVersionClasses, i);\n+                        }\n+                    }\n@@ -1965,0 +2147,5 @@\n+        inspectClassFile(in, classes, excludesIncludes, version, cf -> {});\n+    }\n+\n+    private void inspectClassFile(InputStream in, ClassList classes, ExcludeIncludeList excludesIncludes, String version,\n+                                  Consumer<ClassFile> extraTask) throws IOException, ConstantPoolException {\n@@ -1975,0 +2162,2 @@\n+        extraTask.accept(cf);\n+\n@@ -2035,1 +2224,1 @@\n-    private void inspectModuleInfoClassFile(InputStream in,\n+    private ModuleDescription inspectModuleInfoClassFile(InputStream in,\n@@ -2041,1 +2230,1 @@\n-            return ;\n+            return null;\n@@ -2051,1 +2240,1 @@\n-                return ;\n+                return null;\n@@ -2065,0 +2254,2 @@\n+\n+        return moduleDesc;\n@@ -2075,3 +2266,5 @@\n-                if (cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n-                    continue;\n-                }\n+                additionalIncludes.addAll(otherRelevantTypesWithOwners(cf));\n+            } catch (IOException | ConstantPoolException ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        }\n@@ -2079,1 +2272,2 @@\n-                Set<String> additionalClasses = new HashSet<>();\n+        return additionalIncludes;\n+    }\n@@ -2081,5 +2275,20 @@\n-                if (cf.super_class != 0) {\n-                    additionalClasses.add(cf.getSuperclassName());\n-                }\n-                for (int i = 0; i < cf.interfaces.length; i++) {\n-                    additionalClasses.add(cf.getInterfaceName(i));\n+    private Set<String> otherRelevantTypesWithOwners(ClassFile cf) {\n+        Set<String> supertypes = new HashSet<>();\n+\n+        try {\n+            if (cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n+                return supertypes;\n+            }\n+\n+            Set<String> additionalClasses = new HashSet<>();\n+\n+            if (cf.super_class != 0) {\n+                additionalClasses.add(cf.getSuperclassName());\n+            }\n+            for (int i = 0; i < cf.interfaces.length; i++) {\n+                additionalClasses.add(cf.getInterfaceName(i));\n+            }\n+            PermittedSubclasses_attribute permitted = (PermittedSubclasses_attribute) cf.getAttribute(Attribute.PermittedSubclasses);\n+            if (permitted != null) {\n+                for (int i = 0; i < permitted.subtypes.length; i++) {\n+                    additionalClasses.add(cf.constant_pool.getClassInfo(permitted.subtypes[i]).getName());\n@@ -2087,0 +2296,1 @@\n+            }\n@@ -2088,2 +2298,2 @@\n-                for (String additional : additionalClasses) {\n-                    int dollar;\n+            for (String additional : additionalClasses) {\n+                int dollar;\n@@ -2091,1 +2301,1 @@\n-                    additionalIncludes.add(additional);\n+                supertypes.add(additional);\n@@ -2093,4 +2303,3 @@\n-                    while ((dollar = additional.lastIndexOf('$')) != (-1)) {\n-                        additional = additional.substring(0, dollar);\n-                        additionalIncludes.add(additional);\n-                    }\n+                while ((dollar = additional.lastIndexOf('$')) != (-1)) {\n+                    additional = additional.substring(0, dollar);\n+                    supertypes.add(additional);\n@@ -2098,2 +2307,0 @@\n-            } catch (IOException | ConstantPoolException ex) {\n-                throw new IllegalStateException(ex);\n@@ -2101,1 +2308,0 @@\n-        }\n@@ -2103,1 +2309,4 @@\n-        return additionalIncludes;\n+            return supertypes;\n+        } catch (ConstantPoolException ex) {\n+            throw new IllegalStateException(ex);\n+        }\n@@ -2118,1 +2327,3 @@\n-        headerDesc.versions += version;\n+        if (!headerDesc.versions.contains(version)) {\n+            headerDesc.versions += version;\n+        }\n@@ -2162,1 +2373,3 @@\n-        headerDesc.versions += version;\n+        if (!headerDesc.versions.contains(version)) {\n+            headerDesc.versions += version;\n+        }\n@@ -4418,1 +4631,1 @@\n-                String systemModules;\n+                String moduleClasses;\n@@ -4426,1 +4639,1 @@\n-                    systemModules = args[5];\n+                    moduleClasses = args[5];\n@@ -4433,1 +4646,1 @@\n-                    systemModules = args[6];\n+                    moduleClasses = args[6];\n@@ -4449,1 +4662,1 @@\n-                                                  systemModules);\n+                                                  moduleClasses);\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":264,"deletions":51,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -26,0 +26,4 @@\n+default:all\n+\n+include $(SPEC)\n+include MakeBase.gmk\n@@ -39,1 +43,1 @@\n-CT_MODULES := $(DOCS_MODULES)\n+CT_MODULES := $(filter-out $(MODULES_FILTER), $(DOCS_MODULES))\n@@ -47,6 +51,6 @@\n-    --add-exports java.base\/jdk.internal.javac=java.compiler.interim,jdk.compiler.interim \\\n-    --add-exports jdk.internal.opt\/jdk.internal.opt=jdk.compiler.interim,jdk.javadoc.interim \\\n-    --add-exports jdk.compiler.interim\/com.sun.tools.javac.api=ALL-UNNAMED \\\n-    --add-exports jdk.compiler.interim\/com.sun.tools.javac.code=ALL-UNNAMED \\\n-    --add-exports jdk.compiler.interim\/com.sun.tools.javac.util=ALL-UNNAMED \\\n-    --add-exports jdk.compiler.interim\/com.sun.tools.javac.jvm=ALL-UNNAMED \\\n+    --add-modules jdk.compiler,jdk.jdeps \\\n+    --add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED \\\n+    --add-exports jdk.compiler\/com.sun.tools.javac.code=ALL-UNNAMED \\\n+    --add-exports jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED \\\n+    --add-exports jdk.compiler\/com.sun.tools.javac.jvm=ALL-UNNAMED \\\n+    --add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED \\\n@@ -55,0 +59,1 @@\n+# TODO: Unify with jdk.javadoc-gendata. Should only compile this once and share.\n@@ -56,3 +61,3 @@\n-    TARGET_RELEASE := $(TARGET_RELEASE_BOOTJDK), \\\n-    SRC := $(TOPDIR)\/make\/langtools\/src\/classes \\\n-        $(TOPDIR)\/src\/jdk.jdeps\/share\/classes, \\\n+    TARGET_RELEASE := $(TARGET_RELEASE_NEWJDK), \\\n+    COMPILER := buildjdk, \\\n+    SRC := $(TOPDIR)\/make\/langtools\/src\/classes, \\\n@@ -60,1 +65,1 @@\n-    BIN := $(BUILDTOOLS_OUTPUTDIR)\/create_symbols, \\\n+    BIN := $(BUILDTOOLS_OUTPUTDIR)\/create_symbols_javac, \\\n@@ -63,1 +68,0 @@\n-        $(INTERIM_LANGTOOLS_ARGS) \\\n@@ -70,1 +74,3 @@\n-    $(MODULE_INFOS)\n+    $(MODULE_INFOS) \\\n+    $(foreach m, $(CT_MODULES) $(call FindTransitiveIndirectDepsForModules, $(CT_MODULES)), \\\n+      $(call SetupJavaCompilationApiTarget, $m, $(JDK_OUTPUTDIR)\/modules\/$m))\n@@ -74,8 +80,1 @@\n-\t$(JAVA_SMALL) $(INTERIM_LANGTOOLS_ARGS) \\\n-\t    $(COMPILECREATESYMBOLS_ADD_EXPORTS) \\\n-\t    -classpath $(BUILDTOOLS_OUTPUTDIR)\/create_symbols \\\n-\t    build.tools.symbolgenerator.TransitiveDependencies \\\n-\t    $(@D)\/system-modules \\\n-\t    $(CT_MODULESOURCEPATH) \\\n-\t    $(CT_MODULES)\n-\t$(JAVA_SMALL) $(INTERIM_LANGTOOLS_ARGS) \\\n+\t$(BUILD_JAVA) \\\n@@ -83,1 +82,1 @@\n-\t    -classpath $(BUILDTOOLS_OUTPUTDIR)\/create_symbols \\\n+\t    -classpath $(BUILDTOOLS_OUTPUTDIR)\/create_symbols_javac \\\n@@ -90,1 +89,1 @@\n-\t    $(@D)\/system-modules\n+\t    $(JDK_OUTPUTDIR)\/modules\/\n@@ -102,0 +101,2 @@\n+\n+all: $(TARGETS)\n","filename":"make\/modules\/jdk.compiler\/Gendata.gmk","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.net.URI;\n@@ -51,2 +50,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -74,2 +71,0 @@\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n@@ -176,7 +171,0 @@\n-                        if (result == null) {\n-                            \/\/in jrt:\/\/, the classfile may have the .class extension:\n-                            result = (JavaFileObject) getFileForInput(location,\n-                                                                      \"\",\n-                                                                      fileName + \".class\");\n-                        }\n-\n@@ -185,2 +173,0 @@\n-                        } else {\n-                            return null;\n@@ -265,1 +251,0 @@\n-                    Path systemModules = root.resolve(ctSymVersion).resolve(\"system-modules\");\n@@ -284,12 +269,0 @@\n-                    } else if (Files.isRegularFile(systemModules)) {\n-                        fm.handleOption(\"--system\", Arrays.asList(\"none\").iterator());\n-\n-                        Path jrtModules =\n-                                FileSystems.getFileSystem(URI.create(\"jrt:\/\"))\n-                                           .getPath(\"modules\");\n-                        try (Stream<String> lines =\n-                                Files.lines(systemModules, UTF_8)) {\n-                            lines.map(line -> jrtModules.resolve(line))\n-                                 .filter(mod -> Files.exists(mod))\n-                                 .forEach(mod -> setModule(fm, mod));\n-                        }\n@@ -330,10 +303,0 @@\n-        private static void setModule(StandardJavaFileManager fm, Path mod) {\n-            try {\n-                fm.setLocationForModule(StandardLocation.SYSTEM_MODULES,\n-                                        mod.getFileName().toString(),\n-                                        Collections.singleton(mod));\n-            } catch (IOException ex) {\n-                throw new IllegalStateException(ex);\n-            }\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/platform\/JDKPlatformProvider.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-            var systemModules = targetDir.resolve(\"system-modules\");\n+            var modules = targetDir.resolve(\"modules\");\n@@ -115,1 +115,1 @@\n-            try (Writer w = Files.newBufferedWriter(systemModules)) {}\n+            Files.createDirectories(modules);\n@@ -129,1 +129,1 @@\n-                                               systemModules.toAbsolutePath().toString()});\n+                                               modules.toAbsolutePath().toString()});\n","filename":"test\/langtools\/tools\/javac\/platform\/CanHandleClassFilesTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318913\n+ * @summary Verify correct module versions are recorded when --release is used.\n+ * @library \/tools\/lib\n+ * @modules\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.platform\n+ *          jdk.compiler\/com.sun.tools.javac.util:+open\n+ * @run junit ModuleVersionTest\n+ *\/\n+\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleRequireInfo;\n+\n+import org.junit.Test;\n+\n+import toolbox.JavacTask;\n+import toolbox.ToolBox;\n+\n+import static org.junit.Assert.*;\n+public class ModuleVersionTest {\n+\n+    @Test\n+    public void testVersionInDependency() throws Exception {\n+        doTestVersionInDependency(\"17\");\n+        doTestVersionInDependency(System.getProperty(\"java.specification.version\"));\n+    }\n+\n+    private void doTestVersionInDependency(String specificationVersion) throws Exception {\n+        Path root = Paths.get(\".\");\n+        Path classes = root.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+        ToolBox tb = new ToolBox();\n+\n+        new JavacTask(tb)\n+            .outdir(classes)\n+            .options(\"--release\", specificationVersion)\n+            .sources(\"\"\"\n+                     module test {}\n+                     \"\"\",\n+                     \"\"\"\n+                     package test;\n+                     public class Test {\n+                     }\n+                     \"\"\")\n+            .run()\n+            .writeAll();\n+\n+        Path moduleInfo = classes.resolve(\"module-info.class\");\n+        ClassModel clazz = Classfile.of().parse(moduleInfo);\n+\n+        assertTrue(clazz.isModuleInfo());\n+        ModuleAttribute module = clazz.findAttribute(Attributes.MODULE).get();\n+        ModuleRequireInfo req = module.requires().get(0);\n+        assertEquals(\"java.base\", req.requires().name().stringValue());\n+        assertEquals(specificationVersion, req.requiresVersion().get().stringValue());\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/platform\/ModuleVersionTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318913\n+ * @summary Verify no error is when compiling a class whose permitted types are not exported\n+ * @modules jdk.compiler\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out -XDrawDiagnostics NonExportedPermittedTypes.java\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out --release 21 -XDrawDiagnostics NonExportedPermittedTypes.java\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out --release ${jdk.version} -XDrawDiagnostics NonExportedPermittedTypes.java\n+ *\/\n+\n+\n+import java.lang.constant.ConstantDesc;\n+\n+public class NonExportedPermittedTypes {\n+\n+    public void test1(ConstantDesc cd) {\n+        switch (cd) {\n+            case String s -> {}\n+        }\n+    }\n+\n+    public void test2(ConstantDesc cd) {\n+        switch (cd) {\n+            case String s -> {}\n+            default -> {}\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/platform\/NonExportedPermittedTypes.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+NonExportedPermittedTypes.java:40:9: compiler.err.not.exhaustive.statement\n+1 error\n","filename":"test\/langtools\/tools\/javac\/platform\/NonExportedPermittedTypes.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @compile --release ${jdk.version} NonExportedSuperTypes.java\n","filename":"test\/langtools\/tools\/javac\/platform\/NonExportedSuperTypes.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318913\n+ * @summary Ensure release and enable-preview work well together.\n+ * @modules jdk.compiler\n+ * @compile --release ${jdk.version} --enable-preview ReleaseAndEnablePreview.java\n+ *\/\n+\n+public class ReleaseAndEnablePreview {\n+\n+    public String evt(String str) {\n+        return str.length() + \"\" + str.charAt(0);\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/platform\/ReleaseAndEnablePreview.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -754,1 +754,1 @@\n-        Path systemModules = ctSym.resolve(\"systemModules\");\n+        Path modules = ctSym.resolve(\"modules\");\n@@ -756,1 +756,1 @@\n-        Files.newBufferedWriter(systemModules).close();\n+        Files.createDirectories(modules);\n@@ -761,1 +761,1 @@\n-        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classesZip.toAbsolutePath().toString(), 0, \"9\", systemModules.toString());\n+        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classesZip.toAbsolutePath().toString(), 0, \"9\", modules.toString());\n@@ -1040,1 +1040,1 @@\n-        Path systemModules = descDest.resolve(\"systemModules\");\n+        Path modules = descDest.resolve(\"modules\");\n@@ -1042,1 +1042,1 @@\n-        Files.newBufferedWriter(systemModules).close();\n+        Files.createDirectories(modules);\n@@ -1045,1 +1045,1 @@\n-        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classDest, 0, \"8\", systemModules.toString());\n+        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classDest, 0, \"8\", modules.toString());\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}