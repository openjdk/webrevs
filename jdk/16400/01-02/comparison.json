{"files":[{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package build.tools.symbolgenerator;\n-\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Writer;\n-import java.nio.charset.Charset;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayDeque;\n-import java.util.Arrays;\n-import java.util.Deque;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.ModuleElement.RequiresDirective;\n-import javax.lang.model.util.Elements;\n-import javax.tools.JavaCompiler;\n-\n-import com.sun.tools.javac.api.JavacTaskImpl;\n-import com.sun.tools.javac.api.JavacTool;\n-import com.sun.tools.javac.code.Source;\n-import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n-import com.sun.tools.javac.jvm.Target;\n-\n-\/**\n- * Write reflexive transitive closure of the given modules along their requires transitive edges into\n- * file <version>\/system-modules in the specified directory.\n- *\/\n-public class TransitiveDependencies {\n-\n-    private static void help() {\n-        System.err.println(\"java TransitiveDependencies <target-directory> <module-source-path> <root-modules>\");\n-    }\n-\n-    public static void main(String... args) throws IOException {\n-        if (args.length < 2) {\n-            help();\n-            return ;\n-        }\n-\n-        JavaCompiler compiler = JavacTool.create();\n-        List<String> options = List.of(\"-source\", Source.DEFAULT.name,\n-                                       \"-target\", Target.DEFAULT.name,\n-                                       \"-proc:only\",\n-                                       \"--system\", \"none\",\n-                                       \"--module-source-path\", args[1],\n-                                       \"--add-modules\", Arrays.stream(args)\n-                                                              .skip(2)\n-                                                              .collect(Collectors.joining(\",\")));\n-        List<String> jlObjectList = List.of(\"java.lang.Object\");\n-        JavacTaskImpl task = (JavacTaskImpl) compiler.getTask(null, null, null, options, jlObjectList, null);\n-        task.enter();\n-        Elements elements = task.getElements();\n-        Deque<String> todo = new ArrayDeque<>();\n-        Arrays.stream(args).skip(2).forEach(todo::add);\n-        Set<String> allModules = new HashSet<>();\n-\n-        while (!todo.isEmpty()) {\n-            String current = todo.removeFirst();\n-\n-            if (!allModules.add(current))\n-                continue;\n-\n-            ModuleSymbol mod = (ModuleSymbol) elements.getModuleElement(current);\n-\n-            if (mod == null) {\n-                throw new IllegalStateException(\"Missing: \" + current);\n-            }\n-\n-             \/\/use the internal structure to avoid unnecessarily completing the symbol using the UsesProvidesVisitor:\n-            for (RequiresDirective rd : mod.requires) {\n-                if (rd.isTransitive()) {\n-                    todo.offerLast(rd.getDependency().getQualifiedName().toString());\n-                }\n-            }\n-        }\n-\n-        allModules.add(\"java.base\");\n-        allModules.add(\"jdk.unsupported\");\n-\n-        Path targetFile = Paths.get(args[0]);\n-\n-        Files.createDirectories(targetFile.getParent());\n-\n-        try (Writer w = Files.newBufferedWriter(targetFile);\n-             PrintWriter out = new PrintWriter(w)) {\n-            allModules.stream()\n-                      .sorted()\n-                      .forEach(out::println);\n-        }\n-    }\n-\n-}\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/TransitiveDependencies.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"}]}