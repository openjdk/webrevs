{"files":[{"patch":"@@ -54,1 +54,0 @@\n-     * <li>not be abstract<\/li>\n@@ -92,1 +91,1 @@\n-        if (mainMethod == null) {\n+        if (mainMethod == null || !isValidMainMethod(mainMethod)) {\n@@ -96,1 +95,1 @@\n-        if (mainMethod == null) {\n+        if (mainMethod == null || !isValidMainMethod(mainMethod)) {\n@@ -100,1 +99,2 @@\n-        int mods = mainMethod.getModifiers();\n+        return mainMethod;\n+    }\n@@ -102,5 +102,3 @@\n-        if (Modifier.isAbstract(mods) ||\n-                mainMethod.getReturnType() != void.class ||\n-                Modifier.isPrivate(mods)) {\n-            return null;\n-        }\n+    private static boolean isValidMainMethod(Method mainMethodCandidate) {\n+        return mainMethodCandidate.getReturnType() == void.class &&\n+               !Modifier.isPrivate(mainMethodCandidate.getModifiers());\n@@ -108,1 +106,0 @@\n-        return mainMethod;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MethodFinder.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -951,0 +951,3 @@\n+            if (Modifier.isAbstract(mainClass.getModifiers())) {\n+                abort(null, \"java.launcher.cls.error8\", className);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -282,0 +282,3 @@\n+java.launcher.cls.error8=\\\n+    Error: abstract class {0} can not be instantiated\\n\\\n+    please use a concrete class\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,0 +230,4 @@\n+            if (Modifier.isAbstract(mainClass.getModifiers())) {\n+                throw new Fault(Errors.CantInstantiate(mainClassName));\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/SourceLauncher.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,5 @@\n-    can''t find main(String[]) method in class: {0}\n+    can''t find main(String[]) or main() method in class: {0}\n+\n+# 0: string\n+launcher.err.cant.instantiate=\\\n+    abstract class: {0} can not be instantiated\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/launcher.properties","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -604,0 +604,48 @@\n+\n+        \/\/private method with parameter, usable method without parameter:\n+        createJar(new File(\"some.jar\"), new File(\"Foo\"),\n+            \"private static void main(String[] args){}\",\n+            \"void main() {System.out.println(\\\"THE_CHOSEN_ONE\\\");}\");\n+        tr = doExec(javaCmd, \"-jar\", \"some.jar\");\n+        tr.contains(\"THE_CHOSEN_ONE\");\n+        if (!tr.testStatus)\n+            System.out.println(tr);\n+\n+        createJar(new File(\"some.jar\"), new File(\"Foo\"),\n+            \"private void main(String[] args){}\",\n+            \"void main() {System.out.println(\\\"THE_CHOSEN_ONE\\\");}\");\n+        tr = doExec(javaCmd, \"-jar\", \"some.jar\");\n+        tr.contains(\"THE_CHOSEN_ONE\");\n+        if (!tr.testStatus)\n+            System.out.println(tr);\n+\n+        \/\/method with a wrong return type with parameter, usable method without parameter:\n+        createJar(new File(\"some.jar\"), new File(\"Foo\"),\n+            \"public static int main(String[] args){ return -1; }\",\n+            \"void main() {System.out.println(\\\"THE_CHOSEN_ONE\\\");}\");\n+        tr = doExec(javaCmd, \"-jar\", \"some.jar\");\n+        tr.contains(\"THE_CHOSEN_ONE\");\n+        if (!tr.testStatus)\n+            System.out.println(tr);\n+\n+        createJar(new File(\"some.jar\"), new File(\"Foo\"),\n+            \"public int main(String[] args){ return -1; }\",\n+            \"void main() {System.out.println(\\\"THE_CHOSEN_ONE\\\");}\");\n+        tr = doExec(javaCmd, \"-jar\", \"some.jar\");\n+        tr.contains(\"THE_CHOSEN_ONE\");\n+        if (!tr.testStatus)\n+            System.out.println(tr);\n+\n+        \/\/ instance method abstract class:\n+        createJarForSource(null, new File(\"some.jar\"), new File(\"Foo\"),\n+                \"\"\"\n+                public abstract class Foo {\n+                    void main() {\n+                        System.out.println(\"Cannot be called.\");\n+                    }\n+                }\n+                \"\"\");\n+        tr = doExec(javaCmd, \"-jar\", \"some.jar\");\n+        tr.contains(\"Error: abstract class Foo can not be instantiated\");\n+        if (!tr.testStatus)\n+            System.out.println(tr);\n","filename":"test\/jdk\/tools\/launcher\/Arrrghs.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+import java.util.stream.Collectors;\n@@ -67,0 +68,1 @@\n+    static final String NL = System.getProperty(\"line.separator\");\n@@ -290,0 +292,10 @@\n+        String source =\n+                Arrays.stream(mainDefs != null ? mainDefs : new String[0])\n+                      .collect(Collectors.joining(NL,\n+                                                  \"public class Foo {\" + NL,\n+                                                  \"}\" + NL));\n+        createJarForSource(mEntry, jarName, mainClass, source);\n+    }\n+\n+    static void createJarForSource(String mEntry, File jarName, File mainClass,\n+            String source) throws FileNotFoundException {\n@@ -294,7 +306,1 @@\n-            ps.println(\"public class Foo {\");\n-            if (mainDefs != null) {\n-                for (String x : mainDefs) {\n-                    ps.println(x);\n-                }\n-            }\n-            ps.println(\"}\");\n+            ps.println(source);\n","filename":"test\/jdk\/tools\/launcher\/TestHelper.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -604,1 +604,1 @@\n-                \"error: can't find main(String[]) method in class: NoMain\");\n+                \"error: can't find main(String[]) or main() method in class: NoMain\");\n@@ -612,1 +612,1 @@\n-                \"error: can't find main(String[]) method in class: BadParams\");\n+                \"error: can't find main(String[]) or main() method in class: BadParams\");\n@@ -620,1 +620,1 @@\n-                \"error: can't find main(String[]) method in class: NotVoid\");\n+                \"error: can't find main(String[]) or main() method in class: NotVoid\");\n@@ -777,0 +777,76 @@\n+    @Test\n+    public void testAbstractClassInstanceMain(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+                          \"\"\"\n+                          public abstract class AbstractMain {\n+                              void main(String[] args) {}\n+                          }\n+                          \"\"\");\n+        testError(base.resolve(\"AbstractMain.java\"), \"\",\n+                \"error: abstract class: AbstractMain can not be instantiated\");\n+    }\n+\n+    @Test\n+    public void testWrongMainPrivate(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+                          \"\"\"\n+                          public class WrongMainPrivate {\n+                              private static void main(String[] args) {}\n+                              void main() {\n+                                  System.out.println(\"correct\");\n+                              }\n+                          }\n+                          \"\"\");\n+        testSuccess(base.resolve(\"WrongMainPrivate.java\"),\n+                    \"correct\\n\");\n+    }\n+\n+    @Test\n+    public void testWrongMainPrivateInstance(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+                          \"\"\"\n+                          public class WrongMainPrivate {\n+                              private void main(String[] args) {}\n+                              void main() {\n+                                  System.out.println(\"correct\");\n+                              }\n+                          }\n+                          \"\"\");\n+        testSuccess(base.resolve(\"WrongMainPrivate.java\"),\n+                    \"correct\\n\");\n+    }\n+\n+    @Test\n+    public void testWrongMainReturnType(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+                          \"\"\"\n+                          public class WrongMainReturnType {\n+                              public static int main(String[] args) {\n+                                  return -1;\n+                              }\n+                              void main() {\n+                                  System.out.println(\"correct\");\n+                              }\n+                          }\n+                          \"\"\");\n+        testSuccess(base.resolve(\"WrongMainReturnType.java\"),\n+                    \"correct\\n\");\n+    }\n+\n+    @Test\n+    public void testWrongMainReturnTypeInstance(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+                          \"\"\"\n+                          public class WrongMainReturnType {\n+                              public int main(String[] args) {\n+                                  return -1;\n+                              }\n+                              void main() {\n+                                  System.out.println(\"correct\");\n+                              }\n+                          }\n+                          \"\"\");\n+        testSuccess(base.resolve(\"WrongMainReturnType.java\"),\n+                    \"correct\\n\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":79,"deletions":3,"binary":false,"changes":82,"status":"modified"}]}