{"files":[{"patch":"@@ -59,1 +59,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -192,3 +192,37 @@\n-    public final MemorySegment fill(byte value){\n-        checkAccess(0, length, false);\n-        SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n+    public final MemorySegment fill(byte value) {\n+        if ((length & ~7) == 0) { \/\/ 0 <= length < 8\n+            \/\/ Handle smaller fills directly without having to transition to native code.\n+            final int valueUnsigned = Byte.toUnsignedInt(value);\n+            final int intValue = valueUnsigned | valueUnsigned << 8 | valueUnsigned << 16 | valueUnsigned << 24;\n+            \/\/ Use the old switch statement syntax to improve startup time\n+            switch ((int) length) {\n+                case 0 : checkReadOnly(false); checkValidState(); break; \/\/ Implicit test\n+                case 1 : set(JAVA_BYTE, 0, value); break;\n+                case 2 : set(JAVA_SHORT_UNALIGNED, 0, (short) intValue); break;\n+                case 3 : {\n+                    set(JAVA_SHORT_UNALIGNED, 0, (short) intValue);\n+                    set(JAVA_BYTE, 2, value);\n+                    break;\n+                }\n+                case 4 : set(JAVA_INT_UNALIGNED, 0, intValue); break;\n+                case 5 : {\n+                    set(JAVA_INT_UNALIGNED, 0, intValue);\n+                    set(JAVA_BYTE, 4, value);\n+                    break;\n+                }\n+                case 6 : {\n+                    set(JAVA_INT_UNALIGNED, 0, intValue);\n+                    set(JAVA_SHORT_UNALIGNED, 4, (short) intValue);\n+                    break;\n+                }\n+                case 7 : {\n+                    set(JAVA_INT_UNALIGNED, 0, intValue);\n+                    set(JAVA_SHORT_UNALIGNED, 4, (short) intValue);\n+                    set(JAVA_BYTE, 6, value);\n+                    break;\n+                }\n+            }\n+        } else {\n+            checkReadOnly(false);\n+            SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test MemorySegment::fill\n+ * @run junit TestFill\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class TestFill {\n+\n+    \/\/ Make sure negative values are treated as expected\n+    private static final byte VALUE = -71;\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    public void testFill(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(10);\n+            var slice = segment.asSlice(0, len);\n+            slice.fill(VALUE);\n+\n+            var expected = new byte[10];\n+            Arrays.fill(expected, 0, len, VALUE);\n+\n+            assertArrayEquals(expected, segment.toArray(ValueLayout.JAVA_BYTE));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    public void testReadOnly(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(10).asReadOnly();\n+            assertThrows(IllegalArgumentException.class, () -> segment.fill(VALUE));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    public void testConfinement(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(10);\n+            AtomicReference<RuntimeException> ex = new AtomicReference<>();\n+            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n+                try {\n+                    segment.fill(VALUE);\n+                } catch (RuntimeException e) {\n+                    ex.set(e);\n+                }\n+            });\n+            future.join();\n+            assertInstanceOf(WrongThreadException.class, ex.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    public void testScope(int len) {\n+        var arena = Arena.ofConfined();\n+        var segment = arena.allocate(len);\n+        arena.close();\n+        assertThrows(IllegalStateException.class, () -> segment.fill(VALUE));\n+    }\n+\n+    private static Stream<Arguments> sizes() {\n+        return IntStream.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n+                .boxed()\n+                .map(Arguments::of);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestFill.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class TestFill {\n+\n+    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"16\", \"32\", \"64\", \"128\"})\n+    public int ELEM_SIZE;\n+\n+    byte[] array;\n+    MemorySegment heapSegment;\n+    MemorySegment nativeSegment;\n+    ByteBuffer buffer;\n+\n+    @Setup\n+    public void setup() {\n+        array = new byte[ELEM_SIZE];\n+        heapSegment = MemorySegment.ofArray(array);\n+        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n+        buffer = ByteBuffer.wrap(array);\n+    }\n+\n+    @Benchmark\n+    public void arrays_fill() {\n+        Arrays.fill(array, (byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void heap_segment_fill() {\n+        heapSegment.fill((byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void native_segment_fill() {\n+        nativeSegment.fill((byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void buffer_fill() {\n+        \/\/ Hopefully, the creation of the intermediate array will be optimized away.\n+        buffer.clear().put(new byte[ELEM_SIZE]);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestFill.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}