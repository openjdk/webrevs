{"files":[{"patch":"@@ -1,65 +0,0 @@\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3)\n-public class TestBranchFill {\n-\n-    @Param({\"false\", \"true\"})\n-    private boolean shuffle;\n-    private MemorySegment[] segments;\n-    @Param({ \"1024\", \"128000\"})\n-    private int samples;\n-    private byte[] segmentSequence;\n-\n-    @Setup\n-    public void setup() {\n-        segments = new MemorySegment[8];\n-        \/\/ still allocates 8 different arrays\n-        for (int i = 0; i < 8; i++) {\n-            \/\/ we always pay the most of the cost here, for fun\n-            byte[] a = shuffle? new byte[i + 1] : new byte[8];\n-            segments[i] = MemorySegment.ofArray(a);\n-        }\n-        segmentSequence = new byte[samples];\n-        var rnd = new Random(42);\n-        for(int i = 0; i < samples; i++) {\n-            \/\/ if shuffle == false always fall into the \"worst\" case of populating 8 bytes\n-            segmentSequence[i] = (byte) rnd.nextInt(0, 8);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void heap_segment_fill() {\n-        var segments = this.segments;\n-        for (int nextIndex : segmentSequence) {\n-            fill(segments[nextIndex]);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill(MemorySegment segment) {\n-        segment.fill((byte) 0);\n-    }\n-\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestBranchFill.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"}]}