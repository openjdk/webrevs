{"files":[{"patch":"@@ -54,0 +54,1 @@\n+import jdk.internal.util.Architecture;\n@@ -191,0 +192,4 @@\n+    \/\/ FILL_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n+    \/\/ Update the value for Aarch64 once 8338975 is fixed.\n+    private static final long FILL_NATIVE_THRESHOLD = 1L << (Architecture.isAARCH64() ? 10 : 5);\n+\n@@ -194,1 +199,36 @@\n-        SCOPED_MEMORY_ACCESS.setMemory(this, value);\n+        \/\/ 0...0X...XXXX implies: 0 <= length < FILL_NATIVE_LIMIT\n+        if ((length & -FILL_NATIVE_THRESHOLD) == 0) {\n+            \/\/ Handle smaller segments directly without transitioning to native code\n+            if (length == 0) {\n+                \/\/ Implicit state check\n+                checkValidState();\n+                return this;\n+            }\n+            final long u = Byte.toUnsignedLong(value);\n+            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+\n+            int offset = 0;\n+            \/\/ 0...0X...X000\n+            final int limit = (int) (length & (FILL_NATIVE_THRESHOLD - 8));\n+            for (; offset < limit; offset += 8) {\n+                SCOPED_MEMORY_ACCESS.putLong(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, longValue);\n+            }\n+            \/\/ 0...0X00\n+            if ((length & 4) != 0) {\n+                SCOPED_MEMORY_ACCESS.putInt(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (int) longValue);\n+                offset += 4;\n+            }\n+            \/\/ 0...00X0\n+            if ((length & 2) != 0) {\n+                SCOPED_MEMORY_ACCESS.putShort(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (short) longValue);\n+                offset += 2;\n+            }\n+            \/\/ 0...000X\n+            if ((length & 1) != 0) {\n+                SCOPED_MEMORY_ACCESS.putByte(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, value);\n+            }\n+            \/\/ We have now fully handled 0...0X...XXXX\n+        } else {\n+            \/\/ Handle larger segments via native calls\n+            SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-import jdk.internal.util.Architecture;\n@@ -187,1 +186,1 @@\n-    public void setMemory(AbstractMemorySegmentImpl segment, byte value) {\n+    public void setMemory(MemorySessionImpl session, Object o, long offset, long bytes, byte value) {\n@@ -189,1 +188,1 @@\n-            setMemoryInternal(segment, segment.byteSize(), value);\n+            setMemoryInternal(session, o, offset, bytes, value);\n@@ -195,4 +194,0 @@\n-    \/\/ FILL_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n-    \/\/ Update the value for Aarch64 once 8338975 is fixed.\n-    private static final long FILL_NATIVE_THRESHOLD = 1L << (Architecture.isAARCH64() ? 10 : 5);\n-\n@@ -200,2 +195,1 @@\n-    private void setMemoryInternal(AbstractMemorySegmentImpl segment, long length, byte value) {\n-        final MemorySessionImpl session = segment.sessionImpl();\n+    private void setMemoryInternal(MemorySessionImpl session, Object o, long offset, long bytes, byte value) {\n@@ -206,31 +200,1 @@\n-            \/\/ 0...0X...XXXX implies: 0 <= length < FILL_NATIVE_LIMIT\n-            if ((length & -FILL_NATIVE_THRESHOLD) == 0) {\n-                \/\/ Handle smaller segments directly without transitioning to native code\n-                final long u = Byte.toUnsignedLong(value);\n-                final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n-\n-                int offset = 0;\n-                \/\/ 0...0X...X000\n-                final int limit = (int) (length & (FILL_NATIVE_THRESHOLD - 8));\n-                for (; offset < limit; offset += 8) {\n-                    UNSAFE.putLong(segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, longValue);\n-                }\n-                \/\/ 0...0X00\n-                if ((length & 4) != 0) {\n-                    UNSAFE.putInt(segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, (int) longValue);\n-                    offset += 4;\n-                }\n-                \/\/ 0...00X0\n-                if ((length & 2) != 0) {\n-                    UNSAFE.putShort(segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, (short) longValue);\n-                    offset += 2;\n-                }\n-                \/\/ 0...000X\n-                if ((length & 1) != 0) {\n-                    UNSAFE.putByte(segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, value);\n-                }\n-                \/\/ We have now fully handled 0...0X...XXXX\n-            } else {\n-                \/\/ Handle larger segments via native calls\n-                UNSAFE.setMemory(segment.unsafeGetBase(), segment.unsafeGetOffset(), length, value);\n-            }\n+            UNSAFE.setMemory(o, offset, bytes, value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":5,"deletions":41,"binary":false,"changes":46,"status":"modified"}]}