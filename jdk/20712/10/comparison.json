{"files":[{"patch":"@@ -54,0 +54,1 @@\n+import jdk.internal.util.Architecture;\n@@ -191,0 +192,4 @@\n+    \/\/ FILL_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n+    \/\/ Update the value for Aarch64 once 8338975 is fixed.\n+    private static final long FILL_NATIVE_THRESHOLD = 1L << (Architecture.isAARCH64() ? 10 : 5);\n+\n@@ -192,3 +197,41 @@\n-    public final MemorySegment fill(byte value){\n-        checkAccess(0, length, false);\n-        SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n+    @ForceInline\n+    public final MemorySegment fill(byte value) {\n+        checkReadOnly(false);\n+        if (length == 0) {\n+            \/\/ Implicit state check\n+            checkValidState();\n+        } else if (length < FILL_NATIVE_THRESHOLD) {\n+            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+\n+            \/\/ Handle smaller segments directly without transitioning to native code\n+            final long u = Byte.toUnsignedLong(value);\n+            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+\n+            int offset = 0;\n+            \/\/ 0...0X...X000\n+            final int limit = (int) (length & (FILL_NATIVE_THRESHOLD - 8));\n+            for (; offset < limit; offset += 8) {\n+                SCOPED_MEMORY_ACCESS.putLong(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, longValue);\n+            }\n+            int remaining = (int) length - limit;\n+            \/\/ 0...0X00\n+            if (remaining >= 4) {\n+                SCOPED_MEMORY_ACCESS.putInt(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (int) longValue);\n+                offset += 4;\n+                remaining -= 4;\n+            }\n+            \/\/ 0...00X0\n+            if (remaining >= 2) {\n+                SCOPED_MEMORY_ACCESS.putShort(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (short) longValue);\n+                offset += 2;\n+                remaining -= 2;\n+            }\n+            \/\/ 0...000X\n+            if (remaining == 1) {\n+                SCOPED_MEMORY_ACCESS.putByte(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, value);\n+            }\n+            \/\/ We have now fully handled 0...0X...XXXX\n+        } else {\n+            \/\/ Handle larger segments via native calls\n+            SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":46,"deletions":3,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test MemorySegment::fill\n+ * @run junit TestFill\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestFill {\n+\n+    \/\/ Make sure negative values are treated as expected\n+    private static final byte VALUE = -71;\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testFill(int len) {\n+        int offset = 16;\n+        int expandedLen = offset + MAX_SIZE + offset;\n+\n+        \/\/ Make sure fill only affects the intended region XXXXXX\n+        \/\/\n+        \/\/ ................XXXXXX................\n+        \/\/ |    offset     | len |    offset     |\n+\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(expandedLen);\n+            var slice = segment.asSlice(offset, len);\n+            slice.fill(VALUE);\n+\n+            var expected = new byte[expandedLen];\n+            Arrays.fill(expected, offset, offset + len, VALUE);\n+\n+            \/\/ This checks the actual fill region as well as potential under and overflows\n+            assertArrayEquals(expected, segment.toArray(ValueLayout.JAVA_BYTE));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"values\")\n+    void testValues(int value) {\n+        int size = 0b1111;\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(size);\n+            segment.fill((byte) value);\n+            assertTrue(segment.elements(ValueLayout.JAVA_BYTE)\n+                    .map(s -> s.get(ValueLayout.JAVA_BYTE, 0))\n+                    .allMatch(v -> v == value), \"Failed to fill with value \" + value);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testReadOnly(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(10).asReadOnly();\n+            assertThrows(IllegalArgumentException.class, () -> segment.fill(VALUE));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testConfinement(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(10);\n+            AtomicReference<RuntimeException> ex = new AtomicReference<>();\n+            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n+                try {\n+                    segment.fill(VALUE);\n+                } catch (RuntimeException e) {\n+                    ex.set(e);\n+                }\n+            });\n+            future.join();\n+            assertInstanceOf(WrongThreadException.class, ex.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testScope(int len) {\n+        var arena = Arena.ofConfined();\n+        var segment = arena.allocate(len);\n+        arena.close();\n+        assertThrows(IllegalStateException.class, () -> segment.fill(VALUE));\n+    }\n+\n+    private static final int MAX_SIZE = 1 << 10;\n+\n+    private static Stream<Arguments> sizes() {\n+        return IntStream.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 23, 32, 63, 128, 256, 511, MAX_SIZE)\n+                .boxed()\n+                .map(Arguments::of);\n+    }\n+\n+    private static Stream<Arguments> values() {\n+        return IntStream.rangeClosed(Byte.MIN_VALUE, Byte.MAX_VALUE)\n+                .boxed()\n+                .map(Arguments::of);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestFill.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class TestBranchFill {\n+\n+    @Param({\"false\", \"true\"})\n+    private boolean shuffle;\n+    private MemorySegment[] segments;\n+    @Param({ \"1024\", \"128000\"})\n+    private int samples;\n+    private byte[] segmentSequence;\n+\n+    @Setup\n+    public void setup() {\n+        segments = new MemorySegment[8];\n+        \/\/ still allocates 8 different arrays\n+        for (int i = 0; i < 8; i++) {\n+            \/\/ we always pay the most of the cost here, for fun\n+            byte[] a = shuffle? new byte[i + 1] : new byte[8];\n+            segments[i] = MemorySegment.ofArray(a);\n+        }\n+        segmentSequence = new byte[samples];\n+        var rnd = new Random(42);\n+        for(int i = 0; i < samples; i++) {\n+            \/\/ if shuffle == false always fall into the \"worst\" case of populating 8 bytes\n+            segmentSequence[i] = (byte) rnd.nextInt(0, 8);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void heap_segment_fill() {\n+        var segments = this.segments;\n+        for (int nextIndex : segmentSequence) {\n+            fill(segments[nextIndex]);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void fill(MemorySegment segment) {\n+        segment.fill((byte) 0);\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestBranchFill.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class TestFill {\n+\n+    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\n+            \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\n+            \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\n+            \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\",\n+            \"32\", \"128\", \"256\", \"384\", \"511\", \"512\"})\n+    public int ELEM_SIZE;\n+\n+    byte[] array;\n+    MemorySegment heapSegment;\n+    MemorySegment nativeSegment;\n+    MemorySegment unalignedSegment;\n+    ByteBuffer buffer;\n+\n+    @Setup\n+    public void setup() {\n+        array = new byte[ELEM_SIZE];\n+        heapSegment = MemorySegment.ofArray(array);\n+        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE, 8);\n+        unalignedSegment = Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n+        buffer = ByteBuffer.wrap(array);\n+    }\n+\n+    @Benchmark\n+    public void arrays_fill() {\n+        Arrays.fill(array, (byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void heap_segment_fill() {\n+        heapSegment.fill((byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void native_segment_fill() {\n+        nativeSegment.fill((byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void unaligned_segment_fill() {\n+        unalignedSegment.fill((byte) 0);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestFill.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}