{"files":[{"patch":"@@ -197,0 +197,1 @@\n+    @ForceInline\n@@ -199,2 +200,6 @@\n-        \/\/ 0...0X...XXXX implies: 0 <= length < FILL_NATIVE_LIMIT\n-        if ((length & -FILL_NATIVE_THRESHOLD) == 0) {\n+        if (length == 0) {\n+            \/\/ Implicit state check\n+            checkValidState();\n+        } else if (length < FILL_NATIVE_THRESHOLD) {\n+            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+\n@@ -202,5 +207,0 @@\n-            if (length == 0) {\n-                \/\/ Implicit state check\n-                checkValidState();\n-                return this;\n-            }\n@@ -216,0 +216,1 @@\n+            int remaining = (int) length - limit;\n@@ -217,1 +218,1 @@\n-            if ((length & 4) != 0) {\n+            if (remaining >= 4) {\n@@ -220,0 +221,1 @@\n+                remaining -= 4;\n@@ -222,1 +224,1 @@\n-            if ((length & 2) != 0) {\n+            if (remaining >= 2) {\n@@ -225,0 +227,1 @@\n+                remaining -= 2;\n@@ -227,1 +230,1 @@\n-            if ((length & 1) != 0) {\n+            if (remaining == 1) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -73,0 +73,13 @@\n+    @ParameterizedTest\n+    @MethodSource(\"values\")\n+    void testValues(int value) {\n+        int size = 0b1111;\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(size);\n+            segment.fill((byte) value);\n+            assertTrue(segment.elements(ValueLayout.JAVA_BYTE)\n+                    .map(s -> s.get(ValueLayout.JAVA_BYTE, 0))\n+                    .allMatch(v -> v == value), \"Failed to fill with value \" + value);\n+        }\n+    }\n+\n@@ -117,0 +130,6 @@\n+    private static Stream<Arguments> values() {\n+        return IntStream.rangeClosed(Byte.MIN_VALUE, Byte.MAX_VALUE)\n+                .boxed()\n+                .map(Arguments::of);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestFill.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class TestBranchFill {\n+\n+    @Param({\"false\", \"true\"})\n+    private boolean shuffle;\n+    private MemorySegment[] segments;\n+    @Param({ \"1024\", \"128000\"})\n+    private int samples;\n+    private byte[] segmentSequence;\n+\n+    @Setup\n+    public void setup() {\n+        segments = new MemorySegment[8];\n+        \/\/ still allocates 8 different arrays\n+        for (int i = 0; i < 8; i++) {\n+            \/\/ we always pay the most of the cost here, for fun\n+            byte[] a = shuffle? new byte[i + 1] : new byte[8];\n+            segments[i] = MemorySegment.ofArray(a);\n+        }\n+        segmentSequence = new byte[samples];\n+        var rnd = new Random(42);\n+        for(int i = 0; i < samples; i++) {\n+            \/\/ if shuffle == false always fall into the \"worst\" case of populating 8 bytes\n+            segmentSequence[i] = (byte) rnd.nextInt(0, 8);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void heap_segment_fill() {\n+        var segments = this.segments;\n+        for (int nextIndex : segmentSequence) {\n+            fill(segments[nextIndex]);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void fill(MemorySegment segment) {\n+        segment.fill((byte) 0);\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestBranchFill.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"}]}