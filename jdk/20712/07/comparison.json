{"files":[{"patch":"@@ -60,0 +60,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_INT_UNALIGNED;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT_UNALIGNED;\n@@ -192,3 +194,3 @@\n-    public final MemorySegment fill(byte value){\n-        checkAccess(0, length, false);\n-        SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n+    public final MemorySegment fill(byte value) {\n+        checkReadOnly(false);\n+        SCOPED_MEMORY_ACCESS.setMemory(this, value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import jdk.internal.util.Architecture;\n@@ -186,1 +187,1 @@\n-    public void setMemory(MemorySessionImpl session, Object o, long offset, long bytes, byte value) {\n+    public void setMemory(AbstractMemorySegmentImpl segment, byte value) {\n@@ -188,1 +189,1 @@\n-            setMemoryInternal(session, o, offset, bytes, value);\n+            setMemoryInternal(segment, segment.byteSize(), value);\n@@ -194,0 +195,4 @@\n+    \/\/ FILL_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n+    \/\/ Update the value for Aarch64 once 8338975 is fixed.\n+    private static final long FILL_NATIVE_THRESHOLD = 1L << (Architecture.isAARCH64() ? 10 : 5);\n+\n@@ -195,1 +200,2 @@\n-    private void setMemoryInternal(MemorySessionImpl session, Object o, long offset, long bytes, byte value) {\n+    private void setMemoryInternal(AbstractMemorySegmentImpl segment, long length, byte value) {\n+        final MemorySessionImpl session = segment.sessionImpl();\n@@ -200,1 +206,31 @@\n-            UNSAFE.setMemory(o, offset, bytes, value);\n+            \/\/ 0...0X...XXXX implies: 0 <= length < FILL_NATIVE_LIMIT\n+            if ((length & -FILL_NATIVE_THRESHOLD) == 0) {\n+                \/\/ Handle smaller segments directly without transitioning to native code\n+                final long u = Byte.toUnsignedLong(value);\n+                final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+\n+                int offset = 0;\n+                \/\/ 0...0X...X000\n+                final int limit = (int) (length & (FILL_NATIVE_THRESHOLD - 8));\n+                for (; offset < limit; offset += 8) {\n+                    UNSAFE.putLong(segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, longValue);\n+                }\n+                \/\/ 0...0X00\n+                if ((length & 4) != 0) {\n+                    UNSAFE.putInt(segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, (int) longValue);\n+                    offset += 4;\n+                }\n+                \/\/ 0...00X0\n+                if ((length & 2) != 0) {\n+                    UNSAFE.putShort(segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, (short) longValue);\n+                    offset += 2;\n+                }\n+                \/\/ 0...000X\n+                if ((length & 1) != 0) {\n+                    UNSAFE.putByte(segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, value);\n+                }\n+                \/\/ We have now fully handled 0...0X...XXXX\n+            } else {\n+                \/\/ Handle larger segments via native calls\n+                UNSAFE.setMemory(segment.unsafeGetBase(), segment.unsafeGetOffset(), length, value);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":41,"deletions":5,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test MemorySegment::fill\n+ * @run junit TestFill\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestFill {\n+\n+    \/\/ Make sure negative values are treated as expected\n+    private static final byte VALUE = -71;\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testFill(int len) {\n+        int offset = 16;\n+        int expandedLen = offset + MAX_SIZE + offset;\n+\n+        \/\/ Make sure fill only affects the intended region XXXXXX\n+        \/\/\n+        \/\/ ................XXXXXX................\n+        \/\/ |    offset     | len |    offset     |\n+\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(expandedLen);\n+            var slice = segment.asSlice(offset, len);\n+            slice.fill(VALUE);\n+\n+            var expected = new byte[expandedLen];\n+            Arrays.fill(expected, offset, offset + len, VALUE);\n+\n+            \/\/ This checks the actual fill region as well as potential under and overflows\n+            assertArrayEquals(expected, segment.toArray(ValueLayout.JAVA_BYTE));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testReadOnly(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(10).asReadOnly();\n+            assertThrows(IllegalArgumentException.class, () -> segment.fill(VALUE));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testConfinement(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(10);\n+            AtomicReference<RuntimeException> ex = new AtomicReference<>();\n+            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n+                try {\n+                    segment.fill(VALUE);\n+                } catch (RuntimeException e) {\n+                    ex.set(e);\n+                }\n+            });\n+            future.join();\n+            assertInstanceOf(WrongThreadException.class, ex.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testScope(int len) {\n+        var arena = Arena.ofConfined();\n+        var segment = arena.allocate(len);\n+        arena.close();\n+        assertThrows(IllegalStateException.class, () -> segment.fill(VALUE));\n+    }\n+\n+    private static final int MAX_SIZE = 1 << 10;\n+\n+    private static Stream<Arguments> sizes() {\n+        return IntStream.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 23, 32, 63, 128, 256, 511, MAX_SIZE)\n+                .boxed()\n+                .map(Arguments::of);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestFill.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class TestFill {\n+\n+    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\n+            \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\n+            \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\n+            \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\",\n+            \"32\", \"128\", \"256\", \"384\", \"511\", \"512\"})\n+    public int ELEM_SIZE;\n+\n+    byte[] array;\n+    MemorySegment heapSegment;\n+    MemorySegment nativeSegment;\n+    MemorySegment unalignedSegment;\n+    ByteBuffer buffer;\n+\n+    @Setup\n+    public void setup() {\n+        array = new byte[ELEM_SIZE];\n+        heapSegment = MemorySegment.ofArray(array);\n+        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE, 8);\n+        unalignedSegment = Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n+        buffer = ByteBuffer.wrap(array);\n+    }\n+\n+    @Benchmark\n+    public void arrays_fill() {\n+        Arrays.fill(array, (byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void heap_segment_fill() {\n+        heapSegment.fill((byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void native_segment_fill() {\n+        nativeSegment.fill((byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void unaligned_segment_fill() {\n+        unalignedSegment.fill((byte) 0);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestFill.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}