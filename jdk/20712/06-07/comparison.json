{"files":[{"patch":"@@ -195,27 +195,2 @@\n-        if ((length & ~7) == 0) { \/\/ 0 <= length < 8\n-            if (length == 0) {\n-                \/\/ Make explicit tests as there are no set operations\n-                checkReadOnly(false);\n-                checkValidState();\n-                return this;\n-            }\n-            \/\/ Handle smaller fills directly without having to transition to native code.\n-            final int valueUnsigned = Byte.toUnsignedInt(value);\n-            final int intValue = valueUnsigned | valueUnsigned << 8 | valueUnsigned << 16 | valueUnsigned << 24;\n-\n-            int offset = 0;\n-            if ((length & 4) != 0) {\n-                set(JAVA_INT_UNALIGNED, 0, intValue);\n-                offset += 4;\n-            }\n-            if ((length & 2) != 0) {\n-                set(JAVA_SHORT_UNALIGNED, offset, (short) intValue);\n-                offset += 2;\n-            }\n-            if ((length & 1) != 0) {\n-                set(JAVA_BYTE, offset, value);\n-            }\n-        } else {\n-            checkReadOnly(false);\n-            SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n-        }\n+        checkReadOnly(false);\n+        SCOPED_MEMORY_ACCESS.setMemory(this, value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import jdk.internal.util.Architecture;\n@@ -186,1 +187,1 @@\n-    public void setMemory(MemorySessionImpl session, Object o, long offset, long bytes, byte value) {\n+    public void setMemory(AbstractMemorySegmentImpl segment, byte value) {\n@@ -188,1 +189,1 @@\n-            setMemoryInternal(session, o, offset, bytes, value);\n+            setMemoryInternal(segment, segment.byteSize(), value);\n@@ -194,0 +195,4 @@\n+    \/\/ FILL_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n+    \/\/ Update the value for Aarch64 once 8338975 is fixed.\n+    private static final long FILL_NATIVE_THRESHOLD = 1L << (Architecture.isAARCH64() ? 10 : 5);\n+\n@@ -195,1 +200,2 @@\n-    private void setMemoryInternal(MemorySessionImpl session, Object o, long offset, long bytes, byte value) {\n+    private void setMemoryInternal(AbstractMemorySegmentImpl segment, long length, byte value) {\n+        final MemorySessionImpl session = segment.sessionImpl();\n@@ -200,1 +206,31 @@\n-            UNSAFE.setMemory(o, offset, bytes, value);\n+            \/\/ 0...0X...XXXX implies: 0 <= length < FILL_NATIVE_LIMIT\n+            if ((length & -FILL_NATIVE_THRESHOLD) == 0) {\n+                \/\/ Handle smaller segments directly without transitioning to native code\n+                final long u = Byte.toUnsignedLong(value);\n+                final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+\n+                int offset = 0;\n+                \/\/ 0...0X...X000\n+                final int limit = (int) (length & (FILL_NATIVE_THRESHOLD - 8));\n+                for (; offset < limit; offset += 8) {\n+                    UNSAFE.putLong(segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, longValue);\n+                }\n+                \/\/ 0...0X00\n+                if ((length & 4) != 0) {\n+                    UNSAFE.putInt(segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, (int) longValue);\n+                    offset += 4;\n+                }\n+                \/\/ 0...00X0\n+                if ((length & 2) != 0) {\n+                    UNSAFE.putShort(segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, (short) longValue);\n+                    offset += 2;\n+                }\n+                \/\/ 0...000X\n+                if ((length & 1) != 0) {\n+                    UNSAFE.putByte(segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, value);\n+                }\n+                \/\/ We have now fully handled 0...0X...XXXX\n+            } else {\n+                \/\/ Handle larger segments via native calls\n+                UNSAFE.setMemory(segment.unsafeGetBase(), segment.unsafeGetOffset(), length, value);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":41,"deletions":5,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-public class TestFill {\n+final class TestFill {\n@@ -51,1 +51,9 @@\n-    public void testFill(int len) {\n+    void testFill(int len) {\n+        int offset = 16;\n+        int expandedLen = offset + MAX_SIZE + offset;\n+\n+        \/\/ Make sure fill only affects the intended region XXXXXX\n+        \/\/\n+        \/\/ ................XXXXXX................\n+        \/\/ |    offset     | len |    offset     |\n+\n@@ -53,2 +61,2 @@\n-            var segment = arena.allocate(10);\n-            var slice = segment.asSlice(0, len);\n+            var segment = arena.allocate(expandedLen);\n+            var slice = segment.asSlice(offset, len);\n@@ -57,2 +65,2 @@\n-            var expected = new byte[10];\n-            Arrays.fill(expected, 0, len, VALUE);\n+            var expected = new byte[expandedLen];\n+            Arrays.fill(expected, offset, offset + len, VALUE);\n@@ -60,0 +68,1 @@\n+            \/\/ This checks the actual fill region as well as potential under and overflows\n@@ -66,1 +75,1 @@\n-    public void testReadOnly(int len) {\n+    void testReadOnly(int len) {\n@@ -75,1 +84,1 @@\n-    public void testConfinement(int len) {\n+    void testConfinement(int len) {\n@@ -93,1 +102,1 @@\n-    public void testScope(int len) {\n+    void testScope(int len) {\n@@ -100,0 +109,2 @@\n+    private static final int MAX_SIZE = 1 << 10;\n+\n@@ -101,1 +112,1 @@\n-        return IntStream.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n+        return IntStream.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 23, 32, 63, 128, 256, 511, MAX_SIZE)\n","filename":"test\/jdk\/java\/foreign\/TestFill.java","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -53,1 +53,5 @@\n-    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"16\", \"32\", \"64\", \"128\"})\n+    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\n+            \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\n+            \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\n+            \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\",\n+            \"32\", \"128\", \"256\", \"384\", \"511\", \"512\"})\n@@ -59,0 +63,1 @@\n+    MemorySegment unalignedSegment;\n@@ -65,1 +70,2 @@\n-        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n+        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE, 8);\n+        unalignedSegment = Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n@@ -84,0 +90,5 @@\n+    @Benchmark\n+    public void unaligned_segment_fill() {\n+        unalignedSegment.fill((byte) 0);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestFill.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"}]}