{"files":[{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8373366\n+ * @summary HandshakeState should disallow suspend ops for disabler threads\n+ * @requires vm.continuations\n+ * @requires vm.jvmti\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:ThreadStateTest2 ThreadStateTest2\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import jdk.test.lib.thread.VThreadScheduler;\n+\n+public class ThreadStateTest2 {\n+    private static native void setMonitorContendedMode(boolean enable);\n+    private static native void testSuspendResume(Thread vthread);\n+    private static native void testInterruptThread(Thread vthread);\n+    private static native int testGetThreadState(Thread vthread);\n+\n+    static Thread vthread0;\n+    static Thread vthread1;\n+    static Thread vthread2;\n+    static AtomicBoolean vt2Started = new AtomicBoolean();\n+    static AtomicBoolean vt2Finished = new AtomicBoolean();\n+\n+    static void log(String msg) { System.out.println(msg); }\n+\n+    \/\/ Should handle interruptions from vthread2.\n+    final Runnable FOO_0 = () -> {\n+        log(\"VT-0 started\");\n+        while (!vt2Finished.get()) {\n+            try {\n+                Thread.sleep(10);\n+            } catch (InterruptedException ie) {\n+                \/\/ ignore\n+            }\n+        }\n+        log(\"VT-0 finished\");\n+    };\n+\n+    \/\/ A target for vthread2 to check state with JVMTI GetThreadState.\n+    final Runnable FOO_1 = () -> {\n+        log(\"VT-1 started\");\n+        while (!vt2Finished.get()) {\n+            Thread.yield();\n+        }\n+        log(\"VT-1 finished\");\n+    };\n+\n+    \/\/ In a loop execute JVMTI functions on threads vthread0 and vthread1:\n+    \/\/ InterruptThread(vthread0) and GetThreadState(vthread1).\n+    final Runnable FOO_2 = () -> {\n+        log(\"VT-2 started\");\n+        vt2Started.set(true);\n+        for (int i = 0; i < 40; i++) {\n+            testInterruptThread(vthread0);\n+            int state = testGetThreadState(vthread1);\n+            if (state == 2) {\n+                break;\n+            }\n+            Thread.yield();\n+        }\n+        vt2Finished.set(true);\n+        log(\"VT-2 finished\");\n+    };\n+ \n+    private void runTest() throws Exception {\n+        \/\/ Force creation of JvmtiThreadState on vthread start.\n+        setMonitorContendedMode(true);\n+\n+        ExecutorService scheduler = Executors.newFixedThreadPool(2);\n+        ThreadFactory factory = VThreadScheduler.virtualThreadBuilder(scheduler).factory();\n+\n+        vthread0 = factory.newThread(FOO_0);\n+        vthread1 = factory.newThread(FOO_1);\n+        vthread2 = factory.newThread(FOO_2);\n+        vthread0.setName(\"VT-0\");\n+        vthread1.setName(\"VT-1\");\n+        vthread2.setName(\"VT-2\");\n+        vthread0.start();\n+        vthread1.start();\n+        vthread2.start();\n+\n+        \/\/ Give some time for vthreads to start.\n+        while (!vt2Started.get()) {\n+            Thread.sleep(1);\n+        }\n+        while (!vt2Finished.get() \/* && tryCount-- > 0 *\/) {\n+            testSuspendResume(vthread2);\n+        }\n+        vthread0.join();\n+        vthread1.join();\n+        vthread2.join();\n+\n+        \/\/ Let all carriers go away.\n+        scheduler.shutdown();\n+        Thread.sleep(20);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ThreadStateTest2 obj = new ThreadStateTest2();\n+        obj.runTest();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadStateTest2\/ThreadStateTest2.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jvmti.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti_common.hpp\"\n+\n+\/\/ set by Agent_OnLoad\n+static jvmtiEnv* jvmti = nullptr;\n+static jrawMonitorID agent_event_lock = nullptr;\n+\n+extern \"C\" {\n+\n+static void JNICALL\n+MonitorContended(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread,\n+                 jobject object) {\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_ThreadStateTest2_testSuspendResume(JNIEnv* jni, jclass klass, jthread thread) {\n+  jvmtiError err;\n+  RawMonitorLocker event_locker(jvmti, jni, agent_event_lock);\n+\n+  LOG(\"\\nMAIN: testSuspendResume: before suspend\\n\");\n+  err = jvmti->SuspendThread(thread);\n+  if (err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+    return;\n+  }\n+  check_jvmti_status(jni, err, \"testSuspendResume error in JVMTI SuspendThread\");\n+  LOG(\"\\nMAIN: testSuspendResume:  after suspend\\n\");\n+\n+  event_locker.wait(1);\n+\n+  LOG(\"MAIN: testSuspendResume: before resume\\n\");\n+  err = jvmti->ResumeThread(thread);\n+  check_jvmti_status(jni, err, \"testSuspendResume error in JVMTI ResumeThread\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_ThreadStateTest2_setMonitorContendedMode(JNIEnv* jni, jclass klass, jboolean enable) {\n+  jvmtiError err = jvmti->SetEventNotificationMode(enable ? JVMTI_ENABLE : JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr);\n+  check_jvmti_status(jni, err, \"setMonitorContendedMode: error in JVMTI SetEventNotificationMode for JVMTI_EVENT_MONITOR_CONTENDED_ENTER\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_ThreadStateTest2_testInterruptThread(JNIEnv* jni, jclass klass, jthread vthread) {\n+  char* tname = get_thread_name(jvmti, jni, vthread);\n+  LOG(\"VT-2: testInterruptThread: %s\\n\", tname);\n+\n+  jvmtiError err = jvmti->InterruptThread(vthread);\n+  check_jvmti_status(jni, err, \"testInterruptThread error in JVMTI InterruptThread\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ThreadStateTest2_testGetThreadState(JNIEnv* jni, jclass klass, jthread vthread) {\n+  jint  state = get_thread_state(jvmti, jni, vthread);\n+  char* tname = get_thread_name(jvmti, jni, vthread);\n+\n+  LOG(\"VT-2: testGetThreadState: %s state: %x\\n\", tname, state);\n+  return state;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM* jvm, char* options, void* reserved) {\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+\n+  printf(\"Agent_OnLoad: started\\n\");\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    LOG(\"Agent_OnLoad: error in GetEnv\");\n+    return JNI_ERR;\n+  }\n+\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_suspend = 1;\n+  caps.can_signal_thread = 1;\n+  caps.can_support_virtual_threads = 1;\n+  caps.can_generate_monitor_events = 1;\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent_OnLoad: error in JVMTI AddCapabilities: %d\\n\", err);\n+  }\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.MonitorContendedEnter = &MonitorContended;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(jvmtiEventCallbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent_OnLoad: Error in JVMTI SetEventCallbacks: %d\\n\", err);\n+  }\n+  agent_event_lock = create_raw_monitor(jvmti, \"agent_event_lock\");\n+  printf(\"Agent_OnLoad: finished\\n\");\n+\n+  return 0;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadStateTest2\/libThreadStateTest2.cpp","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"}]}