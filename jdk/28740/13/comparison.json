{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -524,1 +524,1 @@\n-  if (allow_suspend && _handshakee->is_disable_suspend()) {\n+  if (allow_suspend && (_handshakee->is_disable_suspend() || _handshakee->is_vthread_transition_disabler())) {\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -502,1 +502,1 @@\n-  DEBUG_ONLY(_is_vthread_transition_disabler(false) COMMA)\n+  JVMTI_ONLY(_is_vthread_transition_disabler(false) COMMA)\n@@ -1168,1 +1168,1 @@\n-#ifdef ASSERT\n+#if INCLUDE_JVMTI\n@@ -1172,0 +1172,1 @@\n+#endif\n@@ -1173,0 +1174,1 @@\n+#ifdef ASSERT\n@@ -1186,1 +1188,1 @@\n-  assert(!is_vthread_transition_disabler(), \"no suspend allowed for vthread transition disablers\");\n+  \/\/ The HandshakeState::has_operation does not allow such suspends.\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -737,1 +737,1 @@\n-  DEBUG_ONLY(bool _is_vthread_transition_disabler;)  \/\/ thread currently disabled vthread transitions\n+  JVMTI_ONLY(bool _is_vthread_transition_disabler;)  \/\/ thread currently disabled vthread transitions\n@@ -742,0 +742,2 @@\n+  JVMTI_ONLY(bool is_vthread_transition_disabler() const { return _is_vthread_transition_disabler; })\n+  JVMTI_ONLY(void set_is_vthread_transition_disabler(bool val);)\n@@ -743,2 +745,0 @@\n-  bool is_vthread_transition_disabler() const       { return _is_vthread_transition_disabler; }\n-  void set_is_vthread_transition_disabler(bool val);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,1 +132,2 @@\n-         JVMTI_ONLY(|| (JvmtiVTSuspender::is_vthread_suspended(java_lang_Thread::thread_id(vthread)) || thread->is_suspended()));\n+         JVMTI_ONLY(|| (!thread->is_vthread_transition_disabler() &&\n+                        (JvmtiVTSuspender::is_vthread_suspended(java_lang_Thread::thread_id(vthread)) || thread->is_suspended())));\n@@ -297,1 +298,1 @@\n-  DEBUG_ONLY(JavaThread::current()->set_is_vthread_transition_disabler(true);)\n+  JVMTI_ONLY(JavaThread::current()->set_is_vthread_transition_disabler(true);)\n@@ -338,1 +339,1 @@\n-  DEBUG_ONLY(thread->set_is_vthread_transition_disabler(true);)\n+  JVMTI_ONLY(JavaThread::current()->set_is_vthread_transition_disabler(true);)\n@@ -361,1 +362,1 @@\n-  DEBUG_ONLY(JavaThread::current()->set_is_vthread_transition_disabler(false);)\n+  JVMTI_ONLY(JavaThread::current()->set_is_vthread_transition_disabler(false);)\n@@ -367,2 +368,0 @@\n-  JavaThread* thread = JavaThread::current();\n-\n@@ -387,1 +386,1 @@\n-  DEBUG_ONLY(thread->set_is_vthread_transition_disabler(false);)\n+  JVMTI_ONLY(JavaThread::current()->set_is_vthread_transition_disabler(false);)\n","filename":"src\/hotspot\/share\/runtime\/mountUnmountDisabler.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,1 @@\n+  JVMTI_ONLY(assert(!_target->is_vthread_transition_disabler(), \"attempt to suspend a vthread transition disabler\");)\n","filename":"src\/hotspot\/share\/runtime\/suspendResumeManager.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8373366\n+ * @summary HandshakeState should disallow suspend ops for disabler threads\n+ * @requires vm.continuations\n+ * @requires vm.jvmti\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:ThreadStateTest2 ThreadStateTest2\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import jdk.test.lib.thread.VThreadScheduler;\n+\n+\/* Testing scenario:\n+ * Several threads are involved:\n+ *  - VT-0: a virtual thread which is interrupt-friendly and constantly interrupted with JVMTI InterruptThread\n+ *  - VT-1: a virtual thread which state is constantly checked with JVMTI GetThreadState\n+ *  - VT-2: a virtual thread: in a loop calls JVMTI InterruptThread(VT-0) and GetThreadState(VT-1)\n+ *  - main: a platform thread: in a loop invokes native method testSuspendResume which suspends and resumes VT-2\n+ * The JVMTI functions above install a MountUnmountDisabler for target virtual thread (VT-0 or VT-1).\n+ * The goal is to catch VT-2 in an attempt to self-suspend while in a context of MountUnmountDisabler.\n+ * This would mean there is a suspend point while VT-2 is in a context of MountUnmountDisabler.\n+ * The InterruptThread implementation does a Java upcall to j.l.Thread::interrupt().\n+ * The JavaCallWrapper constructor has such a suspend point.\n+ *\/\n+public class ThreadStateTest2 {\n+    private static native void setMonitorContendedMode(boolean enable);\n+    private static native void testSuspendResume(Thread vthread);\n+    private static native void testInterruptThread(Thread vthread);\n+    private static native int testGetThreadState(Thread vthread);\n+\n+    static Thread vthread0;\n+    static Thread vthread1;\n+    static Thread vthread2;\n+    static AtomicBoolean vt2Started = new AtomicBoolean();\n+    static AtomicBoolean vt2Finished = new AtomicBoolean();\n+\n+    static void log(String msg) { System.out.println(msg); }\n+\n+    \/\/ Should handle interruptions from vthread2.\n+    final Runnable FOO_0 = () -> {\n+        log(\"VT-0 started\");\n+        while (!vt2Finished.get()) {\n+            try {\n+                Thread.sleep(10);\n+            } catch (InterruptedException ie) {\n+                \/\/ ignore\n+            }\n+        }\n+        log(\"VT-0 finished\");\n+    };\n+\n+    \/\/ A target for vthread2 to check state with JVMTI GetThreadState.\n+    final Runnable FOO_1 = () -> {\n+        log(\"VT-1 started\");\n+        while (!vt2Finished.get()) {\n+            Thread.yield();\n+        }\n+        log(\"VT-1 finished\");\n+    };\n+\n+    \/\/ In a loop execute JVMTI functions on threads vthread0 and vthread1:\n+    \/\/ InterruptThread(vthread0) and GetThreadState(vthread1).\n+    final Runnable FOO_2 = () -> {\n+        log(\"VT-2 started\");\n+        vt2Started.set(true);\n+        for (int i = 0; i < 40; i++) {\n+            testInterruptThread(vthread0);\n+            int state = testGetThreadState(vthread1);\n+            if (state == 2) {\n+                break;\n+            }\n+            Thread.yield();\n+        }\n+        vt2Finished.set(true);\n+        log(\"VT-2 finished\");\n+    };\n+\n+    private void runTest() throws Exception {\n+        \/\/ Force creation of JvmtiThreadState on vthread start.\n+        setMonitorContendedMode(true);\n+\n+        ExecutorService scheduler = Executors.newFixedThreadPool(2);\n+        ThreadFactory factory = VThreadScheduler.virtualThreadBuilder(scheduler).factory();\n+\n+        vthread0 = factory.newThread(FOO_0);\n+        vthread1 = factory.newThread(FOO_1);\n+        vthread2 = factory.newThread(FOO_2);\n+        vthread0.setName(\"VT-0\");\n+        vthread1.setName(\"VT-1\");\n+        vthread2.setName(\"VT-2\");\n+        vthread0.start();\n+        vthread1.start();\n+        vthread2.start();\n+\n+        \/\/ Give some time for vthreads to start.\n+        while (!vt2Started.get()) {\n+            Thread.sleep(1);\n+        }\n+        while (!vt2Finished.get() \/* && tryCount-- > 0 *\/) {\n+            testSuspendResume(vthread2);\n+        }\n+        vthread0.join();\n+        vthread1.join();\n+        vthread2.join();\n+\n+        \/\/ Let all carriers go away.\n+        scheduler.shutdown();\n+        Thread.sleep(20);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ThreadStateTest2 obj = new ThreadStateTest2();\n+        obj.runTest();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadStateTest2\/ThreadStateTest2.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jvmti.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti_common.hpp\"\n+\n+\/\/ set by Agent_OnLoad\n+static jvmtiEnv* jvmti = nullptr;\n+static jrawMonitorID agent_event_lock = nullptr;\n+\n+extern \"C\" {\n+\n+static void JNICALL\n+MonitorContended(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread,\n+                 jobject object) {\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_ThreadStateTest2_testSuspendResume(JNIEnv* jni, jclass klass, jthread thread) {\n+  jvmtiError err;\n+  RawMonitorLocker event_locker(jvmti, jni, agent_event_lock);\n+\n+  LOG(\"\\nMAIN: testSuspendResume: before suspend\\n\");\n+  err = jvmti->SuspendThread(thread);\n+  if (err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+    return;\n+  }\n+  check_jvmti_status(jni, err, \"testSuspendResume error in JVMTI SuspendThread\");\n+  LOG(\"\\nMAIN: testSuspendResume:  after suspend\\n\");\n+\n+  event_locker.wait(1);\n+\n+  LOG(\"MAIN: testSuspendResume: before resume\\n\");\n+  err = jvmti->ResumeThread(thread);\n+  check_jvmti_status(jni, err, \"testSuspendResume error in JVMTI ResumeThread\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_ThreadStateTest2_setMonitorContendedMode(JNIEnv* jni, jclass klass, jboolean enable) {\n+  jvmtiError err = jvmti->SetEventNotificationMode(enable ? JVMTI_ENABLE : JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr);\n+  check_jvmti_status(jni, err, \"setMonitorContendedMode: error in JVMTI SetEventNotificationMode for JVMTI_EVENT_MONITOR_CONTENDED_ENTER\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_ThreadStateTest2_testInterruptThread(JNIEnv* jni, jclass klass, jthread vthread) {\n+  char* tname = get_thread_name(jvmti, jni, vthread);\n+  LOG(\"VT-2: testInterruptThread: %s\\n\", tname);\n+\n+  jvmtiError err = jvmti->InterruptThread(vthread);\n+  check_jvmti_status(jni, err, \"testInterruptThread error in JVMTI InterruptThread\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ThreadStateTest2_testGetThreadState(JNIEnv* jni, jclass klass, jthread vthread) {\n+  jint  state = get_thread_state(jvmti, jni, vthread);\n+  char* tname = get_thread_name(jvmti, jni, vthread);\n+\n+  LOG(\"VT-2: testGetThreadState: %s state: %x\\n\", tname, state);\n+  return state;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM* jvm, char* options, void* reserved) {\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+\n+  printf(\"Agent_OnLoad: started\\n\");\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    LOG(\"Agent_OnLoad: error in GetEnv\");\n+    return JNI_ERR;\n+  }\n+\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_suspend = 1;\n+  caps.can_signal_thread = 1;\n+  caps.can_support_virtual_threads = 1;\n+  caps.can_generate_monitor_events = 1;\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent_OnLoad: error in JVMTI AddCapabilities: %d\\n\", err);\n+  }\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.MonitorContendedEnter = &MonitorContended;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(jvmtiEventCallbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent_OnLoad: Error in JVMTI SetEventCallbacks: %d\\n\", err);\n+  }\n+  agent_event_lock = create_raw_monitor(jvmti, \"agent_event_lock\");\n+  printf(\"Agent_OnLoad: finished\\n\");\n+\n+  return 0;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadStateTest2\/libThreadStateTest2.cpp","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"}]}