{"files":[{"patch":"@@ -40,0 +40,8 @@\n+ * <p>\n+ * The InputStream passed to the constructor of this class may represent a\n+ * single GZIP file or multiple consecutive GZIP files. When the end of a\n+ * GZIP file is immediately followed by a new GZIP file, this class continues\n+ * to decode compressed data into a single, concatenated stream of uncompressed\n+ * data. Otherwise, any additional trailing bytes following a GZIP file are\n+ * discarded as if the end of stream is reached.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPInputStream.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8322256\n+ * @summary Test support for concatenated GZIP streams\n+ * @run junit GZIPInputStreamConcat\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.stream.*;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class GZIPInputStreamConcat {\n+\n+    \/\/ The buffer size passed to GZIPInputStream\n+    private int bufSize;\n+\n+    public static Stream<Arguments> testScenarios() throws IOException {\n+        \/\/ Test concat vs. non-concat, garbage vs. no-garbage, and various buffer sizes on random data\n+        Random random = new Random();\n+        List<Arguments> scenarios = new ArrayList<>();\n+        for (int bufSize = 1; bufSize < 1024; bufSize += random.nextInt(32) + 1) {\n+            scenarios.add(Arguments.of(randomData(0, 100), bufSize));\n+        }\n+        return scenarios.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testScenarios\")\n+    public void testScenario(byte[] uncompressed, int bufSize) throws IOException {\n+        this.bufSize = bufSize;\n+        runTests(uncompressed);\n+    }\n+\n+    public void runTests(byte[] uncompressed) throws IOException {\n+\n+        \/\/ Compress the test data\n+        byte[] compressed = gzip(uncompressed);\n+\n+        \/\/ Decompress a single stream with no extra garbage - should always work\n+        decomp(compressed, uncompressed);\n+\n+        \/\/ Decompress a truncated GZIP header\n+        decompFail(oneByteShort(gzipHeader()), EOFException.class);\n+\n+        \/\/ Decompress a single stream that is one byte short - should always fail\n+        decompFail(oneByteShort(compressed), EOFException.class);\n+\n+        \/\/ Decompress a single stream with one byte of extra garbage (trying all 256 possible values)\n+        for (int extra = Byte.MIN_VALUE; extra <= Byte.MAX_VALUE ; extra++) {\n+            decomp(oneByteLong(compressed, (byte) extra), uncompressed);\n+        }\n+\n+        \/\/ Decompress a single stream followed by a truncated GZIP header\n+        decomp(concat(compressed, oneByteShort(gzipHeader())), uncompressed);\n+\n+        \/\/ Decompress a single stream followed by another stream that is one byte short\n+        decompFail(concat(compressed, oneByteShort(compressed)), IOException.class);\n+\n+        \/\/ Decompress two streams concatenated\n+        decomp(concat(compressed, compressed), concat(uncompressed, uncompressed));\n+\n+        \/\/ Decompress three streams concatenated\n+        decomp(concat(compressed, compressed, compressed),\n+                concat(uncompressed, uncompressed, uncompressed));\n+\n+        \/\/ Decompress three streams concatenated followed by a truncated GZIP header\n+        decomp(concat(compressed, compressed, compressed, oneByteShort(gzipHeader())),\n+                concat(uncompressed, uncompressed, uncompressed));\n+    }\n+\n+    \/\/ Do decompression and check result\n+    public void decomp(byte[] compressed, byte[] uncompressed) throws IOException {\n+        byte[] readback = gunzip(new ByteArrayInputStream(compressed));\n+        assertArrayEquals(uncompressed, readback);\n+    }\n+\n+    \/\/ Do decompression, asserting an execption\n+    public void decompFail(byte[] compressed, Class<? extends IOException> exceptionType) {\n+        assertThrows(exceptionType, () -> {\n+            byte[] readback = gunzip(new ByteArrayInputStream(compressed));\n+        });\n+    }\n+\n+    \/\/ Create a GZIP header\n+    public static byte[] gzipHeader() throws IOException {\n+        byte[] compressed = gzip(new byte[0]);\n+        return Arrays.copyOfRange(compressed, 0, 10);\n+    }\n+\n+    \/\/ Add one extra byte to the given array\n+    public static byte[] oneByteLong(byte[] array, byte value) {\n+        return concat(array, new byte[] {value});\n+    }\n+\n+    \/\/ Chop off the last byte of the given array\n+    public static byte[] oneByteShort(byte[] array) {\n+        return Arrays.copyOfRange(array, 0, array.length - 1);\n+    }\n+\n+    \/\/ Create some random data\n+    public static byte[] randomData(int min, int max) {\n+        Random random = new Random();\n+        byte[] data = new byte[min + random.nextInt(max - min)];\n+        random.nextBytes(data);\n+        return data;\n+    }\n+\n+    \/\/ Concatenate byte arrays\n+    public static byte[] concat(byte[]... arrays) {\n+        final ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+        for (byte[] array : arrays)\n+            buf.writeBytes(array);\n+        return buf.toByteArray();\n+    }\n+\n+    \/\/ GZIP compress data\n+    public static byte[] gzip(byte[] data) throws IOException {\n+        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+        try (GZIPOutputStream out = new GZIPOutputStream(buf)) {\n+            out.write(data);\n+        }\n+        return buf.toByteArray();\n+    }\n+\n+    \/\/ GZIP decompress data\n+    public byte[] gunzip(InputStream in) throws IOException {\n+        return new GZIPInputStream(in, bufSize).readAllBytes();\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPInputStreamConcat.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8322256\n+ * @summary Test decompression of streams created by the gzip(1) command\n+ * @run junit GZIPInputStreamGzipCommand\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.util.*;\n+import java.util.stream.*;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+\n+public class GZIPInputStreamGzipCommand {\n+\n+    public static Stream<Arguments> gzipScenarios() throws IOException {\n+        List<Arguments> scenarios = new ArrayList();\n+\n+        \/*\n+            # To regenerate the hex data below:\n+            (\n+                for i in 1 2 3 4 5 6 7 8 9; do\n+                    printf 'this is compression level #%d\\n' \"$i\" | gzip -\"${i}\"\n+                done\n+            ) | hexdump -e '32\/1 \"%02x\" \"\\n\"'\n+        *\/\n+        scenarios.add(Arguments.of(\"\"\"\n+            this is compression level #1\n+            this is compression level #2\n+            this is compression level #3\n+            this is compression level #4\n+            this is compression level #5\n+            this is compression level #6\n+            this is compression level #7\n+            this is compression level #8\n+            this is compression level #9\n+            \"\"\", \"\"\"\n+            1f8b0800d42ea46604032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2\n+            d41c0565432e0092bb84691d0000001f8b0800d42ea46600032bc9c82c5600a2\n+            e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c0565232e0051e8a9421d0000001f8b\n+            0800d42ea46600032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c\n+            0565632e0010d9b25b1d0000001f8b0800d42ea46600032bc9c82c5600a2e4fc\n+            dc82a2d4e2e2ccfc3c859cd4b2d41c0565132e00d74ff3141d0000001f8b0800\n+            d42ea46600032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c0565\n+            532e00967ee80d1d0000001f8b0800d42ea46600032bc9c82c5600a2e4fcdc82\n+            a2d4e2e2ccfc3c859cd4b2d41c0565332e00552dc5261d0000001f8b0800d42e\n+            a46600032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c0565732e\n+            00141cde3f1d0000001f8b0800d42ea46600032bc9c82c5600a2e4fcdc82a2d4\n+            e2e2ccfc3c859cd4b2d41c05650b2e00db0046b81d0000001f8b0800d42ea466\n+            02032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c05654b2e009a\n+            315da11d000000\"\"\"));\n+\n+        \/*\n+            # To regenerate the hex data below:\n+            (\n+                printf 'this one has a name\\n' > file1 && gzip file1\n+                printf 'this one has no name\\n' > file2 && gzip --no-name file2\n+                cat file1.gz file2.gz\n+                rm file1.gz file2.gz\n+            ) | hexdump -e '32\/1 \"%02x\" \"\\n\"'\n+        *\/\n+        scenarios.add(Arguments.of(\"\"\"\n+            this one has a name\n+            this one has no name\n+            \"\"\", \"\"\"\n+            1f8b08082230a466000366696c6531002bc9c82c56c8cf4b55c8482c564854c8\n+            4bcc4de50200d7ccdc5a140000001f8b08000000000000032bc9c82c56c8cf4b\n+            55c8482c56c8cb57c84bcc4de50200b1effb5015000000\"\"\" ));\n+\n+        \/*\n+            # To regenerate the hex data below:\n+            (\n+                i=0\n+                while [ \"${i}\" -lt 1000 ]; do\n+                    printf 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\n+                    i=`expr \"${i}\" + 1`\n+                done\n+            ) | gzip --best | hexdump -e '32\/1 \"%02x\" \"\\n\"'\n+        *\/\n+        scenarios.add(Arguments.of(\n+            \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\".repeat(1000),\n+            \"\"\"\n+            1f8b08002a35a4660203edc18100000000c320d6f94b1ce45501000000000000\n+            0000000000000000000000000000000000000000000000000000000000000000\n+            c08f01492d182728a00000\"\"\" ));\n+\n+        return scenarios.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"gzipScenarios\")\n+    public void testScenario(String input, String hexData) throws IOException {\n+\n+        \/\/ Get expected result\n+        byte[] expected = input.getBytes(StandardCharsets.UTF_8);\n+\n+        \/\/ Get actual result\n+        HexFormat hexFormat = HexFormat.of();\n+        byte[] data = hexFormat.parseHex(hexData.replaceAll(\"\\\\s\", \"\"));\n+        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+        try (GZIPInputStream gunzip = new GZIPInputStream(new ByteArrayInputStream(data))) {\n+            gunzip.transferTo(buf);\n+        }\n+        byte[] actual = buf.toByteArray();\n+\n+        \/\/ Compare\n+        System.out.println(\"  ACTUAL: \" + hexFormat.formatHex(actual));\n+        System.out.println(\"EXPECTED: \" + hexFormat.formatHex(expected));\n+        assertArrayEquals(actual, expected);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPInputStreamGzipCommand.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"}]}