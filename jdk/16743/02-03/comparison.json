{"files":[{"patch":"@@ -60,1 +60,1 @@\n-  static constexpr int num_immediates = sizeof(immediates) \/ sizeof(uint16_t);\n+  static constexpr int num_immediates = sizeof(immediates) \/ sizeof(immediates[0]);\n","filename":"src\/hotspot\/cpu\/aarch64\/compressedKlass_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,2 +144,2 @@\n-  \/\/ We check user input for SharedBaseAddress at dumptime. We must weed out values\n-  \/\/ we know will be invalid at runtime.\n+  \/\/ We check user input for SharedBaseAddress at dump time. We must weed out values\n+  \/\/ we already know to be invalid later.\n@@ -148,2 +148,3 @@\n-  \/\/ be the encoding base, since the pre-computed narrow Klass IDs in the headers of\n-  \/\/ archived objects refer to the mapping start as base.\n+  \/\/ be the encoding base, since the the headers of archived base objects (and with Lilliput,\n+  \/\/ the prototype mark words) carry pre-computed narrow Klass IDs that refer to the mapping\n+  \/\/ start as base.\n@@ -151,4 +152,2 @@\n-  \/\/ Therefore, \"shared_base\" must be usable as encoding base. The only platform not\n-  \/\/ accepting arbitrary immediates as encoding base is aarch64. Here, we require the\n-  \/\/ base to be 32-bit aligned since such immediates can be used with 16-bit moves.\n-  return AARCH64_ONLY(is_aligned(shared_base, nth_bit(32))) NOT_AARCH64(true);\n+  \/\/ Therefore, \"shared_base\" must be later usable as encoding base.\n+  return AARCH64_ONLY(is_aligned(shared_base, 4 * G)) NOT_AARCH64(true);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"}]}