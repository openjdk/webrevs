{"files":[{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"memory\/metaspace.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Helper function; reserve at an address that is compatible with EOR\n+static char* reserve_at_eor_compatible_address(size_t size, bool aslr) {\n+  char* result = nullptr;\n+\n+  log_debug(metaspace, map)(\"Trying to reserve at an EOR-compatible address\");\n+\n+  \/\/ We need immediates that are 32-bit aligned, since they should not intersect nKlass\n+  \/\/ bits. They should not be larger than the addressable space either, but we still\n+  \/\/ lack a good abstraction for that (see JDK-8320584), therefore we assume and hard-code\n+  \/\/ 2^48 as a reasonable higher ceiling.\n+  static const uint16_t immediates[] = {\n+      0x0001, 0x0002, 0x0003, 0x0004, 0x0006, 0x0007, 0x0008, 0x000c, 0x000e,\n+      0x000f, 0x0010, 0x0018, 0x001c, 0x001e, 0x001f, 0x0020, 0x0030, 0x0038,\n+      0x003c, 0x003e, 0x003f, 0x0040, 0x0060, 0x0070, 0x0078, 0x007c, 0x007e,\n+      0x007f, 0x0080, 0x00c0, 0x00e0, 0x00f0, 0x00f8, 0x00fc, 0x00fe, 0x00ff,\n+      0x0100, 0x0180, 0x01c0, 0x01e0, 0x01f0, 0x01f8, 0x01fc, 0x01fe, 0x01ff,\n+      0x0200, 0x0300, 0x0380, 0x03c0, 0x03e0, 0x03f0, 0x03f8, 0x03fc, 0x03fe,\n+      0x03ff, 0x0400, 0x0600, 0x0700, 0x0780, 0x07c0, 0x07e0, 0x07f0, 0x07f8,\n+      0x07fc, 0x07fe, 0x07ff, 0x0800, 0x0c00, 0x0e00, 0x0f00, 0x0f80, 0x0fc0,\n+      0x0fe0, 0x0ff0, 0x0ff8, 0x0ffc, 0x0ffe, 0x0fff, 0x1000, 0x1800, 0x1c00,\n+      0x1e00, 0x1f00, 0x1f80, 0x1fc0, 0x1fe0, 0x1ff0, 0x1ff8, 0x1ffc, 0x1ffe,\n+      0x1fff, 0x2000, 0x3000, 0x3800, 0x3c00, 0x3e00, 0x3f00, 0x3f80, 0x3fc0,\n+      0x3fe0, 0x3ff0, 0x3ff8, 0x3ffc, 0x3ffe, 0x3fff, 0x4000, 0x6000, 0x7000,\n+      0x7800, 0x7c00, 0x7e00, 0x7f00, 0x7f80, 0x7fc0, 0x7fe0, 0x7ff0, 0x7ff8,\n+      0x7ffc, 0x7ffe, 0x7fff\n+  };\n+  static constexpr int num_immediates = sizeof(immediates) \/ sizeof(immediates[0]);\n+  const int start_index = aslr ? os::random() : 0;\n+  constexpr int max_tries = 64;\n+  for (int ntry = 0; result == nullptr && ntry < max_tries; ntry ++) {\n+    \/\/ As in os::attempt_reserve_memory_between, we alternate between higher and lower\n+    \/\/ addresses; this maximizes the chance of early success if part of the address space\n+    \/\/ is not accessible (e.g. 39-bit address space).\n+    const int alt_index = (ntry & 1) ? 0 : num_immediates \/ 2;\n+    const int index = (start_index + ntry + alt_index) % num_immediates;\n+    const uint64_t immediate = ((uint64_t)immediates[index]) << 32;\n+    assert(immediate > 0 && Assembler::operand_valid_for_logical_immediate(\/*is32*\/false, immediate),\n+           \"Invalid immediate %d \" UINT64_FORMAT, index, immediate);\n+    result = os::attempt_reserve_memory_at((char*)immediate, size, false);\n+    if (result == nullptr) {\n+      log_trace(metaspace, map)(\"Failed to attach at \" UINT64_FORMAT_X, immediate);\n+    }\n+  }\n+  if (result == nullptr) {\n+    log_debug(metaspace, map)(\"Failed to reserve at any EOR-compatible address\");\n+  }\n+  return result;\n+}\n+char* CompressedKlassPointers::reserve_address_space_for_compressed_classes(size_t size, bool aslr, bool optimize_for_zero_base) {\n+\n+  char* result = nullptr;\n+\n+  \/\/ Optimize for base=0 shift=0\n+  if (optimize_for_zero_base) {\n+    result = reserve_address_space_for_unscaled_encoding(size, aslr);\n+  }\n+\n+  \/\/ If this fails, we don't bother aiming for zero-based encoding (base=0 shift>0), since it has no\n+  \/\/ advantages over EOR or movk mode.\n+\n+  \/\/ EOR-compatible reservation\n+  if (result == nullptr) {\n+    result = reserve_at_eor_compatible_address(size, aslr);\n+  }\n+\n+  \/\/ Movk-compatible reservation via probing.\n+  if (result == nullptr) {\n+    result = reserve_address_space_for_16bit_move(size, aslr);\n+  }\n+\n+  \/\/ Movk-compatible reservation via overallocation.\n+  \/\/ If that failed, attempt to allocate at any 4G-aligned address. Let the system decide where. For ASLR,\n+  \/\/ we now rely on the system.\n+  \/\/ Compared with the probing done above, this has two disadvantages:\n+  \/\/ - on a kernel with 52-bit address space we may get an address that has bits set between [48, 52).\n+  \/\/   In that case, we may need two movk moves (not yet implemented).\n+  \/\/ - this technique leads to temporary over-reservation of address space; it will spike the vsize of\n+  \/\/   the process. Therefore it may fail if a vsize limit is in place (e.g. ulimit -v).\n+  if (result == nullptr) {\n+    constexpr size_t alignment = nth_bit(32);\n+    log_debug(metaspace, map)(\"Trying to reserve at a 32-bit-aligned address\");\n+    result = os::reserve_memory_aligned(size, alignment, false);\n+  }\n+\n+  return result;\n+}\n+\n+void CompressedKlassPointers::initialize(address addr, size_t len) {\n+  constexpr uintptr_t unscaled_max = nth_bit(32);\n+  assert(len <= unscaled_max, \"Klass range larger than 32 bits?\");\n+\n+  \/\/ Shift is always 0 on aarch64.\n+  _shift = 0;\n+\n+  \/\/ On aarch64, we don't bother with zero-based encoding (base=0 shift>0).\n+  address const end = addr + len;\n+  _base = (end <= (address)unscaled_max) ? nullptr : addr;\n+\n+  _range = end - _base;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/compressedKlass_aarch64.cpp","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+char* CompressedKlassPointers::reserve_address_space_for_compressed_classes(size_t size, bool aslr, bool optimize_for_zero_base) {\n+\n+  char* result = nullptr;\n+\n+  \/\/ Optimize for base=0 shift=0; failing that, for base=0 shift>0\n+  if (optimize_for_zero_base) {\n+    result = reserve_address_space_for_unscaled_encoding(size, aslr);\n+    if (result == nullptr) {\n+      result = reserve_address_space_for_zerobased_encoding(size, aslr);\n+    }\n+  }\n+\n+  \/\/ Optimize for a single 16-bit move: a base that has only bits set in its third quadrant [32..48).\n+  if (result == nullptr) {\n+    result = reserve_address_space_for_16bit_move(size, aslr);\n+  }\n+\n+  return result;\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/compressedKlass_ppc.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+char* CompressedKlassPointers::reserve_address_space_for_compressed_classes(size_t size, bool aslr, bool optimize_for_zero_base) {\n+\n+  char* result = nullptr;\n+\n+  \/\/ RiscV loads a 64-bit immediate in up to four separate steps, splitting it into four different sections\n+  \/\/ (two 32-bit sections, each split into two subsections of 20\/12 bits).\n+  \/\/\n+  \/\/ 63 ....... 44 43 ... 32 31 ....... 12 11 ... 0\n+  \/\/       D           C          B           A\n+  \/\/\n+  \/\/ A \"good\" base is, in this order:\n+  \/\/ 1) only bits in A; this would be an address < 4KB, which is unrealistic on normal Linux boxes since\n+  \/\/    the typical default for vm.mmap_min_address is 64KB. We ignore that.\n+  \/\/ 2) only bits in B: a 12-bit-aligned address below 4GB. 12 bit = 4KB, but since mmap reserves at\n+  \/\/    page boundaries, we can ignore the alignment.\n+  \/\/ 3) only bits in C: a 4GB-aligned address that is lower than 16TB.\n+  \/\/ 4) only bits in D: a 16TB-aligned address.\n+\n+  \/\/ First, attempt to allocate < 4GB. We do this unconditionally:\n+  \/\/ - if can_optimize_for_zero_base, a <4GB mapping start would allow us to run unscaled (base = 0, shift = 0)\n+  \/\/ - if !can_optimize_for_zero_base, a <4GB mapping start is still good, the resulting immediate can be encoded\n+  \/\/   with one instruction (2)\n+  result = reserve_address_space_for_unscaled_encoding(size, aslr);\n+\n+  \/\/ Failing that, attempt to reserve for base=zero shift>0\n+  if (result == nullptr && optimize_for_zero_base) {\n+    result = reserve_address_space_for_zerobased_encoding(size, aslr);\n+  }\n+\n+  \/\/ Failing that, optimize for case (3) - a base with only bits set between [33-44)\n+  if (result == nullptr) {\n+    const uintptr_t from = nth_bit(32 + (optimize_for_zero_base ? LogKlassAlignmentInBytes : 0));\n+    constexpr uintptr_t to = nth_bit(44);\n+    constexpr size_t alignment = nth_bit(32);\n+    result = reserve_address_space_X(from, to, size, alignment, aslr);\n+  }\n+\n+  \/\/ Failing that, optimize for case (4) - a base with only bits set between [44-64)\n+  if (result == nullptr) {\n+    constexpr uintptr_t from = nth_bit(44);\n+    constexpr uintptr_t to = UINT64_MAX;\n+    constexpr size_t alignment = nth_bit(44);\n+    result = reserve_address_space_X(from, to, size, alignment, aslr);\n+  }\n+\n+  return result;\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/compressedKlass_riscv.cpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+char* CompressedKlassPointers::reserve_address_space_for_compressed_classes(size_t size, bool aslr, bool optimize_for_zero_base) {\n+\n+  char* result = nullptr;\n+\n+  uintptr_t tried_below = 0;\n+\n+  \/\/ First, attempt to allocate < 4GB. We do this unconditionally:\n+  \/\/ - if optimize_for_zero_base, a <4GB mapping start allows us to use base=0 shift=0\n+  \/\/ - if !optimize_for_zero_base, a <4GB mapping start allows us to use algfi\n+  result = reserve_address_space_for_unscaled_encoding(size, aslr);\n+\n+  \/\/ Failing that, try optimized for base=0 shift>0\n+  if (result == nullptr && optimize_for_zero_base) {\n+    result = reserve_address_space_for_zerobased_encoding(size, aslr);\n+  }\n+\n+  \/\/ Failing that, aim for a base that is 4G-aligned; such a base can be set with aih.\n+  if (result == nullptr) {\n+    result = reserve_address_space_for_16bit_move(size, aslr);\n+  }\n+\n+  return result;\n+}\n","filename":"src\/hotspot\/cpu\/s390\/compressedKlass_s390.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef _LP64\n+\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+char* CompressedKlassPointers::reserve_address_space_for_compressed_classes(size_t size, bool aslr, bool optimize_for_zero_base) {\n+\n+  char* result = nullptr;\n+\n+  \/\/ Optimize for unscaled encoding; failing that, for zero-based encoding:\n+  if (optimize_for_zero_base) {\n+    result = reserve_address_space_for_unscaled_encoding(size, aslr);\n+    if (result == nullptr) {\n+      result = reserve_address_space_for_zerobased_encoding(size, aslr);\n+    }\n+  } \/\/ end: low-address reservation\n+\n+  \/\/ Nothing more to optimize for on x64. If base != 0, we will always emit the full 64-bit immediate.\n+  return result;\n+}\n+\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/compressedKlass_x86.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -346,1 +346,1 @@\n-  assert((alignment & (os::vm_allocation_granularity() - 1)) == 0,\n+  assert(is_aligned(alignment, os::vm_allocation_granularity()),\n@@ -348,1 +348,2 @@\n-  assert((size & (alignment -1)) == 0, \"size must be 'alignment' aligned\");\n+  assert(is_aligned(size, os::vm_allocation_granularity()),\n+      \"Size must be a multiple of allocation granularity (page size)\");\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3331,3 +3331,4 @@\n-  assert((alignment & (os::vm_allocation_granularity() - 1)) == 0,\n-         \"Alignment must be a multiple of allocation granularity (page size)\");\n-  assert((size & (alignment -1)) == 0, \"size must be 'alignment' aligned\");\n+  assert(is_aligned(alignment, os::vm_allocation_granularity()),\n+      \"Alignment must be a multiple of allocation granularity (page size)\");\n+  assert(is_aligned(size, os::vm_allocation_granularity()),\n+      \"Size must be a multiple of allocation granularity (page size)\");\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1334,2 +1334,2 @@\n-      \/\/ case we reserve whereever possible, but the start address needs to be encodable as narrow Klass\n-      \/\/ encoding base since the archived heap objects contain nKlass IDs precalculated toward the start\n+      \/\/ case we reserve wherever possible, but the start address needs to be encodable as narrow Klass\n+      \/\/ encoding base since the archived heap objects contain nKlass IDs pre-calculated toward the start\n@@ -1338,1 +1338,1 @@\n-      total_space_rs = Metaspace::reserve_address_space_for_compressed_classes(total_range_size, false \/* try_in_low_address_ranges *\/);\n+      total_space_rs = Metaspace::reserve_address_space_for_compressed_classes(total_range_size, false \/* optimize_for_zero_base *\/);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n@@ -581,2 +582,1 @@\n-ReservedSpace Metaspace::reserve_address_space_for_compressed_classes(size_t size, bool try_in_low_address_ranges) {\n-\n+ReservedSpace Metaspace::reserve_address_space_for_compressed_classes(size_t size, bool optimize_for_zero_base) {\n@@ -584,15 +584,0 @@\n-  const bool randomize = RandomizeClassSpaceLocation;\n-\n-  \/\/ First try to reserve in low address ranges.\n-  if (try_in_low_address_ranges) {\n-    constexpr uintptr_t unscaled_max = ((uintptr_t)UINT_MAX + 1);\n-    log_debug(metaspace, map)(\"Trying below \" SIZE_FORMAT_X \" for unscaled narrow Klass encoding\", unscaled_max);\n-    result = os::attempt_reserve_memory_between(nullptr, (char*)unscaled_max,\n-                                                size, Metaspace::reserve_alignment(), randomize);\n-    if (result == nullptr) {\n-      constexpr uintptr_t zerobased_max = unscaled_max << LogKlassAlignmentInBytes;\n-      log_debug(metaspace, map)(\"Trying below \" SIZE_FORMAT_X \" for zero-based narrow Klass encoding\", zerobased_max);\n-      result = os::attempt_reserve_memory_between((char*)unscaled_max, (char*)zerobased_max,\n-                                                  size, Metaspace::reserve_alignment(), randomize);\n-    }\n-  } \/\/ end: low-address reservation\n@@ -600,26 +585,3 @@\n-#if defined(AARCH64) || defined(PPC64) || defined(S390)\n-  if (result == nullptr) {\n-    \/\/ Failing zero-based allocation, or in strict_base mode, try to come up with\n-    \/\/ an optimized start address that is amenable to JITs that use 16-bit moves to\n-    \/\/ load the encoding base as a short immediate.\n-    \/\/ Therefore we try here for an address that when right-shifted by\n-    \/\/ LogKlassAlignmentInBytes has only 1s in the third 16-bit quadrant.\n-    \/\/\n-    \/\/ Example: for shift=3, the address space searched would be\n-    \/\/ [0x0080_0000_0000 - 0xFFF8_0000_0000].\n-\n-    \/\/ Number of least significant bits that should be zero\n-    constexpr int lo_zero_bits = 32 + LogKlassAlignmentInBytes;\n-    \/\/ Number of most significant bits that should be zero\n-    constexpr int hi_zero_bits = 16;\n-\n-    constexpr size_t alignment = nth_bit(lo_zero_bits);\n-    assert(alignment >= Metaspace::reserve_alignment(), \"Sanity\");\n-    constexpr uint64_t min = alignment;\n-    constexpr uint64_t max = nth_bit(64 - hi_zero_bits);\n-\n-    log_debug(metaspace, map)(\"Trying between \" UINT64_FORMAT_X \" and \" UINT64_FORMAT_X\n-                              \" with \" SIZE_FORMAT_X \" alignment\", min, max, alignment);\n-    result = os::attempt_reserve_memory_between((char*)min, (char*)max, size, alignment, randomize);\n-  }\n-#endif \/\/ defined(AARCH64) || defined(PPC64) || defined(S390)\n+  NOT_ZERO(result =\n+      (char*) CompressedKlassPointers::reserve_address_space_for_compressed_classes(size, RandomizeClassSpaceLocation,\n+                                                                                    optimize_for_zero_base));\n@@ -628,1 +590,1 @@\n-    \/\/ Fallback: reserve anywhere and hope the resulting block is usable.\n+    \/\/ Fallback: reserve anywhere\n@@ -636,0 +598,1 @@\n+    log_debug(metaspace, map)(\"Mapped at \" PTR_FORMAT, p2i(result));\n@@ -640,0 +603,1 @@\n+    log_debug(metaspace, map)(\"Failed to map.\");\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":8,"deletions":44,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  static ReservedSpace reserve_address_space_for_compressed_classes(size_t size, bool try_in_low_address_ranges);\n+  static ReservedSpace reserve_address_space_for_compressed_classes(size_t size, bool optimize_for_zero_base);\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"memory\/metaspace.hpp\"\n@@ -28,0 +30,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -38,0 +41,7 @@\n+#ifdef ASSERT\n+void CompressedKlassPointers::assert_is_valid_encoding(address addr, size_t len, address base, int shift) {\n+  assert(base + nth_bit(32 + shift) >= addr + len, \"Encoding (base=\" PTR_FORMAT \", shift=%d) does not \"\n+         \"fully cover the class range \" PTR_FORMAT \"-\" PTR_FORMAT, p2i(base), shift, p2i(addr), p2i(addr + len));\n+}\n+#endif\n+\n@@ -53,3 +63,5 @@\n-  set_base(requested_base);\n-  set_shift(requested_shift);\n-  set_range(encoding_range_size);\n+  _base = requested_base;\n+  _shift = requested_shift;\n+  _range = encoding_range_size;\n+\n+  DEBUG_ONLY(assert_is_valid_encoding(addr, len, _base, _shift);)\n@@ -58,7 +70,4 @@\n-\/\/ Given an address range [addr, addr+len) which the encoding is supposed to\n-\/\/  cover, choose base, shift and range.\n-\/\/  The address range is the expected range of uncompressed Klass pointers we\n-\/\/  will encounter (and the implicit promise that there will be no Klass\n-\/\/  structures outside this range).\n-void CompressedKlassPointers::initialize(address addr, size_t len) {\n-  address const end = addr + len;\n+char* CompressedKlassPointers::reserve_address_space_X(uintptr_t from, uintptr_t to, size_t size, size_t alignment, bool aslr) {\n+  alignment = MAX2(Metaspace::reserve_alignment(), alignment);\n+  return os::attempt_reserve_memory_between((char*)from, (char*)to, size, alignment, aslr);\n+}\n@@ -66,3 +75,3 @@\n-  address base;\n-  int shift;\n-  size_t range;\n+char* CompressedKlassPointers::reserve_address_space_for_unscaled_encoding(size_t size, bool aslr) {\n+  return reserve_address_space_X(0, nth_bit(32), size, Metaspace::reserve_alignment(), aslr);\n+}\n@@ -70,6 +79,3 @@\n-  \/\/ Attempt to run with encoding base == zero\n-  if (end <= (address)KlassEncodingMetaspaceMax) {\n-    base = 0;\n-  } else {\n-    base = addr;\n-  }\n+char* CompressedKlassPointers::reserve_address_space_for_zerobased_encoding(size_t size, bool aslr) {\n+  return reserve_address_space_X(nth_bit(32), nth_bit(32 + LogKlassAlignmentInBytes), size, Metaspace::reserve_alignment(), aslr);\n+}\n@@ -77,2 +83,3 @@\n-  \/\/ Highest offset a Klass* can ever have in relation to base.\n-  range = end - base;\n+char* CompressedKlassPointers::reserve_address_space_for_16bit_move(size_t size, bool aslr) {\n+  return reserve_address_space_X(nth_bit(32), nth_bit(48), size, nth_bit(32), aslr);\n+}\n@@ -80,4 +87,18 @@\n-  \/\/ We may not even need a shift if the range fits into 32bit:\n-  const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);\n-  if (range <= UnscaledClassSpaceMax) {\n-    shift = 0;\n+#ifndef AARCH64\n+\/\/ On aarch64 we have an own version; all other platforms use the default version\n+void CompressedKlassPointers::initialize(address addr, size_t len) {\n+  \/\/ The default version of this code tries, in order of preference:\n+  \/\/ -unscaled    (base=0 shift=0)\n+  \/\/ -zero-based  (base=0 shift>0)\n+  \/\/ -nonzero-base (base>0 shift=0)\n+  \/\/ Note that base>0 shift>0 should never be needed, since the klass range will\n+  \/\/ never exceed 4GB.\n+  constexpr uintptr_t unscaled_max = nth_bit(32);\n+  assert(len <= unscaled_max, \"Klass range larger than 32 bits?\");\n+\n+  constexpr uintptr_t zerobased_max = nth_bit(32 + LogKlassAlignmentInBytes);\n+\n+  address const end = addr + len;\n+  if (end <= (address)unscaled_max) {\n+    _base = nullptr;\n+    _shift = 0;\n@@ -85,1 +106,7 @@\n-    shift = LogKlassAlignmentInBytes;\n+    if (end <= (address)zerobased_max) {\n+      _base = nullptr;\n+      _shift = LogKlassAlignmentInBytes;\n+    } else {\n+      _base = addr;\n+      _shift = 0;\n+    }\n@@ -87,0 +114,1 @@\n+  _range = end - _base;\n@@ -88,3 +116,1 @@\n-  set_base(base);\n-  set_shift(shift);\n-  set_range(range);\n+  DEBUG_ONLY(assert_is_valid_encoding(addr, len, _base, _shift);)\n@@ -92,0 +118,1 @@\n+#endif \/\/ !AARCH64\n@@ -99,15 +126,0 @@\n-void CompressedKlassPointers::set_base(address base) {\n-  assert(UseCompressedClassPointers, \"no compressed klass ptrs?\");\n-  _base   = base;\n-}\n-\n-void CompressedKlassPointers::set_shift(int shift)       {\n-  assert(shift == 0 || shift == LogKlassAlignmentInBytes, \"invalid shift for klass ptrs\");\n-  _shift   = shift;\n-}\n-\n-void CompressedKlassPointers::set_range(size_t range) {\n-  assert(UseCompressedClassPointers, \"no compressed klass ptrs?\");\n-  _range = range;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":56,"deletions":44,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -59,3 +59,7 @@\n-  static void set_base(address base);\n-  static void set_range(size_t range);\n-  static void set_shift(int shift);\n+  \/\/ Helper function for common cases.\n+  static char* reserve_address_space_X(uintptr_t from, uintptr_t to, size_t size, size_t alignment, bool aslr);\n+  static char* reserve_address_space_for_unscaled_encoding(size_t size, bool aslr);\n+  static char* reserve_address_space_for_zerobased_encoding(size_t size, bool aslr);\n+  static char* reserve_address_space_for_16bit_move(size_t size, bool aslr);\n+\n+  DEBUG_ONLY(static void assert_is_valid_encoding(address addr, size_t len, address base, int shift);)\n@@ -65,0 +69,4 @@\n+  \/\/ Reserve a range of memory that is to contain Klass strucutures which are referenced by narrow Klass IDs.\n+  \/\/ If optimize_for_zero_base is true, the implementation will attempt to reserve optimized for zero-based encoding.\n+  static char* reserve_address_space_for_compressed_classes(size_t size, bool aslr, bool optimize_for_zero_base);\n+\n@@ -67,1 +75,2 @@\n-  \/\/ archived heap objects.\n+  \/\/ archived heap objects. In this case, we don't have the freedom to choose base and shift; they are handed to\n+  \/\/ us from CDS.\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1987,0 +1987,5 @@\n+                                                                            \\\n+  develop(bool, SimulateFullAddressSpace, false,                             \\\n+          \"Simulates a very populated, fragmented address space; no \"       \\\n+          \"targeted reservations will succeed.\")                            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1813,1 +1813,1 @@\n-  char* result = pd_attempt_reserve_memory_at(addr, bytes, executable);\n+  char* result = SimulateFullAddressSpace ? nullptr : pd_attempt_reserve_memory_at(addr, bytes, executable);\n@@ -1821,1 +1821,0 @@\n-\n@@ -1877,1 +1876,1 @@\n-#define ARGSFMT \" range [\" PTR_FORMAT \"-\" PTR_FORMAT \"), size \" SIZE_FORMAT_X \", alignment \" SIZE_FORMAT_X \", randomize: %d\"\n+#define ARGSFMT \"range [\" PTR_FORMAT \"-\" PTR_FORMAT \"), size \" SIZE_FORMAT_X \", alignment \" SIZE_FORMAT_X \", randomize: %d\"\n@@ -1880,1 +1879,1 @@\n-  log_trace(os, map) (\"reserve_between (\" ARGSFMT \")\", ARGSFMTARGS);\n+  log_debug(os, map) (\"reserve_between (\" ARGSFMT \")\", ARGSFMTARGS);\n@@ -1990,1 +1989,1 @@\n-    result = os::pd_attempt_reserve_memory_at(candidate, bytes, false);\n+    result = SimulateFullAddressSpace ? nullptr : os::pd_attempt_reserve_memory_at(candidate, bytes, false);\n@@ -2008,0 +2007,2 @@\n+  } else {\n+    log_debug(os, map)(\"failed to attach anywhere in [\" PTR_FORMAT \"-\" PTR_FORMAT \")\", p2i(min), p2i(max));\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test the various CPU-specific reservation schemes\n+ * @requires vm.bits == 64 & !vm.graal.enabled & vm.debug == true\n+ * @requires vm.flagless\n+ * @requires os.family != \"windows\"\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver CompressedCPUSpecificClassSpaceReservation\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jtreg.SkippedException;\n+\n+import java.io.IOException;\n+\n+public class CompressedCPUSpecificClassSpaceReservation {\n+    \/\/ Note: windows: On windows, we currently have the issue that os::reserve_memory_aligned relies on\n+    \/\/ os::attempt_reserve_memory_at because VirtualAlloc cannot be unmapped in parts; this precludes use of\n+    \/\/ +SimulateFullAddressSpace (VM won't be able to reserve heap). Therefore we exclude the test for windows\n+    \/\/ for now.\n+\n+    private static void do_test(boolean CDS) throws IOException {\n+        \/\/ We start the VM with -XX:+SimulateFullAdressSpace, which means the JVM will go through all motions\n+        \/\/ of reserving the cds+class space, but never succeed. That means we see every single allocation attempt.\n+        \/\/ We start with -Xlog options enabled. The expected output goes like this:\n+        \/\/ [0.017s][debug][os,map] reserve_between (range [0x0000000000000000-0x0000000100000000), size 0x41000000, alignment 0x1000000, randomize: 1)\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                \"-Xshare:\" + (CDS ? \"on\" : \"off\"),\n+                \"-Xmx128m\",\n+                \"-XX:CompressedClassSpaceSize=128m\",\n+                \"-Xlog:metaspace*\", \"-Xlog:metaspace+map=trace\", \"-Xlog:os+map=trace\",\n+                \"-XX:+SimulateFullAddressSpace\", \/\/ So that no resevation attempt will succeed\n+                \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        final String tryReserveForUnscaled = \"reserve_between (range [0x0000000000000000-0x0000000100000000)\";\n+        final String tryReserveForZeroBased = \"reserve_between (range [0x0000000100000000-0x0000000800000000)\";\n+        final String tryReserveFor16bitMoveIntoQ3 = \"reserve_between (range [0x0000000100000000-0x0001000000000000)\";\n+        if (Platform.isAArch64()) {\n+            if (CDS) {\n+                output.shouldNotContain(tryReserveForUnscaled);\n+            } else {\n+                output.shouldContain(tryReserveForUnscaled);\n+            }\n+            output.shouldContain(\"Trying to reserve at an EOR-compatible address\");\n+            output.shouldNotContain(tryReserveForZeroBased);\n+            output.shouldContain(tryReserveFor16bitMoveIntoQ3);\n+        } else if (Platform.isPPC()) {\n+            if (CDS) {\n+                output.shouldNotContain(tryReserveForUnscaled);\n+                output.shouldNotContain(tryReserveForZeroBased);\n+            } else {\n+                output.shouldContain(tryReserveForUnscaled);\n+                output.shouldContain(tryReserveForZeroBased);\n+            }\n+            output.shouldContain(tryReserveFor16bitMoveIntoQ3);\n+        } else if (Platform.isRISCV64()) {\n+            output.shouldContain(tryReserveForUnscaled); \/\/ unconditionally\n+            if (CDS) {\n+                output.shouldNotContain(tryReserveForZeroBased);\n+                \/\/ bits 32..44\n+                output.shouldContain(\"reserve_between (range [0x0000000100000000-0x0000100000000000)\");\n+            } else {\n+                output.shouldContain(tryReserveForZeroBased);\n+                \/\/ bits 32..44, but not lower than zero-based limit\n+                output.shouldContain(\"reserve_between (range [0x0000000800000000-0x0000100000000000)\");\n+            }\n+            \/\/ bits 44..64\n+            output.shouldContain(\"reserve_between (range [0x0000100000000000-0xffffffffffffffff)\");\n+        } else if (Platform.isS390x()) {\n+            output.shouldContain(tryReserveForUnscaled); \/\/ unconditionally\n+            if (CDS) {\n+                output.shouldNotContain(tryReserveForZeroBased);\n+            } else {\n+                output.shouldContain(tryReserveForZeroBased);\n+            }\n+            output.shouldContain(tryReserveFor16bitMoveIntoQ3);\n+        } else if (Platform.isX64()) {\n+            if (CDS) {\n+                output.shouldNotContain(tryReserveForUnscaled);\n+                output.shouldNotContain(tryReserveForZeroBased);\n+            } else {\n+                output.shouldContain(tryReserveForUnscaled);\n+                output.shouldContain(tryReserveForZeroBased);\n+            }\n+        } else {\n+            throw new RuntimeException(\"Unexpected platform\");\n+        }\n+\n+        \/\/ In all cases we should have managed to map successfully eventually\n+        if (CDS) {\n+            output.shouldContain(\"CDS archive(s) mapped at:\");\n+        } else {\n+            output.shouldContain(\"CDS archive(s) not mapped\");\n+        }\n+        output.shouldContain(\"Compressed class space mapped at:\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"Test with CDS\");\n+        do_test(true);\n+        System.out.println(\"Test without CDS\");\n+        do_test(false);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedCPUSpecificClassSpaceReservation.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"}]}