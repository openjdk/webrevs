{"files":[{"patch":"@@ -368,1 +368,2 @@\n-IfProjNode* PhaseIdealLoop::clone_assertion_predicate_for_unswitched_loops(Node* iff, IfProjNode* predicate,\n+IfProjNode* PhaseIdealLoop::clone_assertion_predicate_for_unswitched_loops(IfNode* template_assertion_predicate,\n+                                                                           IfProjNode* predicate,\n@@ -371,3 +372,5 @@\n-  Node* bol = create_bool_from_template_assertion_predicate(iff, nullptr, nullptr, parse_predicate_proj);\n-  IfProjNode* if_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, iff->Opcode(), false);\n-  _igvn.replace_input_of(if_proj->in(0), 1, bol);\n+  TemplateAssertionPredicateExpression template_assertion_predicate_expression(\n+      template_assertion_predicate->in(1)->as_Opaque4());\n+  Opaque4Node* cloned_opaque4_node = template_assertion_predicate_expression.clone(parse_predicate_proj, this);\n+  IfProjNode* if_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, template_assertion_predicate->Opcode(), false);\n+  _igvn.replace_input_of(if_proj->in(0), 1, cloned_opaque4_node);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/predicates.hpp\"\n@@ -1662,1 +1663,1 @@\n-  IfProjNode* clone_assertion_predicate_for_unswitched_loops(Node* iff, IfProjNode* predicate,\n+  IfProjNode* clone_assertion_predicate_for_unswitched_loops(IfNode* template_assertion_predicate, IfProjNode* predicate,\n@@ -1676,0 +1677,6 @@\n+  Node* clone_and_register(Node* n, Node* ctrl) {\n+    n = n->clone();\n+    register_new_node(n, ctrl);\n+    return n;\n+  }\n+\n@@ -1909,0 +1916,2 @@\n+  void clone_data_nodes_and_transform_opaque_loop_nodes(const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+                                                        Node* new_ctrl);\n@@ -1910,0 +1919,1 @@\n+  void transform_opaque_node(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* node);\n@@ -1920,0 +1930,13 @@\n+\n+  \/\/ Create a copy of the data nodes provided to the constructor by doing the following:\n+  \/\/ Clone all non-OpaqueLoop* nodes and rewire them to create an identical subgraph copy. For the OpaqueLoop* nodes,\n+  \/\/ apply the provided transformation strategy and include the transformed node into the subgraph copy to get a complete\n+  \/\/ \"cloned-and-transformed\" graph copy. For all newly cloned nodes (which could also be new OpaqueLoop* nodes), set\n+  \/\/ `new_ctrl` as ctrl.\n+  const OrigToNewHashtable& clone_with_opaque_loop_transform_strategy(\n+      const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+      Node* new_ctrl) {\n+    clone_data_nodes_and_transform_opaque_loop_nodes(transform_strategy, new_ctrl);\n+    rewire_clones_to_cloned_inputs();\n+    return _orig_to_new;\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -4505,1 +4505,1 @@\n-\/\/ Clone the given node and set it up properly. Set `new_ctrl` as ctrl.\n+\/\/ Clone the given node and set it up properly. Set 'new_ctrl' as ctrl.\n@@ -4526,0 +4526,27 @@\n+\n+\/\/ Clone all non-OpaqueLoop* nodes and apply the provided transformation strategy for OpaqueLoop* nodes.\n+\/\/ Set 'new_ctrl' as ctrl for all cloned non-OpaqueLoop* nodes.\n+void DataNodeGraph::clone_data_nodes_and_transform_opaque_loop_nodes(\n+    const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+    Node* new_ctrl) {\n+  for (uint i = 0; i < _data_nodes.size(); i++) {\n+    Node* data_node = _data_nodes[i];\n+    if (data_node->is_Opaque1()) {\n+      transform_opaque_node(transform_strategy, data_node);\n+    } else {\n+      clone(data_node, new_ctrl);\n+    }\n+  }\n+}\n+\n+void DataNodeGraph::transform_opaque_node(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* node) {\n+  Node* transformed_node;\n+  if (node->is_OpaqueLoopInit()) {\n+    transformed_node = transform_strategy.transform_opaque_init(node->as_OpaqueLoopInit());\n+  } else {\n+    assert(node->is_OpaqueLoopStride(), \"must be OpaqueLoopStrideNode\");\n+    transformed_node = transform_strategy.transform_opaque_stride(node->as_OpaqueLoopStride());\n+  }\n+  \/\/ Add an orig->new mapping to correctly update the inputs of the copied graph in rewire_clones_to_cloned_inputs().\n+  _orig_to_new.put(node, transformed_node);\n+}\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -137,0 +137,3 @@\n+class OpaqueLoopInitNode;\n+class OpaqueLoopStrideNode;\n+class Opaque4Node;\n@@ -789,3 +792,6 @@\n-    DEFINE_CLASS_ID(Move,     Node, 17)\n-    DEFINE_CLASS_ID(LShift,   Node, 18)\n-    DEFINE_CLASS_ID(Neg,      Node, 19)\n+      DEFINE_CLASS_ID(OpaqueLoopInit, Opaque1, 0)\n+      DEFINE_CLASS_ID(OpaqueLoopStride, Opaque1, 1)\n+    DEFINE_CLASS_ID(Opaque4,  Node, 17)\n+    DEFINE_CLASS_ID(Move,     Node, 18)\n+    DEFINE_CLASS_ID(LShift,   Node, 19)\n+    DEFINE_CLASS_ID(Neg,      Node, 20)\n@@ -958,0 +964,3 @@\n+  DEFINE_CLASS_QUERY(Opaque4)\n+  DEFINE_CLASS_QUERY(OpaqueLoopInit)\n+  DEFINE_CLASS_QUERY(OpaqueLoopStride)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    init_class_id(Class_OpaqueLoopInit);\n@@ -70,0 +71,1 @@\n+    init_class_id(Class_OpaqueLoopStride);\n@@ -123,0 +125,1 @@\n+    init_class_id(Class_Opaque4);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"opto\/loopnode.hpp\"\n+#include \"opto\/node.hpp\"\n@@ -150,0 +152,124 @@\n+\n+\/\/ This strategy clones the OpaqueLoopInit and OpaqueLoopStride nodes.\n+class CloneStrategy : public TransformStrategyForOpaqueLoopNodes {\n+  PhaseIdealLoop* const _phase;\n+  Node* const _new_ctrl;\n+\n+ public:\n+  CloneStrategy(PhaseIdealLoop* phase, Node* new_ctrl)\n+      : _phase(phase),\n+        _new_ctrl(new_ctrl) {}\n+  NONCOPYABLE(CloneStrategy);\n+\n+  Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) const override {\n+    return _phase->clone_and_register(opaque_init, _new_ctrl)->as_OpaqueLoopInit();\n+  }\n+\n+  Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) const override {\n+    return _phase->clone_and_register(opaque_stride, _new_ctrl)->as_OpaqueLoopStride();\n+  }\n+};\n+\n+\/\/ Creates an identical clone of this Template Assertion Predicate Expression (i.e.cloning all nodes from the Opaque4Node\n+\/\/ to and including the OpaqueLoop* nodes). The cloned nodes are rewired to reflect the same graph structure as found for\n+\/\/ this Template Assertion Predicate Expression. The cloned nodes get 'new_ctrl' as ctrl. There is no other update done\n+\/\/ for the cloned nodes. Return the newly cloned Opaque4Node.\n+Opaque4Node* TemplateAssertionPredicateExpression::clone(Node* new_ctrl, PhaseIdealLoop* phase) {\n+  CloneStrategy clone_init_and_stride_strategy(phase, new_ctrl);\n+  return clone(clone_init_and_stride_strategy, new_ctrl, phase);\n+}\n+\n+\/\/ Class to collect data nodes from a source to target nodes by following the inputs of the source node recursively.\n+\/\/ The class takes a node filter to decide which input nodes to follow and a target node predicate to start backtracking\n+\/\/ from. All nodes found on all paths from source->target(s) are returned in a Unique_Node_List (without duplicates).\n+class DataNodesOnPathsToTargets : public StackObj {\n+  typedef bool (*NodeCheck)(const Node*);\n+\n+  \/\/ Node filter function to decide if we should process a node or not while searching for targets.\n+  NodeCheck _node_filter;\n+  \/\/ Function to decide if a node is a target node (i.e. where we should start backtracking). This check should also\n+  \/\/ trivially pass the _node_filter.\n+  NodeCheck _is_target_node;\n+  \/\/ The resulting node collection of all nodes on paths from source->target(s).\n+  Unique_Node_List _collected_nodes;\n+  \/\/ List to track all nodes visited on the search for target nodes starting at a start node. These nodes are then used\n+  \/\/ in backtracking to find the nodes actually being on a start->target(s) path. This list also serves as visited set\n+  \/\/ to avoid double visits of a node which could happen with diamonds shapes.\n+  Unique_Node_List _nodes_to_visit;\n+\n+ public:\n+  DataNodesOnPathsToTargets(NodeCheck node_filter, NodeCheck is_target_node)\n+      : _node_filter(node_filter),\n+        _is_target_node(is_target_node) {}\n+  NONCOPYABLE(DataNodesOnPathsToTargets);\n+\n+  \/\/ Collect all input nodes from 'start_node'->target(s) by applying the node filter to discover new input nodes and\n+  \/\/ the target node predicate to stop discovering more inputs and start backtracking. The implementation is done\n+  \/\/ with two BFS traversal: One to collect the target nodes (if any) and one to backtrack from the target nodes to\n+  \/\/ find all other nodes on the start->target(s) paths.\n+  const Unique_Node_List& collect(Node* start_node) {\n+    assert(_collected_nodes.size() == 0 && _nodes_to_visit.size() == 0, \"should not call this method twice in a row\");\n+    assert(!_is_target_node(start_node), \"no trivial paths where start node is also a target node\");\n+\n+    collect_target_nodes(start_node);\n+    backtrack_from_target_nodes();\n+    assert(_collected_nodes.size() == 0 || _collected_nodes.member(start_node),\n+           \"either target node predicate was never true or must find start node again when doing backtracking work\");\n+    return _collected_nodes;\n+  }\n+\n+ private:\n+  \/\/ Do a BFS from the start_node to collect all target nodes. We can then do another BFS from the target nodes to\n+  \/\/ find all nodes on the paths from start->target(s).\n+  \/\/ Note: We could do a single DFS pass to search targets and backtrack in one walk. But this is much more complex.\n+  \/\/       Given that the typical Template Assertion Predicate Expression only consists of a few nodes, we aim for\n+  \/\/       simplicity here.\n+  void collect_target_nodes(Node* start_node) {\n+    _nodes_to_visit.push(start_node);\n+    for (uint i = 0; i < _nodes_to_visit.size(); i++) {\n+      Node* next = _nodes_to_visit[i];\n+      for (uint j = 1; j < next->req(); j++) {\n+        Node* input = next->in(j);\n+        if (_is_target_node(input)) {\n+          assert(_node_filter(input), \"must also pass node filter\");\n+          _collected_nodes.push(input);\n+        } else if (_node_filter(input)) {\n+          _nodes_to_visit.push(input);\n+        }\n+      }\n+    }\n+  }\n+\n+  \/\/ Backtrack from all previously collected target nodes by using the visited set of the start->target(s) search. If no\n+  \/\/ node was collected in the first place (i.e. target node predicate was never true), then nothing needs to be done.\n+  void backtrack_from_target_nodes() {\n+    for (uint i = 0; i < _collected_nodes.size(); i++) {\n+      Node* node_on_path = _collected_nodes[i];\n+      for (DUIterator_Fast jmax, j = node_on_path->fast_outs(jmax); j < jmax; j++) {\n+        Node* use = node_on_path->fast_out(j);\n+        if (_nodes_to_visit.member(use)) {\n+          \/\/ use must be on a path from start->target(s) because it was also visited in the first BFS starting from\n+          \/\/ the start node.\n+          _collected_nodes.push(use);\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+\/\/ Clones this Template Assertion Predicate Expression and applies the given strategy to transform the OpaqueLoop* nodes.\n+Opaque4Node* TemplateAssertionPredicateExpression::clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+                                                         Node* new_ctrl, PhaseIdealLoop* phase) {\n+  ResourceMark rm;\n+  auto is_opaque_loop_node = [](const Node* node) {\n+    return node->is_Opaque1();\n+  };\n+  DataNodesOnPathsToTargets data_nodes_on_path_to_targets(TemplateAssertionPredicateExpression::maybe_contains,\n+                                                          is_opaque_loop_node);\n+  const Unique_Node_List& collected_nodes = data_nodes_on_path_to_targets.collect(_opaque4_node);\n+  DataNodeGraph data_node_graph(collected_nodes, phase);\n+  const OrigToNewHashtable& orig_to_new = data_node_graph.clone_with_opaque_loop_transform_strategy(transform_strategy, new_ctrl);\n+  assert(orig_to_new.contains(_opaque4_node), \"must exist\");\n+  Node* opaque4_clone = *orig_to_new.get(_opaque4_node);\n+  return opaque4_clone->as_Opaque4();\n+}\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -266,0 +267,45 @@\n+\/\/ Interface to transform OpaqueLoopInit and OpaqueLoopStride nodes of a Template Assertion Predicate Expression.\n+class TransformStrategyForOpaqueLoopNodes : public StackObj {\n+ public:\n+  virtual Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) const = 0;\n+  virtual Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) const = 0;\n+};\n+\n+\/\/ A Template Assertion Predicate Expression represents the Opaque4Node for the initial value or the last value of a\n+\/\/ Template Assertion Predicate and all the nodes up to and including the OpaqueLoop* nodes.\n+class TemplateAssertionPredicateExpression : public StackObj {\n+  Opaque4Node* _opaque4_node;\n+\n+ public:\n+  explicit TemplateAssertionPredicateExpression(Opaque4Node* opaque4_node) : _opaque4_node(opaque4_node) {}\n+\n+ private:\n+  Opaque4Node* clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* new_ctrl, PhaseIdealLoop* phase);\n+\n+ public:\n+  \/\/ Is 'n' a node that could be part of a Template Assertion Predicate Expression (i.e. could be found on the input\n+  \/\/ chain of a Template Assertion Predicate Opaque4Node up to and including the OpaqueLoop* nodes)?\n+  static bool maybe_contains(const Node* n) {\n+    const int opcode = n->Opcode();\n+    return (opcode == Op_OpaqueLoopInit ||\n+            opcode == Op_OpaqueLoopStride ||\n+            n->is_Bool() ||\n+            n->is_Cmp() ||\n+            opcode == Op_AndL ||\n+            opcode == Op_OrL ||\n+            opcode == Op_RShiftL ||\n+            opcode == Op_LShiftL ||\n+            opcode == Op_LShiftI ||\n+            opcode == Op_AddL ||\n+            opcode == Op_AddI ||\n+            opcode == Op_MulL ||\n+            opcode == Op_MulI ||\n+            opcode == Op_SubL ||\n+            opcode == Op_SubI ||\n+            opcode == Op_ConvI2L ||\n+            opcode == Op_CastII);\n+  }\n+\n+  Opaque4Node* clone(Node* new_ctrl, PhaseIdealLoop* phase);\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"opto\/predicates.hpp\"\n@@ -104,2 +105,3 @@\n-        Node* bol = create_bool_from_template_assertion_predicate(m, nullptr, nullptr, m->in(0));\n-        _igvn.replace_input_of(m, 1, bol);\n+        TemplateAssertionPredicateExpression template_assertion_predicate_expression(m->in(1)->as_Opaque4());\n+        Opaque4Node* cloned_opaque4_node = template_assertion_predicate_expression.clone(m->in(0), this);\n+        _igvn.replace_input_of(m, 1, cloned_opaque4_node);\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327110\n+ * @requires vm.compiler2.enabled\n+ * @summary Test that DFS algorithm for cloning Template Assertion Predicate Expression does not endlessly process paths.\n+ * @run main\/othervm\/timeout=30 -Xcomp -XX:LoopMaxUnroll=0\n+ *                              -XX:CompileCommand=compileonly,*TestCloningWithManyDiamondsInExpression::test*\n+ *                              -XX:CompileCommand=inline,*TestCloningWithManyDiamondsInExpression::create*\n+ *                              compiler.predicates.TestCloningWithManyDiamondsInExpression\n+ * @run main\/othervm\/timeout=30 -Xbatch -XX:LoopMaxUnroll=0\n+ *                              -XX:CompileCommand=compileonly,*TestCloningWithManyDiamondsInExpression::test*\n+ *                              -XX:CompileCommand=inline,*TestCloningWithManyDiamondsInExpression::create*\n+ *                              compiler.predicates.TestCloningWithManyDiamondsInExpression\n+ * @run main compiler.predicates.TestCloningWithManyDiamondsInExpression\n+ *\/\n+\n+package compiler.predicates;\n+\n+public class TestCloningWithManyDiamondsInExpression {\n+    static int limit = 100;\n+    static int iFld;\n+    static boolean flag;\n+    static int[] iArr;\n+\n+    public static void main(String[] strArr) {\n+        Math.min(10, 13); \/\/ Load class for Xcomp mode.\n+        for (int i = 0; i < 10_000; i++) {\n+            testSplitIf(i % 2);\n+            testLoopUnswitching(i % 2);\n+        }\n+    }\n+\n+    static void testLoopUnswitching(int x) {\n+        \/\/ We create an array with a positive size whose type range is known by the C2 compiler to be positive.\n+        \/\/ Loop Predication will then be able to hoist the array check out of the loop by creating a Hoisted\n+        \/\/ Check Predicate accompanied by a Template Assertion Predicate. The Template Assertion Predicate\n+        \/\/ Expression gets the size as an input. When splitting the loop further (i.e. when doing Loop Unswitching),\n+        \/\/ the predicate needs to be updated. We need to clone all nodes of the Tempalte Assertion Predicate\n+        \/\/ Expression. We first need to find them by doing a DFS walk.\n+        \/\/\n+        \/\/ createExpressionWithManyDiamonds() creates an expression with many diamonds. The current implementation\n+        \/\/ (found in create_bool_from_template_assertion_predicate()) to clone the Template Assertion Predicate\n+        \/\/ does not use a visited set. Therefore, the DFS implementation visits nodes twice to discover more paths.\n+        \/\/ The more diamonds we add, the more possible paths we get to visit. This leads to an exponential explosion\n+        \/\/ of paths and time required to visit them all. This example here will get \"stuck\" during DFS while trying\n+        \/\/ to walk all the possible paths.\n+        \/\/\n+        int[] a = new int[createExpressionWithManyDiamonds(x) + 1000];\n+        for (int i = 0; i < limit; i++) {\n+            a[i] = i; \/\/ Loop Predication hoists this check and creates a Template Assertion Predicate.\n+            \/\/ Triggers Loop Unswitching -> we need to clone the Template Assertion Predicates\n+            \/\/ to both the true- and false-path loop. Will take forever (see explanation above).\n+            if (x == 0) {\n+                iFld = 34;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as for Loop Unswitching but triggered in Split If when the Tempalte Assertion Predicate Expression\n+    \/\/ needs to be cloned. This time it's not the size of the array that contains many diamonds but the array\n+    \/\/ index for the first and last value Template Assertion Predicate Expression.\n+    static void testSplitIf(int x) {\n+        int e = createExpressionWithManyDiamonds(x);\n+        iArr = new int[1000];\n+        int a;\n+        if (flag) {\n+            a = 4;\n+        } else {\n+            a = 3;\n+        }\n+\n+        for (int i = a; i < 100; i++) {\n+            iArr[i+e] = 34;\n+        }\n+    }\n+\n+\n+    \/\/ Creates in int expression with many diamonds. This method is forced-inlined.\n+    static int createExpressionWithManyDiamonds(int x) {\n+        int e = Math.min(10, Math.max(1, x));\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2) - 823542;\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2) - 823542;\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2) - 823542;\n+        return e;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestCloningWithManyDiamondsInExpression.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}