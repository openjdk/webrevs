{"files":[{"patch":"@@ -368,1 +368,1 @@\n-IfProjNode* PhaseIdealLoop::clone_assertion_predicate_for_unswitched_loops(Node* template_assertion_predicate,\n+IfProjNode* PhaseIdealLoop::clone_assertion_predicate_for_unswitched_loops(IfNode* template_assertion_predicate,\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/predicates.hpp\"\n@@ -1662,1 +1663,1 @@\n-  IfProjNode* clone_assertion_predicate_for_unswitched_loops(Node* template_assertion_predicate, IfProjNode* predicate,\n+  IfProjNode* clone_assertion_predicate_for_unswitched_loops(IfNode* template_assertion_predicate, IfProjNode* predicate,\n@@ -1889,7 +1890,0 @@\n-\/\/ Interface to transform OpaqueLoopInit and OpaqueLoopStride nodes of a Template Assertion Predicate Expression.\n-class TransformStrategyForOpaqueLoopNodes : public StackObj {\n- public:\n-  virtual Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) = 0;\n-  virtual Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) = 0;\n-};\n-\n@@ -1922,1 +1916,1 @@\n-  void clone_data_nodes_and_transform_opaque_loop_nodes(TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+  void clone_data_nodes_and_transform_opaque_loop_nodes(const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n@@ -1925,1 +1919,1 @@\n-  void transform_opaque_node(TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* node);\n+  void transform_opaque_node(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* node);\n@@ -1937,1 +1931,1 @@\n-  \/\/ Create a copy of the provided data node collection by doing the following:\n+  \/\/ Create a copy of the data nodes provided to the constructor by doing the following:\n@@ -1942,2 +1936,3 @@\n-  const OrigToNewHashtable& clone_with_opaque_loop_transform_strategy(TransformStrategyForOpaqueLoopNodes& transform_strategy,\n-                                                                      Node* new_ctrl) {\n+  const OrigToNewHashtable& clone_with_opaque_loop_transform_strategy(\n+      const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+      Node* new_ctrl) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -4529,2 +4529,3 @@\n-void DataNodeGraph::clone_data_nodes_and_transform_opaque_loop_nodes(TransformStrategyForOpaqueLoopNodes& transform_strategy,\n-                                                                     Node* new_ctrl) {\n+void DataNodeGraph::clone_data_nodes_and_transform_opaque_loop_nodes(\n+    const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+    Node* new_ctrl) {\n@@ -4541,2 +4542,1 @@\n-void DataNodeGraph::transform_opaque_node(TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* node) {\n-  const uint next_idx = _phase->C->unique();\n+void DataNodeGraph::transform_opaque_node(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* node) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-  Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) override {\n+  Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) const override {\n@@ -168,1 +168,1 @@\n-  Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) override {\n+  Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) const override {\n@@ -184,2 +184,2 @@\n-\/\/ from. All nodes found on all paths from source->target(s) returned in a Unique_Node_List (without duplicates).\n-class DataNodesOnPathToTargets : public StackObj {\n+\/\/ from. All nodes found on all paths from source->target(s) are returned in a Unique_Node_List (without duplicates).\n+class DataNodesOnPathsToTargets : public StackObj {\n@@ -188,4 +188,5 @@\n-  NodeCheck _node_filter; \/\/ Node filter function to decide if we should process a node or not while searching for targets.\n-  NodeCheck _is_target_node; \/\/ Function to decide if a node is a target node (i.e. where we should start backtracking).\n-  Node_Stack _stack; \/\/ Stack that stores entries of the form: [Node* node, int next_unvisited_input_index_of_node].\n-  VectorSet _visited; \/\/ Ensure that we are not visiting a node twice in the DFS walk which could happen with diamonds.\n+  \/\/ Node filter function to decide if we should process a node or not while searching for targets.\n+  NodeCheck _node_filter;\n+  \/\/ Function to decide if a node is a target node (i.e. where we should start backtracking). This check should also\n+  \/\/ trivially pass the _node_filter.\n+  NodeCheck _is_target_node;\n@@ -193,0 +194,4 @@\n+  \/\/ List to track all nodes visited on the search for target nodes starting at a start node. These nodes are then used\n+  \/\/ in backtracking to find the nodes actually being on a start->target(s) path. This list also serves as visited set\n+  \/\/ to avoid double visits of a node which could happen with diamonds shapes.\n+  Unique_Node_List _nodes_to_visit;\n@@ -195,1 +200,1 @@\n-  DataNodesOnPathToTargets(NodeCheck node_filter, NodeCheck is_target_node)\n+  DataNodesOnPathsToTargets(NodeCheck node_filter, NodeCheck is_target_node)\n@@ -197,3 +202,2 @@\n-        _is_target_node(is_target_node),\n-        _stack(2) {}\n-  NONCOPYABLE(DataNodesOnPathToTargets);\n+        _is_target_node(is_target_node) {}\n+  NONCOPYABLE(DataNodesOnPathsToTargets);\n@@ -203,2 +207,2 @@\n-  \/\/ with an iterative DFS walk including a visited set to avoid redundant double visits when encountering a diamand\n-  \/\/ shape which could consume a lot of unnecessary time.\n+  \/\/ with two BFS traversal: One to collect the target nodes (if any) and one to backtrack from the target nodes to\n+  \/\/ find all other nodes on the start->target(s) paths.\n@@ -206,2 +210,2 @@\n-    assert(_collected_nodes.size() == 0, \"should not call this method twice in a row\");\n-    assert(!_is_target_node(start_node), \"no trivial paths where start node is also a target\");\n+    assert(_collected_nodes.size() == 0 && _nodes_to_visit.size() == 0, \"should not call this method twice in a row\");\n+    assert(!_is_target_node(start_node), \"no trivial paths where start node is also a target node\");\n@@ -209,12 +213,4 @@\n-    push_unvisited_node(start_node);\n-    while (_stack.is_nonempty()) {\n-      Node* current = _stack.node();\n-      _visited.set(current->_idx);\n-      if (_is_target_node(current)) {\n-        \/\/ Target node? Do not visit its inputs and begin backtracking.\n-        _collected_nodes.push(current);\n-        pop_target_node_and_collect_predecessor();\n-      } else if (!push_next_unvisited_input()) {\n-        \/\/ All inputs visited. Continue backtracking.\n-        pop_node_and_maybe_collect_predecessor();\n-      }\n+    collect_target_nodes(start_node);\n+    if (_collected_nodes.size() != 0) {\n+      backtrack_from_target_nodes();\n+      assert(_collected_nodes.member(start_node), \"must find start node again when backtracking\");\n@@ -226,46 +222,16 @@\n-  \/\/ The predecessor (just below the target node (currently on top) on the stack) is also on the path from\n-  \/\/ start->target. Collect it and pop the target node from the top of the stack.\n-  void pop_target_node_and_collect_predecessor() {\n-    _stack.pop();\n-    assert(_stack.is_nonempty(), \"target nodes should not be start nodes\");\n-    _collected_nodes.push(_stack.node());\n-  }\n-\n-  \/\/ Push the next unvisited input node of the current node on top of the stack by using its stored associated input index:\n-  \/\/\n-  \/\/                        Stack:\n-  \/\/      I1  I2  I3        [current, 2] \/\/ Index 2 means that I1 (first data node at index 1) was visited before.\n-  \/\/       \\  |  \/                       \/\/ The next unvisited input is I2. Visit I2 by pushing a new entry [I2, 1]\n-  \/\/   Y   current                       \/\/ and update the index [current, 2] -> [current, 3] to visit I3 once 'current'\n-  \/\/    \\  \/                             \/\/ is on top of stack again later in DFS walk.\n-  \/\/     X                  [X, 3]       \/\/ Index 3 points past node input array which means that there are no more inputs\n-  \/\/                                     \/\/ to visit. Once X is on top of stack again, we are done with 'X' and pop it.\n-  \/\/\n-  \/\/ If an input was already collected before (i.e. part of start->target), then the current node is part of some kind\n-  \/\/ of diamond with it:\n-  \/\/\n-  \/\/        C3       X\n-  \/\/       \/  \\     \/\n-  \/\/     C2   current\n-  \/\/      \\  \/\n-  \/\/       C1\n-  \/\/\n-  \/\/ Cx means collected. Since C3 is already collected (and thus already visited), we add 'current' to the collected list\n-  \/\/ since it must also be on a path from start->target. We continue the DFS with X which could potentially also be on a\n-  \/\/ start->target path but that is not known yet.\n-  \/\/\n-  \/\/ This method returns true if there is an unvisited input and return false otherwise if all inputs have been visited.\n-  bool push_next_unvisited_input() {\n-    Node* current = _stack.node();\n-    const uint next_unvisited_input_index = _stack.index();\n-    for (uint i = next_unvisited_input_index; i < current->req(); i++) {\n-      Node* input = current->in(i);\n-      if (_node_filter(input)) {\n-        if (!_visited.test(input->_idx)) { \/\/ Avoid double visits which could take a long time to process.\n-          \/\/ Visit current->in(i) next in DFS walk. Once 'current' is again on top of stack, we need to visit in(i+1).\n-          push_input_and_update_current_index(input, i + 1);\n-          return true;\n-        } else if (_collected_nodes.member(input)) {\n-          \/\/ Diamond case, see description above.\n-          \/\/ Input node part of start->target? Then current node (i.e. a predecessor of input) is also on path. Collect it.\n-          _collected_nodes.push(current);\n+  \/\/ Do a BFS from the start_node to collect all target nodes. We can then do another BFS from the target nodes to\n+  \/\/ find all nodes on the paths from start->target(s).\n+  \/\/ Note: We could do a single DFS pass to search targets and backtrack in one walk. But this is much more complex.\n+  \/\/       Given that the typical Template Assertion Predicate Expression only consists of a few nodes, we aim for\n+  \/\/       simplicity here.\n+  void collect_target_nodes(Node* start_node) {\n+    _nodes_to_visit.push(start_node);\n+    for (uint i = 0; i < _nodes_to_visit.size(); i++) {\n+      Node* next = _nodes_to_visit[i];\n+      for (uint j = 1; j < next->req(); j++) {\n+        Node* input = next->in(j);\n+        if (_is_target_node(input)) {\n+          assert(_node_filter(input), \"must also pass node filter\");\n+          _collected_nodes.push(input);\n+        } else if (_node_filter(input)) {\n+          _nodes_to_visit.push(input);\n@@ -275,13 +241,0 @@\n-    return false;\n-  }\n-\n-  \/\/ Update the index of the current node on top of the stack with the next unvisited input index and push 'input' to\n-  \/\/ the stack which is visited next in the DFS order.\n-  void push_input_and_update_current_index(Node* input, uint next_unvisited_input_index) {\n-    _stack.set_index(next_unvisited_input_index);\n-    push_unvisited_node(input);\n-  }\n-\n-  \/\/ Push the next unvisited node in the DFS order with index 1 since this node needs to visit all its inputs.\n-  void push_unvisited_node(Node* next_to_visit) {\n-    _stack.push(next_to_visit, 1);\n@@ -290,9 +243,12 @@\n-  \/\/ If the current node on top of the stack is on a path from start->target(s), then also collect the predecessor node\n-  \/\/ before popping the current node.\n-  void pop_node_and_maybe_collect_predecessor() {\n-    Node* current_node = _stack.node();\n-    _stack.pop();\n-    if (_stack.is_nonempty() && _collected_nodes.member(current_node)) {\n-      \/\/ Current node was part of start->target? Then predecessor (i.e. newly on top of stack) is also on path. Collect it.\n-      Node* predecessor = _stack.node();\n-      _collected_nodes.push(predecessor);\n+  \/\/ Backtrack from all previously collected target nodes by using the visited set of the start->target(s) search.\n+  void backtrack_from_target_nodes() {\n+    for (uint i = 0; i < _collected_nodes.size(); i++) {\n+      Node* node_on_path = _collected_nodes[i];\n+      for (DUIterator_Fast jmax, j = node_on_path->fast_outs(jmax); j < jmax; j++) {\n+        Node* use = node_on_path->fast_out(j);\n+        if (_nodes_to_visit.member(use)) {\n+          \/\/ use must be on a path from start->target(s) because it was also visited in the first BFS starting from\n+          \/\/ the start node.\n+          _collected_nodes.push(use);\n+        }\n+      }\n@@ -304,1 +260,1 @@\n-Opaque4Node* TemplateAssertionPredicateExpression::clone(TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+Opaque4Node* TemplateAssertionPredicateExpression::clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n@@ -310,2 +266,2 @@\n-  DataNodesOnPathToTargets data_nodes_on_path_to_targets(TemplateAssertionPredicateExpression::maybe_contains,\n-                                                         is_opaque_loop_node);\n+  DataNodesOnPathsToTargets data_nodes_on_path_to_targets(TemplateAssertionPredicateExpression::maybe_contains,\n+                                                          is_opaque_loop_node);\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":55,"deletions":99,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -267,0 +267,7 @@\n+\/\/ Interface to transform OpaqueLoopInit and OpaqueLoopStride nodes of a Template Assertion Predicate Expression.\n+class TransformStrategyForOpaqueLoopNodes : public StackObj {\n+ public:\n+  virtual Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) const = 0;\n+  virtual Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) const = 0;\n+};\n+\n@@ -276,1 +283,1 @@\n-  Opaque4Node* clone(TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* new_ctrl, PhaseIdealLoop* phase);\n+  Opaque4Node* clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* new_ctrl, PhaseIdealLoop* phase);\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @run main compiler.predicates.TestCloningWithManyDiamondsInExpression\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestCloningWithManyDiamondsInExpression.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}