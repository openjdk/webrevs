{"files":[{"patch":"@@ -345,1 +345,1 @@\n-void PhaseIdealLoop::insert_loop_limit_check_predicate(const ParsePredicateSuccessProj* loop_limit_check_parse_proj,\n+void CountedLoopConverter::insert_loop_limit_check_predicate(const ParsePredicateSuccessProj* loop_limit_check_parse_proj,\n@@ -348,3 +348,5 @@\n-  Node* new_predicate_proj = create_new_if_for_predicate(loop_limit_check_parse_proj, nullptr,\n-                                                         Deoptimization::Reason_loop_limit_check,\n-                                                         Op_If);\n+  Node* new_predicate_proj = _phase->create_new_if_for_predicate(loop_limit_check_parse_proj, nullptr,\n+                                                                 Deoptimization::Reason_loop_limit_check,\n+                                                                 Op_If);\n+\n+  PhaseIterGVN& igvn = _phase->igvn();\n@@ -352,4 +354,4 @@\n-  cmp_limit = _igvn.register_new_node_with_optimizer(cmp_limit);\n-  bol = _igvn.register_new_node_with_optimizer(bol);\n-  set_subtree_ctrl(bol, false);\n-  _igvn.replace_input_of(iff, 1, bol);\n+  cmp_limit = igvn.register_new_node_with_optimizer(cmp_limit);\n+  bol = igvn.register_new_node_with_optimizer(bol);\n+  _phase->set_subtree_ctrl(bol, false);\n+  igvn.replace_input_of(iff, 1, bol);\n@@ -373,2 +375,2 @@\n-  Node *init_control = head->in(LoopNode::EntryControl);\n-  Node *back_control = head->in(LoopNode::LoopBackControl);\n+  Node* init_control = head->in(LoopNode::EntryControl);\n+  Node* back_control = head->in(LoopNode::LoopBackControl);\n@@ -442,1 +444,1 @@\n-  return {cmp, incr, limit, bt, cl_prob};\n+  return {cmp->as_Cmp(), incr, limit, bt, cl_prob};\n@@ -1491,1 +1493,1 @@\n-bool PhaseIdealLoop::CountedLoopConverter::should_stress_long_counted_loop() const {\n+bool CountedLoopConverter::should_stress_long_counted_loop() const {\n@@ -1501,1 +1503,1 @@\n-bool PhaseIdealLoop::CountedLoopConverter::stress_long_counted_loop() const {\n+bool CountedLoopConverter::stress_long_counted_loop() const {\n@@ -1504,1 +1506,1 @@\n-  PhaseIterGVN* igvn = &_phase->_igvn;\n+  PhaseIterGVN* igvn = &_phase->igvn();\n@@ -1627,2 +1629,2 @@\n-bool PhaseIdealLoop::CountedLoopConverter::is_counted_loop() {\n-  PhaseIterGVN* igvn = &_phase->_igvn;\n+bool CountedLoopConverter::is_counted_loop() {\n+  PhaseIterGVN* igvn = &_phase->igvn();\n@@ -1635,1 +1637,1 @@\n-  LoopExitTest exit_test = _phase->loop_exit_test(back_control, _loop);\n+  PhaseIdealLoop::LoopExitTest exit_test = _phase->loop_exit_test(back_control, _loop);\n@@ -1646,1 +1648,1 @@\n-  const LoopIVIncr iv_incr = _phase->loop_iv_incr(incr, _head, _loop);\n+  const PhaseIdealLoop::LoopIVIncr iv_incr = PhaseIdealLoop::loop_iv_incr(incr, _head, _loop);\n@@ -1658,1 +1660,1 @@\n-  const LoopIvStride stride = loop_iv_stride(increment.incr);\n+  const PhaseIdealLoop::LoopIvStride stride = PhaseIdealLoop::loop_iv_stride(increment.incr);\n@@ -1672,1 +1674,1 @@\n-  PhiNode* phi = loop_iv_phi(xphi, iv_incr.phi_incr, _head);\n+  PhiNode* phi = PhaseIdealLoop::loop_iv_phi(xphi, iv_incr.phi_incr, _head);\n@@ -1718,1 +1720,1 @@\n-    const TypeInteger* phi_ft = _phase->filtered_type(phi);\n+    const TypeInteger* phi_ft = filtered_type(phi);\n@@ -2013,0 +2015,1 @@\n+  bool insert_stride_overflow_limit_check = false;\n@@ -2034,1 +2037,1 @@\n-    _insert_stride_overflow_limit_check = true;\n+    insert_stride_overflow_limit_check = true;\n@@ -2045,0 +2048,1 @@\n+  bool insert_init_trip_limit_check = false;\n@@ -2047,5 +2051,5 @@\n-          !_phase->has_dominating_loop_limit_check(init_trip,\n-                                                   exit_test.limit,\n-                                                   stride_con,\n-                                                   _iv_bt,\n-                                                   init_control))) { \/\/ (2.2)\n+          !has_dominating_loop_limit_check(init_trip,\n+                                           exit_test.limit,\n+                                           stride_con,\n+                                           _iv_bt,\n+                                           init_control))) { \/\/ (2.2)\n@@ -2080,1 +2084,1 @@\n-    _insert_init_trip_limit_check = true;\n+    insert_init_trip_limit_check = true;\n@@ -2135,0 +2139,3 @@\n+  _insert_stride_overflow_limit_check = insert_stride_overflow_limit_check;\n+  _insert_init_trip_limit_check = insert_init_trip_limit_check;\n+\n@@ -2142,1 +2149,1 @@\n-IdealLoopTree* PhaseIdealLoop::CountedLoopConverter::convert() {\n+IdealLoopTree* CountedLoopConverter::convert() {\n@@ -2147,1 +2154,1 @@\n-  PhaseIterGVN* igvn = &_phase->_igvn;\n+  PhaseIterGVN* igvn = &_phase->igvn();\n@@ -2156,1 +2163,1 @@\n-    _phase->insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n+    insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n@@ -2163,1 +2170,1 @@\n-    _phase->insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n+    insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n@@ -2364,0 +2371,1 @@\n+  IdealLoopTree* loop = _loop;\n@@ -2368,1 +2376,1 @@\n-    _loop = outer_ilt;\n+    loop = outer_ilt;\n@@ -2381,1 +2389,1 @@\n-  return _loop;\n+  return loop;\n@@ -2386,1 +2394,1 @@\n-bool PhaseIdealLoop::has_dominating_loop_limit_check(Node* init_trip, Node* limit, const jlong stride_con,\n+bool CountedLoopConverter::has_dominating_loop_limit_check(Node* init_trip, Node* limit, const jlong stride_con,\n@@ -2388,0 +2396,2 @@\n+  PhaseIterGVN& _igvn = _phase->igvn();\n+\n@@ -2410,2 +2420,2 @@\n-  _igvn.replace_input_of(iff, 0, C->top());\n-  _igvn.replace_input_of(iff, 1, C->top());\n+  _igvn.replace_input_of(iff, 0, _phase->C->top());\n+  _igvn.replace_input_of(iff, 1, _phase->C->top());\n@@ -3336,1 +3346,1 @@\n-const TypeInt* PhaseIdealLoop::filtered_type( Node *n, Node* n_ctrl) {\n+const TypeInt* CountedLoopConverter::filtered_type(Node* n, Node* n_ctrl) {\n@@ -3340,1 +3350,1 @@\n-    assert(n_ctrl != nullptr || n_ctrl == C->top(), \"valid control\");\n+    assert(n_ctrl != nullptr || n_ctrl == _phase->C->top(), \"valid control\");\n@@ -3347,1 +3357,1 @@\n-    if (region && region != C->top()) {\n+    if (region && region != _phase->C->top()) {\n@@ -3362,1 +3372,1 @@\n-  const TypeInt* n_t = _igvn.type(n)->is_int();\n+  const TypeInt* n_t = _phase->igvn().type(n)->is_int();\n@@ -3372,1 +3382,1 @@\n-const TypeInt* PhaseIdealLoop::filtered_type_from_dominators( Node* val, Node *use_ctrl) {\n+const TypeInt* CountedLoopConverter::filtered_type_from_dominators(Node* val, Node* use_ctrl) {\n@@ -3379,3 +3389,3 @@\n-  if (use_ctrl && use_ctrl != C->top()) {\n-    Node* val_ctrl = get_ctrl(val);\n-    uint val_dom_depth = dom_depth(val_ctrl);\n+  if (use_ctrl && use_ctrl != _phase->C->top()) {\n+    Node* val_ctrl = _phase->get_ctrl(val);\n+    uint val_dom_depth = _phase->dom_depth(val_ctrl);\n@@ -3387,1 +3397,1 @@\n-        const TypeInt* if_t = IfNode::filtered_int_type(&_igvn, val, pred);\n+        const TypeInt* if_t = IfNode::filtered_int_type(&_phase->igvn(), val, pred);\n@@ -3396,2 +3406,2 @@\n-      pred = idom(pred);\n-      if (pred == nullptr || pred == C->top()) {\n+      pred = _phase->idom(pred);\n+      if (pred == nullptr || pred == _phase->C->top()) {\n@@ -3401,1 +3411,1 @@\n-      if (dom_depth(pred) < val_dom_depth) {\n+      if (_phase->dom_depth(pred) < val_dom_depth) {\n@@ -5011,1 +5021,2 @@\n-volatile int PhaseIdealLoop::_long_loop_counted_loops=0; \/\/ Number of long loops successfully transformed to a counted loop\n+volatile int CountedLoopConverter::_long_loop_counted_loops = 0; \/\/ Number of long loops successfully transformed to a\n+                                                                 \/\/ counted loop\n@@ -5013,1 +5024,6 @@\n-  tty->print_cr(\"PhaseIdealLoop=%d, sum _unique=%d, long loops=%d\/%d\/%d\", _loop_invokes, _loop_work, _long_loop_counted_loops, _long_loop_nests, _long_loop_candidates);\n+  tty->print_cr(\"PhaseIdealLoop=%d, sum _unique=%d, long loops=%d\/%d\/%d\",\n+                _loop_invokes,\n+                _loop_work,\n+                CountedLoopConverter::_long_loop_counted_loops,\n+                _long_loop_nests,\n+                _long_loop_candidates);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":67,"deletions":51,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -1008,2 +1008,0 @@\n-  void insert_loop_limit_check_predicate(const ParsePredicateSuccessProj* loop_limit_check_parse_proj, Node* cmp_limit,\n-                                         Node* bol);\n@@ -1276,1 +1274,1 @@\n-    Node* cmp = nullptr;\n+    CmpNode* cmp = nullptr;\n@@ -1309,49 +1307,0 @@\n-  class CountedLoopConverter {\n-    PhaseIdealLoop* _phase;\n-    Node* _head;\n-    IdealLoopTree* _loop;\n-    const BasicType _iv_bt;\n-\n-    bool _insert_stride_overflow_limit_check = false;\n-    bool _insert_init_trip_limit_check = false;\n-\n-#ifdef ASSERT\n-    bool _checked_for_counted_loop = false;\n-#endif\n-\n-    \/\/ To be assigned once a counted loop is confirmed.\n-    Node* _limit;\n-    jlong _stride_con;\n-    Node* _phi;\n-    Node* _phi_increment;\n-    Node* _stride;\n-    bool _includes_limit;\n-    BoolTest::mask _mask;\n-    Node* _increment;\n-    Node* _cmp;\n-    float _cl_prob;\n-    Node* _sfpt;\n-    jlong _final_correction;\n-    const TypeInteger* _increment_truncation_type;\n-\n-   public:\n-    CountedLoopConverter(PhaseIdealLoop* phase, Node* head, IdealLoopTree* loop, const BasicType iv_bt)\n-      : _phase(phase),\n-        _head(head),\n-        _loop(loop),\n-        _iv_bt(iv_bt) {\n-      assert(phase != nullptr, \"\");\n-      assert(head != nullptr, \"\");\n-      assert(loop != nullptr, \"\");\n-      assert(iv_bt == T_INT || iv_bt == T_LONG, \"\");\n-    }\n-\n-    bool is_counted_loop();\n-    IdealLoopTree* convert();\n-\n-#ifdef ASSERT\n-    bool should_stress_long_counted_loop() const;\n-    bool stress_long_counted_loop() const;\n-#endif\n-  };\n-\n@@ -1477,2 +1426,0 @@\n-  bool has_dominating_loop_limit_check(Node* init_trip, Node* limit, jlong stride_con, BasicType iv_bt,\n-                                       Node* loop_entry);\n@@ -1680,6 +1627,0 @@\n-  \/\/ Return a type based on condition control flow\n-  const TypeInt* filtered_type( Node *n, Node* n_ctrl);\n-  const TypeInt* filtered_type( Node *n ) { return filtered_type(n, nullptr); }\n- \/\/ Helpers for filtered type\n-  const TypeInt* filtered_type_from_dominators( Node* val, Node *val_ctrl);\n-\n@@ -1814,1 +1755,0 @@\n-  static volatile int _long_loop_counted_loops;\n@@ -1898,0 +1838,64 @@\n+class CountedLoopConverter {\n+  friend class PhaseIdealLoop;\n+\n+  PhaseIdealLoop* const _phase;\n+  Node* const _head; \/\/ FIXME: type to LoopNode?\n+  IdealLoopTree* const _loop;\n+  const BasicType _iv_bt;\n+\n+#ifdef ASSERT\n+  bool _checked_for_counted_loop = false;\n+#endif\n+\n+  \/\/ stats for PhaseIdealLoop::print_statistics()\n+  static volatile int _long_loop_counted_loops;\n+\n+  \/\/ To be assigned once a counted loop is confirmed.\n+  Node* _limit;\n+  jlong _stride_con;\n+  Node* _phi;\n+  Node* _phi_increment;\n+  Node* _stride;\n+  bool _includes_limit;\n+  BoolTest::mask _mask;\n+  Node* _increment;\n+  Node* _cmp;\n+  float _cl_prob;\n+  Node* _sfpt;\n+  jlong _final_correction;\n+  const TypeInteger* _increment_truncation_type;\n+  bool _insert_stride_overflow_limit_check = false;\n+  bool _insert_init_trip_limit_check = false;\n+\n+  \/\/ Return a type based on condition control flow\n+  const TypeInt* filtered_type( Node *n, Node* n_ctrl);\n+  const TypeInt* filtered_type( Node *n ) { return filtered_type(n, nullptr); }\n+  \/\/ Helpers for filtered type\n+  const TypeInt* filtered_type_from_dominators( Node* val, Node *val_ctrl);\n+\n+  void insert_loop_limit_check_predicate(const ParsePredicateSuccessProj* loop_limit_check_parse_proj, Node* cmp_limit,\n+                                         Node* bol);\n+  bool has_dominating_loop_limit_check(Node* init_trip, Node* limit, jlong stride_con, BasicType iv_bt,\n+                                       Node* loop_entry);\n+\n+ public:\n+  CountedLoopConverter(PhaseIdealLoop* phase, Node* head, IdealLoopTree* loop, const BasicType iv_bt)\n+      : _phase(phase),\n+        _head(head),\n+        _loop(loop),\n+        _iv_bt(iv_bt) {\n+    assert(phase != nullptr, \"\"); \/\/ Fail early if mandatory parameters are null.\n+    assert(head != nullptr, \"\");\n+    assert(loop != nullptr, \"\");\n+    assert(iv_bt == T_INT || iv_bt == T_LONG, \"\"); \/\/ Loops can be either int or long.\n+  }\n+\n+  bool is_counted_loop();\n+  IdealLoopTree* convert();\n+\n+#ifdef ASSERT\n+  bool should_stress_long_counted_loop() const;\n+  bool stress_long_counted_loop() const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":65,"deletions":61,"binary":false,"changes":126,"status":"modified"}]}