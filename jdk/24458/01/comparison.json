{"files":[{"patch":"@@ -313,1 +313,1 @@\n-IdealLoopTree* PhaseIdealLoop::create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,\n+IdealLoopTree* PhaseIdealLoop::create_outer_strip_mined_loop(Node* init_control,\n@@ -345,1 +345,1 @@\n-void PhaseIdealLoop::insert_loop_limit_check_predicate(ParsePredicateSuccessProj* loop_limit_check_parse_proj,\n+void PhaseIdealLoop::insert_loop_limit_check_predicate(const ParsePredicateSuccessProj* loop_limit_check_parse_proj,\n@@ -367,1 +367,1 @@\n-Node* PhaseIdealLoop::loop_exit_control(Node* x, IdealLoopTree* loop) {\n+Node* PhaseIdealLoop::loop_exit_control(const Node* head, const IdealLoopTree* loop) const {\n@@ -370,1 +370,1 @@\n-  if (x->in(LoopNode::Self) == nullptr || x->req() != 3 || loop->_irreducible) {\n+  if (head->in(LoopNode::Self) == nullptr || head->req() != 3 || loop->_irreducible) {\n@@ -373,2 +373,2 @@\n-  Node *init_control = x->in(LoopNode::EntryControl);\n-  Node *back_control = x->in(LoopNode::LoopBackControl);\n+  Node *init_control = head->in(LoopNode::EntryControl);\n+  Node *back_control = head->in(LoopNode::LoopBackControl);\n@@ -407,2 +407,2 @@\n-Node* PhaseIdealLoop::loop_exit_test(Node* back_control, IdealLoopTree* loop, Node*& incr, Node*& limit, BoolTest::mask& bt, float& cl_prob) {\n-  Node* iftrue = back_control;\n+PhaseIdealLoop::LoopExitTest PhaseIdealLoop::loop_exit_test(const Node* back_control, const IdealLoopTree* loop) {\n+  const Node* iftrue = back_control;\n@@ -412,2 +412,2 @@\n-  bt = test->_test._test;\n-  cl_prob = iff->as_If()->_prob;\n+  BoolTest::mask bt = test->_test._test;\n+  float cl_prob = iff->as_If()->_prob;\n@@ -416,1 +416,1 @@\n-    cl_prob = 1.0 - cl_prob;\n+    cl_prob = 1.0f - cl_prob;\n@@ -421,1 +421,1 @@\n-    return nullptr;\n+    return {};\n@@ -425,2 +425,2 @@\n-  incr  = cmp->in(1);\n-  limit = cmp->in(2);\n+  Node* incr  = cmp->in(1);\n+  Node* limit = cmp->in(2);\n@@ -433,3 +433,1 @@\n-    Node* tmp = incr;            \/\/ Then reverse order into the CmpI\n-    incr = limit;\n-    limit = tmp;\n+    swap(incr, limit);                \/\/ Then reverse order into the CmpI\n@@ -439,1 +437,1 @@\n-    return nullptr;\n+    return {};\n@@ -442,1 +440,1 @@\n-    return nullptr;\n+    return {};\n@@ -444,1 +442,1 @@\n-  return cmp;\n+  return {cmp, incr, limit, bt, cl_prob};\n@@ -447,9 +445,6 @@\n-Node* PhaseIdealLoop::loop_iv_incr(Node* incr, Node* x, IdealLoopTree* loop, Node*& phi_incr) {\n-  if (incr->is_Phi()) {\n-    if (incr->as_Phi()->region() != x || incr->req() != 3) {\n-      return nullptr; \/\/ Not simple trip counter expression\n-    }\n-    phi_incr = incr;\n-    incr = phi_incr->in(LoopNode::LoopBackControl); \/\/ Assume incr is on backedge of Phi\n-    if (!is_member(loop, get_ctrl(incr))) { \/\/ Trip counter must be loop-variant\n-      return nullptr;\n+PhaseIdealLoop::LoopIVIncr PhaseIdealLoop::loop_iv_incr(Node* incr, const Node* head, const IdealLoopTree* loop) {\n+  if (incr->is_Phi() && incr->as_Phi()->region() == head && incr->req() == 3) { \/\/ Requires simple trip counter expression\n+    Node* phi_incr = incr;\n+    Node* back_control = phi_incr->in(LoopNode::LoopBackControl); \/\/ Assume incr is on backedge of Phi\n+    if (loop->_phase->is_member(loop, loop->_phase->get_ctrl(back_control))) { \/\/ Trip counter must be loop-variant\n+      return {back_control, phi_incr};\n@@ -458,1 +453,1 @@\n-  return incr;\n+  return {incr, nullptr};\n@@ -461,1 +456,1 @@\n-Node* PhaseIdealLoop::loop_iv_stride(Node* incr, IdealLoopTree* loop, Node*& xphi) {\n+PhaseIdealLoop::LoopIvStride PhaseIdealLoop::loop_iv_stride(const Node* incr) {\n@@ -464,1 +459,1 @@\n-  xphi = incr->in(1);\n+  Node* xphi = incr->in(1);\n@@ -468,1 +463,1 @@\n-      return nullptr;          \/\/ Nope, unknown stride, bail out\n+      return {};               \/\/ Nope, unknown stride, bail out\n@@ -470,3 +465,2 @@\n-    Node *tmp = xphi;          \/\/ 'incr' is commutative, so ok to swap\n-    xphi = stride;\n-    stride = tmp;\n+\n+    swap(xphi, stride);        \/\/ 'incr' is commutative, so ok to swap\n@@ -474,1 +468,1 @@\n-  return stride;\n+  return {stride, xphi};\n@@ -477,1 +471,1 @@\n-PhiNode* PhaseIdealLoop::loop_iv_phi(Node* xphi, Node* phi_incr, Node* x, IdealLoopTree* loop) {\n+PhiNode* PhaseIdealLoop::loop_iv_phi(const Node* xphi, const Node* phi_incr, const Node* head) {\n@@ -487,1 +481,1 @@\n-  if (phi->region() != x) {\n+  if (phi->region() != head) {\n@@ -618,1 +612,1 @@\n-static bool no_side_effect_since_safepoint(Compile* C, Node* x, Node* mem, MergeMemNode* mm, PhaseIdealLoop* phase) {\n+static bool no_side_effect_since_safepoint(Compile* C, const Node* head, const Node* mem, MergeMemNode* mm, const PhaseIdealLoop* phase) {\n@@ -620,2 +614,2 @@\n-  for (DUIterator_Fast imax, i = x->fast_outs(imax); i < imax; i++) {\n-    Node* u = x->fast_out(i);\n+  for (DUIterator_Fast imax, i = head->fast_outs(imax); i < imax; i++) {\n+    Node* u = head->fast_out(i);\n@@ -671,1 +665,1 @@\n-SafePointNode* PhaseIdealLoop::find_safepoint(Node* back_control, Node* x, IdealLoopTree* loop) {\n+SafePointNode* PhaseIdealLoop::find_safepoint(Node* back_control, const Node* head, const IdealLoopTree* loop) {\n@@ -678,1 +672,1 @@\n-    while (c != x && c->Opcode() != Op_SafePoint) {\n+    while (c != head && c->Opcode() != Op_SafePoint) {\n@@ -717,1 +711,1 @@\n-    if (!no_side_effect_since_safepoint(C, x, mem, mm, this)) {\n+    if (!no_side_effect_since_safepoint(C, head, mem, mm, this)) {\n@@ -1471,11 +1465,2 @@\n-  BoolTest::mask mask = BoolTest::illegal;\n-  float cl_prob = 0;\n-  Node* incr = nullptr;\n-  Node* limit = nullptr;\n-\n-  Node* cmp = loop_exit_test(back_control, loop, incr, limit, mask, cl_prob);\n-  assert(cmp != nullptr && cmp->Opcode() == Op_Cmp(bt), \"no exit test\");\n-\n-  Node* phi_incr = nullptr;\n-  incr = loop_iv_incr(incr, x, loop, phi_incr);\n-  assert(incr != nullptr && incr->Opcode() == Op_Add(bt), \"no incr\");\n+  LoopExitTest exit_test = loop_exit_test(back_control, loop);\n+  assert(exit_test.cmp != nullptr && exit_test.cmp->Opcode() == Op_Cmp(bt), \"no exit test\");\n@@ -1483,2 +1468,2 @@\n-  Node* xphi = nullptr;\n-  Node* stride = loop_iv_stride(incr, loop, xphi);\n+  const LoopIVIncr iv_incr = loop_iv_incr(exit_test.incr, x, loop);\n+  assert(iv_incr.incr != nullptr && iv_incr.incr->Opcode() == Op_Add(bt), \"no incr\");\n@@ -1486,1 +1471,2 @@\n-  assert(stride != nullptr, \"no stride\");\n+  LoopIvStride stride = loop_iv_stride(iv_incr.incr);\n+  assert(stride.stride != nullptr, \"no stride\");\n@@ -1488,1 +1474,2 @@\n-  PhiNode* phi = loop_iv_phi(xphi, phi_incr, x, loop);\n+  PhiNode* phi = loop_iv_phi(stride.xphi, iv_incr.phi_incr, x);\n+  assert(phi != nullptr && phi->in(LoopNode::LoopBackControl) == iv_incr.incr, \"No phi\");\n@@ -1490,1 +1477,2 @@\n-  assert(phi != nullptr && phi->in(LoopNode::LoopBackControl) == incr, \"No phi\");\n+  jlong stride_con = stride.stride->get_integer_as_long(bt);\n+  assert(condition_stride_ok(exit_test.mask, stride_con), \"illegal condition\");\n@@ -1492,7 +1480,3 @@\n-  jlong stride_con = stride->get_integer_as_long(bt);\n-\n-  assert(condition_stride_ok(mask, stride_con), \"illegal condition\");\n-\n-  assert(mask != BoolTest::ne, \"unexpected condition\");\n-  assert(phi_incr == nullptr, \"bad loop shape\");\n-  assert(cmp->in(1) == incr, \"bad exit test shape\");\n+  assert(exit_test.mask != BoolTest::ne, \"unexpected condition\");\n+  assert(iv_incr.phi_incr == nullptr, \"bad loop shape\");\n+  assert(exit_test.cmp->in(1) == iv_incr.incr, \"bad exit test shape\");\n@@ -1505,0 +1489,1 @@\n+\/\/------------------------------CountedLoopConverter--------------------------------\n@@ -1506,3 +1491,14 @@\n-\/\/ convert an int counted loop to a long counted to stress handling of\n-\/\/ long counted loops\n-bool PhaseIdealLoop::convert_to_long_loop(Node* cmp, Node* phi, IdealLoopTree* loop) {\n+bool PhaseIdealLoop::CountedLoopConverter::should_stress_long_counted_loop() const {\n+  assert(_checked_for_counted_loop, \"must check for counted loop before stressing\");\n+\n+  return StressLongCountedLoop > 0 &&\n+      _iv_bt == T_INT &&\n+      !_head->as_Loop()->is_loop_nest_inner_loop() &&\n+      _increment_truncation_type == TypeInt::INT; \/\/ Only stress an int loop (i.e., not char, byte or short)\n+}\n+\n+\/\/ Convert an int counted loop to a long counted to stress handling of long counted loops. Returns true upon success.\n+bool PhaseIdealLoop::CountedLoopConverter::stress_long_counted_loop() const {\n+  assert(should_stress_long_counted_loop(), \"stress condition not satisfied\");\n+\n+  PhaseIterGVN* igvn = &_phase->_igvn;\n@@ -1511,1 +1507,1 @@\n-  iv_nodes.push(cmp);\n+  iv_nodes.push(_cmp);\n@@ -1541,2 +1537,2 @@\n-    for (uint i = 1; i < n->req(); i++) {\n-      Node* in = n->in(i);\n+    for (uint j = 1; j < n->req(); j++) {\n+      Node* in = n->in(j);\n@@ -1546,1 +1542,1 @@\n-      if (loop->is_member(get_loop(get_ctrl(in)))) {\n+      if (_loop->is_member(_phase->get_loop(_phase->get_ctrl(in)))) {\n@@ -1557,1 +1553,1 @@\n-        _igvn.remove_dead_node(clone);\n+        igvn->remove_dead_node(clone);\n@@ -1566,2 +1562,2 @@\n-    for (uint i = 1; i < n->req(); i++) {\n-      Node* in = n->in(i);\n+    for (uint j = 1; j < n->req(); j++) {\n+      Node* in = n->in(j);\n@@ -1573,1 +1569,1 @@\n-        assert(_igvn.type(in)->isa_int(), \"\");\n+        assert(igvn->type(in)->isa_int(), \"\");\n@@ -1575,2 +1571,2 @@\n-        _igvn.register_new_node_with_optimizer(in_clone);\n-        set_subtree_ctrl(in_clone, false);\n+        igvn->register_new_node_with_optimizer(in_clone);\n+        _phase->set_subtree_ctrl(in_clone, false);\n@@ -1579,2 +1575,2 @@\n-        in_clone->set_req(0, C->top());\n-        clone->set_req(i, in_clone);\n+        in_clone->set_req(0, _phase->C->top());\n+        clone->set_req(j, in_clone);\n@@ -1583,1 +1579,1 @@\n-        clone->set_req(i, in_clone);\n+        clone->set_req(j, in_clone);\n@@ -1586,1 +1582,1 @@\n-    _igvn.register_new_node_with_optimizer(clone);\n+    igvn->register_new_node_with_optimizer(clone);\n@@ -1588,1 +1584,1 @@\n-  set_ctrl(old_new[phi->_idx], phi->in(0));\n+  _phase->set_ctrl(old_new[_phi->_idx], _phi->in(0));\n@@ -1593,1 +1589,1 @@\n-    set_subtree_ctrl(clone, false);\n+    _phase->set_subtree_ctrl(clone, false);\n@@ -1595,2 +1591,2 @@\n-    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-      Node* u = n->fast_out(i);\n+    for (DUIterator_Fast imax, j = n->fast_outs(imax); j < imax; j++) {\n+      Node* u = n->fast_out(j);\n@@ -1602,2 +1598,2 @@\n-        _igvn.register_new_node_with_optimizer(m);\n-        set_subtree_ctrl(m, false);\n+        igvn->register_new_node_with_optimizer(m);\n+        _phase->set_subtree_ctrl(m, false);\n@@ -1605,3 +1601,3 @@\n-      _igvn.rehash_node_delayed(u);\n-      int nb = u->replace_edge(n, m, &_igvn);\n-      --i, imax -= nb;\n+      igvn->rehash_node_delayed(u);\n+      int nb = u->replace_edge(n, m, igvn);\n+      --j, imax -= nb;\n@@ -1614,3 +1610,13 @@\n-\/\/------------------------------is_counted_loop--------------------------------\n-bool PhaseIdealLoop::is_counted_loop(Node* x, IdealLoopTree*&loop, BasicType iv_bt) {\n-  PhaseGVN *gvn = &_igvn;\n+bool PhaseIdealLoop::try_convert_to_counted_loop(Node* head, IdealLoopTree*& loop, const BasicType iv_bt) {\n+  CountedLoopConverter converter(this, head, loop, iv_bt);\n+  if (converter.is_counted_loop()) {\n+#ifdef ASSERT\n+    \/\/ Stress by converting int counted loops to long counted loops\n+    if (converter.should_stress_long_counted_loop() && converter.stress_long_counted_loop()) {\n+      return false;\n+    }\n+#endif\n+\n+    loop = converter.convert();\n+    return true;\n+  }\n@@ -1618,1 +1624,7 @@\n-  Node* back_control = loop_exit_control(x, loop);\n+  return false;\n+}\n+\n+bool PhaseIdealLoop::CountedLoopConverter::is_counted_loop() {\n+  PhaseIterGVN* igvn = &_phase->_igvn;\n+\n+  Node* back_control = _phase->loop_exit_control(_head, _loop);\n@@ -1623,6 +1635,2 @@\n-  BoolTest::mask bt = BoolTest::illegal;\n-  float cl_prob = 0;\n-  Node* incr = nullptr;\n-  Node* limit = nullptr;\n-  Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);\n-  if (cmp == nullptr || cmp->Opcode() != Op_Cmp(iv_bt)) {\n+  LoopExitTest exit_test = _phase->loop_exit_test(back_control, _loop);\n+  if (exit_test.cmp == nullptr || exit_test.cmp->Opcode() != Op_Cmp(_iv_bt)) {\n@@ -1633,1 +1641,2 @@\n-  if (incr->Opcode() == Op_Cast(iv_bt)) {\n+  Node* incr = exit_test.incr;\n+  if (exit_test.incr->Opcode() == Op_Cast(_iv_bt)) {\n@@ -1637,3 +1646,2 @@\n-  Node* phi_incr = nullptr;\n-  incr = loop_iv_incr(incr, x, loop, phi_incr);\n-  if (incr == nullptr) {\n+  const LoopIVIncr iv_incr = _phase->loop_iv_incr(incr, _head, _loop);\n+  if (iv_incr.incr == nullptr) {\n@@ -1643,5 +1651,2 @@\n-  Node* trunc1 = nullptr;\n-  Node* trunc2 = nullptr;\n-  const TypeInteger* iv_trunc_t = nullptr;\n-  Node* orig_incr = incr;\n-  if (!(incr = CountedLoopNode::match_incr_with_optional_truncation(incr, &trunc1, &trunc2, &iv_trunc_t, iv_bt))) {\n+  CountedLoopNode::TruncatedIncrement increment = CountedLoopNode::match_incr_with_optional_truncation(iv_incr.incr, _iv_bt);\n+  if (increment.incr == nullptr) {\n@@ -1650,1 +1655,0 @@\n-  assert(incr->Opcode() == Op_Add(iv_bt), \"wrong increment code\");\n@@ -1652,2 +1656,1 @@\n-  Node* xphi = nullptr;\n-  Node* stride = loop_iv_stride(incr, loop, xphi);\n+  assert(increment.incr->Opcode() == Op_Add(_iv_bt), \"wrong increment code\");\n@@ -1655,1 +1658,2 @@\n-  if (stride == nullptr) {\n+  const LoopIvStride stride = loop_iv_stride(increment.incr);\n+  if (stride.stride == nullptr) {\n@@ -1659,1 +1663,2 @@\n-  if (xphi->Opcode() == Op_Cast(iv_bt)) {\n+  Node* xphi = stride.xphi;\n+  if (xphi->Opcode() == Op_Cast(_iv_bt)) {\n@@ -1664,1 +1669,1 @@\n-  jlong stride_con = stride->get_integer_as_long(iv_bt);\n+  jlong stride_con = stride.stride->get_integer_as_long(_iv_bt);\n@@ -1667,1 +1672,1 @@\n-  PhiNode* phi = loop_iv_phi(xphi, phi_incr, x, loop);\n+  PhiNode* phi = loop_iv_phi(xphi, iv_incr.phi_incr, _head);\n@@ -1670,2 +1675,2 @@\n-      (trunc1 == nullptr && phi->in(LoopNode::LoopBackControl) != incr) ||\n-      (trunc1 != nullptr && phi->in(LoopNode::LoopBackControl) != trunc1)) {\n+      (increment.trunc1 == nullptr && phi->in(LoopNode::LoopBackControl) != increment.incr) ||\n+      (increment.trunc1 != nullptr && phi->in(LoopNode::LoopBackControl) != increment.trunc1)) {\n@@ -1675,1 +1680,1 @@\n-  Node* iftrue = back_control;\n+  const Node* iftrue = back_control;\n@@ -1680,2 +1685,2 @@\n-  const TypeInteger* limit_t = gvn->type(limit)->is_integer(iv_bt);\n-  if (trunc1 != nullptr) {\n+  const TypeInteger* limit_t = igvn->type(exit_test.limit)->is_integer(_iv_bt);\n+  if (increment.trunc1 != nullptr) {\n@@ -1699,1 +1704,1 @@\n-    const TypeInteger* incr_t = gvn->type(orig_incr)->is_integer(iv_bt);\n+    const TypeInteger* incr_t = igvn->type(iv_incr.incr)->is_integer(_iv_bt);\n@@ -1701,1 +1706,1 @@\n-      \/\/ if the limit can have a higher value than the increment (before the phi)\n+      \/\/ if the limit can have a higher value than the increment (before the0 phi)\n@@ -1706,1 +1711,1 @@\n-  Node *init_trip = phi->in(LoopNode::EntryControl);\n+  Node* init_trip = phi->in(LoopNode::EntryControl);\n@@ -1709,2 +1714,2 @@\n-  if (!TypeInteger::bottom(iv_bt)->higher_equal(iv_trunc_t)) {\n-    assert(trunc1 != nullptr, \"must have found some truncation\");\n+  if (!TypeInteger::bottom(_iv_bt)->higher_equal(increment.trunc_type)) {\n+    assert(increment.trunc1 != nullptr, \"must have found some truncation\");\n@@ -1713,1 +1718,1 @@\n-    const TypeInteger* phi_ft = filtered_type(phi);\n+    const TypeInteger* phi_ft = _phase->filtered_type(phi);\n@@ -1727,2 +1732,2 @@\n-      if (iv_trunc_t->hi_as_long() - phi_ft->hi_as_long() < stride_con ||\n-          iv_trunc_t->lo_as_long() > phi_ft->lo_as_long()) {\n+      if (increment.trunc_type->hi_as_long() - phi_ft->hi_as_long() < stride_con ||\n+          increment.trunc_type->lo_as_long() > phi_ft->lo_as_long()) {\n@@ -1732,2 +1737,2 @@\n-      if (iv_trunc_t->lo_as_long() - phi_ft->lo_as_long() > stride_con ||\n-          iv_trunc_t->hi_as_long() < phi_ft->hi_as_long()) {\n+      if (increment.trunc_type->lo_as_long() - phi_ft->lo_as_long() > stride_con ||\n+          increment.trunc_type->hi_as_long() < phi_ft->hi_as_long()) {\n@@ -1740,1 +1745,1 @@\n-    assert(trunc1 == nullptr && trunc2 == nullptr, \"no truncation for int\");\n+    assert(increment.trunc1 == nullptr && increment.trunc2 == nullptr, \"no truncation for int\");\n@@ -1743,1 +1748,1 @@\n-  if (!condition_stride_ok(bt, stride_con)) {\n+  if (!condition_stride_ok(exit_test.mask, stride_con)) {\n@@ -1747,2 +1752,1 @@\n-  const TypeInteger* init_t = gvn->type(init_trip)->is_integer(iv_bt);\n-\n+  const TypeInteger* init_t = igvn->type(init_trip)->is_integer(_iv_bt);\n@@ -1750,1 +1754,1 @@\n-    if (init_t->lo_as_long() > max_signed_integer(iv_bt) - stride_con) {\n+    if (init_t->lo_as_long() > max_signed_integer(_iv_bt) - stride_con) {\n@@ -1754,1 +1758,1 @@\n-    if (init_t->hi_as_long() < min_signed_integer(iv_bt) - stride_con) {\n+    if (init_t->hi_as_long() < min_signed_integer(_iv_bt) - stride_con) {\n@@ -1759,1 +1763,1 @@\n-  if (phi_incr != nullptr && bt != BoolTest::ne) {\n+  if (iv_incr.phi_incr != nullptr && exit_test.mask != BoolTest::ne) {\n@@ -1762,1 +1766,1 @@\n-      if (init_t->hi_as_long() > max_signed_integer(iv_bt) - stride_con) {\n+      if (init_t->hi_as_long() > max_signed_integer(_iv_bt) - stride_con) {\n@@ -1766,1 +1770,1 @@\n-      if (init_t->lo_as_long() < min_signed_integer(iv_bt) - stride_con) {\n+      if (init_t->lo_as_long() < min_signed_integer(_iv_bt) - stride_con) {\n@@ -1776,2 +1780,2 @@\n-  if (x->Opcode() == Op_Region) {\n-    \/\/ x has not yet been transformed to Loop or LongCountedLoop.\n+  if (_head->Opcode() == Op_Region) {\n+    \/\/ head has not yet been transformed to Loop or LongCountedLoop.\n@@ -1784,2 +1788,2 @@\n-    assert(x->as_Region()->is_in_infinite_subgraph(),\n-           \"x can only be a Region and not Loop if inside infinite loop\");\n+    assert(_head->as_Region()->is_in_infinite_subgraph(),\n+           \"head can only be a Region and not Loop if inside infinite loop\");\n@@ -1790,2 +1794,2 @@\n-  assert(x->Opcode() == Op_Loop || x->Opcode() == Op_LongCountedLoop, \"regular loops only\");\n-  C->print_method(PHASE_BEFORE_CLOOPS, 3, x);\n+  assert(_head->Opcode() == Op_Loop || _head->Opcode() == Op_LongCountedLoop, \"regular loops only\");\n+  _phase->C->print_method(PHASE_BEFORE_CLOOPS, 3, _head);\n@@ -1981,1 +1985,1 @@\n-  if (stride_con == min_signed_integer(iv_bt) || (ABS(stride_con) > max_signed_integer(iv_bt) \/ 2)) {\n+  if (stride_con == min_signed_integer(_iv_bt) || (ABS(stride_con) > max_signed_integer(_iv_bt) \/ 2)) {\n@@ -1986,1 +1990,1 @@\n-  const jlong limit_correction_for_pre_iv_exit_check = (phi_incr != nullptr) ? stride_con : 0;\n+  const jlong limit_correction_for_pre_iv_exit_check = (iv_incr.phi_incr != nullptr) ? stride_con : 0;\n@@ -1989,1 +1993,1 @@\n-  const bool includes_limit = (bt == BoolTest::le || bt == BoolTest::ge);\n+  const bool includes_limit = (exit_test.mask == BoolTest::le || exit_test.mask == BoolTest::ge);\n@@ -1996,2 +2000,9 @@\n-  int sov = check_stride_overflow(final_correction, limit_t, iv_bt);\n-  Node* init_control = x->in(LoopNode::EntryControl);\n+  int sov = check_stride_overflow(final_correction, limit_t, _iv_bt);\n+  Node* init_control = _head->in(LoopNode::EntryControl);\n+\n+  const Predicates predicates(init_control);\n+  const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n+\n+  if (sov < 0) {\n+    return false; \/\/ Bailout: integer overflow is certain.\n+  }\n@@ -1999,1 +2010,1 @@\n-  \/\/ If sov==0, limit's type always satisfies the condition, for\n+  \/\/ If sov == 0, limit's type always satisfies the condition, for\n@@ -2001,4 +2012,2 @@\n-  if (sov != 0) {\n-    if (sov < 0) {\n-      return false;  \/\/ Bailout: integer overflow is certain.\n-    }\n+\n+  if (sov > 0) {\n@@ -2007,3 +2016,1 @@\n-    assert(!x->as_Loop()->is_loop_nest_inner_loop(), \"loop was transformed\");\n-    const Predicates predicates(init_control);\n-    const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n+    assert(!_head->as_Loop()->is_loop_nest_inner_loop(), \"loop was transformed\");\n@@ -2015,2 +2022,2 @@\n-        loop->dump_head();\n-        x->dump(1);\n+        _loop->dump_head();\n+        _head->dump(1);\n@@ -2023,1 +2030,1 @@\n-    if (!is_dominator(get_ctrl(limit), loop_limit_check_parse_predicate->in(0))) {\n+    if (!_phase->is_dominator(_phase->get_ctrl(exit_test.limit), loop_limit_check_parse_predicate->in(0))) {\n@@ -2027,12 +2034,1 @@\n-    Node* cmp_limit;\n-    Node* bol;\n-\n-    if (stride_con > 0) {\n-      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_signed_integer(iv_bt) - final_correction, iv_bt), iv_bt);\n-      bol = new BoolNode(cmp_limit, BoolTest::le);\n-    } else {\n-      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_signed_integer(iv_bt) - final_correction, iv_bt), iv_bt);\n-      bol = new BoolNode(cmp_limit, BoolTest::ge);\n-    }\n-\n-    insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n+    _insert_stride_overflow_limit_check = true;\n@@ -2043,2 +2039,2 @@\n-          (stride_con > 0 && init_t->hi_as_long() > max_signed_integer(iv_bt) - stride_con) ||\n-          (stride_con < 0 && init_t->lo_as_long() < min_signed_integer(iv_bt) - stride_con);\n+      (stride_con > 0 && init_t->hi_as_long() > max_signed_integer(_iv_bt) - stride_con) ||\n+          (stride_con < 0 && init_t->lo_as_long() < min_signed_integer(_iv_bt) - stride_con);\n@@ -2047,1 +2043,1 @@\n-                              (stride_con < 0 && init_t->lo_as_long() <= limit_t->hi_as_long());\n+      (stride_con < 0 && init_t->lo_as_long() <= limit_t->hi_as_long());\n@@ -2050,2 +2046,6 @@\n-     ((bt == BoolTest::ne || init_plus_stride_could_overflow) && \/\/ (2.3)\n-      !has_dominating_loop_limit_check(init_trip, limit, stride_con, iv_bt, init_control))) { \/\/ (2.2)\n+      ((exit_test.mask == BoolTest::ne || init_plus_stride_could_overflow) && \/\/ (2.3)\n+          !_phase->has_dominating_loop_limit_check(init_trip,\n+                                                   exit_test.limit,\n+                                                   stride_con,\n+                                                   _iv_bt,\n+                                                   init_control))) { \/\/ (2.2)\n@@ -2061,2 +2061,0 @@\n-    const Predicates predicates(init_control);\n-    const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n@@ -2068,2 +2066,2 @@\n-        loop->dump_head();\n-        x->dump(1);\n+        _loop->dump_head();\n+        _head->dump(1);\n@@ -2077,2 +2075,2 @@\n-    if (!is_dominator(get_ctrl(limit), parse_predicate_entry) ||\n-        !is_dominator(get_ctrl(init_trip), parse_predicate_entry)) {\n+    if (!_phase->is_dominator(_phase->get_ctrl(exit_test.limit), parse_predicate_entry) ||\n+        !_phase->is_dominator(_phase->get_ctrl(init_trip), parse_predicate_entry)) {\n@@ -2082,12 +2080,1 @@\n-    Node* cmp_limit;\n-    Node* bol;\n-\n-    if (stride_con > 0) {\n-      cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n-      bol = new BoolNode(cmp_limit, BoolTest::lt);\n-    } else {\n-      cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n-      bol = new BoolNode(cmp_limit, BoolTest::gt);\n-    }\n-\n-    insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n+    _insert_init_trip_limit_check = true;\n@@ -2096,1 +2083,2 @@\n-  if (bt == BoolTest::ne) {\n+  BoolTest::mask mask = exit_test.mask;\n+  if (mask == BoolTest::ne) {\n@@ -2101,1 +2089,1 @@\n-      bt = BoolTest::lt;\n+      mask = BoolTest::lt;\n@@ -2105,1 +2093,1 @@\n-      bt = BoolTest::gt;\n+      mask = BoolTest::gt;\n@@ -2110,2 +2098,2 @@\n-  if (loop->_child == nullptr) {\n-    sfpt = find_safepoint(back_control, x, loop);\n+  if (_loop->_child == nullptr) {\n+    sfpt = _phase->find_safepoint(back_control, _head, _loop);\n@@ -2119,4 +2107,3 @@\n-  if (x->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n-    Node* backedge_sfpt = x->in(LoopNode::LoopBackControl);\n-    if (((iv_bt == T_INT && LoopStripMiningIter != 0) ||\n-         iv_bt == T_LONG) &&\n+  if (_head->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n+    if (((_iv_bt == T_INT && LoopStripMiningIter != 0) ||\n+        _iv_bt == T_LONG) &&\n@@ -2130,7 +2117,0 @@\n-    if (is_deleteable_safept(backedge_sfpt)) {\n-      lazy_replace(backedge_sfpt, iftrue);\n-      if (loop->_safepts != nullptr) {\n-        loop->_safepts->yank(backedge_sfpt);\n-      }\n-      loop->_tail = iftrue;\n-    }\n@@ -2139,0 +2119,15 @@\n+  \/\/ Variables needed by convert() to do the actual conversion. We set these fields iff a counted loop is confirmed.\n+  \/\/ This way the is_counted_loop() can run multiple times with possibly different configurations.\n+  _limit = exit_test.limit;\n+  _stride_con = stride_con;\n+  _final_correction = final_correction;\n+  _phi = phi;\n+  _phi_increment = iv_incr.phi_incr;\n+  _stride = stride.stride;\n+  _includes_limit = includes_limit;\n+  _mask = mask;\n+  _increment = increment.incr;\n+  _cmp = exit_test.cmp;\n+  _cl_prob = exit_test.cl_prob;\n+  _sfpt = sfpt;\n+  _increment_truncation_type = increment.trunc_type;\n@@ -2141,7 +2136,9 @@\n-  if (iv_bt == T_INT &&\n-      !x->as_Loop()->is_loop_nest_inner_loop() &&\n-      StressLongCountedLoop > 0 &&\n-      trunc1 == nullptr &&\n-      convert_to_long_loop(cmp, phi, loop)) {\n-    return false;\n-  }\n+  _checked_for_counted_loop = true;\n+#endif\n+\n+  return true;\n+}\n+\n+IdealLoopTree* PhaseIdealLoop::CountedLoopConverter::convert() {\n+#ifdef ASSERT\n+  assert(_checked_for_counted_loop, \"must check for counted loop before conversion\");\n@@ -2150,2 +2147,33 @@\n-  Node* adjusted_limit = limit;\n-  if (phi_incr != nullptr) {\n+  PhaseIterGVN* igvn = &_phase->_igvn;\n+  Node* init_control = _head->in(LoopNode::EntryControl);\n+\n+  if (_insert_stride_overflow_limit_check) {\n+    Node* cmp_limit = CmpNode::make(_limit, igvn->integercon((_stride_con > 0\n+                                                              ? max_signed_integer(_iv_bt)\n+                                                              : min_signed_integer(_iv_bt))\n+                                                                 - _final_correction, _iv_bt), _iv_bt);\n+    Node* bol = new BoolNode(cmp_limit, _stride_con > 0 ? BoolTest::le : BoolTest::ge);\n+    _phase->insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n+  }\n+\n+  Node* init_trip = _phi->in(LoopNode::EntryControl);\n+  if (_insert_init_trip_limit_check) {\n+    Node* cmp_limit = CmpNode::make(init_trip, _limit, _iv_bt);\n+    Node* bol = new BoolNode(cmp_limit, _stride_con > 0 ? BoolTest::lt : BoolTest::gt);\n+    _phase->insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n+  }\n+\n+  Node* back_control = _phase->loop_exit_control(_head, _loop);\n+  if (_head->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n+    Node* backedge_sfpt = _head->in(LoopNode::LoopBackControl);\n+    if (_phase->is_deleteable_safept(backedge_sfpt)) {\n+      _phase->lazy_replace(backedge_sfpt, back_control);\n+      if (_loop->_safepts != nullptr) {\n+        _loop->_safepts->yank(backedge_sfpt);\n+      }\n+      _loop->_tail = back_control;\n+    }\n+  }\n+\n+  Node* adjusted_limit = _limit;\n+  if (_phi_increment != nullptr) {\n@@ -2161,1 +2189,1 @@\n-    adjusted_limit = gvn->transform(AddNode::make(limit, stride, iv_bt));\n+    adjusted_limit = igvn->transform(AddNode::make(_limit, _stride, _iv_bt));\n@@ -2164,1 +2192,2 @@\n-  if (includes_limit) {\n+  BoolTest::mask mask = _mask;\n+  if (_includes_limit) {\n@@ -2168,6 +2197,6 @@\n-    Node* one = (stride_con > 0) ? gvn->integercon( 1, iv_bt) : gvn->integercon(-1, iv_bt);\n-    adjusted_limit = gvn->transform(AddNode::make(adjusted_limit, one, iv_bt));\n-    if (bt == BoolTest::le)\n-      bt = BoolTest::lt;\n-    else if (bt == BoolTest::ge)\n-      bt = BoolTest::gt;\n+    Node* one = (_stride_con > 0) ? igvn->integercon(1, _iv_bt) : igvn->integercon(-1, _iv_bt);\n+    adjusted_limit = igvn->transform(AddNode::make(adjusted_limit, one, _iv_bt));\n+    if (mask == BoolTest::le)\n+      mask = BoolTest::lt;\n+    else if (mask == BoolTest::ge)\n+      mask = BoolTest::gt;\n@@ -2177,1 +2206,1 @@\n-  set_subtree_ctrl(adjusted_limit, false);\n+  _phase->set_subtree_ctrl(adjusted_limit, false);\n@@ -2181,7 +2210,7 @@\n-  incr = incr->clone();\n-  incr->set_req(1,phi);\n-  incr->set_req(2,stride);\n-  incr = _igvn.register_new_node_with_optimizer(incr);\n-  set_early_ctrl(incr, false);\n-  _igvn.rehash_node_delayed(phi);\n-  phi->set_req_X( LoopNode::LoopBackControl, incr, &_igvn );\n+  Node* incr = _increment->clone();\n+  incr->set_req(1, _phi);\n+  incr->set_req(2, _stride);\n+  incr = igvn->register_new_node_with_optimizer(incr);\n+  _phase->set_early_ctrl(incr, false);\n+  igvn->rehash_node_delayed(_phi);\n+  _phi->set_req_X(LoopNode::LoopBackControl, incr, igvn);\n@@ -2192,6 +2221,7 @@\n-  if (!TypeInteger::bottom(iv_bt)->higher_equal(phi->bottom_type())) {\n-    Node* nphi = PhiNode::make(phi->in(0), phi->in(LoopNode::EntryControl), TypeInteger::bottom(iv_bt));\n-    nphi->set_req(LoopNode::LoopBackControl, phi->in(LoopNode::LoopBackControl));\n-    nphi = _igvn.register_new_node_with_optimizer(nphi);\n-    set_ctrl(nphi, get_ctrl(phi));\n-    _igvn.replace_node(phi, nphi);\n+  Node* phi = _phi;\n+  if (!TypeInteger::bottom(_iv_bt)->higher_equal(_phi->bottom_type())) {\n+    Node* nphi = PhiNode::make(_phi->in(0), _phi->in(LoopNode::EntryControl), TypeInteger::bottom(_iv_bt));\n+    nphi->set_req(LoopNode::LoopBackControl, _phi->in(LoopNode::LoopBackControl));\n+    nphi = igvn->register_new_node_with_optimizer(nphi);\n+    _phase->set_ctrl(nphi, _phase->get_ctrl(phi));\n+    igvn->replace_node(_phi, nphi);\n@@ -2200,2 +2230,7 @@\n-  cmp = cmp->clone();\n-  cmp->set_req(1,incr);\n+\n+  Node* iftrue = back_control;\n+  const uint iftrue_op = iftrue->Opcode();\n+  Node* iff = iftrue->in(0);\n+  Node* cmp = _cmp->clone();\n+\n+  cmp->set_req(1, incr);\n@@ -2203,2 +2238,2 @@\n-  cmp = _igvn.register_new_node_with_optimizer(cmp);\n-  set_ctrl(cmp, iff->in(0));\n+  cmp = igvn->register_new_node_with_optimizer(cmp);\n+  _phase->set_ctrl(cmp, iff->in(0));\n@@ -2206,5 +2241,5 @@\n-  test = test->clone()->as_Bool();\n-  (*(BoolTest*)&test->_test)._test = bt;\n-  test->set_req(1,cmp);\n-  _igvn.register_new_node_with_optimizer(test);\n-  set_ctrl(test, iff->in(0));\n+  BoolNode* test = iff->in(1)->clone()->as_Bool();\n+  const_cast<BoolTest*>(&test->_test)->_test = mask; \/\/ Yes, it's a const, but it's a newly cloned node so we should be fine.\n+  test->set_req(1, cmp);\n+  igvn->register_new_node_with_optimizer(test);\n+  _phase->set_ctrl(test, iff->in(0));\n@@ -2213,5 +2248,9 @@\n-  Node *lex = _igvn.register_new_node_with_optimizer(BaseCountedLoopEndNode::make(iff->in(0), test, cl_prob, iff->as_If()->_fcnt, iv_bt));\n-  IfNode *le = lex->as_If();\n-  uint dd = dom_depth(iff);\n-  set_idom(le, le->in(0), dd); \/\/ Update dominance for loop exit\n-  set_loop(le, loop);\n+  Node* lex = igvn->register_new_node_with_optimizer(BaseCountedLoopEndNode::make(iff->in(0),\n+                                                                                  test,\n+                                                                                  _cl_prob,\n+                                                                                  iff->as_If()->_fcnt,\n+                                                                                  _iv_bt));\n+  IfNode* le = lex->as_If();\n+  const uint dd = _phase->dom_depth(iff);\n+  _phase->set_idom(le, le->in(0), dd); \/\/ Update dominance for loop exit\n+  _phase->set_loop(le, _loop);\n@@ -2220,1 +2259,1 @@\n-  Node *iffalse = iff->as_If()->proj_out(!(iftrue_op == Op_IfTrue));\n+  Node* iffalse = iff->as_If()->proj_out(!(iftrue_op == Op_IfTrue));\n@@ -2222,1 +2261,1 @@\n-  \/\/ Need to swap loop-exit and loop-back control?\n+\/\/ Need to swap loop-exit and loop-back control?\n@@ -2224,2 +2263,2 @@\n-    Node *ift2=_igvn.register_new_node_with_optimizer(new IfTrueNode (le));\n-    Node *iff2=_igvn.register_new_node_with_optimizer(new IfFalseNode(le));\n+    Node* ift2 = igvn->register_new_node_with_optimizer(new IfTrueNode(le));\n+    Node* iff2 = igvn->register_new_node_with_optimizer(new IfFalseNode(le));\n@@ -2227,3 +2266,3 @@\n-    loop->_tail = back_control = ift2;\n-    set_loop(ift2, loop);\n-    set_loop(iff2, get_loop(iffalse));\n+    _loop->_tail = back_control = ift2;\n+    _phase->set_loop(ift2, _loop);\n+    _phase->set_loop(iff2, _phase->get_loop(iffalse));\n@@ -2232,2 +2271,2 @@\n-    lazy_replace(iffalse, iff2);\n-    lazy_replace(iftrue,  ift2);\n+    _phase->lazy_replace(iffalse, iff2);\n+    _phase->lazy_replace(iftrue, ift2);\n@@ -2237,1 +2276,1 @@\n-    iftrue  = ift2;\n+    iftrue = ift2;\n@@ -2239,4 +2278,4 @@\n-    _igvn.rehash_node_delayed(iffalse);\n-    _igvn.rehash_node_delayed(iftrue);\n-    iffalse->set_req_X( 0, le, &_igvn );\n-    iftrue ->set_req_X( 0, le, &_igvn );\n+    igvn->rehash_node_delayed(iffalse);\n+    igvn->rehash_node_delayed(iftrue);\n+    iffalse->set_req_X(0, le, igvn);\n+    iftrue->set_req_X(0, le, igvn);\n@@ -2245,2 +2284,2 @@\n-  set_idom(iftrue,  le, dd+1);\n-  set_idom(iffalse, le, dd+1);\n+  _phase->set_idom(iftrue, le, dd + 1);\n+  _phase->set_idom(iffalse, le, dd + 1);\n@@ -2248,1 +2287,1 @@\n-  lazy_replace( iff, le ); \/\/ fix 'get_ctrl'\n+  _phase->lazy_replace(iff, le); \/\/ fix 'get_ctrl'\n@@ -2251,5 +2290,5 @@\n-  bool strip_mine_loop = iv_bt == T_INT &&\n-                         loop->_child == nullptr &&\n-                         sfpt != nullptr &&\n-                         !loop->_has_call &&\n-                         is_deleteable_safept(sfpt);\n+  bool strip_mine_loop = _iv_bt == T_INT &&\n+      _loop->_child == nullptr &&\n+      _sfpt != nullptr &&\n+      !_loop->_has_call &&\n+      _phase->is_deleteable_safept(_sfpt);\n@@ -2258,3 +2297,1 @@\n-    outer_ilt = create_outer_strip_mined_loop(test, cmp, init_control, loop,\n-                                              cl_prob, le->_fcnt, entry_control,\n-                                              iffalse);\n+    outer_ilt = _phase->create_outer_strip_mined_loop(init_control, _loop, _cl_prob, le->_fcnt, entry_control, iffalse);\n@@ -2264,2 +2301,2 @@\n-  BaseCountedLoopNode *l = BaseCountedLoopNode::make(entry_control, back_control, iv_bt);\n-  l->set_unswitch_count(x->as_Loop()->unswitch_count()); \/\/ Preserve\n+  BaseCountedLoopNode* l = BaseCountedLoopNode::make(entry_control, back_control, _iv_bt);\n+  l->set_unswitch_count(_head->as_Loop()->unswitch_count()); \/\/ Preserve\n@@ -2270,3 +2307,3 @@\n-  _igvn.register_new_node_with_optimizer(l);\n-  set_loop(l, loop);\n-  loop->_head = l;\n+  igvn->register_new_node_with_optimizer(l);\n+  _phase->set_loop(l, _loop);\n+  _loop->_head = l;\n@@ -2275,2 +2312,2 @@\n-  lazy_replace( x, l );\n-  set_idom(l, entry_control, dom_depth(entry_control) + 1);\n+  _phase->lazy_replace(_head, l);\n+  _phase->set_idom(l, entry_control, _phase->dom_depth(entry_control) + 1);\n@@ -2278,1 +2315,1 @@\n-  if (iv_bt == T_INT && (LoopStripMiningIter == 0 || strip_mine_loop)) {\n+  if (_iv_bt == T_INT && (LoopStripMiningIter == 0 || strip_mine_loop)) {\n@@ -2280,1 +2317,1 @@\n-    if (sfpt != nullptr && (strip_mine_loop || is_deleteable_safept(sfpt))) {\n+    if (_sfpt != nullptr && (strip_mine_loop || _phase->is_deleteable_safept(_sfpt))) {\n@@ -2283,1 +2320,1 @@\n-        Node* sfpt_clone = sfpt->clone();\n+        Node* sfpt_clone = _sfpt->clone();\n@@ -2292,2 +2329,2 @@\n-          _igvn.register_new_node_with_optimizer(new_polladdr, polladdr);\n-          set_ctrl(new_polladdr, iffalse);\n+          igvn->register_new_node_with_optimizer(new_polladdr, polladdr);\n+          _phase->set_ctrl(new_polladdr, iffalse);\n@@ -2298,2 +2335,2 @@\n-        register_control(sfpt_clone, outer_ilt, iffalse, body_populated);\n-        set_idom(outer_le, sfpt_clone, dom_depth(sfpt_clone));\n+        _phase->register_control(sfpt_clone, outer_ilt, iffalse, body_populated);\n+        _phase->set_idom(outer_le, sfpt_clone, _phase->dom_depth(sfpt_clone));\n@@ -2301,3 +2338,3 @@\n-      lazy_replace(sfpt, sfpt->in(TypeFunc::Control));\n-      if (loop->_safepts != nullptr) {\n-        loop->_safepts->yank(sfpt);\n+      _phase->lazy_replace(_sfpt, _sfpt->in(TypeFunc::Control));\n+      if (_loop->_safepts != nullptr) {\n+        _loop->_safepts->yank(_sfpt);\n@@ -2309,2 +2346,2 @@\n-  assert(l->is_valid_counted_loop(iv_bt), \"counted loop shape is messed up\");\n-  assert(l == loop->_head && l->phi() == phi && l->loopexit_or_null() == lex, \"\" );\n+  assert(l->is_valid_counted_loop(_iv_bt), \"counted loop shape is messed up\");\n+  assert(l == _loop->_head && l->phi() == phi && l->loopexit_or_null() == lex, \"\" );\n@@ -2312,0 +2349,1 @@\n+\n@@ -2315,1 +2353,1 @@\n-    loop->dump_head();\n+    _loop->dump_head();\n@@ -2319,1 +2357,1 @@\n-  C->print_method(PHASE_AFTER_CLOOPS, 3, l);\n+  _phase->C->print_method(PHASE_AFTER_CLOOPS, 3, l);\n@@ -2324,1 +2362,1 @@\n-  l->phi()->as_Phi()->set_type(l->phi()->Value(&_igvn));\n+  l->phi()->as_Phi()->set_type(l->phi()->Value(igvn));\n@@ -2330,1 +2368,1 @@\n-    loop = outer_ilt;\n+    _loop = outer_ilt;\n@@ -2334,1 +2372,1 @@\n-  if (x->as_Loop()->is_loop_nest_inner_loop() && iv_bt == T_LONG) {\n+  if (_head->as_Loop()->is_loop_nest_inner_loop() && _iv_bt == T_LONG) {\n@@ -2338,1 +2376,2 @@\n-  if (iv_bt == T_LONG && x->as_Loop()->is_loop_nest_outer_loop()) {\n+\n+  if (_iv_bt == T_LONG && _head->as_Loop()->is_loop_nest_outer_loop()) {\n@@ -2342,1 +2381,1 @@\n-  return true;\n+  return _loop;\n@@ -2680,3 +2719,1 @@\n-Node* CountedLoopNode::match_incr_with_optional_truncation(Node* expr, Node** trunc1, Node** trunc2,\n-                                                           const TypeInteger** trunc_type,\n-                                                           BasicType bt) {\n+CountedLoopNode::TruncatedIncrement CountedLoopNode::match_incr_with_optional_truncation(Node* expr, BasicType bt) {\n@@ -2684,1 +2721,1 @@\n-  if (expr == nullptr || expr->req() != 3)  return nullptr;\n+  if (expr == nullptr || expr->req() != 3)  return TruncatedIncrement{};\n@@ -2725,4 +2762,1 @@\n-    *trunc1 = t1;\n-    *trunc2 = t2;\n-    *trunc_type = trunc_t;\n-    return n1;\n+    return TruncatedIncrement{n1, t1, t2, trunc_t};\n@@ -2732,1 +2766,1 @@\n-  return nullptr;\n+  return TruncatedIncrement{};\n@@ -3952,1 +3986,1 @@\n-bool PhaseIdealLoop::is_deleteable_safept(Node* sfpt) {\n+bool PhaseIdealLoop::is_deleteable_safept(Node* sfpt) const {\n@@ -4171,1 +4205,1 @@\n-      phase->is_counted_loop(_head, loop, T_INT)) {\n+      phase->try_convert_to_counted_loop(_head, loop, T_INT)) {\n@@ -4185,1 +4219,1 @@\n-             phase->is_counted_loop(_head, loop, T_LONG)) {\n+      phase->try_convert_to_counted_loop(_head, loop, T_LONG)) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":359,"deletions":325,"binary":false,"changes":684,"status":"modified"},{"patch":"@@ -261,3 +261,7 @@\n-  static Node*\n-  match_incr_with_optional_truncation(Node* expr, Node** trunc1, Node** trunc2, const TypeInteger** trunc_type,\n-                                      BasicType bt);\n+  struct TruncatedIncrement {\n+    Node* incr = nullptr;\n+    Node* trunc1 = nullptr;\n+    Node* trunc2 = nullptr;\n+    const TypeInteger* trunc_type = nullptr;\n+  };\n+  static TruncatedIncrement match_incr_with_optional_truncation(Node* expr, BasicType bt);\n@@ -1004,1 +1008,1 @@\n-  void insert_loop_limit_check_predicate(ParsePredicateSuccessProj* loop_limit_check_parse_proj, Node* cmp_limit,\n+  void insert_loop_limit_check_predicate(const ParsePredicateSuccessProj* loop_limit_check_parse_proj, Node* cmp_limit,\n@@ -1218,1 +1222,1 @@\n-  bool is_deleteable_safept(Node* sfpt);\n+  bool is_deleteable_safept(Node* sfpt) const;\n@@ -1269,5 +1273,24 @@\n-  Node* loop_exit_control(Node* x, IdealLoopTree* loop);\n-  Node* loop_exit_test(Node* back_control, IdealLoopTree* loop, Node*& incr, Node*& limit, BoolTest::mask& bt, float& cl_prob);\n-  Node* loop_iv_incr(Node* incr, Node* x, IdealLoopTree* loop, Node*& phi_incr);\n-  Node* loop_iv_stride(Node* incr, IdealLoopTree* loop, Node*& xphi);\n-  PhiNode* loop_iv_phi(Node* xphi, Node* phi_incr, Node* x, IdealLoopTree* loop);\n+  Node* loop_exit_control(const Node* head, const IdealLoopTree* loop) const;\n+\n+  struct LoopExitTest {\n+    Node* cmp = nullptr;\n+    Node* incr = nullptr;\n+    Node* limit = nullptr;\n+    const BoolTest::mask mask = BoolTest::illegal;\n+    const float cl_prob = 0.0f;\n+  };\n+  LoopExitTest loop_exit_test(const Node* back_control, const IdealLoopTree* loop);\n+\n+  struct LoopIVIncr {\n+    Node* incr = nullptr;\n+    Node* phi_incr = nullptr;\n+  };\n+  static LoopIVIncr loop_iv_incr(Node* old_incr, const Node* head, const IdealLoopTree* loop);\n+\n+  struct LoopIvStride {\n+    Node* stride = nullptr;\n+    Node* xphi = nullptr;\n+  };\n+  static LoopIvStride loop_iv_stride(const Node* incr);\n+\n+  static PhiNode* loop_iv_phi(const Node* xphi, const Node* phi_incr, const Node* head);\n@@ -1275,1 +1298,1 @@\n-  bool is_counted_loop(Node* x, IdealLoopTree*&loop, BasicType iv_bt);\n+  bool try_convert_to_counted_loop(Node* head, IdealLoopTree*&loop, const BasicType iv_bt);\n@@ -1279,3 +1302,1 @@\n-#ifdef ASSERT\n-  bool convert_to_long_loop(Node* cmp, Node* phi, IdealLoopTree* loop);\n-#endif\n+\n@@ -1283,1 +1304,1 @@\n-  SafePointNode* find_safepoint(Node* back_control, Node* x, IdealLoopTree* loop);\n+  SafePointNode* find_safepoint(Node* back_control, const Node* head, const IdealLoopTree* loop);\n@@ -1285,2 +1306,1 @@\n-  IdealLoopTree* create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,\n-                                               IdealLoopTree* loop, float cl_prob, float le_fcnt,\n+  IdealLoopTree* create_outer_strip_mined_loop(Node* init_control, IdealLoopTree* loop, float cl_prob, float le_fcnt,\n@@ -1289,0 +1309,49 @@\n+  class CountedLoopConverter {\n+    PhaseIdealLoop* _phase;\n+    Node* _head;\n+    IdealLoopTree* _loop;\n+    const BasicType _iv_bt;\n+\n+    bool _insert_stride_overflow_limit_check = false;\n+    bool _insert_init_trip_limit_check = false;\n+\n+#ifdef ASSERT\n+    bool _checked_for_counted_loop = false;\n+#endif\n+\n+    \/\/ To be assigned once a counted loop is confirmed.\n+    Node* _limit;\n+    jlong _stride_con;\n+    Node* _phi;\n+    Node* _phi_increment;\n+    Node* _stride;\n+    bool _includes_limit;\n+    BoolTest::mask _mask;\n+    Node* _increment;\n+    Node* _cmp;\n+    float _cl_prob;\n+    Node* _sfpt;\n+    jlong _final_correction;\n+    const TypeInteger* _increment_truncation_type;\n+\n+   public:\n+    CountedLoopConverter(PhaseIdealLoop* phase, Node* head, IdealLoopTree* loop, const BasicType iv_bt)\n+      : _phase(phase),\n+        _head(head),\n+        _loop(loop),\n+        _iv_bt(iv_bt) {\n+      assert(phase != nullptr, \"\");\n+      assert(head != nullptr, \"\");\n+      assert(loop != nullptr, \"\");\n+      assert(iv_bt == T_INT || iv_bt == T_LONG, \"\");\n+    }\n+\n+    bool is_counted_loop();\n+    IdealLoopTree* convert();\n+\n+#ifdef ASSERT\n+    bool should_stress_long_counted_loop() const;\n+    bool stress_long_counted_loop() const;\n+#endif\n+  };\n+\n@@ -1829,1 +1898,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":86,"deletions":18,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2844,4 +2844,3 @@\n-      Node* add = CountedLoopNode::match_incr_with_optional_truncation(in,\n-                                &trunc1, &trunc2, &ttype, T_INT);\n-      if (add && add->in(1) == phi) {\n-        add2 = add->in(2);\n+      CountedLoopNode::TruncatedIncrement add = CountedLoopNode::match_incr_with_optional_truncation(in, T_INT);\n+      if (add.incr != nullptr && add.incr->in(1) == phi) {\n+        add2 = add.incr->in(2);\n@@ -2854,4 +2853,3 @@\n-    Node* add = CountedLoopNode::match_incr_with_optional_truncation(addtrunc,\n-                                &trunc1, &trunc2, &ttype, T_INT);\n-    if (add && add->in(1)->is_Phi()) {\n-      Node* phi = add->in(1);\n+    CountedLoopNode::TruncatedIncrement add = CountedLoopNode::match_incr_with_optional_truncation(addtrunc, T_INT);\n+    if (add.incr != nullptr && add.incr->in(1)->is_Phi()) {\n+      Node* phi = add.incr->in(1);\n@@ -2860,1 +2858,1 @@\n-          add2 = add->in(2);\n+          add2 = add.incr->in(2);\n@@ -4264,6 +4262,2 @@\n-    BoolTest::mask bt = BoolTest::illegal;\n-    float cl_prob = 0;\n-    Node* incr = nullptr;\n-    Node* limit = nullptr;\n-    Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);\n-    if (cmp == nullptr || cmp->Opcode() != Op_CmpI) {\n+    LoopExitTest loop_exit = loop_exit_test(back_control, loop);\n+    if (loop_exit.cmp == nullptr || loop_exit.cmp->Opcode() != Op_CmpI) {\n@@ -4275,1 +4269,1 @@\n-    if (!incr->is_Phi() || incr->in(0) == head) {\n+    if (!loop_exit.incr->is_Phi() || loop_exit.incr->in(0) == head) {\n@@ -4280,1 +4274,1 @@\n-    region = incr->in(0);\n+    region = loop_exit.incr->in(0);\n@@ -4286,7 +4280,3 @@\n-    for (uint i = 1; i < incr->req(); ++i) {\n-      Node* in = incr->in(i);\n-      Node* trunc1 = nullptr;\n-      Node* trunc2 = nullptr;\n-      const TypeInteger* iv_trunc_t = nullptr;\n-      Node* orig_in = in;\n-      if (!(in = CountedLoopNode::match_incr_with_optional_truncation(in, &trunc1, &trunc2, &iv_trunc_t, T_INT))) {\n+    for (uint i = 1; i < loop_exit.incr->req(); ++i) {\n+      CountedLoopNode::TruncatedIncrement increment = CountedLoopNode::match_incr_with_optional_truncation(loop_exit.incr->in(i), T_INT);\n+      if (increment.incr == nullptr) {\n@@ -4295,3 +4285,2 @@\n-      assert(in->Opcode() == Op_AddI, \"wrong increment code\");\n-      Node* xphi = nullptr;\n-      Node* stride = loop_iv_stride(in, loop, xphi);\n+      assert(increment.incr->Opcode() == Op_AddI, \"wrong increment code\");\n+      LoopIvStride stride = loop_iv_stride(increment.incr);\n@@ -4299,1 +4288,1 @@\n-      if (stride == nullptr) {\n+      if (stride.stride == nullptr) {\n@@ -4303,1 +4292,1 @@\n-      PhiNode* phi = loop_iv_phi(xphi, nullptr, head, loop);\n+      PhiNode* phi = loop_iv_phi(stride.xphi, nullptr, head);\n@@ -4305,2 +4294,2 @@\n-          (trunc1 == nullptr && phi->in(LoopNode::LoopBackControl) != incr) ||\n-          (trunc1 != nullptr && phi->in(LoopNode::LoopBackControl) != trunc1)) {\n+          (increment.trunc1 == nullptr && phi->in(LoopNode::LoopBackControl) != loop_exit.incr) ||\n+          (increment.trunc1 != nullptr && phi->in(LoopNode::LoopBackControl) != increment.trunc1)) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":20,"deletions":31,"binary":false,"changes":51,"status":"modified"}]}