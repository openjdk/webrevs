{"files":[{"patch":"@@ -379,2 +379,3 @@\n-void PhaseIdealLoop::insert_loop_limit_check_predicate(ParsePredicateSuccessProj* loop_limit_check_parse_proj,\n-                                                       Node* cmp_limit, Node* bol) {\n+\n+void CountedLoopConverter::insert_loop_limit_check_predicate(const ParsePredicateSuccessProj* loop_limit_check_parse_proj,\n+                                                             Node* cmp_limit, Node* bol) const {\n@@ -382,3 +383,5 @@\n-  Node* new_predicate_proj = create_new_if_for_predicate(loop_limit_check_parse_proj, nullptr,\n-                                                         Deoptimization::Reason_loop_limit_check,\n-                                                         Op_If);\n+  Node* new_predicate_proj = _phase->create_new_if_for_predicate(loop_limit_check_parse_proj, nullptr,\n+                                                                 Deoptimization::Reason_loop_limit_check,\n+                                                                 Op_If);\n+\n+  PhaseIterGVN& igvn = _phase->igvn();\n@@ -386,4 +389,4 @@\n-  cmp_limit = _igvn.register_new_node_with_optimizer(cmp_limit);\n-  bol = _igvn.register_new_node_with_optimizer(bol);\n-  set_subtree_ctrl(bol, false);\n-  _igvn.replace_input_of(iff, 1, bol);\n+  cmp_limit = igvn.register_new_node_with_optimizer(cmp_limit);\n+  bol = igvn.register_new_node_with_optimizer(bol);\n+  _phase->set_subtree_ctrl(bol, false);\n+  igvn.replace_input_of(iff, 1, bol);\n@@ -401,1 +404,1 @@\n-Node* PhaseIdealLoop::loop_exit_control(Node* x, IdealLoopTree* loop) {\n+Node* PhaseIdealLoop::loop_exit_control(const Node* head, const IdealLoopTree* loop) const {\n@@ -404,1 +407,1 @@\n-  if (x->in(LoopNode::Self) == nullptr || x->req() != 3 || loop->_irreducible) {\n+  if (head->in(LoopNode::Self) == nullptr || head->req() != 3 || loop->_irreducible) {\n@@ -407,2 +410,2 @@\n-  Node *init_control = x->in(LoopNode::EntryControl);\n-  Node *back_control = x->in(LoopNode::LoopBackControl);\n+  Node* init_control = head->in(LoopNode::EntryControl);\n+  Node* back_control = head->in(LoopNode::LoopBackControl);\n@@ -441,71 +444,1 @@\n-Node* PhaseIdealLoop::loop_exit_test(Node* back_control, IdealLoopTree* loop, Node*& incr, Node*& limit, BoolTest::mask& bt, float& cl_prob) {\n-  Node* iftrue = back_control;\n-  uint iftrue_op = iftrue->Opcode();\n-  Node* iff = iftrue->in(0);\n-  BoolNode* test = iff->in(1)->as_Bool();\n-  bt = test->_test._test;\n-  cl_prob = iff->as_If()->_prob;\n-  if (iftrue_op == Op_IfFalse) {\n-    bt = BoolTest(bt).negate();\n-    cl_prob = 1.0 - cl_prob;\n-  }\n-  \/\/ Get backedge compare\n-  Node* cmp = test->in(1);\n-  if (!cmp->is_Cmp()) {\n-    return nullptr;\n-  }\n-\n-  \/\/ Find the trip-counter increment & limit.  Limit must be loop invariant.\n-  incr  = cmp->in(1);\n-  limit = cmp->in(2);\n-\n-  \/\/ ---------\n-  \/\/ need 'loop()' test to tell if limit is loop invariant\n-  \/\/ ---------\n-\n-  if (!is_member(loop, get_ctrl(incr))) { \/\/ Swapped trip counter and limit?\n-    Node* tmp = incr;            \/\/ Then reverse order into the CmpI\n-    incr = limit;\n-    limit = tmp;\n-    bt = BoolTest(bt).commute(); \/\/ And commute the exit test\n-  }\n-  if (is_member(loop, get_ctrl(limit))) { \/\/ Limit must be loop-invariant\n-    return nullptr;\n-  }\n-  if (!is_member(loop, get_ctrl(incr))) { \/\/ Trip counter must be loop-variant\n-    return nullptr;\n-  }\n-  return cmp;\n-}\n-\n-Node* PhaseIdealLoop::loop_iv_incr(Node* incr, Node* x, IdealLoopTree* loop, Node*& phi_incr) {\n-  if (incr->is_Phi()) {\n-    if (incr->as_Phi()->region() != x || incr->req() != 3) {\n-      return nullptr; \/\/ Not simple trip counter expression\n-    }\n-    phi_incr = incr;\n-    incr = phi_incr->in(LoopNode::LoopBackControl); \/\/ Assume incr is on backedge of Phi\n-    if (!is_member(loop, get_ctrl(incr))) { \/\/ Trip counter must be loop-variant\n-      return nullptr;\n-    }\n-  }\n-  return incr;\n-}\n-\n-Node* PhaseIdealLoop::loop_iv_stride(Node* incr, Node*& xphi) {\n-  assert(incr->Opcode() == Op_AddI || incr->Opcode() == Op_AddL, \"caller resp.\");\n-  \/\/ Get merge point\n-  xphi = incr->in(1);\n-  Node *stride = incr->in(2);\n-  if (!stride->is_Con()) {     \/\/ Oops, swap these\n-    if (!xphi->is_Con()) {     \/\/ Is the other guy a constant?\n-      return nullptr;          \/\/ Nope, unknown stride, bail out\n-    }\n-    Node *tmp = xphi;          \/\/ 'incr' is commutative, so ok to swap\n-    xphi = stride;\n-    stride = tmp;\n-  }\n-  return stride;\n-}\n-\n-PhiNode* PhaseIdealLoop::loop_iv_phi(Node* xphi, Node* phi_incr, Node* x) {\n+PhiNode* PhaseIdealLoop::loop_iv_phi(const Node* xphi, const Node* phi_incr, const Node* head) {\n@@ -521,1 +454,1 @@\n-  if (phi->region() != x) {\n+  if (phi->region() != head) {\n@@ -546,15 +479,0 @@\n-static bool condition_stride_ok(BoolTest::mask bt, jlong stride_con) {\n-  \/\/ If the condition is inverted and we will be rolling\n-  \/\/ through MININT to MAXINT, then bail out.\n-  if (bt == BoolTest::eq || \/\/ Bail out, but this loop trips at most twice!\n-      \/\/ Odd stride\n-      (bt == BoolTest::ne && stride_con != 1 && stride_con != -1) ||\n-      \/\/ Count down loop rolls through MAXINT\n-      ((bt == BoolTest::le || bt == BoolTest::lt) && stride_con < 0) ||\n-      \/\/ Count up loop rolls through MININT\n-      ((bt == BoolTest::ge || bt == BoolTest::gt) && stride_con > 0)) {\n-    return false; \/\/ Bail out\n-  }\n-  return true;\n-}\n-\n@@ -651,1 +569,1 @@\n-static bool no_side_effect_since_safepoint(Compile* C, Node* x, Node* mem, MergeMemNode* mm, PhaseIdealLoop* phase) {\n+static bool no_side_effect_since_safepoint(Compile* C, const Node* head, const Node* mem, MergeMemNode* mm, const PhaseIdealLoop* phase) {\n@@ -653,2 +571,2 @@\n-  for (DUIterator_Fast imax, i = x->fast_outs(imax); i < imax; i++) {\n-    Node* u = x->fast_out(i);\n+  for (DUIterator_Fast imax, i = head->fast_outs(imax); i < imax; i++) {\n+    Node* u = head->fast_out(i);\n@@ -704,1 +622,1 @@\n-SafePointNode* PhaseIdealLoop::find_safepoint(Node* back_control, Node* x, IdealLoopTree* loop) {\n+SafePointNode* PhaseIdealLoop::find_safepoint(Node* back_control, const Node* head, const IdealLoopTree* loop) {\n@@ -711,1 +629,1 @@\n-    while (c != x && c->Opcode() != Op_SafePoint) {\n+    while (c != head && c->Opcode() != Op_SafePoint) {\n@@ -750,1 +668,1 @@\n-    if (!no_side_effect_since_safepoint(C, x, mem, mm, this)) {\n+    if (!no_side_effect_since_safepoint(C, head, mem, mm, this)) {\n@@ -1723,4 +1641,7 @@\n-  BoolTest::mask mask = BoolTest::illegal;\n-  float cl_prob = 0;\n-  Node* incr = nullptr;\n-  Node* limit = nullptr;\n+  LoopExitTest exit_test(back_control, loop, this);\n+  exit_test.build();\n+  assert(exit_test.is_valid_with_bt(bt), \"no exit test\");\n+\n+  LoopIVIncr iv_incr(x, loop);\n+  iv_incr.build(exit_test.incr());\n+  assert(iv_incr.is_valid_with_bt(bt), \"no incr\");\n@@ -1728,2 +1649,3 @@\n-  Node* cmp = loop_exit_test(back_control, loop, incr, limit, mask, cl_prob);\n-  assert(cmp != nullptr && cmp->Opcode() == Op_Cmp(bt), \"no exit test\");\n+  LoopIVStride stride = LoopIVStride();\n+  stride.build(iv_incr.incr());\n+  assert(stride.is_valid(), \"no stride\");\n@@ -1731,3 +1653,2 @@\n-  Node* phi_incr = nullptr;\n-  incr = loop_iv_incr(incr, x, loop, phi_incr);\n-  assert(incr != nullptr && incr->Opcode() == Op_Add(bt), \"no incr\");\n+  PhiNode* phi = loop_iv_phi(stride.xphi(), iv_incr.phi_incr(), x);\n+  assert(phi != nullptr && phi->in(LoopNode::LoopBackControl) == iv_incr.incr(), \"No phi\");\n@@ -1735,2 +1656,1 @@\n-  Node* xphi = nullptr;\n-  Node* stride = loop_iv_stride(incr, xphi);\n+  assert(stride.compute_non_zero_stride_con(exit_test.mask(), bt), \"illegal condition\");\n@@ -1738,1 +1658,3 @@\n-  assert(stride != nullptr, \"no stride\");\n+  assert(exit_test.mask() != BoolTest::ne, \"unexpected condition\");\n+  assert(iv_incr.phi_incr() == nullptr, \"bad loop shape\");\n+  assert(exit_test.cmp()->in(1) == iv_incr.incr(), \"bad exit test shape\");\n@@ -1740,1 +1662,4 @@\n-  PhiNode* phi = loop_iv_phi(xphi, phi_incr, x);\n+  \/\/ Safepoint on backedge not supported\n+  assert(x->in(LoopNode::LoopBackControl)->Opcode() != Op_SafePoint, \"no safepoint on backedge\");\n+}\n+#endif\n@@ -1742,1 +1667,2 @@\n-  assert(phi != nullptr && phi->in(LoopNode::LoopBackControl) == incr, \"No phi\");\n+void PhaseIdealLoop::LoopExitTest::build() {\n+  _is_valid = false;\n@@ -1744,1 +1670,15 @@\n-  jlong stride_con = stride->get_integer_as_long(bt);\n+  const Node* iftrue = _back_control;\n+  uint iftrue_op = iftrue->Opcode();\n+  Node* iff = iftrue->in(0);\n+  BoolNode* test = iff->in(1)->as_Bool();\n+  _mask = test->_test._test;\n+  _cl_prob = iff->as_If()->_prob;\n+  if (iftrue_op == Op_IfFalse) {\n+    _mask = BoolTest(_mask).negate();\n+    _cl_prob = 1.0f - _cl_prob;\n+  }\n+  \/\/ Get backedge compare\n+  _cmp = test->in(1);\n+  if (!_cmp->is_Cmp()) {\n+    return;\n+  }\n@@ -1746,1 +1686,3 @@\n-  assert(condition_stride_ok(mask, stride_con), \"illegal condition\");\n+  \/\/ Find the trip-counter increment & limit.  Limit must be loop invariant.\n+  _incr  = _cmp->in(1);\n+  _limit = _cmp->in(2);\n@@ -1748,3 +1690,3 @@\n-  assert(mask != BoolTest::ne, \"unexpected condition\");\n-  assert(phi_incr == nullptr, \"bad loop shape\");\n-  assert(cmp->in(1) == incr, \"bad exit test shape\");\n+  \/\/ ---------\n+  \/\/ need 'loop()' test to tell if limit is loop invariant\n+  \/\/ ---------\n@@ -1752,2 +1694,190 @@\n-  \/\/ Safepoint on backedge not supported\n-  assert(x->in(LoopNode::LoopBackControl)->Opcode() != Op_SafePoint, \"no safepoint on backedge\");\n+  if (!_phase->is_member(_loop, _phase->get_ctrl(_incr))) { \/\/ Swapped trip counter and limit?\n+    swap(_incr, _limit);   \/\/ Then reverse order into the CmpI\n+    _mask = BoolTest(_mask).commute(); \/\/ And commute the exit test\n+  }\n+\n+  if (!_loop->is_invariant(_limit)) { \/\/ Limit must be loop-invariant\n+     return;\n+  }\n+  if (!_phase->is_member(_loop, _phase->get_ctrl(_incr))) { \/\/ Trip counter must be loop-variant\n+    return;\n+  }\n+\n+  _is_valid = true;\n+}\n+\n+\/\/ Canonicalize the loop condition if it is 'ne'.\n+void PhaseIdealLoop::LoopExitTest::canonicalize_mask(jlong stride_con) {\n+  if (_mask != BoolTest::ne) {\n+    return;\n+  }\n+\n+  assert(stride_con == 1 || stride_con == -1, \"simple increment only - checked in CountedLoopConverter\");\n+\n+  if (stride_con == 1) {\n+    \/\/ 'ne' can be replaced with 'lt' only when init < limit.\n+    \/\/ This is ensured by the inserted predicate in CountedLoopConverter\n+    _mask = BoolTest::lt;\n+  } else {\n+    \/\/ 'ne' can be replaced with 'gt' only when init > limit.\n+    \/\/ This is ensured by the inserted predicate in CountedLoopConverter.\n+    _mask = BoolTest::gt;\n+  }\n+}\n+\n+void PhaseIdealLoop::LoopIVIncr::build(Node* old_incr) {\n+  _is_valid = false;\n+\n+  Node* incr = old_incr;\n+  \/\/ Trip-counter increment must be commutative & associative.\n+  if (incr->is_Phi()) {\n+    if (incr->as_Phi()->region() != _head || incr->req() != 3) {\n+      return; \/\/ Not simple trip counter expression\n+    }\n+    Node* phi_incr = incr;\n+    Node* back_control = phi_incr->in(LoopNode::LoopBackControl); \/\/ Assume incr is on backedge of Phi\n+    if (_loop->_phase->is_member(_loop, _loop->_phase->get_ctrl(back_control))) { \/\/ Trip counter must be loop-variant\n+      _incr = back_control;\n+      _phi_incr = phi_incr;\n+      _is_valid = true;\n+      return;\n+    }\n+  }\n+  _incr = incr;\n+  _phi_incr = nullptr;\n+\n+  _is_valid = true;\n+}\n+\n+void PhaseIdealLoop::LoopIVStride::build(const Node* incr) {\n+  _is_valid = false;\n+\n+  assert(incr->Opcode() == Op_AddI || incr->Opcode() == Op_AddL, \"caller resp.\");\n+  \/\/ Get merge point\n+  _xphi = incr->in(1);\n+  _stride_node = incr->in(2);\n+  if (!_stride_node->is_Con()) {     \/\/ Oops, swap these\n+    if (!_xphi->is_Con()) {     \/\/ Is the other guy a constant?\n+      return;            \/\/ Nope, unknown stride, bail out\n+    }\n+\n+    swap(_xphi, _stride_node);        \/\/ 'incr' is commutative, so ok to swap\n+  }\n+\n+  _is_valid = true;\n+}\n+\n+jlong PhaseIdealLoop::LoopIVStride::compute_non_zero_stride_con(const BoolTest::mask mask, const BasicType iv_bt) const {\n+  jlong stride_con = stride_node()->get_integer_as_long(iv_bt);\n+  assert(stride_con != 0, \"missed some peephole opt\"); \/\/ stride constant can never be 0!\n+\n+  \/\/ If the condition is inverted and we will be rolling\n+  \/\/ through MININT to MAXINT, then bail out.\n+  if (mask == BoolTest::eq || \/\/ Bail out, but this loop trips at most twice!\n+      \/\/ Odd stride\n+      (mask == BoolTest::ne && stride_con != 1 && stride_con != -1) ||\n+      \/\/ Count down loop rolls through MAXINT\n+      ((mask == BoolTest::le || mask == BoolTest::lt) && stride_con < 0) ||\n+      \/\/ Count up loop rolls through MININT\n+      ((mask == BoolTest::ge || mask == BoolTest::gt) && stride_con > 0)) {\n+    return 0; \/\/ Bail out with sentinel = 0\n+  }\n+\n+  \/\/ Bail out if the stride is too big.\n+  if (stride_con == min_signed_integer(iv_bt) || (ABS(stride_con) > max_signed_integer(iv_bt) \/ 2)) {\n+    return 0; \/\/ Bail out with sentinel = 0\n+  }\n+\n+  return stride_con;\n+}\n+\n+void CountedLoopConverter::LoopStructure::build() {\n+  _is_valid = false;\n+\n+  if (_back_control == nullptr) {\n+    return;\n+  }\n+\n+  _exit_test.build();\n+  if (!_exit_test.is_valid_with_bt(_iv_bt)) {\n+    return; \/\/ Avoid pointer & float & 64-bit compares\n+  }\n+\n+  Node* incr = _exit_test.incr();\n+  if (_exit_test.incr()->Opcode() == Op_Cast(_iv_bt)) {\n+    incr = incr->in(1);\n+  }\n+\n+  _iv_incr.build(incr);\n+  if (!_iv_incr.is_valid()) {\n+    return;\n+  }\n+\n+  _truncated_increment.build(_iv_incr.incr());\n+  if (!_truncated_increment.is_valid()) {\n+    return; \/\/ Funny increment opcode\n+  }\n+  assert(_truncated_increment.incr()->Opcode() == Op_Add(_iv_bt), \"wrong increment code\");\n+\n+  _stride.build(_truncated_increment.incr());\n+  if (!_stride.is_valid()) {\n+    return;\n+  }\n+\n+  Node* xphi = _stride.xphi();\n+  \/\/ Iteratively uncast the loop induction variable\n+  \/\/ until no more CastII\/CastLL nodes are found.\n+  while (xphi->Opcode() == Op_Cast(_iv_bt)) {\n+    xphi = xphi->in(1);\n+  }\n+\n+  _phi = PhaseIdealLoop::loop_iv_phi(xphi, _iv_incr.phi_incr(), _head);\n+  if (_phi == nullptr ||\n+      (_truncated_increment.outer_trunc() == nullptr && _phi->in(LoopNode::LoopBackControl) != _truncated_increment.incr()) ||\n+      (_truncated_increment.outer_trunc() != nullptr && _phi->in(LoopNode::LoopBackControl) != _truncated_increment.outer_trunc())) {\n+    return;\n+  }\n+\n+  Node* sfpt = _back_control->in(0)->in(0);\n+  if (_loop->_child != nullptr && sfpt->Opcode() == Op_SafePoint) {\n+    _safepoint = sfpt->as_SafePoint();\n+  } else {\n+    _safepoint = _phase->find_safepoint(_back_control, _head, _loop);\n+  }\n+\n+  _is_valid = true;\n+}\n+\n+\/\/ We need to canonicalize the loop exit check by using different values for adjusted_limit:\n+\/\/ (LE1) iv_post_i < limit: Already canonicalized. We can directly use limit as adjusted_limit.\n+\/\/           -> adjusted_limit = limit.\n+\/\/ (LE2) iv_post_i <= limit:\n+\/\/           iv_post_i < limit + 1\n+\/\/           -> adjusted limit = limit + 1\n+\/\/ (LE3) iv_pre_i < limit:\n+\/\/           iv_pre_i + stride < limit + stride\n+\/\/           iv_post_i < limit + stride\n+\/\/           -> adjusted_limit = limit + stride\n+\/\/ (LE4) iv_pre_i <= limit:\n+\/\/           iv_pre_i < limit + 1\n+\/\/           iv_pre_i + stride < limit + stride + 1\n+\/\/           iv_post_i < limit + stride + 1\n+\/\/           -> adjusted_limit = limit + stride + 1\n+\/\/\n+\/\/ Note that:\n+\/\/     (AL) limit <= adjusted_limit.\n+jlong CountedLoopConverter::LoopStructure::final_limit_correction() const {\n+  const jlong stride_con = _stride.compute_non_zero_stride_con(_exit_test.mask(), _iv_bt);\n+\n+  \/\/ Accounting for (LE3) and (LE4) where we use pre-incremented phis in the loop exit check.\n+  const jlong limit_correction_for_pre_iv_exit_check = _iv_incr.phi_incr() != nullptr ? stride_con : 0;\n+\n+  \/\/ Accounting for (LE2) and (LE4) where we use <= or >= in the loop exit check.\n+  const jlong limit_correction_for_le_ge_exit_check = _exit_test.should_include_limit()\n+                                                        ? (stride_con > 0 ? 1 : -1)\n+                                                        : 0;\n+\n+  const jlong limit_correction = limit_correction_for_pre_iv_exit_check + limit_correction_for_le_ge_exit_check;\n+  const jlong canonicalized_correction = stride_con + (stride_con > 0 ? -1 : 1);\n+\n+  return canonicalized_correction + limit_correction; \/\/ final_correction\n@@ -1755,1 +1885,0 @@\n-#endif\n@@ -1758,3 +1887,14 @@\n-\/\/ convert an int counted loop to a long counted to stress handling of\n-\/\/ long counted loops\n-bool PhaseIdealLoop::convert_to_long_loop(Node* cmp, Node* phi, IdealLoopTree* loop) {\n+bool CountedLoopConverter::should_stress_long_counted_loop() {\n+  assert(_checked_for_counted_loop, \"must check for counted loop before stressing\");\n+\n+  return StressLongCountedLoop > 0 &&\n+      _iv_bt == T_INT &&\n+      !_head->as_Loop()->is_loop_nest_inner_loop() &&\n+      _structure.truncated_increment().trunc_type() == TypeInt::INT; \/\/ Only stress an int loop (i.e., not char, byte or short)\n+}\n+\n+\/\/ Convert an int counted loop to a long counted to stress handling of long counted loops. Returns true upon success.\n+bool CountedLoopConverter::stress_long_counted_loop() {\n+  assert(should_stress_long_counted_loop(), \"stress condition not satisfied\");\n+\n+  PhaseIterGVN* igvn = &_phase->igvn();\n@@ -1763,1 +1903,1 @@\n-  iv_nodes.push(cmp);\n+  iv_nodes.push(_structure.exit_test().cmp());\n@@ -1793,2 +1933,2 @@\n-    for (uint i = 1; i < n->req(); i++) {\n-      Node* in = n->in(i);\n+    for (uint j = 1; j < n->req(); j++) {\n+      Node* in = n->in(j);\n@@ -1798,1 +1938,1 @@\n-      if (loop->is_member(get_loop(get_ctrl(in)))) {\n+      if (_loop->is_member(_phase->get_loop(_phase->get_ctrl(in)))) {\n@@ -1809,1 +1949,1 @@\n-        _igvn.remove_dead_node(clone);\n+        igvn->remove_dead_node(clone);\n@@ -1818,2 +1958,2 @@\n-    for (uint i = 1; i < n->req(); i++) {\n-      Node* in = n->in(i);\n+    for (uint j = 1; j < n->req(); j++) {\n+      Node* in = n->in(j);\n@@ -1825,1 +1965,1 @@\n-        assert(_igvn.type(in)->isa_int(), \"\");\n+        assert(igvn->type(in)->isa_int(), \"\");\n@@ -1827,2 +1967,2 @@\n-        _igvn.register_new_node_with_optimizer(in_clone);\n-        set_subtree_ctrl(in_clone, false);\n+        igvn->register_new_node_with_optimizer(in_clone);\n+        _phase->set_subtree_ctrl(in_clone, false);\n@@ -1831,2 +1971,2 @@\n-        in_clone->set_req(0, C->top());\n-        clone->set_req(i, in_clone);\n+        in_clone->set_req(0, _phase->C->top());\n+        clone->set_req(j, in_clone);\n@@ -1835,1 +1975,1 @@\n-        clone->set_req(i, in_clone);\n+        clone->set_req(j, in_clone);\n@@ -1838,1 +1978,1 @@\n-    _igvn.register_new_node_with_optimizer(clone);\n+    igvn->register_new_node_with_optimizer(clone);\n@@ -1840,1 +1980,1 @@\n-  set_ctrl(old_new[phi->_idx], phi->in(0));\n+  _phase->set_ctrl(old_new[_structure.phi()->_idx], _structure.phi()->in(0));\n@@ -1845,1 +1985,1 @@\n-    set_subtree_ctrl(clone, false);\n+    _phase->set_subtree_ctrl(clone, false);\n@@ -1847,2 +1987,2 @@\n-    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-      Node* u = n->fast_out(i);\n+    for (DUIterator_Fast imax, j = n->fast_outs(imax); j < imax; j++) {\n+      Node* u = n->fast_out(j);\n@@ -1854,2 +1994,2 @@\n-        _igvn.register_new_node_with_optimizer(m);\n-        set_subtree_ctrl(m, false);\n+        igvn->register_new_node_with_optimizer(m);\n+        _phase->set_subtree_ctrl(m, false);\n@@ -1857,3 +1997,3 @@\n-      _igvn.rehash_node_delayed(u);\n-      int nb = u->replace_edge(n, m, &_igvn);\n-      --i, imax -= nb;\n+      igvn->rehash_node_delayed(u);\n+      int nb = u->replace_edge(n, m, igvn);\n+      --j, imax -= nb;\n@@ -1866,3 +2006,9 @@\n-\/\/------------------------------is_counted_loop--------------------------------\n-bool PhaseIdealLoop::is_counted_loop(Node* x, IdealLoopTree*&loop, BasicType iv_bt) {\n-  PhaseGVN *gvn = &_igvn;\n+bool PhaseIdealLoop::try_convert_to_counted_loop(Node* head, IdealLoopTree*& loop, const BasicType iv_bt) {\n+  CountedLoopConverter converter(this, head, loop, iv_bt);\n+  if (converter.is_counted_loop()) {\n+#ifdef ASSERT\n+    \/\/ Stress by converting int counted loops to long counted loops\n+    if (converter.should_stress_long_counted_loop() && converter.stress_long_counted_loop()) {\n+      return false;\n+    }\n+#endif\n@@ -1870,3 +2016,2 @@\n-  Node* back_control = loop_exit_control(x, loop);\n-  if (back_control == nullptr) {\n-    return false;\n+    loop = converter.convert();\n+    return true;\n@@ -1875,8 +2020,2 @@\n-  BoolTest::mask bt = BoolTest::illegal;\n-  float cl_prob = 0;\n-  Node* incr = nullptr;\n-  Node* limit = nullptr;\n-  Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);\n-  if (cmp == nullptr || cmp->Opcode() != Op_Cmp(iv_bt)) {\n-    return false; \/\/ Avoid pointer & float & 64-bit compares\n-  }\n+  return false;\n+}\n@@ -1884,4 +2023,2 @@\n-  \/\/ Trip-counter increment must be commutative & associative.\n-  if (incr->Opcode() == Op_Cast(iv_bt)) {\n-    incr = incr->in(1);\n-  }\n+bool CountedLoopConverter::is_counted_loop() {\n+  PhaseIterGVN* igvn = &_phase->igvn();\n@@ -1889,3 +2026,2 @@\n-  Node* phi_incr = nullptr;\n-  incr = loop_iv_incr(incr, x, loop, phi_incr);\n-  if (incr == nullptr) {\n+  _structure.build();\n+  if (!_structure.is_valid()) {\n@@ -1895,11 +2031,2 @@\n-  Node* trunc1 = nullptr;\n-  Node* trunc2 = nullptr;\n-  const TypeInteger* iv_trunc_t = nullptr;\n-  Node* orig_incr = incr;\n-  if (!(incr = CountedLoopNode::match_incr_with_optional_truncation(incr, &trunc1, &trunc2, &iv_trunc_t, iv_bt))) {\n-    return false; \/\/ Funny increment opcode\n-  }\n-  assert(incr->Opcode() == Op_Add(iv_bt), \"wrong increment code\");\n-\n-  Node* xphi = nullptr;\n-  Node* stride = loop_iv_stride(incr, xphi);\n+  \/\/ =================================================\n+  \/\/ ---- Is the loop trip counted? ----\n@@ -1907,1 +2034,3 @@\n-  if (stride == nullptr) {\n+  \/\/ Check trip counter will end up higher than the limit\n+  const TypeInteger* limit_t = igvn->type(_structure.limit())->is_integer(_iv_bt);\n+  if (_structure.is_infinite_loop(limit_t)) {\n@@ -1911,6 +2040,0 @@\n-  \/\/ Iteratively uncast the loop induction variable\n-  \/\/ until no more CastII\/CastLL nodes are found.\n-  while (xphi->Opcode() == Op_Cast(iv_bt)) {\n-    xphi = xphi->in(1);\n-  }\n-\n@@ -1918,8 +2041,2 @@\n-  jlong stride_con = stride->get_integer_as_long(iv_bt);\n-  assert(stride_con != 0, \"missed some peephole opt\");\n-\n-  PhiNode* phi = loop_iv_phi(xphi, phi_incr, x);\n-\n-  if (phi == nullptr ||\n-      (trunc1 == nullptr && phi->in(LoopNode::LoopBackControl) != incr) ||\n-      (trunc1 != nullptr && phi->in(LoopNode::LoopBackControl) != trunc1)) {\n+  const jlong stride_con = _structure.stride_con();\n+  if (stride_con == 0) {\n@@ -1929,69 +2046,2 @@\n-  Node* iftrue = back_control;\n-  uint iftrue_op = iftrue->Opcode();\n-  Node* iff = iftrue->in(0);\n-  BoolNode* test = iff->in(1)->as_Bool();\n-\n-  const TypeInteger* limit_t = gvn->type(limit)->is_integer(iv_bt);\n-  if (trunc1 != nullptr) {\n-    \/\/ When there is a truncation, we must be sure that after the truncation\n-    \/\/ the trip counter will end up higher than the limit, otherwise we are looking\n-    \/\/ at an endless loop. Can happen with range checks.\n-\n-    \/\/ Example:\n-    \/\/ int i = 0;\n-    \/\/ while (true)\n-    \/\/    sum + = array[i];\n-    \/\/    i++;\n-    \/\/    i = i && 0x7fff;\n-    \/\/  }\n-    \/\/\n-    \/\/ If the array is shorter than 0x8000 this exits through a AIOOB\n-    \/\/  - Counted loop transformation is ok\n-    \/\/ If the array is longer then this is an endless loop\n-    \/\/  - No transformation can be done.\n-\n-    const TypeInteger* incr_t = gvn->type(orig_incr)->is_integer(iv_bt);\n-    if (limit_t->hi_as_long() > incr_t->hi_as_long()) {\n-      \/\/ if the limit can have a higher value than the increment (before the phi)\n-      return false;\n-    }\n-  }\n-\n-  Node *init_trip = phi->in(LoopNode::EntryControl);\n-\n-  \/\/ If iv trunc type is smaller than int, check for possible wrap.\n-  if (!TypeInteger::bottom(iv_bt)->higher_equal(iv_trunc_t)) {\n-    assert(trunc1 != nullptr, \"must have found some truncation\");\n-\n-    \/\/ Get a better type for the phi (filtered thru if's)\n-    const TypeInteger* phi_ft = filtered_type(phi);\n-\n-    \/\/ Can iv take on a value that will wrap?\n-    \/\/\n-    \/\/ Ensure iv's limit is not within \"stride\" of the wrap value.\n-    \/\/\n-    \/\/ Example for \"short\" type\n-    \/\/    Truncation ensures value is in the range -32768..32767 (iv_trunc_t)\n-    \/\/    If the stride is +10, then the last value of the induction\n-    \/\/    variable before the increment (phi_ft->_hi) must be\n-    \/\/    <= 32767 - 10 and (phi_ft->_lo) must be >= -32768 to\n-    \/\/    ensure no truncation occurs after the increment.\n-\n-    if (stride_con > 0) {\n-      if (iv_trunc_t->hi_as_long() - phi_ft->hi_as_long() < stride_con ||\n-          iv_trunc_t->lo_as_long() > phi_ft->lo_as_long()) {\n-        return false;  \/\/ truncation may occur\n-      }\n-    } else if (stride_con < 0) {\n-      if (iv_trunc_t->lo_as_long() - phi_ft->lo_as_long() > stride_con ||\n-          iv_trunc_t->hi_as_long() < phi_ft->hi_as_long()) {\n-        return false;  \/\/ truncation may occur\n-      }\n-    }\n-    \/\/ No possibility of wrap so truncation can be discarded\n-    \/\/ Promote iv type to Int\n-  } else {\n-    assert(trunc1 == nullptr && trunc2 == nullptr, \"no truncation for int\");\n-  }\n-\n-  if (!condition_stride_ok(bt, stride_con)) {\n+  \/\/ Check iv type can be promoted to int for short\/char\/byte loops\n+  if (has_truncation_wrap(_structure.truncated_increment(), _structure.phi(), stride_con)) {\n@@ -2001,23 +2051,5 @@\n-  const TypeInteger* init_t = gvn->type(init_trip)->is_integer(iv_bt);\n-\n-  if (stride_con > 0) {\n-    if (init_t->lo_as_long() > max_signed_integer(iv_bt) - stride_con) {\n-      return false; \/\/ cyclic loop\n-    }\n-  } else {\n-    if (init_t->hi_as_long() < min_signed_integer(iv_bt) - stride_con) {\n-      return false; \/\/ cyclic loop\n-    }\n-  }\n-\n-  if (phi_incr != nullptr && bt != BoolTest::ne) {\n-    \/\/ check if there is a possibility of IV overflowing after the first increment\n-    if (stride_con > 0) {\n-      if (init_t->hi_as_long() > max_signed_integer(iv_bt) - stride_con) {\n-        return false;\n-      }\n-    } else {\n-      if (init_t->lo_as_long() < min_signed_integer(iv_bt) - stride_con) {\n-        return false;\n-      }\n-    }\n+  \/\/ Check iv is not overflowing\n+  Node* init_trip = _structure.phi()->in(LoopNode::EntryControl);\n+  const TypeInteger* init_t = igvn->type(init_trip)->is_integer(_iv_bt);\n+  if (is_iv_overflowing(init_t, stride_con, _structure.iv_incr().phi_incr(), _structure.exit_test().mask())) {\n+    return false;\n@@ -2028,1 +2060,0 @@\n-  \/\/\n@@ -2030,2 +2061,2 @@\n-  if (x->Opcode() == Op_Region) {\n-    \/\/ x has not yet been transformed to Loop or LongCountedLoop.\n+  if (_head->Opcode() == Op_Region) {\n+    \/\/ head has not yet been transformed to Loop or LongCountedLoop.\n@@ -2038,2 +2069,2 @@\n-    assert(x->as_Region()->is_in_infinite_subgraph(),\n-           \"x can only be a Region and not Loop if inside infinite loop\");\n+    assert(_head->as_Region()->is_in_infinite_subgraph(),\n+           \"head can only be a Region and not Loop if inside infinite loop\");\n@@ -2044,2 +2075,2 @@\n-  assert(x->Opcode() == Op_Loop || x->Opcode() == Op_LongCountedLoop, \"regular loops only\");\n-  C->print_method(PHASE_BEFORE_CLOOPS, 3, x);\n+  assert(_head->Opcode() == Op_Loop || _head->Opcode() == Op_LongCountedLoop, \"regular loops only\");\n+  _phase->C->print_method(PHASE_BEFORE_CLOOPS, 3, _head);\n@@ -2098,15 +2129,2 @@\n-  \/\/ If that is not the case, we need to canonicalize the loop exit check by using different values for adjusted_limit:\n-  \/\/ (LE1) iv_post_i < limit: Already canonicalized. We can directly use limit as adjusted_limit.\n-  \/\/           -> adjusted_limit = limit.\n-  \/\/ (LE2) iv_post_i <= limit:\n-  \/\/           iv_post_i < limit + 1\n-  \/\/           -> adjusted limit = limit + 1\n-  \/\/ (LE3) iv_pre_i < limit:\n-  \/\/           iv_pre_i + stride < limit + stride\n-  \/\/           iv_post_i < limit + stride\n-  \/\/           -> adjusted_limit = limit + stride\n-  \/\/ (LE4) iv_pre_i <= limit:\n-  \/\/           iv_pre_i < limit + 1\n-  \/\/           iv_pre_i + stride < limit + stride + 1\n-  \/\/           iv_post_i < limit + stride + 1\n-  \/\/           -> adjusted_limit = limit + stride + 1\n+  \/\/ If that is not the case, we need to canonicalize the loop exit check by using different values for adjusted_limit\n+  \/\/ (see LoopStructure::final_limit_correction()).\n@@ -2114,1 +2132,1 @@\n-  \/\/ Note that:\n+  \/\/ Note that after canonicalization:\n@@ -2234,4 +2252,1 @@\n-  \/\/ Check (vi) and bail out if the stride is too big.\n-  if (stride_con == min_signed_integer(iv_bt) || (ABS(stride_con) > max_signed_integer(iv_bt) \/ 2)) {\n-    return false;\n-  }\n+  int sov = check_stride_overflow(_structure.final_limit_correction(), limit_t, _iv_bt);\n@@ -2239,2 +2254,3 @@\n-  \/\/ Accounting for (LE3) and (LE4) where we use pre-incremented phis in the loop exit check.\n-  const jlong limit_correction_for_pre_iv_exit_check = (phi_incr != nullptr) ? stride_con : 0;\n+  Node* init_control = _head->in(LoopNode::EntryControl);\n+  const Predicates predicates(init_control);\n+  const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n@@ -2242,10 +2258,3 @@\n-  \/\/ Accounting for (LE2) and (LE4) where we use <= or >= in the loop exit check.\n-  const bool includes_limit = (bt == BoolTest::le || bt == BoolTest::ge);\n-  const jlong limit_correction_for_le_ge_exit_check = (includes_limit ? (stride_con > 0 ? 1 : -1) : 0);\n-\n-  const jlong limit_correction = limit_correction_for_pre_iv_exit_check + limit_correction_for_le_ge_exit_check;\n-  const jlong canonicalized_correction = stride_con + (stride_con > 0 ? -1 : 1);\n-  const jlong final_correction = canonicalized_correction + limit_correction;\n-\n-  int sov = check_stride_overflow(final_correction, limit_t, iv_bt);\n-  Node* init_control = x->in(LoopNode::EntryControl);\n+  if (sov < 0) {\n+    return false; \/\/ Bailout: integer overflow is certain.\n+  }\n@@ -2253,1 +2262,1 @@\n-  \/\/ If sov==0, limit's type always satisfies the condition, for\n+  \/\/ If sov == 0, limit's type always satisfies the condition, for\n@@ -2255,4 +2264,3 @@\n-  if (sov != 0) {\n-    if (sov < 0) {\n-      return false;  \/\/ Bailout: integer overflow is certain.\n-    }\n+\n+  _insert_stride_overflow_limit_check = false;\n+  if (sov > 0) {\n@@ -2261,3 +2269,1 @@\n-    assert(!x->as_Loop()->is_loop_nest_inner_loop(), \"loop was transformed\");\n-    const Predicates predicates(init_control);\n-    const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n+    assert(!_head->as_Loop()->is_loop_nest_inner_loop(), \"loop was transformed\");\n@@ -2269,2 +2275,2 @@\n-        loop->dump_head();\n-        x->dump(1);\n+        _loop->dump_head();\n+        _head->dump(1);\n@@ -2277,1 +2283,1 @@\n-    if (!is_dominator(get_ctrl(limit), loop_limit_check_parse_predicate->in(0))) {\n+    if (!_phase->is_dominator(_phase->get_ctrl(_structure.limit()), loop_limit_check_parse_predicate->in(0))) {\n@@ -2281,12 +2287,1 @@\n-    Node* cmp_limit;\n-    Node* bol;\n-\n-    if (stride_con > 0) {\n-      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_signed_integer(iv_bt) - final_correction, iv_bt), iv_bt);\n-      bol = new BoolNode(cmp_limit, BoolTest::le);\n-    } else {\n-      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_signed_integer(iv_bt) - final_correction, iv_bt), iv_bt);\n-      bol = new BoolNode(cmp_limit, BoolTest::ge);\n-    }\n-\n-    insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n+    _insert_stride_overflow_limit_check = true;\n@@ -2297,2 +2292,3 @@\n-          (stride_con > 0 && init_t->hi_as_long() > max_signed_integer(iv_bt) - stride_con) ||\n-          (stride_con < 0 && init_t->lo_as_long() < min_signed_integer(iv_bt) - stride_con);\n+      (stride_con > 0 && init_t->hi_as_long() > max_signed_integer(_iv_bt) - stride_con) ||\n+      (stride_con < 0 && init_t->lo_as_long() < min_signed_integer(_iv_bt) - stride_con);\n+\n@@ -2300,2 +2296,3 @@\n-  const bool init_gte_limit = (stride_con > 0 && init_t->hi_as_long() >= limit_t->lo_as_long()) ||\n-                              (stride_con < 0 && init_t->lo_as_long() <= limit_t->hi_as_long());\n+  const bool init_gte_limit =\n+      (stride_con > 0 && init_t->hi_as_long() >= limit_t->lo_as_long()) ||\n+      (stride_con < 0 && init_t->lo_as_long() <= limit_t->hi_as_long());\n@@ -2303,0 +2300,1 @@\n+  _insert_init_trip_limit_check = false;\n@@ -2304,2 +2302,6 @@\n-     ((bt == BoolTest::ne || init_plus_stride_could_overflow) && \/\/ (2.3)\n-      !has_dominating_loop_limit_check(init_trip, limit, stride_con, iv_bt, init_control))) { \/\/ (2.2)\n+      ((_structure.exit_test().mask() == BoolTest::ne || init_plus_stride_could_overflow) && \/\/ (2.3)\n+          !has_dominating_loop_limit_check(init_trip,\n+                                           _structure.limit(),\n+                                           stride_con,\n+                                           _iv_bt,\n+                                           init_control))) { \/\/ (2.2)\n@@ -2315,2 +2317,0 @@\n-    const Predicates predicates(init_control);\n-    const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n@@ -2322,2 +2322,2 @@\n-        loop->dump_head();\n-        x->dump(1);\n+        _loop->dump_head();\n+        _head->dump(1);\n@@ -2331,2 +2331,2 @@\n-    if (!is_dominator(get_ctrl(limit), parse_predicate_entry) ||\n-        !is_dominator(get_ctrl(init_trip), parse_predicate_entry)) {\n+    if (!_phase->is_dominator(_phase->get_ctrl(_structure.limit()), parse_predicate_entry) ||\n+        !_phase->is_dominator(_phase->get_ctrl(init_trip), parse_predicate_entry)) {\n@@ -2336,2 +2336,27 @@\n-    Node* cmp_limit;\n-    Node* bol;\n+    _insert_init_trip_limit_check = true;\n+  }\n+\n+  _structure.exit_test().canonicalize_mask(stride_con);\n+\n+  if (is_safepoint_invalid(_structure.sfpt())) {\n+    return false;\n+  }\n+\n+#ifdef ASSERT\n+  _checked_for_counted_loop = true;\n+#endif\n+\n+  return true;\n+}\n+\n+bool CountedLoopConverter::is_iv_overflowing(const TypeInteger* init_t, jlong stride_con, Node* phi_increment,\n+                                             BoolTest::mask mask) const {\n+  if (stride_con > 0) {\n+    if (init_t->lo_as_long() > max_signed_integer(_iv_bt) - stride_con) {\n+      return true; \/\/ cyclic loop\n+    }\n+  } else {\n+    if (init_t->hi_as_long() < min_signed_integer(_iv_bt) - stride_con) {\n+      return true; \/\/ cyclic loop\n+    }\n+  }\n@@ -2339,0 +2364,2 @@\n+  if (phi_increment != nullptr && mask != BoolTest::ne) {\n+    \/\/ check if there is a possibility of IV overflowing after the first increment\n@@ -2340,2 +2367,3 @@\n-      cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n-      bol = new BoolNode(cmp_limit, BoolTest::lt);\n+      if (init_t->hi_as_long() > max_signed_integer(_iv_bt) - stride_con) {\n+        return true;\n+      }\n@@ -2343,2 +2371,3 @@\n-      cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n-      bol = new BoolNode(cmp_limit, BoolTest::gt);\n+      if (init_t->lo_as_long() < min_signed_integer(_iv_bt) - stride_con) {\n+        return true;\n+      }\n@@ -2346,0 +2375,1 @@\n+  }\n@@ -2347,1 +2377,29 @@\n-    insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n+  return false;\n+}\n+\n+bool CountedLoopConverter::LoopStructure::is_infinite_loop(const TypeInteger* limit_t) const {\n+  PhaseIterGVN& igvn = _phase->igvn();\n+\n+  if (_truncated_increment.outer_trunc() != nullptr) {\n+    \/\/ When there is a truncation, we must be sure that after the truncation\n+    \/\/ the trip counter will end up higher than the limit, otherwise we are looking\n+    \/\/ at an endless loop. Can happen with range checks.\n+\n+    \/\/ Example:\n+    \/\/ int i = 0;\n+    \/\/ while (true)\n+    \/\/    sum + = array[i];\n+    \/\/    i++;\n+    \/\/    i = i && 0x7fff;\n+    \/\/  }\n+    \/\/\n+    \/\/ If the array is shorter than 0x8000 this exits through an AIOOB\n+    \/\/  - Counted loop transformation is ok\n+    \/\/ If the array is longer then this is an endless loop\n+    \/\/  - No transformation can be done.\n+\n+    const TypeInteger* incr_t = igvn.type(_iv_incr.incr())->is_integer(_iv_bt);\n+    if (limit_t->hi_as_long() > incr_t->hi_as_long()) {\n+      \/\/ if the limit can have a higher value than the increment (before the phi)\n+      return true;\n+    }\n@@ -2350,3 +2408,23 @@\n-  if (bt == BoolTest::ne) {\n-    \/\/ Now we need to canonicalize the loop condition if it is 'ne'.\n-    assert(stride_con == 1 || stride_con == -1, \"simple increment only - checked before\");\n+  return false;\n+}\n+\n+bool CountedLoopConverter::has_truncation_wrap(TruncatedIncrement truncation, Node* phi,\n+                                               jlong stride_con) {\n+  \/\/ If iv trunc type is smaller than int (i.e., short\/char\/byte), check for possible wrap.\n+  if (!TypeInteger::bottom(_iv_bt)->higher_equal(truncation.trunc_type())) {\n+    assert(truncation.outer_trunc() != nullptr, \"must have found some truncation\");\n+\n+    \/\/ Get a better type for the phi (filtered thru if's)\n+    const TypeInteger* phi_ft = filtered_type(phi);\n+\n+    \/\/ Can iv take on a value that will wrap?\n+    \/\/\n+    \/\/ Ensure iv's limit is not within \"stride\" of the wrap value.\n+    \/\/\n+    \/\/ Example for \"short\" type\n+    \/\/    Truncation ensures value is in the range -32768..32767 (iv_trunc_t)\n+    \/\/    If the stride is +10, then the last value of the induction\n+    \/\/    variable before the increment (phi_ft->_hi) must be\n+    \/\/    <= 32767 - 10 and (phi_ft->_lo) must be >= -32768 to\n+    \/\/    ensure no truncation occurs after the increment.\n+\n@@ -2354,6 +2432,9 @@\n-      \/\/ 'ne' can be replaced with 'lt' only when init < limit. This is ensured by the inserted predicate above.\n-      bt = BoolTest::lt;\n-    } else {\n-      assert(stride_con < 0, \"must be\");\n-      \/\/ 'ne' can be replaced with 'gt' only when init > limit. This is ensured by the inserted predicate above.\n-      bt = BoolTest::gt;\n+      if (truncation.trunc_type()->hi_as_long() - phi_ft->hi_as_long() < stride_con ||\n+          truncation.trunc_type()->lo_as_long() > phi_ft->lo_as_long()) {\n+        return true;  \/\/ truncation may occur\n+      }\n+    } else if (stride_con < 0) {\n+      if (truncation.trunc_type()->lo_as_long() - phi_ft->lo_as_long() > stride_con ||\n+          truncation.trunc_type()->hi_as_long() < phi_ft->hi_as_long()) {\n+        return true;  \/\/ truncation may occur\n+      }\n@@ -2361,1 +2442,0 @@\n-  }\n@@ -2363,3 +2443,2 @@\n-  Node* sfpt = nullptr;\n-  if (loop->_child == nullptr) {\n-    sfpt = find_safepoint(back_control, x, loop);\n+    \/\/ No possibility of wrap so truncation can be discarded\n+    \/\/ Promote iv type to Int\n@@ -2367,4 +2446,18 @@\n-    sfpt = iff->in(0);\n-    if (sfpt->Opcode() != Op_SafePoint) {\n-      sfpt = nullptr;\n-    }\n+    assert(Type::equals(truncation.trunc_type(), TypeInt::INT) || Type::equals(truncation.trunc_type(), TypeLong::LONG),\n+           \"unexpected truncation type\");\n+    assert(truncation.outer_trunc() == nullptr && truncation.inner_trunc() == nullptr, \"no truncation for int\");\n+  }\n+\n+  return false;\n+}\n+\n+SafePointNode* CountedLoopConverter::find_safepoint(Node* iftrue) {\n+  Node* iff = iftrue->in(0);\n+\n+  if (_loop->_child == nullptr) {\n+    return _phase->find_safepoint(iftrue, _head, _loop);\n+  }\n+\n+  Node* sfpt = iff->in(0);\n+  if (sfpt->Opcode() == Op_SafePoint) {\n+    return sfpt->as_SafePoint();\n@@ -2372,0 +2465,2 @@\n+  return nullptr;\n+}\n@@ -2373,4 +2468,4 @@\n-  if (x->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n-    Node* backedge_sfpt = x->in(LoopNode::LoopBackControl);\n-    if (((iv_bt == T_INT && LoopStripMiningIter != 0) ||\n-         iv_bt == T_LONG) &&\n+bool CountedLoopConverter::is_safepoint_invalid(SafePointNode* sfpt) const {\n+  if (_head->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n+    if (((_iv_bt == T_INT && LoopStripMiningIter != 0) ||\n+        _iv_bt == T_LONG) &&\n@@ -2382,8 +2477,1 @@\n-      return false;\n-    }\n-    if (is_deleteable_safept(backedge_sfpt)) {\n-      replace_node_and_forward_ctrl(backedge_sfpt, iftrue);\n-      if (loop->_safepts != nullptr) {\n-        loop->_safepts->yank(backedge_sfpt);\n-      }\n-      loop->_tail = iftrue;\n+      return true;\n@@ -2393,0 +2481,2 @@\n+  return false;\n+}\n@@ -2394,0 +2484,1 @@\n+IdealLoopTree* CountedLoopConverter::convert() {\n@@ -2395,7 +2486,1 @@\n-  if (iv_bt == T_INT &&\n-      !x->as_Loop()->is_loop_nest_inner_loop() &&\n-      StressLongCountedLoop > 0 &&\n-      trunc1 == nullptr &&\n-      convert_to_long_loop(cmp, phi, loop)) {\n-    return false;\n-  }\n+  assert(_checked_for_counted_loop, \"must check for counted loop before conversion\");\n@@ -2404,2 +2489,35 @@\n-  Node* adjusted_limit = limit;\n-  if (phi_incr != nullptr) {\n+  PhaseIterGVN* igvn = &_phase->igvn();\n+  Node* init_control = _head->in(LoopNode::EntryControl);\n+  const jlong stride_con = _structure.stride_con();\n+\n+  if (_insert_stride_overflow_limit_check) {\n+    jlong adjusted_stride_con = (stride_con > 0\n+                               ? max_signed_integer(_iv_bt)\n+                               : min_signed_integer(_iv_bt)) - _structure.final_limit_correction();\n+\n+    Node* cmp_limit = CmpNode::make(_structure.limit(), igvn->integercon(adjusted_stride_con, _iv_bt), _iv_bt);\n+    Node* bol = new BoolNode(cmp_limit, stride_con > 0 ? BoolTest::le : BoolTest::ge);\n+    insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n+  }\n+\n+  Node* init_trip = _structure.phi()->in(LoopNode::EntryControl);\n+  if (_insert_init_trip_limit_check) {\n+    Node* cmp_limit = CmpNode::make(init_trip, _structure.limit(), _iv_bt);\n+    Node* bol = new BoolNode(cmp_limit, stride_con > 0 ? BoolTest::lt : BoolTest::gt);\n+    insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n+  }\n+\n+  Node* back_control = _phase->loop_exit_control(_head, _loop);\n+  if (_head->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n+    Node* backedge_sfpt = _head->in(LoopNode::LoopBackControl);\n+    if (_phase->is_deleteable_safept(backedge_sfpt)) {\n+      _phase->replace_node_and_forward_ctrl(backedge_sfpt, back_control);\n+      if (_loop->_safepts != nullptr) {\n+        _loop->_safepts->yank(backedge_sfpt);\n+      }\n+      _loop->_tail = back_control;\n+    }\n+  }\n+\n+  Node* adjusted_limit = _structure.limit();\n+  if (_structure.iv_incr().phi_incr() != nullptr) {\n@@ -2415,1 +2533,1 @@\n-    adjusted_limit = gvn->transform(AddNode::make(limit, stride, iv_bt));\n+    adjusted_limit = igvn->transform(AddNode::make(_structure.limit(), _structure.stride().stride_node(), _iv_bt));\n@@ -2418,1 +2536,2 @@\n-  if (includes_limit) {\n+  BoolTest::mask mask = _structure.exit_test().mask();\n+  if (_structure.exit_test().should_include_limit()) {\n@@ -2422,6 +2541,6 @@\n-    Node* one = (stride_con > 0) ? gvn->integercon( 1, iv_bt) : gvn->integercon(-1, iv_bt);\n-    adjusted_limit = gvn->transform(AddNode::make(adjusted_limit, one, iv_bt));\n-    if (bt == BoolTest::le)\n-      bt = BoolTest::lt;\n-    else if (bt == BoolTest::ge)\n-      bt = BoolTest::gt;\n+    Node* one = (stride_con > 0) ? igvn->integercon(1, _iv_bt) : igvn->integercon(-1, _iv_bt);\n+    adjusted_limit = igvn->transform(AddNode::make(adjusted_limit, one, _iv_bt));\n+    if (mask == BoolTest::le)\n+      mask = BoolTest::lt;\n+    else if (mask == BoolTest::ge)\n+      mask = BoolTest::gt;\n@@ -2431,1 +2550,1 @@\n-  set_subtree_ctrl(adjusted_limit, false);\n+  _phase->set_subtree_ctrl(adjusted_limit, false);\n@@ -2435,7 +2554,7 @@\n-  incr = incr->clone();\n-  incr->set_req(1,phi);\n-  incr->set_req(2,stride);\n-  incr = _igvn.register_new_node_with_optimizer(incr);\n-  set_early_ctrl(incr, false);\n-  _igvn.rehash_node_delayed(phi);\n-  phi->set_req_X( LoopNode::LoopBackControl, incr, &_igvn );\n+  Node* incr = _structure.truncated_increment().incr()->clone();\n+  incr->set_req(1, _structure.phi());\n+  incr->set_req(2, _structure.stride().stride_node());\n+  incr = igvn->register_new_node_with_optimizer(incr);\n+  _phase->set_early_ctrl(incr, false);\n+  igvn->rehash_node_delayed(_structure.phi());\n+  _structure.phi()->set_req_X(LoopNode::LoopBackControl, incr, igvn);\n@@ -2446,6 +2565,8 @@\n-  if (!TypeInteger::bottom(iv_bt)->higher_equal(phi->bottom_type())) {\n-    Node* nphi = PhiNode::make(phi->in(0), phi->in(LoopNode::EntryControl), TypeInteger::bottom(iv_bt));\n-    nphi->set_req(LoopNode::LoopBackControl, phi->in(LoopNode::LoopBackControl));\n-    nphi = _igvn.register_new_node_with_optimizer(nphi);\n-    set_ctrl(nphi, get_ctrl(phi));\n-    _igvn.replace_node(phi, nphi);\n+  Node* phi = _structure.phi();\n+  if (!TypeInteger::bottom(_iv_bt)->higher_equal(_structure.phi()->bottom_type())) {\n+    Node* nphi =\n+        PhiNode::make(_structure.phi()->in(0), _structure.phi()->in(LoopNode::EntryControl), TypeInteger::bottom(_iv_bt));\n+    nphi->set_req(LoopNode::LoopBackControl, _structure.phi()->in(LoopNode::LoopBackControl));\n+    nphi = igvn->register_new_node_with_optimizer(nphi);\n+    _phase->set_ctrl(nphi, _phase->get_ctrl(phi));\n+    igvn->replace_node(_structure.phi(), nphi);\n@@ -2454,2 +2575,7 @@\n-  cmp = cmp->clone();\n-  cmp->set_req(1,incr);\n+\n+  Node* iftrue = back_control;\n+  const uint iftrue_op = iftrue->Opcode();\n+  Node* iff = iftrue->in(0);\n+  Node* cmp = _structure.exit_test().cmp()->clone();\n+\n+  cmp->set_req(1, incr);\n@@ -2457,2 +2583,2 @@\n-  cmp = _igvn.register_new_node_with_optimizer(cmp);\n-  set_ctrl(cmp, iff->in(0));\n+  cmp = igvn->register_new_node_with_optimizer(cmp);\n+  _phase->set_ctrl(cmp, iff->in(0));\n@@ -2460,5 +2586,5 @@\n-  test = test->clone()->as_Bool();\n-  (*(BoolTest*)&test->_test)._test = bt;\n-  test->set_req(1,cmp);\n-  _igvn.register_new_node_with_optimizer(test);\n-  set_ctrl(test, iff->in(0));\n+  BoolNode* test = iff->in(1)->clone()->as_Bool();\n+  const_cast<BoolTest*>(&test->_test)->_test = mask; \/\/ Yes, it's a const, but it's a newly cloned node so we should be fine.\n+  test->set_req(1, cmp);\n+  igvn->register_new_node_with_optimizer(test);\n+  _phase->set_ctrl(test, iff->in(0));\n@@ -2467,5 +2593,9 @@\n-  Node *lex = _igvn.register_new_node_with_optimizer(BaseCountedLoopEndNode::make(iff->in(0), test, cl_prob, iff->as_If()->_fcnt, iv_bt));\n-  IfNode *le = lex->as_If();\n-  uint dd = dom_depth(iff);\n-  set_idom(le, le->in(0), dd); \/\/ Update dominance for loop exit\n-  set_loop(le, loop);\n+  Node* lex = igvn->register_new_node_with_optimizer(BaseCountedLoopEndNode::make(iff->in(0),\n+                                                                                  test,\n+                                                                                  _structure.exit_test().cl_prob(),\n+                                                                                  iff->as_If()->_fcnt,\n+                                                                                  _iv_bt));\n+  IfNode* le = lex->as_If();\n+  const uint dd = _phase->dom_depth(iff);\n+  _phase->set_idom(le, le->in(0), dd); \/\/ Update dominance for loop exit\n+  _phase->set_loop(le, _loop);\n@@ -2474,1 +2604,1 @@\n-  Node *iffalse = iff->as_If()->proj_out(!(iftrue_op == Op_IfTrue));\n+  Node* iffalse = iff->as_If()->proj_out(!(iftrue_op == Op_IfTrue));\n@@ -2478,2 +2608,2 @@\n-    Node *ift2=_igvn.register_new_node_with_optimizer(new IfTrueNode (le));\n-    Node *iff2=_igvn.register_new_node_with_optimizer(new IfFalseNode(le));\n+    Node* ift2 = igvn->register_new_node_with_optimizer(new IfTrueNode(le));\n+    Node* iff2 = igvn->register_new_node_with_optimizer(new IfFalseNode(le));\n@@ -2481,3 +2611,3 @@\n-    loop->_tail = back_control = ift2;\n-    set_loop(ift2, loop);\n-    set_loop(iff2, get_loop(iffalse));\n+    _loop->_tail = back_control = ift2;\n+    _phase->set_loop(ift2, _loop);\n+    _phase->set_loop(iff2, _phase->get_loop(iffalse));\n@@ -2486,2 +2616,2 @@\n-    replace_node_and_forward_ctrl(iffalse, iff2);\n-    replace_node_and_forward_ctrl(iftrue,  ift2);\n+    _phase->replace_node_and_forward_ctrl(iffalse, iff2);\n+    _phase->replace_node_and_forward_ctrl(iftrue,  ift2);\n@@ -2491,1 +2621,1 @@\n-    iftrue  = ift2;\n+    iftrue = ift2;\n@@ -2493,4 +2623,4 @@\n-    _igvn.rehash_node_delayed(iffalse);\n-    _igvn.rehash_node_delayed(iftrue);\n-    iffalse->set_req_X( 0, le, &_igvn );\n-    iftrue ->set_req_X( 0, le, &_igvn );\n+    igvn->rehash_node_delayed(iffalse);\n+    igvn->rehash_node_delayed(iftrue);\n+    iffalse->set_req_X(0, le, igvn);\n+    iftrue->set_req_X(0, le, igvn);\n@@ -2499,2 +2629,2 @@\n-  set_idom(iftrue,  le, dd+1);\n-  set_idom(iffalse, le, dd+1);\n+  _phase->set_idom(iftrue, le, dd + 1);\n+  _phase->set_idom(iffalse, le, dd + 1);\n@@ -2502,1 +2632,1 @@\n-  replace_node_and_forward_ctrl(iff, le); \/\/ fix 'get_ctrl'\n+  _phase->replace_node_and_forward_ctrl(iff, le); \/\/ fix 'get_ctrl'\n@@ -2505,5 +2635,5 @@\n-  bool strip_mine_loop = iv_bt == T_INT &&\n-                         loop->_child == nullptr &&\n-                         sfpt != nullptr &&\n-                         !loop->_has_call &&\n-                         is_deleteable_safept(sfpt);\n+  bool strip_mine_loop = _iv_bt == T_INT &&\n+      _loop->_child == nullptr &&\n+      _structure.sfpt() != nullptr &&\n+      !_loop->_has_call &&\n+      _phase->is_deleteable_safept(_structure.sfpt());\n@@ -2512,2 +2642,6 @@\n-    outer_ilt = create_outer_strip_mined_loop(init_control, loop, cl_prob, le->_fcnt,\n-                                              entry_control, iffalse);\n+    outer_ilt = _phase->create_outer_strip_mined_loop(init_control,\n+                                                      _loop,\n+                                                      _structure.exit_test().cl_prob(),\n+                                                      le->_fcnt,\n+                                                      entry_control,\n+                                                      iffalse);\n@@ -2517,2 +2651,2 @@\n-  BaseCountedLoopNode *l = BaseCountedLoopNode::make(entry_control, back_control, iv_bt);\n-  l->set_unswitch_count(x->as_Loop()->unswitch_count()); \/\/ Preserve\n+  BaseCountedLoopNode* l = BaseCountedLoopNode::make(entry_control, back_control, _iv_bt);\n+  l->set_unswitch_count(_head->as_Loop()->unswitch_count()); \/\/ Preserve\n@@ -2523,3 +2657,3 @@\n-  _igvn.register_new_node_with_optimizer(l);\n-  set_loop(l, loop);\n-  loop->_head = l;\n+  igvn->register_new_node_with_optimizer(l);\n+  _phase->set_loop(l, _loop);\n+  _loop->_head = l;\n@@ -2528,2 +2662,2 @@\n-  replace_node_and_forward_ctrl(x, l);\n-  set_idom(l, entry_control, dom_depth(entry_control) + 1);\n+  _phase->replace_node_and_forward_ctrl(_head, l);\n+  _phase->set_idom(l, entry_control, _phase->dom_depth(entry_control) + 1);\n@@ -2531,1 +2665,1 @@\n-  if (iv_bt == T_INT && (LoopStripMiningIter == 0 || strip_mine_loop)) {\n+  if (_iv_bt == T_INT && (LoopStripMiningIter == 0 || strip_mine_loop)) {\n@@ -2533,1 +2667,1 @@\n-    if (sfpt != nullptr && (strip_mine_loop || is_deleteable_safept(sfpt))) {\n+    if (_structure.sfpt() != nullptr && (strip_mine_loop || _phase->is_deleteable_safept(_structure.sfpt()))) {\n@@ -2536,1 +2670,1 @@\n-        Node* sfpt_clone = sfpt->clone();\n+        Node* sfpt_clone = _structure.sfpt()->clone();\n@@ -2545,2 +2679,2 @@\n-          _igvn.register_new_node_with_optimizer(new_polladdr, polladdr);\n-          set_ctrl(new_polladdr, iffalse);\n+          igvn->register_new_node_with_optimizer(new_polladdr, polladdr);\n+          _phase->set_ctrl(new_polladdr, iffalse);\n@@ -2551,2 +2685,2 @@\n-        register_control(sfpt_clone, outer_ilt, iffalse, body_populated);\n-        set_idom(outer_le, sfpt_clone, dom_depth(sfpt_clone));\n+        _phase->register_control(sfpt_clone, outer_ilt, iffalse, body_populated);\n+        _phase->set_idom(outer_le, sfpt_clone, _phase->dom_depth(sfpt_clone));\n@@ -2554,3 +2688,3 @@\n-      replace_node_and_forward_ctrl(sfpt, sfpt->in(TypeFunc::Control));\n-      if (loop->_safepts != nullptr) {\n-        loop->_safepts->yank(sfpt);\n+      _phase->replace_node_and_forward_ctrl(_structure.sfpt(), _structure.sfpt()->in(TypeFunc::Control));\n+      if (_loop->_safepts != nullptr) {\n+        _loop->_safepts->yank(_structure.sfpt());\n@@ -2562,2 +2696,2 @@\n-  assert(l->is_valid_counted_loop(iv_bt), \"counted loop shape is messed up\");\n-  assert(l == loop->_head && l->phi() == phi && l->loopexit_or_null() == lex, \"\" );\n+  assert(l->is_valid_counted_loop(_iv_bt), \"counted loop shape is messed up\");\n+  assert(l == _loop->_head && l->phi() == phi && l->loopexit_or_null() == lex, \"\" );\n@@ -2565,0 +2699,1 @@\n+\n@@ -2568,1 +2703,1 @@\n-    loop->dump_head();\n+    _loop->dump_head();\n@@ -2572,1 +2707,1 @@\n-  C->print_method(PHASE_AFTER_CLOOPS, 3, l);\n+  _phase->C->print_method(PHASE_AFTER_CLOOPS, 3, l);\n@@ -2577,1 +2712,1 @@\n-  l->phi()->as_Phi()->set_type(l->phi()->Value(&_igvn));\n+  l->phi()->as_Phi()->set_type(l->phi()->Value(igvn));\n@@ -2579,0 +2714,1 @@\n+  IdealLoopTree* loop = _loop;\n@@ -2587,1 +2723,1 @@\n-  if (x->as_Loop()->is_loop_nest_inner_loop() && iv_bt == T_LONG) {\n+  if (_head->as_Loop()->is_loop_nest_inner_loop() && _iv_bt == T_LONG) {\n@@ -2591,1 +2727,2 @@\n-  if (iv_bt == T_LONG && x->as_Loop()->is_loop_nest_outer_loop()) {\n+\n+  if (_iv_bt == T_LONG && _head->as_Loop()->is_loop_nest_outer_loop()) {\n@@ -2595,1 +2732,1 @@\n-  return true;\n+  return loop;\n@@ -2600,2 +2737,4 @@\n-bool PhaseIdealLoop::has_dominating_loop_limit_check(Node* init_trip, Node* limit, const jlong stride_con,\n-                                                     const BasicType iv_bt, Node* loop_entry) {\n+bool CountedLoopConverter::has_dominating_loop_limit_check(Node* init_trip, Node* limit, const jlong stride_con,\n+                                                           const BasicType iv_bt, Node* loop_entry) const {\n+  PhaseIterGVN& _igvn = _phase->igvn();\n+\n@@ -2624,2 +2763,2 @@\n-  _igvn.replace_input_of(iff, 0, C->top());\n-  _igvn.replace_input_of(iff, 1, C->top());\n+  _igvn.replace_input_of(iff, 0, _phase->C->top());\n+  _igvn.replace_input_of(iff, 1, _phase->C->top());\n@@ -2929,1 +3068,0 @@\n-\/\/----------------------match_incr_with_optional_truncation--------------------\n@@ -2932,4 +3070,3 @@\n-\/\/ Return null for failure. Success returns the increment node.\n-Node* CountedLoopNode::match_incr_with_optional_truncation(Node* expr, Node** trunc1, Node** trunc2,\n-                                                           const TypeInteger** trunc_type,\n-                                                           BasicType bt) {\n+void CountedLoopConverter::TruncatedIncrement::build(Node* expr) {\n+  _is_valid = false;\n+\n@@ -2937,1 +3074,3 @@\n-  if (expr == nullptr || expr->req() != 3)  return nullptr;\n+  if (expr == nullptr || expr->req() != 3) {\n+    return;\n+  }\n@@ -2939,2 +3078,2 @@\n-  Node *t1 = nullptr;\n-  Node *t2 = nullptr;\n+  Node* t1 = nullptr;\n+  Node* t2 = nullptr;\n@@ -2943,1 +3082,1 @@\n-  const TypeInteger* trunc_t = TypeInteger::bottom(bt);\n+  const TypeInteger* trunc_t = TypeInteger::bottom(_bt);\n@@ -2945,1 +3084,1 @@\n-  if (bt == T_INT) {\n+  if (_bt == T_INT) {\n@@ -2977,6 +3116,5 @@\n-  if (n1op == Op_Add(bt)) {\n-    *trunc1 = t1;\n-    *trunc2 = t2;\n-    *trunc_type = trunc_t;\n-    return n1;\n-  }\n+  if (n1op == Op_Add(_bt)) {\n+    _incr = n1;\n+    _outer_trunc = t1;\n+    _inner_trunc = t2;\n+    _trunc_type = trunc_t;\n@@ -2984,2 +3122,2 @@\n-  \/\/ failed\n-  return nullptr;\n+    _is_valid = true;\n+  }\n@@ -3638,1 +3776,1 @@\n-const TypeInt* PhaseIdealLoop::filtered_type( Node *n, Node* n_ctrl) {\n+const TypeInt* CountedLoopConverter::filtered_type(Node* n, Node* n_ctrl) {\n@@ -3642,1 +3780,1 @@\n-    assert(n_ctrl != nullptr || n_ctrl == C->top(), \"valid control\");\n+    assert(n_ctrl != nullptr || n_ctrl == _phase->C->top(), \"valid control\");\n@@ -3649,1 +3787,1 @@\n-    if (region && region != C->top()) {\n+    if (region && region != _phase->C->top()) {\n@@ -3664,1 +3802,1 @@\n-  const TypeInt* n_t = _igvn.type(n)->is_int();\n+  const TypeInt* n_t = _phase->igvn().type(n)->is_int();\n@@ -3674,1 +3812,1 @@\n-const TypeInt* PhaseIdealLoop::filtered_type_from_dominators( Node* val, Node *use_ctrl) {\n+const TypeInt* CountedLoopConverter::filtered_type_from_dominators(Node* val, Node* use_ctrl) {\n@@ -3681,3 +3819,3 @@\n-  if (use_ctrl && use_ctrl != C->top()) {\n-    Node* val_ctrl = get_ctrl(val);\n-    uint val_dom_depth = dom_depth(val_ctrl);\n+  if (use_ctrl && use_ctrl != _phase->C->top()) {\n+    Node* val_ctrl = _phase->get_ctrl(val);\n+    uint val_dom_depth = _phase->dom_depth(val_ctrl);\n@@ -3689,1 +3827,1 @@\n-        const TypeInt* if_t = IfNode::filtered_int_type(&_igvn, val, pred);\n+        const TypeInt* if_t = IfNode::filtered_int_type(&_phase->igvn(), val, pred);\n@@ -3698,2 +3836,2 @@\n-      pred = idom(pred);\n-      if (pred == nullptr || pred == C->top()) {\n+      pred = _phase->idom(pred);\n+      if (pred == nullptr || pred == _phase->C->top()) {\n@@ -3703,1 +3841,1 @@\n-      if (dom_depth(pred) < val_dom_depth) {\n+      if (_phase->dom_depth(pred) < val_dom_depth) {\n@@ -4288,1 +4426,1 @@\n-bool PhaseIdealLoop::is_deleteable_safept(Node* sfpt) {\n+bool PhaseIdealLoop::is_deleteable_safept(Node* sfpt) const {\n@@ -4507,1 +4645,1 @@\n-      phase->is_counted_loop(_head, loop, T_INT)) {\n+      phase->try_convert_to_counted_loop(_head, loop, T_INT)) {\n@@ -4521,1 +4659,1 @@\n-             phase->is_counted_loop(_head, loop, T_LONG)) {\n+      phase->try_convert_to_counted_loop(_head, loop, T_LONG)) {\n@@ -5326,1 +5464,2 @@\n-volatile int PhaseIdealLoop::_long_loop_counted_loops=0; \/\/ Number of long loops successfully transformed to a counted loop\n+volatile int CountedLoopConverter::_long_loop_counted_loops = 0; \/\/ Number of long loops successfully transformed to a\n+                                                                 \/\/ counted loop\n@@ -5328,1 +5467,6 @@\n-  tty->print_cr(\"PhaseIdealLoop=%d, sum _unique=%d, long loops=%d\/%d\/%d\", _loop_invokes, _loop_work, _long_loop_counted_loops, _long_loop_nests, _long_loop_candidates);\n+  tty->print_cr(\"PhaseIdealLoop=%d, sum _unique=%d, long loops=%d\/%d\/%d\",\n+                _loop_invokes,\n+                _loop_work,\n+                CountedLoopConverter::_long_loop_counted_loops,\n+                _long_loop_nests,\n+                _long_loop_candidates);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":679,"deletions":535,"binary":false,"changes":1214,"status":"modified"},{"patch":"@@ -276,5 +276,0 @@\n-  \/\/ Match increment with optional truncation\n-  static Node*\n-  match_incr_with_optional_truncation(Node* expr, Node** trunc1, Node** trunc2, const TypeInteger** trunc_type,\n-                                      BasicType bt);\n-\n@@ -1044,2 +1039,0 @@\n-  void insert_loop_limit_check_predicate(ParsePredicateSuccessProj* loop_limit_check_parse_proj, Node* cmp_limit,\n-                                         Node* bol);\n@@ -1305,1 +1298,1 @@\n-  bool is_deleteable_safept(Node* sfpt);\n+  bool is_deleteable_safept(Node* sfpt) const;\n@@ -1356,5 +1349,50 @@\n-  Node* loop_exit_control(Node* x, IdealLoopTree* loop);\n-  Node* loop_exit_test(Node* back_control, IdealLoopTree* loop, Node*& incr, Node*& limit, BoolTest::mask& bt, float& cl_prob);\n-  Node* loop_iv_incr(Node* incr, Node* x, IdealLoopTree* loop, Node*& phi_incr);\n-  Node* loop_iv_stride(Node* incr, Node*& xphi);\n-  PhiNode* loop_iv_phi(Node* xphi, Node* phi_incr, Node* x);\n+  Node* loop_exit_control(const Node* head, const IdealLoopTree* loop) const;\n+\n+  class LoopExitTest {\n+    bool _is_valid = false;\n+\n+    const Node* _back_control;\n+    const IdealLoopTree* _loop;\n+    PhaseIdealLoop* _phase;\n+\n+    Node* _cmp = nullptr;\n+    Node* _incr = nullptr;\n+    Node* _limit = nullptr;\n+    BoolTest::mask _mask = BoolTest::illegal;\n+    float _cl_prob = 0.0f;\n+\n+  public:\n+    LoopExitTest(const Node* back_control, const IdealLoopTree* loop, PhaseIdealLoop* phase) :\n+      _back_control(back_control),\n+      _loop(loop),\n+      _phase(phase) {}\n+\n+    void build();\n+    void canonicalize_mask(jlong stride_con);\n+\n+    bool is_valid_with_bt(BasicType bt) const {\n+      return _is_valid && _cmp != nullptr && _cmp->Opcode() == Op_Cmp(bt);\n+    }\n+\n+    bool should_include_limit() const { return _mask == BoolTest::le || _mask == BoolTest::ge; }\n+\n+    CmpNode* cmp() const { return _cmp->as_Cmp(); }\n+    Node* incr() const { return _incr; }\n+    Node* limit() const { return _limit; }\n+    BoolTest::mask mask() const { return _mask; }\n+    float cl_prob() const { return _cl_prob; }\n+  };\n+\n+  class LoopIVIncr {\n+    bool _is_valid = false;\n+\n+    const Node* _head;\n+    const IdealLoopTree* _loop;\n+\n+    Node* _incr = nullptr;\n+    Node* _phi_incr = nullptr;\n+\n+  public:\n+    LoopIVIncr(const Node* head, const IdealLoopTree* loop) :\n+      _head(head),\n+      _loop(loop) {}\n@@ -1362,1 +1400,32 @@\n-  bool is_counted_loop(Node* x, IdealLoopTree*&loop, BasicType iv_bt);\n+    void build(Node* old_incr);\n+\n+    bool is_valid() const { return _is_valid; }\n+    bool is_valid_with_bt(const BasicType bt) const {\n+      return _is_valid && _incr->Opcode() == Op_Add(bt);\n+    }\n+\n+    Node* incr() const { return _incr; }\n+    Node* phi_incr() const { return _phi_incr; }\n+  };\n+\n+  class LoopIVStride {\n+    bool _is_valid = false;\n+\n+    Node* _stride_node = nullptr;\n+    Node* _xphi = nullptr;\n+\n+  public:\n+    LoopIVStride() {}\n+\n+    void build(const Node* incr);\n+\n+    bool is_valid() const { return _is_valid && _stride_node != nullptr; }\n+    Node* stride_node() const { return _stride_node; }\n+    Node* xphi() const { return _xphi; }\n+\n+    jlong compute_non_zero_stride_con(BoolTest::mask mask, BasicType iv_bt) const;\n+  };\n+\n+  static PhiNode* loop_iv_phi(const Node* xphi, const Node* phi_incr, const Node* head);\n+\n+  bool try_convert_to_counted_loop(Node* head, IdealLoopTree*& loop, BasicType iv_bt);\n@@ -1366,3 +1435,1 @@\n-#ifdef ASSERT\n-  bool convert_to_long_loop(Node* cmp, Node* phi, IdealLoopTree* loop);\n-#endif\n+\n@@ -1370,1 +1437,1 @@\n-  SafePointNode* find_safepoint(Node* back_control, Node* x, IdealLoopTree* loop);\n+  SafePointNode* find_safepoint(Node* back_control, const Node* head, const IdealLoopTree* loop);\n@@ -1498,2 +1565,0 @@\n-  bool has_dominating_loop_limit_check(Node* init_trip, Node* limit, jlong stride_con, BasicType iv_bt,\n-                                       Node* loop_entry);\n@@ -1754,6 +1819,0 @@\n-  \/\/ Return a type based on condition control flow\n-  const TypeInt* filtered_type( Node *n, Node* n_ctrl);\n-  const TypeInt* filtered_type( Node *n ) { return filtered_type(n, nullptr); }\n- \/\/ Helpers for filtered type\n-  const TypeInt* filtered_type_from_dominators( Node* val, Node *val_ctrl);\n-\n@@ -1888,1 +1947,0 @@\n-  static volatile int _long_loop_counted_loops;\n@@ -1976,0 +2034,124 @@\n+class CountedLoopConverter {\n+  friend class PhaseIdealLoop;\n+\n+  \/\/ Match increment with optional truncation\n+  class TruncatedIncrement {\n+    bool _is_valid = false;\n+\n+    BasicType _bt;\n+\n+    Node* _incr = nullptr;\n+    Node* _outer_trunc = nullptr;\n+    Node* _inner_trunc = nullptr;\n+    const TypeInteger* _trunc_type = nullptr;\n+\n+  public:\n+    TruncatedIncrement(BasicType bt) :\n+      _bt(bt) {}\n+\n+    void build(Node* expr);\n+\n+    bool is_valid() const { return _is_valid; }\n+    Node* incr() const { return _incr; }\n+\n+    \/\/ Optional truncation for: CHAR: (i+1)&0x7fff, BYTE: ((i+1)<<8)>>8, or SHORT: ((i+1)<<16)>>16\n+    Node* outer_trunc() const { return _outer_trunc; } \/\/ the outermost truncating node (either the & or the final >>)\n+    Node* inner_trunc() const { return _inner_trunc; } \/\/ the inner truncating node, if applicable (the << in a <<\/>> pair)\n+    const TypeInteger* trunc_type() const { return _trunc_type; }\n+  };\n+\n+  class LoopStructure {\n+    bool _is_valid = false;\n+\n+    const Node* _head;\n+    const IdealLoopTree* _loop;\n+    PhaseIdealLoop* _phase;\n+    BasicType _iv_bt;\n+\n+    Node* _back_control = nullptr;\n+    PhaseIdealLoop::LoopExitTest _exit_test;\n+    PhaseIdealLoop::LoopIVIncr _iv_incr;\n+    TruncatedIncrement _truncated_increment;\n+    PhaseIdealLoop::LoopIVStride _stride;\n+    PhiNode* _phi = nullptr;\n+    SafePointNode* _safepoint = nullptr;\n+\n+  public:\n+    LoopStructure(const Node* head, const IdealLoopTree* loop, PhaseIdealLoop* phase, const BasicType iv_bt) :\n+      _head(head),\n+      _loop(loop),\n+      _phase(phase),\n+      _iv_bt(iv_bt),\n+      _back_control(_phase->loop_exit_control(_head, _loop)),\n+      _exit_test(_back_control, _loop, _phase),\n+      _iv_incr(_head, _loop),\n+      _truncated_increment(_iv_bt),\n+      _stride(PhaseIdealLoop::LoopIVStride()) {}\n+\n+    void build();\n+\n+    jlong final_limit_correction() const; \/\/ compute adjusted loop limit correction\n+    bool is_infinite_loop(const TypeInteger* limit_t) const;\n+\n+    bool is_valid() const { return _is_valid; }\n+\n+    Node* back_control() const { return _back_control; }\n+    PhaseIdealLoop::LoopExitTest& exit_test() { return _exit_test; }\n+    PhaseIdealLoop::LoopIVIncr& iv_incr() { return _iv_incr; }\n+    TruncatedIncrement& truncated_increment() { return _truncated_increment; }\n+    PhaseIdealLoop::LoopIVStride& stride() { return _stride; }\n+    PhiNode* phi() const { return _phi; }\n+    SafePointNode* sfpt() const { return _safepoint; }\n+    jlong stride_con() const { return _stride.compute_non_zero_stride_con(_exit_test.mask(), _iv_bt); }\n+    Node* limit() const { return _exit_test.limit(); }\n+  };\n+\n+  PhaseIdealLoop* const _phase;\n+  Node* const _head;\n+  IdealLoopTree* const _loop;\n+  const BasicType _iv_bt;\n+\n+  LoopStructure _structure;\n+  bool _insert_stride_overflow_limit_check = false;\n+  bool _insert_init_trip_limit_check = false;\n+\n+  DEBUG_ONLY(bool _checked_for_counted_loop = false;)\n+\n+  \/\/ stats for PhaseIdealLoop::print_statistics()\n+  static volatile int _long_loop_counted_loops;\n+\n+  \/\/ Return a type based on condition control flow\n+  const TypeInt* filtered_type(Node* n, Node* n_ctrl);\n+  const TypeInt* filtered_type(Node* n) { return filtered_type(n, nullptr); }\n+  \/\/ Helpers for filtered type\n+  const TypeInt* filtered_type_from_dominators(Node* val, Node* val_ctrl);\n+\n+  void insert_loop_limit_check_predicate(const ParsePredicateSuccessProj* loop_limit_check_parse_proj, Node* cmp_limit,\n+                                         Node* bol) const;\n+  bool has_dominating_loop_limit_check(Node* init_trip, Node* limit, jlong stride_con, BasicType iv_bt,\n+                                       Node* loop_entry) const;\n+\n+  bool is_iv_overflowing(const TypeInteger* init_t, jlong stride_con, Node* phi_increment, BoolTest::mask mask) const;\n+  bool has_truncation_wrap(TruncatedIncrement truncation, Node* phi, jlong stride_con);\n+  SafePointNode* find_safepoint(Node* iftrue);\n+  bool is_safepoint_invalid(SafePointNode* sfpt) const;\n+\n+ public:\n+  CountedLoopConverter(PhaseIdealLoop* phase, Node* head, IdealLoopTree* loop, const BasicType iv_bt)\n+      : _phase(phase),\n+        _head(head),\n+        _loop(loop),\n+        _iv_bt(iv_bt),\n+        _structure(LoopStructure(_head, _loop, _phase, _iv_bt)) {\n+    assert(phase != nullptr, \"must be\"); \/\/ Fail early if mandatory parameters are null.\n+    assert(head != nullptr, \"must be\");\n+    assert(loop != nullptr, \"must be\");\n+    assert(iv_bt == T_INT || iv_bt == T_LONG, \"either int or long loops\");\n+  }\n+\n+  bool is_counted_loop();\n+  IdealLoopTree* convert();\n+\n+  DEBUG_ONLY(bool should_stress_long_counted_loop();)\n+  DEBUG_ONLY(bool stress_long_counted_loop();)\n+};\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":209,"deletions":27,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -2846,4 +2846,4 @@\n-      Node* add = CountedLoopNode::match_incr_with_optional_truncation(in,\n-                                &trunc1, &trunc2, &ttype, T_INT);\n-      if (add && add->in(1) == phi) {\n-        add2 = add->in(2);\n+      CountedLoopConverter::TruncatedIncrement add(T_INT);\n+      add.build(in);\n+      if (add.is_valid() && add.incr()->in(1) == phi) {\n+        add2 = add.incr()->in(2);\n@@ -2856,4 +2856,4 @@\n-    Node* add = CountedLoopNode::match_incr_with_optional_truncation(addtrunc,\n-                                &trunc1, &trunc2, &ttype, T_INT);\n-    if (add && add->in(1)->is_Phi()) {\n-      Node* phi = add->in(1);\n+    CountedLoopConverter::TruncatedIncrement add(T_INT);\n+    add.build(addtrunc);\n+    if (add.is_valid() && add.incr()->in(1)->is_Phi()) {\n+      Node* phi = add.incr()->in(1);\n@@ -2862,1 +2862,1 @@\n-          add2 = add->in(2);\n+          add2 = add.incr()->in(2);\n@@ -4266,6 +4266,3 @@\n-    BoolTest::mask bt = BoolTest::illegal;\n-    float cl_prob = 0;\n-    Node* incr = nullptr;\n-    Node* limit = nullptr;\n-    Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);\n-    if (cmp == nullptr || cmp->Opcode() != Op_CmpI) {\n+    LoopExitTest loop_exit(back_control, loop, this);\n+    loop_exit.build();\n+    if (!loop_exit.is_valid_with_bt(T_INT)) {\n@@ -4275,0 +4272,2 @@\n+    Node* loop_incr = loop_exit.incr();\n+\n@@ -4277,1 +4276,1 @@\n-    if (!incr->is_Phi() || incr->in(0) == head) {\n+    if (!loop_incr->is_Phi() || loop_incr->in(0) == head) {\n@@ -4282,1 +4281,1 @@\n-    region = incr->in(0);\n+    region = loop_incr->in(0);\n@@ -4288,7 +4287,4 @@\n-    for (uint i = 1; i < incr->req(); ++i) {\n-      Node* in = incr->in(i);\n-      Node* trunc1 = nullptr;\n-      Node* trunc2 = nullptr;\n-      const TypeInteger* iv_trunc_t = nullptr;\n-      Node* orig_in = in;\n-      if (!(in = CountedLoopNode::match_incr_with_optional_truncation(in, &trunc1, &trunc2, &iv_trunc_t, T_INT))) {\n+    for (uint i = 1; i < loop_incr->req(); ++i) {\n+      CountedLoopConverter::TruncatedIncrement increment(T_INT);\n+      increment.build(loop_incr->in(i));\n+      if (!increment.is_valid()) {\n@@ -4297,3 +4293,1 @@\n-      assert(in->Opcode() == Op_AddI, \"wrong increment code\");\n-      Node* xphi = nullptr;\n-      Node* stride = loop_iv_stride(in, xphi);\n+      assert(increment.incr()->Opcode() == Op_AddI, \"wrong increment code\");\n@@ -4301,1 +4295,3 @@\n-      if (stride == nullptr) {\n+      LoopIVStride stride = LoopIVStride();\n+      stride.build(increment.incr());\n+      if (!stride.is_valid()) {\n@@ -4305,1 +4301,1 @@\n-      PhiNode* phi = loop_iv_phi(xphi, nullptr, head);\n+      PhiNode* phi = loop_iv_phi(stride.xphi(), nullptr, head);\n@@ -4307,2 +4303,2 @@\n-          (trunc1 == nullptr && phi->in(LoopNode::LoopBackControl) != incr) ||\n-          (trunc1 != nullptr && phi->in(LoopNode::LoopBackControl) != trunc1)) {\n+          (increment.outer_trunc() == nullptr && phi->in(LoopNode::LoopBackControl) != loop_exit.incr()) ||\n+          (increment.outer_trunc() != nullptr && phi->in(LoopNode::LoopBackControl) != increment.outer_trunc())) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":27,"deletions":31,"binary":false,"changes":58,"status":"modified"}]}