{"files":[{"patch":"@@ -1663,0 +1663,128 @@\n+\/\/------------------------------Counted Loop Structures-----------------------------\n+bool PhaseIdealLoop::LoopExitTest::build() {\n+  const Node* iftrue = _back_control;\n+  uint iftrue_op = iftrue->Opcode();\n+  Node* iff = iftrue->in(0);\n+  BoolNode* test = iff->in(1)->as_Bool();\n+  _mask = test->_test._test;\n+  _cl_prob = iff->as_If()->_prob;\n+  if (iftrue_op == Op_IfFalse) {\n+    _mask = BoolTest(_mask).negate();\n+    _cl_prob = 1.0f - _cl_prob;\n+  }\n+  \/\/ Get backedge compare\n+  _cmp = test->in(1);\n+  if (!_cmp->is_Cmp()) {\n+    return false;\n+  }\n+\n+  \/\/ Find the trip-counter increment & limit.  Limit must be loop invariant.\n+  _incr  = _cmp->in(1);\n+  _limit = _cmp->in(2);\n+\n+  \/\/ ---------\n+  \/\/ need 'loop()' test to tell if limit is loop invariant\n+  \/\/ ---------\n+\n+  if (!_phase->is_member(_loop, _phase->get_ctrl(_incr))) { \/\/ Swapped trip counter and limit?\n+    swap(_incr, _limit);                \/\/ Then reverse order into the CmpI\n+    _mask = BoolTest(_mask).commute(); \/\/ And commute the exit test\n+  }\n+  if (_phase->is_member(_loop, _phase->get_ctrl(_limit))) { \/\/ Limit must be loop-invariant\n+    return false;\n+  }\n+  if (!_phase->is_member(_loop, _phase->get_ctrl(_incr))) { \/\/ Trip counter must be loop-variant\n+    return false;\n+  }\n+\n+  _is_valid = true;\n+  return true;\n+}\n+\n+\/\/ Canonicalize the loop condition if it is 'ne'.\n+bool PhaseIdealLoop::LoopExitTest::canonicalize_mask(jlong stride_con) {\n+  if (_mask != BoolTest::ne) {\n+    return false;\n+  }\n+\n+  assert(stride_con == 1 || stride_con == -1, \"simple increment only - checked in CountedLoopConverter\");\n+\n+  if (stride_con == 1) {\n+    \/\/ 'ne' can be replaced with 'lt' only when init < limit.\n+    \/\/ This is ensured by the inserted predicate in CountedLoopConverter\n+    _mask = BoolTest::lt;\n+    return true;\n+  }\n+\n+  if (stride_con == -1) {\n+    \/\/ 'ne' can be replaced with 'gt' only when init > limit.\n+    \/\/ This is ensured by the inserted predicate in CountedLoopConverter.\n+    _mask = BoolTest::gt;\n+    return true;\n+  }\n+\n+  \/\/ Should not reach\n+  return false;\n+}\n+\n+bool PhaseIdealLoop::LoopIVIncr::build() {\n+  Node* incr = _old_incr;\n+  if (incr->is_Phi() && incr->as_Phi()->region() == _head && incr->req() == 3) { \/\/ Requires simple trip counter expression\n+    Node* phi_incr = incr;\n+    Node* back_control = phi_incr->in(LoopNode::LoopBackControl); \/\/ Assume incr is on backedge of Phi\n+    if (_loop->_phase->is_member(_loop, _loop->_phase->get_ctrl(back_control))) { \/\/ Trip counter must be loop-variant\n+      _incr = back_control;\n+      _phi_incr = phi_incr;\n+\n+      _is_valid = true;\n+      return true;\n+    }\n+  }\n+  _incr = incr;\n+  _phi_incr = nullptr;\n+\n+  _is_valid = true;\n+  return true;\n+}\n+\n+bool PhaseIdealLoop::LoopIVStride::build() {\n+  assert(_incr->Opcode() == Op_AddI || _incr->Opcode() == Op_AddL, \"caller resp.\");\n+  \/\/ Get merge point\n+  _xphi = _incr->in(1);\n+  _node = _incr->in(2);\n+  if (!_node->is_Con()) {     \/\/ Oops, swap these\n+    if (!_xphi->is_Con()) {     \/\/ Is the other guy a constant?\n+      return false;            \/\/ Nope, unknown stride, bail out\n+    }\n+\n+    swap(_xphi, _node);        \/\/ 'incr' is commutative, so ok to swap\n+  }\n+\n+  _is_valid = true;\n+  return true;\n+}\n+\n+jlong PhaseIdealLoop::LoopIVStride::compute_non_zero_stride_con(const BoolTest::mask mask, const BasicType iv_bt) const {\n+  jlong stride_con = node()->get_integer_as_long(iv_bt);\n+  assert(stride_con != 0, \"missed some peephole opt\"); \/\/ stride constant can never be 0!\n+\n+  \/\/ If the condition is inverted and we will be rolling\n+  \/\/ through MININT to MAXINT, then bail out.\n+  if (mask == BoolTest::eq || \/\/ Bail out, but this loop trips at most twice!\n+      \/\/ Odd stride\n+      (mask == BoolTest::ne && stride_con != 1 && stride_con != -1) ||\n+      \/\/ Count down loop rolls through MAXINT\n+      ((mask == BoolTest::le || mask == BoolTest::lt) && stride_con < 0) ||\n+      \/\/ Count up loop rolls through MININT\n+      ((mask == BoolTest::ge || mask == BoolTest::gt) && stride_con > 0)) {\n+    return 0; \/\/ Bail out with sentinel = 0\n+  }\n+\n+  \/\/ Bail out if the stride is too big.\n+  if (stride_con == min_signed_integer(iv_bt) || (ABS(stride_con) > max_signed_integer(iv_bt) \/ 2)) {\n+    return 0; \/\/ Bail out with sentinel = 0\n+  }\n+\n+  return stride_con;\n+}\n+\n@@ -1664,0 +1792,93 @@\n+bool CountedLoopConverter::LoopStructure::build() {\n+  _back_control = _phase->loop_exit_control(_head, _loop);\n+  if (_back_control == nullptr) {\n+    return false;\n+  }\n+\n+  _exit_test = PhaseIdealLoop::LoopExitTest(_back_control, _loop, _phase);\n+  _exit_test.build();\n+  if (!_exit_test.is_valid_with_bt(_iv_bt)) {\n+    return false; \/\/ Avoid pointer & float & 64-bit compares\n+  }\n+\n+  Node* incr = _exit_test.incr();\n+  if (_exit_test.incr()->Opcode() == Op_Cast(_iv_bt)) {\n+    incr = incr->in(1);\n+  }\n+\n+  _iv_incr = PhaseIdealLoop::LoopIVIncr(incr, _head, _loop);\n+  _iv_incr.build();\n+  if (_iv_incr.incr() == nullptr) {\n+    return false;\n+  }\n+\n+  _truncated_increment = CountedLoopNode::TruncatedIncrement(_iv_incr.incr(), _iv_bt);\n+  _truncated_increment.build();\n+  if (!_truncated_increment.is_valid()) {\n+    return false; \/\/ Funny increment opcode\n+  }\n+  assert(_truncated_increment.incr()->Opcode() == Op_Add(_iv_bt), \"wrong increment code\");\n+\n+  _stride = PhaseIdealLoop::LoopIVStride(_truncated_increment.incr());\n+  _stride.build();\n+  if (!_stride.is_valid()) {\n+    return false;\n+  }\n+\n+  Node* xphi = _stride.xphi();\n+  \/\/ Iteratively uncast the loop induction variable\n+  \/\/ until no more CastII\/CastLL nodes are found.\n+  while (xphi->Opcode() == Op_Cast(_iv_bt)) {\n+    xphi = xphi->in(1);\n+  }\n+\n+  _phi = PhaseIdealLoop::loop_iv_phi(xphi, _iv_incr.phi_incr(), _head);\n+  if (_phi == nullptr ||\n+      (_truncated_increment.trunc1() == nullptr && _phi->in(LoopNode::LoopBackControl) != _truncated_increment.incr()) ||\n+      (_truncated_increment.trunc1() != nullptr && _phi->in(LoopNode::LoopBackControl) != _truncated_increment.trunc1())) {\n+    return false;\n+      }\n+\n+  _sfpt = _loop->_child == nullptr\n+                          ? _phase->find_safepoint(_back_control, _head, _loop)\n+                          : _back_control->in(0)->in(0)->isa_SafePoint();\n+\n+  _is_valid = true;\n+  return true;\n+}\n+\n+\/\/ We need to canonicalize the loop exit check by using different values for adjusted_limit:\n+\/\/ (LE1) iv_post_i < limit: Already canonicalized. We can directly use limit as adjusted_limit.\n+\/\/           -> adjusted_limit = limit.\n+\/\/ (LE2) iv_post_i <= limit:\n+\/\/           iv_post_i < limit + 1\n+\/\/           -> adjusted limit = limit + 1\n+\/\/ (LE3) iv_pre_i < limit:\n+\/\/           iv_pre_i + stride < limit + stride\n+\/\/           iv_post_i < limit + stride\n+\/\/           -> adjusted_limit = limit + stride\n+\/\/ (LE4) iv_pre_i <= limit:\n+\/\/           iv_pre_i < limit + 1\n+\/\/           iv_pre_i + stride < limit + stride + 1\n+\/\/           iv_post_i < limit + stride + 1\n+\/\/           -> adjusted_limit = limit + stride + 1\n+\/\/\n+\/\/ Note that:\n+\/\/     (AL) limit <= adjusted_limit.\n+jlong CountedLoopConverter::LoopStructure::final_limit_correction() const {\n+  const jlong stride_con = _stride.compute_non_zero_stride_con(_exit_test.mask(), _iv_bt);\n+\n+  \/\/ Accounting for (LE3) and (LE4) where we use pre-incremented phis in the loop exit check.\n+  const jlong limit_correction_for_pre_iv_exit_check = _iv_incr.phi_incr() != nullptr ? stride_con : 0;\n+\n+  \/\/ Accounting for (LE2) and (LE4) where we use <= or >= in the loop exit check.\n+  const jlong limit_correction_for_le_ge_exit_check = _exit_test.should_include_limit()\n+                                                        ? (stride_con > 0 ? 1 : -1)\n+                                                        : 0;\n+\n+  const jlong limit_correction = limit_correction_for_pre_iv_exit_check + limit_correction_for_le_ge_exit_check;\n+  const jlong canonicalized_correction = stride_con + (stride_con > 0 ? -1 : 1);\n+\n+  return canonicalized_correction + limit_correction; \/\/ final_correction\n+}\n+\n@@ -1671,1 +1892,1 @@\n-      _structure.truncated_increment().trunc_type == TypeInt::INT; \/\/ Only stress an int loop (i.e., not char, byte or short)\n+      _structure.truncated_increment().trunc_type() == TypeInt::INT; \/\/ Only stress an int loop (i.e., not char, byte or short)\n@@ -1815,1 +2036,1 @@\n-  if (is_infinite_loop(_structure.truncated_increment().trunc1, limit_t, _structure.iv_incr().incr())) {\n+  if (is_infinite_loop(_structure.truncated_increment().trunc1(), limit_t, _structure.iv_incr().incr())) {\n@@ -1826,6 +2047,1 @@\n-  if (has_truncation_wrap(\n-    _structure.truncated_increment().trunc1,\n-    _structure.truncated_increment().trunc2,\n-    _structure.truncated_increment().trunc_type,\n-    _structure.phi(),\n-    stride_con)) {\n+  if (has_truncation_wrap(_structure.truncated_increment(), _structure.phi(), stride_con)) {\n@@ -1913,19 +2129,0 @@\n-  \/\/ If that is not the case, we need to canonicalize the loop exit check by using different values for adjusted_limit:\n-  \/\/ (LE1) iv_post_i < limit: Already canonicalized. We can directly use limit as adjusted_limit.\n-  \/\/           -> adjusted_limit = limit.\n-  \/\/ (LE2) iv_post_i <= limit:\n-  \/\/           iv_post_i < limit + 1\n-  \/\/           -> adjusted limit = limit + 1\n-  \/\/ (LE3) iv_pre_i < limit:\n-  \/\/           iv_pre_i + stride < limit + stride\n-  \/\/           iv_post_i < limit + stride\n-  \/\/           -> adjusted_limit = limit + stride\n-  \/\/ (LE4) iv_pre_i <= limit:\n-  \/\/           iv_pre_i < limit + 1\n-  \/\/           iv_pre_i + stride < limit + stride + 1\n-  \/\/           iv_post_i < limit + stride + 1\n-  \/\/           -> adjusted_limit = limit + stride + 1\n-  \/\/\n-  \/\/ Note that:\n-  \/\/     (AL) limit <= adjusted_limit.\n-  \/\/\n@@ -2049,10 +2246,1 @@\n-  \/\/ Accounting for (LE3) and (LE4) where we use pre-incremented phis in the loop exit check.\n-  const jlong limit_correction_for_pre_iv_exit_check = (_structure.iv_incr().phi_incr() != nullptr) ? stride_con : 0;\n-\n-  \/\/ Accounting for (LE2) and (LE4) where we use <= or >= in the loop exit check.\n-  const bool includes_limit = (_structure.exit_test().mask() == BoolTest::le || _structure.exit_test().mask() == BoolTest::ge);\n-  const jlong limit_correction_for_le_ge_exit_check = (includes_limit ? (stride_con > 0 ? 1 : -1) : 0);\n-\n-  const jlong limit_correction = limit_correction_for_pre_iv_exit_check + limit_correction_for_le_ge_exit_check;\n-  const jlong canonicalized_correction = stride_con + (stride_con > 0 ? -1 : 1);\n-  const jlong final_correction = canonicalized_correction + limit_correction;\n+  int sov = check_stride_overflow(_structure.final_limit_correction(), limit_t, _iv_bt);\n@@ -2060,1 +2248,0 @@\n-  int sov = check_stride_overflow(final_correction, limit_t, _iv_bt);\n@@ -2062,1 +2249,0 @@\n-\n@@ -2073,1 +2259,1 @@\n-  bool insert_stride_overflow_limit_check = false;\n+  _insert_stride_overflow_limit_check = false;\n@@ -2095,1 +2281,1 @@\n-    insert_stride_overflow_limit_check = true;\n+    _insert_stride_overflow_limit_check = true;\n@@ -2108,1 +2294,1 @@\n-  bool insert_init_trip_limit_check = false;\n+  _insert_init_trip_limit_check = false;\n@@ -2144,1 +2330,1 @@\n-    insert_init_trip_limit_check = true;\n+    _insert_init_trip_limit_check = true;\n@@ -2153,10 +2339,0 @@\n-  \/\/ Variables needed by convert() to do the actual conversion. We set these fields iff a counted loop is confirmed.\n-  \/\/ This way the is_counted_loop() can run multiple times with possibly different structures.\n-\n-  _stride_con = stride_con;\n-  _final_correction = final_correction;\n-  _includes_limit = includes_limit;\n-\n-  _insert_stride_overflow_limit_check = insert_stride_overflow_limit_check;\n-  _insert_init_trip_limit_check = insert_init_trip_limit_check;\n-\n@@ -2171,1 +2347,1 @@\n-                                             BoolTest::mask mask) {\n+                                             BoolTest::mask mask) const {\n@@ -2200,1 +2376,1 @@\n-                                            const Node* incr) {\n+                                            const Node* incr) const {\n@@ -2231,4 +2407,1 @@\n-bool CountedLoopConverter::has_truncation_wrap(Node* increment_trunc1,\n-                                               Node* increment_trunc2,\n-                                               const TypeInteger* trunc_type,\n-                                               Node* phi,\n+bool CountedLoopConverter::has_truncation_wrap(CountedLoopNode::TruncatedIncrement truncation, Node* phi,\n@@ -2237,2 +2410,2 @@\n-  if (!TypeInteger::bottom(_iv_bt)->higher_equal(trunc_type)) {\n-    assert(increment_trunc1 != nullptr, \"must have found some truncation\");\n+  if (!TypeInteger::bottom(_iv_bt)->higher_equal(truncation.trunc_type())) {\n+    assert(truncation.trunc1() != nullptr, \"must have found some truncation\");\n@@ -2255,2 +2428,2 @@\n-      if (trunc_type->hi_as_long() - phi_ft->hi_as_long() < stride_con ||\n-          trunc_type->lo_as_long() > phi_ft->lo_as_long()) {\n+      if (truncation.trunc_type()->hi_as_long() - phi_ft->hi_as_long() < stride_con ||\n+          truncation.trunc_type()->lo_as_long() > phi_ft->lo_as_long()) {\n@@ -2260,2 +2433,2 @@\n-      if (trunc_type->lo_as_long() - phi_ft->lo_as_long() > stride_con ||\n-          trunc_type->hi_as_long() < phi_ft->hi_as_long()) {\n+      if (truncation.trunc_type()->lo_as_long() - phi_ft->lo_as_long() > stride_con ||\n+          truncation.trunc_type()->hi_as_long() < phi_ft->hi_as_long()) {\n@@ -2269,1 +2442,1 @@\n-    assert(Type::equals(trunc_type, TypeInt::INT) || Type::equals(trunc_type, TypeLong::LONG),\n+    assert(Type::equals(truncation.trunc_type(), TypeInt::INT) || Type::equals(truncation.trunc_type(), TypeLong::LONG),\n@@ -2271,1 +2444,1 @@\n-    assert(increment_trunc1 == nullptr && increment_trunc2 == nullptr, \"no truncation for int\");\n+    assert(truncation.trunc1() == nullptr && truncation.trunc2() == nullptr, \"no truncation for int\");\n@@ -2310,0 +2483,1 @@\n+  const jlong stride_con = _structure.stride().compute_non_zero_stride_con(_structure.exit_test().mask(), _iv_bt);\n@@ -2312,1 +2486,1 @@\n-    Node* cmp_limit = CmpNode::make(_structure.exit_test().limit(), igvn->integercon((_stride_con > 0\n+    Node* cmp_limit = CmpNode::make(_structure.exit_test().limit(), igvn->integercon((stride_con > 0\n@@ -2315,2 +2489,2 @@\n-                                                                 - _final_correction, _iv_bt), _iv_bt);\n-    Node* bol = new BoolNode(cmp_limit, _stride_con > 0 ? BoolTest::le : BoolTest::ge);\n+                                                                 - _structure.final_limit_correction(), _iv_bt), _iv_bt);\n+    Node* bol = new BoolNode(cmp_limit, stride_con > 0 ? BoolTest::le : BoolTest::ge);\n@@ -2323,1 +2497,1 @@\n-    Node* bol = new BoolNode(cmp_limit, _stride_con > 0 ? BoolTest::lt : BoolTest::gt);\n+    Node* bol = new BoolNode(cmp_limit, stride_con > 0 ? BoolTest::lt : BoolTest::gt);\n@@ -2354,1 +2528,1 @@\n-  if (_includes_limit) {\n+  if (_structure.exit_test().should_include_limit()) {\n@@ -2358,1 +2532,1 @@\n-    Node* one = (_stride_con > 0) ? igvn->integercon(1, _iv_bt) : igvn->integercon(-1, _iv_bt);\n+    Node* one = (stride_con > 0) ? igvn->integercon(1, _iv_bt) : igvn->integercon(-1, _iv_bt);\n@@ -2372,1 +2546,1 @@\n-  Node* incr = _structure.truncated_increment().incr->clone();\n+  Node* incr = _structure.truncated_increment().incr()->clone();\n@@ -2889,2 +3063,3 @@\n-\/\/ Return null for failure. Success returns the increment node.\n-CountedLoopNode::TruncatedIncrement CountedLoopNode::match_incr_with_optional_truncation(Node* expr, BasicType bt) {\n+bool CountedLoopNode::TruncatedIncrement::build() {\n+  _is_valid = false;\n+\n@@ -2892,1 +3067,1 @@\n-  if (expr == nullptr || expr->req() != 3)  return TruncatedIncrement{};\n+  if (_expr == nullptr || _expr->req() != 3)  return false;\n@@ -2896,1 +3071,1 @@\n-  Node* n1 = expr;\n+  Node* n1 = _expr;\n@@ -2898,1 +3073,1 @@\n-  const TypeInteger* trunc_t = TypeInteger::bottom(bt);\n+  const TypeInteger* trunc_t = TypeInteger::bottom(_bt);\n@@ -2900,1 +3075,1 @@\n-  if (bt == T_INT) {\n+  if (_bt == T_INT) {\n@@ -2932,2 +3107,8 @@\n-  if (n1op == Op_Add(bt)) {\n-    return TruncatedIncrement{n1, t1, t2, trunc_t};\n+  if (n1op == Op_Add(_bt)) {\n+    _incr = n1;\n+    _trunc1 = t1;\n+    _trunc2 = t2;\n+    _trunc_type = trunc_t;\n+\n+    _is_valid = true;\n+    return true;\n@@ -2937,1 +3118,1 @@\n-  return TruncatedIncrement{};\n+  return false;\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":264,"deletions":83,"binary":false,"changes":347,"status":"modified"},{"patch":"@@ -277,6 +277,25 @@\n-  \/\/ TODO: convert to class???\n-  struct TruncatedIncrement {\n-    Node* incr = nullptr;\n-    Node* trunc1 = nullptr;\n-    Node* trunc2 = nullptr;\n-    const TypeInteger* trunc_type = nullptr;\n+  class TruncatedIncrement {\n+    bool _is_valid = false;\n+\n+    Node* _expr;\n+    BasicType _bt;\n+\n+    Node* _incr = nullptr;\n+    Node* _trunc1 = nullptr;\n+    Node* _trunc2 = nullptr;\n+    const TypeInteger* _trunc_type = nullptr;\n+\n+  public:\n+    explicit TruncatedIncrement() = default;\n+\n+    TruncatedIncrement(Node* expr, BasicType bt) :\n+      _expr(expr),\n+      _bt(bt) {}\n+\n+    bool build();\n+\n+    bool is_valid() const { return _is_valid; }\n+    Node* incr() const { return _incr; }\n+    Node* trunc1() const { return _trunc1; }\n+    Node* trunc2() const { return _trunc2; }\n+    const TypeInteger* trunc_type() const { return _trunc_type; }\n@@ -284,1 +303,0 @@\n-  static TruncatedIncrement match_incr_with_optional_truncation(Node* expr, BasicType bt);\n@@ -1326,39 +1344,2 @@\n-    bool build() {\n-      const Node* iftrue = _back_control;\n-      uint iftrue_op = iftrue->Opcode();\n-      Node* iff = iftrue->in(0);\n-      BoolNode* test = iff->in(1)->as_Bool();\n-      _mask = test->_test._test;\n-      _cl_prob = iff->as_If()->_prob;\n-      if (iftrue_op == Op_IfFalse) {\n-        _mask = BoolTest(_mask).negate();\n-        _cl_prob = 1.0f - _cl_prob;\n-      }\n-      \/\/ Get backedge compare\n-      _cmp = test->in(1);\n-      if (!_cmp->is_Cmp()) {\n-        return false;\n-      }\n-\n-      \/\/ Find the trip-counter increment & limit.  Limit must be loop invariant.\n-      _incr  = _cmp->in(1);\n-      _limit = _cmp->in(2);\n-\n-      \/\/ ---------\n-      \/\/ need 'loop()' test to tell if limit is loop invariant\n-      \/\/ ---------\n-\n-      if (!_phase->is_member(_loop, _phase->get_ctrl(_incr))) { \/\/ Swapped trip counter and limit?\n-        swap(_incr, _limit);                \/\/ Then reverse order into the CmpI\n-        _mask = BoolTest(_mask).commute(); \/\/ And commute the exit test\n-      }\n-      if (_phase->is_member(_loop, _phase->get_ctrl(_limit))) { \/\/ Limit must be loop-invariant\n-        return false;\n-      }\n-      if (!_phase->is_member(_loop, _phase->get_ctrl(_incr))) { \/\/ Trip counter must be loop-variant\n-        return false;\n-      }\n-\n-      _is_valid = true;\n-      return true;\n-    }\n+    bool build();\n+    bool canonicalize_mask(jlong stride_con);\n@@ -1370,0 +1351,2 @@\n+    bool should_include_limit() const { return _mask == BoolTest::le || _mask == BoolTest::ge; }\n+\n@@ -1375,27 +1358,0 @@\n-\n-    \/\/ Canonicalize the loop condition if it is 'ne'.\n-    bool canonicalize_mask(jlong stride_con) {\n-      if (_mask != BoolTest::ne) {\n-        return false;\n-      }\n-\n-      assert(stride_con == 1 || stride_con == -1, \"simple increment only - checked in CountedLoopConverter\");\n-\n-      if (stride_con == 1) {\n-        \/\/ 'ne' can be replaced with 'lt' only when init < limit.\n-        \/\/ This is ensured by the inserted predicate in CountedLoopConverter.\n-        \/\/ TODO: assert on inserted predicate?\n-        _mask = BoolTest::lt;\n-        return true;\n-      }\n-\n-      if (stride_con == -1) {\n-        \/\/ 'ne' can be replaced with 'gt' only when init > limit.\n-        \/\/ This is ensured by the inserted predicate in CountedLoopConverter.\n-        _mask = BoolTest::gt;\n-        return true;\n-      }\n-\n-      \/\/ Should not reach\n-      return false;\n-    }\n@@ -1422,19 +1378,1 @@\n-    bool build() {\n-      Node* incr = _old_incr;\n-      if (incr->is_Phi() && incr->as_Phi()->region() == _head && incr->req() == 3) { \/\/ Requires simple trip counter expression\n-        Node* phi_incr = incr;\n-        Node* back_control = phi_incr->in(LoopNode::LoopBackControl); \/\/ Assume incr is on backedge of Phi\n-        if (_loop->_phase->is_member(_loop, _loop->_phase->get_ctrl(back_control))) { \/\/ Trip counter must be loop-variant\n-          _incr = back_control;\n-          _phi_incr = phi_incr;\n-\n-          _is_valid = true;\n-          return true;\n-        }\n-      }\n-      _incr = incr;\n-      _phi_incr = nullptr;\n-\n-      _is_valid = true;\n-      return true;\n-    }\n+    bool build();\n@@ -1463,16 +1401,1 @@\n-    bool build() {\n-      assert(_incr->Opcode() == Op_AddI || _incr->Opcode() == Op_AddL, \"caller resp.\");\n-      \/\/ Get merge point\n-      _xphi = _incr->in(1);\n-      _node = _incr->in(2);\n-      if (!_node->is_Con()) {     \/\/ Oops, swap these\n-        if (!_xphi->is_Con()) {     \/\/ Is the other guy a constant?\n-          return false;            \/\/ Nope, unknown stride, bail out\n-        }\n-\n-        swap(_xphi, _node);        \/\/ 'incr' is commutative, so ok to swap\n-      }\n-\n-      _is_valid = true;\n-      return true;\n-    }\n+    bool build();\n@@ -1481,1 +1404,0 @@\n-\n@@ -1485,23 +1407,1 @@\n-    jlong compute_non_zero_stride_con(const BoolTest::mask mask, const BasicType iv_bt) const {\n-      jlong stride_con = node()->get_integer_as_long(iv_bt);\n-      assert(stride_con != 0, \"missed some peephole opt\"); \/\/ stride constant can never be 0!\n-\n-      \/\/ If the condition is inverted and we will be rolling\n-      \/\/ through MININT to MAXINT, then bail out.\n-      if (mask == BoolTest::eq || \/\/ Bail out, but this loop trips at most twice!\n-          \/\/ Odd stride\n-          (mask == BoolTest::ne && stride_con != 1 && stride_con != -1) ||\n-          \/\/ Count down loop rolls through MAXINT\n-          ((mask == BoolTest::le || mask == BoolTest::lt) && stride_con < 0) ||\n-          \/\/ Count up loop rolls through MININT\n-          ((mask == BoolTest::ge || mask == BoolTest::gt) && stride_con > 0)) {\n-        return 0; \/\/ Bail out with sentinel = 0\n-      }\n-\n-      \/\/ Bail out if the stride is too big.\n-      if (stride_con == min_signed_integer(iv_bt) || (ABS(stride_con) > max_signed_integer(iv_bt) \/ 2)) {\n-        return 0;\n-      }\n-\n-      return stride_con;\n-    }\n+    jlong compute_non_zero_stride_con(BoolTest::mask mask, BasicType iv_bt) const;\n@@ -2153,52 +2053,1 @@\n-    bool build() {\n-      _back_control = _phase->loop_exit_control(_head, _loop);\n-      if (_back_control == nullptr) {\n-        return false;\n-      }\n-\n-      _exit_test = PhaseIdealLoop::LoopExitTest(_back_control, _loop, _phase);\n-      _exit_test.build();\n-      if (!_exit_test.is_valid_with_bt(_iv_bt)) {\n-        return false; \/\/ Avoid pointer & float & 64-bit compares\n-      }\n-\n-      Node* incr = _exit_test.incr();\n-      if (_exit_test.incr()->Opcode() == Op_Cast(_iv_bt)) {\n-        incr = incr->in(1);\n-      }\n-\n-      _iv_incr = PhaseIdealLoop::LoopIVIncr(incr, _head, _loop);\n-      _iv_incr.build();\n-      if (_iv_incr.incr() == nullptr) {\n-        return false;\n-      }\n-\n-      _truncated_increment = CountedLoopNode::match_incr_with_optional_truncation(_iv_incr.incr(), _iv_bt);\n-      if (_truncated_increment.incr == nullptr) {\n-        return false; \/\/ Funny increment opcode\n-      }\n-      assert(_truncated_increment.incr->Opcode() == Op_Add(_iv_bt), \"wrong increment code\");\n-\n-      _stride = PhaseIdealLoop::LoopIVStride(_truncated_increment.incr);\n-      _stride.build();\n-      if (!_stride.is_valid()) {\n-        return false;\n-      }\n-\n-      Node* xphi = _stride.xphi();\n-      \/\/ Iteratively uncast the loop induction variable\n-      \/\/ until no more CastII\/CastLL nodes are found.\n-      while (xphi->Opcode() == Op_Cast(_iv_bt)) {\n-        xphi = xphi->in(1);\n-      }\n-\n-      _phi = PhaseIdealLoop::loop_iv_phi(xphi, _iv_incr.phi_incr(), _head);\n-      if (_phi == nullptr ||\n-          (_truncated_increment.trunc1 == nullptr && _phi->in(LoopNode::LoopBackControl) != _truncated_increment.incr) ||\n-          (_truncated_increment.trunc1 != nullptr && _phi->in(LoopNode::LoopBackControl) != _truncated_increment.trunc1)) {\n-        return false;\n-      }\n-\n-      _sfpt = _loop->_child == nullptr\n-                              ? _phase->find_safepoint(_back_control, _head, _loop)\n-                              : _back_control->in(0)->in(0)->isa_SafePoint();\n+    bool build();\n@@ -2206,3 +2055,2 @@\n-      _is_valid = true;\n-      return true;\n-    }\n+    \/\/ compute adjusted loop limit correction\n+    jlong final_limit_correction() const;\n@@ -2222,4 +2070,0 @@\n-  bool _includes_limit = false;\n-  jlong _stride_con = 0;\n-  jlong _final_correction = 0;\n-\n@@ -2240,7 +2084,3 @@\n-  bool is_iv_overflowing(const TypeInteger* init_t, jlong stride_con, Node* phi_increment, BoolTest::mask mask);\n-  bool is_infinite_loop(const Node* increment_trunc1, const TypeInteger* limit_t, const Node* incr);\n-  bool has_truncation_wrap(Node* increment_trunc1,\n-                           Node* increment_trunc2,\n-                           const TypeInteger* trunc_type,\n-                           Node* phi,\n-                           jlong stride_con);\n+  bool is_iv_overflowing(const TypeInteger* init_t, jlong stride_con, Node* phi_increment, BoolTest::mask mask) const;\n+  bool is_infinite_loop(const Node* increment_trunc1, const TypeInteger* limit_t, const Node* incr) const;\n+  bool has_truncation_wrap(CountedLoopNode::TruncatedIncrement truncation, Node* phi, jlong stride_con);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":38,"deletions":198,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -2828,3 +2828,4 @@\n-      CountedLoopNode::TruncatedIncrement add = CountedLoopNode::match_incr_with_optional_truncation(in, T_INT);\n-      if (add.incr != nullptr && add.incr->in(1) == phi) {\n-        add2 = add.incr->in(2);\n+      CountedLoopNode::TruncatedIncrement add(in, T_INT);\n+      add.build();\n+      if (add.is_valid() && add.incr()->in(1) == phi) {\n+        add2 = add.incr()->in(2);\n@@ -2837,3 +2838,4 @@\n-    CountedLoopNode::TruncatedIncrement add = CountedLoopNode::match_incr_with_optional_truncation(addtrunc, T_INT);\n-    if (add.incr != nullptr && add.incr->in(1)->is_Phi()) {\n-      Node* phi = add.incr->in(1);\n+    CountedLoopNode::TruncatedIncrement add(addtrunc, T_INT);\n+    add.build();\n+    if (add.is_valid() && add.incr()->in(1)->is_Phi()) {\n+      Node* phi = add.incr()->in(1);\n@@ -2842,1 +2844,1 @@\n-          add2 = add.incr->in(2);\n+          add2 = add.incr()->in(2);\n@@ -4266,2 +4268,3 @@\n-      CountedLoopNode::TruncatedIncrement increment = CountedLoopNode::match_incr_with_optional_truncation(loop_exit.incr()->in(i), T_INT);\n-      if (increment.incr == nullptr) {\n+      CountedLoopNode::TruncatedIncrement increment(loop_exit.incr()->in(i), T_INT);\n+      increment.build();\n+      if (!increment.is_valid()) {\n@@ -4270,1 +4273,1 @@\n-      assert(increment.incr->Opcode() == Op_AddI, \"wrong increment code\");\n+      assert(increment.incr()->Opcode() == Op_AddI, \"wrong increment code\");\n@@ -4272,1 +4275,1 @@\n-      LoopIVStride stride(increment.incr);\n+      LoopIVStride stride(increment.incr());\n@@ -4280,2 +4283,2 @@\n-          (increment.trunc1 == nullptr && phi->in(LoopNode::LoopBackControl) != loop_exit.incr()) ||\n-          (increment.trunc1 != nullptr && phi->in(LoopNode::LoopBackControl) != increment.trunc1)) {\n+          (increment.trunc1() == nullptr && phi->in(LoopNode::LoopBackControl) != loop_exit.incr()) ||\n+          (increment.trunc1() != nullptr && phi->in(LoopNode::LoopBackControl) != increment.trunc1())) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"}]}