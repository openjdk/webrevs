{"files":[{"patch":"@@ -1499,1 +1499,1 @@\n-      _increment_truncation_type == TypeInt::INT; \/\/ Only stress an int loop (i.e., not char, byte or short)\n+      _structure.trunc_type == TypeInt::INT; \/\/ Only stress an int loop (i.e., not char, byte or short)\n@@ -1509,1 +1509,1 @@\n-  iv_nodes.push(_cmp);\n+  iv_nodes.push(_structure.cmp);\n@@ -1586,1 +1586,1 @@\n-  _phase->set_ctrl(old_new[_phi->_idx], _phi->in(0));\n+  _phase->set_ctrl(old_new[_structure.phi->_idx], _structure.phi->in(0));\n@@ -1632,2 +1632,2 @@\n-  Node* back_control = _phase->loop_exit_control(_head, _loop);\n-  if (back_control == nullptr) {\n+  LoopStructure structure{};\n+  if (!build_loop_structure(structure)) {\n@@ -1637,22 +1637,2 @@\n-  PhaseIdealLoop::LoopExitTest exit_test = _phase->loop_exit_test(back_control, _loop);\n-  if (exit_test.cmp == nullptr || exit_test.cmp->Opcode() != Op_Cmp(_iv_bt)) {\n-    return false; \/\/ Avoid pointer & float & 64-bit compares\n-  }\n-\n-  \/\/ Trip-counter increment must be commutative & associative.\n-  Node* incr = exit_test.incr;\n-  if (exit_test.incr->Opcode() == Op_Cast(_iv_bt)) {\n-    incr = incr->in(1);\n-  }\n-\n-  const PhaseIdealLoop::LoopIVIncr iv_incr = PhaseIdealLoop::loop_iv_incr(incr, _head, _loop);\n-  if (iv_incr.incr == nullptr) {\n-    return false;\n-  }\n-\n-  CountedLoopNode::TruncatedIncrement increment = CountedLoopNode::match_incr_with_optional_truncation(iv_incr.incr, _iv_bt);\n-  if (increment.incr == nullptr) {\n-    return false; \/\/ Funny increment opcode\n-  }\n-\n-  assert(increment.incr->Opcode() == Op_Add(_iv_bt), \"wrong increment code\");\n+  \/\/ =================================================\n+  \/\/ ---- Is the loop trip counted? ----\n@@ -1660,2 +1640,3 @@\n-  const PhaseIdealLoop::LoopIvStride stride = PhaseIdealLoop::loop_iv_stride(increment.incr);\n-  if (stride.stride == nullptr) {\n+  \/\/ Check trip counter will end up higher than the limit\n+  const TypeInteger* limit_t = igvn->type(structure.limit)->is_integer(_iv_bt);\n+  if (is_infinite_loop(structure.trunc1, limit_t, structure.iv_incr)) {\n@@ -1665,5 +1646,0 @@\n-  Node* xphi = stride.xphi;\n-  if (xphi->Opcode() == Op_Cast(_iv_bt)) {\n-    xphi = xphi->in(1);\n-  }\n-\n@@ -1671,1 +1647,1 @@\n-  jlong stride_con = stride.stride->get_integer_as_long(_iv_bt);\n+  jlong stride_con = structure.stride->get_integer_as_long(_iv_bt);\n@@ -1673,6 +1649,1 @@\n-\n-  PhiNode* phi = PhaseIdealLoop::loop_iv_phi(xphi, iv_incr.phi_incr, _head);\n-\n-  if (phi == nullptr ||\n-      (increment.trunc1 == nullptr && phi->in(LoopNode::LoopBackControl) != increment.incr) ||\n-      (increment.trunc1 != nullptr && phi->in(LoopNode::LoopBackControl) != increment.trunc1)) {\n+  if (!condition_stride_ok(structure.mask, stride_con)) {\n@@ -1682,69 +1653,2 @@\n-  const Node* iftrue = back_control;\n-  uint iftrue_op = iftrue->Opcode();\n-  Node* iff = iftrue->in(0);\n-  BoolNode* test = iff->in(1)->as_Bool();\n-\n-  const TypeInteger* limit_t = igvn->type(exit_test.limit)->is_integer(_iv_bt);\n-  if (increment.trunc1 != nullptr) {\n-    \/\/ When there is a truncation, we must be sure that after the truncation\n-    \/\/ the trip counter will end up higher than the limit, otherwise we are looking\n-    \/\/ at an endless loop. Can happen with range checks.\n-\n-    \/\/ Example:\n-    \/\/ int i = 0;\n-    \/\/ while (true)\n-    \/\/    sum + = array[i];\n-    \/\/    i++;\n-    \/\/    i = i && 0x7fff;\n-    \/\/  }\n-    \/\/\n-    \/\/ If the array is shorter than 0x8000 this exits through a AIOOB\n-    \/\/  - Counted loop transformation is ok\n-    \/\/ If the array is longer then this is an endless loop\n-    \/\/  - No transformation can be done.\n-\n-    const TypeInteger* incr_t = igvn->type(iv_incr.incr)->is_integer(_iv_bt);\n-    if (limit_t->hi_as_long() > incr_t->hi_as_long()) {\n-      \/\/ if the limit can have a higher value than the increment (before the0 phi)\n-      return false;\n-    }\n-  }\n-\n-  Node* init_trip = phi->in(LoopNode::EntryControl);\n-\n-  \/\/ If iv trunc type is smaller than int, check for possible wrap.\n-  if (!TypeInteger::bottom(_iv_bt)->higher_equal(increment.trunc_type)) {\n-    assert(increment.trunc1 != nullptr, \"must have found some truncation\");\n-\n-    \/\/ Get a better type for the phi (filtered thru if's)\n-    const TypeInteger* phi_ft = filtered_type(phi);\n-\n-    \/\/ Can iv take on a value that will wrap?\n-    \/\/\n-    \/\/ Ensure iv's limit is not within \"stride\" of the wrap value.\n-    \/\/\n-    \/\/ Example for \"short\" type\n-    \/\/    Truncation ensures value is in the range -32768..32767 (iv_trunc_t)\n-    \/\/    If the stride is +10, then the last value of the induction\n-    \/\/    variable before the increment (phi_ft->_hi) must be\n-    \/\/    <= 32767 - 10 and (phi_ft->_lo) must be >= -32768 to\n-    \/\/    ensure no truncation occurs after the increment.\n-\n-    if (stride_con > 0) {\n-      if (increment.trunc_type->hi_as_long() - phi_ft->hi_as_long() < stride_con ||\n-          increment.trunc_type->lo_as_long() > phi_ft->lo_as_long()) {\n-        return false;  \/\/ truncation may occur\n-      }\n-    } else if (stride_con < 0) {\n-      if (increment.trunc_type->lo_as_long() - phi_ft->lo_as_long() > stride_con ||\n-          increment.trunc_type->hi_as_long() < phi_ft->hi_as_long()) {\n-        return false;  \/\/ truncation may occur\n-      }\n-    }\n-    \/\/ No possibility of wrap so truncation can be discarded\n-    \/\/ Promote iv type to Int\n-  } else {\n-    assert(increment.trunc1 == nullptr && increment.trunc2 == nullptr, \"no truncation for int\");\n-  }\n-\n-  if (!condition_stride_ok(exit_test.mask, stride_con)) {\n+  \/\/ Check iv type can be promoted to int for short\/char\/byte loops\n+  if (has_truncation_wrap(structure.trunc1, structure.trunc2, structure.trunc_type, structure.phi, stride_con)) {\n@@ -1754,0 +1658,1 @@\n+  Node* init_trip = structure.phi->in(LoopNode::EntryControl);\n@@ -1755,21 +1660,2 @@\n-  if (stride_con > 0) {\n-    if (init_t->lo_as_long() > max_signed_integer(_iv_bt) - stride_con) {\n-      return false; \/\/ cyclic loop\n-    }\n-  } else {\n-    if (init_t->hi_as_long() < min_signed_integer(_iv_bt) - stride_con) {\n-      return false; \/\/ cyclic loop\n-    }\n-  }\n-\n-  if (iv_incr.phi_incr != nullptr && exit_test.mask != BoolTest::ne) {\n-    \/\/ check if there is a possibility of IV overflowing after the first increment\n-    if (stride_con > 0) {\n-      if (init_t->hi_as_long() > max_signed_integer(_iv_bt) - stride_con) {\n-        return false;\n-      }\n-    } else {\n-      if (init_t->lo_as_long() < min_signed_integer(_iv_bt) - stride_con) {\n-        return false;\n-      }\n-    }\n+  if (is_iv_overflowing(init_t, stride_con, structure.phi_incr, structure.mask)) {\n+    return false;\n@@ -1780,1 +1666,0 @@\n-  \/\/\n@@ -1992,1 +1877,1 @@\n-  const jlong limit_correction_for_pre_iv_exit_check = (iv_incr.phi_incr != nullptr) ? stride_con : 0;\n+  const jlong limit_correction_for_pre_iv_exit_check = (structure.phi_incr != nullptr) ? stride_con : 0;\n@@ -1995,1 +1880,1 @@\n-  const bool includes_limit = (exit_test.mask == BoolTest::le || exit_test.mask == BoolTest::ge);\n+  const bool includes_limit = (structure.mask == BoolTest::le || structure.mask == BoolTest::ge);\n@@ -2033,1 +1918,1 @@\n-    if (!_phase->is_dominator(_phase->get_ctrl(exit_test.limit), loop_limit_check_parse_predicate->in(0))) {\n+    if (!_phase->is_dominator(_phase->get_ctrl(structure.limit), loop_limit_check_parse_predicate->in(0))) {\n@@ -2043,1 +1928,2 @@\n-          (stride_con < 0 && init_t->lo_as_long() < min_signed_integer(_iv_bt) - stride_con);\n+      (stride_con < 0 && init_t->lo_as_long() < min_signed_integer(_iv_bt) - stride_con);\n+\n@@ -2045,1 +1931,2 @@\n-  const bool init_gte_limit = (stride_con > 0 && init_t->hi_as_long() >= limit_t->lo_as_long()) ||\n+  const bool init_gte_limit =\n+      (stride_con > 0 && init_t->hi_as_long() >= limit_t->lo_as_long()) ||\n@@ -2050,1 +1937,1 @@\n-      ((exit_test.mask == BoolTest::ne || init_plus_stride_could_overflow) && \/\/ (2.3)\n+      ((structure.mask == BoolTest::ne || init_plus_stride_could_overflow) && \/\/ (2.3)\n@@ -2052,1 +1939,1 @@\n-                                           exit_test.limit,\n+                                           structure.limit,\n@@ -2079,1 +1966,1 @@\n-    if (!_phase->is_dominator(_phase->get_ctrl(exit_test.limit), parse_predicate_entry) ||\n+    if (!_phase->is_dominator(_phase->get_ctrl(structure.limit), parse_predicate_entry) ||\n@@ -2087,2 +1974,1 @@\n-  BoolTest::mask mask = exit_test.mask;\n-  if (mask == BoolTest::ne) {\n+  if (structure.mask == BoolTest::ne) {\n@@ -2093,1 +1979,1 @@\n-      mask = BoolTest::lt;\n+      structure.mask = BoolTest::lt;\n@@ -2097,11 +1983,1 @@\n-      mask = BoolTest::gt;\n-    }\n-  }\n-\n-  Node* sfpt = nullptr;\n-  if (_loop->_child == nullptr) {\n-    sfpt = _phase->find_safepoint(back_control, _head, _loop);\n-  } else {\n-    sfpt = iff->in(0);\n-    if (sfpt->Opcode() != Op_SafePoint) {\n-      sfpt = nullptr;\n+      structure.mask = BoolTest::gt;\n@@ -2111,10 +1987,2 @@\n-  if (_head->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n-    if (((_iv_bt == T_INT && LoopStripMiningIter != 0) ||\n-        _iv_bt == T_LONG) &&\n-        sfpt == nullptr) {\n-      \/\/ Leaving the safepoint on the backedge and creating a\n-      \/\/ CountedLoop will confuse optimizations. We can't move the\n-      \/\/ safepoint around because its jvm state wouldn't match a new\n-      \/\/ location. Give up on that loop.\n-      return false;\n-    }\n+  if (is_safepoint_invalid(structure.sfpt, structure.back_control)) {\n+    return false;\n@@ -2124,2 +1992,3 @@\n-  \/\/ This way the is_counted_loop() can run multiple times with possibly different configurations.\n-  _limit = exit_test.limit;\n+  \/\/ This way the is_counted_loop() can run multiple times with possibly different structures.\n+  _structure = structure;\n+\n@@ -2128,3 +1997,0 @@\n-  _phi = phi;\n-  _phi_increment = iv_incr.phi_incr;\n-  _stride = stride.stride;\n@@ -2132,6 +1998,0 @@\n-  _mask = mask;\n-  _increment = increment.incr;\n-  _cmp = exit_test.cmp;\n-  _cl_prob = exit_test.cl_prob;\n-  _sfpt = sfpt;\n-  _increment_truncation_type = increment.trunc_type;\n@@ -2149,0 +2009,210 @@\n+bool CountedLoopConverter::build_loop_structure(CountedLoopConverter::LoopStructure& structure) {\n+  PhaseIterGVN* igvn = &_phase->igvn();\n+\n+  Node* back_control = _phase->loop_exit_control(_head, _loop);\n+  if (back_control == nullptr) {\n+    return false;\n+  }\n+\n+  PhaseIdealLoop::LoopExitTest exit_test = _phase->loop_exit_test(back_control, _loop);\n+  if (exit_test.cmp == nullptr || exit_test.cmp->Opcode() != Op_Cmp(_iv_bt)) {\n+    return false; \/\/ Avoid pointer & float & 64-bit compares\n+  }\n+\n+  Node* incr = exit_test.incr;\n+  if (exit_test.incr->Opcode() == Op_Cast(_iv_bt)) {\n+    incr = incr->in(1);\n+  }\n+\n+  const PhaseIdealLoop::LoopIVIncr iv_incr = PhaseIdealLoop::loop_iv_incr(incr, _head, _loop);\n+  if (iv_incr.incr == nullptr) {\n+    return false;\n+  }\n+\n+  CountedLoopNode::TruncatedIncrement\n+      increment = CountedLoopNode::match_incr_with_optional_truncation(iv_incr.incr, _iv_bt);\n+  if (increment.incr == nullptr) {\n+    return false; \/\/ Funny increment opcode\n+  }\n+  assert(increment.incr->Opcode() == Op_Add(_iv_bt), \"wrong increment code\");\n+\n+  const PhaseIdealLoop::LoopIvStride stride = PhaseIdealLoop::loop_iv_stride(increment.incr);\n+  if (stride.stride == nullptr) {\n+    return false;\n+  }\n+\n+  Node* xphi = stride.xphi;\n+  if (xphi->Opcode() == Op_Cast(_iv_bt)) {\n+    xphi = xphi->in(1);\n+  }\n+\n+  PhiNode* phi = PhaseIdealLoop::loop_iv_phi(xphi, iv_incr.phi_incr, _head);\n+  if (phi == nullptr ||\n+      (increment.trunc1 == nullptr && phi->in(LoopNode::LoopBackControl) != increment.incr) ||\n+      (increment.trunc1 != nullptr && phi->in(LoopNode::LoopBackControl) != increment.trunc1)) {\n+    return false;\n+  }\n+\n+  SafePointNode* sfpt = find_safepoint(back_control);\n+\n+  structure.back_control = back_control;\n+\n+  structure.cmp = exit_test.cmp;\n+  structure.incr = incr;\n+  structure.limit = exit_test.limit;\n+  structure.mask = exit_test.mask;\n+  structure.cl_prob = exit_test.cl_prob;\n+\n+  structure.iv_incr = iv_incr.incr;\n+  structure.phi_incr = iv_incr.phi_incr;\n+\n+  structure.trunc_incr = increment.incr;\n+  structure.trunc1 = increment.trunc1;\n+  structure.trunc2 = increment.trunc2;\n+  structure.trunc_type = increment.trunc_type;\n+\n+  structure.stride = stride.stride;\n+\n+  structure.phi = phi;\n+\n+  structure.sfpt = sfpt;\n+\n+  return true;\n+}\n+\n+bool CountedLoopConverter::is_iv_overflowing(const TypeInteger* init_t, jlong stride_con, Node* phi_increment,\n+                                             BoolTest::mask mask) {\n+  if (stride_con > 0) {\n+    if (init_t->lo_as_long() > max_signed_integer(_iv_bt) - stride_con) {\n+      return true; \/\/ cyclic loop\n+    }\n+  } else {\n+    if (init_t->hi_as_long() < min_signed_integer(_iv_bt) - stride_con) {\n+      return true; \/\/ cyclic loop\n+    }\n+  }\n+\n+  if (phi_increment != nullptr && mask != BoolTest::ne) {\n+    \/\/ check if there is a possibility of IV overflowing after the first increment\n+    if (stride_con > 0) {\n+      if (init_t->hi_as_long() > max_signed_integer(_iv_bt) - stride_con) {\n+        return true;\n+      }\n+    } else {\n+      if (init_t->lo_as_long() < min_signed_integer(_iv_bt) - stride_con) {\n+        return true;\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool CountedLoopConverter::is_infinite_loop(const Node* increment_trunc1,\n+                                            const TypeInteger* limit_t,\n+                                            const Node* incr) {\n+  PhaseIterGVN& igvn = _phase->igvn();\n+\n+  if (increment_trunc1 != nullptr) {\n+    \/\/ When there is a truncation, we must be sure that after the truncation\n+    \/\/ the trip counter will end up higher than the limit, otherwise we are looking\n+    \/\/ at an endless loop. Can happen with range checks.\n+\n+    \/\/ Example:\n+    \/\/ int i = 0;\n+    \/\/ while (true)\n+    \/\/    sum + = array[i];\n+    \/\/    i++;\n+    \/\/    i = i && 0x7fff;\n+    \/\/  }\n+    \/\/\n+    \/\/ If the array is shorter than 0x8000 this exits through a AIOOB\n+    \/\/  - Counted loop transformation is ok\n+    \/\/ If the array is longer then this is an endless loop\n+    \/\/  - No transformation can be done.\n+\n+    const TypeInteger* incr_t = igvn.type(incr)->is_integer(_iv_bt);\n+    if (limit_t->hi_as_long() > incr_t->hi_as_long()) {\n+      \/\/ if the limit can have a higher value than the increment (before the0 phi)\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool CountedLoopConverter::has_truncation_wrap(Node* increment_trunc1,\n+                                               Node* increment_trunc2,\n+                                               const TypeInteger* trunc_type,\n+                                               Node* phi,\n+                                               jlong stride_con) {\n+  \/\/ If iv trunc type is smaller than int (i.e., short\/char\/byte), check for possible wrap.\n+  if (!TypeInteger::bottom(_iv_bt)->higher_equal(trunc_type)) {\n+    assert(increment_trunc1 != nullptr, \"must have found some truncation\");\n+\n+    \/\/ Get a better type for the phi (filtered thru if's)\n+    const TypeInteger* phi_ft = filtered_type(phi);\n+\n+    \/\/ Can iv take on a value that will wrap?\n+    \/\/\n+    \/\/ Ensure iv's limit is not within \"stride\" of the wrap value.\n+    \/\/\n+    \/\/ Example for \"short\" type\n+    \/\/    Truncation ensures value is in the range -32768..32767 (iv_trunc_t)\n+    \/\/    If the stride is +10, then the last value of the induction\n+    \/\/    variable before the increment (phi_ft->_hi) must be\n+    \/\/    <= 32767 - 10 and (phi_ft->_lo) must be >= -32768 to\n+    \/\/    ensure no truncation occurs after the increment.\n+\n+    if (stride_con > 0) {\n+      if (trunc_type->hi_as_long() - phi_ft->hi_as_long() < stride_con ||\n+          trunc_type->lo_as_long() > phi_ft->lo_as_long()) {\n+        return true;  \/\/ truncation may occur\n+      }\n+    } else if (stride_con < 0) {\n+      if (trunc_type->lo_as_long() - phi_ft->lo_as_long() > stride_con ||\n+          trunc_type->hi_as_long() < phi_ft->hi_as_long()) {\n+        return true;  \/\/ truncation may occur\n+      }\n+    }\n+\n+    \/\/ No possibility of wrap so truncation can be discarded\n+    \/\/ Promote iv type to Int\n+  } else {\n+    assert(Type::equals(trunc_type, TypeInt::INT) || Type::equals(trunc_type, TypeLong::LONG),\n+           \"unexpected truncation type\");\n+    assert(increment_trunc1 == nullptr && increment_trunc2 == nullptr, \"no truncation for int\");\n+  }\n+\n+  return false;\n+}\n+\n+SafePointNode* CountedLoopConverter::find_safepoint(Node* iftrue) {\n+  uint iftrue_op = iftrue->Opcode();\n+  Node* iff = iftrue->in(0);\n+\n+  if (_loop->_child == nullptr) {\n+    return _phase->find_safepoint(iftrue, _head, _loop);\n+  } else {\n+    return iff->in(0)->isa_SafePoint();\n+  }\n+}\n+\n+bool CountedLoopConverter::is_safepoint_invalid(SafePointNode* sfpt, Node* iftrue) {\n+  Node* iff = iftrue->in(0);\n+\n+  if (_head->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n+    if (((_iv_bt == T_INT && LoopStripMiningIter != 0) ||\n+        _iv_bt == T_LONG) &&\n+        sfpt == nullptr) {\n+      \/\/ Leaving the safepoint on the backedge and creating a\n+      \/\/ CountedLoop will confuse optimizations. We can't move the\n+      \/\/ safepoint around because its jvm state wouldn't match a new\n+      \/\/ location. Give up on that loop.\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n@@ -2158,1 +2228,1 @@\n-    Node* cmp_limit = CmpNode::make(_limit, igvn->integercon((_stride_con > 0\n+    Node* cmp_limit = CmpNode::make(_structure.limit, igvn->integercon((_stride_con > 0\n@@ -2166,1 +2236,1 @@\n-  Node* init_trip = _phi->in(LoopNode::EntryControl);\n+  Node* init_trip = _structure.phi->in(LoopNode::EntryControl);\n@@ -2168,1 +2238,1 @@\n-    Node* cmp_limit = CmpNode::make(init_trip, _limit, _iv_bt);\n+    Node* cmp_limit = CmpNode::make(init_trip, _structure.limit, _iv_bt);\n@@ -2185,2 +2255,2 @@\n-  Node* adjusted_limit = _limit;\n-  if (_phi_increment != nullptr) {\n+  Node* adjusted_limit = _structure.limit;\n+  if (_structure.phi_incr != nullptr) {\n@@ -2196,1 +2266,1 @@\n-    adjusted_limit = igvn->transform(AddNode::make(_limit, _stride, _iv_bt));\n+    adjusted_limit = igvn->transform(AddNode::make(_structure.limit, _structure.stride, _iv_bt));\n@@ -2199,1 +2269,1 @@\n-  BoolTest::mask mask = _mask;\n+  BoolTest::mask mask = _structure.mask;\n@@ -2214,0 +2284,1 @@\n+  _phase->set_subtree_ctrl(adjusted_limit, false);\n@@ -2217,3 +2288,3 @@\n-  Node* incr = _increment->clone();\n-  incr->set_req(1, _phi);\n-  incr->set_req(2, _stride);\n+  Node* incr = _structure.trunc_incr->clone();\n+  incr->set_req(1, _structure.phi);\n+  incr->set_req(2, _structure.stride);\n@@ -2222,2 +2293,2 @@\n-  igvn->rehash_node_delayed(_phi);\n-  _phi->set_req_X(LoopNode::LoopBackControl, incr, igvn);\n+  igvn->rehash_node_delayed(_structure.phi);\n+  _structure.phi->set_req_X(LoopNode::LoopBackControl, incr, igvn);\n@@ -2228,4 +2299,5 @@\n-  Node* phi = _phi;\n-  if (!TypeInteger::bottom(_iv_bt)->higher_equal(_phi->bottom_type())) {\n-    Node* nphi = PhiNode::make(_phi->in(0), _phi->in(LoopNode::EntryControl), TypeInteger::bottom(_iv_bt));\n-    nphi->set_req(LoopNode::LoopBackControl, _phi->in(LoopNode::LoopBackControl));\n+  Node* phi = _structure.phi;\n+  if (!TypeInteger::bottom(_iv_bt)->higher_equal(_structure.phi->bottom_type())) {\n+    Node* nphi =\n+        PhiNode::make(_structure.phi->in(0), _structure.phi->in(LoopNode::EntryControl), TypeInteger::bottom(_iv_bt));\n+    nphi->set_req(LoopNode::LoopBackControl, _structure.phi->in(LoopNode::LoopBackControl));\n@@ -2234,1 +2306,1 @@\n-    igvn->replace_node(_phi, nphi);\n+    igvn->replace_node(_structure.phi, nphi);\n@@ -2241,1 +2313,1 @@\n-  Node* cmp = _cmp->clone();\n+  Node* cmp = _structure.cmp->clone();\n@@ -2257,1 +2329,1 @@\n-                                                                                  _cl_prob,\n+                                                                                  _structure.cl_prob,\n@@ -2299,1 +2371,1 @@\n-      _sfpt != nullptr &&\n+      _structure.sfpt != nullptr &&\n@@ -2301,1 +2373,1 @@\n-      _phase->is_deleteable_safept(_sfpt);\n+      _phase->is_deleteable_safept(_structure.sfpt);\n@@ -2304,1 +2376,6 @@\n-    outer_ilt = _phase->create_outer_strip_mined_loop(init_control, _loop, _cl_prob, le->_fcnt, entry_control, iffalse);\n+    outer_ilt = _phase->create_outer_strip_mined_loop(init_control,\n+                                                      _loop,\n+                                                      _structure.cl_prob,\n+                                                      le->_fcnt,\n+                                                      entry_control,\n+                                                      iffalse);\n@@ -2324,1 +2401,1 @@\n-    if (_sfpt != nullptr && (strip_mine_loop || _phase->is_deleteable_safept(_sfpt))) {\n+    if (_structure.sfpt != nullptr && (strip_mine_loop || _phase->is_deleteable_safept(_structure.sfpt))) {\n@@ -2327,1 +2404,1 @@\n-        Node* sfpt_clone = _sfpt->clone();\n+        Node* sfpt_clone = _structure.sfpt->clone();\n@@ -2345,1 +2422,1 @@\n-      _phase->lazy_replace(_sfpt, _sfpt->in(TypeFunc::Control));\n+      _phase->lazy_replace(_structure.sfpt, _structure.sfpt->in(TypeFunc::Control));\n@@ -2347,1 +2424,1 @@\n-        _loop->_safepts->yank(_sfpt);\n+        _loop->_safepts->yank(_structure.sfpt);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":278,"deletions":201,"binary":false,"changes":479,"status":"modified"},{"patch":"@@ -1842,1 +1842,1 @@\n-  Node* const _head; \/\/ FIXME: type to LoopNode?\n+  Node* const _head;\n@@ -1853,14 +1853,30 @@\n-  \/\/ To be assigned once a counted loop is confirmed.\n-  Node* _limit;\n-  jlong _stride_con;\n-  Node* _phi;\n-  Node* _phi_increment;\n-  Node* _stride;\n-  bool _includes_limit;\n-  BoolTest::mask _mask;\n-  Node* _increment;\n-  Node* _cmp;\n-  float _cl_prob;\n-  Node* _sfpt;\n-  jlong _final_correction;\n-  const TypeInteger* _increment_truncation_type;\n+  struct LoopStructure {\n+    Node* back_control;\n+\n+    CmpNode* cmp;\n+    Node* incr;\n+    Node* limit;\n+    BoolTest::mask mask;\n+    float cl_prob;\n+\n+    Node* iv_incr;\n+    Node* phi_incr;\n+\n+    Node* trunc_incr;\n+    Node* trunc1;\n+    Node* trunc2;\n+    const TypeInteger* trunc_type;\n+\n+    Node* stride;\n+\n+    PhiNode* phi;\n+\n+    SafePointNode* sfpt;\n+  };\n+\n+  LoopStructure _structure{};\n+\n+  bool _includes_limit = false;\n+  jlong _stride_con = 0;\n+  jlong _final_correction = 0;\n+\n@@ -1871,2 +1887,2 @@\n-  const TypeInt* filtered_type( Node *n, Node* n_ctrl);\n-  const TypeInt* filtered_type( Node *n ) { return filtered_type(n, nullptr); }\n+  const TypeInt* filtered_type(Node* n, Node* n_ctrl);\n+  const TypeInt* filtered_type(Node* n) { return filtered_type(n, nullptr); }\n@@ -1874,1 +1890,1 @@\n-  const TypeInt* filtered_type_from_dominators( Node* val, Node *val_ctrl);\n+  const TypeInt* filtered_type_from_dominators(Node* val, Node* val_ctrl);\n@@ -1881,0 +1897,12 @@\n+  bool build_loop_structure(LoopStructure& structure);\n+\n+  bool is_iv_overflowing(const TypeInteger* init_t, jlong stride_con, Node* phi_increment, BoolTest::mask mask);\n+  bool is_infinite_loop(const Node* increment_trunc1, const TypeInteger* limit_t, const Node* incr);\n+  bool has_truncation_wrap(Node* increment_trunc1,\n+                           Node* increment_trunc2,\n+                           const TypeInteger* trunc_type,\n+                           Node* phi,\n+                           jlong stride_con);\n+  SafePointNode* find_safepoint(Node* iftrue);\n+  bool is_safepoint_invalid(SafePointNode* sfpt, Node* iftrue);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":46,"deletions":18,"binary":false,"changes":64,"status":"modified"}]}