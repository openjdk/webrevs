{"files":[{"patch":"@@ -442,64 +442,0 @@\n-PhaseIdealLoop::LoopExitTest PhaseIdealLoop::loop_exit_test(const Node* back_control, const IdealLoopTree* loop) {\n-  const Node* iftrue = back_control;\n-  uint iftrue_op = iftrue->Opcode();\n-  Node* iff = iftrue->in(0);\n-  BoolNode* test = iff->in(1)->as_Bool();\n-  BoolTest::mask bt = test->_test._test;\n-  float cl_prob = iff->as_If()->_prob;\n-  if (iftrue_op == Op_IfFalse) {\n-    bt = BoolTest(bt).negate();\n-    cl_prob = 1.0f - cl_prob;\n-  }\n-  \/\/ Get backedge compare\n-  Node* cmp = test->in(1);\n-  if (!cmp->is_Cmp()) {\n-    return {};\n-  }\n-\n-  \/\/ Find the trip-counter increment & limit.  Limit must be loop invariant.\n-  Node* incr  = cmp->in(1);\n-  Node* limit = cmp->in(2);\n-\n-  \/\/ ---------\n-  \/\/ need 'loop()' test to tell if limit is loop invariant\n-  \/\/ ---------\n-\n-  if (!is_member(loop, get_ctrl(incr))) { \/\/ Swapped trip counter and limit?\n-    swap(incr, limit);                \/\/ Then reverse order into the CmpI\n-    bt = BoolTest(bt).commute(); \/\/ And commute the exit test\n-  }\n-  if (is_member(loop, get_ctrl(limit))) { \/\/ Limit must be loop-invariant\n-    return {};\n-  }\n-  if (!is_member(loop, get_ctrl(incr))) { \/\/ Trip counter must be loop-variant\n-    return {};\n-  }\n-  return {cmp->as_Cmp(), incr, limit, bt, cl_prob};\n-}\n-\n-PhaseIdealLoop::LoopIVIncr PhaseIdealLoop::loop_iv_incr(Node* incr, const Node* head, const IdealLoopTree* loop) {\n-  if (incr->is_Phi() && incr->as_Phi()->region() == head && incr->req() == 3) { \/\/ Requires simple trip counter expression\n-    Node* phi_incr = incr;\n-    Node* back_control = phi_incr->in(LoopNode::LoopBackControl); \/\/ Assume incr is on backedge of Phi\n-    if (loop->_phase->is_member(loop, loop->_phase->get_ctrl(back_control))) { \/\/ Trip counter must be loop-variant\n-      return {back_control, phi_incr};\n-    }\n-  }\n-  return {incr, nullptr};\n-}\n-\n-PhaseIdealLoop::LoopIvStride PhaseIdealLoop::loop_iv_stride(const Node* incr) {\n-  assert(incr->Opcode() == Op_AddI || incr->Opcode() == Op_AddL, \"caller resp.\");\n-  \/\/ Get merge point\n-  Node* xphi = incr->in(1);\n-  Node *stride = incr->in(2);\n-  if (!stride->is_Con()) {     \/\/ Oops, swap these\n-    if (!xphi->is_Con()) {     \/\/ Is the other guy a constant?\n-      return {};               \/\/ Nope, unknown stride, bail out\n-    }\n-\n-    swap(xphi, stride);        \/\/ 'incr' is commutative, so ok to swap\n-  }\n-  return {stride, xphi};\n-}\n-\n@@ -541,15 +477,0 @@\n-static bool condition_stride_ok(BoolTest::mask bt, jlong stride_con) {\n-  \/\/ If the condition is inverted and we will be rolling\n-  \/\/ through MININT to MAXINT, then bail out.\n-  if (bt == BoolTest::eq || \/\/ Bail out, but this loop trips at most twice!\n-      \/\/ Odd stride\n-      (bt == BoolTest::ne && stride_con != 1 && stride_con != -1) ||\n-      \/\/ Count down loop rolls through MAXINT\n-      ((bt == BoolTest::le || bt == BoolTest::lt) && stride_con < 0) ||\n-      \/\/ Count up loop rolls through MININT\n-      ((bt == BoolTest::ge || bt == BoolTest::gt) && stride_con > 0)) {\n-    return false; \/\/ Bail out\n-  }\n-  return true;\n-}\n-\n@@ -1716,2 +1637,3 @@\n-  LoopExitTest exit_test = loop_exit_test(back_control, loop);\n-  assert(exit_test.cmp != nullptr && exit_test.cmp->Opcode() == Op_Cmp(bt), \"no exit test\");\n+  LoopExitTest exit_test(back_control, loop, this);\n+  exit_test.build();\n+  assert(exit_test.is_valid_with_bt(bt), \"no exit test\");\n@@ -1719,2 +1641,3 @@\n-  const LoopIVIncr iv_incr = loop_iv_incr(exit_test.incr, x, loop);\n-  assert(iv_incr.incr != nullptr && iv_incr.incr->Opcode() == Op_Add(bt), \"no incr\");\n+  LoopIVIncr iv_incr(exit_test.incr(), x, loop);\n+  iv_incr.build();\n+  assert(iv_incr.is_valid_with_bt(bt), \"no incr\");\n@@ -1722,2 +1645,3 @@\n-  LoopIvStride stride = loop_iv_stride(iv_incr.incr);\n-  assert(stride.stride != nullptr, \"no stride\");\n+  LoopIVStride stride(iv_incr.incr());\n+  stride.build();\n+  assert(stride.is_valid(), \"no stride\");\n@@ -1725,2 +1649,2 @@\n-  PhiNode* phi = loop_iv_phi(stride.xphi, iv_incr.phi_incr, x);\n-  assert(phi != nullptr && phi->in(LoopNode::LoopBackControl) == iv_incr.incr, \"No phi\");\n+  PhiNode* phi = loop_iv_phi(stride.xphi(), iv_incr.phi_incr(), x);\n+  assert(phi != nullptr && phi->in(LoopNode::LoopBackControl) == iv_incr.incr(), \"No phi\");\n@@ -1728,2 +1652,1 @@\n-  jlong stride_con = stride.stride->get_integer_as_long(bt);\n-  assert(condition_stride_ok(exit_test.mask, stride_con), \"illegal condition\");\n+  assert(stride.compute_non_zero_stride_con(exit_test.mask(), bt), \"illegal condition\");\n@@ -1731,3 +1654,3 @@\n-  assert(exit_test.mask != BoolTest::ne, \"unexpected condition\");\n-  assert(iv_incr.phi_incr == nullptr, \"bad loop shape\");\n-  assert(exit_test.cmp->in(1) == iv_incr.incr, \"bad exit test shape\");\n+  assert(exit_test.mask() != BoolTest::ne, \"unexpected condition\");\n+  assert(iv_incr.phi_incr() == nullptr, \"bad loop shape\");\n+  assert(exit_test.cmp()->in(1) == iv_incr.incr(), \"bad exit test shape\");\n@@ -1742,1 +1665,1 @@\n-bool CountedLoopConverter::should_stress_long_counted_loop() const {\n+bool CountedLoopConverter::should_stress_long_counted_loop() {\n@@ -1748,1 +1671,1 @@\n-      _structure.trunc_type == TypeInt::INT; \/\/ Only stress an int loop (i.e., not char, byte or short)\n+      _structure.truncated_increment().trunc_type == TypeInt::INT; \/\/ Only stress an int loop (i.e., not char, byte or short)\n@@ -1752,1 +1675,1 @@\n-bool CountedLoopConverter::stress_long_counted_loop() const {\n+bool CountedLoopConverter::stress_long_counted_loop() {\n@@ -1758,1 +1681,1 @@\n-  iv_nodes.push(_structure.cmp);\n+  iv_nodes.push(_structure.exit_test().cmp());\n@@ -1835,1 +1758,1 @@\n-  _phase->set_ctrl(old_new[_structure.phi->_idx], _structure.phi->in(0));\n+  _phase->set_ctrl(old_new[_structure.phi()->_idx], _structure.phi()->in(0));\n@@ -1881,2 +1804,3 @@\n-  LoopStructure structure{};\n-  if (!build_loop_structure(structure)) {\n+  _structure = LoopStructure(_head, _loop, _phase, _iv_bt);\n+  _structure.build();\n+  if (!_structure.is_valid()) {\n@@ -1890,2 +1814,2 @@\n-  const TypeInteger* limit_t = igvn->type(structure.limit)->is_integer(_iv_bt);\n-  if (is_infinite_loop(structure.trunc1, limit_t, structure.iv_incr)) {\n+  const TypeInteger* limit_t = igvn->type(_structure.exit_test().limit())->is_integer(_iv_bt);\n+  if (is_infinite_loop(_structure.truncated_increment().trunc1, limit_t, _structure.iv_incr().incr())) {\n@@ -1896,3 +1820,2 @@\n-  jlong stride_con = structure.stride->get_integer_as_long(_iv_bt);\n-  assert(stride_con != 0, \"missed some peephole opt\");\n-  if (!condition_stride_ok(structure.mask, stride_con)) {\n+  const jlong stride_con = _structure.stride().compute_non_zero_stride_con(_structure.exit_test().mask(), _iv_bt);\n+  if (stride_con == 0) {\n@@ -1903,1 +1826,6 @@\n-  if (has_truncation_wrap(structure.trunc1, structure.trunc2, structure.trunc_type, structure.phi, stride_con)) {\n+  if (has_truncation_wrap(\n+    _structure.truncated_increment().trunc1,\n+    _structure.truncated_increment().trunc2,\n+    _structure.truncated_increment().trunc_type,\n+    _structure.phi(),\n+    stride_con)) {\n@@ -1907,1 +1835,2 @@\n-  Node* init_trip = structure.phi->in(LoopNode::EntryControl);\n+  \/\/ Check iv is not overflowing\n+  Node* init_trip = _structure.phi()->in(LoopNode::EntryControl);\n@@ -1909,1 +1838,1 @@\n-  if (is_iv_overflowing(init_t, stride_con, structure.phi_incr, structure.mask)) {\n+  if (is_iv_overflowing(init_t, stride_con, _structure.iv_incr().phi_incr(), _structure.exit_test().mask())) {\n@@ -2120,5 +2049,0 @@\n-  \/\/ Check (vi) and bail out if the stride is too big.\n-  if (stride_con == min_signed_integer(_iv_bt) || (ABS(stride_con) > max_signed_integer(_iv_bt) \/ 2)) {\n-    return false;\n-  }\n-\n@@ -2126,1 +2050,1 @@\n-  const jlong limit_correction_for_pre_iv_exit_check = (structure.phi_incr != nullptr) ? stride_con : 0;\n+  const jlong limit_correction_for_pre_iv_exit_check = (_structure.iv_incr().phi_incr() != nullptr) ? stride_con : 0;\n@@ -2129,1 +2053,1 @@\n-  const bool includes_limit = (structure.mask == BoolTest::le || structure.mask == BoolTest::ge);\n+  const bool includes_limit = (_structure.exit_test().mask() == BoolTest::le || _structure.exit_test().mask() == BoolTest::ge);\n@@ -2167,1 +2091,1 @@\n-    if (!_phase->is_dominator(_phase->get_ctrl(structure.limit), loop_limit_check_parse_predicate->in(0))) {\n+    if (!_phase->is_dominator(_phase->get_ctrl(_structure.exit_test().limit()), loop_limit_check_parse_predicate->in(0))) {\n@@ -2186,1 +2110,1 @@\n-      ((structure.mask == BoolTest::ne || init_plus_stride_could_overflow) && \/\/ (2.3)\n+      ((_structure.exit_test().mask() == BoolTest::ne || init_plus_stride_could_overflow) && \/\/ (2.3)\n@@ -2188,1 +2112,1 @@\n-                                           structure.limit,\n+                                           _structure.exit_test().limit(),\n@@ -2215,1 +2139,1 @@\n-    if (!_phase->is_dominator(_phase->get_ctrl(structure.limit), parse_predicate_entry) ||\n+    if (!_phase->is_dominator(_phase->get_ctrl(_structure.exit_test().limit()), parse_predicate_entry) ||\n@@ -2223,12 +2147,1 @@\n-  if (structure.mask == BoolTest::ne) {\n-    \/\/ Now we need to canonicalize the loop condition if it is 'ne'.\n-    assert(stride_con == 1 || stride_con == -1, \"simple increment only - checked before\");\n-    if (stride_con > 0) {\n-      \/\/ 'ne' can be replaced with 'lt' only when init < limit. This is ensured by the inserted predicate above.\n-      structure.mask = BoolTest::lt;\n-    } else {\n-      assert(stride_con < 0, \"must be\");\n-      \/\/ 'ne' can be replaced with 'gt' only when init > limit. This is ensured by the inserted predicate above.\n-      structure.mask = BoolTest::gt;\n-    }\n-  }\n+  _structure.exit_test().canonicalize_mask(stride_con);\n@@ -2236,1 +2149,1 @@\n-  if (is_safepoint_invalid(structure.sfpt, structure.back_control)) {\n+  if (is_safepoint_invalid(_structure.sfpt())) {\n@@ -2242,1 +2155,0 @@\n-  _structure = structure;\n@@ -2258,76 +2170,0 @@\n-bool CountedLoopConverter::build_loop_structure(CountedLoopConverter::LoopStructure& structure) {\n-  PhaseIterGVN* igvn = &_phase->igvn();\n-\n-  Node* back_control = _phase->loop_exit_control(_head, _loop);\n-  if (back_control == nullptr) {\n-    return false;\n-  }\n-\n-  PhaseIdealLoop::LoopExitTest exit_test = _phase->loop_exit_test(back_control, _loop);\n-  if (exit_test.cmp == nullptr || exit_test.cmp->Opcode() != Op_Cmp(_iv_bt)) {\n-    return false; \/\/ Avoid pointer & float & 64-bit compares\n-  }\n-\n-  Node* incr = exit_test.incr;\n-  if (exit_test.incr->Opcode() == Op_Cast(_iv_bt)) {\n-    incr = incr->in(1);\n-  }\n-\n-  const PhaseIdealLoop::LoopIVIncr iv_incr = PhaseIdealLoop::loop_iv_incr(incr, _head, _loop);\n-  if (iv_incr.incr == nullptr) {\n-    return false;\n-  }\n-\n-  CountedLoopNode::TruncatedIncrement\n-      increment = CountedLoopNode::match_incr_with_optional_truncation(iv_incr.incr, _iv_bt);\n-  if (increment.incr == nullptr) {\n-    return false; \/\/ Funny increment opcode\n-  }\n-  assert(increment.incr->Opcode() == Op_Add(_iv_bt), \"wrong increment code\");\n-\n-  const PhaseIdealLoop::LoopIvStride stride = PhaseIdealLoop::loop_iv_stride(increment.incr);\n-  if (stride.stride == nullptr) {\n-    return false;\n-  }\n-\n-  Node* xphi = stride.xphi;\n-  \/\/ Iteratively uncast the loop induction variable\n-  \/\/ until no more CastII\/CastLL nodes are found.\n-  while (xphi->Opcode() == Op_Cast(_iv_bt)) {\n-    xphi = xphi->in(1);\n-  }\n-\n-  PhiNode* phi = PhaseIdealLoop::loop_iv_phi(xphi, iv_incr.phi_incr, _head);\n-  if (phi == nullptr ||\n-      (increment.trunc1 == nullptr && phi->in(LoopNode::LoopBackControl) != increment.incr) ||\n-      (increment.trunc1 != nullptr && phi->in(LoopNode::LoopBackControl) != increment.trunc1)) {\n-    return false;\n-  }\n-\n-  SafePointNode* sfpt = find_safepoint(back_control);\n-\n-  structure.back_control = back_control;\n-\n-  structure.cmp = exit_test.cmp;\n-  structure.incr = incr;\n-  structure.limit = exit_test.limit;\n-  structure.mask = exit_test.mask;\n-  structure.cl_prob = exit_test.cl_prob;\n-\n-  structure.iv_incr = iv_incr.incr;\n-  structure.phi_incr = iv_incr.phi_incr;\n-\n-  structure.trunc_incr = increment.incr;\n-  structure.trunc1 = increment.trunc1;\n-  structure.trunc2 = increment.trunc2;\n-  structure.trunc_type = increment.trunc_type;\n-\n-  structure.stride = stride.stride;\n-\n-  structure.phi = phi;\n-\n-  structure.sfpt = sfpt;\n-\n-  return true;\n-}\n-\n@@ -2442,1 +2278,0 @@\n-  uint iftrue_op = iftrue->Opcode();\n@@ -2447,2 +2282,0 @@\n-  } else {\n-    return iff->in(0)->isa_SafePoint();\n@@ -2450,1 +2283,0 @@\n-}\n@@ -2452,2 +2284,2 @@\n-bool CountedLoopConverter::is_safepoint_invalid(SafePointNode* sfpt, Node* iftrue) {\n-  Node* iff = iftrue->in(0);\n+  return iff->in(0)->isa_SafePoint();\n+}\n@@ -2455,0 +2287,1 @@\n+bool CountedLoopConverter::is_safepoint_invalid(SafePointNode* sfpt) {\n@@ -2479,1 +2312,1 @@\n-    Node* cmp_limit = CmpNode::make(_structure.limit, igvn->integercon((_stride_con > 0\n+    Node* cmp_limit = CmpNode::make(_structure.exit_test().limit(), igvn->integercon((_stride_con > 0\n@@ -2487,1 +2320,1 @@\n-  Node* init_trip = _structure.phi->in(LoopNode::EntryControl);\n+  Node* init_trip = _structure.phi()->in(LoopNode::EntryControl);\n@@ -2489,1 +2322,1 @@\n-    Node* cmp_limit = CmpNode::make(init_trip, _structure.limit, _iv_bt);\n+    Node* cmp_limit = CmpNode::make(init_trip, _structure.exit_test().limit(), _iv_bt);\n@@ -2506,2 +2339,2 @@\n-  Node* adjusted_limit = _structure.limit;\n-  if (_structure.phi_incr != nullptr) {\n+  Node* adjusted_limit = _structure.exit_test().limit();\n+  if (_structure.iv_incr().phi_incr() != nullptr) {\n@@ -2517,1 +2350,1 @@\n-    adjusted_limit = igvn->transform(AddNode::make(_structure.limit, _structure.stride, _iv_bt));\n+    adjusted_limit = igvn->transform(AddNode::make(_structure.exit_test().limit(), _structure.stride().node(), _iv_bt));\n@@ -2520,1 +2353,1 @@\n-  BoolTest::mask mask = _structure.mask;\n+  BoolTest::mask mask = _structure.exit_test().mask();\n@@ -2539,3 +2372,3 @@\n-  Node* incr = _structure.trunc_incr->clone();\n-  incr->set_req(1, _structure.phi);\n-  incr->set_req(2, _structure.stride);\n+  Node* incr = _structure.truncated_increment().incr->clone();\n+  incr->set_req(1, _structure.phi());\n+  incr->set_req(2, _structure.stride().node());\n@@ -2544,2 +2377,2 @@\n-  igvn->rehash_node_delayed(_structure.phi);\n-  _structure.phi->set_req_X(LoopNode::LoopBackControl, incr, igvn);\n+  igvn->rehash_node_delayed(_structure.phi());\n+  _structure.phi()->set_req_X(LoopNode::LoopBackControl, incr, igvn);\n@@ -2550,2 +2383,2 @@\n-  Node* phi = _structure.phi;\n-  if (!TypeInteger::bottom(_iv_bt)->higher_equal(_structure.phi->bottom_type())) {\n+  Node* phi = _structure.phi();\n+  if (!TypeInteger::bottom(_iv_bt)->higher_equal(_structure.phi()->bottom_type())) {\n@@ -2553,2 +2386,2 @@\n-        PhiNode::make(_structure.phi->in(0), _structure.phi->in(LoopNode::EntryControl), TypeInteger::bottom(_iv_bt));\n-    nphi->set_req(LoopNode::LoopBackControl, _structure.phi->in(LoopNode::LoopBackControl));\n+        PhiNode::make(_structure.phi()->in(0), _structure.phi()->in(LoopNode::EntryControl), TypeInteger::bottom(_iv_bt));\n+    nphi->set_req(LoopNode::LoopBackControl, _structure.phi()->in(LoopNode::LoopBackControl));\n@@ -2557,1 +2390,1 @@\n-    igvn->replace_node(_structure.phi, nphi);\n+    igvn->replace_node(_structure.phi(), nphi);\n@@ -2564,1 +2397,1 @@\n-  Node* cmp = _structure.cmp->clone();\n+  Node* cmp = _structure.exit_test().cmp()->clone();\n@@ -2580,1 +2413,1 @@\n-                                                                                  _structure.cl_prob,\n+                                                                                  _structure.exit_test().cl_prob(),\n@@ -2622,1 +2455,1 @@\n-      _structure.sfpt != nullptr &&\n+      _structure.sfpt() != nullptr &&\n@@ -2624,1 +2457,1 @@\n-      _phase->is_deleteable_safept(_structure.sfpt);\n+      _phase->is_deleteable_safept(_structure.sfpt());\n@@ -2629,1 +2462,1 @@\n-                                                      _structure.cl_prob,\n+                                                      _structure.exit_test().cl_prob(),\n@@ -2652,1 +2485,1 @@\n-    if (_structure.sfpt != nullptr && (strip_mine_loop || _phase->is_deleteable_safept(_structure.sfpt))) {\n+    if (_structure.sfpt() != nullptr && (strip_mine_loop || _phase->is_deleteable_safept(_structure.sfpt()))) {\n@@ -2655,1 +2488,1 @@\n-        Node* sfpt_clone = _structure.sfpt->clone();\n+        Node* sfpt_clone = _structure.sfpt()->clone();\n@@ -2673,1 +2506,1 @@\n-      _phase->lazy_replace(_structure.sfpt, _structure.sfpt->in(TypeFunc::Control));\n+      _phase->lazy_replace(_structure.sfpt(), _structure.sfpt()->in(TypeFunc::Control));\n@@ -2675,1 +2508,1 @@\n-        _loop->_safepts->yank(_structure.sfpt);\n+        _loop->_safepts->yank(_structure.sfpt());\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":73,"deletions":240,"binary":false,"changes":313,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+#include <bits\/charconv.h>\n+\n@@ -277,0 +279,1 @@\n+  \/\/ TODO: convert to class???\n@@ -1304,6 +1307,97 @@\n-  struct LoopExitTest {\n-    CmpNode* cmp = nullptr;\n-    Node* incr = nullptr;\n-    Node* limit = nullptr;\n-    const BoolTest::mask mask = BoolTest::illegal;\n-    const float cl_prob = 0.0f;\n+  class LoopExitTest {\n+    bool _is_valid = false;\n+\n+    const Node* _back_control;\n+    const IdealLoopTree* _loop;\n+    PhaseIdealLoop* _phase;\n+\n+    Node* _cmp = nullptr;\n+    Node* _incr = nullptr;\n+    Node* _limit = nullptr;\n+    BoolTest::mask _mask = BoolTest::illegal;\n+    float _cl_prob = 0.0f;\n+\n+  public:\n+    explicit LoopExitTest() = default;\n+\n+    LoopExitTest(const Node* back_control, const IdealLoopTree* loop, PhaseIdealLoop* phase) :\n+      _back_control(back_control),\n+      _loop(loop),\n+      _phase(phase) {}\n+\n+    bool build() {\n+      const Node* iftrue = _back_control;\n+      uint iftrue_op = iftrue->Opcode();\n+      Node* iff = iftrue->in(0);\n+      BoolNode* test = iff->in(1)->as_Bool();\n+      _mask = test->_test._test;\n+      _cl_prob = iff->as_If()->_prob;\n+      if (iftrue_op == Op_IfFalse) {\n+        _mask = BoolTest(_mask).negate();\n+        _cl_prob = 1.0f - _cl_prob;\n+      }\n+      \/\/ Get backedge compare\n+      _cmp = test->in(1);\n+      if (!_cmp->is_Cmp()) {\n+        return false;\n+      }\n+\n+      \/\/ Find the trip-counter increment & limit.  Limit must be loop invariant.\n+      _incr  = _cmp->in(1);\n+      _limit = _cmp->in(2);\n+\n+      \/\/ ---------\n+      \/\/ need 'loop()' test to tell if limit is loop invariant\n+      \/\/ ---------\n+\n+      if (!_phase->is_member(_loop, _phase->get_ctrl(_incr))) { \/\/ Swapped trip counter and limit?\n+        swap(_incr, _limit);                \/\/ Then reverse order into the CmpI\n+        _mask = BoolTest(_mask).commute(); \/\/ And commute the exit test\n+      }\n+      if (_phase->is_member(_loop, _phase->get_ctrl(_limit))) { \/\/ Limit must be loop-invariant\n+        return false;\n+      }\n+      if (!_phase->is_member(_loop, _phase->get_ctrl(_incr))) { \/\/ Trip counter must be loop-variant\n+        return false;\n+      }\n+\n+      _is_valid = true;\n+      return true;\n+    }\n+\n+    bool is_valid_with_bt(BasicType bt) {\n+      return _is_valid && _cmp != nullptr && _cmp->Opcode() == Op_Cmp(bt);\n+    }\n+\n+    CmpNode* cmp() const { return _cmp->as_Cmp(); }\n+    Node* incr() const { return _incr; }\n+    Node* limit() const { return _limit; }\n+    BoolTest::mask mask() const { return _mask; }\n+    float cl_prob() const { return _cl_prob; }\n+\n+    \/\/ Canonicalize the loop condition if it is 'ne'.\n+    bool canonicalize_mask(jlong stride_con) {\n+      if (_mask != BoolTest::ne) {\n+        return false;\n+      }\n+\n+      assert(stride_con == 1 || stride_con == -1, \"simple increment only - checked in CountedLoopConverter\");\n+\n+      if (stride_con == 1) {\n+        \/\/ 'ne' can be replaced with 'lt' only when init < limit.\n+        \/\/ This is ensured by the inserted predicate in CountedLoopConverter.\n+        \/\/ TODO: assert on inserted predicate?\n+        _mask = BoolTest::lt;\n+        return true;\n+      }\n+\n+      if (stride_con == -1) {\n+        \/\/ 'ne' can be replaced with 'gt' only when init > limit.\n+        \/\/ This is ensured by the inserted predicate in CountedLoopConverter.\n+        _mask = BoolTest::gt;\n+        return true;\n+      }\n+\n+      \/\/ Should not reach\n+      return false;\n+    }\n@@ -1311,1 +1405,0 @@\n-  LoopExitTest loop_exit_test(const Node* back_control, const IdealLoopTree* loop);\n@@ -1313,3 +1406,44 @@\n-  struct LoopIVIncr {\n-    Node* incr = nullptr;\n-    Node* phi_incr = nullptr;\n+  class LoopIVIncr {\n+    bool _is_valid = false;\n+\n+    Node* _old_incr;\n+    const Node* _head;\n+    const IdealLoopTree* _loop;\n+\n+    Node* _incr = nullptr;\n+    Node* _phi_incr = nullptr;\n+\n+  public:\n+    explicit LoopIVIncr() = default;\n+\n+    LoopIVIncr(Node* incr, const Node* head, const IdealLoopTree* loop) :\n+      _old_incr(incr),\n+      _head(head),\n+      _loop(loop) {}\n+\n+    bool build() {\n+      Node* incr = _old_incr;\n+      if (incr->is_Phi() && incr->as_Phi()->region() == _head && incr->req() == 3) { \/\/ Requires simple trip counter expression\n+        Node* phi_incr = incr;\n+        Node* back_control = phi_incr->in(LoopNode::LoopBackControl); \/\/ Assume incr is on backedge of Phi\n+        if (_loop->_phase->is_member(_loop, _loop->_phase->get_ctrl(back_control))) { \/\/ Trip counter must be loop-variant\n+          _incr = back_control;\n+          _phi_incr = phi_incr;\n+\n+          _is_valid = true;\n+          return true;\n+        }\n+      }\n+      _incr = incr;\n+      _phi_incr = nullptr;\n+\n+      _is_valid = true;\n+      return true;\n+    }\n+\n+    bool is_valid_with_bt(const BasicType bt) const {\n+      return _is_valid && _incr != nullptr && _incr->Opcode() == Op_Add(bt);\n+    }\n+\n+    Node* incr() const { return _incr; }\n+    Node* phi_incr() const { return _phi_incr; }\n@@ -1317,1 +1451,0 @@\n-  static LoopIVIncr loop_iv_incr(Node* old_incr, const Node* head, const IdealLoopTree* loop);\n@@ -1319,3 +1452,58 @@\n-  struct LoopIvStride {\n-    Node* stride = nullptr;\n-    Node* xphi = nullptr;\n+  class LoopIVStride {\n+    bool _is_valid = false;\n+\n+    const Node* _incr;\n+\n+    Node* _node = nullptr;\n+    Node* _xphi = nullptr;\n+\n+  public:\n+    explicit LoopIVStride() = default;\n+\n+    LoopIVStride(const Node* incr) : _incr(incr) {}\n+\n+    bool build() {\n+      assert(_incr->Opcode() == Op_AddI || _incr->Opcode() == Op_AddL, \"caller resp.\");\n+      \/\/ Get merge point\n+      _xphi = _incr->in(1);\n+      _node = _incr->in(2);\n+      if (!_node->is_Con()) {     \/\/ Oops, swap these\n+        if (!_xphi->is_Con()) {     \/\/ Is the other guy a constant?\n+          return false;            \/\/ Nope, unknown stride, bail out\n+        }\n+\n+        swap(_xphi, _node);        \/\/ 'incr' is commutative, so ok to swap\n+      }\n+\n+      _is_valid = true;\n+      return true;\n+    }\n+\n+    bool is_valid() const { return _is_valid && _node != nullptr; }\n+\n+    Node* node() const { return _node; }\n+    Node* xphi() const { return _xphi; }\n+\n+    jlong compute_non_zero_stride_con(const BoolTest::mask mask, const BasicType iv_bt) const {\n+      jlong stride_con = node()->get_integer_as_long(iv_bt);\n+      assert(stride_con != 0, \"missed some peephole opt\"); \/\/ stride constant can never be 0!\n+\n+      \/\/ If the condition is inverted and we will be rolling\n+      \/\/ through MININT to MAXINT, then bail out.\n+      if (mask == BoolTest::eq || \/\/ Bail out, but this loop trips at most twice!\n+          \/\/ Odd stride\n+          (mask == BoolTest::ne && stride_con != 1 && stride_con != -1) ||\n+          \/\/ Count down loop rolls through MAXINT\n+          ((mask == BoolTest::le || mask == BoolTest::lt) && stride_con < 0) ||\n+          \/\/ Count up loop rolls through MININT\n+          ((mask == BoolTest::ge || mask == BoolTest::gt) && stride_con > 0)) {\n+        return 0; \/\/ Bail out with sentinel = 0\n+      }\n+\n+      \/\/ Bail out if the stride is too big.\n+      if (stride_con == min_signed_integer(iv_bt) || (ABS(stride_con) > max_signed_integer(iv_bt) \/ 2)) {\n+        return 0;\n+      }\n+\n+      return stride_con;\n+    }\n@@ -1323,1 +1511,0 @@\n-  static LoopIvStride loop_iv_stride(const Node* incr);\n@@ -1327,1 +1514,1 @@\n-  bool try_convert_to_counted_loop(Node* head, IdealLoopTree*&loop, const BasicType iv_bt);\n+  bool try_convert_to_counted_loop(Node* head, IdealLoopTree*& loop, BasicType iv_bt);\n@@ -1943,2 +2130,2 @@\n-  struct LoopStructure {\n-    Node* back_control;\n+  class LoopStructure {\n+    bool _is_valid = false;\n@@ -1946,5 +2133,4 @@\n-    CmpNode* cmp;\n-    Node* incr;\n-    Node* limit;\n-    BoolTest::mask mask;\n-    float cl_prob;\n+    const Node* _head;\n+    const IdealLoopTree* _loop;\n+    PhaseIdealLoop* _phase;\n+    BasicType _iv_bt;\n@@ -1952,2 +2138,7 @@\n-    Node* iv_incr;\n-    Node* phi_incr;\n+    Node* _back_control = nullptr;\n+    PhaseIdealLoop::LoopExitTest _exit_test;\n+    PhaseIdealLoop::LoopIVIncr _iv_incr;\n+    CountedLoopNode::TruncatedIncrement _truncated_increment;\n+    PhaseIdealLoop::LoopIVStride _stride;\n+    PhiNode* _phi = nullptr;\n+    SafePointNode* _sfpt = nullptr;\n@@ -1955,4 +2146,2 @@\n-    Node* trunc_incr;\n-    Node* trunc1;\n-    Node* trunc2;\n-    const TypeInteger* trunc_type;\n+  public:\n+    explicit LoopStructure() = default;\n@@ -1960,1 +2149,5 @@\n-    Node* stride;\n+    LoopStructure(const Node* head, const IdealLoopTree* loop, PhaseIdealLoop* phase, const BasicType iv_bt) :\n+      _head(head),\n+      _loop(loop),\n+      _phase(phase),\n+      _iv_bt(iv_bt) {}\n@@ -1962,1 +2155,5 @@\n-    PhiNode* phi;\n+    bool build() {\n+      _back_control = _phase->loop_exit_control(_head, _loop);\n+      if (_back_control == nullptr) {\n+        return false;\n+      }\n@@ -1964,2 +2161,50 @@\n-    SafePointNode* sfpt;\n-  };\n+      _exit_test = PhaseIdealLoop::LoopExitTest(_back_control, _loop, _phase);\n+      _exit_test.build();\n+      if (!_exit_test.is_valid_with_bt(_iv_bt)) {\n+        return false; \/\/ Avoid pointer & float & 64-bit compares\n+      }\n+\n+      Node* incr = _exit_test.incr();\n+      if (_exit_test.incr()->Opcode() == Op_Cast(_iv_bt)) {\n+        incr = incr->in(1);\n+      }\n+\n+      _iv_incr = PhaseIdealLoop::LoopIVIncr(incr, _head, _loop);\n+      _iv_incr.build();\n+      if (_iv_incr.incr() == nullptr) {\n+        return false;\n+      }\n+\n+      _truncated_increment = CountedLoopNode::match_incr_with_optional_truncation(_iv_incr.incr(), _iv_bt);\n+      if (_truncated_increment.incr == nullptr) {\n+        return false; \/\/ Funny increment opcode\n+      }\n+      assert(_truncated_increment.incr->Opcode() == Op_Add(_iv_bt), \"wrong increment code\");\n+\n+      _stride = PhaseIdealLoop::LoopIVStride(_truncated_increment.incr);\n+      _stride.build();\n+      if (!_stride.is_valid()) {\n+        return false;\n+      }\n+\n+      Node* xphi = _stride.xphi();\n+      \/\/ Iteratively uncast the loop induction variable\n+      \/\/ until no more CastII\/CastLL nodes are found.\n+      while (xphi->Opcode() == Op_Cast(_iv_bt)) {\n+        xphi = xphi->in(1);\n+      }\n+\n+      _phi = PhaseIdealLoop::loop_iv_phi(xphi, _iv_incr.phi_incr(), _head);\n+      if (_phi == nullptr ||\n+          (_truncated_increment.trunc1 == nullptr && _phi->in(LoopNode::LoopBackControl) != _truncated_increment.incr) ||\n+          (_truncated_increment.trunc1 != nullptr && _phi->in(LoopNode::LoopBackControl) != _truncated_increment.trunc1)) {\n+        return false;\n+      }\n+\n+      _sfpt = _loop->_child == nullptr\n+                              ? _phase->find_safepoint(_back_control, _head, _loop)\n+                              : _back_control->in(0)->in(0)->isa_SafePoint();\n+\n+      _is_valid = true;\n+      return true;\n+    }\n@@ -1967,1 +2212,11 @@\n-  LoopStructure _structure{};\n+    bool is_valid() const { return _is_valid; }\n+\n+    Node* back_control() const { return _back_control; }\n+    PhaseIdealLoop::LoopExitTest& exit_test() { return _exit_test; }\n+    PhaseIdealLoop::LoopIVIncr& iv_incr() { return _iv_incr; }\n+    CountedLoopNode::TruncatedIncrement& truncated_increment() { return _truncated_increment; }\n+    PhaseIdealLoop::LoopIVStride& stride() { return _stride; }\n+    PhiNode* phi() const { return _phi; }\n+    SafePointNode* sfpt() const { return _sfpt; }\n+  };\n+  LoopStructure _structure;\n@@ -1987,2 +2242,0 @@\n-  bool build_loop_structure(LoopStructure& structure);\n-\n@@ -1997,1 +2250,1 @@\n-  bool is_safepoint_invalid(SafePointNode* sfpt, Node* iftrue);\n+  bool is_safepoint_invalid(SafePointNode* sfpt);\n@@ -2015,2 +2268,2 @@\n-  bool should_stress_long_counted_loop() const;\n-  bool stress_long_counted_loop() const;\n+  bool should_stress_long_counted_loop();\n+  bool stress_long_counted_loop();\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":292,"deletions":39,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -4246,2 +4246,3 @@\n-    LoopExitTest loop_exit = loop_exit_test(back_control, loop);\n-    if (loop_exit.cmp == nullptr || loop_exit.cmp->Opcode() != Op_CmpI) {\n+    LoopExitTest loop_exit(back_control, loop, this);\n+    loop_exit.build();\n+    if (!loop_exit.is_valid_with_bt(T_INT)) {\n@@ -4253,1 +4254,1 @@\n-    if (!loop_exit.incr->is_Phi() || loop_exit.incr->in(0) == head) {\n+    if (!loop_exit.incr()->is_Phi() || loop_exit.incr()->in(0) == head) {\n@@ -4258,1 +4259,1 @@\n-    region = loop_exit.incr->in(0);\n+    region = loop_exit.incr()->in(0);\n@@ -4264,2 +4265,2 @@\n-    for (uint i = 1; i < loop_exit.incr->req(); ++i) {\n-      CountedLoopNode::TruncatedIncrement increment = CountedLoopNode::match_incr_with_optional_truncation(loop_exit.incr->in(i), T_INT);\n+    for (uint i = 1; i < loop_exit.incr()->req(); ++i) {\n+      CountedLoopNode::TruncatedIncrement increment = CountedLoopNode::match_incr_with_optional_truncation(loop_exit.incr()->in(i), T_INT);\n@@ -4270,1 +4271,0 @@\n-      LoopIvStride stride = loop_iv_stride(increment.incr);\n@@ -4272,1 +4272,3 @@\n-      if (stride.stride == nullptr) {\n+      LoopIVStride stride(increment.incr);\n+      stride.build();\n+      if (!stride.is_valid()) {\n@@ -4276,1 +4278,1 @@\n-      PhiNode* phi = loop_iv_phi(stride.xphi, nullptr, head);\n+      PhiNode* phi = loop_iv_phi(stride.xphi(), nullptr, head);\n@@ -4278,1 +4280,1 @@\n-          (increment.trunc1 == nullptr && phi->in(LoopNode::LoopBackControl) != loop_exit.incr) ||\n+          (increment.trunc1 == nullptr && phi->in(LoopNode::LoopBackControl) != loop_exit.incr()) ||\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"}]}