{"files":[{"patch":"@@ -17094,0 +17094,168 @@\n+void Assembler::evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x58, (0xC0 | encode));\n+}\n+\n+void Assembler::evaddph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x58);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5C, (0xC0 | encode));\n+}\n+\n+void Assembler::evsubph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x5C);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x59, (0xC0 | encode));\n+}\n+\n+void Assembler::evmulph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x59);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evminph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5D, (0xC0 | encode));\n+}\n+\n+void Assembler::evminph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x5D);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evmaxph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5F, (0xC0 | encode));\n+}\n+\n+void Assembler::evmaxph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x5F);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5E, (0xC0 | encode));\n+}\n+\n+void Assembler::evdivph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x5E);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evsqrtph(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x51, (0xC0 | encode));\n+}\n+\n+void Assembler::evsqrtph(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x51);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evfmadd132ph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);\n+  emit_int16(0x98, (0xC0 | encode));\n+}\n+\n+void Assembler::evfmadd132ph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);\n+  emit_int8(0x98);\n+  emit_operand(dst, src, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":168,"deletions":0,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2882,0 +2882,18 @@\n+  \/\/ Float16 Vector instructions.\n+  void evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evaddph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evsubph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evdivph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evmulph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evminph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evminph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evmaxph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evmaxph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evfmadd132ph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evfmadd132ph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evsqrtph(XMMRegister dst, XMMRegister src1, int vector_len);\n+  void evsqrtph(XMMRegister dst, Address src1, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -7095,0 +7095,25 @@\n+\n+void C2_MacroAssembler::evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(opcode) {\n+    case Op_AddVHF: evaddph(dst, src1, src2, vlen_enc); break;\n+    case Op_SubVHF: evsubph(dst, src1, src2, vlen_enc); break;\n+    case Op_MulVHF: evmulph(dst, src1, src2, vlen_enc); break;\n+    case Op_DivVHF: evdivph(dst, src1, src2, vlen_enc); break;\n+    case Op_MaxVHF: evmaxph(dst, src1, src2, vlen_enc); break;\n+    case Op_MinVHF: evminph(dst, src1, src2, vlen_enc); break;\n+    default: assert(false, \"%s\", NodeClassNames[opcode]); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc) {\n+  switch(opcode) {\n+    case Op_AddVHF: evaddph(dst, src1, src2, vlen_enc); break;\n+    case Op_SubVHF: evsubph(dst, src1, src2, vlen_enc); break;\n+    case Op_MulVHF: evmulph(dst, src1, src2, vlen_enc); break;\n+    case Op_DivVHF: evdivph(dst, src1, src2, vlen_enc); break;\n+    case Op_MaxVHF: evmaxph(dst, src1, src2, vlen_enc); break;\n+    case Op_MinVHF: evminph(dst, src1, src2, vlen_enc); break;\n+    default: assert(false, \"%s\", NodeClassNames[opcode]); break;\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -587,0 +587,4 @@\n+  void evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1743,0 +1743,12 @@\n+    case Op_AddVHF:\n+    case Op_DivVHF:\n+    case Op_FmaVHF:\n+    case Op_MaxVHF:\n+    case Op_MinVHF:\n+    case Op_MulVHF:\n+    case Op_SubVHF:\n+    case Op_SqrtVHF:\n+      if (!VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -10894,0 +10906,10 @@\n+instruct reinterpretHF2S(rRegI dst, regF src)\n+%{\n+  match(Set dst (ReinterpretHF2S src));\n+  format %{ \"vmovw $dst, $src\" %}\n+  ins_encode %{\n+    __ vmovw($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -10914,10 +10936,0 @@\n-instruct reinterpretHF2S(rRegI dst, regF src)\n-%{\n-  match(Set dst (ReinterpretHF2S src));\n-  format %{ \"vmovw $dst, $src\" %}\n-  ins_encode %{\n-    __ vmovw($dst$$Register, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -10960,0 +10972,83 @@\n+\n+\n+instruct vector_sqrt_HF_reg(vec dst, vec src)\n+%{\n+  match(Set dst (SqrtVHF src));\n+  format %{ \"vector_sqrt_fp16 $dst, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evsqrtph($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_sqrt_HF_mem(vec dst, memory src)\n+%{\n+  match(Set dst (SqrtVHF (VectorReinterpret (LoadVector src))));\n+  format %{ \"vector_sqrt_fp16_mem $dst, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evsqrtph($dst$$XMMRegister, $src$$Address, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_binOps_HF_reg(vec dst, vec src1, vec src2)\n+%{\n+  match(Set dst (AddVHF src1 src2));\n+  match(Set dst (DivVHF src1 src2));\n+  match(Set dst (MaxVHF src1 src2));\n+  match(Set dst (MinVHF src1 src2));\n+  match(Set dst (MulVHF src1 src2));\n+  match(Set dst (SubVHF src1 src2));\n+  format %{ \"vector_binop_fp16 $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opcode = this->ideal_Opcode();\n+    __ evfp16ph(opcode, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+instruct vector_binOps_HF_mem(vec dst, vec src1, memory src2)\n+%{\n+  match(Set dst (AddVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (DivVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (MaxVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (MinVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (MulVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (SubVHF src1 (VectorReinterpret (LoadVector src2))));\n+  format %{ \"vector_binop_fp16_mem $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opcode = this->ideal_Opcode();\n+    __ evfp16ph(opcode, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$Address, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_fma_HF_reg(vec dst, vec src1, vec src2)\n+%{\n+  match(Set dst (FmaVHF src2 (Binary dst src1)));\n+  effect(DEF dst);\n+  format %{ \"vector_fma_fp16 $dst, $src1, $src2\\t# $dst = $dst * $src1 + $src2 fma packedH\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evfmadd132ph($dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_fma_HF_mem(vec dst, memory src1, vec src2)\n+%{\n+  match(Set dst (FmaVHF src2 (Binary dst (VectorReinterpret (LoadVector src1)))));\n+  effect(DEF dst);\n+  format %{ \"vector_fma_fp16_mem $dst, $src1, $src2\\t# $dst = $dst * $src1 + $src2 fma packedH\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evfmadd132ph($dst$$XMMRegister, $src2$$XMMRegister, $src1$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":105,"deletions":10,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -3968,2 +3968,2 @@\n-    \"AddVB\", \"AddVS\", \"AddVI\", \"AddVL\", \"AddVF\", \"AddVD\",\n-    \"MulVB\", \"MulVS\", \"MulVI\", \"MulVL\", \"MulVF\", \"MulVD\",\n+    \"AddVB\", \"AddVS\", \"AddVI\", \"AddVL\", \"AddVHF\", \"AddVF\", \"AddVD\",\n+    \"MulVB\", \"MulVS\", \"MulVI\", \"MulVL\", \"MulVHF\", \"MulVF\", \"MulVD\",\n@@ -3971,1 +3971,1 @@\n-    \"MaxV\", \"MinV\", \"UMax\",\"UMin\"\n+    \"MaxVHF\", \"MinVHF\", \"MaxV\", \"MinV\", \"UMax\",\"UMin\"\n@@ -4340,4 +4340,4 @@\n-    \"AddVB\",\"AddVS\",\"AddVI\",\"AddVL\",\"AddVF\",\"AddVD\",\n-    \"SubVB\",\"SubVS\",\"SubVI\",\"SubVL\",\"SubVF\",\"SubVD\",\n-    \"MulVB\",\"MulVS\",\"MulVI\",\"MulVL\",\"MulVF\",\"MulVD\",\n-    \"DivVF\",\"DivVD\",\n+    \"AddVB\",\"AddVS\",\"AddVI\",\"AddVL\",\"AddVHF\",\"AddVF\",\"AddVD\",\n+    \"SubVB\",\"SubVS\",\"SubVI\",\"SubVL\",\"SubVHF\",\"SubVF\",\"SubVD\",\n+    \"MulVB\",\"MulVS\",\"MulVI\",\"MulVL\",\"MulVHF\",\"MulVF\",\"MulVD\",\n+    \"DivVHF\",\"DivVF\",\"DivVD\",\n@@ -4346,1 +4346,1 @@\n-    \"SqrtVD\",\"SqrtVF\",\n+    \"SqrtVD\",\"SqrtVF\",\"SqrtVHF\",\n@@ -4348,1 +4348,1 @@\n-    \"MaxV\", \"MinV\", \"UMinV\", \"UMaxV\",\n+    \"MaxV\", \"MinV\",\"MinVHF\",\"MaxVHF\",\"UMinV\",\"UMaxV\",\n@@ -4370,1 +4370,1 @@\n-    \"FmaVD\",\"FmaVF\",\"PopCountVI\",\"PopCountVL\",\"PopulateIndex\",\"VectorLongToMask\",\n+    \"FmaVD\",\"FmaVF\",\"FmaVHF\",\"PopCountVI\",\"PopCountVL\",\"PopulateIndex\",\"VectorLongToMask\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -393,0 +393,1 @@\n+macro(AddVHF)\n@@ -401,0 +402,1 @@\n+macro(SubVHF)\n@@ -412,0 +414,1 @@\n+macro(MulVHF)\n@@ -415,0 +418,2 @@\n+macro(FmaVHF)\n+macro(DivVHF)\n@@ -429,0 +434,1 @@\n+macro(SqrtVHF)\n@@ -451,0 +457,2 @@\n+macro(MinVHF)\n+macro(MaxVHF)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2310,0 +2310,1 @@\n+    case Op_FmaVHF:\n@@ -2482,1 +2483,2 @@\n-    case Op_FmaVF: {\n+    case Op_FmaVF:\n+    case Op_FmaVHF: {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2589,0 +2589,1 @@\n+  int opc = n->Opcode();\n@@ -2596,1 +2597,1 @@\n-    if (n->Opcode() == Op_LoadUB) {\n+    if (opc == Op_LoadUB) {\n@@ -2610,1 +2611,1 @@\n-    if (n->Opcode() == Op_ConvF2HF || n->Opcode() == Op_ReinterpretHF2S) {\n+    if (opc == Op_ConvF2HF || opc == Op_ReinterpretHF2S) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+           VectorNode::is_reinterpret_opcode(opc) ||\n@@ -165,2 +166,3 @@\n-           opc == Op_FmaD ||\n-           opc == Op_FmaF ||\n+           opc == Op_FmaD  ||\n+           opc == Op_FmaF  ||\n+           opc == Op_FmaHF ||\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  case Op_AddHF: return (bt == T_SHORT ? Op_AddVHF : 0);\n@@ -62,0 +63,1 @@\n+  case Op_SubHF: return (bt == T_SHORT ? Op_SubVHF : 0);\n@@ -75,0 +77,2 @@\n+  case Op_MulHF:\n+    return (bt == T_SHORT ? Op_MulVHF : 0);\n@@ -83,0 +87,2 @@\n+  case Op_FmaHF:\n+    return (bt == T_SHORT ? Op_FmaVHF : 0);\n@@ -89,0 +95,2 @@\n+  case Op_DivHF:\n+    return (bt == T_SHORT ? Op_DivVHF : 0);\n@@ -115,0 +123,2 @@\n+  case Op_MinHF:\n+    return (bt == T_SHORT ? Op_MinVHF : 0);\n@@ -130,0 +140,2 @@\n+  case Op_MaxHF:\n+    return (bt == T_SHORT ? Op_MaxVHF : 0);\n@@ -157,0 +169,2 @@\n+  case Op_SqrtHF:\n+    return (bt == T_SHORT ? Op_SqrtVHF : 0);\n@@ -269,0 +283,3 @@\n+  case Op_ReinterpretS2HF:\n+  case Op_ReinterpretHF2S:\n+    return Op_VectorReinterpret;\n@@ -381,0 +398,4 @@\n+    case Op_MinVHF:\n+      return Op_MinHF;\n+    case Op_MaxVHF:\n+      return Op_MaxHF;\n@@ -621,4 +642,4 @@\n-  case Op_AddI: case Op_AddL: case Op_AddF: case Op_AddD:\n-  case Op_SubI: case Op_SubL: case Op_SubF: case Op_SubD:\n-  case Op_MulI: case Op_MulL: case Op_MulF: case Op_MulD:\n-  case Op_DivF: case Op_DivD:\n+  case Op_AddI: case Op_AddL: case Op_AddHF: case Op_AddF: case Op_AddD:\n+  case Op_SubI: case Op_SubL: case Op_SubHF: case Op_SubF: case Op_SubD:\n+  case Op_MulI: case Op_MulL: case Op_MulHF: case Op_MulF: case Op_MulD:\n+  case Op_DivHF: case Op_DivF: case Op_DivD:\n@@ -634,0 +655,1 @@\n+  case Op_FmaHF:\n@@ -678,23 +700,27 @@\n-  case Op_AddVB: return new AddVBNode(n1, n2, vt);\n-  case Op_AddVS: return new AddVSNode(n1, n2, vt);\n-  case Op_AddVI: return new AddVINode(n1, n2, vt);\n-  case Op_AddVL: return new AddVLNode(n1, n2, vt);\n-  case Op_AddVF: return new AddVFNode(n1, n2, vt);\n-  case Op_AddVD: return new AddVDNode(n1, n2, vt);\n-\n-  case Op_SubVB: return new SubVBNode(n1, n2, vt);\n-  case Op_SubVS: return new SubVSNode(n1, n2, vt);\n-  case Op_SubVI: return new SubVINode(n1, n2, vt);\n-  case Op_SubVL: return new SubVLNode(n1, n2, vt);\n-  case Op_SubVF: return new SubVFNode(n1, n2, vt);\n-  case Op_SubVD: return new SubVDNode(n1, n2, vt);\n-\n-  case Op_MulVB: return new MulVBNode(n1, n2, vt);\n-  case Op_MulVS: return new MulVSNode(n1, n2, vt);\n-  case Op_MulVI: return new MulVINode(n1, n2, vt);\n-  case Op_MulVL: return new MulVLNode(n1, n2, vt);\n-  case Op_MulVF: return new MulVFNode(n1, n2, vt);\n-  case Op_MulVD: return new MulVDNode(n1, n2, vt);\n-\n-  case Op_DivVF: return new DivVFNode(n1, n2, vt);\n-  case Op_DivVD: return new DivVDNode(n1, n2, vt);\n+  case Op_AddVB:  return new AddVBNode(n1, n2, vt);\n+  case Op_AddVHF: return new AddVHFNode(n1, n2, vt);\n+  case Op_AddVS:  return new AddVSNode(n1, n2, vt);\n+  case Op_AddVI:  return new AddVINode(n1, n2, vt);\n+  case Op_AddVL:  return new AddVLNode(n1, n2, vt);\n+  case Op_AddVF:  return new AddVFNode(n1, n2, vt);\n+  case Op_AddVD:  return new AddVDNode(n1, n2, vt);\n+\n+  case Op_SubVB:  return new SubVBNode(n1, n2, vt);\n+  case Op_SubVS:  return new SubVSNode(n1, n2, vt);\n+  case Op_SubVI:  return new SubVINode(n1, n2, vt);\n+  case Op_SubVL:  return new SubVLNode(n1, n2, vt);\n+  case Op_SubVHF: return new SubVHFNode(n1, n2, vt);\n+  case Op_SubVF:  return new SubVFNode(n1, n2, vt);\n+  case Op_SubVD:  return new SubVDNode(n1, n2, vt);\n+\n+  case Op_MulVB:  return new MulVBNode(n1, n2, vt);\n+  case Op_MulVS:  return new MulVSNode(n1, n2, vt);\n+  case Op_MulVI:  return new MulVINode(n1, n2, vt);\n+  case Op_MulVL:  return new MulVLNode(n1, n2, vt);\n+  case Op_MulVHF: return new MulVHFNode(n1, n2, vt);\n+  case Op_MulVF:  return new MulVFNode(n1, n2, vt);\n+  case Op_MulVD:  return new MulVDNode(n1, n2, vt);\n+\n+  case Op_DivVHF: return new DivVHFNode(n1, n2, vt);\n+  case Op_DivVF:  return new DivVFNode(n1, n2, vt);\n+  case Op_DivVD:  return new DivVDNode(n1, n2, vt);\n@@ -704,0 +730,2 @@\n+  case Op_MinVHF: return new MinVHFNode(n1, n2, vt);\n+  case Op_MaxVHF: return new MaxVHFNode(n1, n2, vt);\n@@ -720,2 +748,3 @@\n-  case Op_SqrtVF: return new SqrtVFNode(n1, vt);\n-  case Op_SqrtVD: return new SqrtVDNode(n1, vt);\n+  case Op_SqrtVHF : return new SqrtVHFNode(n1, vt);\n+  case Op_SqrtVF  : return new SqrtVFNode(n1, vt);\n+  case Op_SqrtVD  : return new SqrtVDNode(n1, vt);\n@@ -805,0 +834,1 @@\n+  case Op_FmaVHF: return new FmaVHFNode(n1, n2, n3, vt);\n@@ -952,0 +982,11 @@\n+\n+bool VectorNode::is_reinterpret_opcode(int opc) {\n+  switch (opc) {\n+    case Op_ReinterpretHF2S:\n+    case Op_ReinterpretS2HF:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n@@ -954,0 +995,1 @@\n+    case Op_SqrtHF:\n@@ -979,0 +1021,4 @@\n+VectorNode* VectorReinterpretNode::make(Node* n, const TypeVect* dst_vt, const TypeVect* src_vt) {\n+  return new VectorReinterpretNode(n, dst_vt, src_vt);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":75,"deletions":29,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -139,0 +139,2 @@\n+  static bool is_reinterpret_opcode(int opc);\n+\n@@ -210,0 +212,8 @@\n+\/\/------------------------------AddVHFNode--------------------------------------\n+\/\/ Vector add float\n+class AddVHFNode : public VectorNode {\n+public:\n+  AddVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -404,0 +414,9 @@\n+\/\/------------------------------SubVHFNode--------------------------------------\n+\/\/ Vector subtract half float\n+class SubVHFNode : public VectorNode {\n+public:\n+  SubVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n+\n@@ -456,0 +475,8 @@\n+\/\/------------------------------MulVFNode--------------------------------------\n+\/\/ Vector multiply half float\n+class MulVHFNode : public VectorNode {\n+public:\n+  MulVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -506,0 +533,8 @@\n+\/\/------------------------------FmaVHFNode-------------------------------------\n+\/\/ Vector fused-multiply-add half-precision float\n+class FmaVHFNode : public FmaVNode {\n+public:\n+  FmaVHFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : FmaVNode(in1, in2, in3, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -574,0 +609,8 @@\n+\/\/------------------------------DivVHFNode-------------------------------------\n+\/\/ Vector divide half float\n+class DivVHFNode : public VectorNode {\n+public:\n+  DivVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -614,0 +657,16 @@\n+\/\/------------------------------MinVHFNode------------------------------------\n+\/\/ Vector Min for half floats\n+class MinVHFNode : public VectorNode {\n+public:\n+  MinVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------MaxVHFNode------------------------------------\n+\/\/ Vector Max for half floats\n+class MaxVHFNode : public VectorNode {\n+public:\n+  MaxVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -734,0 +793,8 @@\n+\/\/------------------------------SqrtVHFNode-------------------------------------\n+\/\/ Vector Sqrt half-precision float\n+class SqrtVHFNode : public VectorNode {\n+public:\n+  SqrtVHFNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -1764,0 +1831,1 @@\n+  static VectorNode* make(Node* n, const TypeVect* dst_vt, const TypeVect* src_vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -490,0 +490,4 @@\n+  } else if (VectorNode::is_reinterpret_opcode(opc)) {\n+    assert(first->req() == 2 && req() == 2, \"only one input expected\");\n+    const TypeVect* vt = TypeVect::make(bt, vlen);\n+    vn = VectorReinterpretNode::make(in1, vt, in1->bottom_type()->is_vect());\n@@ -506,2 +510,3 @@\n-    assert(opc == Op_FmaD ||\n-           opc == Op_FmaF ||\n+    assert(opc == Op_FmaD  ||\n+           opc == Op_FmaF  ||\n+           opc == Op_FmaHF ||\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -247,0 +247,5 @@\n+    public static final String ADD_VHF = VECTOR_PREFIX + \"ADD_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(ADD_VHF, \"AddVHF\", TYPE_SHORT);\n+    }\n+\n@@ -628,0 +633,5 @@\n+    public static final String DIV_VHF = VECTOR_PREFIX + \"DIV_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(DIV_VHF, \"DivVHF\", TYPE_SHORT);\n+    }\n+\n@@ -665,0 +675,5 @@\n+    public static final String FMA_VHF = VECTOR_PREFIX + \"FMA_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(FMA_VHF, \"FmaVHF\", TYPE_SHORT);\n+    }\n+\n@@ -1097,0 +1112,5 @@\n+    public static final String MAX_VHF = VECTOR_PREFIX + \"MAX_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(MAX_VHF, \"MaxVHF\", TYPE_SHORT);\n+    }\n+\n@@ -1197,0 +1217,5 @@\n+    public static final String MIN_VHF = VECTOR_PREFIX + \"MIN_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(MIN_VHF, \"MinVHF\", TYPE_SHORT);\n+    }\n+\n@@ -1298,0 +1323,5 @@\n+    public static final String MUL_VHF = VECTOR_PREFIX + \"MUL_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(MUL_VHF, \"MulVHF\", TYPE_SHORT);\n+    }\n+\n@@ -1654,0 +1684,5 @@\n+    public static final String SQRT_VHF = VECTOR_PREFIX + \"SQRT_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(SQRT_VHF, \"SqrtVHF\", TYPE_SHORT);\n+    }\n+\n@@ -1840,0 +1875,5 @@\n+    public static final String SUB_VHF = VECTOR_PREFIX + \"SUB_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(SUB_VHF, \"SubVHF\", TYPE_SHORT);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,288 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8346236\n+* @summary Auto-vectorization support for various Float16 operations\n+* @requires vm.compiler2.enabled\n+* @modules jdk.incubator.vector\n+* @library \/test\/lib \/\n+* @compile TestFloat16VectorOperations.java\n+* @run driver compiler.vectorization.TestFloat16VectorOperations\n+*\/\n+\n+package compiler.vectorization;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import static jdk.incubator.vector.Float16.*;\n+import static java.lang.Float.*;\n+\n+public class TestFloat16VectorOperations {\n+    private short[] input1;\n+    private short[] input2;\n+    private short[] input3;\n+    private short[] output;\n+    private static short SCALAR_FP16 = (short)0x7777;\n+    private static final int LEN = 2048;\n+    private Random rng;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-Xbatch\",\"--add-modules=jdk.incubator.vector\");\n+    }\n+\n+    public TestFloat16VectorOperations() {\n+        input1 = new short[LEN];\n+        input2 = new short[LEN];\n+        input3 = new short[LEN];\n+        output = new short[LEN];\n+        rng = new Random(42);\n+        for (int i = 0; i < LEN; ++i) {\n+            input1[i] = floatToFloat16(rng.nextFloat());\n+            input2[i] = floatToFloat16(rng.nextFloat());\n+            input3[i] = floatToFloat16(rng.nextFloat());\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.ADD_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorAddFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(add(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorAddFloat16\")\n+    public void checkResultAdd() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) + float16ToFloat(input2[i]));\n+            if (output[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.SUB_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorSubFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(subtract(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorSubFloat16\")\n+    public void checkResultSub() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) - float16ToFloat(input2[i]));\n+            if (output[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MUL_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorMulFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(multiply(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMulFloat16\")\n+    public void checkResultMul() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) * float16ToFloat(input2[i]));\n+            if (output[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.DIV_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorDivFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(divide(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorDivFloat16\")\n+    public void checkResultDiv() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) \/ float16ToFloat(input2[i]));\n+            if (output[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MIN_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorMinFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(min(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMinFloat16\")\n+    public void checkResultMin() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(Math.min(float16ToFloat(input1[i]), float16ToFloat(input2[i])));\n+            if (output[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MAX_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorMaxFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(max(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMaxFloat16\")\n+    public void checkResultMax() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(Math.max(float16ToFloat(input1[i]), float16ToFloat(input2[i])));\n+            if (output[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.SQRT_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorSqrtFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(sqrt(shortBitsToFloat16(input1[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorSqrtFloat16\")\n+    public void checkResultSqrt() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = float16ToRawShortBits(valueOf(Math.sqrt(float16ToFloat(input1[i]))));\n+            if (output[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorFmaFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]), shortBitsToFloat16(input3[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorFmaFloat16\")\n+    public void checkResultFma() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(Math.fma(float16ToFloat(input1[i]), float16ToFloat(input2[i]), float16ToFloat(input3[i])));\n+            if (output[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.FMA_VHF, \" >= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorFmaFloat16ScalarMixedConstants() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(SCALAR_FP16), shortBitsToFloat16(floatToFloat16(3.0f))));\n+        }\n+    }\n+\n+    @Check(test=\"vectorFmaFloat16ScalarMixedConstants\")\n+    public void checkResultFmaScalarMixedConstants() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(Math.fma(float16ToFloat(input1[i]), float16ToFloat(SCALAR_FP16), 3.0f));\n+            if (output[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.FMA_VHF, \" >= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorFmaFloat16MixedConstants() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]), shortBitsToFloat16(floatToFloat16(3.0f))));\n+        }\n+    }\n+\n+    @Check(test=\"vectorFmaFloat16MixedConstants\")\n+    public void checkResultFmaMixedConstants() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(Math.fma(float16ToFloat(input1[i]), float16ToFloat(input2[i]), 3.0f));\n+            if (output[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.FMA_VHF, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorFmaFloat16AllConstants() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(floatToFloat16(1.0f)), shortBitsToFloat16(floatToFloat16(2.0f)), shortBitsToFloat16(floatToFloat16(3.0f))));\n+        }\n+    }\n+\n+    @Check(test=\"vectorFmaFloat16AllConstants\")\n+    public void checkResultFmaAllConstants() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(Math.fma(1.0f, 2.0f, 3.0f));\n+            if (output[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorOperations.java","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"},{"patch":"@@ -44,0 +44,2 @@\n+    short [] vector4;\n+    short [] vector5;\n@@ -56,0 +58,2 @@\n+        vector4   = new short[vectorDim];\n+        vector5   = new short[vectorDim];\n@@ -61,1 +65,6 @@\n-\n+        IntStream.range(0, vectorDim).forEach(i -> {vector4[i] = ((i & 0x1) == 0) ?\n+                                                                  float16ToRawShortBits(Float16.POSITIVE_INFINITY) :\n+                                                                  Float.floatToFloat16((float)i);});\n+        IntStream.range(0, vectorDim).forEach(i -> {vector5[i] = ((i & 0x1) == 0) ?\n+                                                                  float16ToRawShortBits(Float16.NaN) :\n+                                                                  Float.floatToFloat16((float)i);});\n@@ -143,1 +152,1 @@\n-            vectorPredicate[i] = Float16.isNaN(shortBitsToFloat16(vector1[i]));\n+            vectorPredicate[i] = isNaN(shortBitsToFloat16(vector1[i]));\n@@ -151,1 +160,1 @@\n-            vectorRes[i] = Float16.isNaN(shortBitsToFloat16(vector1[i])) ? f16_one : f16_two;\n+            vectorRes[i] = isNaN(shortBitsToFloat16(vector5[i])) ? vector1[i] : vector2[i];\n@@ -159,1 +168,1 @@\n-            vectorPredicate[i] = Float16.isInfinite(shortBitsToFloat16(vector1[i]));\n+            vectorPredicate[i] = isInfinite(shortBitsToFloat16(vector1[i]));\n@@ -167,1 +176,1 @@\n-            vectorRes[i] = Float16.isInfinite(shortBitsToFloat16(vector1[i])) ? f16_one : f16_two;\n+            vectorRes[i] = isInfinite(shortBitsToFloat16(vector4[i])) ? vector1[i] : vector2[i];\n@@ -175,1 +184,1 @@\n-            vectorPredicate[i] = Float16.isFinite(shortBitsToFloat16(vector1[i]));\n+            vectorPredicate[i] = isFinite(shortBitsToFloat16(vector1[i]));\n@@ -183,1 +192,1 @@\n-            vectorRes[i] = Float16.isFinite(shortBitsToFloat16(vector1[i])) ? f16_one : f16_two;\n+            vectorRes[i] = isFinite(shortBitsToFloat16(vector4[i])) ? vector1[i] : vector2[i];\n@@ -296,0 +305,12 @@\n+\n+    @Benchmark\n+    public short dotProductFP16() {\n+        short distRes = floatToFloat16(0.0f);\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(multiply(shortBitsToFloat16(vector1[i]), shortBitsToFloat16(vector2[i])));\n+        }\n+        for (int i = 0; i < vectorDim; i++) {\n+            distRes = float16ToRawShortBits(add(shortBitsToFloat16(vectorRes[i]), shortBitsToFloat16(distRes)));\n+        }\n+        return distRes;\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/Float16OperationsBenchmark.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"}]}