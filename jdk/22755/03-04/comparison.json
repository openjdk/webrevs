{"files":[{"patch":"@@ -13753,0 +13753,12 @@\n+void Assembler::evcmpph(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src,\n+                        ComparisonPredicateFP comparison, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0xC2, (0xC0 | encode), comparison);\n+}\n+\n@@ -13755,1 +13767,1 @@\n-  assert(VM_Version::supports_evex(), \"\");\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -13767,1 +13779,1 @@\n-  assert(VM_Version::supports_evex(), \"\");\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14088,1 +14100,1 @@\n-  assert(VM_Version::supports_evex(), \"\");\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14101,1 +14113,1 @@\n-  assert(VM_Version::supports_evex(), \"\");\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14113,2 +14125,1 @@\n-void Assembler::evpblendmb (XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n+void Assembler::evpblendmb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n@@ -14116,0 +14127,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14127,2 +14139,1 @@\n-void Assembler::evpblendmw (XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n+void Assembler::evpblendmw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n@@ -14130,0 +14141,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14141,2 +14153,2 @@\n-void Assembler::evpblendmd (XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n+void Assembler::evpblendmd(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14154,2 +14166,2 @@\n-void Assembler::evpblendmq (XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n+void Assembler::evpblendmq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14353,0 +14365,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14361,0 +14374,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14369,0 +14383,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14377,0 +14392,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14385,0 +14401,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14393,0 +14410,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14401,0 +14419,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14409,0 +14428,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":32,"deletions":12,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3207,0 +3207,3 @@\n+  void evcmpph(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src,\n+               ComparisonPredicateFP comparison, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6683,2 +6683,0 @@\n-    case Op_MaxHF: vmaxsh(dst, src1, src2); break;\n-    case Op_MinHF: vminsh(dst, src1, src2); break;\n@@ -7101,2 +7099,0 @@\n-    case Op_MaxVHF: evmaxph(dst, src1, src2, vlen_enc); break;\n-    case Op_MinVHF: evminph(dst, src1, src2, vlen_enc); break;\n@@ -7113,2 +7109,0 @@\n-    case Op_MaxVHF: evmaxph(dst, src1, src2, vlen_enc); break;\n-    case Op_MinVHF: evminph(dst, src1, src2, vlen_enc); break;\n@@ -7119,0 +7113,24 @@\n+void C2_MacroAssembler::scalar_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                            KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2) {\n+  vector_max_min_fp16(opcode, dst, src1, src2, ktmp, xtmp1, xtmp2, Assembler::AVX_128bit);\n+}\n+\n+void C2_MacroAssembler::vector_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                          KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc) {\n+  if (opcode == Op_MaxVHF || opcode == Op_MaxHF) {\n+    evpmovw2m(ktmp, src2, vlen_enc);\n+    evpblendmw(xtmp1, ktmp, src1, src2, true, vlen_enc);\n+    evpblendmw(xtmp2, ktmp, src2, src1, true, vlen_enc);\n+    evmaxph(dst, xtmp1, xtmp2, vlen_enc);\n+    evcmpph(ktmp, k0, xtmp1, xtmp1, Assembler::UNORD_Q, vlen_enc);\n+    Assembler::evmovdquw(dst, ktmp, xtmp1, true, vlen_enc);\n+  } else {\n+    assert(opcode == Op_MinVHF || opcode == Op_MinHF, \"\");\n+    evpmovw2m(ktmp, src1, vlen_enc);\n+    evpblendmw(xtmp1, ktmp, src1, src2, true, vlen_enc);\n+    evpblendmw(xtmp2, ktmp, src2, src1, true, vlen_enc);\n+    evminph(dst, xtmp1, xtmp2, vlen_enc);\n+    evcmpph(ktmp, k0, xtmp1, xtmp1, Assembler::UNORD_Q, vlen_enc);\n+    Assembler::evmovdquw(dst, ktmp, xtmp1, true, vlen_enc);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -591,0 +591,5 @@\n+  void vector_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                          KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc);\n+\n+  void scalar_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                          KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1464,0 +1464,5 @@\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+      if (!VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n@@ -1467,2 +1472,0 @@\n-    case Op_MaxHF:\n-    case Op_MinHF:\n@@ -1743,0 +1746,5 @@\n+    case Op_MaxVHF:\n+    case Op_MinVHF:\n+      if (!VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n@@ -1746,2 +1754,0 @@\n-    case Op_MaxVHF:\n-    case Op_MinVHF:\n@@ -10950,2 +10956,0 @@\n-  match(Set dst (MaxHF src1 src2));\n-  match(Set dst (MinHF src1 src2));\n@@ -10962,0 +10966,14 @@\n+instruct scalar_minmax_HF_reg(regF dst, regF src1, regF src2, kReg ktmp, regF xtmp1, regF xtmp2)\n+%{\n+  match(Set dst (MaxHF src1 src2));\n+  match(Set dst (MinHF src1 src2));\n+  effect(TEMP_DEF dst, TEMP ktmp, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"scalar_min_max_fp16 $dst, $src1, $src2\\t using $ktmp, $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ scalar_max_min_fp16(opcode, $dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister, $ktmp$$KRegister,\n+                           $xtmp1$$XMMRegister, $xtmp2$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -11018,2 +11036,0 @@\n-  match(Set dst (MaxVHF src1 (VectorReinterpret (LoadVector src2))));\n-  match(Set dst (MinVHF src1 (VectorReinterpret (LoadVector src2))));\n@@ -11034,1 +11050,0 @@\n-  effect(DEF dst);\n@@ -11046,1 +11061,0 @@\n-  effect(DEF dst);\n@@ -11055,0 +11069,14 @@\n+instruct vector_minmax_HF_reg(vec dst, vec src1, vec src2, kReg ktmp, vec xtmp1, vec xtmp2)\n+%{\n+  match(Set dst (MinVHF src1 (VectorReinterpret src2)));\n+  match(Set dst (MaxVHF src1 (VectorReinterpret src2)));\n+  effect(TEMP_DEF dst, TEMP ktmp, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_min_max_fp16 $dst, $src1, $src2\\t using $ktmp, $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opcode = this->ideal_Opcode();\n+    __ vector_max_min_fp16(opcode, $dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister, $ktmp$$KRegister,\n+                           $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.vector.*;\n@@ -168,0 +169,14 @@\n+    \/**\n+     * Generates uniform float16s in the range of [lo, hi) (inclusive of lo, exclusive of hi).\n+     *\/\n+    public RestrictableGenerator<Float16> uniformFloat16s(Float16 lo, Float16 hi) {\n+        return new UniformFloat16Generator(this, lo, hi);\n+    }\n+\n+    \/**\n+     * Generates uniform float16s in the range of [0, 1) (inclusive of 0, exclusive of 1).\n+     *\/\n+    public RestrictableGenerator<Float16> uniformFloat16s() {\n+        return uniformFloat16s(Float16.valueOf(0.0f), Float16.valueOf(1.0f));\n+    }\n+\n@@ -391,0 +406,1 @@\n+        -0d,\n@@ -418,1 +434,1 @@\n-     * Generates interesting double values, which often are corner cases such as, 0, 1, -1, NaN, +\/- Infinity, Min,\n+     * Generates interesting float values, which often are corner cases such as, 0, 1, -1, NaN, +\/- Infinity, Min,\n@@ -423,0 +439,1 @@\n+        -0f,\n@@ -433,0 +450,23 @@\n+    \/**\n+     * Generates interesting float16 values, which often are corner cases such as, +\/- 0, NaN, +\/- Infinity, Min,\n+     * Max.\n+     *\/\n+    public final RestrictableGenerator<Float16> SPECIAL_FLOAT16S = orderedRandomElement(List.of(\n+        Float16.valueOf(0.0f),\n+        Float16.valueOf(-0.0f),\n+        Float16.POSITIVE_INFINITY,\n+        Float16.NEGATIVE_INFINITY,\n+        Float16.NaN,\n+        Float16.MAX_VALUE,\n+        Float16.MIN_NORMAL,\n+        Float16.MIN_VALUE\n+    ));\n+\n+    \/**\n+     * Returns a mixed generator that mixes the provided background generator and {@link #SPECIAL_FLOAT16S} with the provided\n+     * weights.\n+     *\/\n+    public Generator<Float16> mixedWithSpecialFloat16s(Generator<Float16> background, int weightNormal, int weightSpecial) {\n+        return mixed(background, SPECIAL_FLOAT16S, weightNormal, weightSpecial);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/Generators.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+\n+\/**\n+ * Provides a uniform float16 distribution random generator, in the provided range [lo, hi).\n+ *\/\n+final class UniformFloat16Generator extends UniformIntersectionRestrictableGenerator<Float16> {\n+    \/**\n+     * Creates a new {@link UniformFloat16Generator}.\n+     *\n+     * @param lo Lower bound of the range (inclusive).\n+     * @param hi Higher bound of the range (exclusive).\n+     *\/\n+    public UniformFloat16Generator(Generators g, Float16 lo, Float16 hi) {\n+        super(g, lo, hi);\n+    }\n+\n+    @Override\n+    public Float16 next() {\n+        return valueOf(g.random.nextFloat(lo().floatValue(), hi().floatValue()));\n+    }\n+\n+    @Override\n+    protected RestrictableGenerator<Float16> doRestrictionFromIntersection(Float16 lo, Float16 hi) {\n+        return new UniformFloat16Generator(g, lo, hi);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/UniformFloat16Generator.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -38,1 +38,1 @@\n-import java.util.Random;\n+import jdk.incubator.vector.Float16;\n@@ -41,0 +41,2 @@\n+import jdk.test.lib.*;\n+import compiler.lib.generators.*;\n@@ -49,1 +51,0 @@\n-    private Random rng;\n@@ -55,0 +56,9 @@\n+    public static boolean assertResults(short expected, short actual) {\n+        Float16 expected_fp16 = valueOf(expected);\n+        Float16 actual_fp16 = valueOf(actual);\n+        if (isNaN(expected_fp16) ^ isNaN(actual_fp16)) {\n+            return false;\n+        }\n+        return !expected_fp16.equals(actual_fp16);\n+    }\n+\n@@ -60,1 +70,2 @@\n-        rng = new Random(42);\n+\n+        Generator<Float16> gen = Generators.G.mixedWithSpecialFloat16s(Generators.G.uniformFloat16s(Float16.MIN_VALUE, Float16.MAX_VALUE), 10, 2);\n@@ -62,3 +73,3 @@\n-            input1[i] = floatToFloat16(rng.nextFloat());\n-            input2[i] = floatToFloat16(rng.nextFloat());\n-            input3[i] = floatToFloat16(rng.nextFloat());\n+            input1[i] = float16ToRawShortBits(gen.next());\n+            input2[i] = float16ToRawShortBits(gen.next());\n+            input3[i] = float16ToRawShortBits(gen.next());\n@@ -82,2 +93,3 @@\n-            if (output[i] != expected) {\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \" output = \" + output[i] + \" expected = \" + expected);\n@@ -102,2 +114,3 @@\n-            if (output[i] != expected) {\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \" output = \" + output[i] + \" expected = \" + expected);\n@@ -122,2 +135,3 @@\n-            if (output[i] != expected) {\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \" output = \" + output[i] + \" expected = \" + expected);\n@@ -142,2 +156,3 @@\n-            if (output[i] != expected) {\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \" output = \" + output[i] + \" expected = \" + expected);\n@@ -162,2 +177,3 @@\n-            if (output[i] != expected) {\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \" output = \" + output[i] + \" expected = \" + expected);\n@@ -182,2 +198,3 @@\n-            if (output[i] != expected) {\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \" output = \" + output[i] + \" expected = \" + expected);\n@@ -201,3 +218,4 @@\n-            short expected = float16ToRawShortBits(valueOf(Math.sqrt(float16ToFloat(input1[i]))));\n-            if (output[i] != expected) {\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            short expected = float16ToRawShortBits(sqrt(shortBitsToFloat16(input1[i])));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input = \" + input1[i] +\n+                                           \" output = \" + output[i] + \" expected = \" + expected);\n@@ -214,1 +232,2 @@\n-            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]), shortBitsToFloat16(input3[i])));\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]),\n+                                                  shortBitsToFloat16(input3[i])));\n@@ -221,3 +240,5 @@\n-            short expected = floatToFloat16(Math.fma(float16ToFloat(input1[i]), float16ToFloat(input2[i]), float16ToFloat(input3[i])));\n-            if (output[i] != expected) {\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]),\n+                                                       shortBitsToFloat16(input3[i])));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \"input3 = \" + input3[i] + \" output = \" + output[i] + \" expected = \" + expected);\n@@ -234,1 +255,2 @@\n-            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(SCALAR_FP16), shortBitsToFloat16(floatToFloat16(3.0f))));\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(SCALAR_FP16),\n+                                                  shortBitsToFloat16(floatToFloat16(3.0f))));\n@@ -241,3 +263,5 @@\n-            short expected = floatToFloat16(Math.fma(float16ToFloat(input1[i]), float16ToFloat(SCALAR_FP16), 3.0f));\n-            if (output[i] != expected) {\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(SCALAR_FP16),\n+                                                       shortBitsToFloat16(floatToFloat16(3.0f))));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + SCALAR_FP16 +\n+                                           \"input3 = 3.0 \" + \"output = \" + output[i] + \" expected = \" + expected);\n@@ -254,0 +278,1 @@\n+        short input3 = floatToFloat16(3.0f);\n@@ -255,1 +280,1 @@\n-            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]), shortBitsToFloat16(floatToFloat16(3.0f))));\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]), shortBitsToFloat16(input3)));\n@@ -261,0 +286,1 @@\n+        short input3 = floatToFloat16(3.0f);\n@@ -262,3 +288,4 @@\n-            short expected = floatToFloat16(Math.fma(float16ToFloat(input1[i]), float16ToFloat(input2[i]), 3.0f));\n-            if (output[i] != expected) {\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]), shortBitsToFloat16(input3)));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \"input3 = \" + input3 + \" output = \" + output[i] + \" expected = \" + expected);\n@@ -274,0 +301,3 @@\n+        short input1 = floatToFloat16(1.0f);\n+        short input2 = floatToFloat16(2.0f);\n+        short input3 = floatToFloat16(3.0f);\n@@ -275,1 +305,1 @@\n-            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(floatToFloat16(1.0f)), shortBitsToFloat16(floatToFloat16(2.0f)), shortBitsToFloat16(floatToFloat16(3.0f))));\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1), shortBitsToFloat16(input2), shortBitsToFloat16(input3)));\n@@ -281,0 +311,3 @@\n+        short input1 = floatToFloat16(1.0f);\n+        short input2 = floatToFloat16(2.0f);\n+        short input3 = floatToFloat16(3.0f);\n@@ -282,3 +315,4 @@\n-            short expected = floatToFloat16(Math.fma(1.0f, 2.0f, 3.0f));\n-            if (output[i] != expected) {\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1), shortBitsToFloat16(input2), shortBitsToFloat16(input3)));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1 + \" input2 = \" + input2 +\n+                                           \"input3 = \" + input3 + \" output = \" + output[i] + \" expected = \" + expected);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorOperations.java","additions":71,"deletions":37,"binary":false,"changes":108,"status":"modified"}]}