{"files":[{"patch":"@@ -13753,0 +13753,12 @@\n+void Assembler::evcmpph(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src,\n+                        ComparisonPredicateFP comparison, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0xC2, (0xC0 | encode), comparison);\n+}\n+\n@@ -13755,1 +13767,1 @@\n-  assert(VM_Version::supports_evex(), \"\");\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -13767,1 +13779,1 @@\n-  assert(VM_Version::supports_evex(), \"\");\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14088,1 +14100,1 @@\n-  assert(VM_Version::supports_evex(), \"\");\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14101,1 +14113,1 @@\n-  assert(VM_Version::supports_evex(), \"\");\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14113,2 +14125,1 @@\n-void Assembler::evpblendmb (XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n+void Assembler::evpblendmb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n@@ -14116,0 +14127,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14127,2 +14139,1 @@\n-void Assembler::evpblendmw (XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n+void Assembler::evpblendmw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n@@ -14130,0 +14141,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14141,2 +14153,2 @@\n-void Assembler::evpblendmd (XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n+void Assembler::evpblendmd(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14154,2 +14166,2 @@\n-void Assembler::evpblendmq (XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n+void Assembler::evpblendmq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14353,0 +14365,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14361,0 +14374,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14369,0 +14383,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14377,0 +14392,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14385,0 +14401,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14393,0 +14410,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14401,0 +14419,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -14409,0 +14428,1 @@\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n@@ -17094,0 +17114,168 @@\n+void Assembler::evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x58, (0xC0 | encode));\n+}\n+\n+void Assembler::evaddph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x58);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5C, (0xC0 | encode));\n+}\n+\n+void Assembler::evsubph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x5C);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x59, (0xC0 | encode));\n+}\n+\n+void Assembler::evmulph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x59);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evminph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5D, (0xC0 | encode));\n+}\n+\n+void Assembler::evminph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x5D);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evmaxph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5F, (0xC0 | encode));\n+}\n+\n+void Assembler::evmaxph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x5F);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5E, (0xC0 | encode));\n+}\n+\n+void Assembler::evdivph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x5E);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evsqrtph(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x51, (0xC0 | encode));\n+}\n+\n+void Assembler::evsqrtph(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x51);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evfmadd132ph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);\n+  emit_int16(0x98, (0xC0 | encode));\n+}\n+\n+void Assembler::evfmadd132ph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);\n+  emit_int8(0x98);\n+  emit_operand(dst, src, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":200,"deletions":12,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -2882,0 +2882,18 @@\n+  \/\/ Float16 Vector instructions.\n+  void evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evaddph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evsubph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evdivph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evmulph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evminph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evminph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evmaxph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evmaxph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evfmadd132ph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evfmadd132ph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evsqrtph(XMMRegister dst, XMMRegister src1, int vector_len);\n+  void evsqrtph(XMMRegister dst, Address src1, int vector_len);\n+\n@@ -3189,0 +3207,3 @@\n+  void evcmpph(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src,\n+               ComparisonPredicateFP comparison, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -6683,2 +6683,0 @@\n-    case Op_MaxHF: vmaxsh(dst, src1, src2); break;\n-    case Op_MinHF: vminsh(dst, src1, src2); break;\n@@ -7094,0 +7092,70 @@\n+\n+void C2_MacroAssembler::evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(opcode) {\n+    case Op_AddVHF: evaddph(dst, src1, src2, vlen_enc); break;\n+    case Op_SubVHF: evsubph(dst, src1, src2, vlen_enc); break;\n+    case Op_MulVHF: evmulph(dst, src1, src2, vlen_enc); break;\n+    case Op_DivVHF: evdivph(dst, src1, src2, vlen_enc); break;\n+    default: assert(false, \"%s\", NodeClassNames[opcode]); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc) {\n+  switch(opcode) {\n+    case Op_AddVHF: evaddph(dst, src1, src2, vlen_enc); break;\n+    case Op_SubVHF: evsubph(dst, src1, src2, vlen_enc); break;\n+    case Op_MulVHF: evmulph(dst, src1, src2, vlen_enc); break;\n+    case Op_DivVHF: evdivph(dst, src1, src2, vlen_enc); break;\n+    default: assert(false, \"%s\", NodeClassNames[opcode]); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::scalar_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                            KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2) {\n+  vector_max_min_fp16(opcode, dst, src1, src2, ktmp, xtmp1, xtmp2, Assembler::AVX_128bit);\n+}\n+\n+void C2_MacroAssembler::vector_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                          KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc) {\n+  if (opcode == Op_MaxVHF || opcode == Op_MaxHF) {\n+    \/\/ Move sign bits of src2 to mask register.\n+    evpmovw2m(ktmp, src2, vlen_enc);\n+    \/\/ xtmp1 = src2 < 0 ? src2 : src1\n+    evpblendmw(xtmp1, ktmp, src1, src2, true, vlen_enc);\n+    \/\/ xtmp2 = src2 < 0 ? ? src1 : src2\n+    evpblendmw(xtmp2, ktmp, src2, src1, true, vlen_enc);\n+    \/\/ Idea behind above swapping is to make seconds source operand a +ve value.\n+    \/\/ As per instruction semantic, if the values being compared are both 0.0s (of either sign), the value in\n+    \/\/ the second source operand is returned. If only one value is a NaN (SNaN or QNaN) for this instruction,\n+    \/\/ the second source operand, either a NaN or a valid floating-point value, is returned\n+    \/\/ dst = max(xtmp1, xtmp2)\n+    evmaxph(dst, xtmp1, xtmp2, vlen_enc);\n+    \/\/ isNaN = is_unordered_quite(xtmp1)\n+    evcmpph(ktmp, k0, xtmp1, xtmp1, Assembler::UNORD_Q, vlen_enc);\n+    \/\/ Final result is same as first source if its a NaN value,\n+    \/\/ in case second operand holds a NaN value then as per above semantics\n+    \/\/ result is same as second operand.\n+    Assembler::evmovdquw(dst, ktmp, xtmp1, true, vlen_enc);\n+  } else {\n+    assert(opcode == Op_MinVHF || opcode == Op_MinHF, \"\");\n+    \/\/ Move sign bits of src1 to mask register.\n+    evpmovw2m(ktmp, src1, vlen_enc);\n+    \/\/ xtmp1 = src1 < 0 ? src2 : src1\n+    evpblendmw(xtmp1, ktmp, src1, src2, true, vlen_enc);\n+    \/\/ xtmp2 = src1 < 0 ? src1 : src2\n+    evpblendmw(xtmp2, ktmp, src2, src1, true, vlen_enc);\n+    \/\/ Idea behind above swapping is to make seconds source operand a -ve value.\n+    \/\/ As per instruction semantics, if the values being compared are both 0.0s (of either sign), the value in\n+    \/\/ the second source operand is returned.\n+    \/\/ If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN\n+    \/\/ or a valid floating-point value, is written to the result.\n+    \/\/ dst = min(xtmp1, xtmp2)\n+    evminph(dst, xtmp1, xtmp2, vlen_enc);\n+    \/\/ isNaN = is_unordered_quite(xtmp1)\n+    evcmpph(ktmp, k0, xtmp1, xtmp1, Assembler::UNORD_Q, vlen_enc);\n+    \/\/ Final result is same as first source if its a NaN value,\n+    \/\/ in case second operand holds a NaN value then as per above semantics\n+    \/\/ result is same as second operand.\n+    Assembler::evmovdquw(dst, ktmp, xtmp1, true, vlen_enc);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":70,"deletions":2,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -587,0 +587,9 @@\n+  void evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc);\n+\n+  void vector_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                          KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc);\n+\n+  void scalar_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                          KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1464,0 +1464,5 @@\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+      if (!VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n@@ -1467,2 +1472,0 @@\n-    case Op_MaxHF:\n-    case Op_MinHF:\n@@ -1743,0 +1746,15 @@\n+    case Op_MaxVHF:\n+    case Op_MinVHF:\n+      if (!VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n+    case Op_AddVHF:\n+    case Op_DivVHF:\n+    case Op_FmaVHF:\n+    case Op_MulVHF:\n+    case Op_SubVHF:\n+    case Op_SqrtVHF:\n+      if (!VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -10894,0 +10912,10 @@\n+instruct reinterpretHF2S(rRegI dst, regF src)\n+%{\n+  match(Set dst (ReinterpretHF2S src));\n+  format %{ \"vmovw $dst, $src\" %}\n+  ins_encode %{\n+    __ vmovw($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -10914,10 +10942,0 @@\n-instruct reinterpretHF2S(rRegI dst, regF src)\n-%{\n-  match(Set dst (ReinterpretHF2S src));\n-  format %{ \"vmovw $dst, $src\" %}\n-  ins_encode %{\n-    __ vmovw($dst$$Register, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -10938,2 +10956,0 @@\n-  match(Set dst (MaxHF src1 src2));\n-  match(Set dst (MinHF src1 src2));\n@@ -10950,0 +10966,14 @@\n+instruct scalar_minmax_HF_reg(regF dst, regF src1, regF src2, kReg ktmp, regF xtmp1, regF xtmp2)\n+%{\n+  match(Set dst (MaxHF src1 src2));\n+  match(Set dst (MinHF src1 src2));\n+  effect(TEMP_DEF dst, TEMP ktmp, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"scalar_min_max_fp16 $dst, $src1, $src2\\t using $ktmp, $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ scalar_max_min_fp16(opcode, $dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister, $ktmp$$KRegister,\n+                           $xtmp1$$XMMRegister, $xtmp2$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -10960,0 +10990,93 @@\n+\n+\n+instruct vector_sqrt_HF_reg(vec dst, vec src)\n+%{\n+  match(Set dst (SqrtVHF src));\n+  format %{ \"vector_sqrt_fp16 $dst, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evsqrtph($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_sqrt_HF_mem(vec dst, memory src)\n+%{\n+  match(Set dst (SqrtVHF (VectorReinterpret (LoadVector src))));\n+  format %{ \"vector_sqrt_fp16_mem $dst, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evsqrtph($dst$$XMMRegister, $src$$Address, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_binOps_HF_reg(vec dst, vec src1, vec src2)\n+%{\n+  match(Set dst (AddVHF src1 src2));\n+  match(Set dst (DivVHF src1 src2));\n+  match(Set dst (MaxVHF src1 src2));\n+  match(Set dst (MinVHF src1 src2));\n+  match(Set dst (MulVHF src1 src2));\n+  match(Set dst (SubVHF src1 src2));\n+  format %{ \"vector_binop_fp16 $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opcode = this->ideal_Opcode();\n+    __ evfp16ph(opcode, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+instruct vector_binOps_HF_mem(vec dst, vec src1, memory src2)\n+%{\n+  match(Set dst (AddVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (DivVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (MulVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (SubVHF src1 (VectorReinterpret (LoadVector src2))));\n+  format %{ \"vector_binop_fp16_mem $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opcode = this->ideal_Opcode();\n+    __ evfp16ph(opcode, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$Address, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_fma_HF_reg(vec dst, vec src1, vec src2)\n+%{\n+  match(Set dst (FmaVHF src2 (Binary dst src1)));\n+  format %{ \"vector_fma_fp16 $dst, $src1, $src2\\t# $dst = $dst * $src1 + $src2 fma packedH\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evfmadd132ph($dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_fma_HF_mem(vec dst, memory src1, vec src2)\n+%{\n+  match(Set dst (FmaVHF src2 (Binary dst (VectorReinterpret (LoadVector src1)))));\n+  format %{ \"vector_fma_fp16_mem $dst, $src1, $src2\\t# $dst = $dst * $src1 + $src2 fma packedH\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evfmadd132ph($dst$$XMMRegister, $src2$$XMMRegister, $src1$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_minmax_HF_reg(vec dst, vec src1, vec src2, kReg ktmp, vec xtmp1, vec xtmp2)\n+%{\n+  match(Set dst (MinVHF src1 (VectorReinterpret src2)));\n+  match(Set dst (MaxVHF src1 (VectorReinterpret src2)));\n+  effect(TEMP_DEF dst, TEMP ktmp, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_min_max_fp16 $dst, $src1, $src2\\t using $ktmp, $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opcode = this->ideal_Opcode();\n+    __ vector_max_min_fp16(opcode, $dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister, $ktmp$$KRegister,\n+                           $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":137,"deletions":14,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -3968,2 +3968,2 @@\n-    \"AddVB\", \"AddVS\", \"AddVI\", \"AddVL\", \"AddVF\", \"AddVD\",\n-    \"MulVB\", \"MulVS\", \"MulVI\", \"MulVL\", \"MulVF\", \"MulVD\",\n+    \"AddVB\", \"AddVS\", \"AddVI\", \"AddVL\", \"AddVHF\", \"AddVF\", \"AddVD\",\n+    \"MulVB\", \"MulVS\", \"MulVI\", \"MulVL\", \"MulVHF\", \"MulVF\", \"MulVD\",\n@@ -3971,1 +3971,1 @@\n-    \"MaxV\", \"MinV\", \"UMax\",\"UMin\"\n+    \"MaxVHF\", \"MinVHF\", \"MaxV\", \"MinV\", \"UMax\",\"UMin\"\n@@ -4340,4 +4340,4 @@\n-    \"AddVB\",\"AddVS\",\"AddVI\",\"AddVL\",\"AddVF\",\"AddVD\",\n-    \"SubVB\",\"SubVS\",\"SubVI\",\"SubVL\",\"SubVF\",\"SubVD\",\n-    \"MulVB\",\"MulVS\",\"MulVI\",\"MulVL\",\"MulVF\",\"MulVD\",\n-    \"DivVF\",\"DivVD\",\n+    \"AddVB\",\"AddVS\",\"AddVI\",\"AddVL\",\"AddVHF\",\"AddVF\",\"AddVD\",\n+    \"SubVB\",\"SubVS\",\"SubVI\",\"SubVL\",\"SubVHF\",\"SubVF\",\"SubVD\",\n+    \"MulVB\",\"MulVS\",\"MulVI\",\"MulVL\",\"MulVHF\",\"MulVF\",\"MulVD\",\n+    \"DivVHF\",\"DivVF\",\"DivVD\",\n@@ -4346,1 +4346,1 @@\n-    \"SqrtVD\",\"SqrtVF\",\n+    \"SqrtVD\",\"SqrtVF\",\"SqrtVHF\",\n@@ -4348,1 +4348,1 @@\n-    \"MaxV\", \"MinV\", \"UMinV\", \"UMaxV\",\n+    \"MaxV\", \"MinV\",\"MinVHF\",\"MaxVHF\",\"UMinV\",\"UMaxV\",\n@@ -4370,1 +4370,1 @@\n-    \"FmaVD\",\"FmaVF\",\"PopCountVI\",\"PopCountVL\",\"PopulateIndex\",\"VectorLongToMask\",\n+    \"FmaVD\",\"FmaVF\",\"FmaVHF\",\"PopCountVI\",\"PopCountVL\",\"PopulateIndex\",\"VectorLongToMask\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -394,0 +394,1 @@\n+macro(AddVHF)\n@@ -402,0 +403,1 @@\n+macro(SubVHF)\n@@ -413,0 +415,1 @@\n+macro(MulVHF)\n@@ -416,0 +419,2 @@\n+macro(FmaVHF)\n+macro(DivVHF)\n@@ -430,0 +435,1 @@\n+macro(SqrtVHF)\n@@ -452,0 +458,2 @@\n+macro(MinVHF)\n+macro(MaxVHF)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2310,0 +2310,1 @@\n+    case Op_FmaVHF:\n@@ -2482,1 +2483,2 @@\n-    case Op_FmaVF: {\n+    case Op_FmaVF:\n+    case Op_FmaVHF: {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2594,0 +2594,1 @@\n+  int opc = n->Opcode();\n@@ -2601,1 +2602,1 @@\n-    if (n->Opcode() == Op_LoadUB) {\n+    if (opc == Op_LoadUB) {\n@@ -2615,1 +2616,1 @@\n-    if (n->Opcode() == Op_ConvF2HF || n->Opcode() == Op_ReinterpretHF2S) {\n+    if (opc == Op_ConvF2HF || opc == Op_ReinterpretHF2S) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+           VectorNode::is_reinterpret_opcode(opc) ||\n@@ -165,2 +166,3 @@\n-           opc == Op_FmaD ||\n-           opc == Op_FmaF ||\n+           opc == Op_FmaD  ||\n+           opc == Op_FmaF  ||\n+           opc == Op_FmaHF ||\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  case Op_AddHF: return (bt == T_SHORT ? Op_AddVHF : 0);\n@@ -62,0 +63,1 @@\n+  case Op_SubHF: return (bt == T_SHORT ? Op_SubVHF : 0);\n@@ -75,0 +77,2 @@\n+  case Op_MulHF:\n+    return (bt == T_SHORT ? Op_MulVHF : 0);\n@@ -83,0 +87,2 @@\n+  case Op_FmaHF:\n+    return (bt == T_SHORT ? Op_FmaVHF : 0);\n@@ -89,0 +95,2 @@\n+  case Op_DivHF:\n+    return (bt == T_SHORT ? Op_DivVHF : 0);\n@@ -115,0 +123,2 @@\n+  case Op_MinHF:\n+    return (bt == T_SHORT ? Op_MinVHF : 0);\n@@ -130,0 +140,2 @@\n+  case Op_MaxHF:\n+    return (bt == T_SHORT ? Op_MaxVHF : 0);\n@@ -157,0 +169,2 @@\n+  case Op_SqrtHF:\n+    return (bt == T_SHORT ? Op_SqrtVHF : 0);\n@@ -269,0 +283,3 @@\n+  case Op_ReinterpretS2HF:\n+  case Op_ReinterpretHF2S:\n+    return Op_VectorReinterpret;\n@@ -381,0 +398,4 @@\n+    case Op_MinVHF:\n+      return Op_MinHF;\n+    case Op_MaxVHF:\n+      return Op_MaxHF;\n@@ -621,4 +642,4 @@\n-  case Op_AddI: case Op_AddL: case Op_AddF: case Op_AddD:\n-  case Op_SubI: case Op_SubL: case Op_SubF: case Op_SubD:\n-  case Op_MulI: case Op_MulL: case Op_MulF: case Op_MulD:\n-  case Op_DivF: case Op_DivD:\n+  case Op_AddI: case Op_AddL: case Op_AddHF: case Op_AddF: case Op_AddD:\n+  case Op_SubI: case Op_SubL: case Op_SubHF: case Op_SubF: case Op_SubD:\n+  case Op_MulI: case Op_MulL: case Op_MulHF: case Op_MulF: case Op_MulD:\n+  case Op_DivHF: case Op_DivF: case Op_DivD:\n@@ -634,0 +655,1 @@\n+  case Op_FmaHF:\n@@ -678,23 +700,27 @@\n-  case Op_AddVB: return new AddVBNode(n1, n2, vt);\n-  case Op_AddVS: return new AddVSNode(n1, n2, vt);\n-  case Op_AddVI: return new AddVINode(n1, n2, vt);\n-  case Op_AddVL: return new AddVLNode(n1, n2, vt);\n-  case Op_AddVF: return new AddVFNode(n1, n2, vt);\n-  case Op_AddVD: return new AddVDNode(n1, n2, vt);\n-\n-  case Op_SubVB: return new SubVBNode(n1, n2, vt);\n-  case Op_SubVS: return new SubVSNode(n1, n2, vt);\n-  case Op_SubVI: return new SubVINode(n1, n2, vt);\n-  case Op_SubVL: return new SubVLNode(n1, n2, vt);\n-  case Op_SubVF: return new SubVFNode(n1, n2, vt);\n-  case Op_SubVD: return new SubVDNode(n1, n2, vt);\n-\n-  case Op_MulVB: return new MulVBNode(n1, n2, vt);\n-  case Op_MulVS: return new MulVSNode(n1, n2, vt);\n-  case Op_MulVI: return new MulVINode(n1, n2, vt);\n-  case Op_MulVL: return new MulVLNode(n1, n2, vt);\n-  case Op_MulVF: return new MulVFNode(n1, n2, vt);\n-  case Op_MulVD: return new MulVDNode(n1, n2, vt);\n-\n-  case Op_DivVF: return new DivVFNode(n1, n2, vt);\n-  case Op_DivVD: return new DivVDNode(n1, n2, vt);\n+  case Op_AddVB:  return new AddVBNode(n1, n2, vt);\n+  case Op_AddVHF: return new AddVHFNode(n1, n2, vt);\n+  case Op_AddVS:  return new AddVSNode(n1, n2, vt);\n+  case Op_AddVI:  return new AddVINode(n1, n2, vt);\n+  case Op_AddVL:  return new AddVLNode(n1, n2, vt);\n+  case Op_AddVF:  return new AddVFNode(n1, n2, vt);\n+  case Op_AddVD:  return new AddVDNode(n1, n2, vt);\n+\n+  case Op_SubVB:  return new SubVBNode(n1, n2, vt);\n+  case Op_SubVS:  return new SubVSNode(n1, n2, vt);\n+  case Op_SubVI:  return new SubVINode(n1, n2, vt);\n+  case Op_SubVL:  return new SubVLNode(n1, n2, vt);\n+  case Op_SubVHF: return new SubVHFNode(n1, n2, vt);\n+  case Op_SubVF:  return new SubVFNode(n1, n2, vt);\n+  case Op_SubVD:  return new SubVDNode(n1, n2, vt);\n+\n+  case Op_MulVB:  return new MulVBNode(n1, n2, vt);\n+  case Op_MulVS:  return new MulVSNode(n1, n2, vt);\n+  case Op_MulVI:  return new MulVINode(n1, n2, vt);\n+  case Op_MulVL:  return new MulVLNode(n1, n2, vt);\n+  case Op_MulVHF: return new MulVHFNode(n1, n2, vt);\n+  case Op_MulVF:  return new MulVFNode(n1, n2, vt);\n+  case Op_MulVD:  return new MulVDNode(n1, n2, vt);\n+\n+  case Op_DivVHF: return new DivVHFNode(n1, n2, vt);\n+  case Op_DivVF:  return new DivVFNode(n1, n2, vt);\n+  case Op_DivVD:  return new DivVDNode(n1, n2, vt);\n@@ -704,0 +730,2 @@\n+  case Op_MinVHF: return new MinVHFNode(n1, n2, vt);\n+  case Op_MaxVHF: return new MaxVHFNode(n1, n2, vt);\n@@ -720,2 +748,3 @@\n-  case Op_SqrtVF: return new SqrtVFNode(n1, vt);\n-  case Op_SqrtVD: return new SqrtVDNode(n1, vt);\n+  case Op_SqrtVHF : return new SqrtVHFNode(n1, vt);\n+  case Op_SqrtVF  : return new SqrtVFNode(n1, vt);\n+  case Op_SqrtVD  : return new SqrtVDNode(n1, vt);\n@@ -805,0 +834,1 @@\n+  case Op_FmaVHF: return new FmaVHFNode(n1, n2, n3, vt);\n@@ -952,0 +982,11 @@\n+\n+bool VectorNode::is_reinterpret_opcode(int opc) {\n+  switch (opc) {\n+    case Op_ReinterpretHF2S:\n+    case Op_ReinterpretS2HF:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n@@ -954,0 +995,1 @@\n+    case Op_SqrtHF:\n@@ -979,0 +1021,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":72,"deletions":29,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -139,0 +139,2 @@\n+  static bool is_reinterpret_opcode(int opc);\n+\n@@ -210,0 +212,8 @@\n+\/\/------------------------------AddVHFNode--------------------------------------\n+\/\/ Vector add float\n+class AddVHFNode : public VectorNode {\n+public:\n+  AddVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -404,0 +414,9 @@\n+\/\/------------------------------SubVHFNode--------------------------------------\n+\/\/ Vector subtract half float\n+class SubVHFNode : public VectorNode {\n+public:\n+  SubVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n+\n@@ -456,0 +475,8 @@\n+\/\/------------------------------MulVFNode--------------------------------------\n+\/\/ Vector multiply half float\n+class MulVHFNode : public VectorNode {\n+public:\n+  MulVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -506,0 +533,8 @@\n+\/\/------------------------------FmaVHFNode-------------------------------------\n+\/\/ Vector fused-multiply-add half-precision float\n+class FmaVHFNode : public FmaVNode {\n+public:\n+  FmaVHFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : FmaVNode(in1, in2, in3, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -574,0 +609,8 @@\n+\/\/------------------------------DivVHFNode-------------------------------------\n+\/\/ Vector divide half float\n+class DivVHFNode : public VectorNode {\n+public:\n+  DivVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -614,0 +657,16 @@\n+\/\/------------------------------MinVHFNode------------------------------------\n+\/\/ Vector Min for half floats\n+class MinVHFNode : public VectorNode {\n+public:\n+  MinVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------MaxVHFNode------------------------------------\n+\/\/ Vector Max for half floats\n+class MaxVHFNode : public VectorNode {\n+public:\n+  MaxVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -734,0 +793,8 @@\n+\/\/------------------------------SqrtVHFNode-------------------------------------\n+\/\/ Vector Sqrt half-precision float\n+class SqrtVHFNode : public VectorNode {\n+public:\n+  SqrtVHFNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -579,0 +579,4 @@\n+  } else if (VectorNode::is_reinterpret_opcode(opc)) {\n+    assert(first->req() == 2 && req() == 2, \"only one input expected\");\n+    const TypeVect* vt = TypeVect::make(bt, vlen);\n+    vn = new VectorReinterpretNode(in1, vt, in1->bottom_type()->is_vect());\n@@ -595,2 +599,3 @@\n-    assert(opc == Op_FmaD ||\n-           opc == Op_FmaF ||\n+    assert(opc == Op_FmaD  ||\n+           opc == Op_FmaF  ||\n+           opc == Op_FmaHF ||\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+\/**\n+ * Provides an any-bits float16 distribution random generator, i.e. the bits are uniformly sampled,\n+ * thus creating any possible float16 value, including the multiple different NaN representations.\n+ *\/\n+final class AnyBitsFloat16Generator extends BoundGenerator<Short> {\n+\n+    \/**\n+     * Creates a new {@link AnyBitsFloat16Generator}.\n+     *\/\n+    public AnyBitsFloat16Generator(Generators g) {\n+        super(g);\n+    }\n+\n+    @Override\n+    public Short next() {\n+        return (short)g.random.nextInt();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/AnyBitsFloat16Generator.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import static java.lang.Float.floatToFloat16;\n@@ -168,0 +169,14 @@\n+    \/**\n+     * Generates uniform float16s in the range of [lo, hi) (inclusive of lo, exclusive of hi).\n+     *\/\n+    public RestrictableGenerator<Short> uniformFloat16s(short lo, short hi) {\n+        return new UniformFloat16Generator(this, lo, hi);\n+    }\n+\n+    \/**\n+     * Generates uniform float16s in the range of [0, 1) (inclusive of 0, exclusive of 1).\n+     *\/\n+    public RestrictableGenerator<Short> uniformFloat16s() {\n+        return uniformFloat16s(floatToFloat16(0.0f), floatToFloat16(1.0f));\n+    }\n+\n@@ -175,0 +190,8 @@\n+    \/**\n+     * Provides an any-bits float16 distribution random generator, i.e. the bits are uniformly sampled,\n+     * thus creating any possible float16 value, including the multiple different NaN representations.\n+     *\/\n+    public Generator<Short> anyBitsFloat16s() {\n+        return new AnyBitsFloat16Generator(this);\n+    }\n+\n@@ -347,0 +370,19 @@\n+    \/**\n+     * Randomly pick a float16 generator.\n+     *\n+     * @return Random float16 generator.\n+     *\/\n+    public Generator<Short> float16s() {\n+        switch(random.nextInt(0, 5)) {\n+            case 0  -> { return uniformFloat16s(floatToFloat16(-1.0f), floatToFloat16(1.0f)); }\n+            \/\/ Well-balanced, so that multiplication reduction never explodes or collapses to zero:\n+            case 1  -> { return uniformFloat16s(floatToFloat16(0.999f), floatToFloat16(1.001f)); }\n+            case 2  -> { return anyBitsFloat16s(); }\n+            \/\/ A tame distribution, mixed in with the occasional special float value:\n+            case 3  -> { return mixedWithSpecialFloat16s(uniformFloat16s(floatToFloat16(0.999f), floatToFloat16(1.001f)), 10, 1000); }\n+            \/\/ Generating any bits, but special values are more frequent.\n+            case 4  -> { return mixedWithSpecialFloat16s(anyBitsFloat16s(), 100, 200); }\n+            default -> { throw new RuntimeException(\"impossible\"); }\n+        }\n+    }\n+\n@@ -391,0 +433,1 @@\n+        -0d,\n@@ -418,1 +461,1 @@\n-     * Generates interesting double values, which often are corner cases such as, 0, 1, -1, NaN, +\/- Infinity, Min,\n+     * Generates interesting float values, which often are corner cases such as, 0, 1, -1, NaN, +\/- Infinity, Min,\n@@ -423,0 +466,1 @@\n+        -0f,\n@@ -433,0 +477,23 @@\n+    \/**\n+     * Generates interesting float16 values, which often are corner cases such as, +\/- 0, NaN, +\/- Infinity, Min,\n+     * Max.\n+     *\/\n+    public final RestrictableGenerator<Short> SPECIAL_FLOAT16S = orderedRandomElement(List.of(\n+        floatToFloat16(0.0f),\n+        floatToFloat16(-0.0f),\n+        floatToFloat16(Float.POSITIVE_INFINITY),\n+        floatToFloat16(Float.NEGATIVE_INFINITY),\n+        floatToFloat16(Float.NaN),\n+        floatToFloat16(0x1.ffcP+15f), \/\/ MAX_VALUE\n+        floatToFloat16(0x1.0P-14f),   \/\/ MIN_NORMAL\n+        floatToFloat16(0x1.0P-24f)    \/\/ MIN_VALUE\n+    ));\n+\n+    \/**\n+     * Returns a mixed generator that mixes the provided background generator and {@link #SPECIAL_FLOAT16S} with the provided\n+     * weights.\n+     *\/\n+    public Generator<Short> mixedWithSpecialFloat16s(Generator<Short> background, int weightNormal, int weightSpecial) {\n+        return mixed(background, SPECIAL_FLOAT16S, weightNormal, weightSpecial);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/Generators.java","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+    \/** Samples the next float16 value in the half-open interval [lo, hi) uniformly at random. *\/\n+    short nextFloat16(short lo, short hi);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/RandomnessSource.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static java.lang.Float.floatToFloat16;\n+import static java.lang.Float.float16ToFloat;\n@@ -68,0 +70,5 @@\n+\n+    @Override\n+    public short nextFloat16(short lo, short hi) {\n+        return floatToFloat16(rand.nextFloat(float16ToFloat(lo), float16ToFloat(hi)));\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/RandomnessSourceAdapter.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+import static java.lang.Float.*;\n+\n+\/**\n+ * Provides a uniform float16 distribution random generator, in the provided range [lo, hi).\n+ *\/\n+final class UniformFloat16Generator extends UniformIntersectionRestrictableGenerator<Short> {\n+    \/**\n+     * Creates a new {@link UniformFloat16Generator}.\n+     *\n+     * @param lo Lower bound of the range (inclusive).\n+     * @param hi Higher bound of the range (exclusive).\n+     *\/\n+    public UniformFloat16Generator(Generators g, Short lo, Short hi) {\n+        super(g, lo, hi);\n+    }\n+\n+    @Override\n+    public Short next() {\n+        return g.random.nextFloat16(lo(), hi());\n+    }\n+\n+    @Override\n+    protected RestrictableGenerator<Short> doRestrictionFromIntersection(Short lo, Short hi) {\n+        return new UniformFloat16Generator(g, lo, hi);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/UniformFloat16Generator.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -247,0 +247,5 @@\n+    public static final String ADD_VHF = VECTOR_PREFIX + \"ADD_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(ADD_VHF, \"AddVHF\", TYPE_SHORT);\n+    }\n+\n@@ -633,0 +638,5 @@\n+    public static final String DIV_VHF = VECTOR_PREFIX + \"DIV_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(DIV_VHF, \"DivVHF\", TYPE_SHORT);\n+    }\n+\n@@ -670,0 +680,5 @@\n+    public static final String FMA_VHF = VECTOR_PREFIX + \"FMA_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(FMA_VHF, \"FmaVHF\", TYPE_SHORT);\n+    }\n+\n@@ -1102,0 +1117,5 @@\n+    public static final String MAX_VHF = VECTOR_PREFIX + \"MAX_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(MAX_VHF, \"MaxVHF\", TYPE_SHORT);\n+    }\n+\n@@ -1202,0 +1222,5 @@\n+    public static final String MIN_VHF = VECTOR_PREFIX + \"MIN_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(MIN_VHF, \"MinVHF\", TYPE_SHORT);\n+    }\n+\n@@ -1303,0 +1328,5 @@\n+    public static final String MUL_VHF = VECTOR_PREFIX + \"MUL_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(MUL_VHF, \"MulVHF\", TYPE_SHORT);\n+    }\n+\n@@ -1679,0 +1709,5 @@\n+    public static final String SQRT_VHF = VECTOR_PREFIX + \"SQRT_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(SQRT_VHF, \"SqrtVHF\", TYPE_SHORT);\n+    }\n+\n@@ -1865,0 +1900,5 @@\n+    public static final String SUB_VHF = VECTOR_PREFIX + \"SUB_VHF\" + POSTFIX;\n+    static {\n+        vectorNode(SUB_VHF, \"SubVHF\", TYPE_SHORT);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8346236\n+* @summary Auto-vectorization support for various Float16 operations\n+* @requires vm.compiler2.enabled\n+* @modules jdk.incubator.vector\n+* @library \/test\/lib \/\n+* @compile TestFloat16VectorOperations.java\n+* @run driver compiler.vectorization.TestFloat16VectorOperations\n+*\/\n+\n+package compiler.vectorization;\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+import static java.lang.Float.*;\n+import jdk.test.lib.*;\n+import compiler.lib.generators.Generator;\n+import static compiler.lib.generators.Generators.G;\n+\n+public class TestFloat16VectorOperations {\n+    private short[] input1;\n+    private short[] input2;\n+    private short[] input3;\n+    private short[] output;\n+    private static short SCALAR_FP16 = (short)0x7777;\n+    private static final int LEN = 2048;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-Xbatch\",\"--add-modules=jdk.incubator.vector\");\n+    }\n+\n+    public static boolean assertResults(short expected, short actual) {\n+        if (Float.isNaN(Float.float16ToFloat(expected)) && Float.isNaN(Float.float16ToFloat(actual))) {\n+            return false;\n+        }\n+        return expected != actual;\n+    }\n+\n+    public TestFloat16VectorOperations() {\n+        input1 = new short[LEN];\n+        input2 = new short[LEN];\n+        input3 = new short[LEN];\n+        output = new short[LEN];\n+\n+        short min_value = float16ToRawShortBits(Float16.MIN_VALUE);\n+        short max_value = float16ToRawShortBits(Float16.MAX_VALUE);\n+        Generator<Short> gen = G.float16s();\n+        for (int i = 0; i < LEN; ++i) {\n+            input1[i] = gen.next();\n+            input2[i] = gen.next();\n+            input3[i] = gen.next();\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.ADD_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorAddFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(add(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorAddFloat16\")\n+    public void checkResultAdd() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) + float16ToFloat(input2[i]));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \" output = \" + output[i] + \" expected = \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.SUB_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorSubFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(subtract(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorSubFloat16\")\n+    public void checkResultSub() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) - float16ToFloat(input2[i]));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \" output = \" + output[i] + \" expected = \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MUL_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorMulFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(multiply(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMulFloat16\")\n+    public void checkResultMul() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) * float16ToFloat(input2[i]));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \" output = \" + output[i] + \" expected = \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.DIV_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorDivFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(divide(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorDivFloat16\")\n+    public void checkResultDiv() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) \/ float16ToFloat(input2[i]));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \" output = \" + output[i] + \" expected = \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MIN_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorMinFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(min(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMinFloat16\")\n+    public void checkResultMin() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(Math.min(float16ToFloat(input1[i]), float16ToFloat(input2[i])));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \" output = \" + output[i] + \" expected = \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MAX_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorMaxFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(max(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMaxFloat16\")\n+    public void checkResultMax() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(Math.max(float16ToFloat(input1[i]), float16ToFloat(input2[i])));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \" output = \" + output[i] + \" expected = \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.SQRT_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorSqrtFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(sqrt(shortBitsToFloat16(input1[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorSqrtFloat16\")\n+    public void checkResultSqrt() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = float16ToRawShortBits(sqrt(shortBitsToFloat16(input1[i])));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input = \" + input1[i] +\n+                                           \" output = \" + output[i] + \" expected = \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorFmaFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]),\n+                                                  shortBitsToFloat16(input3[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorFmaFloat16\")\n+    public void checkResultFma() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]),\n+                                                       shortBitsToFloat16(input3[i])));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \"input3 = \" + input3[i] + \" output = \" + output[i] + \" expected = \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.FMA_VHF, \" >= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorFmaFloat16ScalarMixedConstants() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(SCALAR_FP16),\n+                                                  shortBitsToFloat16(floatToFloat16(3.0f))));\n+        }\n+    }\n+\n+    @Check(test=\"vectorFmaFloat16ScalarMixedConstants\")\n+    public void checkResultFmaScalarMixedConstants() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(SCALAR_FP16),\n+                                                       shortBitsToFloat16(floatToFloat16(3.0f))));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + SCALAR_FP16 +\n+                                           \"input3 = 3.0 \" + \"output = \" + output[i] + \" expected = \" + expected);\n+            }\n+        }\n+    }\n+\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.FMA_VHF, \" >= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorFmaFloat16MixedConstants() {\n+        short input3 = floatToFloat16(3.0f);\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]), shortBitsToFloat16(input3)));\n+        }\n+    }\n+\n+    @Check(test=\"vectorFmaFloat16MixedConstants\")\n+    public void checkResultFmaMixedConstants() {\n+        short input3 = floatToFloat16(3.0f);\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]), shortBitsToFloat16(input3)));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n+                                           \"input3 = \" + input3 + \" output = \" + output[i] + \" expected = \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.FMA_VHF, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorFmaFloat16AllConstants() {\n+        short input1 = floatToFloat16(1.0f);\n+        short input2 = floatToFloat16(2.0f);\n+        short input3 = floatToFloat16(3.0f);\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1), shortBitsToFloat16(input2), shortBitsToFloat16(input3)));\n+        }\n+    }\n+\n+    @Check(test=\"vectorFmaFloat16AllConstants\")\n+    public void checkResultFmaAllConstants() {\n+        short input1 = floatToFloat16(1.0f);\n+        short input2 = floatToFloat16(2.0f);\n+        short input3 = floatToFloat16(3.0f);\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1), shortBitsToFloat16(input2), shortBitsToFloat16(input3)));\n+            if (assertResults(expected, output[i])) {\n+                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1 + \" input2 = \" + input2 +\n+                                           \"input3 = \" + input3 + \" output = \" + output[i] + \" expected = \" + expected);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorOperations.java","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -51,0 +51,1 @@\n+    private final Queue<Bounded<Short>> boundedFloat16Queue = new ArrayDeque<>();\n@@ -94,0 +95,5 @@\n+    public MockRandomnessSource enqueueFloat16(short lo, short hi, short value) {\n+        boundedFloat16Queue.add(new Bounded<>(lo, hi, value));\n+        return this;\n+    }\n+\n@@ -101,0 +107,1 @@\n+        checkQueueEmpty(boundedFloat16Queue, \"bounded float16s\");\n@@ -133,0 +140,5 @@\n+\n+    @Override\n+    public short nextFloat16(short lo, short hi) {\n+        return dequeueBounded(boundedFloat16Queue, lo, hi);\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/generators\/tests\/MockRandomnessSource.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+        testUniformFloat16();\n@@ -67,0 +68,1 @@\n+        testSpecialFloat16();\n@@ -160,1 +162,1 @@\n-                .enqueueInteger(0, 9, 1);\n+                .enqueueInteger(0, 10, 1);\n@@ -172,1 +174,1 @@\n-                .enqueueInteger(0, 9, 1);\n+                .enqueueInteger(0, 10, 1);\n@@ -178,0 +180,22 @@\n+    static void testSpecialFloat16() {\n+        mockSource\n+                .checkEmpty()\n+                .enqueueInteger(0, 8, 2)\n+                .enqueueFloat16((short)0, (short)15360, (short)17010)\n+                .enqueueInteger(0, 8, 6)\n+                .enqueueInteger(0, 8, 5)\n+                .enqueueInteger(0, 8, 7)\n+                .enqueueInteger(0, 8, 4);\n+        var g = mockGS.mixedWithSpecialFloat16s(mockGS.uniformFloat16s(), 4, 4);\n+        Asserts.assertEQ(g.next(), (short)17010);\n+        Asserts.assertEQ(g.next(), (short)31743);\n+        Asserts.assertEQ(g.next(), (short)1024);\n+    }\n+\n+    static void testUniformFloat16() {\n+        mockSource.checkEmpty().enqueueFloat16((short)0, (short)10, (short)17664);\n+        Asserts.assertEQ(mockGS.uniformFloat16s((short)0, (short)10).next(), (short)17664);\n+        mockSource.checkEmpty().enqueueFloat16((short)0, (short)5, (short)31744);\n+        Asserts.assertEQ(mockGS.uniformFloat16s((short)0, (short)5).next(), (short)31744);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/generators\/tests\/TestGenerators.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+    short [] vector4;\n+    short [] vector5;\n@@ -56,0 +58,2 @@\n+        vector4   = new short[vectorDim];\n+        vector5   = new short[vectorDim];\n@@ -61,1 +65,6 @@\n-\n+        IntStream.range(0, vectorDim).forEach(i -> {vector4[i] = ((i & 0x1) == 0) ?\n+                                                                  float16ToRawShortBits(Float16.POSITIVE_INFINITY) :\n+                                                                  Float.floatToFloat16((float)i);});\n+        IntStream.range(0, vectorDim).forEach(i -> {vector5[i] = ((i & 0x1) == 0) ?\n+                                                                  float16ToRawShortBits(Float16.NaN) :\n+                                                                  Float.floatToFloat16((float)i);});\n@@ -143,1 +152,1 @@\n-            vectorPredicate[i] = Float16.isNaN(shortBitsToFloat16(vector1[i]));\n+            vectorPredicate[i] = isNaN(shortBitsToFloat16(vector1[i]));\n@@ -151,1 +160,1 @@\n-            vectorRes[i] = Float16.isNaN(shortBitsToFloat16(vector1[i])) ? f16_one : f16_two;\n+            vectorRes[i] = isNaN(shortBitsToFloat16(vector5[i])) ? vector1[i] : vector2[i];\n@@ -159,1 +168,1 @@\n-            vectorPredicate[i] = Float16.isInfinite(shortBitsToFloat16(vector1[i]));\n+            vectorPredicate[i] = isInfinite(shortBitsToFloat16(vector1[i]));\n@@ -167,1 +176,1 @@\n-            vectorRes[i] = Float16.isInfinite(shortBitsToFloat16(vector1[i])) ? f16_one : f16_two;\n+            vectorRes[i] = isInfinite(shortBitsToFloat16(vector4[i])) ? vector1[i] : vector2[i];\n@@ -175,1 +184,1 @@\n-            vectorPredicate[i] = Float16.isFinite(shortBitsToFloat16(vector1[i]));\n+            vectorPredicate[i] = isFinite(shortBitsToFloat16(vector1[i]));\n@@ -183,1 +192,1 @@\n-            vectorRes[i] = Float16.isFinite(shortBitsToFloat16(vector1[i])) ? f16_one : f16_two;\n+            vectorRes[i] = isFinite(shortBitsToFloat16(vector4[i])) ? vector1[i] : vector2[i];\n@@ -296,0 +305,12 @@\n+\n+    @Benchmark\n+    public short dotProductFP16() {\n+        short distRes = floatToFloat16(0.0f);\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(multiply(shortBitsToFloat16(vector1[i]), shortBitsToFloat16(vector2[i])));\n+        }\n+        for (int i = 0; i < vectorDim; i++) {\n+            distRes = float16ToRawShortBits(add(shortBitsToFloat16(vectorRes[i]), shortBitsToFloat16(distRes)));\n+        }\n+        return distRes;\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/Float16OperationsBenchmark.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"}]}