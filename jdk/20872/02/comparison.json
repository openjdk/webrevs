{"files":[{"patch":"@@ -370,1 +370,1 @@\n-static char* reserve_mmapped_memory(size_t bytes, char* requested_addr, MEMFLAGS flag) {\n+static char* reserve_mmapped_memory(size_t bytes, char* requested_addr, MemTag mem_tag) {\n@@ -385,1 +385,1 @@\n-    MemTracker::record_virtual_memory_reserve((address)addr, bytes, CALLER_PC, flag);\n+    MemTracker::record_virtual_memory_reserve((address)addr, bytes, CALLER_PC, mem_tag);\n@@ -498,1 +498,1 @@\n-char* os::map_memory_to_file_aligned(size_t size, size_t alignment, int file_desc, MEMFLAGS flag) {\n+char* os::map_memory_to_file_aligned(size_t size, size_t alignment, int file_desc, MemTag mem_tag) {\n@@ -506,1 +506,1 @@\n-  char* extra_base = reserve_mmapped_memory(extra_size, nullptr, flag);\n+  char* extra_base = reserve_mmapped_memory(extra_size, nullptr, mem_tag);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3431,1 +3431,1 @@\n-static char* map_or_reserve_memory_aligned(size_t size, size_t alignment, int file_desc, MEMFLAGS flag = mtNone) {\n+static char* map_or_reserve_memory_aligned(size_t size, size_t alignment, int file_desc, MemTag mem_tag = mtNone) {\n@@ -3444,2 +3444,2 @@\n-    char* extra_base = file_desc != -1 ? os::map_memory_to_file(extra_size, file_desc, flag) :\n-                                         os::reserve_memory(extra_size, false, flag);\n+    char* extra_base = file_desc != -1 ? os::map_memory_to_file(extra_size, file_desc, mem_tag) :\n+                                         os::reserve_memory(extra_size, false, mem_tag);\n@@ -3461,2 +3461,2 @@\n-    aligned_base = file_desc != -1 ? os::attempt_map_memory_to_file_at(aligned_base, size, file_desc, flag) :\n-                                     os::attempt_reserve_memory_at(aligned_base, size, false, flag);\n+    aligned_base = file_desc != -1 ? os::attempt_map_memory_to_file_at(aligned_base, size, file_desc, mem_tag) :\n+                                     os::attempt_reserve_memory_at(aligned_base, size, false, mem_tag);\n@@ -3476,2 +3476,2 @@\n-char* os::map_memory_to_file_aligned(size_t size, size_t alignment, int fd, MEMFLAGS flag) {\n-  return map_or_reserve_memory_aligned(size, alignment, fd, flag);\n+char* os::map_memory_to_file_aligned(size_t size, size_t alignment, int fd, MemTag mem_tag) {\n+  return map_or_reserve_memory_aligned(size, alignment, fd, mem_tag);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1715,1 +1715,1 @@\n-                        bool allow_exec, MEMFLAGS flags = mtNone) {\n+                        bool allow_exec, MemTag mem_tag = mtNone) {\n@@ -1718,1 +1718,1 @@\n-                             allow_exec, flags);\n+                             allow_exec, mem_tag);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-template <typename E, MEMFLAGS F>\n+template <typename E, MemTag F>\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BatchedTask.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-G1MonotonicArena::Segment::Segment(uint slot_size, uint num_slots, Segment* next, MEMFLAGS flag) :\n+G1MonotonicArena::Segment::Segment(uint slot_size, uint num_slots, Segment* next, MemTag mem_tag) :\n@@ -37,1 +37,1 @@\n-  _mem_flag(flag) {\n+  _mem_tag(mem_tag) {\n@@ -44,1 +44,1 @@\n-                                                                     MEMFLAGS mem_flag) {\n+                                                                     MemTag mem_tag) {\n@@ -46,2 +46,2 @@\n-  char* alloc_block = NEW_C_HEAP_ARRAY(char, block_size, mem_flag);\n-  return new (alloc_block) Segment(slot_size, num_slots, next, mem_flag);\n+  char* alloc_block = NEW_C_HEAP_ARRAY(char, block_size, mem_tag);\n+  return new (alloc_block) Segment(slot_size, num_slots, next, mem_tag);\n@@ -57,1 +57,1 @@\n-  FREE_C_HEAP_ARRAY(_mem_flag, segment);\n+  FREE_C_HEAP_ARRAY(_mem_tag, segment);\n@@ -111,1 +111,1 @@\n-    next = Segment::create_segment(slot_size(), num_slots, prev, _alloc_options->mem_flag());\n+    next = Segment::create_segment(slot_size(), num_slots, prev, _alloc_options->mem_tag());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonotonicArena.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -123,1 +123,1 @@\n-  const MEMFLAGS _mem_flag;\n+  const MemTag _mem_tag;\n@@ -139,1 +139,1 @@\n-  Segment(uint slot_size, uint num_slots, Segment* next, MEMFLAGS flag);\n+  Segment(uint slot_size, uint num_slots, Segment* next, MemTag mem_tag);\n@@ -176,1 +176,1 @@\n-  static Segment* create_segment(uint slot_size, uint num_slots, Segment* next, MEMFLAGS mem_flag);\n+  static Segment* create_segment(uint slot_size, uint num_slots, Segment* next, MemTag mem_tag);\n@@ -225,1 +225,1 @@\n-  const MEMFLAGS _mem_flag;\n+  const MemTag _mem_tag;\n@@ -233,2 +233,2 @@\n-  AllocOptions(MEMFLAGS mem_flag, uint slot_size, uint initial_num_slots, uint max_num_slots, uint alignment) :\n-    _mem_flag(mem_flag),\n+  AllocOptions(MemTag mem_tag, uint slot_size, uint initial_num_slots, uint max_num_slots, uint alignment) :\n+    _mem_tag(mem_tag),\n@@ -253,1 +253,1 @@\n-  MEMFLAGS mem_flag() const {return _mem_flag; }\n+  MemTag mem_tag() const {return _mem_tag; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonotonicArena.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-                                             MEMFLAGS type) :\n+                                             MemTag mem_tag) :\n@@ -47,1 +47,1 @@\n-  _memory_type(type) {\n+  _memory_tag(mem_tag) {\n@@ -51,1 +51,1 @@\n-  MemTracker::record_virtual_memory_type((address)rs.base(), type);\n+  MemTracker::record_virtual_memory_type((address)rs.base(), mem_tag);\n@@ -75,2 +75,2 @@\n-                                      MEMFLAGS type) :\n-    G1RegionToSpaceMapper(rs, actual_size, page_size, alloc_granularity, commit_factor, type),\n+                                      MemTag mem_tag) :\n+    G1RegionToSpaceMapper(rs, actual_size, page_size, alloc_granularity, commit_factor, mem_tag),\n@@ -100,1 +100,1 @@\n-    if (_memory_type == mtJavaHeap) {\n+    if (_memory_tag == mtJavaHeap) {\n@@ -153,1 +153,1 @@\n-    if (_memory_type == mtJavaHeap) {\n+    if (_memory_tag == mtJavaHeap) {\n@@ -167,2 +167,2 @@\n-                                       MEMFLAGS type) :\n-    G1RegionToSpaceMapper(rs, actual_size, page_size, alloc_granularity, commit_factor, type),\n+                                       MemTag mem_tag) :\n+    G1RegionToSpaceMapper(rs, actual_size, page_size, alloc_granularity, commit_factor, mem_tag),\n@@ -266,1 +266,1 @@\n-                                                            MEMFLAGS type) {\n+                                                            MemTag mem_tag) {\n@@ -268,1 +268,1 @@\n-    return new G1RegionsLargerThanCommitSizeMapper(rs, actual_size, page_size, region_granularity, commit_factor, type);\n+    return new G1RegionsLargerThanCommitSizeMapper(rs, actual_size, page_size, region_granularity, commit_factor, mem_tag);\n@@ -270,1 +270,1 @@\n-    return new G1RegionsSmallerThanCommitSizeMapper(rs, actual_size, page_size, region_granularity, commit_factor, type);\n+    return new G1RegionsSmallerThanCommitSizeMapper(rs, actual_size, page_size, region_granularity, commit_factor, mem_tag);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-  MEMFLAGS _memory_type;\n+  MemTag _memory_tag;\n@@ -57,1 +57,1 @@\n-  G1RegionToSpaceMapper(ReservedSpace rs, size_t used_size, size_t page_size, size_t region_granularity, size_t commit_factor, MEMFLAGS type);\n+  G1RegionToSpaceMapper(ReservedSpace rs, size_t used_size, size_t page_size, size_t region_granularity, size_t commit_factor, MemTag mem_tag);\n@@ -88,1 +88,1 @@\n-                                              MEMFLAGS type);\n+                                              MemTag mem_tag);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-                                                         MEMFLAGS memflags,\n+                                                         MemTag mem_tag,\n@@ -133,1 +133,1 @@\n-  void* mem = NEW_C_HEAP_ARRAY3(char, size_in_bytes, memflags, CURRENT_PC, alloc_fail);\n+  void* mem = NEW_C_HEAP_ARRAY3(char, size_in_bytes, mem_tag, CURRENT_PC, alloc_fail);\n@@ -346,1 +346,1 @@\n-  void* memory = NEW_C_HEAP_ARRAY_RETURN_NULL(char, size_needed, owner->memflags());\n+  void* memory = NEW_C_HEAP_ARRAY_RETURN_NULL(char, size_needed, owner->mem_tag());\n@@ -578,1 +578,1 @@\n-                                               memflags(),\n+                                               mem_tag(),\n@@ -808,2 +808,2 @@\n-OopStorage* OopStorage::create(const char* name, MEMFLAGS memflags) {\n-  return new (memflags) OopStorage(name, memflags);\n+OopStorage* OopStorage::create(const char* name, MemTag mem_tag) {\n+  return new (mem_tag) OopStorage(name, mem_tag);\n@@ -822,1 +822,1 @@\n-OopStorage::OopStorage(const char* name, MEMFLAGS memflags) :\n+OopStorage::OopStorage(const char* name, MemTag mem_tag) :\n@@ -824,1 +824,1 @@\n-  _active_array(ActiveArray::create(initial_active_array_size, memflags)),\n+  _active_array(ActiveArray::create(initial_active_array_size, mem_tag)),\n@@ -832,1 +832,1 @@\n-  _memflags(memflags),\n+  _mem_tag(mem_tag),\n@@ -1033,1 +1033,1 @@\n-MEMFLAGS OopStorage::memflags() const { return _memflags; }\n+MemTag OopStorage::mem_tag() const { return _mem_tag; }\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-  static OopStorage* create(const char* name, MEMFLAGS memflags);\n+  static OopStorage* create(const char* name, MemTag mem_tag);\n@@ -93,1 +93,1 @@\n-  MEMFLAGS memflags() const;\n+  MemTag mem_tag() const;\n@@ -277,1 +277,1 @@\n-  MEMFLAGS _memflags;\n+  MemTag _mem_tag;\n@@ -283,1 +283,1 @@\n-  OopStorage(const char* name, MEMFLAGS memflags);\n+  OopStorage(const char* name, MemTag mem_tag);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-                             MEMFLAGS memflags = mtGC,\n+                             MemTag mem_tag = mtGC,\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-OopStorage* OopStorageSet::create_strong(const char* name, MEMFLAGS memflags) {\n+OopStorage* OopStorageSet::create_strong(const char* name, MemTag mem_tag) {\n@@ -37,1 +37,1 @@\n-  OopStorage* storage = OopStorage::create(name, memflags);\n+  OopStorage* storage = OopStorage::create(name, mem_tag);\n@@ -42,1 +42,1 @@\n-OopStorage* OopStorageSet::create_weak(const char* name, MEMFLAGS memflags) {\n+OopStorage* OopStorageSet::create_weak(const char* name, MemTag mem_tag) {\n@@ -45,1 +45,1 @@\n-  OopStorage* storage = OopStorage::create(name, memflags);\n+  OopStorage* storage = OopStorage::create(name, mem_tag);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -82,2 +82,2 @@\n-  static OopStorage* create_strong(const char* name, MEMFLAGS memflags);\n-  static OopStorage* create_weak(const char* name, MEMFLAGS memflags);\n+  static OopStorage* create_strong(const char* name, MemTag mem_tag);\n+  static OopStorage* create_weak(const char* name, MemTag mem_tag);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-template <unsigned int N, MEMFLAGS F>\n+template <unsigned int N, MemTag F>\n@@ -327,1 +327,1 @@\n-template <class E, MEMFLAGS F, unsigned int N = TASKQUEUE_SIZE>\n+template <class E, MemTag F, unsigned int N = TASKQUEUE_SIZE>\n@@ -431,1 +431,1 @@\n-template<class E, MEMFLAGS F, unsigned int N = TASKQUEUE_SIZE>\n+template<class E, MemTag F, unsigned int N = TASKQUEUE_SIZE>\n@@ -470,1 +470,1 @@\n-template <MEMFLAGS F> class TaskQueueSetSuperImpl: public CHeapObj<F>, public TaskQueueSetSuper {\n+template <MemTag F> class TaskQueueSetSuperImpl: public CHeapObj<F>, public TaskQueueSetSuper {\n@@ -473,1 +473,1 @@\n-template<class T, MEMFLAGS F>\n+template<class T, MemTag F>\n@@ -521,1 +521,1 @@\n-template<class T, MEMFLAGS F> void\n+template<class T, MemTag F> void\n@@ -527,1 +527,1 @@\n-template<class T, MEMFLAGS F> T*\n+template<class T, MemTag F> T*\n@@ -534,1 +534,1 @@\n-template<class T, MEMFLAGS F>\n+template<class T, MemTag F>\n@@ -542,1 +542,1 @@\n-template<class T, MEMFLAGS F>\n+template<class T, MemTag F>\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-template <class T, MEMFLAGS F>\n+template <class T, MemTag F>\n@@ -50,1 +50,1 @@\n-template <class T, MEMFLAGS F>\n+template <class T, MemTag F>\n@@ -56,1 +56,1 @@\n-template<class T, MEMFLAGS F>\n+template<class T, MemTag F>\n@@ -63,1 +63,1 @@\n-template<class T, MEMFLAGS F>\n+template<class T, MemTag F>\n@@ -78,1 +78,1 @@\n-template<class T, MEMFLAGS F>\n+template<class T, MemTag F>\n@@ -86,1 +86,1 @@\n-template <class T, MEMFLAGS F>\n+template <class T, MemTag F>\n@@ -100,1 +100,1 @@\n-template<class E, MEMFLAGS F, unsigned int N>\n+template<class E, MemTag F, unsigned int N>\n@@ -106,1 +106,1 @@\n-template<class E, MEMFLAGS F, unsigned int N>\n+template<class E, MemTag F, unsigned int N>\n@@ -111,1 +111,1 @@\n-template<class E, MEMFLAGS F, unsigned int N> inline bool\n+template<class E, MemTag F, unsigned int N> inline bool\n@@ -137,1 +137,1 @@\n-template <class E, MEMFLAGS F, unsigned int N>\n+template <class E, MemTag F, unsigned int N>\n@@ -146,1 +146,1 @@\n-template <class E, MEMFLAGS F, unsigned int N>\n+template <class E, MemTag F, unsigned int N>\n@@ -157,1 +157,1 @@\n-template<class E, MEMFLAGS F, unsigned int N>\n+template<class E, MemTag F, unsigned int N>\n@@ -190,1 +190,1 @@\n-template<class E, MEMFLAGS F, unsigned int N> inline bool\n+template<class E, MemTag F, unsigned int N> inline bool\n@@ -227,1 +227,1 @@\n-template <class E, MEMFLAGS F, unsigned int N>\n+template <class E, MemTag F, unsigned int N>\n@@ -256,1 +256,1 @@\n-template<class E, MEMFLAGS F, unsigned int N>\n+template<class E, MemTag F, unsigned int N>\n@@ -314,1 +314,1 @@\n-template<class E, MEMFLAGS F, unsigned int N>\n+template<class E, MemTag F, unsigned int N>\n@@ -319,1 +319,1 @@\n-template<class T, MEMFLAGS F>\n+template<class T, MemTag F>\n@@ -375,1 +375,1 @@\n-template<class T, MEMFLAGS F>\n+template<class T, MemTag F>\n@@ -397,1 +397,1 @@\n-template<class E, MEMFLAGS F, unsigned int N>\n+template<class E, MemTag F, unsigned int N>\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.inline.hpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -39,1 +39,1 @@\n-template<class E, MEMFLAGS F, unsigned int N = TASKQUEUE_SIZE>\n+template<class E, MemTag F, unsigned int N = TASKQUEUE_SIZE>\n@@ -304,1 +304,1 @@\n-template <class T, MEMFLAGS F>\n+template <class T, MemTag F>\n@@ -334,1 +334,1 @@\n-template <class T, MEMFLAGS F>\n+template <class T, MemTag F>\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2016, 2024, Red Hat, Inc. All rights reserved.\n@@ -33,1 +33,1 @@\n-template <class E, MEMFLAGS F, unsigned int N>\n+template <class E, MemTag F, unsigned int N>\n@@ -48,1 +48,1 @@\n-template <class E, MEMFLAGS F, unsigned int N>\n+template <class E, MemTag F, unsigned int N>\n@@ -61,1 +61,1 @@\n-template <class E, MEMFLAGS F, unsigned int N>\n+template <class E, MemTag F, unsigned int N>\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zNMT.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/jfrbitset.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-void JfrNativeMemoryEvent::send_type_event(const Ticks& starttime, MEMFLAGS flag, size_t reserved, size_t committed) {\n+void JfrNativeMemoryEvent::send_type_event(const Ticks& starttime, MemTag mem_tag, size_t reserved, size_t committed) {\n@@ -69,1 +69,1 @@\n-  event.set_type(NMTUtil::flag_to_index(flag));\n+  event.set_type(NMTUtil::tag_to_index(mem_tag));\n@@ -82,3 +82,3 @@\n-  for (int index = 0; index < mt_number_of_types; index ++) {\n-    MEMFLAGS flag = NMTUtil::index_to_flag(index);\n-    if (flag == mtNone) {\n+  for (int index = 0; index < mt_number_of_tags; index ++) {\n+    MemTag mem_tag = NMTUtil::index_to_tag(index);\n+    if (mem_tag == mtNone) {\n@@ -88,1 +88,1 @@\n-    send_type_event(timestamp, flag, usage->reserved(flag), usage->committed(flag));\n+    send_type_event(timestamp, mem_tag, usage->reserved(mem_tag), usage->committed(mem_tag));\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrNativeMemoryEvent.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -38,1 +38,1 @@\n-  static void send_type_event(const Ticks& starttime, MEMFLAGS flag, size_t reserved, size_t committed);\n+  static void send_type_event(const Ticks& starttime, MemTag mem_tag, size_t reserved, size_t committed);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrNativeMemoryEvent.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -335,2 +335,2 @@\n-  writer.write_count(mt_number_of_types);\n-  for (int i = 0; i < mt_number_of_types; ++i) {\n+  writer.write_count(mt_number_of_tags);\n+  for (int i = 0; i < mt_number_of_tags; ++i) {\n@@ -338,2 +338,2 @@\n-    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n-    writer.write(NMTUtil::flag_to_name(flag));\n+    MemTag mem_tag = NMTUtil::index_to_tag(i);\n+    writer.write(NMTUtil::tag_to_name(mem_tag));\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-                   MEMFLAGS flags,\n+                   MemTag mem_tag,\n@@ -42,1 +42,1 @@\n-  char* p = (char*) os::malloc(size, flags, stack);\n+  char* p = (char*) os::malloc(size, mem_tag, stack);\n@@ -50,1 +50,1 @@\n-                   MEMFLAGS flags,\n+                   MemTag mem_tag,\n@@ -52,1 +52,1 @@\n-  return AllocateHeap(size, flags, CALLER_PC, alloc_failmode);\n+  return AllocateHeap(size, mem_tag, CALLER_PC, alloc_failmode);\n@@ -57,1 +57,1 @@\n-                     MEMFLAGS flag,\n+                     MemTag mem_tag,\n@@ -59,1 +59,1 @@\n-  char* p = (char*) os::realloc(old, size, flag, CALLER_PC);\n+  char* p = (char*) os::realloc(old, size, mem_tag, CALLER_PC);\n@@ -120,2 +120,2 @@\n-void* AnyObj::operator new(size_t size, MEMFLAGS flags) throw() {\n-  address res = (address)AllocateHeap(size, flags, CALLER_PC);\n+void* AnyObj::operator new(size_t size, MemTag mem_tag) throw() {\n+  address res = (address)AllocateHeap(size, mem_tag, CALLER_PC);\n@@ -127,1 +127,1 @@\n-    MEMFLAGS flags) throw() {\n+    MemTag mem_tag) throw() {\n@@ -129,1 +129,1 @@\n-    address res = (address)AllocateHeap(size, flags, CALLER_PC, AllocFailStrategy::RETURN_NULL);\n+    address res = (address)AllocateHeap(size, mem_tag, CALLER_PC, AllocFailStrategy::RETURN_NULL);\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -97,3 +97,3 @@\n-\/\/ char* AllocateHeap(size_t size, MEMFLAGS flags, const NativeCallStack& stack, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n-\/\/ char* AllocateHeap(size_t size, MEMFLAGS flags, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n-\/\/ char* ReallocateHeap(char *old, size_t size, MEMFLAGS flag, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n+\/\/ char* AllocateHeap(size_t size, MemTag mem_tag, const NativeCallStack& stack, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n+\/\/ char* AllocateHeap(size_t size, MemTag mem_tag, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n+\/\/ char* ReallocateHeap(char *old, size_t size, MemTag mem_tag, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n@@ -109,1 +109,1 @@\n-                   MEMFLAGS flags,\n+                   MemTag mem_tag,\n@@ -113,1 +113,1 @@\n-                   MEMFLAGS flags,\n+                   MemTag mem_tag,\n@@ -118,1 +118,1 @@\n-                     MEMFLAGS flag,\n+                     MemTag mem_tag,\n@@ -126,2 +126,2 @@\n-  ALWAYSINLINE void* operator new(size_t size, MEMFLAGS f) {\n-    return AllocateHeap(size, f);\n+  ALWAYSINLINE void* operator new(size_t size, MemTag mem_tag) {\n+    return AllocateHeap(size, mem_tag);\n@@ -131,1 +131,1 @@\n-                                  MEMFLAGS f,\n+                                  MemTag mem_tag,\n@@ -133,1 +133,1 @@\n-    return AllocateHeap(size, f, stack);\n+    return AllocateHeap(size, mem_tag, stack);\n@@ -137,1 +137,1 @@\n-                                  MEMFLAGS f,\n+                                  MemTag mem_tag,\n@@ -140,1 +140,1 @@\n-    return AllocateHeap(size, f, stack, AllocFailStrategy::RETURN_NULL);\n+    return AllocateHeap(size, mem_tag, stack, AllocFailStrategy::RETURN_NULL);\n@@ -144,1 +144,1 @@\n-                                  MEMFLAGS f,\n+                                  MemTag mem_tag,\n@@ -146,1 +146,1 @@\n-    return AllocateHeap(size, f, AllocFailStrategy::RETURN_NULL);\n+    return AllocateHeap(size, mem_tag, AllocFailStrategy::RETURN_NULL);\n@@ -149,2 +149,2 @@\n-  ALWAYSINLINE void* operator new[](size_t size, MEMFLAGS f) {\n-    return AllocateHeap(size, f);\n+  ALWAYSINLINE void* operator new[](size_t size, MemTag mem_tag) {\n+    return AllocateHeap(size, mem_tag);\n@@ -154,1 +154,1 @@\n-                                    MEMFLAGS f,\n+                                    MemTag mem_tag,\n@@ -156,1 +156,1 @@\n-    return AllocateHeap(size, f, stack);\n+    return AllocateHeap(size, mem_tag, stack);\n@@ -160,1 +160,1 @@\n-                                    MEMFLAGS f,\n+                                    MemTag mem_tag,\n@@ -163,1 +163,1 @@\n-    return AllocateHeap(size, f, stack, AllocFailStrategy::RETURN_NULL);\n+    return AllocateHeap(size, mem_tag, stack, AllocFailStrategy::RETURN_NULL);\n@@ -167,1 +167,1 @@\n-                                    MEMFLAGS f,\n+                                    MemTag mem_tag,\n@@ -169,1 +169,1 @@\n-    return AllocateHeap(size, f, AllocFailStrategy::RETURN_NULL);\n+    return AllocateHeap(size, mem_tag, AllocFailStrategy::RETURN_NULL);\n@@ -177,1 +177,1 @@\n-template<MEMFLAGS F>\n+template<MemTag F>\n@@ -442,4 +442,4 @@\n-  void* operator new(size_t size, MEMFLAGS flags) throw();\n-  void* operator new [](size_t size, MEMFLAGS flags) throw() = delete;\n-  void* operator new(size_t size, const std::nothrow_t&  nothrow_constant, MEMFLAGS flags) throw();\n-  void* operator new [](size_t size, const std::nothrow_t&  nothrow_constant, MEMFLAGS flags) throw() = delete;\n+  void* operator new(size_t size, MemTag mem_tag) throw();\n+  void* operator new [](size_t size, MemTag mem_tag) throw() = delete;\n+  void* operator new(size_t size, const std::nothrow_t&  nothrow_constant, MemTag mem_tag) throw();\n+  void* operator new [](size_t size, const std::nothrow_t&  nothrow_constant, MemTag mem_tag) throw() = delete;\n@@ -513,2 +513,2 @@\n-#define NEW_C_HEAP_ARRAY3(type, size, memflags, pc, allocfail)\\\n-  (type*) AllocateHeap((size) * sizeof(type), memflags, pc, allocfail)\n+#define NEW_C_HEAP_ARRAY3(type, size, mem_tag, pc, allocfail)\\\n+  (type*) AllocateHeap((size) * sizeof(type), mem_tag, pc, allocfail)\n@@ -516,2 +516,2 @@\n-#define NEW_C_HEAP_ARRAY2(type, size, memflags, pc)\\\n-  (type*) (AllocateHeap((size) * sizeof(type), memflags, pc))\n+#define NEW_C_HEAP_ARRAY2(type, size, mem_tag, pc)\\\n+  (type*) (AllocateHeap((size) * sizeof(type), mem_tag, pc))\n@@ -519,2 +519,2 @@\n-#define NEW_C_HEAP_ARRAY(type, size, memflags)\\\n-  (type*) (AllocateHeap((size) * sizeof(type), memflags))\n+#define NEW_C_HEAP_ARRAY(type, size, mem_tag)\\\n+  (type*) (AllocateHeap((size) * sizeof(type), mem_tag))\n@@ -522,2 +522,2 @@\n-#define NEW_C_HEAP_ARRAY2_RETURN_NULL(type, size, memflags, pc)\\\n-  NEW_C_HEAP_ARRAY3(type, (size), memflags, pc, AllocFailStrategy::RETURN_NULL)\n+#define NEW_C_HEAP_ARRAY2_RETURN_NULL(type, size, mem_tag, pc)\\\n+  NEW_C_HEAP_ARRAY3(type, (size), mem_tag, pc, AllocFailStrategy::RETURN_NULL)\n@@ -525,2 +525,2 @@\n-#define NEW_C_HEAP_ARRAY_RETURN_NULL(type, size, memflags)\\\n-  NEW_C_HEAP_ARRAY2(type, (size), memflags, AllocFailStrategy::RETURN_NULL)\n+#define NEW_C_HEAP_ARRAY_RETURN_NULL(type, size, mem_tag)\\\n+  NEW_C_HEAP_ARRAY2(type, (size), mem_tag, AllocFailStrategy::RETURN_NULL)\n@@ -528,2 +528,2 @@\n-#define REALLOC_C_HEAP_ARRAY(type, old, size, memflags)\\\n-  (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), memflags))\n+#define REALLOC_C_HEAP_ARRAY(type, old, size, mem_tag)\\\n+  (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), mem_tag))\n@@ -531,2 +531,2 @@\n-#define REALLOC_C_HEAP_ARRAY_RETURN_NULL(type, old, size, memflags)\\\n-  (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), memflags, AllocFailStrategy::RETURN_NULL))\n+#define REALLOC_C_HEAP_ARRAY_RETURN_NULL(type, old, size, mem_tag)\\\n+  (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), mem_tag, AllocFailStrategy::RETURN_NULL))\n@@ -538,2 +538,2 @@\n-#define NEW_C_HEAP_OBJ(type, memflags)\\\n-  NEW_C_HEAP_ARRAY(type, 1, memflags)\n+#define NEW_C_HEAP_OBJ(type, mem_tag)\\\n+  NEW_C_HEAP_ARRAY(type, 1, mem_tag)\n@@ -541,2 +541,2 @@\n-#define NEW_C_HEAP_OBJ_RETURN_NULL(type, memflags)\\\n-  NEW_C_HEAP_ARRAY_RETURN_NULL(type, 1, memflags)\n+#define NEW_C_HEAP_OBJ_RETURN_NULL(type, mem_tag)\\\n+  NEW_C_HEAP_ARRAY_RETURN_NULL(type, 1, mem_tag)\n@@ -571,2 +571,2 @@\n-  static E* allocate_or_null(size_t length, MEMFLAGS flags);\n-  static E* allocate(size_t length, MEMFLAGS flags);\n+  static E* allocate_or_null(size_t length, MemTag mem_tag);\n+  static E* allocate(size_t length, MemTag mem_tag);\n@@ -582,2 +582,2 @@\n-  static E* allocate(size_t length, MEMFLAGS flags);\n-  static E* reallocate(E* addr, size_t new_length, MEMFLAGS flags);\n+  static E* allocate(size_t length, MemTag mem_tag);\n+  static E* reallocate(E* addr, size_t new_length, MemTag mem_tag);\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":50,"deletions":50,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-E* MmapArrayAllocator<E>::allocate_or_null(size_t length, MEMFLAGS flags) {\n+E* MmapArrayAllocator<E>::allocate_or_null(size_t length, MemTag mem_tag) {\n@@ -61,1 +61,1 @@\n-  char* addr = os::reserve_memory(size, !ExecMem, flags);\n+  char* addr = os::reserve_memory(size, !ExecMem, mem_tag);\n@@ -75,1 +75,1 @@\n-E* MmapArrayAllocator<E>::allocate(size_t length, MEMFLAGS flags) {\n+E* MmapArrayAllocator<E>::allocate(size_t length, MemTag mem_tag) {\n@@ -78,1 +78,1 @@\n-  char* addr = os::reserve_memory(size, !ExecMem, flags);\n+  char* addr = os::reserve_memory(size, !ExecMem, mem_tag);\n@@ -100,2 +100,2 @@\n-E* MallocArrayAllocator<E>::allocate(size_t length, MEMFLAGS flags) {\n-  return (E*)AllocateHeap(size_for(length), flags);\n+E* MallocArrayAllocator<E>::allocate(size_t length, MemTag mem_tag) {\n+  return (E*)AllocateHeap(size_for(length), mem_tag);\n@@ -105,2 +105,2 @@\n-E* MallocArrayAllocator<E>::reallocate(E* addr, size_t new_length, MEMFLAGS flags) {\n-  return (E*)ReallocateHeap((char*)addr, size_for(new_length), flags);\n+E* MallocArrayAllocator<E>::reallocate(E* addr, size_t new_length, MemTag mem_tag) {\n+  return (E*)ReallocateHeap((char*)addr, size_for(new_length), mem_tag);\n","filename":"src\/hotspot\/share\/memory\/allocation.inline.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -225,2 +225,2 @@\n-Arena::Arena(MEMFLAGS flag, Tag tag, size_t init_size) :\n-  _flags(flag), _tag(tag),\n+Arena::Arena(MemTag mem_tag, Tag tag, size_t init_size) :\n+  _mem_tag(mem_tag), _tag(tag),\n@@ -236,1 +236,1 @@\n-  MemTracker::record_new_arena(flag);\n+  MemTracker::record_new_arena(mem_tag);\n@@ -242,1 +242,1 @@\n-  MemTracker::record_arena_free(_flags);\n+  MemTracker::record_arena_free(_mem_tag);\n@@ -262,2 +262,2 @@\n-    MemTracker::record_arena_size_change(delta, _flags);\n-    if (CompilationMemoryStatistic::enabled() && _flags == mtCompiler) {\n+    MemTracker::record_arena_size_change(delta, _mem_tag);\n+    if (CompilationMemoryStatistic::enabled() && _mem_tag == mtCompiler) {\n@@ -289,1 +289,1 @@\n-  if (MemTracker::check_exceeds_limit(x, _flags)) {\n+  if (MemTracker::check_exceeds_limit(x, _mem_tag)) {\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-  const MEMFLAGS _flags;        \/\/ Memory tracking flags\n+  const MemTag _mem_tag;        \/\/ Native Memory Tracking tag\n@@ -141,1 +141,1 @@\n-  Arena(MEMFLAGS memflag, Tag tag = Tag::tag_other, size_t init_size = Chunk::init_size);\n+  Arena(MemTag mem_tag, Tag tag = Tag::tag_other, size_t init_size = Chunk::init_size);\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n","filename":"src\/hotspot\/share\/memory\/guardedMemory.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,2 +105,2 @@\n-MemRegion* MemRegion::create_array(size_t length, MEMFLAGS flags) {\n-  MemRegion* result = NEW_C_HEAP_ARRAY(MemRegion, length, flags);\n+MemRegion* MemRegion::create_array(size_t length, MemTag mem_tag) {\n+  MemRegion* result = NEW_C_HEAP_ARRAY(MemRegion, length, mem_tag);\n","filename":"src\/hotspot\/share\/memory\/memRegion.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-  static MemRegion* create_array(size_t length, MEMFLAGS flags);\n+  static MemRegion* create_array(size_t length, MemTag mem_tag);\n","filename":"src\/hotspot\/share\/memory\/memRegion.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -92,1 +92,1 @@\n-template <class T, MEMFLAGS flags, size_t alignment = DEFAULT_PADDING_SIZE>\n+template <class T, MemTag mem_tag, size_t alignment = DEFAULT_PADDING_SIZE>\n@@ -103,1 +103,1 @@\n-template <class T, MEMFLAGS flags, size_t alignment = DEFAULT_PADDING_SIZE>\n+template <class T, MemTag mem_tag, size_t alignment = DEFAULT_PADDING_SIZE>\n@@ -115,1 +115,1 @@\n-template <class T, MEMFLAGS flags, size_t alignment = DEFAULT_PADDING_SIZE>\n+template <class T, MemTag mem_tag, size_t alignment = DEFAULT_PADDING_SIZE>\n","filename":"src\/hotspot\/share\/memory\/padded.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n-template <class T, MEMFLAGS flags, size_t alignment>\n-PaddedEnd<T>* PaddedArray<T, flags, alignment>::create_unfreeable(uint length) {\n+template <class T, MemTag mem_tag, size_t alignment>\n+PaddedEnd<T>* PaddedArray<T, mem_tag, alignment>::create_unfreeable(uint length) {\n@@ -43,1 +43,1 @@\n-  void* chunk = AllocateHeap(length * sizeof(PaddedEnd<T, alignment>) + alignment, flags);\n+  void* chunk = AllocateHeap(length * sizeof(PaddedEnd<T, alignment>) + alignment, mem_tag);\n@@ -56,2 +56,2 @@\n-template <class T, MEMFLAGS flags, size_t alignment>\n-T** Padded2DArray<T, flags, alignment>::create_unfreeable(uint rows, uint columns, size_t* allocation_size) {\n+template <class T, MemTag mem_tag, size_t alignment>\n+T** Padded2DArray<T, mem_tag, alignment>::create_unfreeable(uint rows, uint columns, size_t* allocation_size) {\n@@ -66,1 +66,1 @@\n-  void* chunk = MmapArrayAllocator<uint8_t>::allocate(total_size, flags);\n+  void* chunk = MmapArrayAllocator<uint8_t>::allocate(total_size, mem_tag);\n@@ -84,2 +84,2 @@\n-template <class T, MEMFLAGS flags, size_t alignment>\n-T* PaddedPrimitiveArray<T, flags, alignment>::create_unfreeable(size_t length) {\n+template <class T, MemTag mem_tag, size_t alignment>\n+T* PaddedPrimitiveArray<T, mem_tag, alignment>::create_unfreeable(size_t length) {\n@@ -90,2 +90,2 @@\n-template <class T, MEMFLAGS flags, size_t alignment>\n-T* PaddedPrimitiveArray<T, flags, alignment>::create(size_t length, void** alloc_base) {\n+template <class T, MemTag mem_tag, size_t alignment>\n+T* PaddedPrimitiveArray<T, mem_tag, alignment>::create(size_t length, void** alloc_base) {\n@@ -93,1 +93,1 @@\n-  void* chunk = AllocateHeap(length * sizeof(T) + alignment, flags);\n+  void* chunk = AllocateHeap(length * sizeof(T) + alignment, mem_tag);\n","filename":"src\/hotspot\/share\/memory\/padded.inline.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-  ResourceArea(MEMFLAGS flags = mtThread) :\n-    Arena(flags, Arena::Tag::tag_ra) DEBUG_ONLY(COMMA _nesting(0)) {}\n+  ResourceArea(MemTag mem_tag = mtThread) :\n+    Arena(mem_tag, Arena::Tag::tag_ra) DEBUG_ONLY(COMMA _nesting(0)) {}\n@@ -57,2 +57,2 @@\n-  ResourceArea(size_t init_size, MEMFLAGS flags = mtThread) :\n-    Arena(flags, Arena::Tag::tag_ra, init_size) DEBUG_ONLY(COMMA _nesting(0)) {\n+  ResourceArea(size_t init_size, MemTag mem_tag = mtThread) :\n+    Arena(mem_tag, Arena::Tag::tag_ra, init_size) DEBUG_ONLY(COMMA _nesting(0)) {\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -36,1 +36,1 @@\n-  const MEMFLAGS         _flag;\n+  const MemTag           _mem_tag;\n@@ -38,1 +38,1 @@\n-  AllocationSite(const NativeCallStack& stack, MEMFLAGS flag) : _call_stack(stack), _flag(flag) { }\n+  AllocationSite(const NativeCallStack& stack, MemTag mem_tag) : _call_stack(stack), _mem_tag(mem_tag) { }\n@@ -52,1 +52,1 @@\n-  MEMFLAGS flag() const { return _flag; }\n+  MemTag mem_tag() const { return _mem_tag; }\n","filename":"src\/hotspot\/share\/nmt\/allocationSite.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-template<typename E, MEMFLAGS flag>\n+template<typename E, MemTag mem_tag>\n@@ -55,1 +55,1 @@\n-  GrowableArrayCHeap<BackingElement, flag> _backing_storage;\n+  GrowableArrayCHeap<BackingElement, mem_tag> _backing_storage;\n","filename":"src\/hotspot\/share\/nmt\/arrayWithFreeList.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -36,1 +36,1 @@\n-\/\/ The malloc header, as well as the coming VMATree implementation, rely on MEMFLAGS\n+\/\/ The malloc header, as well as the coming VMATree implementation, rely on MemTag\n@@ -38,1 +38,1 @@\n-STATIC_ASSERT(sizeof(MEMFLAGS) == sizeof(uint8_t));\n+STATIC_ASSERT(sizeof(MemTag) == sizeof(uint8_t));\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -95,1 +95,1 @@\n-  const MEMFLAGS _flags;\n+  const MemTag _mem_tag;\n@@ -124,1 +124,1 @@\n-    const MEMFLAGS flags;\n+    const MemTag mem_tag;\n@@ -128,1 +128,1 @@\n-  inline MallocHeader(size_t size, MEMFLAGS flags, uint32_t mst_marker);\n+  inline MallocHeader(size_t size, MemTag mem_tag, uint32_t mst_marker);\n@@ -130,2 +130,2 @@\n-  inline size_t   size()  const { return _size; }\n-  inline MEMFLAGS flags() const { return _flags; }\n+  inline size_t size()  const { return _size; }\n+  inline MemTag mem_tag() const { return _mem_tag; }\n@@ -136,1 +136,1 @@\n-    return FreeInfo{this->size(), this->flags(), this->mst_marker()};\n+    return FreeInfo{this->size(), this->mem_tag(), this->mst_marker()};\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n-inline MallocHeader::MallocHeader(size_t size, MEMFLAGS flags, uint32_t mst_marker)\n-  : _size(size), _mst_marker(mst_marker), _flags(flags),\n+inline MallocHeader::MallocHeader(size_t size, MemTag mem_tag, uint32_t mst_marker)\n+  : _size(size), _mst_marker(mst_marker), _mem_tag(mem_tag),\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -83,1 +83,1 @@\n-  bool match_category(MEMFLAGS* out) {\n+  bool match_category(MemTag* out) {\n@@ -93,3 +93,3 @@\n-    MEMFLAGS f = NMTUtil::string_to_flag(ss.base());\n-    if (f != mtNone) {\n-      *out = f;\n+    MemTag mem_tag = NMTUtil::string_to_mem_tag(ss.base());\n+    if (mem_tag != mtNone) {\n+      *out = mem_tag;\n@@ -134,2 +134,2 @@\n-void MallocLimitSet::set_category_limit(MEMFLAGS f, size_t s, MallocLimitMode flag) {\n-  const int i = NMTUtil::flag_to_index(f);\n+void MallocLimitSet::set_category_limit(MemTag mem_tag, size_t s, MallocLimitMode flag) {\n+  const int i = NMTUtil::tag_to_index(mem_tag);\n@@ -142,2 +142,2 @@\n-  for (int i = 0; i < mt_number_of_types; i++) {\n-    set_category_limit(NMTUtil::index_to_flag(i), 0, MallocLimitMode::trigger_fatal);\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    set_category_limit(NMTUtil::index_to_tag(i), 0, MallocLimitMode::trigger_fatal);\n@@ -153,1 +153,1 @@\n-    for (int i = 0; i < mt_number_of_types; i++) {\n+    for (int i = 0; i < mt_number_of_tags; i++) {\n@@ -156,1 +156,1 @@\n-                     NMTUtil::flag_to_enum_name(NMTUtil::index_to_flag(i)),\n+                     NMTUtil::tag_to_enum_name(NMTUtil::index_to_tag(i)),\n@@ -190,1 +190,1 @@\n-      MEMFLAGS f;\n+      MemTag mem_tag;\n@@ -193,1 +193,1 @@\n-      BAIL_UNLESS(sst.match_category(&f), \"Expected category name\");\n+      BAIL_UNLESS(sst.match_category(&mem_tag), \"Expected category name\");\n@@ -196,1 +196,1 @@\n-      malloclimit* const modified_limit = &_cat[NMTUtil::flag_to_index(f)];\n+      malloclimit* const modified_limit = &_cat[NMTUtil::tag_to_index(mem_tag)];\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -49,1 +49,1 @@\n-  malloclimit _cat[mt_number_of_types]; \/\/ per-category limit\n+  malloclimit _cat[mt_number_of_tags]; \/\/ per-category limit\n@@ -56,2 +56,2 @@\n-  void set_global_limit(size_t s, MallocLimitMode flag);\n-  void set_category_limit(MEMFLAGS f, size_t s, MallocLimitMode flag);\n+  void set_global_limit(size_t s, MallocLimitMode type);\n+  void set_category_limit(MemTag mem_tag, size_t s, MallocLimitMode mode);\n@@ -60,1 +60,1 @@\n-  const malloclimit* category_limit(MEMFLAGS f) const { return &_cat[(int)f]; }\n+  const malloclimit* category_limit(MemTag mem_tag) const { return &_cat[(int)mem_tag]; }\n@@ -72,1 +72,1 @@\n-  static const malloclimit* category_limit(MEMFLAGS f) { return _limits.category_limit(f); }\n+  static const malloclimit* category_limit(MemTag mem_tag) { return _limits.category_limit(mem_tag); }\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,2 +114,2 @@\n-MallocSite* MallocSiteTable::lookup_or_add(const NativeCallStack& key, uint32_t* marker, MEMFLAGS flags) {\n-  assert(flags != mtNone, \"Should have a real memory type\");\n+MallocSite* MallocSiteTable::lookup_or_add(const NativeCallStack& key, uint32_t* marker, MemTag mem_tag) {\n+  assert(mem_tag != mtNone, \"Should have a real memory tag\");\n@@ -122,1 +122,1 @@\n-    MallocSiteHashtableEntry* entry = new_entry(key, flags);\n+    MallocSiteHashtableEntry* entry = new_entry(key, mem_tag);\n@@ -140,1 +140,1 @@\n-      if (site->flag() == flags && site->equals(key)) {\n+      if (site->mem_tag() == mem_tag && site->equals(key)) {\n@@ -147,1 +147,1 @@\n-      MallocSiteHashtableEntry* entry = new_entry(key, flags);\n+      MallocSiteHashtableEntry* entry = new_entry(key, mem_tag);\n@@ -180,1 +180,1 @@\n-MallocSiteHashtableEntry* MallocSiteTable::new_entry(const NativeCallStack& key, MEMFLAGS flags) {\n+MallocSiteHashtableEntry* MallocSiteTable::new_entry(const NativeCallStack& key, MemTag mem_tag) {\n@@ -183,1 +183,1 @@\n-  return ::new (p) MallocSiteHashtableEntry(key, flags);\n+  return ::new (p) MallocSiteHashtableEntry(key, mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/mallocSiteTable.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-  MallocSite(const NativeCallStack& stack, MEMFLAGS flags) :\n-    AllocationSite(stack, flags) {}\n+  MallocSite(const NativeCallStack& stack, MemTag mem_tag) :\n+    AllocationSite(stack, mem_tag) {}\n@@ -66,3 +66,3 @@\n-  MallocSiteHashtableEntry(NativeCallStack stack, MEMFLAGS flags):\n-    _malloc_site(stack, flags), _hash(stack.calculate_hash()), _next(nullptr) {\n-    assert(flags != mtNone, \"Expect a real memory type\");\n+  MallocSiteHashtableEntry(NativeCallStack stack, MemTag mem_tag):\n+    _malloc_site(stack, mem_tag), _hash(stack.calculate_hash()), _next(nullptr) {\n+    assert(mem_tag != mtNone, \"Expect a real memory type\");\n@@ -150,2 +150,2 @@\n-      uint32_t* marker, MEMFLAGS flags) {\n-    MallocSite* site = lookup_or_add(stack, marker, flags);\n+      uint32_t* marker, MemTag mem_tag) {\n+    MallocSite* site = lookup_or_add(stack, marker, mem_tag);\n@@ -173,1 +173,1 @@\n-  static MallocSiteHashtableEntry* new_entry(const NativeCallStack& key, MEMFLAGS flags);\n+  static MallocSiteHashtableEntry* new_entry(const NativeCallStack& key, MemTag mem_tag);\n@@ -175,1 +175,1 @@\n-  static MallocSite* lookup_or_add(const NativeCallStack& key, uint32_t* marker, MEMFLAGS flags);\n+  static MallocSite* lookup_or_add(const NativeCallStack& key, uint32_t* marker, MemTag mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/mallocSiteTable.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  for (int index = 0; index < mt_number_of_types; index ++) {\n+  for (int index = 0; index < mt_number_of_tags; index ++) {\n@@ -84,1 +84,1 @@\n-  for (int index = 0; index < mt_number_of_types; index ++) {\n+  for (int index = 0; index < mt_number_of_tags; index ++) {\n@@ -94,1 +94,1 @@\n-  int chunk_idx = NMTUtil::flag_to_index(mtChunk);\n+  int chunk_idx = NMTUtil::tag_to_index(mtChunk);\n@@ -131,1 +131,1 @@\n-bool MallocMemorySummary::category_limit_reached(MEMFLAGS f, size_t s, size_t so_far, const malloclimit* limit) {\n+bool MallocMemorySummary::category_limit_reached(MemTag mem_tag, size_t s, size_t so_far, const malloclimit* limit) {\n@@ -135,1 +135,1 @@\n-  NMTUtil::flag_to_enum_name(f), PROPERFMTARGS(s), PROPERFMTARGS(so_far), PROPERFMTARGS(limit->sz)\n+  NMTUtil::tag_to_enum_name(mem_tag), PROPERFMTARGS(s), PROPERFMTARGS(so_far), PROPERFMTARGS(limit->sz)\n@@ -170,1 +170,1 @@\n-void* MallocTracker::record_malloc(void* malloc_base, size_t size, MEMFLAGS flags,\n+void* MallocTracker::record_malloc(void* malloc_base, size_t size, MemTag mem_tag,\n@@ -176,1 +176,1 @@\n-  MallocMemorySummary::record_malloc(size, flags);\n+  MallocMemorySummary::record_malloc(size, mem_tag);\n@@ -179,1 +179,1 @@\n-    MallocSiteTable::allocation_at(stack, size, &mst_marker, flags);\n+    MallocSiteTable::allocation_at(stack, size, &mst_marker, mem_tag);\n@@ -183,1 +183,1 @@\n-  MallocHeader* const header = ::new (malloc_base)MallocHeader(size, flags, mst_marker);\n+  MallocHeader* const header = ::new (malloc_base)MallocHeader(size, mem_tag, mst_marker);\n@@ -195,1 +195,1 @@\n-    assert(header2->flags() == flags, \"Wrong flags\");\n+    assert(header2->mem_tag() == mem_tag, \"Wrong memory tag\");\n@@ -216,1 +216,1 @@\n-  MallocMemorySummary::record_free(free_info.size, free_info.flags);\n+  MallocMemorySummary::record_free(free_info.size, free_info.mem_tag);\n@@ -299,1 +299,1 @@\n-                 block->size(), NMTUtil::flag_to_enum_name(block->flags()));\n+                 block->size(), NMTUtil::tag_to_enum_name(block->mem_tag()));\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -153,1 +153,1 @@\n-  MallocMemory      _malloc[mt_number_of_types];\n+  MallocMemory      _malloc[mt_number_of_tags];\n@@ -158,2 +158,2 @@\n-  inline MallocMemory* by_type(MEMFLAGS flags) {\n-    int index = NMTUtil::flag_to_index(flags);\n+  inline MallocMemory* by_type(MemTag mem_tag) {\n+    int index = NMTUtil::tag_to_index(mem_tag);\n@@ -163,2 +163,2 @@\n-  inline const MallocMemory* by_type(MEMFLAGS flags) const {\n-    int index = NMTUtil::flag_to_index(flags);\n+  inline const MallocMemory* by_type(MemTag mem_tag) const {\n+    int index = NMTUtil::tag_to_index(mem_tag);\n@@ -217,1 +217,1 @@\n-  static bool category_limit_reached(MEMFLAGS f, size_t s, size_t so_far, const malloclimit* limit);\n+  static bool category_limit_reached(MemTag mem_tag, size_t s, size_t so_far, const malloclimit* limit);\n@@ -222,2 +222,2 @@\n-   static inline void record_malloc(size_t size, MEMFLAGS flag) {\n-     as_snapshot()->by_type(flag)->record_malloc(size);\n+   static inline void record_malloc(size_t size, MemTag mem_tag) {\n+     as_snapshot()->by_type(mem_tag)->record_malloc(size);\n@@ -227,2 +227,2 @@\n-   static inline void record_free(size_t size, MEMFLAGS flag) {\n-     as_snapshot()->by_type(flag)->record_free(size);\n+   static inline void record_free(size_t size, MemTag mem_tag) {\n+     as_snapshot()->by_type(mem_tag)->record_free(size);\n@@ -232,2 +232,2 @@\n-   static inline void record_new_arena(MEMFLAGS flag) {\n-     as_snapshot()->by_type(flag)->record_new_arena();\n+   static inline void record_new_arena(MemTag mem_tag) {\n+     as_snapshot()->by_type(mem_tag)->record_new_arena();\n@@ -236,2 +236,2 @@\n-   static inline void record_arena_free(MEMFLAGS flag) {\n-     as_snapshot()->by_type(flag)->record_arena_free();\n+   static inline void record_arena_free(MemTag mem_tag) {\n+     as_snapshot()->by_type(mem_tag)->record_arena_free();\n@@ -240,2 +240,2 @@\n-   static inline void record_arena_size_change(ssize_t size, MEMFLAGS flag) {\n-     as_snapshot()->by_type(flag)->record_arena_size_change(size);\n+   static inline void record_arena_size_change(ssize_t size, MemTag mem_tag) {\n+     as_snapshot()->by_type(mem_tag)->record_arena_size_change(size);\n@@ -260,1 +260,1 @@\n-  static inline bool check_exceeds_limit(size_t s, MEMFLAGS f);\n+  static inline bool check_exceeds_limit(size_t s, MemTag mem_tag);\n@@ -283,1 +283,1 @@\n-  static void* record_malloc(void* malloc_base, size_t size, MEMFLAGS flags,\n+  static void* record_malloc(void* malloc_base, size_t size, MemTag mem_tag,\n@@ -292,2 +292,2 @@\n-  static inline void record_new_arena(MEMFLAGS flags) {\n-    MallocMemorySummary::record_new_arena(flags);\n+  static inline void record_new_arena(MemTag mem_tag) {\n+    MallocMemorySummary::record_new_arena(mem_tag);\n@@ -296,2 +296,2 @@\n-  static inline void record_arena_free(MEMFLAGS flags) {\n-    MallocMemorySummary::record_arena_free(flags);\n+  static inline void record_arena_free(MemTag mem_tag) {\n+    MallocMemorySummary::record_arena_free(mem_tag);\n@@ -300,2 +300,2 @@\n-  static inline void record_arena_size_change(ssize_t size, MEMFLAGS flags) {\n-    MallocMemorySummary::record_arena_size_change(size, flags);\n+  static inline void record_arena_size_change(ssize_t size, MemTag mem_tag) {\n+    MallocMemorySummary::record_arena_size_change(size, mem_tag);\n@@ -306,1 +306,1 @@\n-  static inline bool check_exceeds_limit(size_t s, MEMFLAGS f);\n+  static inline bool check_exceeds_limit(size_t s, MemTag mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.hpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-inline bool MallocMemorySummary::check_exceeds_limit(size_t s, MEMFLAGS f) {\n+inline bool MallocMemorySummary::check_exceeds_limit(size_t s, MemTag mem_tag) {\n@@ -53,1 +53,1 @@\n-      l = MallocLimitHandler::category_limit(f);\n+      l = MallocLimitHandler::category_limit(mem_tag);\n@@ -55,1 +55,1 @@\n-        const MallocMemory* mm = as_snapshot()->by_type(f);\n+        const MallocMemory* mm = as_snapshot()->by_type(mem_tag);\n@@ -58,1 +58,1 @@\n-          return category_limit_reached(f, s, so_far, l);\n+          return category_limit_reached(mem_tag, s, so_far, l);\n@@ -67,2 +67,2 @@\n-inline bool MallocTracker::check_exceeds_limit(size_t s, MEMFLAGS f) {\n-  return MallocMemorySummary::check_exceeds_limit(s, f);\n+inline bool MallocTracker::check_exceeds_limit(size_t s, MemTag mem_tag) {\n+  return MallocMemorySummary::check_exceeds_limit(s, mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    res = (int)(NMTUtil::flag_to_index(s1.flag()) - NMTUtil::flag_to_index(s2.flag()));\n+    res = (int)(NMTUtil::tag_to_index(s1.mem_tag()) - NMTUtil::tag_to_index(s2.mem_tag()));\n@@ -210,1 +210,1 @@\n-    VirtualMemoryAllocationSite tmp(*rgn->call_stack(), rgn->flag());\n+    VirtualMemoryAllocationSite tmp(*rgn->call_stack(), rgn->mem_tag());\n","filename":"src\/hotspot\/share\/nmt\/memBaseline.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,1 +147,1 @@\n-  MallocMemory* malloc_memory(MEMFLAGS flag) {\n+  MallocMemory* malloc_memory(MemTag mem_tag) {\n@@ -149,1 +149,1 @@\n-    return _malloc_memory_snapshot.by_type(flag);\n+    return _malloc_memory_snapshot.by_type(mem_tag);\n@@ -152,1 +152,1 @@\n-  VirtualMemory* virtual_memory(MEMFLAGS flag) {\n+  VirtualMemory* virtual_memory(MemTag mem_tag) {\n@@ -154,1 +154,1 @@\n-    return _virtual_memory_snapshot.by_type(flag);\n+    return _virtual_memory_snapshot.by_type(mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/memBaseline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2024, Red Hat, Inc. All rights reserved.\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_NMT_MEMFLAGBITMAP_HPP\n-#define SHARE_NMT_MEMFLAGBITMAP_HPP\n-\n-#include \"nmt\/memflags.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class MemFlagBitmap {\n-  uint32_t _v;\n-  STATIC_ASSERT(sizeof(_v) * BitsPerByte >= mt_number_of_types);\n-\n-public:\n-  MemFlagBitmap(uint32_t v = 0) : _v(v) {}\n-  MemFlagBitmap(const MemFlagBitmap& o) : _v(o._v) {}\n-\n-  uint32_t raw_value() const { return _v; }\n-\n-  void set_flag(MEMFLAGS f) {\n-    const int bitno = (int)f;\n-    _v |= nth_bit(bitno);\n-  }\n-\n-  bool has_flag(MEMFLAGS f) const {\n-    const int bitno = (int)f;\n-    return _v & nth_bit(bitno);\n-  }\n-\n-  bool has_any() const { return _v > 0; }\n-};\n-\n-#endif \/\/ SHARE_NMT_NMTUSAGE_HPP\n","filename":"src\/hotspot\/share\/nmt\/memFlagBitmap.hpp","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -35,2 +35,2 @@\n-#include \"nmt\/memflags.hpp\"\n-#include \"nmt\/memFlagBitmap.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"nmt\/memTagBitmap.hpp\"\n@@ -53,1 +53,1 @@\n-\/\/ those that have been used with mmap. Flags left out are printed with their nmt flag name.\n+\/\/ those that have been used with mmap. Flags left out are printed with their nmt tags name.\n@@ -55,1 +55,1 @@\n-  \/* flag, short, description *\/ \\\n+  \/* mem_tag, short, description *\/ \\\n@@ -70,2 +70,2 @@\n-static const char* get_shortname_for_nmt_flag(MEMFLAGS f) {\n-#define DO(flag, shortname, text) if (flag == f) return shortname;\n+static const char* get_shortname_for_mem_tag(MemTag mem_tag) {\n+#define DO(t, shortname, text) if (t == mem_tag) return shortname;\n@@ -74,1 +74,1 @@\n-  return NMTUtil::flag_to_enum_name(f);\n+  return NMTUtil::tag_to_enum_name(mem_tag);\n@@ -91,1 +91,1 @@\n-  MEMFLAGS* _flags;\n+  MemTag* _mem_tags;\n@@ -96,1 +96,1 @@\n-  CachedNMTInformation() : _ranges(nullptr), _flags(nullptr),\n+  CachedNMTInformation() : _ranges(nullptr), _mem_tags(nullptr),\n@@ -101,1 +101,1 @@\n-    ALLOW_C_FUNCTION(free, ::free(_flags);)\n+    ALLOW_C_FUNCTION(free, ::free(_mem_tags);)\n@@ -104,1 +104,1 @@\n-  bool add(const void* from, const void* to, MEMFLAGS f) {\n+  bool add(const void* from, const void* to, MemTag mem_tag) {\n@@ -107,2 +107,2 @@\n-    \/\/ we can just fold two regions if they are adjacent and have the same flag.\n-    if (_count > 0 && from == _ranges[_count - 1].to && f == _flags[_count - 1]) {\n+    \/\/ we can just fold two regions if they are adjacent and have the same mem_tag.\n+    if (_count > 0 && from == _ranges[_count - 1].to && mem_tag == _mem_tags[_count - 1]) {\n@@ -117,2 +117,2 @@\n-      ALLOW_C_FUNCTION(realloc, _flags = (MEMFLAGS*)::realloc(_flags, new_capacity * sizeof(MEMFLAGS));)\n-      if (_ranges == nullptr || _flags == nullptr) {\n+      ALLOW_C_FUNCTION(realloc, _mem_tags = (MemTag*)::realloc(_mem_tags, new_capacity * sizeof(MemTag));)\n+      if (_ranges == nullptr || _mem_tags == nullptr) {\n@@ -126,1 +126,1 @@\n-    _flags[_count] = f;\n+    _mem_tags[_count] = mem_tag;\n@@ -133,1 +133,1 @@\n-  MemFlagBitmap lookup(const void* from, const void* to) const {\n+  MemTagBitmap lookup(const void* from, const void* to) const {\n@@ -142,1 +142,1 @@\n-    MemFlagBitmap bm;\n+    MemTagBitmap bm;\n@@ -145,1 +145,1 @@\n-        bm.set_flag(_flags[i]);\n+        bm.set_tag(_mem_tags[i]);\n@@ -156,1 +156,1 @@\n-    return add(rgn->base(), rgn->end(), rgn->flag());\n+    return add(rgn->base(), rgn->end(), rgn->mem_tag());\n@@ -250,1 +250,1 @@\n-    const MemFlagBitmap flags = _nmt_info.lookup(vma_from, vma_to);\n+    const MemTagBitmap flags = _nmt_info.lookup(vma_from, vma_to);\n@@ -252,3 +252,3 @@\n-      for (int i = 0; i < mt_number_of_types; i++) {\n-        const MEMFLAGS flag = (MEMFLAGS)i;\n-        if (flags.has_flag(flag)) {\n+      for (int i = 0; i < mt_number_of_tags; i++) {\n+        const MemTag mem_tag = (MemTag)i;\n+        if (flags.has_tag(mem_tag)) {\n@@ -258,2 +258,2 @@\n-          _out->print(\"%s\", get_shortname_for_nmt_flag(flag));\n-          if (flag == mtThreadStack) {\n+          _out->print(\"%s\", get_shortname_for_mem_tag(mem_tag));\n+          if (mem_tag == mtThreadStack) {\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -73,1 +73,1 @@\n-void MemReporterBase::print_malloc(const MemoryCounter* c, MEMFLAGS flag) const {\n+void MemReporterBase::print_malloc(const MemoryCounter* c, MemTag mem_tag) const {\n@@ -76,1 +76,1 @@\n-  const char* alloc_type = (flag == mtThreadStack) ? \"\" : \"malloc=\";\n+  const char* alloc_type = (mem_tag == mtThreadStack) ? \"\" : \"malloc=\";\n@@ -81,1 +81,1 @@\n-  if (flag != mtNone) {\n+  if (mem_tag != mtNone) {\n@@ -83,1 +83,1 @@\n-      amount_in_current_scale(amount), scale, NMTUtil::flag_to_name(flag));\n+      amount_in_current_scale(amount), scale, NMTUtil::tag_to_name(mem_tag));\n@@ -180,2 +180,2 @@\n-  for (int index = 0; index < mt_number_of_types; index ++) {\n-    MEMFLAGS flag = NMTUtil::index_to_flag(index);\n+  for (int index = 0; index < mt_number_of_tags; index ++) {\n+    MemTag mem_tag = NMTUtil::index_to_tag(index);\n@@ -183,3 +183,3 @@\n-    if (flag == mtThreadStack) continue;\n-    MallocMemory* malloc_memory = _malloc_snapshot->by_type(flag);\n-    VirtualMemory* virtual_memory = _vm_snapshot->by_type(flag);\n+    if (mem_tag == mtThreadStack) continue;\n+    MallocMemory* malloc_memory = _malloc_snapshot->by_type(mem_tag);\n+    VirtualMemory* virtual_memory = _vm_snapshot->by_type(mem_tag);\n@@ -187,1 +187,1 @@\n-    report_summary_of_type(flag, malloc_memory, virtual_memory);\n+    report_summary_of_type(mem_tag, malloc_memory, virtual_memory);\n@@ -191,1 +191,1 @@\n-void MemSummaryReporter::report_summary_of_type(MEMFLAGS flag,\n+void MemSummaryReporter::report_summary_of_type(MemTag mem_tag,\n@@ -198,1 +198,1 @@\n-  if (flag == mtThread) {\n+  if (mem_tag == mtThread) {\n@@ -203,1 +203,1 @@\n-  } else if (flag == mtNMT) {\n+  } else if (mem_tag == mtNMT) {\n@@ -222,1 +222,1 @@\n-  out->print(\"-%*s (\", indent - 2, NMTUtil::flag_to_name(flag));\n+  out->print(\"-%*s (\", indent - 2, NMTUtil::tag_to_name(mem_tag));\n@@ -225,1 +225,1 @@\n-  if (flag == mtClassShared) {\n+  if (mem_tag == mtClassShared) {\n@@ -235,1 +235,1 @@\n-  if (flag == mtClass) {\n+  if (mem_tag == mtClass) {\n@@ -240,1 +240,1 @@\n-  } else if (flag == mtThread) {\n+  } else if (mem_tag == mtThread) {\n@@ -266,1 +266,1 @@\n-  if (flag == mtNMT &&\n+  if (mem_tag == mtNMT &&\n@@ -270,1 +270,1 @@\n-  } else if (flag == mtClass) {\n+  } else if (mem_tag == mtClass) {\n@@ -341,2 +341,2 @@\n-    MEMFLAGS flag = malloc_site->flag();\n-    assert(NMTUtil::flag_is_valid(flag) && flag != mtNone,\n+    MemTag mem_tag = malloc_site->mem_tag();\n+    assert(NMTUtil::tag_is_valid(mem_tag) && mem_tag != mtNone,\n@@ -346,1 +346,1 @@\n-      print_malloc(malloc_site->counter(), flag);\n+      print_malloc(malloc_site->counter(), mem_tag);\n@@ -381,3 +381,3 @@\n-      const MEMFLAGS flag = virtual_memory_site->flag();\n-      if (flag != mtNone) {\n-        out->print(\" Type=%s\", NMTUtil::flag_to_name(flag));\n+      const MemTag mem_tag = virtual_memory_site->mem_tag();\n+      if (mem_tag != mtNone) {\n+        out->print(\" Type=%s\", NMTUtil::tag_to_name(mem_tag));\n@@ -426,1 +426,1 @@\n-  out->print(\" for %s\", NMTUtil::flag_to_name(reserved_rgn->flag()));\n+  out->print(\" for %s\", NMTUtil::tag_to_name(reserved_rgn->mem_tag()));\n@@ -523,2 +523,2 @@\n-  for (int index = 0; index < mt_number_of_types; index ++) {\n-    MEMFLAGS flag = NMTUtil::index_to_flag(index);\n+  for (int index = 0; index < mt_number_of_tags; index ++) {\n+    MemTag mem_tag = NMTUtil::index_to_tag(index);\n@@ -526,4 +526,4 @@\n-    if (flag == mtThreadStack) continue;\n-    diff_summary_of_type(flag,\n-      _early_baseline.malloc_memory(flag),\n-      _early_baseline.virtual_memory(flag),\n+    if (mem_tag == mtThreadStack) continue;\n+    diff_summary_of_type(mem_tag,\n+      _early_baseline.malloc_memory(mem_tag),\n+      _early_baseline.virtual_memory(mem_tag),\n@@ -531,2 +531,2 @@\n-      _current_baseline.malloc_memory(flag),\n-      _current_baseline.virtual_memory(flag),\n+      _current_baseline.malloc_memory(mem_tag),\n+      _current_baseline.virtual_memory(mem_tag),\n@@ -538,1 +538,1 @@\n-    size_t early_amount, size_t early_count, MEMFLAGS flags) const {\n+    size_t early_amount, size_t early_count, MemTag mem_tag) const {\n@@ -541,1 +541,1 @@\n-  const char* alloc_type = (flags == mtThread) ? \"\" : \"malloc=\";\n+  const char* alloc_tag = (mem_tag == mtThread) ? \"\" : \"malloc=\";\n@@ -543,1 +543,1 @@\n-  out->print(\"%s\" SIZE_FORMAT \"%s\", alloc_type, amount_in_current_scale(current_amount), scale);\n+  out->print(\"%s\" SIZE_FORMAT \"%s\", alloc_tag, amount_in_current_scale(current_amount), scale);\n@@ -545,2 +545,2 @@\n-  if (flags != mtNone && flags != mtThread) {\n-    out->print(\" type=%s\", NMTUtil::flag_to_name(flags));\n+  if (mem_tag != mtNone && mem_tag != mtThread) {\n+    out->print(\" type=%s\", NMTUtil::tag_to_name(mem_tag));\n@@ -597,1 +597,1 @@\n-void MemSummaryDiffReporter::diff_summary_of_type(MEMFLAGS flag,\n+void MemSummaryDiffReporter::diff_summary_of_type(MemTag mem_tag,\n@@ -616,1 +616,1 @@\n-  if (flag == mtThread) {\n+  if (mem_tag == mtThread) {\n@@ -627,1 +627,1 @@\n-  } else if (flag == mtNMT) {\n+  } else if (mem_tag == mtNMT) {\n@@ -639,1 +639,1 @@\n-    out->print(\"-%*s (\", indent - 2, NMTUtil::flag_to_name(flag));\n+    out->print(\"-%*s (\", indent - 2, NMTUtil::tag_to_name(mem_tag));\n@@ -647,1 +647,1 @@\n-    if (flag == mtClass) {\n+    if (mem_tag == mtClass) {\n@@ -671,1 +671,1 @@\n-    } else if (flag == mtThread) {\n+    } else if (mem_tag == mtThread) {\n@@ -699,1 +699,1 @@\n-      print_malloc_diff(current_malloc_amount, (flag == mtChunk) ? 0 : current_malloc->malloc_count(),\n+      print_malloc_diff(current_malloc_amount, (mem_tag == mtChunk) ? 0 : current_malloc->malloc_count(),\n@@ -723,1 +723,1 @@\n-    if (flag == mtNMT) {\n+    if (mem_tag == mtNMT) {\n@@ -736,1 +736,1 @@\n-    } else if (flag == mtClass) {\n+    } else if (mem_tag == mtClass) {\n@@ -850,3 +850,3 @@\n-      } else if (early_site->flag() != current_site->flag()) {\n-        \/\/ This site was originally allocated with one flag, then released,\n-        \/\/ then re-allocated at the same site (as far as we can tell) with a different flag.\n+      } else if (early_site->mem_tag() != current_site->mem_tag()) {\n+        \/\/ This site was originally allocated with one memory type, then released,\n+        \/\/ then re-allocated at the same site (as far as we can tell) with a different memory type.\n@@ -869,1 +869,1 @@\n-    0, 0, malloc_site->flag());\n+    0, 0, malloc_site->mem_tag());\n@@ -874,1 +874,1 @@\n-    malloc_site->count(), malloc_site->flag());\n+    malloc_site->count(), malloc_site->mem_tag());\n@@ -879,1 +879,1 @@\n-  if (early->flag() != current->flag()) {\n+  if (early->mem_tag() != current->mem_tag()) {\n@@ -886,1 +886,1 @@\n-      early->size(), early->count(), early->flag());\n+      early->size(), early->count(), early->mem_tag());\n@@ -891,1 +891,1 @@\n-  size_t current_count, size_t early_size, size_t early_count, MEMFLAGS flags) const {\n+  size_t current_count, size_t early_size, size_t early_count, MemTag mem_tag) const {\n@@ -903,1 +903,1 @@\n-    print_malloc_diff(current_size, current_count, early_size, early_count, flags);\n+    print_malloc_diff(current_size, current_count, early_size, early_count, mem_tag);\n@@ -912,1 +912,1 @@\n-  diff_virtual_memory_site(site->call_stack(), site->reserved(), site->committed(), 0, 0, site->flag());\n+  diff_virtual_memory_site(site->call_stack(), site->reserved(), site->committed(), 0, 0, site->mem_tag());\n@@ -916,1 +916,1 @@\n-  diff_virtual_memory_site(site->call_stack(), 0, 0, site->reserved(), site->committed(), site->flag());\n+  diff_virtual_memory_site(site->call_stack(), 0, 0, site->reserved(), site->committed(), site->mem_tag());\n@@ -922,1 +922,1 @@\n-    early->reserved(), early->committed(), current->flag());\n+    early->reserved(), early->committed(), current->mem_tag());\n@@ -926,1 +926,1 @@\n-  size_t current_committed, size_t early_reserved, size_t early_committed, MEMFLAGS flag) const  {\n+  size_t current_committed, size_t early_reserved, size_t early_committed, MemTag mem_tag) const  {\n@@ -939,2 +939,2 @@\n-    if (flag != mtNone) {\n-      out->print(\" Type=%s\", NMTUtil::flag_to_name(flag));\n+    if (mem_tag != mtNone) {\n+      out->print(\" Type=%s\", NMTUtil::tag_to_name(mem_tag));\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":64,"deletions":64,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  void print_malloc(const MemoryCounter* c, MEMFLAGS flag = mtNone) const;\n+  void print_malloc(const MemoryCounter* c, MemTag mem_tag = mtNone) const;\n@@ -142,1 +142,1 @@\n-  void report_summary_of_type(MEMFLAGS type, MallocMemory* malloc_memory,\n+  void report_summary_of_type(MemTag mem_tag, MallocMemory* malloc_memory,\n@@ -206,2 +206,2 @@\n-  \/\/ report the comparison of each memory type\n-  void diff_summary_of_type(MEMFLAGS type,\n+  \/\/ report the comparison of each mem_tag\n+  void diff_summary_of_type(MemTag mem_tag,\n@@ -215,1 +215,1 @@\n-    size_t early_amount, size_t early_count, MEMFLAGS flags) const;\n+    size_t early_amount, size_t early_count, MemTag mem_tag) const;\n@@ -265,1 +265,1 @@\n-    size_t currrent_count, size_t early_size, size_t early_count, MEMFLAGS flags) const;\n+    size_t currrent_count, size_t early_size, size_t early_count, MemTag mem_tag) const;\n@@ -267,1 +267,1 @@\n-    size_t current_committed, size_t early_reserved, size_t early_committed, MEMFLAGS flag) const;\n+    size_t current_committed, size_t early_reserved, size_t early_committed, MemTag mem_tag) const;\n","filename":"src\/hotspot\/share\/nmt\/memReporter.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_NMT_MEM_TAG_HPP\n+#define SHARE_NMT_MEM_TAG_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#define MEMORY_TAG_DO(f)                                                             \\\n+  \/* Memory tag by sub systems. It occupies lower byte. *\/                           \\\n+  f(mtJavaHeap,       \"Java Heap\")   \/* Java heap                                 *\/ \\\n+  f(mtClass,          \"Class\")       \/* Java classes                              *\/ \\\n+  f(mtThread,         \"Thread\")      \/* thread objects                            *\/ \\\n+  f(mtThreadStack,    \"Thread Stack\")                                                \\\n+  f(mtCode,           \"Code\")        \/* generated code                            *\/ \\\n+  f(mtGC,             \"GC\")                                                          \\\n+  f(mtGCCardSet,      \"GCCardSet\")   \/* G1 card set remembered set                *\/ \\\n+  f(mtCompiler,       \"Compiler\")                                                    \\\n+  f(mtJVMCI,          \"JVMCI\")                                                       \\\n+  f(mtInternal,       \"Internal\")    \/* memory used by VM, but does not belong to *\/ \\\n+                                     \/* any of above categories, and not used by  *\/ \\\n+                                     \/* NMT                                       *\/ \\\n+  f(mtOther,          \"Other\")       \/* memory not used by VM                     *\/ \\\n+  f(mtSymbol,         \"Symbol\")                                                      \\\n+  f(mtNMT,            \"Native Memory Tracking\")  \/* memory used by NMT            *\/ \\\n+  f(mtClassShared,    \"Shared class space\")      \/* class data sharing            *\/ \\\n+  f(mtChunk,          \"Arena Chunk\") \/* chunk that holds content of arenas        *\/ \\\n+  f(mtTest,           \"Test\")        \/* Test type for verifying NMT               *\/ \\\n+  f(mtTracing,        \"Tracing\")                                                     \\\n+  f(mtLogging,        \"Logging\")                                                     \\\n+  f(mtStatistics,     \"Statistics\")                                                  \\\n+  f(mtArguments,      \"Arguments\")                                                   \\\n+  f(mtModule,         \"Module\")                                                      \\\n+  f(mtSafepoint,      \"Safepoint\")                                                   \\\n+  f(mtSynchronizer,   \"Synchronization\")                                             \\\n+  f(mtServiceability, \"Serviceability\")                                              \\\n+  f(mtMetaspace,      \"Metaspace\")                                                   \\\n+  f(mtStringDedup,    \"String Deduplication\")                                        \\\n+  f(mtObjectMonitor,  \"Object Monitors\")                                             \\\n+  f(mtNone,           \"Unknown\")                                                     \\\n+  \/\/end\n+\n+#define MEMORY_TAG_DECLARE_ENUM(mem_tag, human_readable) \\\n+mem_tag,\n+\n+enum class MemTag : uint8_t  {\n+  MEMORY_TAG_DO(MEMORY_TAG_DECLARE_ENUM)\n+  mt_number_of_tags    \/\/ number of memory tags (mtDontTrack\n+                       \/\/ is not included as validate tag)\n+};\n+\n+#define MEMORY_TAG_SHORTNAME(mem_tag, human_readable) \\\n+  constexpr MemTag mem_tag = MemTag::mem_tag;\n+\n+\/\/ Generate short aliases for the enum values. E.g. mtGC instead of MemTag::mtGC.\n+MEMORY_TAG_DO(MEMORY_TAG_SHORTNAME)\n+\n+\/\/ Make an int version of the sentinel end value.\n+constexpr int mt_number_of_tags = static_cast<int>(MemTag::mt_number_of_tags);\n+\n+#endif \/\/ SHARE_NMT_MEM_TAG_HPP\n","filename":"src\/hotspot\/share\/nmt\/memTag.hpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_NMT_MEMTAGBITMAP_HPP\n+#define SHARE_NMT_MEMTAGBITMAP_HPP\n+\n+#include \"nmt\/memTag.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class MemTagBitmap {\n+  uint32_t _v;\n+  STATIC_ASSERT(sizeof(_v) * BitsPerByte >= mt_number_of_tags);\n+\n+public:\n+  MemTagBitmap(uint32_t v = 0) : _v(v) {}\n+  MemTagBitmap(const MemTagBitmap& o) : _v(o._v) {}\n+\n+  uint32_t raw_value() const { return _v; }\n+\n+  void set_tag(MemTag mem_tag) {\n+    const int bitno = (int)mem_tag;\n+    _v |= nth_bit(bitno);\n+  }\n+\n+  bool has_tag(MemTag mem_tag) const {\n+    const int bitno = (int)mem_tag;\n+    return _v & nth_bit(bitno);\n+  }\n+\n+  bool has_any() const { return _v > 0; }\n+};\n+\n+#endif \/\/ SHARE_NMT_MEMTAGBITMAP_HPP\n","filename":"src\/hotspot\/share\/nmt\/memTagBitmap.hpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -66,1 +66,1 @@\n-  STATIC_ASSERT(mt_number_of_types <= max_jubyte);\n+  STATIC_ASSERT(mt_number_of_tags <= max_jubyte);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-  static inline void* record_malloc(void* mem_base, size_t size, MEMFLAGS flag,\n+  static inline void* record_malloc(void* mem_base, size_t size, MemTag mem_tag,\n@@ -82,1 +82,1 @@\n-      return MallocTracker::record_malloc(mem_base, size, flag, stack);\n+      return MallocTracker::record_malloc(mem_base, size, mem_tag, stack);\n@@ -102,1 +102,1 @@\n-  static inline void record_new_arena(MEMFLAGS flag) {\n+  static inline void record_new_arena(MemTag mem_tag) {\n@@ -104,1 +104,1 @@\n-    MallocTracker::record_new_arena(flag);\n+    MallocTracker::record_new_arena(mem_tag);\n@@ -108,1 +108,1 @@\n-  static inline void record_arena_free(MEMFLAGS flag) {\n+  static inline void record_arena_free(MemTag mem_tag) {\n@@ -110,1 +110,1 @@\n-    MallocTracker::record_arena_free(flag);\n+    MallocTracker::record_arena_free(mem_tag);\n@@ -115,1 +115,1 @@\n-  static inline void record_arena_size_change(ssize_t diff, MEMFLAGS flag) {\n+  static inline void record_arena_size_change(ssize_t diff, MemTag mem_tag) {\n@@ -117,1 +117,1 @@\n-    MallocTracker::record_arena_size_change(diff, flag);\n+    MallocTracker::record_arena_size_change(diff, mem_tag);\n@@ -124,1 +124,1 @@\n-    MEMFLAGS flag = mtNone) {\n+    MemTag mem_tag = mtNone) {\n@@ -129,1 +129,1 @@\n-      VirtualMemoryTracker::add_reserved_region((address)addr, size, stack, flag);\n+      VirtualMemoryTracker::add_reserved_region((address)addr, size, stack, mem_tag);\n@@ -150,1 +150,1 @@\n-    const NativeCallStack& stack, MEMFLAGS flag = mtNone) {\n+    const NativeCallStack& stack, MemTag mem_tag = mtNone) {\n@@ -155,1 +155,1 @@\n-      VirtualMemoryTracker::add_reserved_region((address)addr, size, stack, flag);\n+      VirtualMemoryTracker::add_reserved_region((address)addr, size, stack, mem_tag);\n@@ -186,1 +186,1 @@\n-                                       const NativeCallStack& stack, MEMFLAGS flag) {\n+                                       const NativeCallStack& stack, MemTag mem_tag) {\n@@ -191,1 +191,1 @@\n-    MemoryFileTracker::Instance::allocate_memory(file, offset, size, stack, flag);\n+    MemoryFileTracker::Instance::allocate_memory(file, offset, size, stack, mem_tag);\n@@ -209,1 +209,1 @@\n-  static inline void record_virtual_memory_split_reserved(void* addr, size_t size, size_t split, MEMFLAGS flag, MEMFLAGS split_flag) {\n+  static inline void record_virtual_memory_split_reserved(void* addr, size_t size, size_t split, MemTag mem_tag, MemTag split_tag) {\n@@ -214,1 +214,1 @@\n-      VirtualMemoryTracker::split_reserved_region((address)addr, size, split, flag, split_flag);\n+      VirtualMemoryTracker::split_reserved_region((address)addr, size, split, mem_tag, split_tag);\n@@ -218,1 +218,1 @@\n-  static inline void record_virtual_memory_type(void* addr, MEMFLAGS flag) {\n+  static inline void record_virtual_memory_type(void* addr, MemTag mem_tag) {\n@@ -223,1 +223,1 @@\n-      VirtualMemoryTracker::set_reserved_region_type((address)addr, flag);\n+      VirtualMemoryTracker::set_reserved_region_type((address)addr, mem_tag);\n@@ -265,2 +265,2 @@\n-  \/\/ under category f would hit either the global limit or the limit for category f.\n-  static inline bool check_exceeds_limit(size_t s, MEMFLAGS f);\n+  \/\/ under category f would hit either the global limit or the limit for mem_tag.\n+  static inline bool check_exceeds_limit(size_t s, MemTag mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-inline bool MemTracker::check_exceeds_limit(size_t s, MEMFLAGS f) {\n+inline bool MemTracker::check_exceeds_limit(size_t s, MemTag mem_tag) {\n@@ -37,1 +37,1 @@\n-  return MallocTracker::check_exceeds_limit(s, f);\n+  return MallocTracker::check_exceeds_limit(s, mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_NMT_MEMFLAGS_HPP\n-#define SHARE_NMT_MEMFLAGS_HPP\n-\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-#define MEMORY_TYPES_DO(f)                                                           \\\n-  \/* Memory type by sub systems. It occupies lower byte. *\/                          \\\n-  f(mtJavaHeap,       \"Java Heap\")   \/* Java heap                                 *\/ \\\n-  f(mtClass,          \"Class\")       \/* Java classes                              *\/ \\\n-  f(mtThread,         \"Thread\")      \/* thread objects                            *\/ \\\n-  f(mtThreadStack,    \"Thread Stack\")                                                \\\n-  f(mtCode,           \"Code\")        \/* generated code                            *\/ \\\n-  f(mtGC,             \"GC\")                                                          \\\n-  f(mtGCCardSet,      \"GCCardSet\")   \/* G1 card set remembered set                *\/ \\\n-  f(mtCompiler,       \"Compiler\")                                                    \\\n-  f(mtJVMCI,          \"JVMCI\")                                                       \\\n-  f(mtInternal,       \"Internal\")    \/* memory used by VM, but does not belong to *\/ \\\n-                                     \/* any of above categories, and not used by  *\/ \\\n-                                     \/* NMT                                       *\/ \\\n-  f(mtOther,          \"Other\")       \/* memory not used by VM                     *\/ \\\n-  f(mtSymbol,         \"Symbol\")                                                      \\\n-  f(mtNMT,            \"Native Memory Tracking\")  \/* memory used by NMT            *\/ \\\n-  f(mtClassShared,    \"Shared class space\")      \/* class data sharing            *\/ \\\n-  f(mtChunk,          \"Arena Chunk\") \/* chunk that holds content of arenas        *\/ \\\n-  f(mtTest,           \"Test\")        \/* Test type for verifying NMT               *\/ \\\n-  f(mtTracing,        \"Tracing\")                                                     \\\n-  f(mtLogging,        \"Logging\")                                                     \\\n-  f(mtStatistics,     \"Statistics\")                                                  \\\n-  f(mtArguments,      \"Arguments\")                                                   \\\n-  f(mtModule,         \"Module\")                                                      \\\n-  f(mtSafepoint,      \"Safepoint\")                                                   \\\n-  f(mtSynchronizer,   \"Synchronization\")                                             \\\n-  f(mtServiceability, \"Serviceability\")                                              \\\n-  f(mtMetaspace,      \"Metaspace\")                                                   \\\n-  f(mtStringDedup,    \"String Deduplication\")                                        \\\n-  f(mtObjectMonitor,  \"Object Monitors\")                                             \\\n-  f(mtNone,           \"Unknown\")                                                     \\\n-  \/\/end\n-\n-#define MEMORY_TYPE_DECLARE_ENUM(type, human_readable) \\\n-  type,\n-\n-enum class MEMFLAGS : uint8_t  {\n-  MEMORY_TYPES_DO(MEMORY_TYPE_DECLARE_ENUM)\n-  mt_number_of_types   \/\/ number of memory types (mtDontTrack\n-                       \/\/ is not included as validate type)\n-};\n-\n-#define MEMORY_TYPE_SHORTNAME(type, human_readable) \\\n-  constexpr MEMFLAGS type = MEMFLAGS::type;\n-\n-\/\/ Generate short aliases for the enum values. E.g. mtGC instead of MEMFLAGS::mtGC.\n-MEMORY_TYPES_DO(MEMORY_TYPE_SHORTNAME)\n-\n-\/\/ Make an int version of the sentinel end value.\n-constexpr int mt_number_of_types = static_cast<int>(MEMFLAGS::mt_number_of_types);\n-\n-#endif \/\/ SHARE_NMT_MEMFLAGS_HPP\n","filename":"src\/hotspot\/share\/nmt\/memflags.hpp","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -45,1 +45,1 @@\n-                                        MEMFLAGS flag) {\n+                                        MemTag mem_tag) {\n@@ -47,1 +47,1 @@\n-  VMATree::RegionData regiondata(sidx, flag);\n+  VMATree::RegionData regiondata(sidx, mem_tag);\n@@ -49,4 +49,4 @@\n-  for (int i = 0; i < mt_number_of_types; i++) {\n-    VirtualMemory* summary = file->_summary.by_type(NMTUtil::index_to_flag(i));\n-    summary->reserve_memory(diff.flag[i].commit);\n-    summary->commit_memory(diff.flag[i].commit);\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    VirtualMemory* summary = file->_summary.by_type(NMTUtil::index_to_tag(i));\n+    summary->reserve_memory(diff.tag[i].commit);\n+    summary->commit_memory(diff.tag[i].commit);\n@@ -58,4 +58,4 @@\n-  for (int i = 0; i < mt_number_of_types; i++) {\n-    VirtualMemory* summary = file->_summary.by_type(NMTUtil::index_to_flag(i));\n-    summary->reserve_memory(diff.flag[i].commit);\n-    summary->commit_memory(diff.flag[i].commit);\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    VirtualMemory* summary = file->_summary.by_type(NMTUtil::index_to_tag(i));\n+    summary->reserve_memory(diff.tag[i].commit);\n+    summary->commit_memory(diff.tag[i].commit);\n@@ -82,1 +82,1 @@\n-    if (broken_start != nullptr && prev->val().out.type() != current->val().in.type()) {\n+    if (broken_start != nullptr && prev->val().out.mem_tag() != current->val().in.mem_tag()) {\n@@ -87,1 +87,1 @@\n-    if (prev->val().out.type() == VMATree::StateType::Committed) {\n+    if (prev->val().out.state() == VMATree::StateType::Committed) {\n@@ -94,1 +94,1 @@\n-                       NMTUtil::flag_to_name(prev->val().out.flag()));\n+                       NMTUtil::tag_to_name(prev->val().out.mem_tag()));\n@@ -108,2 +108,2 @@\n-                  VMATree::statetype_to_string(broken_start->val().out.type()),\n-                  VMATree::statetype_to_string(broken_end->val().in.type()));\n+                  VMATree::statetype_to_string(broken_start->val().out.mem_tag()),\n+                  VMATree::statetype_to_string(broken_end->val().in.mem_tag()));\n@@ -141,2 +141,2 @@\n-                                                  MEMFLAGS flag) {\n-  _tracker->allocate_memory(file, offset, size, stack, flag);\n+                                                  MemTag mem_tag) {\n+  _tracker->allocate_memory(file, offset, size, stack, mem_tag);\n@@ -184,3 +184,3 @@\n-    for (int i = 0; i < mt_number_of_types; i++) {\n-      VirtualMemory* snap = snapshot->by_type(NMTUtil::index_to_flag(i));\n-      const VirtualMemory* current = file->_summary.by_type(NMTUtil::index_to_flag(i));\n+    for (int i = 0; i < mt_number_of_tags; i++) {\n+      VirtualMemory* snap = snapshot->by_type(NMTUtil::index_to_tag(i));\n+      const VirtualMemory* current = file->_summary.by_type(NMTUtil::index_to_tag(i));\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-                       MEMFLAGS flag);\n+                       MemTag mem_tag);\n@@ -99,1 +99,1 @@\n-                                const NativeCallStack& stack, MEMFLAGS flag);\n+                                const NativeCallStack& stack, MemTag mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/nativeCallStackPrinter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#define MEMORY_TYPE_DECLARE_NAME(type, human_readable) \\\n+#define MEMORY_TAG_DECLARE_NAME(type, human_readable) \\\n@@ -36,1 +36,1 @@\n-  MEMORY_TYPES_DO(MEMORY_TYPE_DECLARE_NAME)\n+  MEMORY_TAG_DO(MEMORY_TAG_DECLARE_NAME)\n@@ -90,2 +90,2 @@\n-MEMFLAGS NMTUtil::string_to_flag(const char* s) {\n-  for (int i = 0; i < mt_number_of_types; i ++) {\n+MemTag NMTUtil::string_to_mem_tag(const char* s) {\n+  for (int i = 0; i < mt_number_of_tags; i ++) {\n@@ -97,1 +97,1 @@\n-      return (MEMFLAGS)i;\n+      return (MemTag)i;\n","filename":"src\/hotspot\/share\/nmt\/nmtCommon.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -78,3 +78,3 @@\n-  \/\/ Check if index is a valid MEMFLAGS enum value (including mtNone)\n-  static inline bool flag_index_is_valid(int index) {\n-    return index >= 0 && index < mt_number_of_types;\n+  \/\/ Check if index is a valid MemTag enum value (including mtNone)\n+  static inline bool tag_index_is_valid(int index) {\n+    return index >= 0 && index < mt_number_of_tags;\n@@ -83,4 +83,4 @@\n-  \/\/ Check if flag value is a valid MEMFLAGS enum value (including mtNone)\n-  static inline bool flag_is_valid(MEMFLAGS flag) {\n-    const int index = static_cast<int>(flag);\n-    return flag_index_is_valid(index);\n+  \/\/ Check if tag value is a valid MemTag enum value (including mtNone)\n+  static inline bool tag_is_valid(MemTag mem_tag) {\n+    const int index = static_cast<int>(mem_tag);\n+    return tag_index_is_valid(index);\n@@ -89,4 +89,4 @@\n-  \/\/ Map memory type to index\n-  static inline int flag_to_index(MEMFLAGS flag) {\n-    assert(flag_is_valid(flag), \"Invalid flag (%u)\", (unsigned)flag);\n-    return static_cast<int>(flag);\n+  \/\/ Map memory tag to index\n+  static inline int tag_to_index(MemTag mem_tag) {\n+    assert(tag_is_valid(mem_tag), \"Invalid type (%u)\", (unsigned)mem_tag);\n+    return static_cast<int>(mem_tag);\n@@ -95,3 +95,3 @@\n-  \/\/ Map memory type to human readable name\n-  static const char* flag_to_name(MEMFLAGS flag) {\n-    return _strings[flag_to_index(flag)].human_readable;\n+  \/\/ Map memory tag to human readable name\n+  static const char* tag_to_name(MemTag mem_tag) {\n+    return _strings[tag_to_index(mem_tag)].human_readable;\n@@ -100,3 +100,3 @@\n-  \/\/ Map memory type to literalized enum name (e.g. \"mtTest\")\n-  static const char* flag_to_enum_name(MEMFLAGS flag) {\n-    return _strings[flag_to_index(flag)].enum_s;\n+  \/\/ Map memory tag to literalized enum name (e.g. \"mtTest\")\n+  static const char* tag_to_enum_name(MemTag mem_tag) {\n+    return _strings[tag_to_index(mem_tag)].enum_s;\n@@ -105,4 +105,4 @@\n-  \/\/ Map an index to memory type\n-  static MEMFLAGS index_to_flag(int index) {\n-    assert(flag_index_is_valid(index), \"Invalid flag index (%d)\", index);\n-    return static_cast<MEMFLAGS>(index);\n+  \/\/ Map an index to memory tag\n+  static MemTag index_to_tag(int index) {\n+    assert(tag_index_is_valid(index), \"Invalid type index (%d)\", index);\n+    return static_cast<MemTag>(index);\n@@ -124,1 +124,1 @@\n-  \/\/ Given a string, return associated flag. mtNone if name is invalid.\n+  \/\/ Given a string, return associated mem_tag. mtNone if name is invalid.\n@@ -127,1 +127,1 @@\n-  static MEMFLAGS string_to_flag(const char* name);\n+  static MemTag string_to_mem_tag(const char* name);\n@@ -137,1 +137,1 @@\n-  static S _strings[mt_number_of_types];\n+  static S _strings[mt_number_of_tags];\n","filename":"src\/hotspot\/share\/nmt\/nmtCommon.hpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,2 +201,2 @@\n-void* NMTPreInit::do_os_malloc(size_t size, MEMFLAGS memflags) {\n-  return os::malloc(size, memflags);\n+void* NMTPreInit::do_os_malloc(size_t size, MemTag mem_tag) {\n+  return os::malloc(size, mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/nmtPreInit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -258,1 +258,1 @@\n-  static void* do_os_malloc(size_t size, MEMFLAGS memflags);\n+  static void* do_os_malloc(size_t size, MemTag mem_tag);\n@@ -286,1 +286,1 @@\n-  static bool handle_realloc(void** rc, void* old_p, size_t new_size, MEMFLAGS memflags) {\n+  static bool handle_realloc(void** rc, void* old_p, size_t new_size, MemTag mem_tag) {\n@@ -325,1 +325,1 @@\n-          void* p_new = do_os_malloc(new_size, memflags);\n+          void* p_new = do_os_malloc(new_size, mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/nmtPreInit.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -60,3 +60,3 @@\n-  for (int i = 0; i < mt_number_of_types; i++) {\n-    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n-    const MallocMemory* mm = ms->by_type(flag);\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    MemTag mem_tag = NMTUtil::index_to_tag(i);\n+    const MallocMemory* mm = ms->by_type(mem_tag);\n@@ -71,1 +71,1 @@\n-  _malloc_by_type[NMTUtil::flag_to_index(mtChunk)] -= total_arena_size;\n+  _malloc_by_type[NMTUtil::tag_to_index(mtChunk)] -= total_arena_size;\n@@ -75,1 +75,1 @@\n-  _malloc_by_type[NMTUtil::flag_to_index(mtNMT)] += ms->malloc_overhead();\n+  _malloc_by_type[NMTUtil::tag_to_index(mtNMT)] += ms->malloc_overhead();\n@@ -84,3 +84,3 @@\n-  for (int i = 0; i < mt_number_of_types; i++) {\n-    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n-    const VirtualMemory* vm = vms->by_type(flag);\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    MemTag mem_tag = NMTUtil::index_to_tag(i);\n+    const VirtualMemory* vm = vms->by_type(mem_tag);\n@@ -119,2 +119,2 @@\n-size_t NMTUsage::reserved(MEMFLAGS flag) const {\n-  int index = NMTUtil::flag_to_index(flag);\n+size_t NMTUsage::reserved(MemTag mem_tag) const {\n+  int index = NMTUtil::tag_to_index(mem_tag);\n@@ -124,2 +124,2 @@\n-size_t NMTUsage::committed(MEMFLAGS flag) const {\n-  int index = NMTUtil::flag_to_index(flag);\n+size_t NMTUsage::committed(MemTag mem_tag) const {\n+  int index = NMTUtil::tag_to_index(mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/nmtUsage.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-  size_t _malloc_by_type[mt_number_of_types];\n+  size_t _malloc_by_type[mt_number_of_tags];\n@@ -46,1 +46,1 @@\n-  NMTUsagePair _vm_by_type[mt_number_of_types];\n+  NMTUsagePair _vm_by_type[mt_number_of_tags];\n@@ -64,2 +64,2 @@\n-  size_t reserved(MEMFLAGS flag) const;\n-  size_t committed(MEMFLAGS flag) const;\n+  size_t reserved(MemTag mem_tag) const;\n+  size_t committed(MemTag mem_tag) const;\n","filename":"src\/hotspot\/share\/nmt\/nmtUsage.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-  VirtualMemorySummary::record_committed_memory(size, flag());\n+  VirtualMemorySummary::record_committed_memory(size, mem_tag());\n@@ -215,1 +215,1 @@\n-      VirtualMemorySummary::record_uncommitted_memory(crgn->size(), flag());\n+      VirtualMemorySummary::record_uncommitted_memory(crgn->size(), mem_tag());\n@@ -222,1 +222,1 @@\n-      VirtualMemorySummary::record_uncommitted_memory(crgn->size(), flag());\n+      VirtualMemorySummary::record_uncommitted_memory(crgn->size(), mem_tag());\n@@ -233,1 +233,1 @@\n-        VirtualMemorySummary::record_uncommitted_memory(sz, flag());\n+        VirtualMemorySummary::record_uncommitted_memory(sz, mem_tag());\n@@ -239,1 +239,1 @@\n-        VirtualMemorySummary::record_uncommitted_memory(size, flag());\n+        VirtualMemorySummary::record_uncommitted_memory(size, mem_tag());\n@@ -246,1 +246,1 @@\n-      VirtualMemorySummary::record_uncommitted_memory(size, flag());\n+      VirtualMemorySummary::record_uncommitted_memory(size, mem_tag());\n@@ -295,2 +295,2 @@\n-void ReservedMemoryRegion::set_flag(MEMFLAGS f) {\n-  assert((flag() == mtNone || flag() == f),\n+void ReservedMemoryRegion::set_mem_tag(MemTag new_mem_tag) {\n+  assert((mem_tag() == mtNone || mem_tag() == new_mem_tag),\n@@ -298,5 +298,5 @@\n-         p2i(base()), p2i(end()), (unsigned)flag(), (unsigned)f);\n-  if (flag() != f) {\n-    VirtualMemorySummary::move_reserved_memory(flag(), f, size());\n-    VirtualMemorySummary::move_committed_memory(flag(), f, committed_size());\n-    _flag = f;\n+         p2i(base()), p2i(end()), (unsigned)mem_tag(), (unsigned)new_mem_tag);\n+  if (mem_tag() != new_mem_tag) {\n+    VirtualMemorySummary::move_reserved_memory(mem_tag(), new_mem_tag, size());\n+    VirtualMemorySummary::move_committed_memory(mem_tag(), new_mem_tag, committed_size());\n+    _mem_tag = new_mem_tag;\n@@ -307,1 +307,1 @@\n-  assert(flag() == mtThreadStack, \"Only for thread stack\");\n+  assert(mem_tag() == mtThreadStack, \"Only for thread stack\");\n@@ -337,1 +337,1 @@\n-    const NativeCallStack& stack, MEMFLAGS flag) {\n+    const NativeCallStack& stack, MemTag mem_tag) {\n@@ -341,1 +341,1 @@\n-  ReservedMemoryRegion  rgn(base_addr, size, stack, flag);\n+  ReservedMemoryRegion  rgn(base_addr, size, stack, mem_tag);\n@@ -345,1 +345,1 @@\n-                rgn.flag_name(), p2i(rgn.base()), rgn.size());\n+                rgn.mem_tag_name(), p2i(rgn.base()), rgn.size());\n@@ -347,1 +347,1 @@\n-    VirtualMemorySummary::record_reserved_memory(size, flag);\n+    VirtualMemorySummary::record_reserved_memory(size, mem_tag);\n@@ -354,1 +354,1 @@\n-        (reserved_rgn->flag() == flag || reserved_rgn->flag() == mtNone)) {\n+        (reserved_rgn->mem_tag() == mem_tag || reserved_rgn->mem_tag() == mtNone)) {\n@@ -356,1 +356,1 @@\n-      reserved_rgn->set_flag(flag);\n+      reserved_rgn->set_mem_tag(mem_tag);\n@@ -365,1 +365,1 @@\n-      if (reserved_rgn->flag() == mtThreadStack) {\n+      if (reserved_rgn->mem_tag() == mtThreadStack) {\n@@ -370,2 +370,2 @@\n-        VirtualMemorySummary::record_uncommitted_memory(reserved_rgn->committed_size(), reserved_rgn->flag());\n-        VirtualMemorySummary::record_released_memory(reserved_rgn->size(), reserved_rgn->flag());\n+        VirtualMemorySummary::record_uncommitted_memory(reserved_rgn->committed_size(), reserved_rgn->mem_tag());\n+        VirtualMemorySummary::record_released_memory(reserved_rgn->size(), reserved_rgn->mem_tag());\n@@ -374,1 +374,1 @@\n-        VirtualMemorySummary::record_reserved_memory(rgn.size(), flag);\n+        VirtualMemorySummary::record_reserved_memory(rgn.size(), mem_tag);\n@@ -383,1 +383,1 @@\n-      if (reserved_rgn->flag() == mtClassShared) {\n+      if (reserved_rgn->mem_tag() == mtClassShared) {\n@@ -385,1 +385,1 @@\n-                      reserved_rgn->flag_name(), p2i(reserved_rgn->base()), reserved_rgn->size());\n+                      reserved_rgn->mem_tag_name(), p2i(reserved_rgn->base()), reserved_rgn->size());\n@@ -392,1 +392,1 @@\n-      if (reserved_rgn->flag() == mtJavaHeap) {\n+      if (reserved_rgn->mem_tag() == mtJavaHeap) {\n@@ -394,1 +394,1 @@\n-                      reserved_rgn->flag_name(), p2i(reserved_rgn->base()), reserved_rgn->size());\n+                      reserved_rgn->mem_tag_name(), p2i(reserved_rgn->base()), reserved_rgn->size());\n@@ -400,4 +400,4 @@\n-      tty->print_cr(\"Error: existing region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), flag %u.\\n\"\n-                    \"       new region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), flag %u.\",\n-                    p2i(reserved_rgn->base()), p2i(reserved_rgn->end()), (unsigned)reserved_rgn->flag(),\n-                    p2i(base_addr), p2i(base_addr + size), (unsigned)flag);\n+      tty->print_cr(\"Error: existing region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), memory tag %u.\\n\"\n+                    \"       new region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), memory tag %u.\",\n+                    p2i(reserved_rgn->base()), p2i(reserved_rgn->end()), (unsigned)reserved_rgn->mem_tag(),\n+                    p2i(base_addr), p2i(base_addr + size), (unsigned)mem_tag);\n@@ -416,1 +416,1 @@\n-void VirtualMemoryTracker::set_reserved_region_type(address addr, MEMFLAGS flag) {\n+void VirtualMemoryTracker::set_reserved_region_type(address addr, MemTag mem_tag) {\n@@ -424,4 +424,4 @@\n-    if (reserved_rgn->flag() != flag) {\n-      assert(reserved_rgn->flag() == mtNone, \"Overwrite memory type (should be mtNone, is: \\\"%s\\\")\",\n-             NMTUtil::flag_to_name(reserved_rgn->flag()));\n-      reserved_rgn->set_flag(flag);\n+    if (reserved_rgn->mem_tag() != mem_tag) {\n+      assert(reserved_rgn->mem_tag() == mtNone, \"Overwrite memory type (should be mtNone, is: \\\"%s\\\")\",\n+             NMTUtil::tag_to_name(reserved_rgn->mem_tag()));\n+      reserved_rgn->set_mem_tag(mem_tag);\n@@ -443,1 +443,1 @@\n-                  rgn.flag_name(),  p2i(rgn.base()), rgn.size());\n+                  rgn.mem_tag_name(),  p2i(rgn.base()), rgn.size());\n@@ -449,1 +449,1 @@\n-                reserved_rgn->flag_name(),  p2i(rgn.base()), rgn.size(), (result ? \"Succeeded\" : \"Failed\"));\n+                reserved_rgn->mem_tag_name(),  p2i(rgn.base()), rgn.size(), (result ? \"Succeeded\" : \"Failed\"));\n@@ -462,1 +462,1 @@\n-  const char* flag_name = reserved_rgn->flag_name();  \/\/ after remove, info is not complete\n+  const char* type_name = reserved_rgn->mem_tag_name();  \/\/ after remove, info is not complete\n@@ -465,1 +465,1 @@\n-                flag_name,  p2i(addr), size, (result ? \" Succeeded\" : \"Failed\"));\n+                 type_name,  p2i(addr), size, (result ? \" Succeeded\" : \"Failed\"));\n@@ -477,1 +477,1 @@\n-                backup.flag_name(), p2i(backup.base()), backup.size(), (result ? \"Succeeded\" : \"Failed\"));\n+                backup.mem_tag_name(), p2i(backup.base()), backup.size(), (result ? \"Succeeded\" : \"Failed\"));\n@@ -482,1 +482,1 @@\n-  VirtualMemorySummary::record_released_memory(rgn->size(), rgn->flag());\n+  VirtualMemorySummary::record_released_memory(rgn->size(), rgn->mem_tag());\n@@ -485,1 +485,1 @@\n-                backup.flag_name(), p2i(backup.base()), backup.size(), (result ? \"Succeeded\" : \"Failed\"));\n+                backup.mem_tag_name(), p2i(backup.base()), backup.size(), (result ? \"Succeeded\" : \"Failed\"));\n@@ -511,1 +511,1 @@\n-  if (reserved_rgn->flag() == mtClassShared) {\n+  if (reserved_rgn->mem_tag() == mtClassShared) {\n@@ -526,1 +526,1 @@\n-      assert(cls_rgn->flag() == mtClass, \"Must be class type\");\n+      assert(cls_rgn->mem_tag() == mtClass, \"Must be class mem tag\");\n@@ -533,1 +533,1 @@\n-  VirtualMemorySummary::record_released_memory(size, reserved_rgn->flag());\n+  VirtualMemorySummary::record_released_memory(size, reserved_rgn->mem_tag());\n@@ -544,1 +544,1 @@\n-      *reserved_rgn->call_stack(), reserved_rgn->flag());\n+      *reserved_rgn->call_stack(), reserved_rgn->mem_tag());\n@@ -560,2 +560,2 @@\n-\/\/  stack and the memory flags of the original section.\n-bool VirtualMemoryTracker::split_reserved_region(address addr, size_t size, size_t split, MEMFLAGS flag, MEMFLAGS split_flag) {\n+\/\/  stack and the memory tags of the original section.\n+bool VirtualMemoryTracker::split_reserved_region(address addr, size_t size, size_t split, MemTag mem_tag, MemTag split_tag) {\n@@ -570,1 +570,1 @@\n-  MEMFLAGS original_flags = reserved_rgn->flag();\n+  MemTag original_tag = reserved_rgn->mem_tag();\n@@ -572,1 +572,1 @@\n-  const char* name = reserved_rgn->flag_name();\n+  const char* name = reserved_rgn->mem_tag_name();\n@@ -577,2 +577,2 @@\n-  add_reserved_region(addr, split, original_stack, flag);\n-  add_reserved_region(addr + split, size - split, original_stack, split_flag);\n+  add_reserved_region(addr, split, original_stack, mem_tag);\n+  add_reserved_region(addr + split, size - split, original_stack, split_tag);\n@@ -624,1 +624,1 @@\n-    if (rgn->flag() == mtThreadStack) {\n+    if (rgn->mem_tag() == mtThreadStack) {\n@@ -691,1 +691,1 @@\n-        p2i(_p), p2i(rgn->base()), p2i(rgn->base() + rgn->size()), NMTUtil::flag_to_enum_name(rgn->flag()));\n+        p2i(_p), p2i(rgn->base()), p2i(rgn->base() + rgn->size()), NMTUtil::tag_to_enum_name(rgn->mem_tag()));\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,2 +80,2 @@\n-  VirtualMemoryAllocationSite(const NativeCallStack& stack, MEMFLAGS flag) :\n-    AllocationSite(stack, flag) { }\n+  VirtualMemoryAllocationSite(const NativeCallStack& stack, MemTag mem_tag) :\n+    AllocationSite(stack, mem_tag) { }\n@@ -98,1 +98,1 @@\n-  VirtualMemory  _virtual_memory[mt_number_of_types];\n+  VirtualMemory  _virtual_memory[mt_number_of_tags];\n@@ -101,2 +101,2 @@\n-  inline VirtualMemory* by_type(MEMFLAGS flag) {\n-    int index = NMTUtil::flag_to_index(flag);\n+  inline VirtualMemory* by_type(MemTag mem_tag) {\n+    int index = NMTUtil::tag_to_index(mem_tag);\n@@ -106,2 +106,2 @@\n-  inline const VirtualMemory* by_type(MEMFLAGS flag) const {\n-    int index = NMTUtil::flag_to_index(flag);\n+  inline const VirtualMemory* by_type(MemTag mem_tag) const {\n+    int index = NMTUtil::tag_to_index(mem_tag);\n@@ -113,1 +113,1 @@\n-    for (int index = 0; index < mt_number_of_types; index ++) {\n+    for (int index = 0; index < mt_number_of_tags; index ++) {\n@@ -121,1 +121,1 @@\n-    for (int index = 0; index < mt_number_of_types; index ++) {\n+    for (int index = 0; index < mt_number_of_tags; index ++) {\n@@ -128,1 +128,1 @@\n-    for (int index = 0; index < mt_number_of_types; index ++) {\n+    for (int index = 0; index < mt_number_of_tags; index ++) {\n@@ -137,2 +137,2 @@\n-  static inline void record_reserved_memory(size_t size, MEMFLAGS flag) {\n-    as_snapshot()->by_type(flag)->reserve_memory(size);\n+  static inline void record_reserved_memory(size_t size, MemTag mem_tag) {\n+    as_snapshot()->by_type(mem_tag)->reserve_memory(size);\n@@ -141,2 +141,2 @@\n-  static inline void record_committed_memory(size_t size, MEMFLAGS flag) {\n-    as_snapshot()->by_type(flag)->commit_memory(size);\n+  static inline void record_committed_memory(size_t size, MemTag mem_tag) {\n+    as_snapshot()->by_type(mem_tag)->commit_memory(size);\n@@ -145,2 +145,2 @@\n-  static inline void record_uncommitted_memory(size_t size, MEMFLAGS flag) {\n-    as_snapshot()->by_type(flag)->uncommit_memory(size);\n+  static inline void record_uncommitted_memory(size_t size, MemTag mem_tag) {\n+    as_snapshot()->by_type(mem_tag)->uncommit_memory(size);\n@@ -149,2 +149,2 @@\n-  static inline void record_released_memory(size_t size, MEMFLAGS flag) {\n-    as_snapshot()->by_type(flag)->release_memory(size);\n+  static inline void record_released_memory(size_t size, MemTag mem_tag) {\n+    as_snapshot()->by_type(mem_tag)->release_memory(size);\n@@ -157,1 +157,1 @@\n-  static inline void move_reserved_memory(MEMFLAGS from, MEMFLAGS to, size_t size) {\n+  static inline void move_reserved_memory(MemTag from, MemTag to, size_t size) {\n@@ -162,1 +162,1 @@\n-  static inline void move_committed_memory(MEMFLAGS from, MEMFLAGS to, size_t size) {\n+  static inline void move_committed_memory(MemTag from, MemTag to, size_t size) {\n@@ -296,1 +296,1 @@\n-  MEMFLAGS         _flag;\n+  MemTag           _mem_tag;\n@@ -300,2 +300,2 @@\n-    MEMFLAGS flag = mtNone) :\n-    VirtualMemoryRegion(base, size), _stack(stack), _flag(flag) { }\n+    MemTag mem_tag = mtNone) :\n+    VirtualMemoryRegion(base, size), _stack(stack), _mem_tag(mem_tag) { }\n@@ -305,1 +305,1 @@\n-    VirtualMemoryRegion(base, size), _stack(NativeCallStack::empty_stack()), _flag(mtNone) { }\n+    VirtualMemoryRegion(base, size), _stack(NativeCallStack::empty_stack()), _mem_tag(mtNone) { }\n@@ -316,2 +316,2 @@\n-  void  set_flag(MEMFLAGS flag);\n-  inline MEMFLAGS flag() const            { return _flag;  }\n+  void  set_mem_tag(MemTag mem_tag);\n+  inline MemTag mem_tag() const            { return _mem_tag;  }\n@@ -339,2 +339,2 @@\n-    _stack =         *other.call_stack();\n-    _flag  =         other.flag();\n+    _stack   = *other.call_stack();\n+    _mem_tag = other.mem_tag();\n@@ -353,1 +353,1 @@\n-  const char* flag_name() const { return NMTUtil::flag_to_name(_flag); }\n+  const char* mem_tag_name() const { return NMTUtil::tag_to_name(_mem_tag); }\n@@ -383,1 +383,1 @@\n-  static bool add_reserved_region (address base_addr, size_t size, const NativeCallStack& stack, MEMFLAGS flag = mtNone);\n+  static bool add_reserved_region (address base_addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n@@ -389,1 +389,1 @@\n-  static void set_reserved_region_type  (address addr, MEMFLAGS flag);\n+  static void set_reserved_region_type  (address addr, MemTag mem_tag);\n@@ -393,2 +393,2 @@\n-  \/\/  stack and the memory flags of the original section.\n-  static bool split_reserved_region(address addr, size_t size, size_t split, MEMFLAGS flag, MEMFLAGS split_flag);\n+  \/\/  stack and the memory types of the original section.\n+  static bool split_reserved_region(address addr, size_t size, size_t split, MemTag mem_tag, MemTag split_type);\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n-        \/\/ reserve [x1, A), flag1; ... reserve [A, x2), flag2; or\n-        \/\/ reserve [A, x1), flag1; ... reserve [A, x2), flag2;\n+        \/\/ reserve [x1, A), mem_tag1; ... reserve [A, x2), mem_tag2; or\n+        \/\/ reserve [A, x1), mem_tag1; ... reserve [A, x2), mem_tag2;\n@@ -150,2 +150,2 @@\n-    SingleDiff& rescom = diff.flag[NMTUtil::flag_to_index(LEQ_A.out().flag())];\n-    if (LEQ_A.out().type() == StateType::Reserved) {\n+    SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(LEQ_A.out().mem_tag())];\n+    if (LEQ_A.out().state() == StateType::Reserved) {\n@@ -153,1 +153,1 @@\n-    } else if (LEQ_A.out().type() == StateType::Committed) {\n+    } else if (LEQ_A.out().state() == StateType::Committed) {\n@@ -166,2 +166,2 @@\n-    SingleDiff& rescom = diff.flag[NMTUtil::flag_to_index(delete_me.in().flag())];\n-    if (delete_me.in().type() == StateType::Reserved) {\n+    SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(delete_me.in().mem_tag())];\n+    if (delete_me.in().state() == StateType::Reserved) {\n@@ -169,1 +169,1 @@\n-    } else if (delete_me.in().type() == StateType::Committed) {\n+    } else if (delete_me.in().state() == StateType::Committed) {\n@@ -176,1 +176,1 @@\n-  if (prev.address != A && prev.out().type() != StateType::Released) {\n+  if (prev.address != A && prev.out().state() != StateType::Released) {\n@@ -180,2 +180,2 @@\n-    if (prev.out().type() == StateType::Reserved) {\n-      SingleDiff& rescom = diff.flag[NMTUtil::flag_to_index(prev.out().flag())];\n+    if (prev.out().state() == StateType::Reserved) {\n+      SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(prev.out().mem_tag())];\n@@ -183,2 +183,2 @@\n-    } else if (prev.out().type() == StateType::Committed) {\n-      SingleDiff& rescom = diff.flag[NMTUtil::flag_to_index(prev.out().flag())];\n+    } else if (prev.out().state() == StateType::Committed) {\n+      SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(prev.out().mem_tag())];\n@@ -191,1 +191,1 @@\n-  SingleDiff& rescom = diff.flag[NMTUtil::flag_to_index(metadata.flag)];\n+  SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(metadata.mem_tag)];\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-\/\/ or from committed memory of a certain MEMFLAGS to committed memory of a different MEMFLAGS.\n+\/\/ or from committed memory of a certain MemTag to committed memory of a different MemTag.\n@@ -72,1 +72,1 @@\n-    const MEMFLAGS flag;\n+    const MemTag mem_tag;\n@@ -74,1 +74,1 @@\n-    RegionData() : stack_idx(), flag(mtNone) {}\n+    RegionData() : stack_idx(), mem_tag(mtNone) {}\n@@ -76,2 +76,2 @@\n-    RegionData(NativeCallStackStorage::StackIndex stack_idx, MEMFLAGS flag)\n-    : stack_idx(stack_idx), flag(flag) {}\n+    RegionData(NativeCallStackStorage::StackIndex stack_idx, MemTag mem_tag)\n+    : stack_idx(stack_idx), mem_tag(mem_tag) {}\n@@ -80,1 +80,1 @@\n-      return a.flag == b.flag &&\n+      return a.mem_tag == b.mem_tag &&\n@@ -90,2 +90,2 @@\n-    \/\/ Store the type and flag as two bytes\n-    uint8_t type_flag[2];\n+    \/\/ Store the state and mem_tag as two bytes\n+    uint8_t info[2];\n@@ -95,5 +95,5 @@\n-    IntervalState() : type_flag{0,0}, sidx() {}\n-    IntervalState(const StateType type, const RegionData data) {\n-      assert(!(type == StateType::Released) || data.flag == mtNone, \"Released type must have flag mtNone\");\n-      type_flag[0] = static_cast<uint8_t>(type);\n-      type_flag[1] = static_cast<uint8_t>(data.flag);\n+    IntervalState() : info{0,0}, sidx() {}\n+    IntervalState(const StateType state, const RegionData data) {\n+      assert(!(state == StateType::Released) || data.mem_tag == mtNone, \"Released type must have flag mtNone\");\n+      info[0] = static_cast<uint8_t>(state);\n+      info[1] = static_cast<uint8_t>(data.mem_tag);\n@@ -103,2 +103,2 @@\n-    StateType type() const {\n-      return static_cast<StateType>(type_flag[0]);\n+    StateType state() const {\n+      return static_cast<StateType>(info[0]);\n@@ -107,2 +107,2 @@\n-    MEMFLAGS flag() const {\n-      return static_cast<MEMFLAGS>(type_flag[1]);\n+    MemTag mem_tag() const {\n+      return static_cast<MemTag>(info[1]);\n@@ -112,1 +112,1 @@\n-      return RegionData{sidx, flag()};\n+      return RegionData{sidx, mem_tag()};\n@@ -127,1 +127,1 @@\n-      return in.type() == out.type() &&\n+      return in.state() == out.state() &&\n@@ -162,1 +162,1 @@\n-    SingleDiff flag[mt_number_of_types];\n+    SingleDiff tag[mt_number_of_tags];\n@@ -164,2 +164,2 @@\n-      for (int i = 0; i < mt_number_of_types; i++) {\n-        flag[i] = SingleDiff{0, 0};\n+      for (int i = 0; i < mt_number_of_tags; i++) {\n+        tag[i] = SingleDiff{0, 0};\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -696,1 +696,1 @@\n-WB_ENTRY(jlong, WB_NMTMallocWithPseudoStackAndType(JNIEnv* env, jobject o, jlong size, jint pseudo_stack, jint type))\n+WB_ENTRY(jlong, WB_NMTMallocWithPseudoStackAndType(JNIEnv* env, jobject o, jlong size, jint pseudo_stack, jint mem_tag))\n@@ -699,1 +699,1 @@\n-  return (jlong)(uintptr_t)os::malloc(size, (MEMFLAGS)type, stack);\n+  return (jlong)(uintptr_t)os::malloc(size, (MemTag)mem_tag, stack);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-  HandleArea(MEMFLAGS flags, HandleArea* prev) : Arena(flags, Tag::tag_ha, Chunk::tiny_size) {\n+  HandleArea(MemTag mem_tag, HandleArea* prev) : Arena(mem_tag, Tag::tag_ha, Chunk::tiny_size) {\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -412,2 +412,2 @@\n-JavaThread::JavaThread(MEMFLAGS flags) :\n-  Thread(flags),\n+JavaThread::JavaThread(MemTag mem_tag) :\n+  Thread(mem_tag),\n@@ -637,1 +637,1 @@\n-JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz, MEMFLAGS flags) : JavaThread(flags) {\n+JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz, MemTag mem_tag) : JavaThread(mem_tag) {\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-  JavaThread(MEMFLAGS flags = mtThread);   \/\/ delegating constructor\n-  JavaThread(ThreadFunction entry_point, size_t stack_size = 0, MEMFLAGS flags = mtThread);\n+  JavaThread(MemTag mem_tag = mtThread);   \/\/ delegating constructor\n+  JavaThread(ThreadFunction entry_point, size_t stack_size = 0, MemTag mem_tag = mtThread);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -63,1 +63,1 @@\n-      return AllocateHeap(size, MEMFLAGS::mtObjectMonitor);\n+      return AllocateHeap(size, mtObjectMonitor);\n@@ -70,1 +70,1 @@\n-  using ConcurrentTable = ConcurrentHashTable<Config, MEMFLAGS::mtObjectMonitor>;\n+  using ConcurrentTable = ConcurrentHashTable<Config, mtObjectMonitor>;\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-char *os::strdup(const char *str, MEMFLAGS flags) {\n+char *os::strdup(const char *str, MemTag mem_tag) {\n@@ -605,1 +605,1 @@\n-  char *dup_str = (char *)malloc(size + 1, flags);\n+  char *dup_str = (char *)malloc(size + 1, mem_tag);\n@@ -611,2 +611,2 @@\n-char* os::strdup_check_oom(const char* str, MEMFLAGS flags) {\n-  char* p = os::strdup(str, flags);\n+char* os::strdup_check_oom(const char* str, MemTag mem_tag) {\n+  char* p = os::strdup(str, mem_tag);\n@@ -632,2 +632,2 @@\n-void* os::malloc(size_t size, MEMFLAGS flags) {\n-  return os::malloc(size, flags, CALLER_PC);\n+void* os::malloc(size_t size, MemTag mem_tag) {\n+  return os::malloc(size, mem_tag, CALLER_PC);\n@@ -636,1 +636,1 @@\n-void* os::malloc(size_t size, MEMFLAGS memflags, const NativeCallStack& stack) {\n+void* os::malloc(size_t size, MemTag mem_tag, const NativeCallStack& stack) {\n@@ -654,1 +654,1 @@\n-  if (MemTracker::check_exceeds_limit(size, memflags)) {\n+  if (MemTracker::check_exceeds_limit(size, mem_tag)) {\n@@ -670,1 +670,1 @@\n-  void* const inner_ptr = MemTracker::record_malloc((address)outer_ptr, size, memflags, stack);\n+  void* const inner_ptr = MemTracker::record_malloc((address)outer_ptr, size, mem_tag, stack);\n@@ -682,2 +682,2 @@\n-void* os::realloc(void *memblock, size_t size, MEMFLAGS flags) {\n-  return os::realloc(memblock, size, flags, CALLER_PC);\n+void* os::realloc(void *memblock, size_t size, MemTag mem_tag) {\n+  return os::realloc(memblock, size, mem_tag, CALLER_PC);\n@@ -686,1 +686,1 @@\n-void* os::realloc(void *memblock, size_t size, MEMFLAGS memflags, const NativeCallStack& stack) {\n+void* os::realloc(void *memblock, size_t size, MemTag mem_tag, const NativeCallStack& stack) {\n@@ -690,1 +690,1 @@\n-  if (NMTPreInit::handle_realloc(&rc, memblock, size, memflags)) {\n+  if (NMTPreInit::handle_realloc(&rc, memblock, size, mem_tag)) {\n@@ -695,1 +695,1 @@\n-    return os::malloc(size, memflags, stack);\n+    return os::malloc(size, mem_tag, stack);\n@@ -718,1 +718,1 @@\n-    if ((size > old_size) && MemTracker::check_exceeds_limit(size - old_size, memflags)) {\n+    if ((size > old_size) && MemTracker::check_exceeds_limit(size - old_size, mem_tag)) {\n@@ -725,2 +725,2 @@\n-    assert(memflags == header->flags(), \"weird NMT flags mismatch (new:\\\"%s\\\" != old:\\\"%s\\\")\\n\",\n-           NMTUtil::flag_to_name(memflags), NMTUtil::flag_to_name(header->flags()));\n+    assert(mem_tag == header->mem_tag(), \"weird NMT type mismatch (new:\\\"%s\\\" != old:\\\"%s\\\")\\n\",\n+           NMTUtil::tag_to_name(mem_tag), NMTUtil::tag_to_name(header->mem_tag()));\n@@ -745,1 +745,1 @@\n-    void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, memflags, stack);\n+    void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, mem_tag, stack);\n@@ -1874,1 +1874,1 @@\n-char* os::reserve_memory(size_t bytes, bool executable, MEMFLAGS flags) {\n+char* os::reserve_memory(size_t bytes, bool executable, MemTag mem_tag) {\n@@ -1877,1 +1877,1 @@\n-    MemTracker::record_virtual_memory_reserve(result, bytes, CALLER_PC, flags);\n+    MemTracker::record_virtual_memory_reserve(result, bytes, CALLER_PC, mem_tag);\n@@ -1885,1 +1885,1 @@\n-char* os::attempt_reserve_memory_at(char* addr, size_t bytes, bool executable, MEMFLAGS flag) {\n+char* os::attempt_reserve_memory_at(char* addr, size_t bytes, bool executable, MemTag mem_tag) {\n@@ -1888,1 +1888,1 @@\n-    MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC, flag);\n+    MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC, mem_tag);\n@@ -2238,1 +2238,1 @@\n-char* os::map_memory_to_file(size_t bytes, int file_desc, MEMFLAGS flag) {\n+char* os::map_memory_to_file(size_t bytes, int file_desc, MemTag mem_tag) {\n@@ -2244,1 +2244,1 @@\n-    MemTracker::record_virtual_memory_reserve_and_commit(result, bytes, CALLER_PC, flag);\n+    MemTracker::record_virtual_memory_reserve_and_commit(result, bytes, CALLER_PC, mem_tag);\n@@ -2249,1 +2249,1 @@\n-char* os::attempt_map_memory_to_file_at(char* addr, size_t bytes, int file_desc, MEMFLAGS flag) {\n+char* os::attempt_map_memory_to_file_at(char* addr, size_t bytes, int file_desc, MemTag mem_tag) {\n@@ -2252,1 +2252,1 @@\n-    MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC, flag);\n+    MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC, mem_tag);\n@@ -2259,1 +2259,1 @@\n-                           bool allow_exec, MEMFLAGS flags) {\n+                           bool allow_exec, MemTag mem_tag) {\n@@ -2262,1 +2262,1 @@\n-    MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC, flags);\n+    MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC, mem_tag);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -453,1 +453,1 @@\n-  static char*  reserve_memory(size_t bytes, bool executable = false, MEMFLAGS flags = mtNone);\n+  static char*  reserve_memory(size_t bytes, bool executable = false, MemTag mem_tag = mtNone);\n@@ -460,1 +460,1 @@\n-  static char*  attempt_reserve_memory_at(char* addr, size_t bytes, bool executable = false, MEMFLAGS flag = mtNone);\n+  static char*  attempt_reserve_memory_at(char* addr, size_t bytes, bool executable = false, MemTag mem_tag = mtNone);\n@@ -512,2 +512,2 @@\n-  static char* map_memory_to_file(size_t size, int fd, MEMFLAGS flag = mtNone);\n-  static char* map_memory_to_file_aligned(size_t size, size_t alignment, int fd, MEMFLAGS flag = mtNone);\n+  static char* map_memory_to_file(size_t size, int fd, MemTag mem_tag = mtNone);\n+  static char* map_memory_to_file_aligned(size_t size, size_t alignment, int fd, MemTag mem_tag = mtNone);\n@@ -515,1 +515,1 @@\n-  static char* attempt_map_memory_to_file_at(char* base, size_t size, int fd, MEMFLAGS flag = mtNone);\n+  static char* attempt_map_memory_to_file_at(char* base, size_t size, int fd, MemTag mem_tag = mtNone);\n@@ -521,1 +521,1 @@\n-                           bool allow_exec = false, MEMFLAGS flags = mtNone);\n+                           bool allow_exec = false, MemTag mem_tag = mtNone);\n@@ -903,4 +903,4 @@\n-  static void* malloc  (size_t size, MEMFLAGS flags, const NativeCallStack& stack);\n-  static void* malloc  (size_t size, MEMFLAGS flags);\n-  static void* realloc (void *memblock, size_t size, MEMFLAGS flag, const NativeCallStack& stack);\n-  static void* realloc (void *memblock, size_t size, MEMFLAGS flag);\n+  static void* malloc  (size_t size, MemTag mem_tag, const NativeCallStack& stack);\n+  static void* malloc  (size_t size, MemTag mem_tag);\n+  static void* realloc (void *memblock, size_t size, MemTag mem_tag, const NativeCallStack& stack);\n+  static void* realloc (void *memblock, size_t size, MemTag mem_tag);\n@@ -910,1 +910,1 @@\n-  static char* strdup(const char *, MEMFLAGS flags = mtInternal);  \/\/ Like strdup\n+  static char* strdup(const char *, MemTag mem_tag = mtInternal);  \/\/ Like strdup\n@@ -912,1 +912,1 @@\n-  static char* strdup_check_oom(const char*, MEMFLAGS flags = mtInternal);\n+  static char* strdup_check_oom(const char*, MemTag mem_tag = mtInternal);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-Thread::Thread(MEMFLAGS flags) {\n+Thread::Thread(MemTag mem_tag) {\n@@ -81,1 +81,1 @@\n-  set_resource_area(new (flags) ResourceArea(flags));\n+  set_resource_area(new (mem_tag) ResourceArea(mem_tag));\n@@ -83,1 +83,1 @@\n-  set_handle_area(new (flags) HandleArea(flags, nullptr));\n+  set_handle_area(new (mem_tag) HandleArea(mem_tag, nullptr));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-  Thread(MEMFLAGS flag = mtThread);\n+  Thread(MemTag mem_tag = mtThread);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,2 +176,2 @@\n-CHeapBitMap::CHeapBitMap(idx_t size_in_bits, MEMFLAGS flags, bool clear)\n-  : GrowableBitMap<CHeapBitMap>(), _flags(flags) {\n+CHeapBitMap::CHeapBitMap(idx_t size_in_bits, MemTag mem_tag, bool clear)\n+  : GrowableBitMap<CHeapBitMap>(), _mem_tag(mem_tag) {\n@@ -186,1 +186,1 @@\n-  return MallocArrayAllocator<bm_word_t>::allocate(size_in_words, _flags);\n+  return MallocArrayAllocator<bm_word_t>::allocate(size_in_words, _mem_tag);\n@@ -196,1 +196,1 @@\n-  return MallocArrayAllocator<bm_word_t>::reallocate(map, new_size_in_words, _flags);\n+  return MallocArrayAllocator<bm_word_t>::reallocate(map, new_size_in_words, _mem_tag);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -645,1 +645,1 @@\n-  const MEMFLAGS _flags;\n+  const MemTag _mem_tag;\n@@ -652,2 +652,2 @@\n-  explicit CHeapBitMap(MEMFLAGS flags) : GrowableBitMap(), _flags(flags) {}\n-  CHeapBitMap(idx_t size_in_bits, MEMFLAGS flags, bool clear = true);\n+  explicit CHeapBitMap(MemTag mem_tag) : GrowableBitMap(), _mem_tag(mem_tag) {}\n+  CHeapBitMap(idx_t size_in_bits, MemTag mem_tag, bool clear = true);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-template <class T, MEMFLAGS F> class ChunkedList : public CHeapObj<F> {\n+template <class T, MemTag F> class ChunkedList : public CHeapObj<F> {\n","filename":"src\/hotspot\/share\/utilities\/chunkedList.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -64,1 +64,1 @@\n-  \/\/ Only constructed with placement new from memory allocated with MEMFLAGS of\n+  \/\/ Only constructed with placement new from memory allocated with MemTag of\n@@ -108,1 +108,1 @@\n-  \/\/ Only constructed with placement new from an array allocated with MEMFLAGS\n+  \/\/ Only constructed with placement new from an array allocated with MemTag\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -70,1 +70,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -78,1 +78,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -90,1 +90,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -99,1 +99,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -106,1 +106,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -113,1 +113,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -131,1 +131,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -144,1 +144,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -159,1 +159,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -174,1 +174,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -184,1 +184,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -193,1 +193,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -209,1 +209,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -217,1 +217,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -230,1 +230,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -237,1 +237,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -246,1 +246,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -274,1 +274,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -290,1 +290,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -307,1 +307,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -326,1 +326,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -351,1 +351,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -361,1 +361,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -377,1 +377,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -385,1 +385,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -393,1 +393,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -409,1 +409,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -449,1 +449,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -481,1 +481,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -536,1 +536,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -571,1 +571,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -585,1 +585,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -616,1 +616,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -641,1 +641,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -701,1 +701,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -718,1 +718,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -737,1 +737,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -774,1 +774,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -789,1 +789,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -803,1 +803,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -829,1 +829,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -847,1 +847,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -863,1 +863,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -884,1 +884,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -952,1 +952,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -968,1 +968,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -985,1 +985,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1016,1 +1016,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1035,1 +1035,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1045,1 +1045,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1053,1 +1053,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1061,1 +1061,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1070,1 +1070,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1079,1 +1079,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1087,1 +1087,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1095,1 +1095,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1110,1 +1110,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1131,1 +1131,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1144,1 +1144,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1158,1 +1158,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1182,1 +1182,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1207,1 +1207,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1221,1 +1221,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1233,1 +1233,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1271,1 +1271,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1286,1 +1286,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -1303,1 +1303,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":68,"deletions":68,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -149,1 +149,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -193,1 +193,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n@@ -232,1 +232,1 @@\n-template <typename CONFIG, MEMFLAGS F>\n+template <typename CONFIG, MemTag F>\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTableTasks.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-void* GrowableArrayCHeapAllocator::allocate(int max, int element_size, MEMFLAGS memflags) {\n+void* GrowableArrayCHeapAllocator::allocate(int max, int element_size, MemTag mem_tag) {\n@@ -50,2 +50,2 @@\n-  assert(memflags != mtNone, \"memory type not specified for C heap object\");\n-  return (void*)AllocateHeap(byte_size, memflags);\n+  assert(mem_tag != mtNone, \"memory type not specified for C heap object\");\n+  return (void*)AllocateHeap(byte_size, mem_tag);\n","filename":"src\/hotspot\/share\/utilities\/growableArray.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -598,1 +598,1 @@\n-  static void* allocate(int max, int element_size, MEMFLAGS memflags);\n+  static void* allocate(int max, int element_size, MemTag mem_tag);\n@@ -631,3 +631,3 @@\n-  static uintptr_t bits(MEMFLAGS memflags) {\n-    assert(memflags != mtNone, \"Must provide a proper MEMFLAGS\");\n-    return (uintptr_t(memflags) << 1) | 1;\n+  static uintptr_t bits(MemTag mem_tag) {\n+    assert(mem_tag != mtNone, \"Must provide a proper MemTag\");\n+    return (uintptr_t(mem_tag) << 1) | 1;\n@@ -656,2 +656,2 @@\n-  GrowableArrayMetadata(MEMFLAGS memflags) :\n-      _bits(bits(memflags))\n+  GrowableArrayMetadata(MemTag mem_tag) :\n+      _bits(bits(mem_tag))\n@@ -686,1 +686,1 @@\n-  MEMFLAGS memflags() const { return MEMFLAGS(_bits >> 1); }\n+  MemTag mem_tag() const { return MemTag(_bits >> 1); }\n@@ -693,1 +693,1 @@\n-\/\/  - CHeap allocation: if memflags is provided\n+\/\/  - CHeap allocation: if mem_tag is provided\n@@ -715,2 +715,2 @@\n-  static E* allocate(int max, MEMFLAGS memflags) {\n-    return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), memflags);\n+  static E* allocate(int max, MemTag mem_tag) {\n+    return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), mem_tag);\n@@ -739,1 +739,1 @@\n-      return allocate(this->_capacity, _metadata.memflags());\n+      return allocate(this->_capacity, _metadata.mem_tag());\n@@ -763,1 +763,1 @@\n-  GrowableArray(int initial_capacity, MEMFLAGS memflags) :\n+  GrowableArray(int initial_capacity, MemTag mem_tag) :\n@@ -765,1 +765,1 @@\n-          allocate(initial_capacity, memflags),\n+          allocate(initial_capacity, mem_tag),\n@@ -767,1 +767,1 @@\n-      _metadata(memflags) {\n+      _metadata(mem_tag) {\n@@ -779,1 +779,1 @@\n-  GrowableArray(int initial_capacity, int initial_len, const E& filler, MEMFLAGS memflags) :\n+  GrowableArray(int initial_capacity, int initial_len, const E& filler, MemTag mem_tag) :\n@@ -781,1 +781,1 @@\n-          allocate(initial_capacity, memflags),\n+          allocate(initial_capacity, mem_tag),\n@@ -783,1 +783,1 @@\n-      _metadata(memflags) {\n+      _metadata(mem_tag) {\n@@ -802,2 +802,2 @@\n-\/\/ Leaner GrowableArray for CHeap backed data arrays, with compile-time decided MEMFLAGS.\n-template <typename E, MEMFLAGS F>\n+\/\/ Leaner GrowableArray for CHeap backed data arrays, with compile-time decided MemTag.\n+template <typename E, MemTag F>\n@@ -809,1 +809,1 @@\n-  static E* allocate(int max, MEMFLAGS flags) {\n+  static E* allocate(int max, MemTag mem_tag) {\n@@ -814,1 +814,1 @@\n-    return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), flags);\n+    return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), mem_tag);\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-  MEMFLAGS F = mtNMT, AllocFailType alloc_failmode = AllocFailStrategy::RETURN_NULL>\n+  MemTag F = mtNMT, AllocFailType alloc_failmode = AllocFailStrategy::RETURN_NULL>\n@@ -368,1 +368,1 @@\n-  MEMFLAGS F = mtNMT, AllocFailType alloc_failmode = AllocFailStrategy::RETURN_NULL>\n+  MemTag F = mtNMT, AllocFailType alloc_failmode = AllocFailStrategy::RETURN_NULL>\n","filename":"src\/hotspot\/share\/utilities\/linkedlist.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-template<MEMFLAGS F>\n+template<MemTag F>\n@@ -84,1 +84,1 @@\n-template<MEMFLAGS F>\n+template<MemTag F>\n","filename":"src\/hotspot\/share\/utilities\/objectBitSet.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-template<MEMFLAGS F>\n+template<MemTag F>\n@@ -39,1 +39,1 @@\n-template<MEMFLAGS F>\n+template<MemTag F>\n@@ -47,1 +47,1 @@\n-template<MEMFLAGS F>\n+template<MemTag F>\n@@ -59,1 +59,1 @@\n-template<MEMFLAGS F>\n+template<MemTag F>\n@@ -64,1 +64,1 @@\n-template<MEMFLAGS F>\n+template<MemTag F>\n@@ -89,1 +89,1 @@\n-template<MEMFLAGS F>\n+template<MemTag F>\n@@ -96,1 +96,1 @@\n-template<MEMFLAGS F>\n+template<MemTag F>\n","filename":"src\/hotspot\/share\/utilities\/objectBitSet.inline.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-    MEMFLAGS MEM_TYPE>\n+    MemTag MEM_TYPE>\n@@ -75,1 +75,1 @@\n-    MEMFLAGS MEM_TYPE = mtInternal,\n+    MemTag MEM_TYPE = mtInternal,\n","filename":"src\/hotspot\/share\/utilities\/resizeableResourceHash.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-    MEMFLAGS MEM_TYPE,\n+    MemTag MEM_TYPE,\n@@ -367,1 +367,1 @@\n-    MEMFLAGS MEM_TYPE = mtInternal,\n+    MemTag MEM_TAG = mtInternal,\n@@ -373,1 +373,1 @@\n-    K, V, ALLOC_TYPE, MEM_TYPE, HASH, EQUALS> {\n+    K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> {\n@@ -377,1 +377,1 @@\n-                                              K, V, ALLOC_TYPE, MEM_TYPE, HASH, EQUALS>() {}\n+                                              K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS>() {}\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-template <class E, MEMFLAGS F> class StackIterator;\n+template <class E, MemTag F> class StackIterator;\n@@ -58,1 +58,1 @@\n-template <MEMFLAGS F> class StackBase\n+template <MemTag F> class StackBase\n@@ -88,1 +88,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -163,1 +163,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n","filename":"src\/hotspot\/share\/utilities\/stack.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-template <MEMFLAGS F> StackBase<F>::StackBase(size_t segment_size, size_t max_cache_size,\n+template <MemTag F> StackBase<F>::StackBase(size_t segment_size, size_t max_cache_size,\n@@ -43,1 +43,1 @@\n-template <MEMFLAGS F> size_t StackBase<F>::adjust_max_size(size_t max_size, size_t seg_size)\n+template <MemTag F> size_t StackBase<F>::adjust_max_size(size_t max_size, size_t seg_size)\n@@ -54,1 +54,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -61,1 +61,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -74,1 +74,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -88,1 +88,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -96,1 +96,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -108,1 +108,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -114,1 +114,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -120,1 +120,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -126,1 +126,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -132,1 +132,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -139,1 +139,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -145,1 +145,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -155,1 +155,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -176,1 +176,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -197,1 +197,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -208,1 +208,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -221,1 +221,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -237,1 +237,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -246,1 +246,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n@@ -254,1 +254,1 @@\n-template <class E, MEMFLAGS F>\n+template <class E, MemTag F>\n","filename":"src\/hotspot\/share\/utilities\/stack.inline.hpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-template<typename E, template<typename, MEMFLAGS> class Allocator>\n+template<typename E, template<typename, MemTag> class Allocator>\n","filename":"test\/hotspot\/gtest\/nmt\/test_arrayWithFreeList.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static void check_expected_malloc_header(const void* payload, MEMFLAGS type, size_t size) {\n+static void check_expected_malloc_header(const void* payload, MemTag mem_tag, size_t size) {\n@@ -39,1 +39,1 @@\n-  EXPECT_EQ(hdr->flags(), type);\n+  EXPECT_EQ(hdr->mem_tag(), mem_tag);\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_cornercases.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,3 +45,3 @@\n-    for (int i = 0; i < mt_number_of_types; i++) {\n-      if (!compare_limits(a->category_limit(NMTUtil::index_to_flag(i)),\n-                          b->category_limit(NMTUtil::index_to_flag(i)))) {\n+    for (int i = 0; i < mt_number_of_tags; i++) {\n+      if (!compare_limits(a->category_limit(NMTUtil::index_to_tag(i)),\n+                          b->category_limit(NMTUtil::index_to_tag(i)))) {\n@@ -99,5 +99,5 @@\n-  for (int i = 0; i < mt_number_of_types; i++) {\n-    MEMFLAGS f = NMTUtil::index_to_flag(i);\n-    if (f != MEMFLAGS::mtNone) {\n-      expected.set_category_limit(f, (i + 1) * M, MallocLimitMode::trigger_fatal);\n-      option.print(\"%s%s:%dM\", (i > 0 ? \",\" : \"\"), NMTUtil::flag_to_enum_name(f), i + 1);\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    MemTag mem_tag = NMTUtil::index_to_tag(i);\n+    if (mem_tag != MemTag::mtNone) {\n+      expected.set_category_limit(mem_tag, (i + 1) * M, MallocLimitMode::trigger_fatal);\n+      option.print(\"%s%s:%dM\", (i > 0 ? \",\" : \"\"), NMTUtil::tag_to_enum_name(mem_tag), i + 1);\n@@ -112,5 +112,5 @@\n-  for (int i = 0; i < mt_number_of_types; i++) {\n-    MEMFLAGS f = NMTUtil::index_to_flag(i);\n-    if (f != MEMFLAGS::mtNone) {\n-      expected.set_category_limit(f, (i + 1) * M, MallocLimitMode::trigger_fatal);\n-      option.print(\"%s%s:%dM\", (i > 0 ? \",\" : \"\"), NMTUtil::flag_to_name(f), i + 1);\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    MemTag mem_tag = NMTUtil::index_to_tag(i);\n+    if (mem_tag != MemTag::mtNone) {\n+      expected.set_category_limit(mem_tag, (i + 1) * M, MallocLimitMode::trigger_fatal);\n+      option.print(\"%s%s:%dM\", (i > 0 ? \",\" : \"\"), NMTUtil::tag_to_name(mem_tag), i + 1);\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_malloclimit.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"nmt\/nmtCommon.hpp\"\n@@ -36,1 +37,1 @@\n-  VirtualMemorySummary::record_reserved_memory(os::vm_page_size(), region1.flag());\n+  VirtualMemorySummary::record_reserved_memory(os::vm_page_size(), region1.mem_tag());\n@@ -41,1 +42,1 @@\n-  VirtualMemorySummary::record_reserved_memory(os::vm_page_size(), region2.flag());\n+  VirtualMemorySummary::record_reserved_memory(os::vm_page_size(), region2.mem_tag());\n@@ -49,1 +50,1 @@\n-  ASSERT_EQ(region2.flag(), mtThreadStack); \/\/ Should be correct flag\n+  ASSERT_EQ(region2.mem_tag(), mtThreadStack); \/\/ Should be correct flag\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_reserved_region.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,2 +92,2 @@\n-    int category = i % (mt_number_of_types - 1);\n-    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MEMFLAGS)category);\n+    int category = i % (mt_number_of_tags - 1);\n+    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MemTag)category);\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_totals.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -71,1 +71,1 @@\n-    return x->val().in.type();\n+    return x->val().in.state();\n@@ -75,1 +75,1 @@\n-    return x->val().out.type();\n+    return x->val().out.state();\n@@ -217,1 +217,1 @@\n-        EXPECT_EQ(x->val().out.regiondata().flag, mtTest);\n+        EXPECT_EQ(x->val().out.regiondata().mem_tag, mtTest);\n@@ -243,0 +243,1 @@\n+\n@@ -252,1 +253,1 @@\n-        EXPECT_EQ(mtTest, x->val().out.regiondata().flag);\n+        EXPECT_EQ(mtTest, x->val().out.regiondata().mem_tag);\n@@ -255,1 +256,1 @@\n-        EXPECT_EQ(mtTest, x->val().in.regiondata().flag);\n+        EXPECT_EQ(mtTest, x->val().in.regiondata().mem_tag);\n@@ -277,1 +278,1 @@\n-    VMATree::SingleDiff diff = all_diff.flag[NMTUtil::flag_to_index(mtTest)];\n+    VMATree::SingleDiff diff = all_diff.type[NMTUtil::tag_to_index(mtTest)];\n@@ -280,2 +281,2 @@\n-    diff = all_diff.flag[NMTUtil::flag_to_index(mtTest)];\n-    VMATree::SingleDiff diff2 = all_diff.flag[NMTUtil::flag_to_index(mtNMT)];\n+    diff = all_diff.type[NMTUtil::tag_to_index(mtTest)];\n+    VMATree::SingleDiff diff2 = all_diff.type[NMTUtil::tag_to_index(mtNMT)];\n@@ -289,1 +290,1 @@\n-    VMATree::SingleDiff diff = all_diff.flag[NMTUtil::flag_to_index(mtTest)];\n+    VMATree::SingleDiff diff = all_diff.type[NMTUtil::tag_to_index(mtTest)];\n@@ -292,1 +293,1 @@\n-    diff = all_diff.flag[NMTUtil::flag_to_index(mtTest)];\n+    diff = all_diff.type[NMTUtil::tag_to_index(mtTest)];\n@@ -299,1 +300,1 @@\n-    VMATree::SingleDiff diff = all_diff.flag[NMTUtil::flag_to_index(mtTest)];\n+    VMATree::SingleDiff diff = all_diff.type[NMTUtil::tag_to_index(mtTest)];\n@@ -302,1 +303,1 @@\n-    diff = all_diff.flag[NMTUtil::flag_to_index(mtTest)];\n+    diff = all_diff.type[NMTUtil::tag_to_index(mtTest)];\n@@ -306,1 +307,1 @@\n-  { \/\/ Adjacent reserved mappings with same flag\n+  { \/\/ Adjacent reserved mappings with same type\n@@ -310,1 +311,1 @@\n-    VMATree::SingleDiff diff = all_diff.flag[NMTUtil::flag_to_index(mtTest)];\n+    VMATree::SingleDiff diff = all_diff.type[NMTUtil::tag_to_index(mtTest)];\n@@ -313,1 +314,1 @@\n-    diff = all_diff.flag[NMTUtil::flag_to_index(mtTest)];\n+    diff = all_diff.type[NMTUtil::tag_to_index(mtTest)];\n@@ -321,1 +322,1 @@\n-    VMATree::SingleDiff diff = all_diff.flag[NMTUtil::flag_to_index(mtTest)];\n+    VMATree::SingleDiff diff = all_diff.type[NMTUtil::tag_to_index(mtTest)];\n@@ -324,1 +325,1 @@\n-    diff = all_diff.flag[NMTUtil::flag_to_index(mtTest)];\n+    diff = all_diff.type[NMTUtil::tag_to_index(mtTest)];\n@@ -326,1 +327,1 @@\n-    diff = all_diff.flag[NMTUtil::flag_to_index(mtNMT)];\n+    diff = all_diff.type[NMTUtil::tag_to_index(mtNMT)];\n@@ -337,2 +338,2 @@\n-    EXPECT_EQ(768, diff.flag[NMTUtil::flag_to_index(mtTest)].commit);\n-    EXPECT_EQ(768, diff.flag[NMTUtil::flag_to_index(mtTest)].reserve);\n+    EXPECT_EQ(768, diff.type[NMTUtil::tag_to_index(mtTest)].commit);\n+    EXPECT_EQ(768, diff.type[NMTUtil::tag_to_index(mtTest)].reserve);\n@@ -344,1 +345,1 @@\n-struct SimpleVMATracker : public CHeapObj<mtTest> {\n+  struct SimpleVMATracker : public CHeapObj<mtTest> {\n@@ -346,1 +347,1 @@\n-  enum Type { Reserved, Committed, Free };\n+  enum Kind { Reserved, Committed, Free };\n@@ -348,2 +349,2 @@\n-    Type type;\n-    MEMFLAGS flag;\n+    Kind kind;\n+    MemTag mem_tag;\n@@ -351,1 +352,1 @@\n-    Info() : type(Free), flag(mtNone), stack() {}\n+    Info() : kind(Free), mem_tag(mtNone), stack() {}\n@@ -353,2 +354,2 @@\n-    Info(Type type, NativeCallStack stack, MEMFLAGS flag)\n-    : type(type), flag(flag), stack(stack) {}\n+    Info(Kind kind, NativeCallStack stack, MemTag mem_tag)\n+    : kind(kind), mem_tag(mem_tag), stack(stack) {}\n@@ -357,1 +358,1 @@\n-      return flag == other.flag && stack.equals(other.stack);\n+      return kind == other.kind && stack.equals(other.stack);\n@@ -371,1 +372,1 @@\n-  VMATree::SummaryDiff do_it(Type type, size_t start, size_t size, NativeCallStack stack, MEMFLAGS flag) {\n+  VMATree::SummaryDiff do_it(Kind kind, size_t start, size_t size, NativeCallStack stack, MemTag mem_tag) {\n@@ -380,1 +381,1 @@\n-    Info new_info(type, stack, flag);\n+    Info new_info(kind, stack, mem_tag);\n@@ -385,5 +386,5 @@\n-      if (old_info.type == Reserved) {\n-        diff.flag[(int)old_info.flag].reserve -= page_size;\n-      } else if (old_info.type == Committed) {\n-        diff.flag[(int)old_info.flag].reserve -= page_size;\n-        diff.flag[(int)old_info.flag].commit -= page_size;\n+      if (old_info.kind == Reserved) {\n+        diff.type[(int)old_info.mem_tag].reserve -= page_size;\n+      } else if (old_info.kind == Committed) {\n+        diff.type[(int)old_info.mem_tag].reserve -= page_size;\n+        diff.type[(int)old_info.mem_tag].commit -= page_size;\n@@ -392,5 +393,5 @@\n-      if (type == Reserved) {\n-        diff.flag[(int)new_info.flag].reserve += page_size;\n-      } else if(type == Committed) {\n-        diff.flag[(int)new_info.flag].reserve += page_size;\n-        diff.flag[(int)new_info.flag].commit += page_size;\n+      if (kind == Reserved) {\n+        diff.type[(int)new_info.mem_tag].reserve += page_size;\n+      } else if (kind == Committed) {\n+        diff.type[(int)new_info.mem_tag].reserve += page_size;\n+        diff.type[(int)new_info.mem_tag].commit += page_size;\n@@ -404,2 +405,2 @@\n-  VMATree::SummaryDiff reserve(size_t start, size_t size, NativeCallStack stack, MEMFLAGS flag) {\n-    return do_it(Reserved, start, size, stack, flag);\n+  VMATree::SummaryDiff reserve(size_t start, size_t size, NativeCallStack stack, MemTag mem_tag) {\n+    return do_it(Reserved, start, size, stack, mem_tag);\n@@ -408,2 +409,2 @@\n-  VMATree::SummaryDiff commit(size_t start, size_t size, NativeCallStack stack, MEMFLAGS flag) {\n-    return do_it(Committed, start, size, stack, flag);\n+  VMATree::SummaryDiff commit(size_t start, size_t size, NativeCallStack stack, MemTag mem_tag) {\n+    return do_it(Committed, start, size, stack, mem_tag);\n@@ -434,1 +435,1 @@\n-  const MEMFLAGS candidate_flags[candidates_len_flags] = {\n+  const MemTag candidate_flags[candidates_len_flags] = {\n@@ -458,1 +459,1 @@\n-    const MEMFLAGS flag = candidate_flags[os::random() % candidates_len_flags];\n+    const MemTag mem_tag = candidate_flags[os::random() % candidates_len_flags];\n@@ -462,1 +463,1 @@\n-    VMATree::RegionData data(si, flag);\n+    VMATree::RegionData data(si, mem_tag);\n@@ -464,1 +465,1 @@\n-    const SimpleVMATracker::Type type = (SimpleVMATracker::Type)(os::random() % 3);\n+    const SimpleVMATracker::Kind kind = (SimpleVMATracker::Kind)(os::random() % 3);\n@@ -468,2 +469,2 @@\n-    if (type == SimpleVMATracker::Reserved) {\n-      simple_diff = tr->reserve(start, size, stack, flag);\n+    if (kind == SimpleVMATracker::Reserved) {\n+      simple_diff = tr->reserve(start, size, stack, mem_tag);\n@@ -471,2 +472,2 @@\n-    } else if (type == SimpleVMATracker::Committed) {\n-      simple_diff = tr->commit(start, size, stack, flag);\n+    } else if (kind == SimpleVMATracker::Committed) {\n+      simple_diff = tr->commit(start, size, stack, mem_tag);\n@@ -479,3 +480,3 @@\n-    for (int j = 0; j < mt_number_of_types; j++) {\n-      VMATree::SingleDiff td = tree_diff.flag[j];\n-      VMATree::SingleDiff sd = simple_diff.flag[j];\n+    for (int j = 0; j < mt_number_of_tags; j++) {\n+      VMATree::SingleDiff td = tree_diff.type[j];\n+      VMATree::SingleDiff sd = simple_diff.type[j];\n@@ -492,1 +493,1 @@\n-               tr->pages[j].type == SimpleVMATracker::Free) {\n+               tr->pages[j].kind == SimpleVMATracker::Free) {\n@@ -523,2 +524,2 @@\n-        ASSERT_EQ(starti.flag, startn->val().out.flag());\n-        ASSERT_EQ(endi.flag, endn->val().in.flag());\n+        ASSERT_EQ(starti.mem_tag, startn->val().out.mem_tag());\n+        ASSERT_EQ(endi.mem_tag, endn->val().in.mem_tag());\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":60,"deletions":59,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-  WithEmbeddedArray(int initial_max, MEMFLAGS memflags) : _a(initial_max, memflags) {\n-    assert(memflags != mtNone, \"test requirement\");\n+  WithEmbeddedArray(int initial_max, MemTag mem_tag) : _a(initial_max, mem_tag) {\n+    assert(mem_tag != mtNone, \"test requirement\");\n","filename":"test\/hotspot\/gtest\/utilities\/test_growableArray.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"nmt\/nmtCommon.hpp\"\n@@ -38,1 +39,1 @@\n-  const static MEMFLAGS MEM_TYPE = mtInternal;\n+  const static MemTag MEM_TAG = mtInternal;\n@@ -96,1 +97,1 @@\n-      ResourceHashtable<K, V, SIZE, ALLOC_TYPE, MEM_TYPE, HASH, EQUALS> rh;\n+      ResourceHashtable<K, V, SIZE, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> rh;\n@@ -228,1 +229,1 @@\n-      ResourceHashtable<K, V, SIZE, ALLOC_TYPE, MEM_TYPE, HASH, EQUALS> rh;\n+      ResourceHashtable<K, V, SIZE, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> rh;\n","filename":"test\/hotspot\/gtest\/utilities\/test_resourceHash.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n","filename":"test\/hotspot\/gtest\/utilities\/test_utf8.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}