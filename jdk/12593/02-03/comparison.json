{"files":[{"patch":"@@ -50,1 +50,0 @@\n-    DISABLED_WARNINGS_microsoft_NetworkInterface.c := 4133, \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,6 @@\n+\/*\n+ * Gets the unicast and anycast IP address tables.\n+ * If an error occurs while fetching a table,\n+ * any tables already fetched are freed and an exception is set.\n+ * It is the caller's responsibility to free the tables when they are no longer needed.\n+ *\/\n@@ -83,0 +89,3 @@\n+\/*\n+ * Frees a linked list of netaddr structs.\n+ *\/\n@@ -92,0 +101,8 @@\n+\/*\n+ * Builds and returns a java.net.NetworkInterface object from the given MIB_IF_ROW2.\n+ * Unlike createNetworkInterfaceForSingleRowWithTables,\n+ * this expects that the row is already populated, either by GetIfEntry2 or GetIfTable2.\n+ * If anything goes wrong, an exception will be set,\n+ * but the address tables are not freed.\n+ * Freeing the address tables is always the caller's responsibility.\n+ *\/\n@@ -110,1 +127,1 @@\n-            &(ifRow->InterfaceLuid), (PWSTR) &ifName, NDIS_IF_MAX_BUFFER_SIZE);\n+            &(ifRow->InterfaceLuid), ifName, NDIS_IF_MAX_BUFFER_SIZE);\n@@ -117,2 +134,1 @@\n-    name = (*env)->NewString(\n-            env, (const jchar *) &ifName, (jsize) wcslen((const wchar_t *) &ifName));\n+    name = (*env)->NewString(env, ifName, (jsize) wcslen(ifName));\n@@ -127,2 +143,1 @@\n-            env, (const jchar *) ifRow->Description,\n-            (jsize) wcslen((const wchar_t *) &(ifRow->Description)));\n+            env, ifRow->Description, (jsize) wcslen(ifRow->Description));\n@@ -145,0 +160,5 @@\n+            if (addrsCurrent == NULL) {\n+                freeNetaddrs(addrsHead);\n+                JNU_ThrowOutOfMemoryError(env, \"native heap\");\n+                return NULL;\n+            }\n@@ -155,0 +175,5 @@\n+            if (addrsCurrent == NULL) {\n+                freeNetaddrs(addrsHead);\n+                JNU_ThrowOutOfMemoryError(env, \"native heap\");\n+                return NULL;\n+            }\n@@ -288,0 +313,8 @@\n+\/*\n+ * Builds and returns a java.net.NetworkInterface object from the given MIB_IF_ROW2.\n+ * This expects that the row is not yet populated, but an index has been set,\n+ * so the row is ready to be populated by GetIfEntry2.\n+ * If anything goes wrong, an exception will be set,\n+ * but the address tables are not freed.\n+ * Freeing the address tables is always the caller's responsibility.\n+ *\/\n@@ -289,1 +322,1 @@\n-        JNIEnv *env, BOOL throwIfNotFound, MIB_IF_ROW2 *ifRow,\n+        JNIEnv *env, MIB_IF_ROW2 *ifRow,\n@@ -295,1 +328,1 @@\n-        if (throwIfNotFound && apiRetVal == ERROR_FILE_NOT_FOUND) {\n+        if (apiRetVal != ERROR_FILE_NOT_FOUND) {\n@@ -305,0 +338,8 @@\n+\/*\n+ * Builds and returns a java.net.NetworkInterface object from the given MIB_IF_ROW2.\n+ * This expects that the row is not yet populated, but an index has been set,\n+ * so the row is ready to be populated by GetIfEntry2.\n+ * Unlike createNetworkInterfaceForSingleRowWithTables, this will get the address\n+ * tables at the beginning and free them at the end.\n+ * If anything goes wrong, an exception will be set.\n+ *\/\n@@ -306,1 +347,1 @@\n-        JNIEnv *env, BOOL throwIfNotFound, MIB_IF_ROW2 *ifRow) {\n+        JNIEnv *env, MIB_IF_ROW2 *ifRow) {\n@@ -316,1 +357,1 @@\n-            env, throwIfNotFound, ifRow, uniAddrs, anyAddrs);\n+            env, ifRow, uniAddrs, anyAddrs);\n@@ -333,0 +374,5 @@\n+    if (index == 0) {\n+        \/\/ 0 is never a valid index, and would make GetIfEntry2 think nothing is set\n+        return NULL;\n+    }\n+\n@@ -334,1 +380,1 @@\n-    return createNetworkInterfaceForSingleRow(env, FALSE, &ifRow);\n+    return createNetworkInterfaceForSingleRow(env, &ifRow);\n@@ -360,1 +406,1 @@\n-    return createNetworkInterfaceForSingleRow(env, TRUE, &ifRow);\n+    return createNetworkInterfaceForSingleRow(env, &ifRow);\n@@ -387,1 +433,1 @@\n-                    env, TRUE, &ifRow, uniAddrs, anyAddrs);\n+                    env, &ifRow, uniAddrs, anyAddrs);\n@@ -396,1 +442,1 @@\n-                    env, TRUE, &ifRow, uniAddrs, anyAddrs);\n+                    env, &ifRow, uniAddrs, anyAddrs);\n@@ -623,24 +669,1 @@\n-    \/*\n-    In older versions of Windows, multicast could be disabled for individual interfaces.\n-    That does not appear to be supported any longer.\n-    Now, it seems to be a system-wide setting, but with separate settings for IPv4 vs IPv6.\n-    We also have the additional complication that multicast sending\n-    can be enabled while receiving is disabled.\n-\n-    There are no good ways to access these settings.\n-    GetAdaptersAddresses has a NO_MULTICAST flag, but I have never seen it set,\n-    even when multicast is disabled.\n-    The flags appear to be stored in the registry,\n-    but the exact location seems to change depending on the Windows version.\n-    We could open a socket and try to join a multicast group.\n-    If receiving is disabled, that fails. But if enabled, it generates network traffic.\n-    I also tried some socket IOCTLs (e.g. SIO_ROUTING_INTERFACE_QUERY)\n-    but all of those succeeded even when multicast was disabled.\n-    Same for various setsockopt params (e.g. IP_MULTICAST_IF).\n-    It's also possible to use COM to execute a WMI query:\n-    \"SELECT MldLevel FROM MSFT_NetIPv4Protocol\" in namespace \"ROOT\\\\StandardCimv2\"\n-    But during review, we agreed that wasn't great either.\n-    So we're just going to unconditionally return true\n-    since multicast is unlikely to be disabled,\n-    and a boolean can't represent the full range of possibilities anyway.\n-    *\/\n+    \/\/ we assume that multicast is enabled, because there are no reliable APIs to tell us\n","filename":"src\/java.base\/windows\/native\/libnet\/NetworkInterface.c","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"}]}