{"files":[{"patch":"@@ -50,2 +50,0 @@\n-    DISABLED_WARNINGS_microsoft_NetworkInterface.c := 4133, \\\n-    DISABLED_WARNINGS_microsoft_NetworkInterface_winXP.c := 4133, \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,13 +35,0 @@\n- *\n- * Interfaces and addresses are enumerated using the IP helper routines\n- * GetIfTable, GetIfAddrTable resp. These routines are available on Windows\n- * 98, NT SP+4, 2000, and XP. They are also available on Windows 95 if\n- * IE is upgraded to 5.x.\n- *\n- * Windows does not have any standard for device names so we are forced\n- * to use our own convention which is based on the normal Unix naming\n- * convention (\"lo\" for the loopback, eth0, eth1, .. for ethernet devices,\n- * tr0, tr1, .. for token ring, and so on). This convention gives us\n- * consistency across multiple Windows editions and also consistency with\n- * Solaris\/Linux device names. Note that we always enumerate in index\n- * order and this ensures consistent device number across invocations.\n@@ -50,0 +37,3 @@\n+#define NDIS_IF_MAX_BUFFER_SIZE NDIS_IF_MAX_STRING_SIZE + 1\n+#define NO_PREFIX 255\n+\n@@ -70,1 +60,4 @@\n- * Support routines to free netif and netaddr lists\n+ * Gets the unicast and anycast IP address tables.\n+ * If an error occurs while fetching a table,\n+ * any tables already fetched are freed and an exception is set.\n+ * It is the caller's responsibility to free the tables when they are no longer needed.\n@@ -72,13 +65,22 @@\n-void free_netif(netif *netifP) {\n-    netif *curr = netifP;\n-    while (curr != NULL) {\n-        if (curr->name != NULL)\n-            free(curr->name);\n-        if (curr->displayName != NULL)\n-            free(curr->displayName);\n-        if (curr->addrs != NULL)\n-            free_netaddr (curr->addrs);\n-        netifP = netifP->next;\n-        free(curr);\n-        curr = netifP;\n-    }\n+static BOOL getAddressTables(\n+        JNIEnv *env, MIB_UNICASTIPADDRESS_TABLE **uniAddrs,\n+        MIB_ANYCASTIPADDRESS_TABLE **anyAddrs) {\n+    ULONG apiRetVal;\n+    ADDRESS_FAMILY addrFamily = ipv6_available() ? AF_UNSPEC : AF_INET;\n+\n+    apiRetVal = GetUnicastIpAddressTable(addrFamily, uniAddrs);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetUnicastIpAddressTable\");\n+        return FALSE;\n+    }\n+    apiRetVal = GetAnycastIpAddressTable(addrFamily, anyAddrs);\n+    if (apiRetVal != NO_ERROR) {\n+        FreeMibTable(*uniAddrs);\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetAnycastIpAddressTable\");\n+        return FALSE;\n+    }\n+    return TRUE;\n@@ -87,1 +89,4 @@\n-void free_netaddr(netaddr *netaddrP) {\n+\/*\n+ * Frees a linked list of netaddr structs.\n+ *\/\n+static void freeNetaddrs(netaddr *netaddrP) {\n@@ -90,1 +95,1 @@\n-        netaddrP = netaddrP->next;\n+        netaddrP = netaddrP->Next;\n@@ -97,1 +102,6 @@\n- * Returns the interface structure from the table with the matching index.\n+ * Builds and returns a java.net.NetworkInterface object from the given MIB_IF_ROW2.\n+ * Unlike createNetworkInterfaceForSingleRowWithTables,\n+ * this expects that the row is already populated, either by GetIfEntry2 or GetIfTable2.\n+ * If anything goes wrong, an exception will be set,\n+ * but the address tables are not freed.\n+ * Freeing the address tables is always the caller's responsibility.\n@@ -99,6 +109,9 @@\n-MIB_IFROW *getIF(jint index) {\n-    MIB_IFTABLE *tableP;\n-    MIB_IFROW *ifrowP, *ret = NULL;\n-    ULONG size;\n-    DWORD i, count;\n-    jint ifindex;\n+static jobject createNetworkInterface(\n+        JNIEnv *env, MIB_IF_ROW2 *ifRow, MIB_UNICASTIPADDRESS_TABLE *uniAddrs,\n+        MIB_ANYCASTIPADDRESS_TABLE *anyAddrs) {\n+    WCHAR ifName[NDIS_IF_MAX_BUFFER_SIZE];\n+    jobject netifObj, name, displayName, inetAddr, bcastAddr, bindAddr;\n+    jobjectArray addrArr, bindsArr, childArr;\n+    netaddr *addrsHead = NULL, *addrsCurrent = NULL;\n+    int addrCount = 0;\n+    ULONG apiRetVal, i, mask;\n@@ -106,6 +119,3 @@\n-    \/*\n-     * Ask the IP Helper library to enumerate the adapters\n-     *\/\n-    size = sizeof(MIB_IFTABLE);\n-    tableP = (MIB_IFTABLE *)malloc(size);\n-    if(tableP == NULL)\n+    \/\/ instantiate the NetworkInterface object\n+    netifObj = (*env)->NewObject(env, ni_class, ni_ctor);\n+    if (netifObj == NULL) {\n@@ -113,11 +123,0 @@\n-\n-    count = GetIfTable(tableP, &size, TRUE);\n-    if (count == ERROR_INSUFFICIENT_BUFFER) {\n-        MIB_IFTABLE* newTableP =  (MIB_IFTABLE *)realloc(tableP, size);\n-        if (newTableP == NULL) {\n-            free(tableP);\n-            return NULL;\n-        }\n-        tableP = newTableP;\n-\n-        count = GetIfTable(tableP, &size, TRUE);\n@@ -126,2 +125,7 @@\n-    if (count != NO_ERROR) {\n-        free(tableP);\n+    \/\/ set the NetworkInterface's name\n+    apiRetVal = ConvertInterfaceLuidToNameW(\n+            &(ifRow->InterfaceLuid), ifName, NDIS_IF_MAX_BUFFER_SIZE);\n+    if (apiRetVal != ERROR_SUCCESS) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"ConvertInterfaceLuidToNameW\");\n@@ -130,71 +134,3 @@\n-\n-    {\n-    ifrowP = tableP->table;\n-    for (i=0; i<tableP->dwNumEntries; i++) {\n-    \/*\n-     * Warning: the real index is obtained by GetFriendlyIfIndex()\n-    *\/\n-        ifindex = GetFriendlyIfIndex(ifrowP->dwIndex);\n-        if (ifindex == index) {\n-          \/*\n-           * Create a copy of the entry so that we can free the table.\n-           *\/\n-            ret = (MIB_IFROW *) malloc(sizeof(MIB_IFROW));\n-            if (ret == NULL) {\n-                free(tableP);\n-                return NULL;\n-            }\n-            memcpy(ret, ifrowP, sizeof(MIB_IFROW));\n-            break;\n-        }\n-\n-        \/* onto the next interface *\/\n-        ifrowP++;\n-      }\n-      free(tableP);\n-    }\n-    return ret;\n-}\n-\n-\/*\n- * Enumerate network interfaces using IP Helper Library routine GetIfTable.\n- * We use GetIfTable rather than other IP helper routines because it's\n- * available on 98 & NT SP4+.\n- *\n- * Returns the number of interfaces found or -1 if error. If no error\n- * occurs then netifPP be returned as list of netif structures or NULL\n- * if no interfaces are found.\n- *\/\n-int enumInterfaces(JNIEnv *env, netif **netifPP)\n-{\n-    MIB_IFTABLE *tableP;\n-    MIB_IFROW *ifrowP;\n-    ULONG size;\n-    DWORD ret;\n-    int count;\n-    netif *netifP;\n-    DWORD i;\n-    int lo=0, eth=0, tr=0, fddi=0, ppp=0, sl=0, wlan=0, net=0, wlen=0;\n-\n-    *netifPP = NULL;\n-\n-    \/*\n-     * Ask the IP Helper library to enumerate the adapters\n-     *\/\n-    size = sizeof(MIB_IFTABLE);\n-    tableP = (MIB_IFTABLE *)malloc(size);\n-    if (tableP == NULL) {\n-        JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failure\");\n-        return -1;\n-    }\n-\n-    ret = GetIfTable(tableP, &size, TRUE);\n-    if (ret == ERROR_INSUFFICIENT_BUFFER) {\n-        MIB_IFTABLE * newTableP = (MIB_IFTABLE *)realloc(tableP, size);\n-        if (newTableP == NULL) {\n-            free(tableP);\n-            JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failure\");\n-            return -1;\n-        }\n-        tableP = newTableP;\n-        ret = GetIfTable(tableP, &size, TRUE);\n+    name = (*env)->NewString(env, ifName, (jsize) wcslen(ifName));\n+    if (name == NULL) {\n+        return NULL;\n@@ -202,0 +138,2 @@\n+    (*env)->SetObjectField(env, netifObj, ni_nameID, name);\n+    (*env)->DeleteLocalRef(env, name);\n@@ -203,16 +141,5 @@\n-    if (ret != NO_ERROR) {\n-        free(tableP);\n-        switch (ret) {\n-            case ERROR_INVALID_PARAMETER:\n-                JNU_ThrowInternalError(env,\n-                    \"IP Helper Library GetIfTable function failed: \"\n-                    \"invalid parameter\");\n-                break;\n-            default:\n-                SetLastError(ret);\n-                JNU_ThrowByNameWithMessageAndLastError(env,\n-                    JNU_JAVANETPKG \"SocketException\",\n-                    \"IP Helper Library GetIfTable function failed\");\n-                break;\n-        }\n-        return -1;\n+    \/\/ set the NetworkInterface's display name\n+    displayName = (*env)->NewString(\n+            env, ifRow->Description, (jsize) wcslen(ifRow->Description));\n+    if (displayName == NULL) {\n+        return NULL;\n@@ -220,0 +147,2 @@\n+    (*env)->SetObjectField(env, netifObj, ni_displayNameID, displayName);\n+    (*env)->DeleteLocalRef(env, displayName);\n@@ -221,129 +150,14 @@\n-    \/*\n-     * Iterate through the list of adapters\n-     *\/\n-    count = 0;\n-    netifP = NULL;\n-\n-    ifrowP = tableP->table;\n-    for (i=0; i<tableP->dwNumEntries; i++) {\n-        char dev_name[8];\n-        netif *curr;\n-\n-        \/*\n-         * Generate a name for the device as Windows doesn't have any\n-         * real concept of a device name.\n-         *\/\n-        switch (ifrowP->dwType) {\n-            case MIB_IF_TYPE_ETHERNET:\n-                _snprintf_s(dev_name, 8, _TRUNCATE, \"eth%d\", eth++);\n-                break;\n-\n-            case MIB_IF_TYPE_TOKENRING:\n-                _snprintf_s(dev_name, 8, _TRUNCATE, \"tr%d\", tr++);\n-                break;\n-\n-            case MIB_IF_TYPE_FDDI:\n-                _snprintf_s(dev_name, 8, _TRUNCATE, \"fddi%d\", fddi++);\n-                break;\n-\n-            case MIB_IF_TYPE_LOOPBACK:\n-                \/* There should only be only IPv4 loopback address *\/\n-                if (lo > 0) {\n-                    continue;\n-                }\n-                strncpy_s(dev_name, 8, \"lo\", _TRUNCATE);\n-                lo++;\n-                break;\n-\n-            case MIB_IF_TYPE_PPP:\n-                _snprintf_s(dev_name, 8, _TRUNCATE, \"ppp%d\", ppp++);\n-                break;\n-\n-            case MIB_IF_TYPE_SLIP:\n-                _snprintf_s(dev_name, 8, _TRUNCATE, \"sl%d\", sl++);\n-                break;\n-\n-            case IF_TYPE_IEEE80211:\n-                _snprintf_s(dev_name, 8, _TRUNCATE, \"wlan%d\", wlan++);\n-                break;\n-\n-            default:\n-                _snprintf_s(dev_name, 8, _TRUNCATE, \"net%d\", net++);\n-        }\n-\n-        \/*\n-         * Allocate a netif structure and space for the name and\n-         * display name (description in this case).\n-         *\/\n-        curr = (netif *)calloc(1, sizeof(netif));\n-        if (curr != NULL) {\n-            wlen = MultiByteToWideChar(CP_OEMCP, 0, ifrowP->bDescr,\n-                       ifrowP->dwDescrLen, NULL, 0);\n-            if(wlen == 0) {\n-                \/\/ MultiByteToWideChar should not fail\n-                \/\/ But in rare case it fails, we allow 'char' to be displayed\n-                curr->displayName = (char *)malloc(ifrowP->dwDescrLen + 1);\n-            } else {\n-                curr->displayName = (wchar_t *)malloc((wlen+1)*sizeof(wchar_t));\n-            }\n-\n-            curr->name = (char *)malloc(strlen(dev_name) + 1);\n-\n-            if (curr->name == NULL || curr->displayName == NULL) {\n-                if (curr->name) free(curr->name);\n-                if (curr->displayName) free(curr->displayName);\n-                free(curr);\n-                curr = NULL;\n-            }\n-        }\n-        if (curr == NULL) {\n-            JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failure\");\n-            free_netif(netifP);\n-            free(tableP);\n-            return -1;\n-        }\n-\n-        \/*\n-         * Populate the interface. Note that we need to convert the\n-         * index into its \"friendly\" value as otherwise we will expose\n-         * 32-bit numbers as index values.\n-         *\/\n-        strcpy(curr->name, dev_name);\n-        if (wlen == 0) {\n-            \/\/ display char type in case of MultiByteToWideChar failure\n-            strncpy(curr->displayName, ifrowP->bDescr, ifrowP->dwDescrLen);\n-            curr->displayName[ifrowP->dwDescrLen] = '\\0';\n-        } else {\n-            \/\/ call MultiByteToWideChar again to fill curr->displayName\n-            \/\/ it should not fail, because we have called it once before\n-            if (MultiByteToWideChar(CP_OEMCP, 0, ifrowP->bDescr,\n-                   ifrowP->dwDescrLen, curr->displayName, wlen) == 0) {\n-                JNU_ThrowInternalError(env,\n-                    \"Cannot get multibyte char for interface display name\");\n-                free_netif(netifP);\n-                free(tableP);\n-                free(curr->name);\n-                free(curr->displayName);\n-                free(curr);\n-                return -1;\n-            } else {\n-                ((wchar_t *)curr->displayName)[wlen] = L'\\0';\n-                curr->dNameIsUnicode = TRUE;\n-            }\n-        }\n-\n-        curr->dwIndex = ifrowP->dwIndex;\n-        curr->ifType = ifrowP->dwType;\n-        curr->index = GetFriendlyIfIndex(ifrowP->dwIndex);\n-\n-        \/*\n-         * Put the interface at tail of list as GetIfTable(,,TRUE) is\n-         * returning the interfaces in index order.\n-         *\/\n-        count++;\n-        if (netifP == NULL) {\n-            netifP = curr;\n-        } else {\n-            netif *tail = netifP;\n-            while (tail->next != NULL) {\n-                tail = tail->next;\n+    \/\/ set the NetworkInterface's index\n+    (*env)->SetIntField(env, netifObj, ni_indexID, ifRow->InterfaceIndex);\n+\n+    \/\/ find addresses associated with this interface\n+    for (i = 0; i < uniAddrs->NumEntries; i++) {\n+        if (uniAddrs->Table[i].InterfaceLuid.Value == ifRow->InterfaceLuid.Value &&\n+                (uniAddrs->Table[i].DadState == IpDadStatePreferred ||\n+                        uniAddrs->Table[i].DadState == IpDadStateDeprecated)) {\n+            addrCount++;\n+            addrsCurrent = malloc(sizeof(netaddr));\n+            if (addrsCurrent == NULL) {\n+                freeNetaddrs(addrsHead);\n+                JNU_ThrowOutOfMemoryError(env, \"native heap\");\n+                return NULL;\n@@ -351,66 +165,4 @@\n-            tail->next = curr;\n-        }\n-\n-        \/* onto the next interface *\/\n-        ifrowP++;\n-    }\n-\n-    \/*\n-     * Free the interface table and return the interface list\n-     *\/\n-    if (tableP != NULL) {\n-        free(tableP);\n-    }\n-    *netifPP = netifP;\n-    return count;\n-}\n-\n-\/*\n- * Enumerate all addresses using the IP helper library\n- *\/\n-int lookupIPAddrTable(JNIEnv *env, MIB_IPADDRTABLE **tablePP)\n-{\n-    MIB_IPADDRTABLE *tableP;\n-    ULONG size;\n-    DWORD ret;\n-\n-    *tablePP = NULL;\n-\n-    \/*\n-     * Use GetIpAddrTable to enumerate the IP Addresses\n-     *\/\n-    size = sizeof(MIB_IPADDRTABLE);\n-    tableP = (MIB_IPADDRTABLE *)malloc(size);\n-    if (tableP == NULL) {\n-        JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failure\");\n-        return -1;\n-    }\n-\n-    ret = GetIpAddrTable(tableP, &size, FALSE);\n-    if (ret == ERROR_INSUFFICIENT_BUFFER) {\n-        MIB_IPADDRTABLE * newTableP = (MIB_IPADDRTABLE *)realloc(tableP, size);\n-        if (newTableP == NULL) {\n-            free(tableP);\n-            JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failure\");\n-            return -1;\n-        }\n-        tableP = newTableP;\n-\n-        ret = GetIpAddrTable(tableP, &size, FALSE);\n-    }\n-    if (ret != NO_ERROR) {\n-        if (tableP != NULL) {\n-            free(tableP);\n-        }\n-        switch (ret) {\n-            case ERROR_INVALID_PARAMETER:\n-                JNU_ThrowInternalError(env,\n-                    \"IP Helper Library GetIpAddrTable function failed: \"\n-                    \"invalid parameter\");\n-                break;\n-            default:\n-                SetLastError(ret);\n-                JNU_ThrowByNameWithMessageAndLastError(env,\n-                    JNU_JAVANETPKG \"SocketException\",\n-                    \"IP Helper Library GetIpAddrTable function failed\");\n-                break;\n+            addrsCurrent->Address = uniAddrs->Table[i].Address;\n+            addrsCurrent->PrefixLength = uniAddrs->Table[i].OnLinkPrefixLength;\n+            addrsCurrent->Next = addrsHead;\n+            addrsHead = addrsCurrent;\n@@ -418,3 +170,0 @@\n-        \/\/ this different error code is to handle the case when we call\n-        \/\/ GetIpAddrTable in pure IPv6 environment\n-        return -2;\n@@ -422,80 +171,8 @@\n-    *tablePP = tableP;\n-    return 0;\n-}\n-\n-\/*\n- * Enumerate the IP addresses on an interface, given an IP address table\n- * and matching based on index.\n- *\n- * Returns the count of addresses, or -1 if error. If no error occurs then\n- * netaddrPP will return a list of netaddr structures with the IP addresses.\n- *\/\n-int enumAddresses_win_ipaddrtable(JNIEnv *env, netif *netifP, netaddr **netaddrPP, MIB_IPADDRTABLE *tableP)\n-{\n-    DWORD i;\n-    netaddr *netaddrP;\n-    int count = 0;\n-    unsigned long mask;\n-\n-    *netaddrPP = NULL;\n-\n-    \/*\n-     * Iterate through the table to find the addresses with the\n-     * matching dwIndex. Ignore 0.0.0.0 addresses.\n-     *\/\n-    if (tableP == NULL) {\n-        return 0;\n-    }\n-    count = 0;\n-    netaddrP = NULL;\n-\n-    i = 0;\n-    while (i < tableP->dwNumEntries) {\n-        if (tableP->table[i].dwIndex == netifP->dwIndex &&\n-            tableP->table[i].dwAddr != 0) {\n-\n-            netaddr *curr = (netaddr *)malloc(sizeof(netaddr));\n-            if (curr == NULL) {\n-                JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failure\");\n-                free_netaddr(netaddrP);\n-                return -1;\n-            }\n-\n-            curr->addr.sa4.sin_family = AF_INET;\n-            curr->addr.sa4.sin_addr.s_addr = tableP->table[i].dwAddr;\n-            \/*\n-             * Get netmask \/ broadcast address\n-             *\/\n-            switch (netifP->ifType) {\n-            case MIB_IF_TYPE_ETHERNET:\n-            case MIB_IF_TYPE_TOKENRING:\n-            case MIB_IF_TYPE_FDDI:\n-            case MIB_IF_TYPE_LOOPBACK:\n-            case IF_TYPE_IEEE80211:\n-                \/**\n-                 * Contrary to what it seems to indicate, dwBCastAddr doesn't\n-                 * contain the broadcast address but 0 or 1 depending on whether\n-                 * the broadcast address should set the bits of the host part\n-                 * to 0 or 1.\n-                 * Yes, I know it's stupid, but what can I say, it's MSFTs API.\n-                 *\/\n-                curr->brdcast.sa4.sin_family = AF_INET;\n-                if (tableP->table[i].dwBCastAddr == 1)\n-                    curr->brdcast.sa4.sin_addr.s_addr = (tableP->table[i].dwAddr & tableP->table[i].dwMask) | (0xffffffff ^ tableP->table[i].dwMask);\n-                else\n-                    curr->brdcast.sa4.sin_addr.s_addr = (tableP->table[i].dwAddr & tableP->table[i].dwMask);\n-                mask = ntohl(tableP->table[i].dwMask);\n-                curr->mask = 0;\n-                while (mask) {\n-                    mask <<= 1;\n-                    curr->mask++;\n-                }\n-                break;\n-            case MIB_IF_TYPE_PPP:\n-            case MIB_IF_TYPE_SLIP:\n-            default:\n-                \/**\n-                 * these don't have broadcast\/subnet\n-                 *\/\n-                curr->mask = -1;\n-                    break;\n+    for (i = 0; i < anyAddrs->NumEntries; i++) {\n+        if (anyAddrs->Table[i].InterfaceLuid.Value == ifRow->InterfaceLuid.Value) {\n+            addrCount++;\n+            addrsCurrent = malloc(sizeof(netaddr));\n+            if (addrsCurrent == NULL) {\n+                freeNetaddrs(addrsHead);\n+                JNU_ThrowOutOfMemoryError(env, \"native heap\");\n+                return NULL;\n@@ -503,4 +180,4 @@\n-\n-            curr->next = netaddrP;\n-            netaddrP = curr;\n-            count++;\n+            addrsCurrent->Address = anyAddrs->Table[i].Address;\n+            addrsCurrent->PrefixLength = NO_PREFIX;\n+            addrsCurrent->Next = addrsHead;\n+            addrsHead = addrsCurrent;\n@@ -508,101 +185,0 @@\n-        i++;\n-    }\n-\n-    *netaddrPP = netaddrP;\n-    return count;\n-}\n-\n-\n-\/*\n- * Enumerate the IP addresses on an interface, using an IP address table\n- * retrieved using GetIPAddrTable and matching based on index.\n- *\n- * Returns the count of addresses, or -1 if error. If no error occurs then\n- * netaddrPP will return a list of netaddr structures with the IP addresses.\n- *\/\n-int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP) {\n-    MIB_IPADDRTABLE *tableP;\n-    int count;\n-\n-    *netaddrPP = NULL;\n-\n-    int ret = lookupIPAddrTable(env, &tableP);\n-    if (ret < 0) {\n-      return ret;\n-    }\n-    count = enumAddresses_win_ipaddrtable(env, netifP, netaddrPP, tableP);\n-    free(tableP);\n-    return count;\n-}\n-\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_NetworkInterface_init(JNIEnv *env, jclass cls)\n-{\n-    \/*\n-     * Get the various JNI ids that we require\n-     *\/\n-    ni_class = (*env)->NewGlobalRef(env, cls);\n-    CHECK_NULL(ni_class);\n-    ni_nameID = (*env)->GetFieldID(env, ni_class, \"name\", \"Ljava\/lang\/String;\");\n-    CHECK_NULL(ni_nameID);\n-    ni_displayNameID = (*env)->GetFieldID(env, ni_class, \"displayName\", \"Ljava\/lang\/String;\");\n-    CHECK_NULL(ni_displayNameID);\n-    ni_indexID = (*env)->GetFieldID(env, ni_class, \"index\", \"I\");\n-    CHECK_NULL(ni_indexID);\n-    ni_addrsID = (*env)->GetFieldID(env, ni_class, \"addrs\", \"[Ljava\/net\/InetAddress;\");\n-    CHECK_NULL(ni_addrsID);\n-    ni_bindsID = (*env)->GetFieldID(env, ni_class, \"bindings\", \"[Ljava\/net\/InterfaceAddress;\");\n-    CHECK_NULL(ni_bindsID);\n-    ni_childsID = (*env)->GetFieldID(env, ni_class, \"childs\", \"[Ljava\/net\/NetworkInterface;\");\n-    CHECK_NULL(ni_childsID);\n-    ni_ctor = (*env)->GetMethodID(env, ni_class, \"<init>\", \"()V\");\n-    CHECK_NULL(ni_ctor);\n-    ni_ibcls = (*env)->FindClass(env, \"java\/net\/InterfaceAddress\");\n-    CHECK_NULL(ni_ibcls);\n-    ni_ibcls = (*env)->NewGlobalRef(env, ni_ibcls);\n-    CHECK_NULL(ni_ibcls);\n-    ni_ibctrID = (*env)->GetMethodID(env, ni_ibcls, \"<init>\", \"()V\");\n-    CHECK_NULL(ni_ibctrID);\n-    ni_ibaddressID = (*env)->GetFieldID(env, ni_ibcls, \"address\", \"Ljava\/net\/InetAddress;\");\n-    CHECK_NULL(ni_ibaddressID);\n-    ni_ibbroadcastID = (*env)->GetFieldID(env, ni_ibcls, \"broadcast\", \"Ljava\/net\/Inet4Address;\");\n-    CHECK_NULL(ni_ibbroadcastID);\n-    ni_ibmaskID = (*env)->GetFieldID(env, ni_ibcls, \"maskLength\", \"S\");\n-    CHECK_NULL(ni_ibmaskID);\n-\n-    initInetAddressIDs(env);\n-}\n-\n-\/*\n- * Create a NetworkInterface object, populate the name and index, and\n- * populate the InetAddress array based on the IP addresses for this\n- * interface.\n- *\/\n-jobject createNetworkInterface\n-    (JNIEnv *env, netif *ifs, int netaddrCount, netaddr *netaddrP)\n-{\n-    jobject netifObj;\n-    jobject name, displayName;\n-    jobjectArray addrArr, bindsArr, childArr;\n-    netaddr *addrs;\n-    jint addr_index;\n-    jint bind_index;\n-\n-    \/*\n-     * Create a NetworkInterface object and populate it\n-     *\/\n-    netifObj = (*env)->NewObject(env, ni_class, ni_ctor);\n-    CHECK_NULL_RETURN(netifObj, NULL);\n-    name = (*env)->NewStringUTF(env, ifs->name);\n-    CHECK_NULL_RETURN(name, NULL);\n-    if (ifs->dNameIsUnicode) {\n-        displayName = (*env)->NewString(env, (PWCHAR)ifs->displayName,\n-                                       (jsize)wcslen ((PWCHAR)ifs->displayName));\n-    } else {\n-        displayName = (*env)->NewStringUTF(env, ifs->displayName);\n@@ -610,4 +186,0 @@\n-    CHECK_NULL_RETURN(displayName, NULL);\n-    (*env)->SetObjectField(env, netifObj, ni_nameID, name);\n-    (*env)->SetObjectField(env, netifObj, ni_displayNameID, displayName);\n-    (*env)->SetIntField(env, netifObj, ni_indexID, ifs->index);\n@@ -615,11 +187,2 @@\n-    \/*\n-     * Get the IP addresses for this interface if necessary\n-     * Note that 0 is a valid number of addresses.\n-     *\/\n-    if (netaddrCount < 0) {\n-        netaddrCount = enumAddresses_win(env, ifs, &netaddrP);\n-        if (netaddrCount < 0) {\n-            return NULL;\n-        }\n-    }\n-    addrArr = (*env)->NewObjectArray(env, netaddrCount, ia_class, NULL);\n+    \/\/ instantiate the addrs and bindings array\n+    addrArr = (*env)->NewObjectArray(env, addrCount, ia_class, NULL);\n@@ -627,1 +190,1 @@\n-        free_netaddr(netaddrP);\n+        freeNetaddrs(addrsHead);\n@@ -630,2 +193,1 @@\n-\n-    bindsArr = (*env)->NewObjectArray(env, netaddrCount, ni_ibcls, NULL);\n+    bindsArr = (*env)->NewObjectArray(env, addrCount, ni_ibcls, NULL);\n@@ -633,2 +195,2 @@\n-      free_netaddr(netaddrP);\n-      return NULL;\n+        freeNetaddrs(addrsHead);\n+        return NULL;\n@@ -636,10 +198,9 @@\n-    addrs = netaddrP;\n-    addr_index = 0;\n-    bind_index = 0;\n-    while (addrs != NULL) {\n-        jobject iaObj, ia2Obj;\n-        jobject ibObj = NULL;\n-        if (addrs->addr.sa.sa_family == AF_INET) {\n-            iaObj = (*env)->NewObject(env, ia4_class, ia4_ctrID);\n-            if (iaObj == NULL) {\n-                free_netaddr(netaddrP);\n+\n+    \/\/ populate the addrs and bindings arrays\n+    i = 0;\n+    while (addrsCurrent != NULL) {\n+        if (addrsCurrent->Address.si_family == AF_INET) { \/\/ IPv4\n+            \/\/ create and populate InetAddress object\n+            inetAddr = (*env)->NewObject(env, ia4_class, ia4_ctrID);\n+            if (inetAddr == NULL) {\n+                freeNetaddrs(addrsHead);\n@@ -648,3 +209,2 @@\n-            \/* default ctor will set family to AF_INET *\/\n-\n-            setInetAddress_addr(env, iaObj, ntohl(addrs->addr.sa4.sin_addr.s_addr));\n+            setInetAddress_addr(\n+                    env, inetAddr, ntohl(addrsCurrent->Address.Ipv4.sin_addr.s_addr));\n@@ -652,1 +212,1 @@\n-                free_netaddr(netaddrP);\n+                freeNetaddrs(addrsHead);\n@@ -655,10 +215,5 @@\n-            if (addrs->mask != -1) {\n-              ibObj = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);\n-              if (ibObj == NULL) {\n-                free_netaddr(netaddrP);\n-                return NULL;\n-              }\n-              (*env)->SetObjectField(env, ibObj, ni_ibaddressID, iaObj);\n-              ia2Obj = (*env)->NewObject(env, ia4_class, ia4_ctrID);\n-              if (ia2Obj == NULL) {\n-                free_netaddr(netaddrP);\n+\n+            \/\/ create and populate InterfaceAddress object\n+            bindAddr = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);\n+            if (bindAddr == NULL) {\n+                freeNetaddrs(addrsHead);\n@@ -666,11 +221,0 @@\n-              }\n-              setInetAddress_addr(env, ia2Obj, ntohl(addrs->brdcast.sa4.sin_addr.s_addr));\n-              if ((*env)->ExceptionCheck(env)) {\n-                  free_netaddr(netaddrP);\n-                  return NULL;\n-              }\n-              (*env)->SetObjectField(env, ibObj, ni_ibbroadcastID, ia2Obj);\n-              (*env)->DeleteLocalRef(env, ia2Obj);\n-              (*env)->SetShortField(env, ibObj, ni_ibmaskID, addrs->mask);\n-              (*env)->SetObjectArrayElement(env, bindsArr, bind_index++, ibObj);\n-              (*env)->DeleteLocalRef(env, ibObj);\n@@ -678,7 +222,11 @@\n-        } else \/* AF_INET6 *\/ {\n-            int scope;\n-            iaObj = (*env)->NewObject(env, ia6_class, ia6_ctrID);\n-            if (iaObj) {\n-                jboolean ret = setInet6Address_ipaddress(env, iaObj,  (jbyte *)&(addrs->addr.sa6.sin6_addr.s6_addr));\n-                if (ret == JNI_FALSE) {\n-                    free_netaddr(netaddrP);\n+            (*env)->SetObjectField(env, bindAddr, ni_ibaddressID, inetAddr);\n+            if (addrsCurrent->PrefixLength != NO_PREFIX) {\n+                (*env)->SetShortField(\n+                        env, bindAddr, ni_ibmaskID, addrsCurrent->PrefixLength);\n+                apiRetVal = ConvertLengthToIpv4Mask(addrsCurrent->PrefixLength, &mask);\n+                if (apiRetVal != NO_ERROR) {\n+                    freeNetaddrs(addrsHead);\n+                    SetLastError(apiRetVal);\n+                    NET_ThrowByNameWithLastError(\n+                            env, JNU_JAVANETPKG \"SocketException\",\n+                            \"ConvertLengthToIpv4Mask\");\n@@ -687,5 +235,4 @@\n-\n-                scope = addrs->addr.sa6.sin6_scope_id;\n-                if (scope != 0) { \/* zero is default value, no need to set *\/\n-                    setInet6Address_scopeid(env, iaObj, scope);\n-                    setInet6Address_scopeifname(env, iaObj, netifObj);\n+                bcastAddr = (*env)->NewObject(env, ia4_class, ia4_ctrID);\n+                if (bcastAddr == NULL) {\n+                    freeNetaddrs(addrsHead);\n+                    return NULL;\n@@ -693,4 +240,6 @@\n-                ibObj = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);\n-                if (ibObj == NULL) {\n-                  free_netaddr(netaddrP);\n-                  return NULL;\n+                setInetAddress_addr(\n+                        env, bcastAddr,\n+                        ntohl(addrsCurrent->Address.Ipv4.sin_addr.s_addr | ~mask));\n+                if ((*env)->ExceptionCheck(env)) {\n+                    freeNetaddrs(addrsHead);\n+                    return NULL;\n@@ -698,4 +247,31 @@\n-                (*env)->SetObjectField(env, ibObj, ni_ibaddressID, iaObj);\n-                (*env)->SetShortField(env, ibObj, ni_ibmaskID, addrs->mask);\n-                (*env)->SetObjectArrayElement(env, bindsArr, bind_index++, ibObj);\n-                (*env)->DeleteLocalRef(env, ibObj);\n+                (*env)->SetObjectField(env, bindAddr, ni_ibbroadcastID, bcastAddr);\n+                (*env)->DeleteLocalRef(env, bcastAddr);\n+            }\n+        } else { \/\/ IPv6\n+            inetAddr = (*env)->NewObject(env, ia6_class, ia6_ctrID);\n+            if (inetAddr == NULL) {\n+                freeNetaddrs(addrsHead);\n+                return NULL;\n+            }\n+            if (setInet6Address_ipaddress(\n+                    env, inetAddr,\n+                    (jbyte *)&(addrsCurrent->Address.Ipv6.sin6_addr.s6_addr))\n+                    == JNI_FALSE) {\n+                freeNetaddrs(addrsHead);\n+                return NULL;\n+            }\n+            \/* zero is default value, no need to set *\/\n+            if (addrsCurrent->Address.Ipv6.sin6_scope_id != 0) {\n+                setInet6Address_scopeid(\n+                        env, inetAddr, addrsCurrent->Address.Ipv6.sin6_scope_id);\n+                setInet6Address_scopeifname(env, inetAddr, netifObj);\n+            }\n+            bindAddr = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);\n+            if (bindAddr == NULL) {\n+                freeNetaddrs(addrsHead);\n+                return NULL;\n+            }\n+            (*env)->SetObjectField(env, bindAddr, ni_ibaddressID, inetAddr);\n+            if (addrsCurrent->PrefixLength != NO_PREFIX) {\n+                (*env)->SetShortField(\n+                        env, bindAddr, ni_ibmaskID, addrsCurrent->PrefixLength);\n@@ -704,4 +280,10 @@\n-        (*env)->SetObjectArrayElement(env, addrArr, addr_index, iaObj);\n-        (*env)->DeleteLocalRef(env, iaObj);\n-        addrs = addrs->next;\n-        addr_index++;\n+\n+        \/\/ add the new elements to the arrays\n+        (*env)->SetObjectArrayElement(env, addrArr, i, inetAddr);\n+        (*env)->DeleteLocalRef(env, inetAddr);\n+        (*env)->SetObjectArrayElement(env, bindsArr, i, bindAddr);\n+        (*env)->DeleteLocalRef(env, bindAddr);\n+\n+        \/\/ advance to the next address\n+        addrsCurrent = addrsCurrent->Next;\n+        i++;\n@@ -709,2 +291,0 @@\n-    (*env)->SetObjectField(env, netifObj, ni_addrsID, addrArr);\n-    (*env)->SetObjectField(env, netifObj, ni_bindsID, bindsArr);\n@@ -712,3 +292,5 @@\n-    free_netaddr(netaddrP);\n-    (*env)->DeleteLocalRef(env, name);\n-    (*env)->DeleteLocalRef(env, displayName);\n+    \/\/ free the address list since we no longer need it\n+    freeNetaddrs(addrsHead);\n+\n+    \/\/ set the addrs and bindings arrays on the NetworkInterface\n+    (*env)->SetObjectField(env, netifObj, ni_addrsID, addrArr);\n@@ -716,0 +298,1 @@\n+    (*env)->SetObjectField(env, netifObj, ni_bindsID, bindsArr);\n@@ -718,4 +301,2 @@\n-    \/*\n-     * Windows doesn't have virtual interfaces, so child array\n-     * is always empty.\n-     *\/\n+    \/\/ set child array on the NetworkInterface\n+    \/\/ Windows doesn't have virtual interfaces, so this is always empty\n@@ -724,1 +305,1 @@\n-      return NULL;\n+        return NULL;\n@@ -729,1 +310,0 @@\n-    \/* return the NetworkInterface *\/\n@@ -734,3 +314,6 @@\n- * Class:     java_net_NetworkInterface\n- * Method:    getByName0\n- * Signature: (Ljava\/lang\/String;)Ljava\/net\/NetworkInterface;\n+ * Builds and returns a java.net.NetworkInterface object from the given MIB_IF_ROW2.\n+ * This expects that the row is not yet populated, but an index has been set,\n+ * so the row is ready to be populated by GetIfEntry2.\n+ * If anything goes wrong, an exception will be set,\n+ * but the address tables are not freed.\n+ * Freeing the address tables is always the caller's responsibility.\n@@ -738,15 +321,12 @@\n-JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByName0\n-    (JNIEnv *env, jclass cls, jstring name)\n-{\n-    netif *ifList, *curr;\n-    jboolean isCopy;\n-    const char *name_utf;\n-    jobject netifObj = NULL;\n-\n-    \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-    if (ipv6_available()) {\n-        return Java_java_net_NetworkInterface_getByName0_XP (env, cls, name);\n-    }\n-\n-    \/* get the list of interfaces *\/\n-    if (enumInterfaces(env, &ifList) < 0) {\n+static jobject createNetworkInterfaceForSingleRowWithTables(\n+        JNIEnv *env, MIB_IF_ROW2 *ifRow,\n+        MIB_UNICASTIPADDRESS_TABLE *uniAddrs, MIB_ANYCASTIPADDRESS_TABLE *anyAddrs) {\n+    ULONG apiRetVal;\n+\n+    apiRetVal = GetIfEntry2(ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        if (apiRetVal != ERROR_FILE_NOT_FOUND) {\n+            SetLastError(apiRetVal);\n+            NET_ThrowByNameWithLastError(\n+                    env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n+        }\n@@ -755,0 +335,2 @@\n+    return createNetworkInterface(env, ifRow, uniAddrs, anyAddrs);\n+}\n@@ -756,17 +338,13 @@\n-    \/* get the name as a C string *\/\n-    name_utf = (*env)->GetStringUTFChars(env, name, &isCopy);\n-    if (name_utf != NULL) {\n-\n-        \/* Search by name *\/\n-        curr = ifList;\n-        while (curr != NULL) {\n-            if (strcmp(name_utf, curr->name) == 0) {\n-                break;\n-            }\n-            curr = curr->next;\n-        }\n-\n-        \/* if found create a NetworkInterface *\/\n-        if (curr != NULL) {;\n-            netifObj = createNetworkInterface(env, curr, -1, NULL);\n-        }\n+\/*\n+ * Builds and returns a java.net.NetworkInterface object from the given MIB_IF_ROW2.\n+ * This expects that the row is not yet populated, but an index has been set,\n+ * so the row is ready to be populated by GetIfEntry2.\n+ * Unlike createNetworkInterfaceForSingleRowWithTables, this will get the address\n+ * tables at the beginning and free them at the end.\n+ * If anything goes wrong, an exception will be set.\n+ *\/\n+static jobject createNetworkInterfaceForSingleRow(\n+        JNIEnv *env, MIB_IF_ROW2 *ifRow) {\n+    MIB_UNICASTIPADDRESS_TABLE *uniAddrs;\n+    MIB_ANYCASTIPADDRESS_TABLE *anyAddrs;\n+    jobject netifObj;\n@@ -774,5 +352,2 @@\n-        \/* release the UTF string *\/\n-        (*env)->ReleaseStringUTFChars(env, name, name_utf);\n-    } else {\n-        if (!(*env)->ExceptionCheck(env))\n-            JNU_ThrowOutOfMemoryError(env, NULL);\n+    if (getAddressTables(env, &uniAddrs, &anyAddrs) == FALSE) {\n+        return NULL;\n@@ -781,2 +356,5 @@\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n+    netifObj = createNetworkInterfaceForSingleRowWithTables(\n+            env, ifRow, uniAddrs, anyAddrs);\n+\n+    FreeMibTable(uniAddrs);\n+    FreeMibTable(anyAddrs);\n@@ -792,10 +370,3 @@\n-JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByIndex0\n-  (JNIEnv *env, jclass cls, jint index)\n-{\n-    netif *ifList, *curr;\n-    jobject netifObj = NULL;\n-\n-    \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-    if (ipv6_available()) {\n-        return Java_java_net_NetworkInterface_getByIndex0_XP (env, cls, index);\n-    }\n+JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByIndex0(\n+        JNIEnv *env, jclass cls, jint index) {\n+    MIB_IF_ROW2 ifRow = {0};\n@@ -803,2 +374,2 @@\n-    \/* get the list of interfaces *\/\n-    if (enumInterfaces(env, &ifList) < 0) {\n+    if (index == 0) {\n+        \/\/ 0 is never a valid index, and would make GetIfEntry2 think nothing is set\n@@ -808,18 +379,2 @@\n-    \/* search by index *\/\n-    curr = ifList;\n-    while (curr != NULL) {\n-        if (index == curr->index) {\n-            break;\n-        }\n-        curr = curr->next;\n-    }\n-\n-    \/* if found create a NetworkInterface *\/\n-    if (curr != NULL) {\n-        netifObj = createNetworkInterface(env, curr, -1, NULL);\n-    }\n-\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n-\n-    return netifObj;\n+    ifRow.InterfaceIndex = index;\n+    return createNetworkInterfaceForSingleRow(env, &ifRow);\n@@ -828,1 +383,0 @@\n-\n@@ -831,2 +385,2 @@\n- * Method:    boundInetAddress0\n- * Signature: (Ljava\/net\/InetAddress;)Z\n+ * Method:    getByName0\n+ * Signature: (Ljava\/lang\/String;)Ljava\/net\/NetworkInterface;\n@@ -834,27 +388,15 @@\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_boundInetAddress0\n-    (JNIEnv *env, jclass cls, jobject iaObj)\n-{\n-    DWORD i;\n-\n-    int family = getInetAddress_family(env, iaObj);\n-    JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);\n-\n-    if (family == java_net_InetAddress_IPv6) {\n-        if (!ipv6_available())\n-            return JNI_FALSE;\n-        return Java_java_net_NetworkInterface_getByInetAddress0_XP(env, cls, iaObj) != NULL;\n-    } else if (family == java_net_InetAddress_IPv4) {\n-        jint addr = getInetAddress_addr(env, iaObj);\n-        JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);\n-\n-        jboolean found = JNI_FALSE;\n-        MIB_IPADDRTABLE *tableP;\n-        if (lookupIPAddrTable(env, &tableP) >= 0 && tableP != NULL) {\n-            for (i = 0; i < tableP->dwNumEntries; i++) {\n-                if (tableP->table[i].dwAddr != 0 &&\n-                    (unsigned long)addr == ntohl(tableP->table[i].dwAddr)) {\n-                    found = JNI_TRUE;\n-                    break;\n-                }\n-            }\n-            free(tableP);\n+JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByName0(\n+        JNIEnv *env, jclass cls, jstring name) {\n+    const jchar *nameChars;\n+    ULONG apiRetVal;\n+    MIB_IF_ROW2 ifRow = {0};\n+\n+    nameChars = (*env)->GetStringChars(env, name, NULL);\n+    apiRetVal = ConvertInterfaceNameToLuidW(nameChars, &(ifRow.InterfaceLuid));\n+    (*env)->ReleaseStringChars(env, name, nameChars);\n+    if (apiRetVal != ERROR_SUCCESS) {\n+        if (apiRetVal != ERROR_INVALID_NAME) {\n+            SetLastError(apiRetVal);\n+            NET_ThrowByNameWithLastError(\n+                    env, JNU_JAVANETPKG \"SocketException\",\n+                    \"ConvertInterfaceNameToLuidW\");\n@@ -862,4 +404,1 @@\n-        return found;\n-    } else {\n-      \/\/ Unknown address family\n-      return JNI_FALSE;\n+        return NULL;\n@@ -867,0 +406,1 @@\n+    return createNetworkInterfaceForSingleRow(env, &ifRow);\n@@ -874,15 +414,9 @@\n-JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0\n-    (JNIEnv *env, jclass cls, jobject iaObj)\n-{\n-    netif *ifList, *curr;\n-    MIB_IPADDRTABLE *tableP;\n-    jobject netifObj = NULL;\n-    jint addr = getInetAddress_addr(env, iaObj);\n-    JNU_CHECK_EXCEPTION_RETURN(env, NULL);\n-\n-    if (ipv6_available()) {\n-        return Java_java_net_NetworkInterface_getByInetAddress0_XP (env, cls, iaObj);\n-    }\n-\n-    \/* get the list of interfaces *\/\n-    if (enumInterfaces(env, &ifList) < 0) {\n+JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0(\n+        JNIEnv *env, jclass cls, jobject inetAddr) {\n+    MIB_UNICASTIPADDRESS_TABLE *uniAddrs;\n+    MIB_ANYCASTIPADDRESS_TABLE *anyAddrs;\n+    ULONG i;\n+    MIB_IF_ROW2 ifRow = {0};\n+    jobject result = NULL;\n+\n+    if (getAddressTables(env, &uniAddrs, &anyAddrs) == FALSE) {\n@@ -892,29 +426,20 @@\n-    \/*\n-     * Enumerate the addresses on each interface until we find a\n-     * matching address.\n-     *\/\n-    tableP = NULL;\n-    if (lookupIPAddrTable(env, &tableP) >= 0) {\n-        curr = ifList;\n-        while (curr != NULL) {\n-            int count;\n-            netaddr *addrList;\n-            netaddr *addrP;\n-\n-            \/* enumerate the addresses on this interface *\/\n-            count = enumAddresses_win_ipaddrtable(env, curr, &addrList, tableP);\n-            if (count < 0) {\n-                free_netif(ifList);\n-                free(tableP);\n-                return NULL;\n-            }\n-\n-            \/* iterate through each address *\/\n-            addrP = addrList;\n-\n-            while (addrP != NULL) {\n-                if ((unsigned long)addr == ntohl(addrP->addr.sa4.sin_addr.s_addr)) {\n-                    break;\n-                }\n-                addrP = addrP->next;\n-            }\n+    for (i = 0; i < uniAddrs->NumEntries; i++) {\n+        if (NET_SockaddrEqualsInetAddress(\n+                env, (SOCKETADDRESS*) &(uniAddrs->Table[i].Address), inetAddr) &&\n+                (uniAddrs->Table[i].DadState == IpDadStatePreferred ||\n+                        uniAddrs->Table[i].DadState == IpDadStateDeprecated)) {\n+            ifRow.InterfaceLuid = uniAddrs->Table[i].InterfaceLuid;\n+            result = createNetworkInterfaceForSingleRowWithTables(\n+                    env, &ifRow, uniAddrs, anyAddrs);\n+            goto done;\n+        }\n+    }\n+    for (i = 0; i < anyAddrs->NumEntries; i++) {\n+        if (NET_SockaddrEqualsInetAddress(\n+                env, (SOCKETADDRESS*) &(anyAddrs->Table[i].Address), inetAddr)) {\n+            ifRow.InterfaceLuid = anyAddrs->Table[i].InterfaceLuid;\n+            result = createNetworkInterfaceForSingleRowWithTables(\n+                    env, &ifRow, uniAddrs, anyAddrs);\n+            goto done;\n+        }\n+    }\n@@ -922,11 +447,5 @@\n-            \/*\n-             * Address matched so create NetworkInterface for this interface\n-             * and address list.\n-             *\/\n-            if (addrP != NULL) {\n-                \/* createNetworkInterface will free addrList *\/\n-                netifObj = createNetworkInterface(env, curr, count, addrList);\n-                break;\n-            } else {\n-                free_netaddr(addrList);\n-            }\n+    done:\n+    FreeMibTable(uniAddrs);\n+    FreeMibTable(anyAddrs);\n+    return result;\n+}\n@@ -934,2 +453,30 @@\n-            \/* on next interface *\/\n-            curr = curr->next;\n+\/*\n+ * Class:     java_net_NetworkInterface\n+ * Method:    boundInetAddress0\n+ * Signature: (Ljava\/net\/InetAddress;)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_boundInetAddress0(\n+        JNIEnv *env, jclass cls, jobject inetAddr) {\n+    MIB_UNICASTIPADDRESS_TABLE *uniAddrs;\n+    MIB_ANYCASTIPADDRESS_TABLE *anyAddrs;\n+    ULONG i;\n+    jboolean result = JNI_FALSE;\n+\n+    if (getAddressTables(env, &uniAddrs, &anyAddrs) == FALSE) {\n+        return JNI_FALSE;\n+    }\n+\n+    for (i = 0; i < uniAddrs->NumEntries; i++) {\n+        if (NET_SockaddrEqualsInetAddress(\n+                env, (SOCKETADDRESS*) &(uniAddrs->Table[i].Address), inetAddr) &&\n+                (uniAddrs->Table[i].DadState == IpDadStatePreferred ||\n+                        uniAddrs->Table[i].DadState == IpDadStateDeprecated)) {\n+            result = JNI_TRUE;\n+            goto done;\n+        }\n+    }\n+    for (i = 0; i < anyAddrs->NumEntries; i++) {\n+        if (NET_SockaddrEqualsInetAddress(\n+                env, (SOCKETADDRESS*) &(anyAddrs->Table[i].Address), inetAddr)) {\n+            result = JNI_TRUE;\n+            goto done;\n@@ -937,2 +484,0 @@\n-        \/* release the IP address table *\/\n-        free(tableP);\n@@ -941,4 +486,4 @@\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n-\n-    return netifObj;\n+    done:\n+    FreeMibTable(uniAddrs);\n+    FreeMibTable(anyAddrs);\n+    return result;\n@@ -952,11 +497,15 @@\n-JNIEXPORT jobjectArray JNICALL Java_java_net_NetworkInterface_getAll\n-    (JNIEnv *env, jclass cls)\n-{\n-    int count;\n-    netif *ifList, *curr;\n-    jobjectArray netIFArr;\n-    jint arr_index;\n-\n-    \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-    if (ipv6_available()) {\n-        return Java_java_net_NetworkInterface_getAll_XP (env, cls);\n+JNIEXPORT jobjectArray JNICALL Java_java_net_NetworkInterface_getAll(\n+        JNIEnv *env, jclass cls) {\n+    MIB_IF_TABLE2 *ifTable;\n+    jobjectArray ifArray;\n+    MIB_UNICASTIPADDRESS_TABLE *uniAddrs;\n+    MIB_ANYCASTIPADDRESS_TABLE *anyAddrs;\n+    ULONG apiRetVal, i;\n+    jobject ifObj;\n+\n+    apiRetVal = GetIfTable2(&ifTable);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfTable2\");\n+        return NULL;\n@@ -965,5 +514,3 @@\n-    \/*\n-     * Get list of interfaces\n-     *\/\n-    count = enumInterfaces(env, &ifList);\n-    if (count < 0) {\n+    ifArray = (*env)->NewObjectArray(env, ifTable->NumEntries, cls, NULL);\n+    if (ifArray == NULL) {\n+        FreeMibTable(ifTable);\n@@ -973,4 +520,2 @@\n-    \/* allocate a NetworkInterface array *\/\n-    netIFArr = (*env)->NewObjectArray(env, count, cls, NULL);\n-    if (netIFArr == NULL) {\n-        free_netif(ifList);\n+    if (getAddressTables(env, &uniAddrs, &anyAddrs) == FALSE) {\n+        FreeMibTable(ifTable);\n@@ -980,12 +525,7 @@\n-    \/*\n-     * Iterate through the interfaces, create a NetworkInterface instance\n-     * for each array element and populate the object.\n-     *\/\n-    curr = ifList;\n-    arr_index = 0;\n-    while (curr != NULL) {\n-        jobject netifObj;\n-\n-        netifObj = createNetworkInterface(env, curr, -1, NULL);\n-        if (netifObj == NULL) {\n-            free_netif(ifList);\n+    for (i = 0; i < ifTable->NumEntries; i++) {\n+        ifObj = createNetworkInterface(\n+                env, &(ifTable->Table[i]), uniAddrs, anyAddrs);\n+        if (ifObj == NULL) {\n+            FreeMibTable(ifTable);\n+            FreeMibTable(uniAddrs);\n+            FreeMibTable(anyAddrs);\n@@ -994,6 +534,2 @@\n-\n-        \/* put the NetworkInterface into the array *\/\n-        (*env)->SetObjectArrayElement(env, netIFArr, arr_index++, netifObj);\n-        (*env)->DeleteLocalRef(env, netifObj);\n-\n-        curr = curr->next;\n+        (*env)->SetObjectArrayElement(env, ifArray, i, ifObj);\n+        (*env)->DeleteLocalRef(env, ifObj);\n@@ -1002,4 +538,4 @@\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n-\n-    return netIFArr;\n+    FreeMibTable(ifTable);\n+    FreeMibTable(uniAddrs);\n+    FreeMibTable(anyAddrs);\n+    return ifArray;\n@@ -1013,18 +549,16 @@\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isUp0\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-  jboolean ret = JNI_FALSE;\n-\n-  \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-  if (ipv6_available()) {\n-    return Java_java_net_NetworkInterface_isUp0_XP(env, cls, name, index);\n-  } else {\n-    MIB_IFROW *ifRowP;\n-    ifRowP = getIF(index);\n-    if (ifRowP != NULL) {\n-      ret = ifRowP->dwAdminStatus == MIB_IF_ADMIN_STATUS_UP &&\n-            (ifRowP->dwOperStatus == MIB_IF_OPER_STATUS_OPERATIONAL ||\n-             ifRowP->dwOperStatus == MIB_IF_OPER_STATUS_CONNECTED);\n-      free(ifRowP);\n-    }\n-  }\n-    return ret;\n+JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isUp0(\n+        JNIEnv *env, jclass cls, jstring name, jint index) {\n+    MIB_IF_ROW2 ifRow = {0};\n+    ULONG apiRetVal;\n+\n+    ifRow.InterfaceIndex = index;\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n+        return JNI_FALSE;\n+    }\n+    return ifRow.AdminStatus == NET_IF_ADMIN_STATUS_UP &&\n+            ifRow.OperStatus == IfOperStatusUp\n+            ? JNI_TRUE : JNI_FALSE;\n@@ -1038,21 +572,14 @@\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isP2P0\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-  MIB_IFROW *ifRowP;\n-  jboolean ret = JNI_FALSE;\n-\n-  \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-  if (ipv6_available()) {\n-    return Java_java_net_NetworkInterface_isP2P0_XP(env, cls, name, index);\n-  } else {\n-    ifRowP = getIF(index);\n-    if (ifRowP != NULL) {\n-      switch(ifRowP->dwType) {\n-      case MIB_IF_TYPE_PPP:\n-      case MIB_IF_TYPE_SLIP:\n-        ret = JNI_TRUE;\n-        break;\n-      }\n-      free(ifRowP);\n-    }\n-  }\n-  return ret;\n+JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isP2P0(\n+        JNIEnv *env, jclass cls, jstring name, jint index) {\n+    MIB_IF_ROW2 ifRow = {0};\n+    ULONG apiRetVal;\n+\n+    ifRow.InterfaceIndex = index;\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n+        return JNI_FALSE;\n+    }\n+    return ifRow.AccessType == NET_IF_ACCESS_POINT_TO_POINT ? JNI_TRUE : JNI_FALSE;\n@@ -1066,28 +593,14 @@\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isLoopback0\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-  MIB_IFROW *ifRowP;\n-  jboolean ret = JNI_FALSE;\n-\n-  \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-  if (ipv6_available()) {\n-    return Java_java_net_NetworkInterface_isLoopback0_XP(env, cls, name, index);\n-  } else {\n-    ifRowP = getIF(index);\n-    if (ifRowP != NULL) {\n-      if (ifRowP->dwType == MIB_IF_TYPE_LOOPBACK)\n-        ret = JNI_TRUE;\n-      free(ifRowP);\n-    }\n-    return ret;\n-  }\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    supportsMulticast0\n- * Signature: (Ljava\/lang\/String;I)Z\n- *\/\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_supportsMulticast0\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-    return Java_java_net_NetworkInterface_supportsMulticast0_XP(env, cls,\n-                                                               name, index);\n+JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isLoopback0(\n+        JNIEnv *env, jclass cls, jstring name, jint index) {\n+    MIB_IF_ROW2 ifRow = {0};\n+    ULONG apiRetVal;\n+\n+    ifRow.InterfaceIndex = index;\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n+        return JNI_FALSE;\n+    }\n+    return ifRow.Type == IF_TYPE_SOFTWARE_LOOPBACK ? JNI_TRUE : JNI_FALSE;\n@@ -1101,27 +614,13 @@\n-JNIEXPORT jbyteArray JNICALL Java_java_net_NetworkInterface_getMacAddr0\n-    (JNIEnv *env, jclass class, jbyteArray addrArray, jstring name, jint index) {\n-  jbyteArray ret = NULL;\n-  int len;\n-  MIB_IFROW *ifRowP;\n-\n-  \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-  if (ipv6_available()) {\n-    return Java_java_net_NetworkInterface_getMacAddr0_XP(env, class, name, index);\n-  } else {\n-    ifRowP = getIF(index);\n-    if (ifRowP != NULL) {\n-      switch(ifRowP->dwType) {\n-      case MIB_IF_TYPE_ETHERNET:\n-      case MIB_IF_TYPE_TOKENRING:\n-      case MIB_IF_TYPE_FDDI:\n-      case IF_TYPE_IEEE80211:\n-        len = ifRowP->dwPhysAddrLen;\n-        if (len > 0) {\n-            ret = (*env)->NewByteArray(env, len);\n-            if (!IS_NULL(ret)) {\n-              (*env)->SetByteArrayRegion(env, ret, 0, len, (jbyte *) ifRowP->bPhysAddr);\n-            }\n-        }\n-        break;\n-      }\n-      free(ifRowP);\n+JNIEXPORT jbyteArray JNICALL Java_java_net_NetworkInterface_getMacAddr0(\n+        JNIEnv *env, jclass class, jbyteArray addrArray, jstring name, jint index) {\n+    MIB_IF_ROW2 ifRow = {0};\n+    ULONG apiRetVal;\n+    jbyteArray macAddr;\n+\n+    ifRow.InterfaceIndex = index;\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n+        return NULL;\n@@ -1129,2 +628,11 @@\n-    return ret;\n-  }\n+    if (ifRow.PhysicalAddressLength == 0) {\n+        return NULL;\n+    }\n+    macAddr = (*env)->NewByteArray(env, ifRow.PhysicalAddressLength);\n+    if (macAddr == NULL) {\n+        return NULL;\n+    }\n+    (*env)->SetByteArrayRegion(\n+            env, macAddr, 0, ifRow.PhysicalAddressLength,\n+            (jbyte *) ifRow.PhysicalAddress);\n+    return macAddr;\n@@ -1138,13 +646,12 @@\n-JNIEXPORT jint JNICALL Java_java_net_NetworkInterface_getMTU0\n-    (JNIEnv *env, jclass class, jstring name, jint index) {\n-  jint ret = -1;\n-  MIB_IFROW *ifRowP;\n-\n-  \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-  if (ipv6_available()) {\n-    return Java_java_net_NetworkInterface_getMTU0_XP(env, class, name, index);\n-  } else {\n-    ifRowP = getIF(index);\n-    if (ifRowP != NULL) {\n-      ret = ifRowP->dwMtu;\n-      free(ifRowP);\n+JNIEXPORT jint JNICALL Java_java_net_NetworkInterface_getMTU0(\n+        JNIEnv *env, jclass class, jstring name, jint index) {\n+    MIB_IF_ROW2 ifRow = {0};\n+    ULONG apiRetVal;\n+\n+    ifRow.InterfaceIndex = index;\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n+        return -1;\n@@ -1152,2 +659,53 @@\n-    return ret;\n-  }\n+    return ifRow.Mtu;\n+}\n+\n+\/*\n+ * Class:     java_net_NetworkInterface\n+ * Method:    supportsMulticast0\n+ * Signature: (Ljava\/lang\/String;I)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_supportsMulticast0(\n+        JNIEnv *env, jclass cls, jstring name, jint index) {\n+    \/\/ we assume that multicast is enabled, because there are no reliable APIs to tell us\n+    return JNI_TRUE;\n+}\n+\n+\/*\n+ * Class:     java_net_NetworkInterface\n+ * Method:    init\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_java_net_NetworkInterface_init(JNIEnv *env, jclass cls) {\n+    \/*\n+     * Get the various JNI ids that we require\n+     *\/\n+    ni_class = (*env)->NewGlobalRef(env, cls);\n+    CHECK_NULL(ni_class);\n+    ni_nameID = (*env)->GetFieldID(env, ni_class, \"name\", \"Ljava\/lang\/String;\");\n+    CHECK_NULL(ni_nameID);\n+    ni_displayNameID = (*env)->GetFieldID(env, ni_class, \"displayName\", \"Ljava\/lang\/String;\");\n+    CHECK_NULL(ni_displayNameID);\n+    ni_indexID = (*env)->GetFieldID(env, ni_class, \"index\", \"I\");\n+    CHECK_NULL(ni_indexID);\n+    ni_addrsID = (*env)->GetFieldID(env, ni_class, \"addrs\", \"[Ljava\/net\/InetAddress;\");\n+    CHECK_NULL(ni_addrsID);\n+    ni_bindsID = (*env)->GetFieldID(env, ni_class, \"bindings\", \"[Ljava\/net\/InterfaceAddress;\");\n+    CHECK_NULL(ni_bindsID);\n+    ni_childsID = (*env)->GetFieldID(env, ni_class, \"childs\", \"[Ljava\/net\/NetworkInterface;\");\n+    CHECK_NULL(ni_childsID);\n+    ni_ctor = (*env)->GetMethodID(env, ni_class, \"<init>\", \"()V\");\n+    CHECK_NULL(ni_ctor);\n+    ni_ibcls = (*env)->FindClass(env, \"java\/net\/InterfaceAddress\");\n+    CHECK_NULL(ni_ibcls);\n+    ni_ibcls = (*env)->NewGlobalRef(env, ni_ibcls);\n+    CHECK_NULL(ni_ibcls);\n+    ni_ibctrID = (*env)->GetMethodID(env, ni_ibcls, \"<init>\", \"()V\");\n+    CHECK_NULL(ni_ibctrID);\n+    ni_ibaddressID = (*env)->GetFieldID(env, ni_ibcls, \"address\", \"Ljava\/net\/InetAddress;\");\n+    CHECK_NULL(ni_ibaddressID);\n+    ni_ibbroadcastID = (*env)->GetFieldID(env, ni_ibcls, \"broadcast\", \"Ljava\/net\/Inet4Address;\");\n+    CHECK_NULL(ni_ibbroadcastID);\n+    ni_ibmaskID = (*env)->GetFieldID(env, ni_ibcls, \"maskLength\", \"S\");\n+    CHECK_NULL(ni_ibmaskID);\n+\n+    initInetAddressIDs(env);\n","filename":"src\/java.base\/windows\/native\/libnet\/NetworkInterface.c","additions":496,"deletions":938,"binary":false,"changes":1434,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,5 +34,4 @@\n-typedef struct _netaddr  {\n-    SOCKETADDRESS    addr;                  \/* IPv4 or IPv6 address *\/\n-    SOCKETADDRESS    brdcast;\n-    short            mask;\n-    struct _netaddr *next;\n+typedef struct _netaddr {\n+    SOCKADDR_INET Address;\n+    UINT8 PrefixLength;\n+    struct _netaddr *Next;\n@@ -41,44 +40,0 @@\n-typedef struct _netif {\n-    char *name;\n-    char *displayName;\n-    DWORD dwIndex;              \/* Internal index *\/\n-    DWORD ifType;               \/* Interface type *\/\n-    int index;                  \/* Friendly index *\/\n-    struct _netif *next;\n-\n-    \/* Following fields used on Windows XP when IPv6 is used only *\/\n-    jboolean hasIpv6Address;    \/* true when following fields valid *\/\n-    jboolean dNameIsUnicode;    \/* Display Name is Unicode *\/\n-    int naddrs;                 \/* Number of addrs *\/\n-    DWORD ipv6Index;\n-    struct _netaddr *addrs;     \/* addr list for interfaces *\/\n-} netif;\n-\n-extern void free_netif(netif *netifP);\n-extern void free_netaddr(netaddr *netaddrP);\n-\n-\/* various JNI ids *\/\n-extern jclass ni_class;             \/* NetworkInterface *\/\n-\n-extern jmethodID ni_ctor;           \/* NetworkInterface() *\/\n-\n-extern jfieldID ni_indexID;         \/* NetworkInterface.index *\/\n-extern jfieldID ni_addrsID;         \/* NetworkInterface.addrs *\/\n-extern jfieldID ni_bindsID;         \/* NetworkInterface.bindings *\/\n-extern jfieldID ni_nameID;          \/* NetworkInterface.name *\/\n-extern jfieldID ni_displayNameID;   \/* NetworkInterface.displayName *\/\n-extern jfieldID ni_childsID;        \/* NetworkInterface.childs *\/\n-\n-extern jclass ni_ibcls;             \/* InterfaceAddress *\/\n-extern jmethodID ni_ibctrID;        \/* InterfaceAddress() *\/\n-extern jfieldID ni_ibaddressID;     \/* InterfaceAddress.address *\/\n-extern jfieldID ni_ibbroadcastID;   \/* InterfaceAddress.broadcast *\/\n-extern jfieldID ni_ibmaskID;        \/* InterfaceAddress.maskLength *\/\n-\n-int enumInterfaces(JNIEnv *env, netif **netifPP);\n-\n-\/\/ Windows Visa (and later) only.....\n-#ifndef IF_TYPE_IEEE80211\n-#define IF_TYPE_IEEE80211     71\n-#endif\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/NetworkInterface.h","additions":5,"deletions":50,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1,1010 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include \"net_util.h\"\n-#include \"NetworkInterface.h\"\n-\n-#include \"java_net_NetworkInterface.h\"\n-\n-\/*\n- * Windows implementation of the java.net.NetworkInterface native methods.\n- * This module provides the implementations of getAll, getByName, getByIndex,\n- * and getByAddress.\n- *\/\n-\n-extern int enumAddresses_win_ipaddrtable(JNIEnv *env, netif *netifP, netaddr **netaddrPP, MIB_IPADDRTABLE *tableP);\n-extern int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP);\n-extern int lookupIPAddrTable(JNIEnv *env, MIB_IPADDRTABLE **tablePP);\n-int getAddrsFromAdapter(IP_ADAPTER_ADDRESSES *ptr, netaddr **netaddrPP);\n-\n-#ifdef DEBUG\n-void printnif (netif *nif) {\n-#ifdef _WIN64\n-        printf (\"nif:0x%I64x name:%s\\n\", (UINT_PTR)nif, nif->name);\n-#else\n-        printf (\"nif:0x%x name:%s\\n\", (UINT_PTR)nif, nif->name);\n-#endif\n-        if (nif->dNameIsUnicode) {\n-            printf (\"dName:%S index:%d \", (unsigned short *)nif->displayName,\n-                nif->index);\n-        } else {\n-            printf (\"dName:%s index:%d \", nif->displayName, nif->index);\n-        }\n-        printf (\"naddrs:%d\\n\", nif->naddrs);\n-}\n-\n-void printnifs (netif *netifPP, char *str) {\n-    netif *nif;\n-    printf (\"%s\\n\", str);\n-    for (nif=netifPP; nif!=NULL; nif=nif->next) {\n-        printnif (nif);\n-    }\n-    printf(\"-----------------\\n\");\n-}\n-\n-#endif\n-\n-const ULONG BUFF_SIZE = 15360;\n-const int MAX_TRIES = 3;\n-\n-\/*\n- * return an array of IP_ADAPTER_ADDRESSES containing one element\n- * for each adapter on the system. Returned in *adapters.\n- * Buffer is malloc'd and must be freed (unless error returned)\n- *\/\n-int getAdapters (JNIEnv *env, int flags, IP_ADAPTER_ADDRESSES **adapters) {\n-    DWORD ret;\n-    IP_ADAPTER_ADDRESSES *adapterInfo;\n-    ULONG len;\n-    int try;\n-\n-    *adapters = NULL;\n-\n-    adapterInfo = (IP_ADAPTER_ADDRESSES *) malloc(BUFF_SIZE);\n-    if (adapterInfo == NULL) {\n-        JNU_ThrowByName(env, \"java\/lang\/OutOfMemoryError\",\n-            \"Native heap allocation failure\");\n-        return -1;\n-    }\n-\n-    len = BUFF_SIZE;\n-    ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &len);\n-\n-    for (try = 0; ret == ERROR_BUFFER_OVERFLOW && try < MAX_TRIES; ++try) {\n-        IP_ADAPTER_ADDRESSES * newAdapterInfo = NULL;\n-        if (len < (ULONG_MAX - BUFF_SIZE)) {\n-            len += BUFF_SIZE;\n-        }\n-        newAdapterInfo =\n-            (IP_ADAPTER_ADDRESSES *) realloc (adapterInfo, len);\n-        if (newAdapterInfo == NULL) {\n-            free(adapterInfo);\n-            JNU_ThrowByName(env, \"java\/lang\/OutOfMemoryError\",\n-                \"Native heap allocation failure\");\n-            return -1;\n-        }\n-\n-        adapterInfo = newAdapterInfo;\n-\n-        ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &len);\n-    }\n-\n-    if (ret != ERROR_SUCCESS) {\n-        free (adapterInfo);\n-        switch (ret) {\n-            case ERROR_INVALID_PARAMETER:\n-                JNU_ThrowInternalError(env,\n-                    \"IP Helper Library GetAdaptersAddresses function failed: \"\n-                    \"invalid parameter\");\n-                break;\n-            case ERROR_NOT_ENOUGH_MEMORY:\n-                JNU_ThrowOutOfMemoryError(env,\n-                    \"IP Helper Library GetAdaptersAddresses function failed: \"\n-                    \"not enough memory\");\n-                break;\n-            case ERROR_NO_DATA:\n-                \/\/ not an error\n-                *adapters = NULL;\n-                return ERROR_SUCCESS;\n-            default:\n-                SetLastError(ret);\n-                JNU_ThrowByNameWithMessageAndLastError(env,\n-                    JNU_JAVANETPKG \"SocketException\",\n-                    \"IP Helper Library GetAdaptersAddresses function failed\");\n-                break;\n-        }\n-\n-        return -1;\n-    }\n-    *adapters = adapterInfo;\n-    return ERROR_SUCCESS;\n-}\n-\n-\/*\n- * return an array of IP_ADAPTER_ADDRESSES containing one element\n- * for each adapter on the system. Returned in *adapters.\n- * Buffer is malloc'd and must be freed (unless error returned)\n- *\/\n-IP_ADAPTER_ADDRESSES *getAdapter (JNIEnv *env,  jint index) {\n-    DWORD flags, val;\n-    IP_ADAPTER_ADDRESSES *adapterInfo, *ptr, *ret;\n-    ULONG len;\n-    int try;\n-    adapterInfo = (IP_ADAPTER_ADDRESSES *) malloc(BUFF_SIZE);\n-    if (adapterInfo == NULL) {\n-        JNU_ThrowByName(env, \"java\/lang\/OutOfMemoryError\",\n-            \"Native heap allocation failure\");\n-        return NULL;\n-    }\n-    len = BUFF_SIZE;\n-    flags = GAA_FLAG_SKIP_DNS_SERVER;\n-    flags |= GAA_FLAG_SKIP_MULTICAST;\n-    flags |= GAA_FLAG_INCLUDE_PREFIX;\n-    val = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &len);\n-    for (try = 0; val == ERROR_BUFFER_OVERFLOW && try < MAX_TRIES; ++try) {\n-        IP_ADAPTER_ADDRESSES * newAdapterInfo = NULL;\n-        if (len < (ULONG_MAX - BUFF_SIZE)) {\n-            len += BUFF_SIZE;\n-        }\n-        newAdapterInfo =\n-                (IP_ADAPTER_ADDRESSES *) realloc (adapterInfo, len);\n-        if (newAdapterInfo == NULL) {\n-            free(adapterInfo);\n-            JNU_ThrowByName(env, \"java\/lang\/OutOfMemoryError\",\n-                \"Native heap allocation failure\");\n-            return NULL;\n-        }\n-\n-        adapterInfo = newAdapterInfo;\n-\n-        val = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &len);\n-    }\n-\n-    if (val != ERROR_SUCCESS) {\n-        free (adapterInfo);\n-        switch (val) {\n-            case ERROR_INVALID_PARAMETER:\n-                JNU_ThrowInternalError(env,\n-                    \"IP Helper Library GetAdaptersAddresses function failed: \"\n-                    \"invalid parameter\");\n-                break;\n-            case ERROR_NOT_ENOUGH_MEMORY:\n-                JNU_ThrowOutOfMemoryError(env,\n-                    \"IP Helper Library GetAdaptersAddresses function failed: \"\n-                    \"not enough memory\");\n-                break;\n-            case ERROR_NO_DATA:\n-                \/\/ not an error\n-                break;\n-            default:\n-                SetLastError(val);\n-                JNU_ThrowByNameWithMessageAndLastError(env,\n-                    JNU_JAVANETPKG \"SocketException\",\n-                    \"IP Helper Library GetAdaptersAddresses function failed\");\n-                break;\n-        }\n-        return NULL;\n-    }\n-\n-    ptr = adapterInfo;\n-    ret = NULL;\n-    while (ptr != NULL) {\n-      \/\/ in theory the IPv4 index and the IPv6 index can be the same\n-      \/\/ where an interface is enabled for v4 and v6\n-      \/\/ IfIndex == 0 IPv4 not available on this interface\n-      \/\/ Ipv6IfIndex == 0 IPv6 not available on this interface\n-      if (((ptr->IfIndex != 0)&&(ptr->IfIndex == index)) ||\n-          ((ptr->Ipv6IfIndex !=0) && (ptr->Ipv6IfIndex == index))) {\n-        ret = (IP_ADAPTER_ADDRESSES *) malloc(sizeof(IP_ADAPTER_ADDRESSES));\n-        if (ret == NULL) {\n-            free(adapterInfo);\n-            JNU_ThrowByName(env, \"java\/lang\/OutOfMemoryError\",\n-                \"Native heap allocation failure\");\n-            return NULL;\n-        }\n-\n-        \/\/copy the memory and break out of the while loop.\n-        memcpy(ret, ptr, sizeof(IP_ADAPTER_ADDRESSES));\n-        break;\n-\n-      }\n-      ptr=ptr->Next;\n-    }\n-    free(adapterInfo);\n-    return ret;\n-}\n-\n-\/*\n- *\/\n-int getAllInterfacesAndAddresses (JNIEnv *env, netif **netifPP)\n-{\n-    int ret, flags;\n-    MIB_IPADDRTABLE *tableP;\n-    IP_ADAPTER_ADDRESSES *ptr, *adapters=NULL;\n-    ULONG count=0;\n-    netif *nif=NULL, *dup_nif, *last=NULL, *loopif=NULL, *curr;\n-    int tun=0, net=0;\n-\n-   \/*\n-    * Get the IPv4 interfaces. This information is the same\n-    * as what previous JDK versions would return.\n-    *\/\n-\n-    ret = enumInterfaces(env, netifPP);\n-    if (ret < 0) {\n-        return -1;\n-    } else {\n-        count = ret;\n-    }\n-\n-    \/* locate the loopback (and the last) interface *\/\n-    for (nif=*netifPP, last=nif; nif!=NULL; nif=nif->next) {\n-        if (nif->ifType == MIB_IF_TYPE_LOOPBACK) {\n-            loopif = nif;\n-        }\n-        last = nif;\n-    }\n-\n-    \/\/ Retrieve IPv4 addresses with the IP Helper API\n-    curr = *netifPP;\n-    ret = lookupIPAddrTable(env, &tableP);\n-    if (ret == -1) {\n-      free_netif(*netifPP);\n-      return -1;\n-    } else if (ret == -2) {\n-        \/\/ Clear the exception and continue.\n-        if ((*env)->ExceptionCheck(env)) {\n-            (*env)->ExceptionClear(env);\n-        }\n-        tableP = NULL;\n-    }\n-    while (curr != NULL) {\n-        netaddr *netaddrP;\n-        ret = enumAddresses_win_ipaddrtable(env, curr, &netaddrP, tableP);\n-        if (ret < 0) {\n-            free_netif(*netifPP);\n-            free(tableP);\n-            return -1;\n-        } else{\n-            curr->addrs = netaddrP;\n-            curr->naddrs += ret;\n-            curr = curr->next;\n-        }\n-    }\n-    free(tableP);\n-\n-    flags = GAA_FLAG_SKIP_DNS_SERVER;\n-    flags |= GAA_FLAG_SKIP_MULTICAST;\n-    flags |= GAA_FLAG_INCLUDE_PREFIX;\n-    ret = getAdapters (env, flags, &adapters);\n-    if (ret != ERROR_SUCCESS) {\n-        free_netif(*netifPP);\n-        return -1;\n-    }\n-\n-    \/* Now get the IPv6 information. This includes:\n-     *  (a)  IPv6 information associated with interfaces already found\n-     *  (b)  IPv6 information for IPv6 only interfaces (probably tunnels)\n-     *\n-     * For compatibility with previous releases we use the naming\n-     * information gotten from enumInterfaces() for (a) entries\n-     * However, the index numbers are taken from the new API.\n-     *\n-     * The procedure is to go through the list of adapters returned\n-     * by the new API looking for entries that correspond to IPv4 interfaces\n-     * already found.\n-     *\/\n-\n-    ptr = adapters;\n-    while (ptr != NULL) {\n-        int c;\n-        netif *nif0;\n-        if (ptr->IfType == IF_TYPE_SOFTWARE_LOOPBACK && (loopif != NULL)) {\n-            c = getAddrsFromAdapter(ptr, &loopif->addrs);\n-            if (c == -1) {\n-                goto err;\n-            }\n-            loopif->naddrs += c;\n-            loopif->ipv6Index = ptr->Ipv6IfIndex;\n-        } else {\n-            int index = ptr->IfIndex;\n-            if (index != 0) {\n-                \/* This entry is associated with an IPv4 interface *\/\n-                for (nif=*netifPP; nif!=NULL; nif=nif->next) {\n-                    if (nif->index == index) {\n-                        \/* found the interface entry\n-                         * set the index to the IPv6 index and add the\n-                         * IPv6 addresses\n-                         *\/\n-                        nif->ipv6Index = ptr->Ipv6IfIndex;\n-                        c = getAddrsFromAdapter(ptr, &nif->addrs);\n-                        if (c == -1) {\n-                            goto err;\n-                        }\n-                        nif->naddrs += c;\n-                        break;\n-                    }\n-                }\n-            } else {\n-                \/* This entry is IPv6 only *\/\n-                char newname [128];\n-                int c;\n-\n-                \/* Windows allocates duplicate adapter entries\n-                 * for tunnel interfaces when there are multiple\n-                 * physical adapters. Need to check\n-                 * if this is a duplicate (ipv6Index is the same)\n-                 *\/\n-                dup_nif = 0;\n-                for (nif0=*netifPP; nif0!=NULL; nif0=nif0->next) {\n-                    if (nif0->hasIpv6Address &&\n-                                ptr->Ipv6IfIndex == nif0->ipv6Index) {\n-                        dup_nif = nif0;\n-                        break;\n-                    }\n-                }\n-                if (dup_nif == 0) {\n-                    \/* new interface *\/\n-                        nif = (netif *) calloc (1, sizeof(netif));\n-                        if (nif == 0) {\n-                            goto err;\n-                        }\n-                        if (ptr->IfType == IF_TYPE_TUNNEL) {\n-                                sprintf (newname, \"tun%d\", tun);\n-                                tun ++;\n-                        } else {\n-                                sprintf (newname, \"net%d\", net);\n-                                net ++;\n-                        }\n-                        nif->name = malloc (strlen(newname)+1);\n-                        nif->displayName = malloc (wcslen(ptr->FriendlyName)*2+2);\n-                        if (nif->name == 0 || nif->displayName == 0) {\n-                                free(nif);\n-                                goto err;\n-                        }\n-                        strcpy (nif->name, newname);\n-                        wcscpy ((PWCHAR)nif->displayName, ptr->FriendlyName);\n-                        nif->dNameIsUnicode = TRUE;\n-\n-                        \/\/ the java.net.NetworkInterface abstraction only has index\n-                        \/\/ so the Ipv6IfIndex needs to map onto index\n-                        nif->index = ptr->Ipv6IfIndex;\n-                        nif->ipv6Index = ptr->Ipv6IfIndex;\n-                        nif->hasIpv6Address = TRUE;\n-\n-                        if (last) {\n-                                last->next = nif;\n-                        } else {\n-                                *netifPP = nif;\n-                        }\n-                        last = nif;\n-                        count++;\n-                        c = getAddrsFromAdapter(ptr, &nif->addrs);\n-                        if (c == -1) {\n-                                goto err;\n-                        }\n-                        nif->naddrs += c;\n-                 } else {\n-                        \/* add the addresses from this adapter to the\n-                         * original (dup_nif)\n-                         *\/\n-                        c = getAddrsFromAdapter(ptr, &dup_nif->addrs);\n-                        if (c == -1) {\n-                                goto err;\n-                        }\n-                        dup_nif->naddrs += c;\n-                }\n-            }\n-        }\n-        ptr=ptr->Next;\n-    }\n-\n-    free (adapters);\n-    return count;\n-\n-err:\n-    if (*netifPP) {\n-        free_netif (*netifPP);\n-    }\n-    if (adapters) {\n-        free (adapters);\n-    }\n-    return -1;\n-}\n-\n-\/* If *netaddrPP is null, then the addresses are allocated and the beginning\n- * of the allocated chain is returned in *netaddrPP.\n- * If *netaddrPP is not null, then the addresses allocated here are appended\n- * to the existing chain.\n- *\n- * Returns count of addresses or -1 on error.\n- *\/\n-\n-static int getAddrsFromAdapter(IP_ADAPTER_ADDRESSES *ptr, netaddr **netaddrPP) {\n-        LPSOCKADDR sock;\n-        int        count = 0;\n-        netaddr    *curr, *start = NULL, *prev = NULL;\n-        PIP_ADAPTER_UNICAST_ADDRESS uni_addr;\n-        PIP_ADAPTER_ANYCAST_ADDRESS any_addr;\n-        PIP_ADAPTER_PREFIX prefix;\n-\n-        \/* If chain passed in, find end *\/\n-        if (*netaddrPP != NULL) {\n-            for (start=*netaddrPP; start->next!=NULL; start=start->next)\n-                ;\n-\n-            prev=start;\n-        }\n-\n-        prefix = ptr->FirstPrefix;\n-        \/* Unicast *\/\n-        uni_addr = ptr->FirstUnicastAddress;\n-        while (uni_addr != NULL) {\n-        \/* address is only usable if dad state is preferred or deprecated *\/\n-                if (uni_addr->DadState == IpDadStateDeprecated ||\n-                                uni_addr->DadState == IpDadStatePreferred) {\n-                        sock = uni_addr->Address.lpSockaddr;\n-\n-                        \/\/ IPv4 addresses already retrieved with enumAddresses_win\n-                        if (sock->sa_family == AF_INET) {\n-                                uni_addr = uni_addr->Next;\n-                                continue;\n-                        }\n-\n-            curr = (netaddr *)calloc (1, sizeof (netaddr));\n-\n-            if (curr == NULL)\n-                goto freeAllocatedMemory;\n-\n-            if (start == NULL)\n-                start = curr;\n-\n-            if (prev != NULL)\n-               prev->next = curr;\n-\n-            prev = curr;\n-            SOCKETADDRESS_COPY (&curr->addr, sock);\n-            if (prefix != NULL) {\n-              curr->mask = (short)prefix->PrefixLength;\n-              prefix = prefix->Next;\n-            }\n-            count ++;\n-        }\n-        uni_addr = uni_addr->Next;\n-    }\n-    \/* Anycast *\/\n-    any_addr = ptr->FirstAnycastAddress;\n-    while (any_addr != NULL) {\n-        curr = (netaddr *)calloc (1, sizeof (netaddr));\n-\n-        if (curr == NULL)\n-            goto freeAllocatedMemory;\n-\n-        if (start == NULL)\n-            start = curr;\n-\n-        if (prev != NULL)\n-            prev->next = curr;\n-\n-        prev = curr;\n-        sock = any_addr->Address.lpSockaddr;\n-        SOCKETADDRESS_COPY (&curr->addr, sock);\n-        count ++;\n-        any_addr = any_addr->Next;\n-    }\n-    if (*netaddrPP == NULL) {\n-        *netaddrPP = start;\n-    }\n-    return count;\n-\n-freeAllocatedMemory:\n-\n-    if (*netaddrPP != NULL) {\n-        \/\/N.B. the variable \"start\" cannot be NULL at this point because we started with an\n-        \/\/existing list.\n-        curr=start->next;\n-        start->next = NULL;\n-        start = curr;\n-    }\n-    \/\/ otherwise, \"start\" points to the beginning of an incomplete list that we must deallocate.\n-\n-    while (start != NULL) {\n-        curr = start->next;\n-        free(start);\n-        start = curr;\n-    }\n-\n-    return -1;\n-}\n-\n-\/*\n- * Create a NetworkInterface object, populate the name and index, and\n- * populate the InetAddress array based on the IP addresses for this\n- * interface.\n- *\/\n-static jobject createNetworkInterfaceXP(JNIEnv *env, netif *ifs)\n-{\n-    jobject netifObj;\n-    jobject name, displayName;\n-    jobjectArray addrArr, bindsArr, childArr;\n-    netaddr *addrs;\n-    jint addr_index;\n-    int netaddrCount = ifs->naddrs;\n-    netaddr *netaddrP = ifs->addrs;\n-    netaddr *netaddrPToFree = NULL;\n-    jint bind_index;\n-\n-    \/*\n-     * Create a NetworkInterface object and populate it\n-     *\/\n-    netifObj = (*env)->NewObject(env, ni_class, ni_ctor);\n-    if (netifObj == NULL) {\n-        return NULL;\n-    }\n-    name = (*env)->NewStringUTF(env, ifs->name);\n-    if (name == NULL) {\n-        return NULL;\n-    }\n-    if (ifs->dNameIsUnicode) {\n-        displayName = (*env)->NewString(env, (PWCHAR)ifs->displayName,\n-                                        (jsize)wcslen ((PWCHAR)ifs->displayName));\n-    } else {\n-        displayName = (*env)->NewStringUTF(env, ifs->displayName);\n-    }\n-    if (displayName == NULL) {\n-        return NULL;\n-    }\n-    (*env)->SetObjectField(env, netifObj, ni_nameID, name);\n-    (*env)->DeleteLocalRef(env, name);\n-    (*env)->SetObjectField(env, netifObj, ni_displayNameID, displayName);\n-    (*env)->DeleteLocalRef(env, displayName);\n-    (*env)->SetIntField(env, netifObj, ni_indexID, ifs->index);\n-    \/*\n-     * Get the IP addresses for this interface if necessary\n-     * Note that 0 is a valid number of addresses.\n-     *\/\n-    if (netaddrCount < 0) {\n-        netaddrCount = enumAddresses_win(env, ifs, &netaddrPToFree);\n-        if (netaddrCount == -1) {\n-            return NULL;\n-        }\n-        if (netaddrCount == -2) {\n-            \/\/ Clear the exception and continue.\n-            if ((*env)->ExceptionCheck(env)) {\n-                (*env)->ExceptionClear(env);\n-            }\n-            netaddrCount = 0;\n-            netaddrPToFree = NULL;\n-        }\n-        netaddrP = netaddrPToFree;\n-    }\n-\n-    addrArr = (*env)->NewObjectArray(env, netaddrCount, ia_class, NULL);\n-    if (addrArr == NULL) {\n-        free_netaddr(netaddrPToFree);\n-        return NULL;\n-    }\n-\n-    bindsArr = (*env)->NewObjectArray(env, netaddrCount, ni_ibcls, NULL);\n-    if (bindsArr == NULL) {\n-        free_netaddr(netaddrPToFree);\n-        return NULL;\n-    }\n-\n-    addrs = netaddrP;\n-    addr_index = 0;\n-    bind_index = 0;\n-    while (addrs != NULL) {\n-        jobject iaObj, ia2Obj;\n-        jobject ibObj = NULL;\n-        if (addrs->addr.sa.sa_family == AF_INET) {\n-            iaObj = (*env)->NewObject(env, ia4_class, ia4_ctrID);\n-            if (iaObj == NULL) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            \/* default ctor will set family to AF_INET *\/\n-\n-            setInetAddress_addr(env, iaObj, ntohl(addrs->addr.sa4.sin_addr.s_addr));\n-            if ((*env)->ExceptionCheck(env)) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            ibObj = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);\n-            if (ibObj == NULL) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            (*env)->SetObjectField(env, ibObj, ni_ibaddressID, iaObj);\n-            ia2Obj = (*env)->NewObject(env, ia4_class, ia4_ctrID);\n-            if (ia2Obj == NULL) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            setInetAddress_addr(env, ia2Obj, ntohl(addrs->brdcast.sa4.sin_addr.s_addr));\n-            if ((*env)->ExceptionCheck(env)) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            (*env)->SetObjectField(env, ibObj, ni_ibbroadcastID, ia2Obj);\n-            (*env)->DeleteLocalRef(env, ia2Obj);\n-            (*env)->SetShortField(env, ibObj, ni_ibmaskID, addrs->mask);\n-            (*env)->SetObjectArrayElement(env, bindsArr, bind_index++, ibObj);\n-            (*env)->DeleteLocalRef(env, ibObj);\n-        } else \/* AF_INET6 *\/ {\n-            int scope;\n-            jboolean ret;\n-            iaObj = (*env)->NewObject(env, ia6_class, ia6_ctrID);\n-            if (iaObj == NULL) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            ret = setInet6Address_ipaddress(env, iaObj, (jbyte *)&(addrs->addr.sa6.sin6_addr.s6_addr));\n-            if (ret == JNI_FALSE) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            scope = addrs->addr.sa6.sin6_scope_id;\n-            if (scope != 0) { \/* zero is default value, no need to set *\/\n-                setInet6Address_scopeid(env, iaObj, scope);\n-                setInet6Address_scopeifname(env, iaObj, netifObj);\n-            }\n-            ibObj = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);\n-            if (ibObj == NULL) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            (*env)->SetObjectField(env, ibObj, ni_ibaddressID, iaObj);\n-            (*env)->SetShortField(env, ibObj, ni_ibmaskID, addrs->mask);\n-            (*env)->SetObjectArrayElement(env, bindsArr, bind_index++, ibObj);\n-            (*env)->DeleteLocalRef(env, ibObj);\n-        }\n-        (*env)->SetObjectArrayElement(env, addrArr, addr_index, iaObj);\n-        (*env)->DeleteLocalRef(env, iaObj);\n-        addrs = addrs->next;\n-        addr_index++;\n-    }\n-    (*env)->SetObjectField(env, netifObj, ni_addrsID, addrArr);\n-    (*env)->DeleteLocalRef(env, addrArr);\n-    (*env)->SetObjectField(env, netifObj, ni_bindsID, bindsArr);\n-    (*env)->DeleteLocalRef(env, bindsArr);\n-\n-    free_netaddr(netaddrPToFree);\n-\n-    \/*\n-     * Windows doesn't have virtual interfaces, so child array\n-     * is always empty.\n-     *\/\n-    childArr = (*env)->NewObjectArray(env, 0, ni_class, NULL);\n-    if (childArr == NULL) {\n-      return NULL;\n-    }\n-    (*env)->SetObjectField(env, netifObj, ni_childsID, childArr);\n-    (*env)->DeleteLocalRef(env, childArr);\n-\n-    \/* return the NetworkInterface *\/\n-    return netifObj;\n-}\n-\n-JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByName0_XP\n-    (JNIEnv *env, jclass cls, jstring name)\n-{\n-    netif *ifList, *curr;\n-    jboolean isCopy;\n-    const char *name_utf;\n-    jobject netifObj = NULL;\n-\n-    if (getAllInterfacesAndAddresses (env, &ifList) < 0) {\n-        return NULL;\n-    }\n-\n-    \/* get the name as a C string *\/\n-    name_utf = (*env)->GetStringUTFChars(env, name, &isCopy);\n-\n-    \/* Search by name *\/\n-    curr = ifList;\n-    while (curr != NULL) {\n-        if (strcmp(name_utf, curr->name) == 0) {\n-            break;\n-        }\n-        curr = curr->next;\n-    }\n-\n-    \/* if found create a NetworkInterface *\/\n-    if (curr != NULL) {\n-        netifObj = createNetworkInterfaceXP(env, curr);\n-    }\n-\n-    \/* release the UTF string *\/\n-    (*env)->ReleaseStringUTFChars(env, name, name_utf);\n-\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n-\n-    return netifObj;\n-}\n-\n-\/*\n- * Class:     NetworkInterface\n- * Method:    getByIndex0_XP\n- * Signature: (I)LNetworkInterface;\n- *\/\n-JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByIndex0_XP\n-  (JNIEnv *env, jclass cls, jint index)\n-{\n-    netif *ifList, *curr;\n-    jobject netifObj = NULL;\n-\n-    if (getAllInterfacesAndAddresses (env, &ifList) < 0) {\n-        return NULL;\n-    }\n-\n-    \/* search by index *\/\n-    curr = ifList;\n-    while (curr != NULL) {\n-        if (index == curr->index) {\n-            break;\n-        }\n-        curr = curr->next;\n-    }\n-\n-    \/* if found create a NetworkInterface *\/\n-    if (curr != NULL) {\n-        netifObj = createNetworkInterfaceXP(env, curr);\n-    }\n-\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n-\n-    return netifObj;\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    getByInetAddress0\n- * Signature: (Ljava\/net\/InetAddress;)Ljava\/net\/NetworkInterface;\n- *\/\n-JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0_XP\n-    (JNIEnv *env, jclass cls, jobject iaObj)\n-{\n-    netif *ifList, *curr;\n-    jobject netifObj = NULL;\n-\n-    \/* get the list of interfaces *\/\n-    if (getAllInterfacesAndAddresses (env, &ifList) < 0) {\n-        return NULL;\n-    }\n-\n-    \/*\n-     * Enumerate the addresses on each interface until we find a\n-     * matching address.\n-     *\/\n-    curr = ifList;\n-    while (curr != NULL) {\n-        netaddr *addrList = curr->addrs;\n-        netaddr *addrP;\n-\n-        \/* iterate through each address *\/\n-        addrP = addrList;\n-\n-        while (addrP != NULL) {\n-            if (NET_SockaddrEqualsInetAddress(env,\n-                                (struct sockaddr*)&addrP->addr, iaObj)) {\n-                break;\n-            }\n-            addrP = addrP->next;\n-        }\n-\n-        \/*\n-         * Address matched so create NetworkInterface for this interface\n-         * and address list.\n-         *\/\n-        if (addrP != NULL) {\n-            netifObj = createNetworkInterfaceXP(env, curr);\n-            break;\n-        }\n-\n-        \/* on next interface *\/\n-        curr = curr->next;\n-    }\n-\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n-\n-    return netifObj;\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    getAll\n- * Signature: ()[Ljava\/net\/NetworkInterface;\n- *\/\n-JNIEXPORT jobjectArray JNICALL Java_java_net_NetworkInterface_getAll_XP\n-    (JNIEnv *env, jclass cls)\n-{\n-    int count;\n-    netif *ifList, *curr;\n-    jobjectArray netIFArr;\n-    jint arr_index;\n-\n-    \/*\n-     * Get list of interfaces\n-     *\/\n-    count = getAllInterfacesAndAddresses (env, &ifList);\n-    if (count < 0) {\n-        return NULL;\n-    }\n-\n-    \/* allocate a NetworkInterface array *\/\n-    netIFArr = (*env)->NewObjectArray(env, count, cls, NULL);\n-    if (netIFArr == NULL) {\n-        free_netif(ifList);\n-        return NULL;\n-    }\n-\n-    \/*\n-     * Iterate through the interfaces, create a NetworkInterface instance\n-     * for each array element and populate the object.\n-     *\/\n-    curr = ifList;\n-    arr_index = 0;\n-    while (curr != NULL) {\n-        jobject netifObj;\n-\n-        netifObj = createNetworkInterfaceXP(env, curr);\n-        if (netifObj == NULL) {\n-            free_netif(ifList);\n-            return NULL;\n-        }\n-\n-        \/* put the NetworkInterface into the array *\/\n-        (*env)->SetObjectArrayElement(env, netIFArr, arr_index++, netifObj);\n-        (*env)->DeleteLocalRef(env, netifObj);\n-        curr = curr->next;\n-    }\n-\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n-\n-    return netIFArr;\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    supportsMulticast0\n- * Signature: (Ljava\/lang\/String;I)Z\n- *\/\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_supportsMulticast0_XP\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-      IP_ADAPTER_ADDRESSES *ptr;\n-      jboolean val = JNI_TRUE;\n-\n-      ptr = getAdapter(env, index);\n-      if (ptr != NULL) {\n-        val = ptr->Flags & IP_ADAPTER_NO_MULTICAST ? JNI_FALSE : JNI_TRUE;\n-        free(ptr);\n-      }\n-      return val;\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    isUp0\n- * Signature: (Ljava\/lang\/String;I)Z\n- *\/\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isUp0_XP\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-      IP_ADAPTER_ADDRESSES *ptr;\n-      jboolean val = JNI_FALSE;\n-\n-      ptr = getAdapter(env, index);\n-      if (ptr != NULL) {\n-        val = ptr->OperStatus == IfOperStatusUp ? JNI_TRUE : JNI_FALSE;\n-        free(ptr);\n-      }\n-      return val;\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    getMacAddr0\n- * Signature: (Ljava\/lang\/String;I)Z\n- *\/\n-JNIEXPORT jbyteArray JNICALL Java_java_net_NetworkInterface_getMacAddr0_XP\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-      IP_ADAPTER_ADDRESSES *ptr;\n-      jbyteArray ret = NULL;\n-      int len;\n-\n-      ptr = getAdapter(env, index);\n-      if (ptr != NULL) {\n-        len = ptr->PhysicalAddressLength;\n-        if (len > 0) {\n-          ret = (*env)->NewByteArray(env, len);\n-          if (!IS_NULL(ret)) {\n-            (*env)->SetByteArrayRegion(env, ret, 0, len,\n-                                       (jbyte*) ptr->PhysicalAddress);\n-          }\n-        }\n-        free(ptr);\n-      }\n-      return ret;\n-}\n-\n-\/*\n- * Class:       java_net_NetworkInterface\n- * Method:      getMTU0\n- * Signature:   ([bLjava\/lang\/String;I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_NetworkInterface_getMTU0_XP\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-      IP_ADAPTER_ADDRESSES *ptr;\n-      jint ret = -1;\n-\n-      ptr = getAdapter(env, index);\n-      if (ptr != NULL) {\n-        ret = ptr->Mtu;\n-        free(ptr);\n-      }\n-      return ret;\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    isLoopback0\n- * Signature: (Ljava\/lang\/String;I)Z\n- *\/\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isLoopback0_XP\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-      IP_ADAPTER_ADDRESSES *ptr;\n-      jboolean val = JNI_FALSE;\n-\n-      ptr = getAdapter(env, index);\n-      if (ptr != NULL) {\n-        val = ptr->IfType == IF_TYPE_SOFTWARE_LOOPBACK ? JNI_TRUE : JNI_FALSE;\n-        free(ptr);\n-      }\n-      return val;\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    isP2P0\n- * Signature: (Ljava\/lang\/String;I)Z\n- *\/\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isP2P0_XP\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-      IP_ADAPTER_ADDRESSES *ptr;\n-      jboolean val = JNI_FALSE;\n-\n-      ptr = getAdapter(env, index);\n-      if (ptr != NULL) {\n-        if (ptr->IfType == IF_TYPE_PPP || ptr->IfType == IF_TYPE_SLIP ||\n-           ptr->IfType == IF_TYPE_TUNNEL) {\n-          val = JNI_TRUE;\n-        }\n-        free(ptr);\n-      }\n-      return val;\n-}\n","filename":"src\/java.base\/windows\/native\/libnet\/NetworkInterface_winXP.c","additions":0,"deletions":1010,"binary":false,"changes":1010,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+#define BUFF_SIZE           15360\n+#define MAX_TRIES           3\n@@ -49,1 +51,72 @@\n-extern int getAdapters(JNIEnv *env, int flags, IP_ADAPTER_ADDRESSES **adapters);\n+\/*\n+ * return an array of IP_ADAPTER_ADDRESSES containing one element\n+ * for each adapter on the system. Returned in *adapters.\n+ * Buffer is malloc'd and must be freed (unless error returned)\n+ *\/\n+static int getAdapters (JNIEnv *env, int flags, IP_ADAPTER_ADDRESSES **adapters) {\n+    DWORD ret;\n+    IP_ADAPTER_ADDRESSES *adapterInfo;\n+    ULONG len;\n+    int try;\n+\n+    *adapters = NULL;\n+\n+    adapterInfo = (IP_ADAPTER_ADDRESSES *) malloc(BUFF_SIZE);\n+    if (adapterInfo == NULL) {\n+        JNU_ThrowByName(env, \"java\/lang\/OutOfMemoryError\",\n+            \"Native heap allocation failure\");\n+        return -1;\n+    }\n+\n+    len = BUFF_SIZE;\n+    ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &len);\n+\n+    for (try = 0; ret == ERROR_BUFFER_OVERFLOW && try < MAX_TRIES; ++try) {\n+        IP_ADAPTER_ADDRESSES * newAdapterInfo = NULL;\n+        if (len < (ULONG_MAX - BUFF_SIZE)) {\n+            len += BUFF_SIZE;\n+        }\n+        newAdapterInfo =\n+            (IP_ADAPTER_ADDRESSES *) realloc (adapterInfo, len);\n+        if (newAdapterInfo == NULL) {\n+            free(adapterInfo);\n+            JNU_ThrowByName(env, \"java\/lang\/OutOfMemoryError\",\n+                \"Native heap allocation failure\");\n+            return -1;\n+        }\n+\n+        adapterInfo = newAdapterInfo;\n+\n+        ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &len);\n+    }\n+\n+    if (ret != ERROR_SUCCESS) {\n+        free (adapterInfo);\n+        switch (ret) {\n+            case ERROR_INVALID_PARAMETER:\n+                JNU_ThrowInternalError(env,\n+                    \"IP Helper Library GetAdaptersAddresses function failed: \"\n+                    \"invalid parameter\");\n+                break;\n+            case ERROR_NOT_ENOUGH_MEMORY:\n+                JNU_ThrowOutOfMemoryError(env,\n+                    \"IP Helper Library GetAdaptersAddresses function failed: \"\n+                    \"not enough memory\");\n+                break;\n+            case ERROR_NO_DATA:\n+                \/\/ not an error\n+                *adapters = NULL;\n+                return ERROR_SUCCESS;\n+            default:\n+                SetLastError(ret);\n+                JNU_ThrowByNameWithMessageAndLastError(env,\n+                    JNU_JAVANETPKG \"SocketException\",\n+                    \"IP Helper Library GetAdaptersAddresses function failed\");\n+                break;\n+        }\n+\n+        return -1;\n+    }\n+    *adapters = adapterInfo;\n+    return ERROR_SUCCESS;\n+}\n@@ -117,0 +190,1 @@\n+    flags |= GAA_FLAG_INCLUDE_ALL_INTERFACES;\n","filename":"src\/java.base\/windows\/native\/libnet\/ResolverConfigurationImpl.c","additions":76,"deletions":2,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-                if (ni.supportsMulticast()) {\n+                if (ni.supportsMulticast() && !ni.getInterfaceAddresses().isEmpty()) {\n","filename":"test\/jdk\/java\/net\/SocketOption\/OptionsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}