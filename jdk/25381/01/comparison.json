{"files":[{"patch":"@@ -123,0 +123,1 @@\n+  declare_constant(ZPageSizeMediumShift)                                                             \\\n@@ -129,1 +130,0 @@\n-  declare_constant(ZPageSizeMediumShift)                                                             \\\n","filename":"src\/hotspot\/share\/gc\/z\/vmStructs_z.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,4 +34,6 @@\n-\/\/   7      1 0\n-\/\/  +------+-+-+\n-\/\/  |000000|1|1|\n-\/\/  +------+-+-+\n+\/\/   7     2 1 0\n+\/\/  +-----+-+-+-+\n+\/\/  |00000|1|1|1|\n+\/\/  +-----+-+-+-+\n+\/\/  |      | | |\n+\/\/  |      | | * 0-0 Non-Blocking Flag (1-bit)\n@@ -39,1 +41,1 @@\n-\/\/  |      | * 0-0 Non-Blocking Flag (1-bit)\n+\/\/  |      | * 1-1 GC Relocation Flag (1-bit)\n@@ -41,1 +43,1 @@\n-\/\/  |      * 1-1 GC Relocation Flag (1-bit)\n+\/\/  |      * 2-2 Fast Medium Flag (1-bit)\n@@ -43,1 +45,1 @@\n-\/\/  * 7-2 Unused (6-bits)\n+\/\/  * 7-3 Unused (5-bits)\n@@ -50,0 +52,1 @@\n+  typedef ZBitField<uint8_t, bool, 2, 1> field_fast_medium;\n@@ -65,0 +68,4 @@\n+  void set_fast_medium() {\n+    _flags |= field_fast_medium::encode(true);\n+  }\n+\n@@ -72,0 +79,4 @@\n+\n+  bool fast_medium() const {\n+    return field_fast_medium::decode(_flags);\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zAllocationFlags.hpp","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -165,3 +165,2 @@\n-      const size_t medium_page_overhead = ZPageSizeMedium * tenuring_threshold;\n-      const size_t small_page_overhead = ZPageSizeSmall * ConcGCThreads * tenuring_threshold;\n-      if (small_page_overhead + medium_page_overhead >= ZHeuristics::significant_young_overhead()) {\n+      const size_t per_age_overhead = ZHeuristics::relocation_headroom();\n+      if (per_age_overhead * tenuring_threshold >= ZHeuristics::significant_young_overhead()) {\n","filename":"src\/hotspot\/share\/gc\/z\/zArguments.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,2 +26,4 @@\n-size_t     ZPageSizeMediumShift;\n-size_t     ZPageSizeMedium;\n+int        ZPageSizeMediumShift;\n+size_t     ZPageSizeMediumMax;\n+size_t     ZPageSizeMediumMin;\n+bool       ZPageSizeMediumEnabled;\n","filename":"src\/hotspot\/share\/gc\/z\/zGlobals.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-extern size_t     ZPageSizeMediumShift;\n+extern int        ZPageSizeMediumShift;\n@@ -50,1 +50,3 @@\n-extern size_t     ZPageSizeMedium;\n+extern size_t     ZPageSizeMediumMax;\n+extern size_t     ZPageSizeMediumMin;\n+extern bool       ZPageSizeMediumEnabled;\n","filename":"src\/hotspot\/share\/gc\/z\/zGlobals.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -367,1 +367,9 @@\n-  st->print_cr(\" Page Size Medium:   %zuM\", ZPageSizeMedium \/ M);\n+  if (ZPageSizeMediumEnabled) {\n+    if (ZPageSizeMediumMin == ZPageSizeMediumMax) {\n+      st->print_cr(\" Page Size Medium: %zuM\", ZPageSizeMediumMax \/ M);\n+    } else {\n+      st->print_cr(\" Page Size Medium: Range [%zuM, %zuM]\", ZPageSizeMediumMin \/ M, ZPageSizeMediumMax \/ M);\n+    }\n+  } else {\n+    st->print_cr(\" Page Size Medium: N\/A\");\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/align.hpp\"\n@@ -47,4 +48,4 @@\n-    ZPageSizeMedium             = size;\n-    ZPageSizeMediumShift        = (size_t)log2i_exact(ZPageSizeMedium);\n-    ZObjectSizeLimitMedium      = ZPageSizeMedium \/ 8;\n-    ZObjectAlignmentMediumShift = (int)ZPageSizeMediumShift - 13;\n+    ZPageSizeMediumMax          = size;\n+    ZPageSizeMediumShift        = log2i_exact(ZPageSizeMediumMax);\n+    ZObjectSizeLimitMedium      = ZPageSizeMediumMax \/ 8;\n+    ZObjectAlignmentMediumShift = ZPageSizeMediumShift - 13;\n@@ -52,0 +53,4 @@\n+    ZPageSizeMediumEnabled      = true;\n+    ZPageSizeMediumMin          = ZUseMediumPageSizeRange\n+                                ? align_up(ZObjectSizeLimitMedium, ZGranuleSize)\n+                                : ZPageSizeMediumMax;\n@@ -58,1 +63,1 @@\n-  return (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMedium;\n+  return (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n","filename":"src\/hotspot\/share\/gc\/z\/zHeuristics.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -315,0 +315,5 @@\n+  if (_size < min_size) {\n+    \/\/ Not enough left in cache to satisfy the min_size\n+    return false;\n+  }\n+\n@@ -550,0 +555,31 @@\n+ZVirtualMemory ZMappedCache::remove_contiguous_power_of_2(size_t min_size, size_t max_size) {\n+  precond(is_aligned(min_size, ZGranuleSize));\n+  precond(is_power_of_2(min_size));\n+  precond(is_aligned(max_size, ZGranuleSize));\n+  precond(is_power_of_2(max_size));\n+  precond(min_size <= max_size);\n+\n+  ZVirtualMemory result;\n+\n+  const auto select_size_fn = [&](size_t size) {\n+    \/\/ Always select a power of 2 within the [min_size, max_size] interval.\n+    return clamp(round_down_power_of_2(size), min_size, max_size);\n+  };\n+\n+  const auto consume_vmem_fn = [&](ZVirtualMemory vmem) {\n+    assert(result.is_null(), \"only consume once\");\n+    assert(min_size <= vmem.size() && vmem.size() <= max_size,\n+      \"Must be %zu <= %zu <= %zu\", min_size, vmem.size(), max_size);\n+    assert(is_power_of_2(vmem.size()), \"Must be power_of_2(%zu)\", vmem.size());\n+\n+    result = vmem;\n+\n+    \/\/ Only require one vmem\n+    return true;\n+  };\n+\n+  scan_remove_vmem<RemovalStrategy::SizeClasses>(min_size, select_size_fn, consume_vmem_fn);\n+\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+  ZVirtualMemory remove_contiguous_power_of_2(size_t min_size, size_t max_size);\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -143,1 +143,14 @@\n-    addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMedium, size, non_blocking_flags);\n+    if (ZPageSizeMediumMin != ZPageSizeMediumMax) {\n+      assert(ZPageSizeMediumEnabled, \"must be enabled\");\n+      \/\/ We attempt a fast medium allocations first. Which will only succeed\n+      \/\/ if a page in the range [ZPageSizeMediumMin, ZPageSizeMediumMax] can\n+      \/\/ be allocated without any expensive syscalls, directly from the cache.\n+      ZAllocationFlags fast_medium_flags = non_blocking_flags;\n+      fast_medium_flags.set_fast_medium();\n+      addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMediumMax, size, fast_medium_flags);\n+    }\n+\n+    if (is_null(addr)) {\n+      addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMediumMax, size, non_blocking_flags);\n+    }\n+\n@@ -149,1 +162,1 @@\n-    addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMedium, size, flags);\n+    addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMediumMax, size, flags);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/z\/zGlobals.hpp\"\n@@ -46,1 +47,1 @@\n-         (_type == ZPageType::medium && size() == ZPageSizeMedium) ||\n+         (_type == ZPageType::medium && ZPageSizeMediumMin <= size() && size() <= ZPageSizeMediumMax) ||\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -187,0 +188,11 @@\n+  void set_satisfied_from_cache_vmem_fast_medium(ZVirtualMemory vmem) {\n+    precond(_satisfied_from_cache_vmem.is_null());\n+    precond(_partial_vmems.is_empty());\n+    precond(ZPageSizeMediumEnabled);\n+    precond(vmem.size() >= ZPageSizeMediumMin);\n+    precond(vmem.size() <= ZPageSizeMediumMax);\n+    precond(is_power_of_2(vmem.size()));\n+\n+    _satisfied_from_cache_vmem = vmem;\n+  }\n+\n@@ -437,0 +449,9 @@\n+    if (_flags.fast_medium()) {\n+      \/\/ A fast medium allocation may have allocated less than the _size field\n+      const ZVirtualMemory vmem = _single_partition_allocation.allocation()->satisfied_from_cache_vmem();\n+      if (!vmem.is_null()) {\n+        \/\/ The allocation has been satisfied, return the satisfied size.\n+        return vmem.size();\n+      }\n+    }\n+\n@@ -537,1 +558,1 @@\n-                 _size,\n+                 size(),\n@@ -743,0 +764,26 @@\n+bool ZPartition::claim_capacity_fast_medium(ZMemoryAllocation* allocation) {\n+  precond(ZPageSizeMediumEnabled);\n+\n+  \/\/ Try to allocate a medium page sized contiguous vmem\n+  const size_t min_size = ZPageSizeMediumMin;\n+  const size_t max_size = ZStressFastMediumPageAllocation ? min_size : ZPageSizeMediumMax;\n+  ZVirtualMemory vmem = _cache.remove_contiguous_power_of_2(min_size, max_size);\n+\n+  if (vmem.is_null()) {\n+    \/\/ Failed to find a contiguous vmem\n+    return false;\n+  }\n+\n+  \/\/ Found a satisfying vmem in the cache\n+  allocation->set_satisfied_from_cache_vmem_fast_medium(vmem);\n+\n+  \/\/ Associate the allocation with this partition.\n+  allocation->set_partition(this);\n+\n+  \/\/ Updated used statistics\n+  increase_used(vmem.size());\n+\n+  \/\/ Success\n+  return true;\n+}\n+\n@@ -1281,2 +1328,6 @@\n-  if (ZPageSizeMedium > 0) {\n-    log_info_p(gc, init)(\"Medium Page Size: %zuM\", ZPageSizeMedium \/ M);\n+  if (ZPageSizeMediumEnabled) {\n+    if (ZPageSizeMediumMin == ZPageSizeMediumMax) {\n+      log_info_p(gc, init)(\"Page Size Medium: %zuM\", ZPageSizeMediumMax \/ M);\n+    } else {\n+      log_info_p(gc, init)(\"Page Size Medium: Range [%zuM, %zuM]\", ZPageSizeMediumMin \/ M, ZPageSizeMediumMax \/ M);\n+    }\n@@ -1462,2 +1513,2 @@\n-    ZStatInc(ZCounterMutatorAllocationRate, size);\n-    ZStatMutatorAllocRate::sample_allocation(size);\n+    ZStatInc(ZCounterMutatorAllocationRate, page->size());\n+    ZStatMutatorAllocRate::sample_allocation(page->size());\n@@ -1591,0 +1642,6 @@\n+  \/\/ Fast medium allocation\n+  if (allocation->flags().fast_medium()) {\n+    return claim_capacity_fast_medium(allocation);\n+  }\n+\n+  \/\/ Round robin single-partition claiming\n@@ -1595,2 +1652,0 @@\n-  \/\/ Round robin single-partition claiming\n-\n@@ -1622,0 +1677,17 @@\n+bool ZPageAllocator::claim_capacity_fast_medium(ZPageAllocation* allocation) {\n+  const uint32_t start_node = allocation->initiating_numa_id();\n+  const uint32_t numa_nodes = ZNUMA::count();\n+\n+  for (uint32_t i = 0; i < numa_nodes; ++i) {\n+    const uint32_t numa_id = (start_node + i) % numa_nodes;\n+    ZPartition& partition = _partitions.get(numa_id);\n+    ZSinglePartitionAllocation* single_partition_allocation = allocation->single_partition_allocation();\n+\n+    if (partition.claim_capacity_fast_medium(single_partition_allocation->allocation())) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n@@ -2079,0 +2151,2 @@\n+  assert(allocation->size() == vmem.size(), \"Must be %zu == %zu\", allocation->size(), vmem.size());\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":81,"deletions":7,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+  bool claim_capacity_fast_medium(ZMemoryAllocation* allocation);\n@@ -177,0 +178,1 @@\n+  bool claim_capacity_fast_medium(ZPageAllocation* allocation);\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-                                                         size_t page_size,\n+                                                         size_t max_page_size,\n@@ -50,1 +50,1 @@\n-    _page_size(page_size),\n+    _max_page_size(max_page_size),\n@@ -53,1 +53,1 @@\n-    _page_fragmentation_limit((size_t)(page_size * (fragmentation_limit \/ 100))),\n+    _page_fragmentation_limit((size_t)(_max_page_size * (_fragmentation_limit \/ 100))),\n@@ -61,1 +61,1 @@\n-  return _page_type == ZPageType::medium && _page_size == 0;\n+  return _page_type == ZPageType::medium && !ZPageSizeMediumEnabled;\n@@ -69,0 +69,7 @@\n+size_t ZRelocationSetSelectorGroup::partition_index(const ZPage* page) const {\n+  const size_t partition_size = page->size() >> NumPartitionsShift;\n+  const int partition_size_shift = log2i_exact(partition_size);\n+\n+  return page->live_bytes() >> partition_size_shift;\n+}\n+\n@@ -71,4 +78,0 @@\n-  const size_t npartitions_shift = 11;\n-  const size_t npartitions = (size_t)1 << npartitions_shift;\n-  const size_t partition_size = _page_size >> npartitions_shift;\n-  const int partition_size_shift = log2i_exact(partition_size);\n@@ -77,1 +80,1 @@\n-  int partitions[npartitions] = { \/* zero initialize *\/ };\n+  int partitions[NPartitions] = { \/* zero initialize *\/ };\n@@ -82,1 +85,1 @@\n-    const size_t index = page->live_bytes() >> partition_size_shift;\n+    const size_t index = partition_index(page);\n@@ -88,1 +91,1 @@\n-  for (size_t i = 0; i < npartitions; i++) {\n+  for (size_t i = 0; i < NPartitions; i++) {\n@@ -101,1 +104,1 @@\n-    const size_t index = page->live_bytes() >> partition_size_shift;\n+    const size_t index = partition_index(page);\n@@ -137,1 +140,1 @@\n-    const int to = (int)ceil(from_live_bytes \/ (double)(_page_size - _object_size_limit));\n+    const int to = (int)ceil(from_live_bytes \/ (double)(_max_page_size - _object_size_limit));\n@@ -214,2 +217,2 @@\n-    _medium(\"Medium\", ZPageType::medium, ZPageSizeMedium, ZObjectSizeLimitMedium, fragmentation_limit),\n-    _large(\"Large\", ZPageType::large, 0 \/* page_size *\/, 0 \/* object_size_limit *\/, fragmentation_limit),\n+    _medium(\"Medium\", ZPageType::medium, ZPageSizeMediumMax, ZObjectSizeLimitMedium, fragmentation_limit),\n+    _large(\"Large\", ZPageType::large, 0 \/* max_page_size *\/, 0 \/* object_size_limit *\/, fragmentation_limit),\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.cpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+  static constexpr int NumPartitionsShift = 11;\n+  static constexpr int NPartitions = int(1) << NumPartitionsShift;\n+\n@@ -83,1 +86,1 @@\n-  const size_t                     _page_size;\n+  const size_t                     _max_page_size;\n@@ -94,0 +97,2 @@\n+\n+  size_t partition_index(const ZPage* page) const;\n@@ -97,0 +102,2 @@\n+  bool pre_filter_page(const ZPage* page, size_t live_bytes) const;\n+\n@@ -100,1 +107,1 @@\n-                              size_t page_size,\n+                              size_t max_page_size,\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/z\/zGlobals.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -72,0 +74,31 @@\n+inline bool ZRelocationSetSelectorGroup::pre_filter_page(const ZPage* page, size_t live_bytes) const {\n+  if (page->is_small()) {\n+    \/\/ Small pages are always the same size, so we can simply compare the\n+    \/\/ garbage pre-calculated _page_fragmentation_limit.\n+    assert(page->size() == ZPageSizeSmall, \"Unexpected small page size %zu\", page->size());\n+\n+    const size_t garbage = ZPageSizeSmall - live_bytes;\n+\n+    return garbage > _page_fragmentation_limit;\n+  }\n+\n+  if (page->is_medium()) {\n+    \/\/ Medium pages may have different sizes, so we can recalculate the page\n+    \/\/ fragmentation limit for a specific page by multiplying pre-calculated\n+    \/\/ _page_fragmentation_limit (calculated using the max page size) by the\n+    \/\/ fraction the specific page size is of the max page size.\n+    \/\/ Because the page sizes are always a power of two we can rewrite this\n+    \/\/ using log2 and bit-shift.\n+    const size_t size = page->size();\n+    const int shift = ZPageSizeMediumShift - log2i_exact(size);\n+    const size_t page_fragmentation_limit = _page_fragmentation_limit >> shift;\n+\n+    const size_t garbage = size - live_bytes;\n+\n+    return garbage > page_fragmentation_limit;\n+  }\n+\n+  \/\/ Large pages are never relocated\n+  return false;\n+}\n+\n@@ -73,1 +106,0 @@\n-  const size_t size = page->size();\n@@ -75,1 +107,0 @@\n-  const size_t garbage = size - live;\n@@ -78,1 +109,1 @@\n-  if (!page->is_large() && garbage > _page_fragmentation_limit) {\n+  if (pre_filter_page(page, live)) {\n@@ -84,0 +115,1 @@\n+  const size_t size = page->size();\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.inline.hpp","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1534,1 +1534,1 @@\n-  if (ZPageSizeMedium != 0) {\n+  if (ZPageSizeMediumEnabled) {\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,0 +107,7 @@\n+  product(bool, ZUseMediumPageSizeRange, true, DIAGNOSTIC,                  \\\n+          \"Allow multiple medium page sizes\")                               \\\n+                                                                            \\\n+  product(bool, ZStressFastMediumPageAllocation, false, DIAGNOSTIC,         \\\n+          \"Always use the minimum medium page size for fast medium page \"   \\\n+          \"allocations\")                                                    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/z\/z_globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.z;\n+\n+\/**\n+ * @test TestZMediumPageSizes\n+ * @requires vm.gc.Z\n+ * @summary Test TestZMediumPageSizes heap reservation \/ commits interactions.\n+ * @library \/ \/test\/lib\n+ * @run driver gc.z.TestZMediumPageSizes\n+ *\/\n+\n+import static gc.testlibrary.Allocation.blackHole;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jtreg.SkippedException;\n+\n+public class TestZMediumPageSizes {\n+    private static final int XmxInM = 1024;\n+    private static final int XmsInM = 512;\n+    static class Test {\n+        private static final int K = 1024;\n+        private static final int M = 1024 * K;\n+        private static final int SMALL_PAGE_SIZE = 2 * M;\n+        private static final int SMALL_OBJECTS_PER_PAGE = 20;\n+        private static final int SMALL_OBJECT_SIZE = SMALL_PAGE_SIZE \/ SMALL_OBJECTS_PER_PAGE;\n+        private static final int MEDIUM_OBJECT_SIZE = 3 * M;\n+        private static final int CHUNK_COUNT = 32;\n+        private static final int CHUNK_LENGTH = SMALL_OBJECTS_PER_PAGE * 3;\n+        private static final int ITERATIONS = 10;\n+\n+        public static void main(String[] args) throws Exception {\n+            for (int page = 0; page < ITERATIONS; ++page) {\n+                var keep = new ArrayList<byte[]>();\n+                try {\n+                    System.gc();\n+                    for (;;) {\n+                        \/\/ Allocate objects on small pages until we're unable to\n+                        keep.add(new byte[SMALL_OBJECT_SIZE]);\n+                    }\n+                } catch (OutOfMemoryError oome) {\n+                    \/\/ Assume that most small allocations were allocated in\n+                    \/\/ consecutive addresses. By making CHUNK_LENGTH consecutive\n+                    \/\/ number of small objects eligible for collection, at least\n+                    \/\/ CHUNK_LENGTH - 1 pages should get eligible for relocation\n+                    \/\/ and be returned to the mapped cache. We do this for\n+                    \/\/ CHUNK_COUNT number of chunks which should ensure that\n+                    \/\/ there is enough free memory to allocate a full sized\n+                    \/\/ medium page. These chunks are spread out, so as not to be\n+                    \/\/ consecutive, so that a full sized medium page can only be\n+                    \/\/ created harvesting some number of smaller memory chunks.\n+                    for (int i = 0; i < CHUNK_COUNT; i++) {\n+                        for (int j = 0; j < CHUNK_LENGTH; j++) {\n+                            keep.set(2 * i * CHUNK_LENGTH + j, null);\n+                        }\n+                    }\n+\n+                    \/\/ Reclaim memory from pages\n+                    System.gc();\n+\n+                    \/\/ Allocate a new medium page (may happen through flush\/harvest)\n+                    blackHole(new byte[MEDIUM_OBJECT_SIZE]);\n+                }\n+\n+                blackHole(keep);\n+            }\n+\n+        }\n+    }\n+\n+    private static OutputAnalyzer createAndExecuteJava(String... extraOptions) throws Exception {\n+        final var options = new ArrayList<String>(List.of(\n+            \"-XX:+UseZGC\",\n+            \"-Xms\" + XmsInM + \"M\",\n+            \"-Xmx\" + XmxInM + \"M\",\n+            \"-Xlog:gc,gc+init,gc+heap=debug\"));\n+        Collections.addAll(options, extraOptions);\n+        options.add(Test.class.getName());\n+        OutputAnalyzer oa = ProcessTools\n+                .executeTestJava(options)\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .shouldHaveExitValue(0);\n+        return oa;\n+    }\n+\n+    private static void runTestDefault() throws Exception  {\n+        var oa = createAndExecuteJava(\"-XX:+ZUseMediumPageSizeRange\");\n+        oa.shouldContain(\"Page Size Medium: Range\");\n+        oa.shouldNotContain(\"Mapped Cache Harvested\");\n+    }\n+\n+    private static void runTestFixedPageSize() throws Exception {\n+        var oa = createAndExecuteJava(\"-XX:-ZUseMediumPageSizeRange\");\n+        oa.shouldNotContain(\"Page Size Medium: Range\");\n+        oa.shouldContain(\"Mapped Cache Harvested\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        runTestDefault();\n+        runTestFixedPageSize();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestZMediumPageSizes.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"}]}