{"files":[{"patch":"@@ -315,0 +315,12 @@\n+    \/**\n+     * Submits the given task to the given executor. If the scheduler is a\n+     * ForkJoinPool then the task is first adapted to a ForkJoinTask.\n+     *\/\n+    private void submit(Executor executor, Runnable task) {\n+        if (executor instanceof ForkJoinPool pool) {\n+            pool.submit(ForkJoinTask.adapt(task));\n+        } else {\n+            executor.execute(task);\n+        }\n+    }\n+\n@@ -335,1 +347,1 @@\n-                        scheduler.execute(runContinuation);\n+                        submit(scheduler, runContinuation);\n@@ -340,1 +352,1 @@\n-                    scheduler.execute(runContinuation);\n+                    submit(scheduler, runContinuation);\n@@ -1535,1 +1547,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-        volatile Thread parked; \/\/ Set to this thread when parked, else null\n+        final Thread thread;\n@@ -282,1 +282,1 @@\n-            seed = Thread.currentThread().threadId();\n+            seed = (thread = Thread.currentThread()).threadId();\n@@ -332,0 +332,1 @@\n+        p.item = item;\n@@ -334,2 +335,1 @@\n-        Object offered = null;                   \/\/ for cleanup\n-        Object v = null;\n+        Object v;                                \/\/ the match\n@@ -347,1 +347,0 @@\n-                    Thread w;\n@@ -350,2 +349,2 @@\n-                    if (i == 0 && (w = q.parked) != null)\n-                        LockSupport.unpark(w);\n+                    if (i == 0)\n+                        LockSupport.unpark(q.thread);\n@@ -369,15 +368,13 @@\n-            else {                               \/\/ try offer\n-                if (offered == null)\n-                    offered = p.item = item;\n-                if (ENTRY.compareAndSet(s, null, p)) {\n-                    boolean tryCancel;           \/\/ true if interrupted\n-                    Thread t = Thread.currentThread();\n-                    if (!(tryCancel = t.isInterrupted()) && ncpu > 1 &&\n-                        (i != 0 ||               \/\/ check for busy VTs\n-                         (!ForkJoinWorkerThread.hasKnownQueuedWork()))) {\n-                        for (int j = SPINS; j > 0; --j) {\n-                            if ((v = p.match) != null) {\n-                                MATCH.set(p, null);\n-                                break outer;     \/\/ spin wait\n-                            }\n-                            Thread.onSpinWait();\n+            else if (ENTRY.compareAndSet(s, null, p)) { \/\/ try offer\n+                boolean tryCancel = false;\n+                for (long ns = 1L;;) {\n+                    if (p.match == null && !tryCancel) {\n+                        if ((deadline != 0L &&\n+                             (ns = deadline - System.nanoTime()) <= 0L) ||\n+                            Thread.currentThread().isInterrupted())\n+                            tryCancel = true;    \/\/ cancel unless match\n+                        else if (ncpu > 1 &&\n+                                 (i != 0 ||      \/\/ check for busy VTs\n+                                  (!ForkJoinWorkerThread.hasKnownQueuedWork()))) {\n+                            for (int j = SPINS; p.match == null && j > 0; --j)\n+                                Thread.onSpinWait();\n@@ -386,21 +383,13 @@\n-                    for (long ns = 1L;;) {       \/\/ block or cancel offer\n-                        if ((v = p.match) != null) {\n-                            MATCH.set(p, null);\n-                            break outer;\n-                        }\n-                        if (i == 0 && !tryCancel &&\n-                            (deadline == 0L ||\n-                             ((ns = deadline - System.nanoTime()) > 0L))) {\n-                            p.parked = t;        \/\/ emable unpark and recheck\n-                            if (p.match == null) {\n-                                if (deadline == 0L)\n-                                    LockSupport.park(this);\n-                                else\n-                                    LockSupport.parkNanos(this, ns);\n-                                tryCancel = t.isInterrupted();\n-                            }\n-                            p.parked = null;\n-                        }\n-                        else if (ENTRY.compareAndSet(s, p, null)) { \/\/ cancel\n-                            offered = p.item = null;\n-                            if (Thread.interrupted())\n+                    if ((v = MATCH.getAndSet(p, null)) != null)\n+                        break outer;\n+                    else if (!tryCancel && i == 0) {\n+                        if (deadline == 0L)\n+                            LockSupport.park(this);\n+                        else\n+                            LockSupport.parkNanos(this, ns);\n+                    }\n+                    else if (ENTRY.compareAndSet(s, p, null)) { \/\/ cancel\n+                        boolean interrupted = Thread.interrupted();\n+                        if (interrupted || ns <= 0L) {\n+                            p.item = null;\n+                            if (interrupted)\n@@ -408,1 +397,1 @@\n-                            if (deadline != 0L && ns <= 0L)\n+                            else\n@@ -410,0 +399,2 @@\n+                        }\n+                        else {\n@@ -419,1 +410,1 @@\n-                            continue outer;\n+                            break;\n@@ -425,2 +416,1 @@\n-        if (offered != null)                     \/\/ cleanup\n-            p.item = null;\n+        p.item = null;                           \/\/ cleanup\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Exchanger.java","additions":37,"deletions":47,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -588,4 +588,1 @@\n-     *    activation (phase change). We distinguish the cases by\n-     *    further signalling only if the task is an InterruptibleTask\n-     *    (see below), which are the only supported forms of task that\n-     *    may do so.\n+     *    activation (phase change).\n@@ -1283,3 +1280,1 @@\n-            if ((a = array) != null && (cap = a.length) > 0 && \/\/ else disabled\n-                task != null) {\n-                int pk = task.noUserHelp() + 1;             \/\/ prev slot offset\n+            if ((a = array) != null && (cap = a.length) > 0) { \/\/ else disabled\n@@ -1293,1 +1288,1 @@\n-                    if (room == 0)                          \/\/ resize\n+                    if (room == 0) {                        \/\/ resize\n@@ -1295,0 +1290,2 @@\n+                        a = null;\n+                    }\n@@ -1300,3 +1297,4 @@\n-                if ((room == 0 || a[m & (s - pk)] == null) &&\n-                    pool != null)\n-                    pool.signalWork();   \/\/ may have appeared empty\n+                if (pool != null &&\n+                    (a == null ||                \/\/ always signal on resize\n+                     U.getReferenceAcquire(a, slotOffset(m & (s - 1))) == null))\n+                    pool.signalWork(a, m & s);   \/\/ may have appeared empty\n@@ -1861,1 +1859,0 @@\n-            signalWork();                  \/\/ possibly replace\n@@ -1863,0 +1860,1 @@\n+            signalWork(null, 0);           \/\/ possibly replace\n@@ -1869,1 +1867,2 @@\n-     * Releases an idle worker, or creates one if not enough exist.\n+     * Releases an idle worker, or creates one if not enough exist,\n+     * giving up if array a is nonnull and task at a[k] already taken.\n@@ -1871,1 +1870,1 @@\n-    final void signalWork() {\n+    final void signalWork(ForkJoinTask<?>[] a, int k) {\n@@ -1887,1 +1886,1 @@\n-                nc = ((c + TC_UNIT) & TC_MASK);\n+                nc = ((c + TC_UNIT) & TC_MASK) | ac;\n@@ -1892,2 +1891,4 @@\n-                nc = (v.stackPred & LMASK) | (c & TC_MASK);\n-            if (c == (c = compareAndExchangeCtl(c, nc | ac))) {\n+                nc = (v.stackPred & LMASK) | (c & TC_MASK) | ac;\n+            if (a != null && k < a.length && k >= 0 && a[k] == null)\n+                break;\n+            if (c == (c = ctl) && c == (c = compareAndExchangeCtl(c, nc))) {\n@@ -1978,2 +1979,2 @@\n-            int fifo = w.config & FIFO, nsteals = 0, src = -1;\n-            for (;;) {\n+            int fifo = w.config & FIFO, nsteals = 0;\n+            rescan: for (boolean propagated = false;;) {\n@@ -1985,3 +1986,2 @@\n-                boolean rescan = false;\n-                scan: for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n-                    int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n+                for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n+                    int j, m; WorkQueue q; ForkJoinTask<?>[] a;\n@@ -1989,3 +1989,4 @@\n-                        (a = q.array) != null && (cap = a.length) > 0) {\n-                        for (int m = cap - 1, pb = -1, b = q.base;;) {\n-                            ForkJoinTask<?> t; long k;\n+                        (a = q.array) != null && (m = a.length - 1) >= 0) {\n+                        boolean ran = false;\n+                        for (int pb = -1, b = q.base;;) {\n+                            ForkJoinTask<?> t; long k; int bk;\n@@ -1993,8 +1994,12 @@\n-                                a, k = slotOffset(m & b));\n-                            if (b != (b = q.base) || t == null ||\n-                                !U.compareAndSetReference(a, k, t, null)) {\n-                                if (a[b & m] == null) {\n-                                    if (rescan)           \/\/ end of run\n-                                        break scan;\n-                                    if (a[(b + 1) & m] == null &&\n-                                        a[(b + 2) & m] == null) {\n+                                a, k = slotOffset(bk = b & m));\n+                            int nb = b + 1, nk = nb & m;\n+                            if (b != (b = q.base))\n+                               ;                          \/\/ inconsistent\n+                            else if (t == null ||\n+                                     !U.compareAndSetReference(a, k, t, null)) {\n+                                if (q.array != a)         \/\/ resized\n+                                    continue rescan;\n+                                if (b == (b = q.base) && a[bk] == null) {\n+                                    if (a[nk] == null && a[(b + 2) & m] == null) {\n+                                        if (ran)          \/\/ end of run\n+                                            continue rescan;\n@@ -2003,4 +2008,2 @@\n-                                    if (pb == (pb = b)) { \/\/ track progress\n-                                        rescan = true;    \/\/ stalled; reorder scan\n-                                        break scan;\n-                                    }\n+                                    if (pb == (pb = b))   \/\/ track progress\n+                                        continue rescan;  \/\/ stalled; reorder scan\n@@ -2010,2 +2013,1 @@\n-                                boolean propagate;\n-                                int nb = q.base = b + 1, prevSrc = src;\n+                                q.base = nb;\n@@ -2013,6 +2015,6 @@\n-                                w.source = src = j;       \/\/ volatile\n-                                rescan = true;\n-                                int nh = t.noUserHelp();\n-                                if (propagate =\n-                                    (prevSrc != src || nh != 0) && a[nb & m] != null)\n-                                    signalWork();\n+                                w.source = j;             \/\/ volatile\n+                                ran = true;\n+                                if ((!propagated || (j & 1) == 0) && a[nk] != null) {\n+                                    propagated = true;\n+                                    signalWork(a, nk);\n+                                }\n@@ -2020,2 +2022,3 @@\n-                                if ((b = q.base) != nb && !propagate)\n-                                    break scan;          \/\/ reduce interference\n+                                b = q.base;               \/\/ refresh\n+                                if ((a = q.array) == null || (m = a.length - 1) < 0)\n+                                    break;\n@@ -2026,5 +2029,3 @@\n-                if (!rescan) {\n-                    if (((phase = deactivate(w, phase)) & IDLE) != 0)\n-                        break;\n-                    src = -1;                            \/\/ re-enable propagation\n-                }\n+                propagated = false;\n+                if (((phase = deactivate(w, phase)) & IDLE) != 0)\n+                    break;\n@@ -2043,2 +2044,0 @@\n-        if (w == null)                        \/\/ currently impossible\n-            return IDLE;\n@@ -2046,25 +2045,27 @@\n-        long pc = ctl, qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n-        int sp = w.stackPred = (int)pc;       \/\/ set ctl stack link\n-        w.phase = p;\n-        if (!compareAndSetCtl(pc, qc))        \/\/ try to enqueue\n-            return w.phase = phase;           \/\/ back out on possible signal\n-        int ac = (short)(qc >>> RC_SHIFT), n; long e; WorkQueue[] qs;\n-        if (((e = runState) & STOP) != 0L ||\n-            ((e & SHUTDOWN) != 0L && ac == 0 && quiescent() > 0) ||\n-            (qs = queues) == null || (n = qs.length) <= 0)\n-            return IDLE;                      \/\/ terminating\n-\n-        for (int prechecks = Math.min(ac, 2), \/\/ reactivation threshold\n-             k = Math.max(n + (n << 1), SPIN_WAITS << 1);;) {\n-            WorkQueue q; int cap; ForkJoinTask<?>[] a; long c;\n-            if (w.phase == activePhase)\n-                return activePhase;\n-            if (--k < 0)\n-                return awaitWork(w, p);       \/\/ block, drop, or exit\n-            if ((q = qs[k & (n - 1)]) == null)\n-                Thread.onSpinWait();\n-            else if ((a = q.array) != null && (cap = a.length) > 0 &&\n-                     a[q.base & (cap - 1)] != null && --prechecks < 0 &&\n-                     (int)(c = ctl) == activePhase &&\n-                     compareAndSetCtl(c, (sp & LMASK) | ((c + RC_UNIT) & UMASK)))\n-                return w.phase = activePhase; \/\/ reactivate\n+        if (w != null) {                      \/\/ always true\n+            long e;\n+            long pc = ctl, qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n+            w.stackPred = (int)pc;            \/\/ set ctl stack link\n+            w.phase = p;\n+            if (!compareAndSetCtl(pc, qc))    \/\/ try to enqueue\n+                p = w.phase = phase;          \/\/ back out on possible signal\n+            else if (((e = runState) & STOP) == 0L &&\n+                     ((e & SHUTDOWN) == 0L || (qc >> RC_SHIFT) > 0L ||\n+                      quiescent() <= 0) &&    \/\/ termination checks\n+                     (p = w.phase) != activePhase) {\n+                WorkQueue[] qs = queues;      \/\/ missed signal check\n+                int n = (qs == null) ? 0 : qs.length;\n+                for (int i = 0; i < n; ++i) {\n+                    WorkQueue q; long c;\n+                    if ((q = qs[i]) != null && q.top - q.base > 0) {\n+                        if ((p = w.phase) != activePhase &&\n+                            (int)(c = ctl) == activePhase &&\n+                            compareAndSetCtl(c, ((pc & LMASK) |\n+                                                 ((c + RC_UNIT) & UMASK))))\n+                            p = w.phase = activePhase; \/\/ reactivate\n+                        break;\n+                    }\n+                }\n+                if (p != activePhase)\n+                    p = awaitWork(w, p);      \/\/ block, drop, or exit\n+            }\n@@ -2072,0 +2073,1 @@\n+        return p;\n@@ -2082,2 +2084,3 @@\n-        if (w != null) {\n-            ForkJoinWorkerThread t; long deadline;\n+        int activePhase = p + IDLE, spins = 0;\n+        if ((runState & STOP) == 0L && w != null && (p = w.phase) != activePhase) {\n+            ForkJoinWorkerThread t;\n@@ -2085,9 +2088,13 @@\n-                t.resetThreadLocals();          \/\/ clear before reactivate\n-            if ((ctl & RC_MASK) > 0L)\n-                deadline = 0L;\n-            else if ((deadline =\n-                      (((w.source != INVALID_ID) ? keepAlive : TIMEOUT_SLOP)) +\n-                      System.currentTimeMillis()) == 0L)\n-                deadline = 1L;                 \/\/ avoid zero\n-            int activePhase = p + IDLE;\n-            if ((p = w.phase) != activePhase && (runState & STOP) == 0L) {\n+                t.resetThreadLocals();         \/\/ clear before reactivate\n+            long deadline = 0L, c = ctl;\n+            if ((int)c == activePhase) {       \/\/ w is at ctl top\n+                if ((c >> RC_SHIFT) <= 0L &&\n+                    (deadline =                \/\/ use timeout\n+                     (((w.source != INVALID_ID) ? keepAlive : TIMEOUT_SLOP)) +\n+                     System.currentTimeMillis()) == 0L)\n+                    deadline = 1L;             \/\/ avoid zero\n+                spins = Math.max(((short)(c >>> TC_SHIFT)) << 2, SPIN_WAITS);\n+                while ((p = w.phase) != activePhase && --spins != 0)\n+                    Thread.onSpinWait();       \/\/ spin at head\n+            }\n+            if (spins == 0) {\n@@ -2596,4 +2603,2 @@\n-                if (reuse == 0) {\n-                    if (probes >= n >> 1)\n-                        reuse = r;                   \/\/ stop prefering free slot\n-                }\n+                if (probes >= 4)                     \/\/ probably nearly full\n+                    reuse = 1;                       \/\/ stop prefering free slot\n@@ -2601,1 +2606,1 @@\n-                    reuse = 0;                       \/\/ probe on collision\n+                    reuse = 0;                       \/\/ collision\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":100,"deletions":95,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.concurrent.ForkJoinTask;\n@@ -45,1 +46,1 @@\n-    public static void main(String[] args) throws Exception {\n+    static void testSubmitExternalCallable() throws Exception {\n@@ -56,0 +57,17 @@\n+\n+    static void testSubmitAdaptedCallable() throws Exception {\n+        try (var pool = new ForkJoinPool(2)) {\n+            for (int i = 0; i < 100_000; i++) {\n+                var future1 = pool.submit(new AwaitCount(i));\n+                var future2 = pool.submit(ForkJoinTask.adapt(noop));\n+                future2.get();\n+                count.set(i + 1);\n+                future1.get();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        testSubmitExternalCallable();\n+        testSubmitAdaptedCallable();\n+    }\n","filename":"test\/jdk\/java\/util\/concurrent\/forkjoin\/Starvation.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"}]}