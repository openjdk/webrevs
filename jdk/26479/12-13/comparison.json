{"files":[{"patch":"@@ -521,1 +521,1 @@\n-     * enqueuing in ctl (see method deactivate).  This \"queue\" is a\n+     * enqueuing in ctl (see method tryDeactivate).  This \"queue\" is a\n@@ -649,7 +649,7 @@\n-     * thread (in deactivate()) uses quiescent() to check for tasks\n-     * that could have been added during a race window that would not\n-     * be accompanied by a signal, in which case re-activating itself\n-     * (or any other worker) to rescan. Method helpQuiesce acts\n-     * similarly but cannot rely on ctl counts to determine that all\n-     * workers are inactive because the caller and any others\n-     * executing helpQuiesce are not included in counts.\n+     * thread uses quiescent() to check for tasks that could have been\n+     * added during a race window that would not be accompanied by a\n+     * signal, in which case re-activating itself (or any other\n+     * worker) to rescan. Method helpQuiesce acts similarly but cannot\n+     * rely on ctl counts to determine that all workers are inactive\n+     * because the caller and any others executing helpQuiesce are not\n+     * included in counts.\n@@ -1258,1 +1258,1 @@\n-            int s = top, b = base, m, cap, room; ForkJoinTask<?>[] a;\n+            int s = top, b = base, m, cap, room; ForkJoinTask<?>[] a, na;\n@@ -1260,1 +1260,2 @@\n-                if ((room = (m = cap - 1) - (s - b)) >= 0) {\n+                int k = (m = cap - 1) & s;\n+                if ((room = m - (s - b)) >= 0) {\n@@ -1262,1 +1263,1 @@\n-                    long pos = slotOffset(m & s);\n+                    long pos = slotOffset(k);\n@@ -1267,2 +1268,2 @@\n-                    if (room == 0 && (a = growArray(a, cap, s)) != null)\n-                        m = a.length - 1;                   \/\/ resize\n+                    if (room == 0 && (na = growArray(a, cap, s)) != null)\n+                        k = ((a = na).length - 1) & s;      \/\/ resize\n@@ -1274,3 +1275,4 @@\n-                if (pool != null && a != null &&\n-                    U.getReferenceAcquire(a, slotOffset(m & (s - 1))) == null)\n-                    pool.signalWork(a, m & s);   \/\/ may have appeared empty\n+                if (pool != null &&\n+                    (room == 0 ||\n+                     U.getReferenceAcquire(a, slotOffset(m & (s - 1))) == null))\n+                    pool.signalWork(a, k);    \/\/ may have appeared empty\n@@ -1975,1 +1977,1 @@\n-            int r = w.stackPred;                          \/\/ seed from registerWorker\n+            int phase = w.phase, r = w.stackPred;         \/\/ seed from registerWorker\n@@ -1978,1 +1980,0 @@\n-            boolean rescan = true;\n@@ -1980,3 +1981,2 @@\n-            while ((rescan || deactivate(w) == 0) && (runState & STOP) == 0L &&\n-                   (qs = queues) != null && (n = qs.length) > 0) {\n-                rescan = false;\n+            while ((runState & STOP) == 0L && (qs = queues) != null &&\n+                   (n = qs.length) > 0) {\n@@ -1985,0 +1985,1 @@\n+                boolean rescan = false;\n@@ -1996,7 +1997,15 @@\n-                            if (q.array != a || q.base != b ||\n-                                U.getReference(a, bp) != t)\n-                                continue;                 \/\/ inconsistent\n-                            if (t == null) {\n-                                if (rescan) {             \/\/ end of run\n-                                    w.nsteals = nsteals;\n-                                    break scan;\n+                            if (q.base == b && U.getReference(a, bp) == t) {\n+                                if (t == null) {\n+                                    if (rescan) {          \/\/ end of run\n+                                        w.nsteals = nsteals;\n+                                        break scan;\n+                                    }\n+                                    if (U.getReference(a, np) != null) {\n+                                        rescan = true;\n+                                        break scan;       \/\/ stalled; reorder scan\n+                                    }\n+                                    if (j < n && q.top - b > 0) {\n+                                        rescan = true;\n+                                        break scan;       \/\/ full check on 2nd sweep\n+                                    }\n+                                    break;                \/\/ probably empty\n@@ -2004,3 +2013,17 @@\n-                                if (U.getReference(a, np) != null) {\n-                                    rescan = true;        \/\/ stalled; reorder scan\n-                                    break scan;\n+                                else if ((phase & IDLE) != 0) \/\/ can't take yet\n+                                    phase = tryReactivate(w, phase);\n+                                else if (U.compareAndSetReference(a, bp, t, null)) {\n+                                    q.base = nb;\n+                                    Object nt = U.getReferenceAcquire(a, np);\n+                                    if (!rescan) {        \/\/ begin run\n+                                        rescan = true;\n+                                        w.source = qid;\n+                                    }\n+                                    ++nsteals;\n+                                    if (nt != null &&     \/\/ confirm a[nk]\n+                                        U.getReference(a, np) == nt)\n+                                        signalWork(a, nk); \/\/ propagate\n+                                    if (fifo != 0)        \/\/ run t & its subtasks\n+                                        w.topLevelExecFifo(t);\n+                                    else\n+                                        w.topLevelExecLifo(t);\n@@ -2008,17 +2031,0 @@\n-                                break;                    \/\/ probably empty\n-                            }\n-                            if (U.compareAndSetReference(a, bp, t, null)) {\n-                                q.base = nb;\n-                                Object nt = U.getReferenceAcquire(a, np);\n-                                if (!rescan) {            \/\/ begin run\n-                                    rescan = true;\n-                                    w.source = qid;\n-                                }\n-                                ++nsteals;\n-                                if (nt != null &&         \/\/ confirm a[nk]\n-                                    U.getReference(a, np) == nt)\n-                                    signalWork(a, nk);    \/\/ propagate\n-                                if (fifo != 0)            \/\/ run t & its subtasks\n-                                    w.topLevelExecFifo(t);\n-                                else\n-                                    w.topLevelExecLifo(t);\n@@ -2029,0 +2035,6 @@\n+                if (!rescan) {\n+                    if ((phase & IDLE) == 0)\n+                        phase = tryDeactivate(w, phase);\n+                    else if (awaitWork(w, phase += IDLE) != 0)\n+                        break;\n+                }\n@@ -2034,1 +2046,1 @@\n-     * Deactivates and awaits signal or termination.\n+     * Tries to deactivate worker, keeping active on contention.\n@@ -2037,1 +2049,2 @@\n-     * @return zero if now active\n+     * @param phase w's current (active) phase\n+     * @return current phase\n@@ -2039,32 +2052,10 @@\n-    private int deactivate(WorkQueue w) {\n-        int idle = 1;\n-        if (w != null) {                        \/\/ always true; hoist checks\n-            int p = w.phase, idlePhase = p | IDLE, activePhase = p + (IDLE << 1);\n-            long pc = ctl, qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n-            w.stackPred = (int)pc;              \/\/ set ctl stack link\n-            w.phase = idlePhase;\n-            if (!compareAndSetCtl(pc, qc)) {    \/\/ try to enqueue\n-                w.phase = p;                    \/\/ back out on contention\n-                idle = 0;\n-            }\n-            WorkQueue[] qs; int n; long e;\n-            if (idle != 0 && ((e = runState) & STOP) == 0 && \/\/ quiescence checks\n-                ((e & SHUTDOWN) == 0L || (qc & RC_MASK) > 0L || quiescent() <= 0) &&\n-                (qs = queues) != null && (n = qs.length) > 1) {\n-                long psp = pc & LMASK;          \/\/ ctl predecessor prefix\n-                for (int i = 1; i < n; ++i) {   \/\/ scan; stagger origins\n-                    WorkQueue q; long c;        \/\/ missed signal check\n-                    if ((q = qs[(activePhase + i) & (n - 1)]) != null &&\n-                        q.top - q.base > 0) {\n-                        if ((idle = w.phase - activePhase) != 0 &&\n-                            (int)(c = ctl) == activePhase &&\n-                            compareAndSetCtl(c, psp | ((c + RC_UNIT) & UMASK))) {\n-                            w.phase = activePhase;\n-                            idle = 0;           \/\/ reactivated\n-                        }                       \/\/ else ineligible or lost race\n-                        break;\n-                    }\n-                }\n-                if (idle != 0 && (idle = w.phase - activePhase) != 0)\n-                    idle = awaitWork(w, activePhase, n);\n-            }\n+    private int tryDeactivate(WorkQueue w, int phase) {\n+        if (w != null) {                          \/\/ always true; hoist checks\n+            long pc; int idlePhase;\n+            w.stackPred = (int)(pc = ctl);        \/\/ set ctl stack link\n+            w.phase = idlePhase = phase | IDLE;   \/\/ try to enqueue\n+            if (compareAndSetCtl(pc, (((phase + (IDLE << 1)) & LMASK) |\n+                                      ((pc - RC_UNIT) & UMASK))))\n+                phase = idlePhase;\n+            else\n+                w.phase = phase;                  \/\/ back out on contention\n@@ -2072,1 +2063,17 @@\n-        return idle;\n+        return phase;\n+    }\n+\n+    \/**\n+     * Reactivates worker w if it is currently top of ctl stack\n+     *\n+     * @param w the work queue\n+     * @param phase w's currently known (idle) phase\n+     * @return currently known phase on exit\n+     *\/\n+    private int tryReactivate(WorkQueue w, int phase) {\n+        int activePhase = phase + IDLE; long c;\n+        if (w != null && (phase = w.phase) != activePhase &&\n+            (int)(c = ctl) == activePhase &&\n+            compareAndSetCtl(c, (w.stackPred & LMASK) | ((c + RC_UNIT) & UMASK)))\n+            phase = w.phase = activePhase;\n+        return phase;\n@@ -2080,1 +2087,0 @@\n-     * @param qsize current size of queues array\n@@ -2083,3 +2089,6 @@\n-    private int awaitWork(WorkQueue w, int activePhase, int qsize) {\n-        int idle = 1;\n-        if ((runState & STOP) == 0L && w != null) {\n+    private int awaitWork(WorkQueue w, int activePhase) {\n+        int idle = 1; long e;\n+        if (((e = runState) & STOP) == 0 &&\n+            ((e & SHUTDOWN) == 0L || quiescent() <= 0) &&\n+            w != null && (idle = w.phase - activePhase) != 0) {\n+            WorkQueue[] qs;\n@@ -2088,0 +2097,2 @@\n+            int n = ((qs = queues) == null) ? 0 : qs.length;\n+            int spins = Math.max((n << 1) | (n - 1), SPIN_WAITS);\n@@ -2089,1 +2100,0 @@\n-            int spins = (qsize << 1) | (qsize - 1); \/\/ approx traversal cost\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":98,"deletions":88,"binary":false,"changes":186,"status":"modified"}]}