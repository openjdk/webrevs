{"files":[{"patch":"@@ -592,1 +592,1 @@\n-     * it invokes awaitWork, that first deactivates (to an IDLE\n+     * it invokes deactivate, that first deactivates (to an IDLE\n@@ -1432,4 +1432,3 @@\n-        \/*\n-         * Two version (lifo and fifo) of top-level execution, split\n-         * across modes to better isolate task dispatch and local\n-         * processing from top-level scheduling.\n+        \/**\n+         * Runs the given task, as well as remaining local tasks, and\n+         * those from the given queue that can be polled without interference.\n@@ -1437,11 +1436,50 @@\n-        final void topLevelExecLifo(ForkJoinTask<?> task) {\n-            while (task != null) {\n-                task.doExec();\n-                task = localPop();\n-            }\n-        }\n-\n-        final void topLevelExecFifo(ForkJoinTask<?> task) {\n-            while (task != null) {\n-                task.doExec();\n-                task = localPoll();\n+        final void topLevelExec(ForkJoinTask<?> task, WorkQueue q, int fifo) {\n+            if (task != null && q != null) {\n+                int stolen = 1;\n+                for (;;) {\n+                    task.doExec();\n+                    task = null;\n+                    int p = top, cap; ForkJoinTask<?>[] a;\n+                    if ((a = array) == null || (cap = a.length) <= 0)\n+                        break;\n+                    if (fifo == 0) {  \/\/ specialized localPop\n+                        int s = p - 1;\n+                        long k = slotOffset((cap - 1) & s);\n+                        if (U.getReference(a, k) != null &&\n+                            (task = (ForkJoinTask<?>)\n+                             U.getAndSetReference(a, k, null)) != null)\n+                            top = s;\n+                    } else {         \/\/ specialized localPoll\n+                        for (int b = base; p - b > 0; ) {\n+                            int nb = b + 1;\n+                            long k = slotOffset((cap - 1) & b);\n+                            if (U.getReference(a, k) != null &&\n+                                (task = (ForkJoinTask<?>)\n+                                 U.getAndSetReference(a, k, null)) != null) {\n+                                base = nb;\n+                                break;\n+                            }\n+                            if (nb == p)\n+                                break;\n+                            while (b == (b = U.getIntAcquire(this, BASE)))\n+                                Thread.onSpinWait();\n+                        }\n+                    }\n+                    if (task == null) { \/\/ one-shot steal attempt\n+                        int qb = q.base, qcap; ForkJoinTask<?>[] qa; long bp;\n+                        if ((qa = q.array) != null && (qcap = qa.length) > 0 &&\n+                            (task = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                qa, bp = slotOffset((qcap - 1) & qb))) != null &&\n+                            q.base == qb &&\n+                            U.compareAndSetReference(qa, bp, task, null)) {\n+                            q.base = qb + 1;\n+                            ++stolen;\n+                        }\n+                        else\n+                            break;\n+                    }\n+                }\n+                nsteals += stolen;\n+                ForkJoinWorkerThread o;\n+                if ((config & CLEAR_TLS) != 0 && (o = owner) != null)\n+                    o.resetThreadLocals();\n@@ -1977,0 +2015,1 @@\n+            WorkQueue[] qs;\n@@ -1978,6 +2017,2 @@\n-            int fifo = (int)config & FIFO;\n-            int nsteals = 0;                              \/\/ shadow w.nsteals\n-            boolean rescan = true;\n-            WorkQueue[] qs; int n;\n-            while ((rescan || (phase = deactivate(w, phase)) != 0) &&\n-                   (runState & STOP) == 0L && (qs = queues) != null &&\n+            int fifo = (int)config & FIFO, rescans = 0, n;\n+            while ((runState & STOP) == 0L && (qs = queues) != null &&\n@@ -1985,1 +2020,0 @@\n-                rescan = false;\n@@ -1988,1 +2022,1 @@\n-                scan: for (int j = -n; j < n; ++j, i += step) { \/\/ 2 passes\n+                scan: for (int j = n; j != 0; --j, i += step) {\n@@ -1991,9 +2025,6 @@\n-                        for (;;) {                        \/\/ poll queue q\n-                            ForkJoinTask<?>[] a; int cap, b, m, nb, nk;\n-                            if ((a = q.array) == null || (cap = a.length) <= 0)\n-                                break;\n-                            long bp = slotOffset((m = cap - 1) & (b = q.base));\n-                            long np = slotOffset(nk = m & (nb = b + 1));\n-                            ForkJoinTask<?> t = (ForkJoinTask<?>)\n-                                U.getReferenceAcquire(a, bp);\n-                            if (q.base != b || U.getReference(a, bp) != t)\n+                        ForkJoinTask<?>[] a; int cap;     \/\/ poll queue\n+                        while ((a = q.array) != null && (cap = a.length) > 0) {\n+                            int b, nb, nk; long bp; ForkJoinTask<?> t;\n+                            t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                a, bp = slotOffset((cap - 1) & (b = q.base)));\n+                            if (q.base != b)\n@@ -2001,0 +2032,1 @@\n+                            long np = slotOffset(nk = (nb = b + 1) & (cap - 1));\n@@ -2002,2 +2034,3 @@\n-                                if (rescan) {             \/\/ end of run\n-                                    w.nsteals = nsteals;\n+                                if (q.array != a)         \/\/ resized\n+                                    continue;\n+                                if (rescans > 0)          \/\/ ran or stalled\n@@ -2005,0 +2038,4 @@\n+                                if (U.getReference(a, np) != null ||\n+                                    (rescans < 0 && q.top - b > 0)) {\n+                                    rescans = 1;          \/\/ may be stalled\n+                                    continue;\n@@ -2006,8 +2043,2 @@\n-                                if (U.getReference(a, np) != null) {\n-                                    rescan = true;\n-                                    break scan;           \/\/ stalled; reorder scan\n-                                }\n-                                if (j >= 0 && q.top - b > 0) {\n-                                    rescan = true;\n-                                    break scan;           \/\/ size check on 2nd pass\n-                                }\n+                                if (U.getReference(a, bp) != null)\n+                                    continue;             \/\/ stale\n@@ -2016,3 +2047,7 @@\n-                            if ((phase & IDLE) != 0)      \/\/ can't take yet\n-                                phase = tryReactivate(w, phase);\n-                            else if (U.compareAndSetReference(a, bp, t, null)) {\n+                            if ((phase & IDLE) != 0 &&\n+                                ((phase = tryReactivate(w, phase)) & IDLE) != 0) {\n+                                rescans = 1;              \/\/ can't take yet\n+                                break scan;\n+                            }\n+                            if (U.getReference(a, bp) == t &&\n+                                U.compareAndSetReference(a, bp, t, null)) {\n@@ -2021,5 +2056,2 @@\n-                                if (!rescan) {            \/\/ begin run\n-                                    rescan = true;\n-                                    w.source = qid;\n-                                }\n-                                ++nsteals;\n+                                w.source = qid;\n+                                rescans = 1;\n@@ -2027,1 +2059,1 @@\n-                                    U.getReference(a, np) == nt)\n+                                    U.getReferenceAcquire(a, np) == nt)\n@@ -2029,4 +2061,1 @@\n-                                if (fifo != 0)            \/\/ run t & its subtasks\n-                                    w.topLevelExecFifo(t);\n-                                else\n-                                    w.topLevelExecLifo(t);\n+                                w.topLevelExec(t, q, fifo);\n@@ -2037,0 +2066,7 @@\n+                int prev;\n+                if (rescans >= 0)\n+                    --rescans;\n+                else if ((phase = deactivate(w, prev = phase)) == 0)\n+                    break;\n+                else if (phase != prev)\n+                    rescans = 0;\n@@ -2042,2 +2078,2 @@\n-     * If active, tries to deactivate worker, keeping active on contention,\n-     * else awaits signal or termination.\n+     * If active, tries to deactivate worker, keeping active on\n+     * contention; else awaits signal or termination\n@@ -2050,13 +2086,26 @@\n-        if ((phase & IDLE) == 0 && w != null) {\n-            int idlePhase = phase | IDLE;\n-            long pc = ctl, e;\n-            long qc = ((phase + (IDLE << 1)) & LMASK) | ((pc - RC_UNIT) & UMASK);\n-            w.stackPred = (int)pc;                \/\/ set ctl stack link\n-            w.phase = idlePhase;                  \/\/ try to enqueue\n-            if (!compareAndSetCtl(pc, qc))\n-                w.phase = phase;                  \/\/ back out on contention\n-            else {\n-                phase = idlePhase;\n-                if ((qc & RC_MASK) <= 0L && ((e = runState) & SHUTDOWN) != 0L &&\n-                    (e & STOP) == 0L)\n-                    quiescent();                  \/\/ check quiescent termination\n+        if (w != null) {                          \/\/ always true; hoist checks\n+            if ((phase & IDLE) == 0) {\n+                int idlePhase = phase | IDLE;\n+                long pc = ctl, e;\n+                long qc = ((phase + (IDLE << 1)) & LMASK) | ((pc - RC_UNIT) & UMASK);\n+                w.stackPred = (int)pc;            \/\/ set ctl stack link\n+                w.phase = idlePhase;              \/\/ try to enqueue\n+                if (!compareAndSetCtl(pc, qc))\n+                    w.phase = phase;              \/\/ back out on contention\n+                else {\n+                    phase = idlePhase;\n+                    if ((qc & RC_MASK) <= 0L && ((e = runState) & SHUTDOWN) != 0L &&\n+                        (e & STOP) == 0L)\n+                        quiescent();              \/\/ may trigger quiescent termination\n+                }\n+            }\n+            else if ((runState & STOP) != 0L)\n+                phase = 0;\n+            else {                                \/\/ spin before blocking\n+                int activePhase = phase + IDLE;\n+                int noise = activePhase | (activePhase >>> 16);\n+                int spins = (SPIN_WAITS << 1) | (noise & (SPIN_WAITS - 1));\n+                while ((phase = w.phase) != activePhase && --spins != 0)\n+                    Thread.onSpinWait();\n+                if (spins == 0 && awaitWork(w, phase = activePhase) != 0)\n+                    phase = 0;\n@@ -2065,2 +2114,0 @@\n-        else\n-            phase = awaitWork(w, phase);\n@@ -2090,2 +2137,2 @@\n-     * @param phase w's currently known (idle) phase\n-     * @return current phase or 0 on exit\n+     * @param activePhase w's next active phase\n+     * @return 0 if now active\n@@ -2093,6 +2140,3 @@\n-    private int awaitWork(WorkQueue w, int phase) {\n-        int idle = 1, activePhase = phase + IDLE;\n-        if ((runState & STOP) == 0L && w != null &&\n-            (idle = w.phase - activePhase) != 0) {\n-            WorkQueue[] qs;\n-            int cfg = w.config;\n+    private int awaitWork(WorkQueue w, int activePhase) {\n+        int idle = 1;\n+        if (w != null) {                      \/\/ always true; hoist checks\n@@ -2100,6 +2144,0 @@\n-            int n = ((qs = queues) == null) ? 0 : qs.length;\n-            int spins = Math.max((n << 1) | (n - 1), SPIN_WAITS);\n-            long deadline = waitTime + System.currentTimeMillis();\n-            if ((cfg & CLEAR_TLS) != 0 &&     \/\/ instanceof check always true\n-                Thread.currentThread() instanceof ForkJoinWorkerThread f)\n-                f.resetThreadLocals();        \/\/ clear while accessing thread state\n@@ -2107,1 +2145,1 @@\n-            for (;;) {\n+            for (long deadline = 0L;;) {\n@@ -2109,5 +2147,0 @@\n-                int s = spins;\n-                while ((idle = w.phase - activePhase) != 0 && --s != 0)\n-                    Thread.onSpinWait();      \/\/ spin before\/between parks\n-                if (idle == 0)\n-                    break;\n@@ -2116,0 +2149,2 @@\n+                if ((idle = w.phase - activePhase) == 0)\n+                    break;\n@@ -2119,1 +2154,4 @@\n-                    if (deadline - System.currentTimeMillis() <= TIMEOUT_SLOP) {\n+                    long now = System.currentTimeMillis();\n+                    if (deadline == 0L)\n+                        deadline = waitTime + now;\n+                    if (deadline - now <= TIMEOUT_SLOP) {\n@@ -2136,1 +2174,1 @@\n-        return (idle == 0) ? activePhase : 0;\n+        return idle;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":133,"deletions":95,"binary":false,"changes":228,"status":"modified"}]}