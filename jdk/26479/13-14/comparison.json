{"files":[{"patch":"@@ -521,1 +521,1 @@\n-     * enqueuing in ctl (see method tryDeactivate).  This \"queue\" is a\n+     * enqueuing in ctl (see method deactivate).  This \"queue\" is a\n@@ -649,7 +649,7 @@\n-     * thread uses quiescent() to check for tasks that could have been\n-     * added during a race window that would not be accompanied by a\n-     * signal, in which case re-activating itself (or any other\n-     * worker) to rescan. Method helpQuiesce acts similarly but cannot\n-     * rely on ctl counts to determine that all workers are inactive\n-     * because the caller and any others executing helpQuiesce are not\n-     * included in counts.\n+     * thread (in deactivate()) uses quiescent() to check for tasks\n+     * that could have been added during a race window that would not\n+     * be accompanied by a signal, in which case re-activating itself\n+     * (or any other worker) to rescan. Method helpQuiesce acts\n+     * similarly but cannot rely on ctl counts to determine that all\n+     * workers are inactive because the caller and any others\n+     * executing helpQuiesce are not included in counts.\n@@ -1980,0 +1980,1 @@\n+            boolean rescan = true;\n@@ -1981,1 +1982,2 @@\n-            while ((runState & STOP) == 0L && (qs = queues) != null &&\n+            while ((rescan || (phase = deactivate(w, phase)) != 0) &&\n+                   (runState & STOP) == 0L && (qs = queues) != null &&\n@@ -1983,0 +1985,1 @@\n+                rescan = false;\n@@ -1985,2 +1988,1 @@\n-                boolean rescan = false;\n-                scan: for (int j = n << 1; j != 0; --j, i += step) { \/\/ 2 sweeps\n+                scan: for (int j = -n; j < n; ++j, i += step) { \/\/ 2 passes\n@@ -1997,15 +1999,6 @@\n-                            if (q.base == b && U.getReference(a, bp) == t) {\n-                                if (t == null) {\n-                                    if (rescan) {          \/\/ end of run\n-                                        w.nsteals = nsteals;\n-                                        break scan;\n-                                    }\n-                                    if (U.getReference(a, np) != null) {\n-                                        rescan = true;\n-                                        break scan;       \/\/ stalled; reorder scan\n-                                    }\n-                                    if (j < n && q.top - b > 0) {\n-                                        rescan = true;\n-                                        break scan;       \/\/ full check on 2nd sweep\n-                                    }\n-                                    break;                \/\/ probably empty\n+                            if (q.base != b || U.getReference(a, bp) != t)\n+                                continue;                 \/\/ inconsistent\n+                            if (t == null) {\n+                                if (rescan) {             \/\/ end of run\n+                                    w.nsteals = nsteals;\n+                                    break scan;\n@@ -2013,17 +2006,3 @@\n-                                else if ((phase & IDLE) != 0) \/\/ can't take yet\n-                                    phase = tryReactivate(w, phase);\n-                                else if (U.compareAndSetReference(a, bp, t, null)) {\n-                                    q.base = nb;\n-                                    Object nt = U.getReferenceAcquire(a, np);\n-                                    if (!rescan) {        \/\/ begin run\n-                                        rescan = true;\n-                                        w.source = qid;\n-                                    }\n-                                    ++nsteals;\n-                                    if (nt != null &&     \/\/ confirm a[nk]\n-                                        U.getReference(a, np) == nt)\n-                                        signalWork(a, nk); \/\/ propagate\n-                                    if (fifo != 0)        \/\/ run t & its subtasks\n-                                        w.topLevelExecFifo(t);\n-                                    else\n-                                        w.topLevelExecLifo(t);\n+                                if (U.getReference(a, np) != null) {\n+                                    rescan = true;\n+                                    break scan;           \/\/ stalled; reorder scan\n@@ -2031,0 +2010,23 @@\n+                                if (j >= 0 && q.top - b > 0) {\n+                                    rescan = true;\n+                                    break scan;           \/\/ size check on 2nd pass\n+                                }\n+                                break;                    \/\/ probably empty\n+                            }\n+                            if ((phase & IDLE) != 0)      \/\/ can't take yet\n+                                phase = tryReactivate(w, phase);\n+                            else if (U.compareAndSetReference(a, bp, t, null)) {\n+                                q.base = nb;\n+                                Object nt = U.getReferenceAcquire(a, np);\n+                                if (!rescan) {            \/\/ begin run\n+                                    rescan = true;\n+                                    w.source = qid;\n+                                }\n+                                ++nsteals;\n+                                if (nt != null &&         \/\/ confirm a[nk]\n+                                    U.getReference(a, np) == nt)\n+                                    signalWork(a, nk);    \/\/ propagate\n+                                if (fifo != 0)            \/\/ run t & its subtasks\n+                                    w.topLevelExecFifo(t);\n+                                else\n+                                    w.topLevelExecLifo(t);\n@@ -2035,6 +2037,0 @@\n-                if (!rescan) {\n-                    if ((phase & IDLE) == 0)\n-                        phase = tryDeactivate(w, phase);\n-                    else if (awaitWork(w, phase += IDLE) != 0)\n-                        break;\n-                }\n@@ -2046,1 +2042,2 @@\n-     * Tries to deactivate worker, keeping active on contention.\n+     * If active, tries to deactivate worker, keeping active on contention,\n+     * else awaits signal or termination.\n@@ -2049,2 +2046,2 @@\n-     * @param phase w's current (active) phase\n-     * @return current phase\n+     * @param phase w's currently known phase\n+     * @return current phase or 0 on exit\n@@ -2052,9 +2049,8 @@\n-    private int tryDeactivate(WorkQueue w, int phase) {\n-        if (w != null) {                          \/\/ always true; hoist checks\n-            long pc; int idlePhase;\n-            w.stackPred = (int)(pc = ctl);        \/\/ set ctl stack link\n-            w.phase = idlePhase = phase | IDLE;   \/\/ try to enqueue\n-            if (compareAndSetCtl(pc, (((phase + (IDLE << 1)) & LMASK) |\n-                                      ((pc - RC_UNIT) & UMASK))))\n-                phase = idlePhase;\n-            else\n+    private int deactivate(WorkQueue w, int phase) {\n+        if ((phase & IDLE) == 0 && w != null) {\n+            int idlePhase = phase | IDLE;\n+            long pc = ctl, e;\n+            long qc = ((phase + (IDLE << 1)) & LMASK) | ((pc - RC_UNIT) & UMASK);\n+            w.stackPred = (int)pc;                \/\/ set ctl stack link\n+            w.phase = idlePhase;                  \/\/ try to enqueue\n+            if (!compareAndSetCtl(pc, qc))\n@@ -2062,0 +2058,6 @@\n+            else {\n+                phase = idlePhase;\n+                if ((qc & RC_MASK) <= 0L && ((e = runState) & SHUTDOWN) != 0L &&\n+                    (e & STOP) == 0L)\n+                    quiescent();                  \/\/ check quiescent termination\n+            }\n@@ -2063,0 +2065,2 @@\n+        else\n+            phase = awaitWork(w, phase);\n@@ -2086,2 +2090,2 @@\n-     * @param activePhase w's next active phase\n-     * @return zero if now active\n+     * @param phase w's currently known (idle) phase\n+     * @return current phase or 0 on exit\n@@ -2089,5 +2093,4 @@\n-    private int awaitWork(WorkQueue w, int activePhase) {\n-        int idle = 1; long e;\n-        if (((e = runState) & STOP) == 0 &&\n-            ((e & SHUTDOWN) == 0L || quiescent() <= 0) &&\n-            w != null && (idle = w.phase - activePhase) != 0) {\n+    private int awaitWork(WorkQueue w, int phase) {\n+        int idle = 1, activePhase = phase + IDLE;\n+        if ((runState & STOP) == 0L && w != null &&\n+            (idle = w.phase - activePhase) != 0) {\n@@ -2133,1 +2136,1 @@\n-        return idle;\n+        return (idle == 0) ? activePhase : 0;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":72,"deletions":69,"binary":false,"changes":141,"status":"modified"}]}