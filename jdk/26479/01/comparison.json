{"files":[{"patch":"@@ -315,0 +315,12 @@\n+    \/**\n+     * Submits the given task to the given executor. If the scheduler is a\n+     * ForkJoinPool then the task is first adapted to a ForkJoinTask.\n+     *\/\n+    private void submit(Executor executor, Runnable task) {\n+        if (executor instanceof ForkJoinPool pool) {\n+            pool.submit(ForkJoinTask.adapt(task));\n+        } else {\n+            executor.execute(task);\n+        }\n+    }\n+\n@@ -335,1 +347,1 @@\n-                        scheduler.execute(runContinuation);\n+                        submit(scheduler, runContinuation);\n@@ -340,1 +352,1 @@\n-                    scheduler.execute(runContinuation);\n+                    submit(scheduler, runContinuation);\n@@ -1535,1 +1547,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-        volatile Thread parked; \/\/ Set to this thread when parked, else null\n+        final Thread thread;\n@@ -282,1 +282,1 @@\n-            seed = Thread.currentThread().threadId();\n+            seed = (thread = Thread.currentThread()).threadId();\n@@ -332,0 +332,1 @@\n+        p.item = item;\n@@ -334,2 +335,1 @@\n-        Object offered = null;                   \/\/ for cleanup\n-        Object v = null;\n+        Object v;                                \/\/ the match\n@@ -347,1 +347,0 @@\n-                    Thread w;\n@@ -350,2 +349,2 @@\n-                    if (i == 0 && (w = q.parked) != null)\n-                        LockSupport.unpark(w);\n+                    if (i == 0)\n+                        LockSupport.unpark(q.thread);\n@@ -369,15 +368,13 @@\n-            else {                               \/\/ try offer\n-                if (offered == null)\n-                    offered = p.item = item;\n-                if (ENTRY.compareAndSet(s, null, p)) {\n-                    boolean tryCancel;           \/\/ true if interrupted\n-                    Thread t = Thread.currentThread();\n-                    if (!(tryCancel = t.isInterrupted()) && ncpu > 1 &&\n-                        (i != 0 ||               \/\/ check for busy VTs\n-                         (!ForkJoinWorkerThread.hasKnownQueuedWork()))) {\n-                        for (int j = SPINS; j > 0; --j) {\n-                            if ((v = p.match) != null) {\n-                                MATCH.set(p, null);\n-                                break outer;     \/\/ spin wait\n-                            }\n-                            Thread.onSpinWait();\n+            else if (ENTRY.compareAndSet(s, null, p)) { \/\/ try offer\n+                boolean tryCancel = false;\n+                for (long ns = 1L;;) {\n+                    if (p.match == null && !tryCancel) {\n+                        if ((deadline != 0L &&\n+                             (ns = deadline - System.nanoTime()) <= 0L) ||\n+                            Thread.currentThread().isInterrupted())\n+                            tryCancel = true;    \/\/ cancel unless match\n+                        else if (ncpu > 1 &&\n+                                 (i != 0 ||      \/\/ check for busy VTs\n+                                  (!ForkJoinWorkerThread.hasKnownQueuedWork()))) {\n+                            for (int j = SPINS; p.match == null && j > 0; --j)\n+                                Thread.onSpinWait();\n@@ -386,21 +383,13 @@\n-                    for (long ns = 1L;;) {       \/\/ block or cancel offer\n-                        if ((v = p.match) != null) {\n-                            MATCH.set(p, null);\n-                            break outer;\n-                        }\n-                        if (i == 0 && !tryCancel &&\n-                            (deadline == 0L ||\n-                             ((ns = deadline - System.nanoTime()) > 0L))) {\n-                            p.parked = t;        \/\/ emable unpark and recheck\n-                            if (p.match == null) {\n-                                if (deadline == 0L)\n-                                    LockSupport.park(this);\n-                                else\n-                                    LockSupport.parkNanos(this, ns);\n-                                tryCancel = t.isInterrupted();\n-                            }\n-                            p.parked = null;\n-                        }\n-                        else if (ENTRY.compareAndSet(s, p, null)) { \/\/ cancel\n-                            offered = p.item = null;\n-                            if (Thread.interrupted())\n+                    if ((v = MATCH.getAndSet(p, null)) != null)\n+                        break outer;\n+                    else if (!tryCancel && i == 0) {\n+                        if (deadline == 0L)\n+                            LockSupport.park(this);\n+                        else\n+                            LockSupport.parkNanos(this, ns);\n+                    }\n+                    else if (ENTRY.compareAndSet(s, p, null)) { \/\/ cancel\n+                        boolean interrupted = Thread.interrupted();\n+                        if (interrupted || ns <= 0L) {\n+                            p.item = null;\n+                            if (interrupted)\n@@ -408,1 +397,1 @@\n-                            if (deadline != 0L && ns <= 0L)\n+                            else\n@@ -410,0 +399,2 @@\n+                        }\n+                        else {\n@@ -419,1 +410,1 @@\n-                            continue outer;\n+                            break;\n@@ -425,2 +416,1 @@\n-        if (offered != null)                     \/\/ cleanup\n-            p.item = null;\n+        p.item = null;                           \/\/ cleanup\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Exchanger.java","additions":37,"deletions":47,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -588,4 +588,1 @@\n-     *    activation (phase change). We distinguish the cases by\n-     *    further signalling only if the task is an InterruptibleTask\n-     *    (see below), which are the only supported forms of task that\n-     *    may do so.\n+     *    activation (phase change).\n@@ -1283,3 +1280,1 @@\n-            if ((a = array) != null && (cap = a.length) > 0 && \/\/ else disabled\n-                task != null) {\n-                int pk = task.noUserHelp() + 1;             \/\/ prev slot offset\n+            if ((a = array) != null && (cap = a.length) > 0) { \/\/ else disabled\n@@ -1293,2 +1288,2 @@\n-                    if (room == 0)                          \/\/ resize\n-                        growArray(a, cap, s);\n+                    if (room == 0 && (a = growArray(a, cap, s)) != null)\n+                        m = a.length - 1;                   \/\/ resize\n@@ -1300,3 +1295,3 @@\n-                if ((room == 0 || a[m & (s - pk)] == null) &&\n-                    pool != null)\n-                    pool.signalWork();   \/\/ may have appeared empty\n+                if (pool != null && a != null &&\n+                    U.getReferenceVolatile(a, slotOffset(m & (s - 1))) == null)\n+                    pool.signalWork(a, m & s);   \/\/ may have appeared empty\n@@ -1311,0 +1306,1 @@\n+         * @return new array, or null on failure\n@@ -1312,1 +1308,1 @@\n-        private void growArray(ForkJoinTask<?>[] a, int cap, int s) {\n+        private ForkJoinTask<?>[] growArray(ForkJoinTask<?>[] a, int cap, int s) {\n@@ -1314,0 +1310,1 @@\n+            ForkJoinTask<?>[] newArray = null;\n@@ -1315,1 +1312,0 @@\n-                ForkJoinTask<?>[] newArray = null;\n@@ -1332,0 +1328,1 @@\n+            return newArray;\n@@ -1861,1 +1858,0 @@\n-            signalWork();                  \/\/ possibly replace\n@@ -1863,0 +1859,1 @@\n+            signalWork(null, 0);           \/\/ possibly replace\n@@ -1869,1 +1866,3 @@\n-     * Releases an idle worker, or creates one if not enough exist.\n+     * Releases an idle worker, or creates one if not enough exist,\n+     * giving up on contention if array a nonnull and task at a[k]\n+     * already taken.\n@@ -1871,1 +1870,1 @@\n-    final void signalWork() {\n+    final void signalWork(ForkJoinTask<?>[] a, int k) {\n@@ -1903,0 +1902,2 @@\n+            if (a != null && k < a.length && k >= 0 && a[k] == null)\n+                break;\n@@ -1978,1 +1979,1 @@\n-            int fifo = w.config & FIFO, nsteals = 0, src = -1;\n+            int fifo = w.config & FIFO, nsteals = 0, propagated = 0;\n@@ -2000,1 +2001,1 @@\n-                                        a[(b + 2) & m] == null) {\n+                                        a[(b + 2) & m] == null)\n@@ -2002,1 +2003,0 @@\n-                                    }\n@@ -2010,2 +2010,1 @@\n-                                boolean propagate;\n-                                int nb = q.base = b + 1, prevSrc = src;\n+                                int nb = q.base = b + 1, nk;\n@@ -2013,1 +2012,1 @@\n-                                w.source = src = j;       \/\/ volatile\n+                                w.source = j;             \/\/ volatile\n@@ -2015,4 +2014,4 @@\n-                                int nh = t.noUserHelp();\n-                                if (propagate =\n-                                    (prevSrc != src || nh != 0) && a[nb & m] != null)\n-                                    signalWork();\n+                                if (propagated != phase && a[nk = nb & m] != null) {\n+                                    propagated = phase;\n+                                    signalWork(a, nk);\n+                                }\n@@ -2020,2 +2019,1 @@\n-                                if ((b = q.base) != nb && !propagate)\n-                                    break scan;          \/\/ reduce interference\n+                                b = q.base;\n@@ -2026,5 +2024,2 @@\n-                if (!rescan) {\n-                    if (((phase = deactivate(w, phase)) & IDLE) != 0)\n-                        break;\n-                    src = -1;                            \/\/ re-enable propagation\n-                }\n+                if (!rescan && ((phase = deactivate(w, phase)) & IDLE) != 0)\n+                    break;\n@@ -2045,0 +2040,1 @@\n+        long e; WorkQueue[] qs; int n;\n@@ -2047,1 +2043,1 @@\n-        int sp = w.stackPred = (int)pc;       \/\/ set ctl stack link\n+        w.stackPred = (int)pc;                \/\/ set ctl stack link\n@@ -2050,5 +2046,5 @@\n-            return w.phase = phase;           \/\/ back out on possible signal\n-        int ac = (short)(qc >>> RC_SHIFT), n; long e; WorkQueue[] qs;\n-        if (((e = runState) & STOP) != 0L ||\n-            ((e & SHUTDOWN) != 0L && ac == 0 && quiescent() > 0) ||\n-            (qs = queues) == null || (n = qs.length) <= 0)\n+            p = w.phase = activePhase;        \/\/ advance on possible signal\n+        else if (((e = runState) & STOP) != 0L ||\n+                 ((e & SHUTDOWN) != 0L && (qc >> RC_SHIFT) <= 0L &&\n+                  quiescent() > 0) ||\n+                 (qs = queues) == null || (n = qs.length) <= 0)\n@@ -2056,15 +2052,19 @@\n-\n-        for (int prechecks = Math.min(ac, 2), \/\/ reactivation threshold\n-             k = Math.max(n + (n << 1), SPIN_WAITS << 1);;) {\n-            WorkQueue q; int cap; ForkJoinTask<?>[] a; long c;\n-            if (w.phase == activePhase)\n-                return activePhase;\n-            if (--k < 0)\n-                return awaitWork(w, p);       \/\/ block, drop, or exit\n-            if ((q = qs[k & (n - 1)]) == null)\n-                Thread.onSpinWait();\n-            else if ((a = q.array) != null && (cap = a.length) > 0 &&\n-                     a[q.base & (cap - 1)] != null && --prechecks < 0 &&\n-                     (int)(c = ctl) == activePhase &&\n-                     compareAndSetCtl(c, (sp & LMASK) | ((c + RC_UNIT) & UMASK)))\n-                return w.phase = activePhase; \/\/ reactivate\n+        else if ((int)ctl != activePhase)     \/\/ no longer top of ctl stack\n+            p = w.phase;\n+        else {\n+            int step = p, j = p >>> 16, spins = Math.max(n << 1, SPIN_WAITS);\n+            for (int l = n; l > 0; --l, j += step) {\n+                WorkQueue q; long c;          \/\/ missed signal check\n+                if ((q = qs[j & (n - 1)]) != null && q.top - q.base > 0) {\n+                    if ((p = w.phase) != activePhase &&\n+                        (int)(c = ctl) == activePhase &&\n+                        compareAndSetCtl(c, ((pc & LMASK) |\n+                                             ((c + RC_UNIT) & UMASK))))\n+                        p = w.phase = activePhase; \/\/ reactivate\n+                    break;\n+                }\n+            }\n+            if (p != activePhase && (int)ctl == activePhase) {\n+                while ((p = w.phase) != activePhase && --spins > 0)\n+                    Thread.onSpinWait();      \/\/ reduce flailing\n+            }\n@@ -2072,0 +2072,3 @@\n+        if (p != activePhase)\n+            p = awaitWork(w, p);              \/\/ block, drop, or exit\n+        return p;\n@@ -2596,6 +2599,4 @@\n-                if (reuse == 0) {\n-                    if (probes >= n >> 1)\n-                        reuse = r;                   \/\/ stop prefering free slot\n-                }\n-                else if (q != null)\n-                    reuse = 0;                       \/\/ probe on collision\n+                if (q != null && probes == 0)\n+                    reuse = 0;                       \/\/ initial collision\n+                else if (reuse == 0 && probes >= 4)  \/\/ probably nearly full\n+                    reuse = 1;                       \/\/ stop prefering free slot\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":62,"deletions":61,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.concurrent.ForkJoinTask;\n@@ -45,1 +46,1 @@\n-    public static void main(String[] args) throws Exception {\n+    static void testSubmitExternalCallable() throws Exception {\n@@ -56,0 +57,17 @@\n+\n+    static void testSubmitAdaptedCallable() throws Exception {\n+        try (var pool = new ForkJoinPool(2)) {\n+            for (int i = 0; i < 100_000; i++) {\n+                var future1 = pool.submit(new AwaitCount(i));\n+                var future2 = pool.submit(ForkJoinTask.adapt(noop));\n+                future2.get();\n+                count.set(i + 1);\n+                future1.get();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        testSubmitExternalCallable();\n+        testSubmitAdaptedCallable();\n+    }\n","filename":"test\/jdk\/java\/util\/concurrent\/forkjoin\/Starvation.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"}]}