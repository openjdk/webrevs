{"files":[{"patch":"@@ -1430,2 +1430,4 @@\n-        \/**\n-         * Runs the given task, as well as remaining local tasks.\n+        \/*\n+         * Two version (lifo and fifo) of top-level execution, split\n+         * across modes to better isolate task dispatch and local\n+         * processing from top-level scheduling.\n@@ -1433,1 +1435,1 @@\n-        final void topLevelExec(ForkJoinTask<?> task, int fifo) {\n+        final void topLevelExecLifo(ForkJoinTask<?> task) {\n@@ -1436,1 +1438,8 @@\n-                task = (fifo == 0) ? localPop() : localPoll();\n+                task = localPop();\n+            }\n+        }\n+\n+        final void topLevelExecFifo(ForkJoinTask<?> task) {\n+            while (task != null) {\n+                task.doExec();\n+                task = localPoll();\n@@ -2012,1 +2021,4 @@\n-                                w.topLevelExec(t, fifo);  \/\/ run t & its subtasks\n+                                if (fifo != 0)            \/\/ run t & its subtasks\n+                                    w.topLevelExecFifo(t);\n+                                else\n+                                    w.topLevelExecLifo(t);\n@@ -2074,5 +2086,3 @@\n-            int cfg = w.config, src = w.source;\n-            long startTime = System.nanoTime();\n-            long minWaitTime = TimeUnit.MILLISECONDS.toNanos(TIMEOUT_SLOP);\n-            long waitTime = (src == INVALID_ID) ? minWaitTime :\n-                TimeUnit.MILLISECONDS.toNanos(keepAlive);\n+            int cfg = w.config;\n+            long waitTime = (w.source == INVALID_ID) ? 0L : keepAlive;\n+            long deadline = waitTime + System.currentTimeMillis();\n@@ -2093,7 +2103,10 @@\n-                long wt = waitTime - (System.nanoTime() - startTime);\n-                long parkTime = 0L, c;        \/\/ use timed wait if trimmable\n-                if (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase &&\n-                    (parkTime = wt) <= minWaitTime) {\n-                    if (tryTrim(w, c, activePhase))\n-                        break;\n-                    continue;                 \/\/ lost race to trim\n+                boolean trimmable = false;    \/\/ use timed wait if trimmable\n+                long d = 0L, c;\n+                if (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase) {\n+                    if (deadline - System.currentTimeMillis() <= TIMEOUT_SLOP) {\n+                        if (tryTrim(w, c, activePhase))\n+                            break;\n+                        continue;             \/\/ lost race to trim\n+                    }\n+                    d = deadline;\n+                    trimmable = true;\n@@ -2103,1 +2116,1 @@\n-                    U.park(false, parkTime);  \/\/ timed relative wait if nonzero\n+                    U.park(trimmable, d);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":31,"deletions":18,"binary":false,"changes":49,"status":"modified"}]}