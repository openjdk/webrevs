{"files":[{"patch":"@@ -585,2 +585,2 @@\n-     * permutation on each invocation.  The pseudorandom generator\n-     * need not have high-quality statistical properties in the long\n+     * permutation on each rescan.  The pseudorandom generator need\n+     * not have high-quality statistical properties in the long\n@@ -592,6 +592,5 @@\n-     * phase)()).  Avoiding missed signals during deactivation\n-     * requires a (conservative) rescan, reactivating if there may be\n-     * tasks to poll.  signal during deactivation.  Because idle\n-     * workers are often not yet blocked (parked), we use a WorkQueue\n-     * field to advertise that a waiter actually needs unparking upon\n-     * signal.\n+     * phase).  Avoiding missed signals during deactivation requires a\n+     * (conservative) rescan, reactivating if there may be tasks to\n+     * poll. Because idle workers are often not yet blocked (parked),\n+     * we use a WorkQueue field to advertise that a waiter actually\n+     * needs unparking upon signal.\n@@ -603,5 +602,4 @@\n-     * Locality. Polls are organized into \"runs\" from the same source\n-     * queue, until empty or contended, while also minimizing\n-     * interference by postponing bookeeping to ends of runs. This may\n-     * reduce fairness, which is partially counteracted by the\n-     * following.\n+     * Locality. Polls are organized into \"runs\", continuing until\n+     * empty or contended, while also minimizing interference by\n+     * postponing bookeeping to ends of runs. This may reduce\n+     * fairness, which is partially counteracted by the following.\n@@ -617,1 +615,1 @@\n-     * Oversignalling. When many small top-level tasks are present in\n+     * Oversignalling. When many short top-level tasks are present in\n@@ -620,5 +618,5 @@\n-     * contention problems, while also generating more global ctl\n-     * contention (which is CASed on every activation and\n-     * deactivation.) We filter out (both in runWorker and signalWork)\n-     * attempted signals that are surely not needed because the\n-     * signalled tasks are already taken.\n+     * contention problems, while also generating more global\n+     * contention (field is CASed on every activation and\n+     * deactivation). We filter out (both in runWorker and\n+     * signalWork) attempted signals that are surely not needed\n+     * because the signalled tasks are already taken.\n@@ -1311,1 +1309,1 @@\n-        final ForkJoinTask<?> nextLocalTask(int fifo) {\n+        private ForkJoinTask<?> nextLocalTask(int fifo) {\n@@ -1417,0 +1415,10 @@\n+        \/**\n+         * Runs the given task, as well as remaining local tasks.\n+         *\/\n+        final void topLevelExec(ForkJoinTask<?> task, int fifo) {\n+            while (task != null) {\n+                task.doExec();\n+                task = nextLocalTask(fifo);\n+            }\n+        }\n+\n@@ -1943,1 +1951,2 @@\n-            int phase = w.phase, r = w.stackPred;         \/\/ seed from registerWorker\n+            int phase = w.phase;\n+            int r = w.stackPred, origin = r;              \/\/ seed from registerWorker\n@@ -1945,1 +1954,2 @@\n-            int nsteals = 0, src = -1;                    \/\/ current source queue\n+            int src = -1;                                 \/\/ current source queue\n+            int taken = 0, ptaken = 0, staken = 0;        \/\/ takes per phase and scan\n@@ -1949,3 +1959,2 @@\n-                int i = r, step = (r >>> 16) | 1;         \/\/ random origin\n-                r ^= r << 13; r ^= r >>> 17; r ^= r << 5; \/\/ xorshift\n-                boolean taken = false;\n+                int i = origin, step = (r >>> 16) | 1;\n+                r ^= r << 13; r ^= r >>> 17; origin = r ^= r << 5; \/\/ xorshift\n@@ -1966,7 +1975,3 @@\n-                                if (taken) {              \/\/ end of run\n-                                    w.nsteals = nsteals;\n-                                    if (clearLocals != 0 &&\n-                                        Thread.currentThread()\n-                                        instanceof ForkJoinWorkerThread wt)\n-                                        wt.resetThreadLocals();\n-                                    continue rescan;\n+                                if (taken != staken) {\n+                                    staken = taken;\n+                                    continue rescan;      \/\/ sweep until clean\n@@ -1982,4 +1987,3 @@\n-                                taken = true;\n-                                ++nsteals;\n-                                if (src != (src = j))\n-                                    w.source = j;\n+                                ++taken;\n+                                if (src != j)\n+                                    w.source = src = j;\n@@ -1988,3 +1992,1 @@\n-                                do {\n-                                    t.doExec();           \/\/ run task & subtasks\n-                                } while ((t = w.nextLocalTask(fifo)) != null);\n+                                w.topLevelExec(t, fifo);  \/\/ run t & its subtasks\n@@ -1995,2 +1997,9 @@\n-                if ((runState & STOP) != 0L)              \/\/ check before deactivate\n-                    break;\n+                if (taken != ptaken) {                    \/\/ end run\n+                    ptaken = taken;\n+                    origin = src;                         \/\/ hint for next run\n+                    if (clearLocals != 0 &&\n+                        Thread.currentThread() instanceof ForkJoinWorkerThread wt)\n+                        wt.resetThreadLocals();\n+                    w.nsteals = taken;\n+                }\n+                w.phase = phase += IDLE;                  \/\/ deactivate\n@@ -2004,1 +2013,1 @@\n-     * Deactivates and awaits signal or termination.\n+     * Awaits signal or termination.\n@@ -2007,1 +2016,1 @@\n-     * @param phase current phase\n+     * @param p current phase (known to be idle\n@@ -2010,1 +2019,1 @@\n-    private int awaitWork(WorkQueue w, int phase) {\n+    private int awaitWork(WorkQueue w, int p) {\n@@ -2013,12 +2022,10 @@\n-        int p = phase | IDLE, activePhase = phase + (IDLE << 1);\n-        long qsp = activePhase & LMASK;\n-        long pc = ctl, qc = qsp | ((pc - RC_UNIT) & UMASK);\n-        int sp = w.stackPred = (int)pc;       \/\/ set ctl stack link\n-        w.phase = p;                          \/\/ deactivate\n-        while (pc != (pc = compareAndExchangeCtl(pc, qc))) {\n-            sp = w.stackPred = (int)pc;\n-            qc = qsp | ((pc - RC_UNIT) & UMASK);\n-        }\n-        WorkQueue[] qs = queues;              \/\/ missed signal check\n-        int n = (qs == null) ? 0 : qs.length;\n-        long psp = sp & LMASK;                \/\/ reactivation stack prefix\n+        int activePhase = p + IDLE;\n+        long ap = activePhase & LMASK, pc = ctl, qc;\n+        do {                                  \/\/ enqueue\n+            qc = ap | ((pc - RC_UNIT) & UMASK);\n+            w.stackPred = (int)pc;            \/\/ set ctl stack link\n+        } while (pc != (pc = compareAndExchangeCtl(pc, qc)));\n+        long psp = pc & LMASK;                \/\/ reactivation stack prefix\n+        WorkQueue[] qs; int n;                \/\/ missed signal check\n+        if ((runState & STOP) != 0 || (qs = queues) == null || (n = qs.length) <= 0)\n+            return IDLE;                      \/\/ already terminating\n@@ -2073,0 +2080,2 @@\n+                if (p != activePhase)\n+                    return IDLE;\n@@ -2074,2 +2083,0 @@\n-            if (p != activePhase)\n-                return IDLE;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":65,"deletions":58,"binary":false,"changes":123,"status":"modified"}]}