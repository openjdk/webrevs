{"files":[{"patch":"@@ -943,7 +943,7 @@\n-     * embedded @Contended isolates the very busy top index, and\n-     * another segregates status and bookkeeping fields written\n-     * (mostly) by owners, that otherwise interfere with reading\n-     * array, top, and base fields. There are other variables commonly\n-     * contributing to false-sharing-related performance issues\n-     * (including fields of class Thread), but we can't do much about\n-     * this except try to minimize access.\n+     * embedded @Contended isolates the very busy top index, along\n+     * with status and bookkeeping fields written (mostly) by owners,\n+     * that otherwise interfere with reading array and base\n+     * fields. There are other variables commonly contributing to\n+     * false-sharing-related performance issues (including fields of\n+     * class Thread), but we can't do much about this except try to\n+     * minimize access.\n@@ -1181,3 +1181,0 @@\n-        @jdk.internal.vm.annotation.Contended(\"t\") \/\/ segregate\n-        int top;                   \/\/ index of next slot for push\n-\n@@ -1186,0 +1183,2 @@\n+        int top;                   \/\/ index of next slot for push\n+        @jdk.internal.vm.annotation.Contended(\"w\")\n@@ -1472,4 +1471,6 @@\n-                    int qb = q.base, nqb = qb + 1; long qk;\n-                    if ((t = (ForkJoinTask<?>)U.getReferenceAcquire(\n-                             qa, qk = slotOffset((qcap - 1) & qb))) == null ||\n-                        q.base != qb || !U.compareAndSetReference(qa, qk, t, null))\n+                    int qb = q.base; long qk;\n+                    do {\n+                        t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                            qa, qk = slotOffset((qcap - 1) & qb));\n+                    } while (qb != (qb = q.base));\n+                    if (t == null || !U.compareAndSetReference(qa, qk, t, null))\n@@ -1477,1 +1478,1 @@\n-                    q.base = nqb;\n+                    q.base = qb + 1;\n@@ -1482,3 +1483,3 @@\n-                ForkJoinWorkerThread o;\n-                if ((config & CLEAR_TLS) != 0 && (o = owner) != null)\n-                    o.resetThreadLocals();\n+                if ((config & CLEAR_TLS) != 0 &&\n+                    (Thread.currentThread() instanceof ForkJoinWorkerThread f))\n+                    f.resetThreadLocals();\n@@ -2013,1 +2014,1 @@\n-        if (w != null) {\n+        if (w != null && w.phase != 0) {                  \/\/ else unregistered\n@@ -2015,2 +2016,2 @@\n-            int phase = w.phase, r = w.stackPred;         \/\/ seed from registerWorker\n-            int fifo = (int)config & FIFO, rescans = 0, inactive = 0, n;\n+            int r = w.stackPred;                          \/\/ seed from registerWorker\n+            int fifo = (int)config & FIFO, rescans = 0, inactive = 0, taken = 0, n;\n@@ -2047,1 +2048,1 @@\n-                                if (((phase = tryReactivate(w, phase)) & IDLE) != 0) {\n+                                if ((inactive = tryReactivate(w)) != 0) {\n@@ -2051,1 +2052,0 @@\n-                                inactive = 0;\n@@ -2057,1 +2057,1 @@\n-                                rescans = 1;\n+                                rescans = taken = 1;\n@@ -2068,3 +2068,5 @@\n-                else if (inactive == 0)\n-                    inactive = (phase = deactivate(w, phase)) & IDLE;\n-                else if (awaitWork(w, phase += IDLE) == 0)\n+                else if (inactive == 0) {\n+                    if ((inactive = deactivate(w, taken)) != 0)\n+                        taken = 0;\n+                }\n+                else if (awaitWork(w) == 0)\n@@ -2082,2 +2084,2 @@\n-     * @param phase w's current (active) phase\n-     * @return current phase\n+     * @param taken nonzero if stole tasks since last deactivation\n+     * @return nonzero if inactive\n@@ -2085,8 +2087,8 @@\n-    private int deactivate(WorkQueue w, int phase) {\n-        if (w != null) {                      \/\/ always true; hoist checks\n-            int idlePhase = phase | IDLE, activePhase = phase + (IDLE << 1);\n-            long pc = ctl;\n-            long qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n-            w.stackPred = (int)pc;            \/\/ set ctl stack link\n-            w.phase = idlePhase;              \/\/ try to enqueue\n-            if (!compareAndSetCtl(pc, qc))\n+    private int deactivate(WorkQueue w, int taken) {\n+        int inactive = 0, phase;\n+        if (w != null && (inactive = (phase = w.phase) & IDLE) == 0) {\n+            long sp = (phase + (IDLE << 1)) & LMASK, pc, c;\n+            w.phase = phase | IDLE;\n+            w.stackPred = (int)(pc = ctl);    \/\/ set ctl stack link\n+            if (!compareAndSetCtl(            \/\/ try to enqueue\n+                    pc, c = ((pc - RC_UNIT) & UMASK) | sp))\n@@ -2094,8 +2096,7 @@\n-            else {\n-                phase = idlePhase;            \/\/ check quiescent termination\n-                if ((qc & RC_MASK) > 0L || quiescent() <= 0) {\n-                    int tc = (short)(qc >>> TC_SHIFT); \/\/ approx scan cost\n-                    int spins = Math.max((tc << 2) + 0xf, SPIN_WAITS);\n-                    while ((phase = w.phase) != activePhase && --spins != 0)\n-                        Thread.onSpinWait();  \/\/ spin before rescanning\n-                }\n+            else if (((c & RC_MASK) == 0L && quiescent() > 0) || taken == 0)\n+                inactive = w.phase & IDLE;    \/\/ check quiescent termination\n+            else {                            \/\/ spin for approx 1 scan cost\n+                int tc = (short)(c >>> TC_SHIFT);\n+                int spins = Math.max(tc << 2, SPIN_WAITS) | 0x3;\n+                while ((inactive = w.phase & IDLE) != 0 && --spins != 0)\n+                    Thread.onSpinWait();\n@@ -2104,1 +2105,1 @@\n-        return phase;\n+        return inactive;\n@@ -2111,2 +2112,1 @@\n-     * @param phase w's currently known (idle) phase\n-     * @return currently known phase on exit\n+     * @return 0 if now active\n@@ -2114,7 +2114,12 @@\n-    private int tryReactivate(WorkQueue w, int phase) {\n-        int activePhase = phase + IDLE; long c;\n-        if (w != null && (phase = w.phase) != activePhase &&\n-            (int)(c = ctl) == activePhase &&\n-            compareAndSetCtl(c, (w.stackPred & LMASK) | ((c + RC_UNIT) & UMASK)))\n-            phase = w.phase = activePhase;\n-        return phase;\n+    private int tryReactivate(WorkQueue w) {\n+        int inactive = 0;\n+        if (w != null) {                         \/\/ always true; hoist checks\n+            int sp = w.stackPred, phase, activePhase; long c;\n+            if ((inactive = (phase = w.phase) & IDLE) != 0 &&\n+                (int)(c = ctl) == (activePhase = phase + IDLE) &&\n+                compareAndSetCtl(c, (sp & LMASK) | ((c + RC_UNIT) & UMASK))) {\n+                w.phase = activePhase;\n+                inactive = 0;\n+            }\n+        }\n+        return inactive;\n@@ -2127,1 +2132,0 @@\n-     * @param activePhase w's next active phase\n@@ -2130,2 +2134,2 @@\n-    private int awaitWork(WorkQueue w, int activePhase) {\n-        int idle = 1;\n+    private int awaitWork(WorkQueue w) {\n+        int inactive = 0, phase;\n@@ -2134,1 +2138,1 @@\n-            if ((idle = w.phase - activePhase) != 0) {\n+            if ((inactive = (phase = w.phase) & IDLE) != 0) {\n@@ -2136,0 +2140,1 @@\n+                int activePhase = phase + IDLE;\n@@ -2155,1 +2160,1 @@\n-                    if ((idle = w.phase - activePhase) != 0)\n+                    if ((inactive = w.phase & IDLE) != 0)\n@@ -2158,1 +2163,1 @@\n-                    if (idle == 0 || (idle = w.phase - activePhase) == 0)\n+                    if (inactive == 0 || (inactive = w.phase & IDLE) == 0)\n@@ -2164,1 +2169,1 @@\n-        return idle;\n+        return inactive;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":67,"deletions":62,"binary":false,"changes":129,"status":"modified"}]}