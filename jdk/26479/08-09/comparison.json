{"files":[{"patch":"@@ -575,1 +575,2 @@\n-     * failsafe in case of Thread failures in deregisterWorker.)\n+     * failsafe in case of Thread failures in deregisterWorker, to\n+     * activate or create a new worker to replace them).\n@@ -598,1 +599,1 @@\n-     * When tasks are constructed as (recursive) dags, top-level\n+     * When tasks are constructed as (recursive) DAGs, top-level\n@@ -605,1 +606,1 @@\n-     * fairness, which is partially counteracted by the following.\n+     * fairness.\n@@ -612,1 +613,1 @@\n-     * ahead in queue arrays. In both caes, workers restart scans in a\n+     * ahead in queue arrays. In both cases, workers restart scans in a\n@@ -619,1 +620,1 @@\n-     * contention (field is CASed on every activation and\n+     * contention (field ctl is CASed on every activation and\n@@ -942,3 +943,7 @@\n-     * embedded @Contended region segregates fields most heavily\n-     * updated by owners from those most commonly read by stealers or\n-     * other management.\n+     * embedded @Contended isolates the very busy top index, and\n+     * another segregates status and bookkeeping fields written\n+     * (mostly) by owners, that otherwise interfere with reading\n+     * array, top, and base fields. There are other variables commonly\n+     * contributing to false-sharing-related performance issues\n+     * (including fields of class Thread), but we can't do much about\n+     * this except try to minimize access.\n@@ -1176,2 +1181,1 @@\n-        \/\/ fields otherwise causing more unnecessary false-sharing cache misses\n-        @jdk.internal.vm.annotation.Contended(\"w\")\n+        @jdk.internal.vm.annotation.Contended(\"t\") \/\/ segregate\n@@ -1179,0 +1183,2 @@\n+\n+        \/\/ fields otherwise causing more unnecessary false-sharing cache misses\n@@ -1184,0 +1190,2 @@\n+        volatile int parking;      \/\/ nonzero if parked in awaitWork\n+        @jdk.internal.vm.annotation.Contended(\"w\")\n@@ -1187,2 +1195,0 @@\n-        @jdk.internal.vm.annotation.Contended(\"w\")\n-        volatile int parking;      \/\/ nonzero if parked in awaitWork\n@@ -1223,1 +1229,0 @@\n-                phase = id | IDLE;\n@@ -1225,0 +1230,1 @@\n+                phase = id | IDLE;\n@@ -1305,3 +1311,1 @@\n-         * Takes next task, if one exists, in order specified by mode,\n-         * so acts as either local-pop or local-poll. Called only by owner.\n-         * @param fifo nonzero if FIFO mode\n+         * Takes next task, if one exists, in lifo order.\n@@ -1309,1 +1313,1 @@\n-        private ForkJoinTask<?> nextLocalTask(int fifo) {\n+        private ForkJoinTask<?> localPop() {\n@@ -1311,9 +1315,23 @@\n-            ForkJoinTask<?>[] a = array;\n-            int b = base, p = top, cap;\n-            if (p - b > 0 && a != null && (cap = a.length) > 0) {\n-                for (int m = cap - 1, s, nb;;) {\n-                    if (fifo == 0 || (nb = b + 1) == p) {\n-                        if ((t = (ForkJoinTask<?>)U.getAndSetReference(\n-                                 a, slotOffset(m & (s = p - 1)), null)) != null)\n-                            updateTop(s);       \/\/ else lost race for only task\n-                        break;\n+            int s = top - 1, cap; long k; ForkJoinTask<?>[] a;\n+            if ((a = array) != null && (cap = a.length) > 0 &&\n+                U.getReference(a, k = slotOffset((cap - 1) & s)) != null &&\n+                (t = (ForkJoinTask<?>)U.getAndSetReference(a, k, null)) != null)\n+                updateTop(s);\n+            return t;\n+        }\n+\n+        \/**\n+         * Takes next task, if one exists, in fifo order.\n+         *\/\n+        private ForkJoinTask<?> localPoll() {\n+            ForkJoinTask<?> t = null;\n+            int p = top, cap; ForkJoinTask<?>[] a;\n+            if ((a = array) != null && (cap = a.length) > 0) {\n+                for (int b = base; p - b > 0; ) {\n+                    int nb = b + 1;\n+                    long k = slotOffset((cap - 1) & b);\n+                    if (U.getReference(a, k) == null) {\n+                        if (nb == p)\n+                            break;          \/\/ else base is lagging\n+                        while (b == (b = U.getIntAcquire(this, BASE)))\n+                            Thread.onSpinWait(); \/\/ spin to reduce memory traffic\n@@ -1321,2 +1339,2 @@\n-                    if ((t = (ForkJoinTask<?>)U.getAndSetReference(\n-                             a, slotOffset(m & b), null)) != null) {\n+                    else if ((t = (ForkJoinTask<?>)\n+                              U.getAndSetReference(a, k, null)) != null) {\n@@ -1326,4 +1344,2 @@\n-                    while (b == (b = U.getIntAcquire(this, BASE)))\n-                        Thread.onSpinWait();    \/\/ spin to reduce memory traffic\n-                    if (p - b <= 0)\n-                        break;\n+                    else\n+                        b = base;\n@@ -1337,1 +1353,0 @@\n-         * (Always internal, never called for Common pool.)\n@@ -1340,1 +1355,1 @@\n-            return nextLocalTask(config & FIFO);\n+            return (config & FIFO) == 0 ? localPop() : localPoll();\n@@ -1421,1 +1436,1 @@\n-                task = nextLocalTask(fifo);\n+                task = (fifo == 0) ? localPop() : localPoll();\n@@ -1551,1 +1566,1 @@\n-            for (ForkJoinTask<?> t; (t = nextLocalTask(0)) != null; ) {\n+            for (ForkJoinTask<?> t; (t = localPop()) != null; ) {\n@@ -1951,15 +1966,15 @@\n-            int phase = w.phase;\n-            int r = w.stackPred, origin = r;              \/\/ seed from registerWorker\n-            int cfg = w.config, fifo = cfg & FIFO, clearLocals = cfg & CLEAR_TLS;\n-            int src = -1;                                 \/\/ current source queue\n-            int taken = 0, ptaken = 0, staken = 0;        \/\/ takes per phase and scan\n-            rescan: while ((runState & STOP) == 0L) {\n-                WorkQueue[] qs = queues;\n-                int n = (qs == null) ? 0 : qs.length;\n-                int i = origin, step = (r >>> 16) | 1;\n-                r ^= r << 13; r ^= r >>> 17; origin = r ^= r << 5; \/\/ xorshift\n-                for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n-                    WorkQueue q; int j;\n-                    if ((q = qs[j = i & (n - 1)]) != null) {\n-                        for (;;) {                        \/\/ poll q\n-                            ForkJoinTask<?>[] a; int cap, b, m, k;\n+            int r = w.stackPred;                          \/\/ seed from registerWorker\n+            int fifo = (int)config & FIFO;\n+            int nsteals = 0;                              \/\/ shadow w.nsteals\n+            boolean rescan = true;\n+            WorkQueue[] qs; int n;\n+            while ((rescan || deactivate(w) == 0) && (runState & STOP) == 0L &&\n+                   (qs = queues) != null && (n = qs.length) > 0) {\n+                rescan = false;\n+                int i = r, step = (r >>> 16) | 1;\n+                r ^= r << 13; r ^= r >>> 17; r ^= r << 5; \/\/ xorshift\n+                scan: for (int j = n; j > 0; --j, i += step) {\n+                    WorkQueue q; int qid;\n+                    if ((q = qs[qid = i & (n - 1)]) != null) {\n+                        for (;;) {                        \/\/ poll queue q\n+                            ForkJoinTask<?>[] a; int cap, b, m, nb, nk;\n@@ -1968,2 +1983,2 @@\n-                            long bp = slotOffset(k = (b = q.base) & (m = cap - 1));\n-                            int nb = b + 1, nk = nb & m;\n+                            long bp = slotOffset((m = cap - 1) & (b = q.base));\n+                            long np = slotOffset(nk = m & (nb = b + 1));\n@@ -1972,1 +1987,2 @@\n-                            if (q.array != a || q.base != b || a[k] != t)\n+                            if (q.array != a || q.base != b ||\n+                                U.getReference(a, bp) != t)\n@@ -1975,3 +1991,7 @@\n-                                if (taken != staken) {\n-                                    staken = taken;\n-                                    continue rescan;      \/\/ sweep until clean\n+                                if (rescan) {             \/\/ end of run\n+                                    w.nsteals = nsteals;\n+                                    break scan;\n+                                }\n+                                if (U.getReference(a, np) != null) {\n+                                    rescan = true;        \/\/ stalled; reorder scan\n+                                    break scan;\n@@ -1979,2 +1999,0 @@\n-                                if (a[nk] != null || a[(b + 2) & m] != null)\n-                                    continue rescan;      \/\/ stalled; reorder scan\n@@ -1985,6 +2003,8 @@\n-                                Object nt = U.getReferenceAcquire\n-                                    (a, slotOffset(nk));  \/\/ confirm below\n-                                ++taken;\n-                                if (src != j)\n-                                    w.source = src = j;\n-                                if (nt != null && nt == a[nk])\n+                                Object nt = U.getReferenceAcquire(a, np);\n+                                if (!rescan) {            \/\/ begin run\n+                                    rescan = true;\n+                                    w.source = qid;\n+                                }\n+                                ++nsteals;\n+                                if (nt != null &&         \/\/ confirm a[nk]\n+                                    U.getReference(a, np) == nt)\n@@ -1997,11 +2017,0 @@\n-                if (taken != ptaken) {                    \/\/ end run\n-                    ptaken = taken;\n-                    origin = src;                         \/\/ hint for next run\n-                    if (clearLocals != 0 &&\n-                        Thread.currentThread() instanceof ForkJoinWorkerThread wt)\n-                        wt.resetThreadLocals();\n-                    w.nsteals = taken;\n-                }\n-                w.phase = phase += IDLE;                  \/\/ deactivate\n-                if ((phase = awaitWork(w, phase)) == IDLE)\n-                    break;\n@@ -2013,1 +2022,1 @@\n-     * Awaits signal or termination.\n+     * Deactivates and awaits signal or termination.\n@@ -2016,2 +2025,1 @@\n-     * @param p current phase (known to be idle\n-     * @return current phase or IDLE if worker should exit\n+     * @return zero if now active\n@@ -2019,22 +2027,32 @@\n-    private int awaitWork(WorkQueue w, int p) {\n-        if (w == null)                        \/\/ never true; hoist checks\n-            return IDLE;\n-        int activePhase = p + IDLE;\n-        long ap = activePhase & LMASK, pc = ctl, qc;\n-        do {                                  \/\/ enqueue\n-            qc = ap | ((pc - RC_UNIT) & UMASK);\n-            w.stackPred = (int)pc;            \/\/ set ctl stack link\n-        } while (pc != (pc = compareAndExchangeCtl(pc, qc)));\n-        long psp = pc & LMASK;                \/\/ reactivation stack prefix\n-        WorkQueue[] qs; int n;                \/\/ missed signal check\n-        if ((runState & STOP) != 0 || (qs = queues) == null || (n = qs.length) <= 0)\n-            return IDLE;                      \/\/ already terminating\n-        for (int m = n - 1, origin = p + 1, i = 0; i < m; ++i) {\n-            WorkQueue q; long cc;             \/\/ stagger origins\n-            if ((q = qs[(origin + i) & m]) != null && q.top - q.base > 0) {\n-                if ((p = w.phase) == activePhase)\n-                    break;\n-                if ((int)(cc = ctl) == activePhase &&\n-                    compareAndSetCtl(cc, psp | ((cc + RC_UNIT) & UMASK))) {\n-                    p = w.phase = activePhase;\n-                    break;                    \/\/ reactivated\n+    private int deactivate(WorkQueue w) {\n+        int idle = 1;\n+        if (w != null) {                        \/\/ always true; hoist checks\n+            int activePhase = (w.phase += IDLE) + IDLE; \/\/ advance\n+            long ap = activePhase & LMASK, pc = ctl, qc;\n+            do {                                \/\/ enqueue\n+                qc = ap | ((pc - RC_UNIT) & UMASK);\n+                w.stackPred = (int)pc;          \/\/ set ctl stack link\n+            } while (pc != (pc = compareAndExchangeCtl(pc, qc)));\n+\n+            WorkQueue[] qs; int n; long e;\n+            if (((e = runState) & STOP) == 0 && \/\/ quiescence checks\n+                ((e & SHUTDOWN) == 0L || (qc & RC_MASK) > 0L || quiescent() <= 0) &&\n+                (qs = queues) != null && (n = qs.length) > 1) {\n+                long psp = pc & LMASK;          \/\/ ctl predecessor prefix\n+                for (int i = 1;;) {             \/\/ scan; stagger origins\n+                    long c;\n+                    WorkQueue q = qs[(activePhase + i) & (n - 1)];\n+                    if ((idle = w.phase - activePhase) == 0)\n+                        break;\n+                    if (q != null && q.top - q.base > 0 &&\n+                        (int)(c = ctl) == activePhase &&\n+                        compareAndSetCtl(c, psp | ((c + RC_UNIT) & UMASK))) {\n+                        w.phase = activePhase;\n+                        idle = 0;               \/\/ possible missed signal\n+                        break;\n+                    }\n+                    if (++i == n) {\n+                        idle = awaitWork(w, activePhase);\n+                        break;\n+                    }\n+                    Thread.onSpinWait();        \/\/ reduce memory traffic\n@@ -2044,21 +2062,26 @@\n-        if (p != activePhase && (p = w.phase) != activePhase) {\n-            long deadline = 0L, c, e;         \/\/ quiescence checks\n-            if (((e = runState) & STOP) != 0)\n-                return IDLE;\n-            else if ((int)(c = ctl) != activePhase || (c & RC_MASK) > 0L) {\n-                for (int spins = n; (p = w.phase) != activePhase && --spins > 0;)\n-                    Thread.onSpinWait();      \/\/ spin unless possibly quiescent\n-            }\n-            else if ((e & SHUTDOWN) != 0L && quiescent() > 0)\n-                return IDLE;                  \/\/ quiescent termination\n-            else {                            \/\/ use trim timeout\n-                long d = ((w.source != INVALID_ID) ? keepAlive :\n-                          TIMEOUT_SLOP) + System.currentTimeMillis();\n-                deadline = (d == 0L)? 1L : d; \/\/ avoid zero\n-                p = w.phase;\n-            }\n-            if (p != activePhase) {           \/\/ block\n-                LockSupport.setCurrentBlocker(this);\n-                w.parking = 1;                \/\/ enable unpark\n-                while ((p = w.phase) != activePhase) {\n-                    boolean trimmable = false; int trim;\n+        return idle;\n+    }\n+\n+    \/**\n+     * Awaits signal or termination.\n+     *\n+     * @param w the work queue\n+     * @param activePhase w's next active phase\n+     * @return zero if now active\n+     *\/\n+    private int awaitWork(WorkQueue w, int activePhase) {\n+        int idle = 1;\n+        if (w != null) {                      \/\/ always true; hoist checks\n+            boolean trimmable; long deadline, c;\n+            long trimTime = (w.source == INVALID_ID) ? TIMEOUT_SLOP : keepAlive;\n+            if ((w.config & CLEAR_TLS) != 0 &&\n+                Thread.currentThread() instanceof ForkJoinWorkerThread f)\n+                f.resetThreadLocals();        \/\/ clear while accessing thread state\n+            LockSupport.setCurrentBlocker(this);\n+            if (trimmable = (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase))\n+                deadline = trimTime + System.currentTimeMillis();\n+            else\n+                deadline = 0L;\n+            if ((idle = w.phase - activePhase) != 0) {\n+                for (;;) {\n+                    int trim;\n@@ -2068,2 +2091,9 @@\n-                    if (deadline != 0L) {\n-                        if ((trim = tryTrim(w, p, deadline)) > 0)\n+                    w.parking = 1;            \/\/ enable unpark and recheck\n+                    if ((idle = w.phase - activePhase) != 0)\n+                        U.park(trimmable, deadline);\n+                    w.parking = 0;            \/\/ close unpark window\n+                    if (idle == 0 || (idle = w.phase - activePhase) == 0)\n+                        break;\n+                    if (trimmable &&\n+                        (trim = tryTrim(w, activePhase, deadline)) != 0) {\n+                        if (trim > 0)\n@@ -2071,4 +2101,2 @@\n-                        else if (trim < 0)\n-                            deadline = 0L;\n-                        else\n-                            trimmable = true;\n+                        trimmable = false;\n+                        deadline = 0L;\n@@ -2076,1 +2104,0 @@\n-                    U.park(trimmable, deadline);\n@@ -2078,4 +2105,0 @@\n-                w.parking = 0;\n-                LockSupport.setCurrentBlocker(null);\n-                if (p != activePhase)\n-                    return IDLE;\n@@ -2083,0 +2106,1 @@\n+            LockSupport.setCurrentBlocker(null);\n@@ -2084,1 +2108,1 @@\n-        return activePhase;\n+        return idle;\n@@ -2092,3 +2116,4 @@\n-    private int tryTrim(WorkQueue w, int phase, long deadline) {\n-        long c, nc; int stat, activePhase, vp, i; WorkQueue[] vs; WorkQueue v;\n-        if ((activePhase = phase + IDLE) != (int)(c = ctl) || w == null)\n+    private int tryTrim(WorkQueue w, int activePhase, long deadline) {\n+        long c, nc; int stat, vp, i; WorkQueue[] vs; WorkQueue v;\n+        long waitTime = deadline - System.currentTimeMillis();\n+        if ((int)(c = ctl) != activePhase || w == null)\n@@ -2096,1 +2121,1 @@\n-        else if (deadline - System.currentTimeMillis() >= TIMEOUT_SLOP)\n+        else if (waitTime > TIMEOUT_SLOP)\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":163,"deletions":138,"binary":false,"changes":301,"status":"modified"}]}