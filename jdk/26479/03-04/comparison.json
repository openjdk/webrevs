{"files":[{"patch":"@@ -1288,2 +1288,4 @@\n-                    if (room == 0 && (a = growArray(a, cap, s)) != null)\n-                        m = a.length - 1;                   \/\/ resize\n+                    if (room == 0) {                        \/\/ resize\n+                        growArray(a, cap, s);\n+                        a = null;\n+                    }\n@@ -1295,2 +1297,3 @@\n-                if (pool != null && a != null &&\n-                    U.getReferenceAcquire(a, slotOffset(m & (s - 1))) == null)\n+                if (pool != null &&\n+                    (a == null ||                \/\/ always signal on resize\n+                     U.getReferenceAcquire(a, slotOffset(m & (s - 1))) == null))\n@@ -1306,1 +1309,0 @@\n-         * @return new array, or null on failure\n@@ -1308,1 +1310,1 @@\n-        private ForkJoinTask<?>[] growArray(ForkJoinTask<?>[] a, int cap, int s) {\n+        private void growArray(ForkJoinTask<?>[] a, int cap, int s) {\n@@ -1310,1 +1312,0 @@\n-            ForkJoinTask<?>[] newArray = null;\n@@ -1312,0 +1313,1 @@\n+                ForkJoinTask<?>[] newArray = null;\n@@ -1328,1 +1330,0 @@\n-            return newArray;\n@@ -1867,2 +1868,1 @@\n-     * giving up on contention if array a nonnull and task at a[k]\n-     * already taken.\n+     * giving up if array a is nonnull and task at a[k] already taken.\n@@ -1886,1 +1886,1 @@\n-                nc = ((c + TC_UNIT) & TC_MASK);\n+                nc = ((c + TC_UNIT) & TC_MASK) | ac;\n@@ -1891,2 +1891,4 @@\n-                nc = (v.stackPred & LMASK) | (c & TC_MASK);\n-            if (c == (c = compareAndExchangeCtl(c, nc | ac))) {\n+                nc = (v.stackPred & LMASK) | (c & TC_MASK) | ac;\n+            if (a != null && k < a.length && k >= 0 && a[k] == null)\n+                break;\n+            if (c == (c = ctl) && c == (c = compareAndExchangeCtl(c, nc))) {\n@@ -1902,2 +1904,0 @@\n-            if (a != null && k < a.length && k >= 0 && a[k] == null)\n-                break;\n@@ -1979,2 +1979,2 @@\n-            int fifo = w.config & FIFO, nsteals = 0, propagated = 0;\n-            for (;;) {\n+            int fifo = w.config & FIFO, nsteals = 0;\n+            rescan: for (boolean propagated = false;;) {\n@@ -1986,3 +1986,2 @@\n-                boolean rescan = false;\n-                scan: for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n-                    int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n+                for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n+                    int j, m; WorkQueue q; ForkJoinTask<?>[] a;\n@@ -1990,3 +1989,4 @@\n-                        (a = q.array) != null && (cap = a.length) > 0) {\n-                        for (int m = cap - 1, pb = -1, b = q.base;;) {\n-                            ForkJoinTask<?> t; long k;\n+                        (a = q.array) != null && (m = a.length - 1) >= 0) {\n+                        boolean ran = false;\n+                        for (int pb = -1, b = q.base;;) {\n+                            ForkJoinTask<?> t; long k; int bk;\n@@ -1994,8 +1994,12 @@\n-                                a, k = slotOffset(m & b));\n-                            if (b != (b = q.base) || t == null ||\n-                                !U.compareAndSetReference(a, k, t, null)) {\n-                                if (a[b & m] == null) {\n-                                    if (rescan)           \/\/ end of run\n-                                        break scan;\n-                                    if (a[(b + 1) & m] == null &&\n-                                        a[(b + 2) & m] == null)\n+                                a, k = slotOffset(bk = b & m));\n+                            int nb = b + 1, nk = nb & m;\n+                            if (b != (b = q.base))\n+                               ;                          \/\/ inconsistent\n+                            else if (t == null ||\n+                                     !U.compareAndSetReference(a, k, t, null)) {\n+                                if (q.array != a)         \/\/ resized\n+                                    continue rescan;\n+                                if (b == (b = q.base) && a[bk] == null) {\n+                                    if (a[nk] == null && a[(b + 2) & m] == null) {\n+                                        if (ran)          \/\/ end of run\n+                                            continue rescan;\n@@ -2003,3 +2007,0 @@\n-                                    if (pb == (pb = b)) { \/\/ track progress\n-                                        rescan = true;    \/\/ stalled; reorder scan\n-                                        break scan;\n@@ -2007,0 +2008,2 @@\n+                                    if (pb == (pb = b))   \/\/ track progress\n+                                        continue rescan;  \/\/ stalled; reorder scan\n@@ -2010,1 +2013,1 @@\n-                                int nb = q.base = b + 1, nk;\n+                                q.base = nb;\n@@ -2013,3 +2016,3 @@\n-                                rescan = true;\n-                                if (propagated != phase && a[nk = nb & m] != null) {\n-                                    propagated = phase;\n+                                ran = true;\n+                                if ((!propagated || (j & 1) == 0) && a[nk] != null) {\n+                                    propagated = true;\n@@ -2019,1 +2022,3 @@\n-                                b = q.base;\n+                                b = q.base;               \/\/ refresh\n+                                if ((a = q.array) == null || (m = a.length - 1) < 0)\n+                                    break;\n@@ -2024,1 +2029,2 @@\n-                if (!rescan && ((phase = deactivate(w, phase)) & IDLE) != 0)\n+                propagated = false;\n+                if (((phase = deactivate(w, phase)) & IDLE) != 0)\n@@ -2038,3 +2044,0 @@\n-        if (w == null)                        \/\/ currently impossible\n-            return IDLE;\n-        long e; WorkQueue[] qs; int n;\n@@ -2042,23 +2045,23 @@\n-        long pc = ctl, qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n-        w.stackPred = (int)pc;                \/\/ set ctl stack link\n-        w.phase = p;\n-        if (!compareAndSetCtl(pc, qc))        \/\/ try to enqueue\n-            p = w.phase = activePhase;        \/\/ advance on possible signal\n-        else if (((e = runState) & STOP) != 0L ||\n-                 ((e & SHUTDOWN) != 0L && (qc >> RC_SHIFT) <= 0L &&\n-                  quiescent() > 0) ||\n-                 (qs = queues) == null || (n = qs.length) <= 0)\n-            return IDLE;                      \/\/ terminating\n-        else if ((int)ctl != activePhase)     \/\/ no longer top of ctl stack\n-            p = w.phase;\n-        else {\n-            int step = p, j = p >>> 16, spins = Math.max(n << 1, SPIN_WAITS);\n-            for (int l = n; l > 0; --l, j += step) {\n-                WorkQueue q; long c;          \/\/ missed signal check\n-                if ((q = qs[j & (n - 1)]) != null && q.top - q.base > 0) {\n-                    if ((p = w.phase) != activePhase &&\n-                        (int)(c = ctl) == activePhase &&\n-                        compareAndSetCtl(c, ((pc & LMASK) |\n-                                             ((c + RC_UNIT) & UMASK))))\n-                        p = w.phase = activePhase; \/\/ reactivate\n-                    break;\n+        if (w != null) {                      \/\/ always true\n+            long e;\n+            long pc = ctl, qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n+            w.stackPred = (int)pc;            \/\/ set ctl stack link\n+            w.phase = p;\n+            if (!compareAndSetCtl(pc, qc))    \/\/ try to enqueue\n+                p = w.phase = phase;          \/\/ back out on possible signal\n+            else if (((e = runState) & STOP) == 0L &&\n+                     ((e & SHUTDOWN) == 0L || (qc >> RC_SHIFT) > 0L ||\n+                      quiescent() <= 0) &&    \/\/ termination checks\n+                     (p = w.phase) != activePhase) {\n+                WorkQueue[] qs = queues;      \/\/ missed signal check\n+                int n = (qs == null) ? 0 : qs.length;\n+                for (int i = 0; i < n; ++i) {\n+                    WorkQueue q; long c;\n+                    if ((q = qs[i]) != null && q.top - q.base > 0) {\n+                        if ((p = w.phase) != activePhase &&\n+                            (int)(c = ctl) == activePhase &&\n+                            compareAndSetCtl(c, ((pc & LMASK) |\n+                                                 ((c + RC_UNIT) & UMASK))))\n+                            p = w.phase = activePhase; \/\/ reactivate\n+                        break;\n+                    }\n@@ -2066,4 +2069,2 @@\n-            }\n-            if (p != activePhase && (int)ctl == activePhase) {\n-                while ((p = w.phase) != activePhase && --spins > 0)\n-                    Thread.onSpinWait();      \/\/ reduce flailing\n+                if (p != activePhase)\n+                    p = awaitWork(w, p);      \/\/ block, drop, or exit\n@@ -2072,2 +2073,0 @@\n-        if (p != activePhase)\n-            p = awaitWork(w, p);              \/\/ block, drop, or exit\n@@ -2085,2 +2084,3 @@\n-        if (w != null) {\n-            ForkJoinWorkerThread t; long deadline;\n+        int activePhase = p + IDLE, spins = 0;\n+        if ((runState & STOP) == 0L && w != null && (p = w.phase) != activePhase) {\n+            ForkJoinWorkerThread t;\n@@ -2088,9 +2088,13 @@\n-                t.resetThreadLocals();          \/\/ clear before reactivate\n-            if ((ctl & RC_MASK) > 0L)\n-                deadline = 0L;\n-            else if ((deadline =\n-                      (((w.source != INVALID_ID) ? keepAlive : TIMEOUT_SLOP)) +\n-                      System.currentTimeMillis()) == 0L)\n-                deadline = 1L;                 \/\/ avoid zero\n-            int activePhase = p + IDLE;\n-            if ((p = w.phase) != activePhase && (runState & STOP) == 0L) {\n+                t.resetThreadLocals();         \/\/ clear before reactivate\n+            long deadline = 0L, c = ctl;\n+            if ((int)c == activePhase) {       \/\/ w is at ctl top\n+                if ((c >> RC_SHIFT) <= 0L &&\n+                    (deadline =                \/\/ use timeout\n+                     (((w.source != INVALID_ID) ? keepAlive : TIMEOUT_SLOP)) +\n+                     System.currentTimeMillis()) == 0L)\n+                    deadline = 1L;             \/\/ avoid zero\n+                spins = Math.max(((short)(c >>> TC_SHIFT)) << 2, SPIN_WAITS);\n+                while ((p = w.phase) != activePhase && --spins != 0)\n+                    Thread.onSpinWait();       \/\/ spin at head\n+            }\n+            if (spins == 0) {\n@@ -2599,3 +2603,1 @@\n-                if (q != null && probes == 0)\n-                    reuse = 0;                       \/\/ initial collision\n-                else if (reuse == 0 && probes >= 4)  \/\/ probably nearly full\n+                if (probes >= 4)                     \/\/ probably nearly full\n@@ -2603,0 +2605,2 @@\n+                else if (q != null)\n+                    reuse = 0;                       \/\/ collision\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":90,"deletions":86,"binary":false,"changes":176,"status":"modified"}]}