{"files":[{"patch":"@@ -1439,1 +1439,1 @@\n-                for (;;) {\n+                outer: for (;;) {\n@@ -1446,3 +1446,3 @@\n-                        int s = p - 1;\n-                        long k = slotOffset((cap - 1) & s);\n-                        if (U.getReference(a, k) != null &&\n+                        int s = p - 1; long k;\n+                        if (U.getReference(\n+                                a, k = slotOffset((cap - 1) & s)) != null &&\n@@ -1450,1 +1450,1 @@\n-                             U.getAndSetReference(a, k, null)) != null)\n+                             U.getAndSetReference(a, k, null)) != null) {\n@@ -1452,0 +1452,2 @@\n+                            continue;\n+                        }\n@@ -1455,4 +1457,2 @@\n-                            long k = slotOffset((cap - 1) & b);\n-                            if (U.getReference(a, k) != null &&\n-                                (task = (ForkJoinTask<?>)\n-                                 U.getAndSetReference(a, k, null)) != null) {\n+                            if ((task = (ForkJoinTask<?>)U.getAndSetReference(\n+                                     a, slotOffset((cap - 1) & b), null)) != null) {\n@@ -1460,1 +1460,1 @@\n-                                break;\n+                                continue outer;\n@@ -1468,13 +1468,12 @@\n-                    if (task == null) { \/\/ one-shot steal attempt\n-                        int qb = q.base, qcap; ForkJoinTask<?>[] qa; long bp;\n-                        if ((qa = q.array) != null && (qcap = qa.length) > 0 &&\n-                            (task = (ForkJoinTask<?>)U.getReferenceAcquire(\n-                                qa, bp = slotOffset((qcap - 1) & qb))) != null &&\n-                            q.base == qb &&\n-                            U.compareAndSetReference(qa, bp, task, null)) {\n-                            q.base = qb + 1;\n-                            ++stolen;\n-                        }\n-                        else\n-                            break;\n-                    }\n+\n+                    ForkJoinTask<?> t; ForkJoinTask<?>[] qa; int qcap;\n+                    if ((qa = q.array) == null || (qcap = qa.length) <= 0)\n+                        break;       \/\/ one-shot steal attempt\n+                    int qb = q.base, nqb = qb + 1; long qk;\n+                    if ((t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                             qa, qk = slotOffset((qcap - 1) & qb))) == null ||\n+                        q.base != qb || !U.compareAndSetReference(qa, qk, t, null))\n+                        break;\n+                    q.base = nqb;\n+                    ++stolen;\n+                    task = t;\n@@ -2017,1 +2016,1 @@\n-            int fifo = (int)config & FIFO, rescans = 0, n;\n+            int fifo = (int)config & FIFO, rescans = 0, inactive = 0, n;\n@@ -2039,1 +2038,3 @@\n-                                    (rescans < 0 && q.top - b > 0)) {\n+                                    (rescans < 0 &&\n+                                     (U.getReferenceAcquire(a, bp) != null ||\n+                                      q.top != q.base))) {\n@@ -2043,2 +2044,0 @@\n-                                if (U.getReference(a, bp) != null)\n-                                    continue;             \/\/ stale\n@@ -2047,4 +2046,6 @@\n-                            if ((phase & IDLE) != 0 &&\n-                                ((phase = tryReactivate(w, phase)) & IDLE) != 0) {\n-                                rescans = 1;              \/\/ can't take yet\n-                                break scan;\n+                            else if (inactive != 0) {\n+                                if (((phase = tryReactivate(w, phase)) & IDLE) != 0) {\n+                                    rescans = 1;          \/\/ can't take yet\n+                                    break scan;\n+                                }\n+                                inactive = 0;\n@@ -2052,2 +2053,1 @@\n-                            if (U.getReference(a, bp) == t &&\n-                                U.compareAndSetReference(a, bp, t, null)) {\n+                            else if (U.compareAndSetReference(a, bp, t, null)) {\n@@ -2066,1 +2066,0 @@\n-                int prev;\n@@ -2069,1 +2068,5 @@\n-                else if ((phase = deactivate(w, prev = phase)) == 0)\n+                else if (inactive == 0)\n+                    inactive = (phase = deactivate(w, phase)) & IDLE;\n+                else if (awaitWork(w, phase += IDLE) == 0)\n+                    inactive = rescans = 0;\n+                else\n@@ -2071,2 +2074,0 @@\n-                else if (phase != prev)\n-                    rescans = 0;\n@@ -2078,2 +2079,1 @@\n-     * If active, tries to deactivate worker, keeping active on\n-     * contention; else awaits signal or termination\n+     * Tries to deactivate worker, keeping active on contention\n@@ -2082,2 +2082,2 @@\n-     * @param phase w's currently known phase\n-     * @return current phase or 0 on exit\n+     * @param phase w's current (active) phase\n+     * @return current phase\n@@ -2086,14 +2086,15 @@\n-        if (w != null) {                          \/\/ always true; hoist checks\n-            if ((phase & IDLE) == 0) {\n-                int idlePhase = phase | IDLE;\n-                long pc = ctl, e;\n-                long qc = ((phase + (IDLE << 1)) & LMASK) | ((pc - RC_UNIT) & UMASK);\n-                w.stackPred = (int)pc;            \/\/ set ctl stack link\n-                w.phase = idlePhase;              \/\/ try to enqueue\n-                if (!compareAndSetCtl(pc, qc))\n-                    w.phase = phase;              \/\/ back out on contention\n-                else {\n-                    phase = idlePhase;\n-                    if ((qc & RC_MASK) <= 0L && ((e = runState) & SHUTDOWN) != 0L &&\n-                        (e & STOP) == 0L)\n-                        quiescent();              \/\/ may trigger quiescent termination\n+        if (w != null) {                      \/\/ always true; hoist checks\n+            int idlePhase = phase | IDLE, activePhase = phase + (IDLE << 1);\n+            long pc = ctl;\n+            long qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n+            w.stackPred = (int)pc;            \/\/ set ctl stack link\n+            w.phase = idlePhase;              \/\/ try to enqueue\n+            if (!compareAndSetCtl(pc, qc))\n+                w.phase = phase;              \/\/ back out on contention\n+            else {\n+                phase = idlePhase;            \/\/ check quiescent termination\n+                if ((qc & RC_MASK) > 0L || quiescent() <= 0) {\n+                    int tc = (short)(qc >>> TC_SHIFT); \/\/ approx scan cost\n+                    int spins = Math.max((tc << 2) + 0xf, SPIN_WAITS);\n+                    while ((phase = w.phase) != activePhase && --spins != 0)\n+                        Thread.onSpinWait();  \/\/ spin before rescanning\n@@ -2102,11 +2103,0 @@\n-            else if ((runState & STOP) != 0L)\n-                phase = 0;\n-            else {                                \/\/ spin before blocking\n-                int activePhase = phase + IDLE;\n-                int noise = activePhase | (activePhase >>> 16);\n-                int spins = (SPIN_WAITS << 1) | (noise & (SPIN_WAITS - 1));\n-                while ((phase = w.phase) != activePhase && --spins != 0)\n-                    Thread.onSpinWait();\n-                if (spins == 0 && awaitWork(w, phase = activePhase) != 0)\n-                    phase = 0;\n-            }\n@@ -2142,1 +2132,1 @@\n-        if (w != null) {                      \/\/ always true; hoist checks\n+        if (w != null) {                          \/\/ always true; hoist checks\n@@ -2144,17 +2134,19 @@\n-            LockSupport.setCurrentBlocker(this);\n-            for (long deadline = 0L;;) {\n-                Thread.interrupted();         \/\/ clear status\n-                if ((runState & STOP) != 0L)\n-                    break;\n-                if ((idle = w.phase - activePhase) == 0)\n-                    break;\n-                boolean trimmable = false;    \/\/ use timed wait if trimmable\n-                long d = 0L, c;\n-                if (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase) {\n-                    long now = System.currentTimeMillis();\n-                    if (deadline == 0L)\n-                        deadline = waitTime + now;\n-                    if (deadline - now <= TIMEOUT_SLOP) {\n-                        if (tryTrim(w, c, activePhase))\n-                            break;\n-                        continue;             \/\/ lost race to trim\n+            if ((idle = w.phase - activePhase) != 0) {\n+                LockSupport.setCurrentBlocker(this);\n+                for (long deadline = 0L;;) {\n+                    Thread.interrupted();         \/\/ clear status\n+                    if ((runState & STOP) != 0L)\n+                        break;\n+                    boolean trimmable = false;    \/\/ use timed wait if trimmable\n+                    long d = 0L, c;\n+                    if (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase) {\n+                        long now = System.currentTimeMillis();\n+                        if (deadline == 0L)\n+                            deadline = waitTime + now;\n+                        if (deadline - now <= TIMEOUT_SLOP) {\n+                            if (tryTrim(w, c, activePhase))\n+                                break;\n+                            continue;             \/\/ lost race to trim\n+                        }\n+                        d = deadline;\n+                        trimmable = true;\n@@ -2162,2 +2154,6 @@\n-                    d = deadline;\n-                    trimmable = true;\n+                    w.parking = 1;                \/\/ enable unpark and recheck\n+                    if ((idle = w.phase - activePhase) != 0)\n+                        U.park(trimmable, d);\n+                    w.parking = 0;                \/\/ close unpark window\n+                    if (idle == 0 || (idle = w.phase - activePhase) == 0)\n+                        break;\n@@ -2165,6 +2161,1 @@\n-                w.parking = 1;                \/\/ enable unpark and recheck\n-                if ((idle = w.phase - activePhase) != 0)\n-                    U.park(trimmable, d);\n-                w.parking = 0;                \/\/ close unpark window\n-                if (idle == 0 || (idle = w.phase - activePhase) == 0)\n-                    break;\n+                LockSupport.setCurrentBlocker(null);\n@@ -2172,1 +2163,0 @@\n-            LockSupport.setCurrentBlocker(null);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":83,"deletions":93,"binary":false,"changes":176,"status":"modified"}]}