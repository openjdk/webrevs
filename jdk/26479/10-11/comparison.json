{"files":[{"patch":"@@ -2030,8 +2030,8 @@\n-            int inactive = w.phase |= IDLE;     \/\/ set status\n-            int activePhase = inactive + IDLE;  \/\/ phase value when reactivated\n-            long ap = activePhase & LMASK, pc = ctl, qc;\n-            do {                                \/\/ enqueue\n-                qc = ap | ((pc - RC_UNIT) & UMASK);\n-                w.stackPred = (int)pc;          \/\/ set ctl stack link\n-            } while (pc != (pc = compareAndExchangeCtl(pc, qc)));\n-\n+            int p = w.phase, idlePhase = p | IDLE, activePhase = p + (IDLE << 1);\n+            long pc = ctl, qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n+            w.stackPred = (int)pc;              \/\/ set ctl stack link\n+            w.phase = idlePhase;\n+            if (!compareAndSetCtl(pc, qc)) {    \/\/ try to enqueue\n+                w.phase = p;                    \/\/ back out on contention\n+                idle = 0;\n+            }\n@@ -2039,1 +2039,1 @@\n-            if (((e = runState) & STOP) == 0 && \/\/ quiescence checks\n+            if (idle != 0 && ((e = runState) & STOP) == 0 && \/\/ quiescence checks\n@@ -2073,5 +2073,8 @@\n-        int spins = qsize | (qsize - 1);      \/\/ approx traversal cost\n-        if (w != null) {                      \/\/ always true; hoist checks\n-            boolean trimmable; long deadline, c;\n-            long trimTime = (w.source == INVALID_ID) ? TIMEOUT_SLOP : keepAlive;\n-            if ((w.config & CLEAR_TLS) != 0 && \/\/ instanceof check always true\n+        if ((runState & STOP) == 0L && w != null) {\n+            int cfg = w.config, src = w.source;\n+            long startTime = System.nanoTime();\n+            long minWaitTime = TimeUnit.MILLISECONDS.toNanos(TIMEOUT_SLOP);\n+            long waitTime = (src == INVALID_ID) ? minWaitTime :\n+                TimeUnit.MILLISECONDS.toNanos(keepAlive);\n+            int spins = (qsize << 1) | (qsize - 1); \/\/ approx traversal cost\n+            if ((cfg & CLEAR_TLS) != 0 &&     \/\/ instanceof check always true\n@@ -2081,4 +2084,0 @@\n-            if (trimmable = (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase))\n-                deadline = trimTime + System.currentTimeMillis();\n-            else\n-                deadline = 0L;\n@@ -2086,1 +2085,0 @@\n-                int s = spins, trim;\n@@ -2088,2 +2086,1 @@\n-                if ((runState & STOP) != 0L)\n-                    break;\n+                int s = spins;\n@@ -2091,1 +2088,1 @@\n-                    Thread.onSpinWait();      \/\/ spin before blocking\n+                    Thread.onSpinWait();      \/\/ spin before\/between parks\n@@ -2094,3 +2091,7 @@\n-                if (trimmable &&\n-                    (trim = tryTrim(w, activePhase, deadline)) != 0) {\n-                    if (trim > 0)\n+                if ((runState & STOP) != 0L)\n+                    break;\n+                long wt = waitTime - (System.nanoTime() - startTime);\n+                long parkTime = 0L, c;        \/\/ use timed wait if trimmable\n+                if (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase &&\n+                    (parkTime = wt) <= minWaitTime) {\n+                    if (tryTrim(w, c, activePhase))\n@@ -2098,2 +2099,1 @@\n-                    trimmable = false;\n-                    deadline = 0L;\n+                    continue;                 \/\/ lost race to trim\n@@ -2103,1 +2103,1 @@\n-                    U.park(trimmable, deadline);\n+                    U.park(false, parkTime);  \/\/ timed relative wait if nonzero\n@@ -2115,2 +2115,1 @@\n-     * another to do the same.\n-     * @return > 0: trimmed, < 0 : not trimmable, else 0\n+     * another to do the same unless new tasks are found.\n@@ -2118,23 +2117,18 @@\n-    private int tryTrim(WorkQueue w, int activePhase, long deadline) {\n-        long c, nc; int stat, vp, i; WorkQueue[] vs; WorkQueue v;\n-        long waitTime = deadline - System.currentTimeMillis();\n-        if ((int)(c = ctl) != activePhase || w == null)\n-            stat = -1;                      \/\/ no longer ctl top\n-        else if (waitTime > TIMEOUT_SLOP)\n-            stat = 0;                       \/\/ spurious wakeup\n-        else if (!compareAndSetCtl(\n-                     c, nc = ((w.stackPred & LMASK) | (RC_MASK & c) |\n-                               (TC_MASK & (c - TC_UNIT)))))\n-            stat = -1;                      \/\/ lost race to signaller\n-        else {\n-            stat = 1;\n-            w.source = DROPPED;\n-            w.phase = activePhase;\n-            if ((vp = (int)nc) != 0 && (vs = queues) != null &&\n-                vs.length > (i = vp & SMASK) && (v = vs[i]) != null &&\n-                compareAndSetCtl(           \/\/ try to wake up next waiter\n-                    nc, ((UMASK & (nc + RC_UNIT)) |\n-                         (nc & TC_MASK) | (v.stackPred & LMASK)))) {\n-                v.source = INVALID_ID;      \/\/ enable cascaded timeouts\n-                v.phase = vp;\n-                U.unpark(v.owner);\n+    private boolean tryTrim(WorkQueue w, long c, int activePhase) {\n+        if (w != null) {\n+            int vp, i; WorkQueue[] vs; WorkQueue v;\n+            long nc = ((w.stackPred & LMASK) |\n+                       ((RC_MASK & c) | (TC_MASK & (c - TC_UNIT))));\n+            if (compareAndSetCtl(c, nc)) {\n+                w.source = DROPPED;\n+                w.phase = activePhase;\n+                if ((vp = (int)nc) != 0 && (vs = queues) != null &&\n+                    vs.length > (i = vp & SMASK) && (v = vs[i]) != null &&\n+                    compareAndSetCtl(           \/\/ try to wake up next waiter\n+                        nc, ((v.stackPred & LMASK) |\n+                             ((UMASK & (nc + RC_UNIT)) | (nc & TC_MASK))))) {\n+                    v.source = INVALID_ID;      \/\/ enable cascaded timeouts\n+                    v.phase = vp;\n+                    U.unpark(v.owner);\n+                }\n+                return true;\n@@ -2143,1 +2137,1 @@\n-        return stat;\n+        return false;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":48,"deletions":54,"binary":false,"changes":102,"status":"modified"}]}