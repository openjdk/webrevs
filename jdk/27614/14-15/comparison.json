{"files":[{"patch":"@@ -54,2 +54,0 @@\n-import java.util.List;\n-import java.util.Map;\n@@ -80,1 +78,1 @@\n-    static final class Handler\n+    private static final class Handler\n@@ -189,2 +187,2 @@\n-                \"XDH\", \"XDH\", NamedParameterSpec.X448),\n-        ;\n+                \"XDH\", \"XDH\", NamedParameterSpec.X448);\n+\n@@ -197,1 +195,0 @@\n-\n@@ -258,24 +255,0 @@\n-\n-    public static class HybridService extends Provider.Service {\n-\n-        HybridService(Provider p, String type, String algo, String cn,\n-                List<String> aliases, Map<String, String> attrs) {\n-            super(p, type, algo, cn, aliases, attrs);\n-        }\n-\n-        @Override\n-        public Object newInstance(Object ctrParamObj)\n-                throws NoSuchAlgorithmException {\n-            String type = getType();\n-            return switch (type) {\n-                case \"KeyPairGenerator\" -> new Hybrid.KeyPairGeneratorImpl(\n-                        getAttribute(\"left\"), getAttribute(\"right\"));\n-                case \"KeyFactory\" -> new Hybrid.KeyFactoryImpl(\n-                        getAttribute(\"left\"), getAttribute(\"right\"));\n-                case \"KEM\" -> new Hybrid.KEMImpl(\n-                        getAttribute(\"left\"), getAttribute(\"right\"));\n-                default -> throw new NoSuchAlgorithmException(\n-                        \"Unexpected value: \" + type);\n-            };\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DHasKEM.java","additions":3,"deletions":30,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -57,10 +57,9 @@\n-\/**\n- * The Hybrid class wraps two underlying algorithms (left and right sides)\n- * in a single TLS hybrid named group.\n- * It implements:\n- *  - Hybrid KeyPair generation\n- *  - Hybrid KeyFactory for decoding concatenated hybrid public keys\n- *  - Hybrid KEM implementation for performing encapsulation and\n- *    decapsulation over two underlying algorithms (traditional\n- *    algorithm and post-quantum KEM algorithm)\n- *\/\n+\/\/ The Hybrid class wraps two underlying algorithms (left and right sides)\n+\/\/ in a single TLS hybrid named group.\n+\/\/ It implements:\n+\/\/ - Hybrid KeyPair generation\n+\/\/ - Hybrid KeyFactory for decoding concatenated hybrid public keys\n+\/\/ - Hybrid KEM implementation for performing encapsulation and\n+\/\/   decapsulation over two underlying algorithms (traditional\n+\/\/   algorithm and post-quantum KEM algorithm)\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Hybrid.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.security.NoSuchAlgorithmException;\n+import java.util.List;\n@@ -56,2 +58,2 @@\n-            \/\/ X25519MLKEM768 has been reversed. This is due to IETF\n-            \/\/ historical reasons.\n+            \/\/ X25519MLKEM768 has been reversed as per the current\n+            \/\/ draft RFC.\n@@ -60,1 +62,1 @@\n-            putService(new DHasKEM.HybridService(this, \"KeyPairGenerator\",\n+            putService(new HybridService(this, \"KeyPairGenerator\",\n@@ -64,1 +66,1 @@\n-            putService(new DHasKEM.HybridService(this, \"KEM\",\n+            putService(new HybridService(this, \"KEM\",\n@@ -68,1 +70,1 @@\n-            putService(new DHasKEM.HybridService(this, \"KeyFactory\",\n+            putService(new HybridService(this, \"KeyFactory\",\n@@ -75,1 +77,1 @@\n-            putService(new DHasKEM.HybridService(this, \"KeyPairGenerator\",\n+            putService(new HybridService(this, \"KeyPairGenerator\",\n@@ -79,1 +81,1 @@\n-            putService(new DHasKEM.HybridService(this, \"KEM\",\n+            putService(new HybridService(this, \"KEM\",\n@@ -83,1 +85,1 @@\n-            putService(new DHasKEM.HybridService(this, \"KeyFactory\",\n+            putService(new HybridService(this, \"KeyFactory\",\n@@ -90,1 +92,1 @@\n-            putService(new DHasKEM.HybridService(this, \"KeyPairGenerator\",\n+            putService(new HybridService(this, \"KeyPairGenerator\",\n@@ -94,1 +96,1 @@\n-            putService(new DHasKEM.HybridService(this, \"KEM\",\n+            putService(new HybridService(this, \"KEM\",\n@@ -98,1 +100,1 @@\n-            putService(new DHasKEM.HybridService(this, \"KeyFactory\",\n+            putService(new HybridService(this, \"KeyFactory\",\n@@ -104,0 +106,24 @@\n+\n+    private static class HybridService extends Provider.Service {\n+\n+        HybridService(Provider p, String type, String algo, String cn,\n+                      List<String> aliases, Map<String, String> attrs) {\n+            super(p, type, algo, cn, aliases, attrs);\n+        }\n+\n+        @Override\n+        public Object newInstance(Object ctrParamObj)\n+                throws NoSuchAlgorithmException {\n+            String type = getType();\n+            return switch (type) {\n+                case \"KeyPairGenerator\" -> new Hybrid.KeyPairGeneratorImpl(\n+                        getAttribute(\"left\"), getAttribute(\"right\"));\n+                case \"KeyFactory\" -> new Hybrid.KeyFactoryImpl(\n+                        getAttribute(\"left\"), getAttribute(\"right\"));\n+                case \"KEM\" -> new Hybrid.KEMImpl(\n+                        getAttribute(\"left\"), getAttribute(\"right\"));\n+                default -> throw new NoSuchAlgorithmException(\n+                        \"Unexpected value: \" + type);\n+            };\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HybridProvider.java","additions":37,"deletions":11,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -314,0 +314,1 @@\n+                \/\/ Check KEM's availability via KeyFactory\n@@ -332,1 +333,2 @@\n-                            \"No AlgorithmParameters for \" + name, exp);\n+                            \"No AlgorithmParameters or KeyFactory for \" + name,\n+                                exp);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NamedGroup.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -572,3 +572,3 @@\n-            \/\/ In JSSE for KA flow, the server usually generates its key\n-            \/\/ share and then derives the shared secret after receiving the\n-            \/\/ client's share. However, this is changed for KEM: the server\n+            \/\/ For KA flows, the server first receives the client's share,\n+            \/\/ then generates its key share, and finally comes here.\n+            \/\/ However, this is changed for KEM: the server\n@@ -581,2 +581,2 @@\n-            \/\/   - Each peer computes a shared secret upon receiving the\n-            \/\/     other's key share.\n+            \/\/   - Each peer computes a shared secret sometime after\n+            \/\/     receiving the other's key share.\n@@ -585,8 +585,10 @@\n-            \/\/  The decapsulator (the client) publishes a public key, and\n-            \/\/  the encapsulator (the server) uses it to generate:\n-            \/\/  - the shared secret\n-            \/\/  - the key encapsulation message, which is sent back to the\n-            \/\/    client.\n-            \/\/  - The derived shared secret must be stored in a\n-            \/\/    KEMSenderPossession so it can be retrieved for handshake\n-            \/\/    traffic secret derivation later.\n+            \/\/  The client publishes a public key via a KeyShareExtension,\n+            \/\/  which the server uses to:\n+            \/\/\n+            \/\/  - generate the shared secret\n+            \/\/  - encapsulate the message which is sent to the client in\n+            \/\/    another KeyShareExtension\n+            \/\/\n+            \/\/  The derived shared secret must be stored in a\n+            \/\/  KEMSenderPossession so it can be retrieved for handshake\n+            \/\/  traffic secret derivation later.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"}]}