{"files":[{"patch":"@@ -214,12 +214,0 @@\n-            } else if (\"RAW\".equalsIgnoreCase(key.getFormat())) {\n-                byte[] km = key.getEncoded();\n-                if (km == null) {\n-                    \/\/ Should not happen if format is \"RAW\"\n-                    throw new UnsupportedOperationException(\n-                            \"Key extract failed\");\n-                } else {\n-                    return new SecretKeySpec(km, from, to - from,\n-                            key.getAlgorithm());\n-                }\n-            } else {\n-                throw new UnsupportedOperationException(\"Cannot extract key\");\n@@ -227,0 +215,5 @@\n+\n+            \/\/ Key slicing should never happen. Otherwise, there might be\n+            \/\/ a programming error.\n+            throw new AssertionError(\n+                    \"Unexpected key slicing: from=\" + from + \", to=\" + to);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DHasKEM.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -404,1 +404,2 @@\n-        \/\/ getFormat() returns \"RAW\" if both keys are X509Key; otherwise null.\n+        \/\/ getFormat() returns \"RAW\" as hybrid key uses RAW concatenation\n+        \/\/ of underlying encodings.\n@@ -407,5 +408,1 @@\n-            if (left instanceof X509Key && right instanceof X509Key) {\n-                return \"RAW\";\n-            } else {\n-                return null;\n-            }\n+            return \"RAW\";\n@@ -415,1 +412,1 @@\n-        \/\/ left and right public keys only if both are X509Key types.\n+        \/\/ left and right public keys.\n@@ -418,4 +415,18 @@\n-            if (left instanceof X509Key xk1 && right instanceof X509Key xk2) {\n-                return concat(xk1.getKeyAsBytes(), xk2.getKeyAsBytes());\n-            } else {\n-                return null;\n+            return concat(onlyKey(left), onlyKey(right));\n+        }\n+\n+        static byte[] onlyKey(PublicKey key) {\n+            if (key instanceof X509Key xk) {\n+                return xk.getKeyAsBytes();\n+            }\n+\n+            \/\/ Fallback for 3rd-party providers\n+            if (!\"X.509\".equalsIgnoreCase(key.getFormat())) {\n+                throw new ProviderException(\"Invalid public key encoding \" +\n+                        \"format\");\n+            }\n+            var xk = new X509Key();\n+            try {\n+                xk.decode(key.getEncoded());\n+            } catch (InvalidKeyException e) {\n+                throw new ProviderException(\"Invalid public key encoding\", e);\n@@ -423,0 +434,1 @@\n+            return xk.getKeyAsBytes();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Hybrid.java","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"}]}