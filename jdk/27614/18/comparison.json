{"files":[{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import sun.security.util.ArrayUtil;\n+import sun.security.util.CurveDB;\n+import sun.security.util.ECUtil;\n+import sun.security.util.NamedCurve;\n+\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.KeyAgreement;\n+import javax.crypto.SecretKey;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.*;\n+import java.security.interfaces.ECKey;\n+import java.security.interfaces.ECPublicKey;\n+import java.security.interfaces.XECKey;\n+import java.security.interfaces.XECPublicKey;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.ECPoint;\n+import java.security.spec.ECPublicKeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.security.spec.XECPublicKeySpec;\n+import java.util.Arrays;\n+\n+\/**\n+ * The DHasKEM class presents a KEM abstraction layer over traditional\n+ * DH-based key exchange, which can be used for either straight\n+ * ECDH\/XDH or TLS hybrid key exchanges.\n+ *\n+ * This class can be alongside standard full post-quantum KEMs\n+ * when hybrid implementations are required.\n+ *\/\n+public class DHasKEM implements KEMSpi {\n+\n+    @Override\n+    public EncapsulatorSpi engineNewEncapsulator(\n+            PublicKey publicKey, AlgorithmParameterSpec spec,\n+            SecureRandom secureRandom) throws InvalidKeyException {\n+        return new Handler(publicKey, null, secureRandom);\n+    }\n+\n+    @Override\n+    public DecapsulatorSpi engineNewDecapsulator(PrivateKey privateKey,\n+            AlgorithmParameterSpec spec) throws InvalidKeyException {\n+        return new Handler(null, privateKey, null);\n+    }\n+\n+    private static final class Handler\n+            implements KEMSpi.EncapsulatorSpi, KEMSpi.DecapsulatorSpi {\n+        private final PublicKey pkR;\n+        private final PrivateKey skR;\n+        private final SecureRandom sr;\n+        private final Params params;\n+\n+        Handler(PublicKey pk, PrivateKey sk, SecureRandom sr)\n+                throws InvalidKeyException {\n+            this.pkR = pk;\n+            this.skR = sk;\n+            this.sr = sr;\n+            this.params = paramsFromKey(pk == null ? sk : pk);\n+        }\n+\n+        @Override\n+        public KEM.Encapsulated engineEncapsulate(int from, int to,\n+                String algorithm) {\n+            KeyPair kpE = params.generateKeyPair(sr);\n+            PrivateKey skE = kpE.getPrivate();\n+            PublicKey pkE = kpE.getPublic();\n+            byte[] pkEm = params.SerializePublicKey(pkE);\n+            try {\n+                SecretKey dh = params.DH(algorithm, skE, pkR);\n+                return new KEM.Encapsulated(\n+                        sub(dh, from, to),\n+                        pkEm, null);\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        @Override\n+        public int engineSecretSize() {\n+            return params.secretLen;\n+        }\n+\n+        @Override\n+        public int engineEncapsulationSize() {\n+            return params.publicKeyLen;\n+        }\n+\n+        @Override\n+        public SecretKey engineDecapsulate(byte[] encapsulation, int from,\n+                int to, String algorithm) throws DecapsulateException {\n+            if (encapsulation.length != params.publicKeyLen) {\n+                throw new DecapsulateException(\"incorrect encapsulation size\");\n+            }\n+            try {\n+                PublicKey pkE = params.DeserializePublicKey(encapsulation);\n+                SecretKey dh = params.DH(algorithm, skR, pkE);\n+                return sub(dh, from, to);\n+            } catch (IOException | InvalidKeyException e) {\n+                throw new DecapsulateException(\"Cannot decapsulate\", e);\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        private SecretKey sub(SecretKey key, int from, int to) {\n+            if (from == 0 && to == params.secretLen) {\n+                return key;\n+            }\n+\n+            \/\/ Key slicing should never happen. Otherwise, there might be\n+            \/\/ a programming error.\n+            throw new AssertionError(\n+                    \"Unexpected key slicing: from=\" + from + \", to=\" + to);\n+        }\n+\n+        \/\/ This KEM is designed to be able to represent every ECDH and XDH\n+        private Params paramsFromKey(Key k) throws InvalidKeyException {\n+            if (k instanceof ECKey eckey) {\n+                if (ECUtil.equals(eckey.getParams(), CurveDB.P_256)) {\n+                    return Params.P256;\n+                } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_384)) {\n+                    return Params.P384;\n+                } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_521)) {\n+                    return Params.P521;\n+                }\n+            } else if (k instanceof XECKey xkey\n+                    && xkey.getParams() instanceof NamedParameterSpec ns) {\n+                if (ns.getName().equalsIgnoreCase(\n+                        NamedParameterSpec.X25519.getName())) {\n+                    return Params.X25519;\n+                } else if (ns.getName().equalsIgnoreCase(\n+                        NamedParameterSpec.X448.getName())) {\n+                    return Params.X448;\n+                }\n+            }\n+            throw new InvalidKeyException(\"Unsupported key\");\n+        }\n+    }\n+\n+    private enum Params {\n+\n+        P256(32, 2 * 32 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_256),\n+\n+        P384(48, 2 * 48 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_384),\n+\n+        P521(66, 2 * 66 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_521),\n+\n+        X25519(32, 32,\n+                \"XDH\", \"XDH\", NamedParameterSpec.X25519),\n+\n+        X448(56, 56,\n+                \"XDH\", \"XDH\", NamedParameterSpec.X448);\n+\n+        private final int secretLen;\n+        private final int publicKeyLen;\n+        private final String kaAlgorithm;\n+        private final String keyAlgorithm;\n+        private final AlgorithmParameterSpec spec;\n+\n+        Params(int secretLen, int publicKeyLen, String kaAlgorithm,\n+                String keyAlgorithm, AlgorithmParameterSpec spec) {\n+            this.spec = spec;\n+            this.secretLen = secretLen;\n+            this.publicKeyLen = publicKeyLen;\n+            this.kaAlgorithm = kaAlgorithm;\n+            this.keyAlgorithm = keyAlgorithm;\n+        }\n+\n+        private boolean isEC() {\n+            return this == P256 || this == P384 || this == P521;\n+        }\n+\n+        private KeyPair generateKeyPair(SecureRandom sr) {\n+            try {\n+                KeyPairGenerator g = KeyPairGenerator.getInstance(keyAlgorithm);\n+                g.initialize(spec, sr);\n+                return g.generateKeyPair();\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        private byte[] SerializePublicKey(PublicKey k) {\n+            if (isEC()) {\n+                ECPoint w = ((ECPublicKey) k).getW();\n+                return ECUtil.encodePoint(w, ((NamedCurve) spec).getCurve());\n+            } else {\n+                byte[] uArray = ((XECPublicKey) k).getU().toByteArray();\n+                ArrayUtil.reverse(uArray);\n+                return Arrays.copyOf(uArray, publicKeyLen);\n+            }\n+        }\n+\n+        private PublicKey DeserializePublicKey(byte[] data) throws\n+                IOException, NoSuchAlgorithmException,\n+                InvalidKeySpecException {\n+            KeySpec keySpec;\n+            if (isEC()) {\n+                NamedCurve curve = (NamedCurve) this.spec;\n+                keySpec = new ECPublicKeySpec(\n+                        ECUtil.decodePoint(data, curve.getCurve()), curve);\n+            } else {\n+                data = data.clone();\n+                ArrayUtil.reverse(data);\n+                keySpec = new XECPublicKeySpec(\n+                        this.spec, new BigInteger(1, data));\n+            }\n+            return KeyFactory.getInstance(keyAlgorithm).\n+                    generatePublic(keySpec);\n+        }\n+\n+        private SecretKey DH(String alg, PrivateKey skE, PublicKey pkR)\n+                throws NoSuchAlgorithmException, InvalidKeyException {\n+            KeyAgreement ka = KeyAgreement.getInstance(kaAlgorithm);\n+            ka.init(skE);\n+            ka.doPhase(pkR, true);\n+            return ka.generateSecret(alg);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DHasKEM.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -0,0 +1,475 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import sun.security.util.ArrayUtil;\n+import sun.security.util.CurveDB;\n+import sun.security.util.ECUtil;\n+import sun.security.util.RawKeySpec;\n+import sun.security.x509.X509Key;\n+\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.SecretKey;\n+import java.math.BigInteger;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.KeyFactorySpi;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyPairGeneratorSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+import java.util.Locale;\n+\n+\/\/ The Hybrid class wraps two underlying algorithms (left and right sides)\n+\/\/ in a single TLS hybrid named group.\n+\/\/ It implements:\n+\/\/ - Hybrid KeyPair generation\n+\/\/ - Hybrid KeyFactory for decoding concatenated hybrid public keys\n+\/\/ - Hybrid KEM implementation for performing encapsulation and\n+\/\/   decapsulation over two underlying algorithms (traditional\n+\/\/   algorithm and post-quantum KEM algorithm)\n+\n+public class Hybrid {\n+\n+    public static final NamedParameterSpec X25519_MLKEM768 =\n+            new NamedParameterSpec(\"X25519MLKEM768\");\n+\n+    public static final NamedParameterSpec SECP256R1_MLKEM768 =\n+            new NamedParameterSpec(\"SecP256r1MLKEM768\");\n+\n+    public static final NamedParameterSpec SECP384R1_MLKEM1024 =\n+            new NamedParameterSpec(\"SecP384r1MLKEM1024\");\n+\n+    private static AlgorithmParameterSpec getSpec(String name) {\n+        if (name.startsWith(\"secp\")) {\n+            return new ECGenParameterSpec(name);\n+        } else {\n+            return new NamedParameterSpec(name);\n+        }\n+    }\n+\n+    private static KeyPairGenerator getKeyPairGenerator(String name) throws\n+            NoSuchAlgorithmException {\n+        if (name.startsWith(\"secp\")) {\n+            name = \"EC\";\n+        }\n+        return KeyPairGenerator.getInstance(name);\n+    }\n+\n+    private static KeyFactory getKeyFactory(String name) throws\n+            NoSuchAlgorithmException {\n+        if (name.startsWith(\"secp\")) {\n+            name = \"EC\";\n+        }\n+        return KeyFactory.getInstance(name);\n+    }\n+\n+    \/**\n+     * Returns a KEM instance for each side of the hybrid algorithm.\n+     * For traditional key exchange algorithms, we use the DH-based KEM\n+     * implementation provided by DHasKEM class.\n+     * For ML-KEM post-quantum algorithms, we obtain a KEM instance\n+     * with \"ML-KEM\". This is done to work with 3rd-party providers that\n+     * only have \"ML-KEM\" KEM algorithm.\n+     *\/\n+    private static KEM getKEM(String name) throws NoSuchAlgorithmException {\n+        if (name.startsWith(\"secp\") || name.equals(\"X25519\")) {\n+            return KEM.getInstance(\"DH\", HybridProvider.PROVIDER);\n+        } else {\n+            return KEM.getInstance(\"ML-KEM\");\n+        }\n+    }\n+\n+    public static class KeyPairGeneratorImpl extends KeyPairGeneratorSpi {\n+        private final KeyPairGenerator left;\n+        private final KeyPairGenerator right;\n+        private final AlgorithmParameterSpec leftSpec;\n+        private final AlgorithmParameterSpec rightSpec;\n+\n+        public KeyPairGeneratorImpl(String leftAlg, String rightAlg)\n+                throws NoSuchAlgorithmException  {\n+            left = getKeyPairGenerator(leftAlg);\n+            right = getKeyPairGenerator(rightAlg);\n+            leftSpec = getSpec(leftAlg);\n+            rightSpec = getSpec(rightAlg);\n+        }\n+\n+        @Override\n+        public void initialize(AlgorithmParameterSpec params,\n+                SecureRandom random)\n+                throws InvalidAlgorithmParameterException {\n+            left.initialize(leftSpec, random);\n+            right.initialize(rightSpec, random);\n+        }\n+\n+        @Override\n+        public void initialize(int keysize, SecureRandom random) {\n+            \/\/ NO-OP (do nothing)\n+        }\n+\n+        @Override\n+        public KeyPair generateKeyPair() {\n+            var kp1 = left.generateKeyPair();\n+            var kp2 = right.generateKeyPair();\n+            return new KeyPair(\n+                    new PublicKeyImpl(\"Hybrid\", kp1.getPublic(),\n+                            kp2.getPublic()),\n+                    new PrivateKeyImpl(\"Hybrid\", kp1.getPrivate(),\n+                            kp2.getPrivate()));\n+        }\n+    }\n+\n+    public static class KeyFactoryImpl extends KeyFactorySpi {\n+        private final KeyFactory left;\n+        private final KeyFactory right;\n+        private final int leftlen;\n+        private final String leftname;\n+        private final String rightname;\n+\n+        public KeyFactoryImpl(String left, String right)\n+                throws NoSuchAlgorithmException {\n+            this.left = getKeyFactory(left);\n+            this.right = getKeyFactory(right);\n+            this.leftlen = leftPublicLength(left);\n+            this.leftname = left;\n+            this.rightname = right;\n+        }\n+\n+        @Override\n+        protected PublicKey engineGeneratePublic(KeySpec keySpec)\n+                throws InvalidKeySpecException {\n+            if (keySpec == null) {\n+                throw new InvalidKeySpecException(\"keySpec must not be null\");\n+            }\n+\n+            if (keySpec instanceof RawKeySpec rks) {\n+                byte[] key = rks.getKeyArr();\n+                if (key == null) {\n+                    throw new InvalidKeySpecException(\n+                            \"RawkeySpec contains null key data\");\n+                }\n+                if (key.length <= leftlen) {\n+                    throw new InvalidKeySpecException(\n+                            \"Hybrid key length \" + key.length +\n+                            \" is too short and its left key length is \" +\n+                            leftlen);\n+                }\n+\n+                byte[] leftKeyBytes = Arrays.copyOfRange(key, 0, leftlen);\n+                byte[] rightKeyBytes = Arrays.copyOfRange(key, leftlen,\n+                        key.length);\n+                PublicKey leftKey, rightKey;\n+\n+                try {\n+                    if (leftname.startsWith(\"secp\")) {\n+                        var curve = CurveDB.lookup(leftname);\n+                        var ecSpec = new ECPublicKeySpec(\n+                                ECUtil.decodePoint(leftKeyBytes,\n+                                curve.getCurve()), curve);\n+                        leftKey = left.generatePublic(ecSpec);\n+                    } else if (leftname.startsWith(\"ML-KEM\")) {\n+                        leftKey = left.generatePublic(new RawKeySpec(\n+                                leftKeyBytes));\n+                    } else {\n+                        throw new InvalidKeySpecException(\"Unsupported left\" +\n+                                \" algorithm\" + leftname);\n+                    }\n+\n+                    if (rightname.equals(\"X25519\")) {\n+                        ArrayUtil.reverse(rightKeyBytes);\n+                        var xecSpec = new XECPublicKeySpec(\n+                                new NamedParameterSpec(rightname),\n+                                new BigInteger(1, rightKeyBytes));\n+                        rightKey = right.generatePublic(xecSpec);\n+                    } else if (rightname.startsWith(\"ML-KEM\")) {\n+                        rightKey = right.generatePublic(new RawKeySpec(\n+                                rightKeyBytes));\n+                    } else {\n+                        throw new InvalidKeySpecException(\"Unsupported right\" +\n+                                \" algorithm: \" + rightname);\n+                    }\n+\n+                    return new PublicKeyImpl(\"Hybrid\", leftKey, rightKey);\n+                } catch (Exception e) {\n+                    throw new InvalidKeySpecException(\"Failed to decode \" +\n+                            \"hybrid key\", e);\n+                }\n+            }\n+\n+            throw new InvalidKeySpecException(\n+                    \"KeySpec type:\" +\n+                    keySpec.getClass().getName() + \" not supported\");\n+        }\n+\n+        private static int leftPublicLength(String name) {\n+            return switch (name.toLowerCase(Locale.ROOT)) {\n+                case \"secp256r1\" -> 65;\n+                case \"secp384r1\" -> 97;\n+                case \"ml-kem-768\" -> 1184;\n+                default -> throw new IllegalArgumentException(\n+                        \"Unknown named group: \" + name);\n+            };\n+        }\n+\n+        @Override\n+        protected PrivateKey engineGeneratePrivate(KeySpec keySpec) throws\n+                InvalidKeySpecException {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected <T extends KeySpec> T engineGetKeySpec(Key key,\n+                Class<T> keySpec) throws InvalidKeySpecException {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected Key engineTranslateKey(Key key) throws InvalidKeyException {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public static class KEMImpl implements KEMSpi {\n+        private final KEM left;\n+        private final KEM right;\n+\n+        public KEMImpl(String left, String right)\n+                throws NoSuchAlgorithmException {\n+            this.left = getKEM(left);\n+            this.right = getKEM(right);\n+        }\n+\n+        @Override\n+        public EncapsulatorSpi engineNewEncapsulator(PublicKey publicKey,\n+                AlgorithmParameterSpec spec, SecureRandom secureRandom) throws\n+                InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (publicKey instanceof PublicKeyImpl pk) {\n+                return new Handler(left.newEncapsulator(pk.left, secureRandom),\n+                        right.newEncapsulator(pk.right, secureRandom),\n+                        null, null);\n+            }\n+            throw new InvalidKeyException();\n+        }\n+\n+        @Override\n+        public DecapsulatorSpi engineNewDecapsulator(PrivateKey privateKey,\n+                AlgorithmParameterSpec spec)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (privateKey instanceof PrivateKeyImpl pk) {\n+                return new Handler(null, null, left.newDecapsulator(pk.left),\n+                        right.newDecapsulator(pk.right));\n+            }\n+            throw new InvalidKeyException();\n+        }\n+    }\n+\n+    private static byte[] concat(byte[]... inputs) {\n+        int outLen = 0;\n+        for (byte[] in : inputs) {\n+            outLen += in.length;\n+        }\n+        byte[] out = new byte[outLen];\n+        int pos = 0;\n+        for (byte[] in : inputs) {\n+            System.arraycopy(in, 0, out, pos, in.length);\n+            pos += in.length;\n+        }\n+        return out;\n+    }\n+\n+    private record Handler(KEM.Encapsulator le, KEM.Encapsulator re,\n+            KEM.Decapsulator ld, KEM.Decapsulator rd)\n+            implements KEMSpi.EncapsulatorSpi, KEMSpi.DecapsulatorSpi {\n+        @Override\n+        public KEM.Encapsulated engineEncapsulate(int from, int to,\n+                String algorithm) {\n+            int expectedSecretSize = le.secretSize() + re.secretSize();\n+            if (!(from == 0 && to == expectedSecretSize)) {\n+                throw new IllegalArgumentException(\n+                        \"Invalid range for encapsulation: from = \" + from +\n+                        \" to = \" + to + \", expected total secret size = \" +\n+                        expectedSecretSize);\n+            }\n+\n+            var left  = le.encapsulate();\n+            var right = re.encapsulate();\n+            return new KEM.Encapsulated(\n+                    new SecretKeyImpl(left.key(), right.key()),\n+                    concat(left.encapsulation(), right.encapsulation()),\n+                    null);\n+        }\n+\n+        @Override\n+        public int engineSecretSize() {\n+            if (le != null) {\n+                return le.secretSize() + re.secretSize();\n+            } else {\n+                return ld.secretSize() + rd.secretSize();\n+            }\n+        }\n+\n+        @Override\n+        public int engineEncapsulationSize() {\n+            if (le != null) {\n+                return le.encapsulationSize() + re.encapsulationSize();\n+            } else {\n+                return ld.encapsulationSize() + rd.encapsulationSize();\n+            }\n+        }\n+\n+        @Override\n+        public SecretKey engineDecapsulate(byte[] encapsulation, int from,\n+                int to, String algorithm) throws DecapsulateException {\n+            int leftEncSize = ld.encapsulationSize();\n+            int rightEncSize = rd.encapsulationSize();\n+            int expectedEncSize = leftEncSize + rightEncSize;\n+\n+            if (encapsulation.length != expectedEncSize) {\n+                throw new IllegalArgumentException(\n+                        \"Invalid key encapsulation message length: \" +\n+                        encapsulation.length +\n+                        \", expected = \" + expectedEncSize);\n+            }\n+\n+            int expectedSecretSize = ld.secretSize() + rd.secretSize();\n+            if (!(from == 0 && to == expectedSecretSize)) {\n+                throw new IllegalArgumentException(\n+                        \"Invalid range for decapsulation: from = \" + from +\n+                        \" to = \" + to + \", expected total secret size = \" +\n+                        expectedSecretSize);\n+            }\n+\n+            var left = Arrays.copyOf(encapsulation, leftEncSize);\n+            var right = Arrays.copyOfRange(encapsulation,\n+                    leftEncSize, encapsulation.length);\n+            return new SecretKeyImpl(\n+                    ld.decapsulate(left),\n+                    rd.decapsulate(right)\n+            );\n+        }\n+    }\n+\n+    public record SecretKeyImpl(SecretKey k1, SecretKey k2)\n+            implements SecretKey {\n+        @Override\n+        public String getAlgorithm() {\n+            return \"Generic\";\n+        }\n+\n+        @Override\n+        public String getFormat() {\n+            return null;\n+        }\n+\n+        @Override\n+        public byte[] getEncoded() {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Hybrid public key combines two underlying public keys (left and right).\n+     * Public keys can be transmitted\/encoded because the hybrid protocol\n+     * requires the public component to be sent.\n+     *\/\n+    public record PublicKeyImpl(String algorithm, PublicKey left,\n+            PublicKey right) implements PublicKey {\n+        @Override\n+        public String getAlgorithm() {\n+            return algorithm;\n+        }\n+\n+        \/\/ getFormat() returns \"RAW\" as hybrid key uses RAW concatenation\n+        \/\/ of underlying encodings.\n+        @Override\n+        public String getFormat() {\n+            return \"RAW\";\n+        }\n+\n+        \/\/ getEncoded() returns the concatenation of the encoded bytes of the\n+        \/\/ left and right public keys.\n+        @Override\n+        public byte[] getEncoded() {\n+            return concat(onlyKey(left), onlyKey(right));\n+        }\n+\n+        static byte[] onlyKey(PublicKey key) {\n+            if (key instanceof X509Key xk) {\n+                return xk.getKeyAsBytes();\n+            }\n+\n+            \/\/ Fallback for 3rd-party providers\n+            if (!\"X.509\".equalsIgnoreCase(key.getFormat())) {\n+                throw new ProviderException(\"Invalid public key encoding \" +\n+                        \"format\");\n+            }\n+            var xk = new X509Key();\n+            try {\n+                xk.decode(key.getEncoded());\n+            } catch (InvalidKeyException e) {\n+                throw new ProviderException(\"Invalid public key encoding\", e);\n+            }\n+            return xk.getKeyAsBytes();\n+        }\n+    }\n+\n+    \/**\n+     * Hybrid private key combines two underlying private keys (left and right).\n+     * It is for internal use only. The private keys should never be exported.\n+     *\/\n+    public record PrivateKeyImpl(String algorithm, PrivateKey left,\n+            PrivateKey right) implements PrivateKey {\n+\n+        @Override\n+        public String getAlgorithm() {\n+            return algorithm;\n+        }\n+\n+        \/\/ getFormat() returns null because there is no standard\n+        \/\/ format for a hybrid private key.\n+        @Override\n+        public String getFormat() {\n+            return null;\n+        }\n+\n+        \/\/ getEncoded() returns an empty byte array because there is no\n+        \/\/ standard encoding format for a hybrid private key.\n+        @Override\n+        public byte[] getEncoded() {\n+            return null;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Hybrid.java","additions":475,"deletions":0,"binary":false,"changes":475,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import java.security.Provider;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static sun.security.util.SecurityConstants.PROVIDER_VER;\n+\n+\/\/ This is an internal provider used in the JSSE code for DH-as-KEM\n+\/\/ and Hybrid KEM support. It doesn't actually get installed in the\n+\/\/ system's list of security providers that is searched at runtime.\n+\/\/ JSSE loads this provider internally.\n+\/\/ It registers Hybrid KeyPairGenerator, KeyFactory, and KEM\n+\/\/ implementations for hybrid named groups as Provider services.\n+\n+public class HybridProvider {\n+\n+    public static final Provider PROVIDER = new ProviderImpl();\n+\n+    private static final class ProviderImpl extends Provider {\n+        @java.io.Serial\n+        private static final long serialVersionUID = 0L;\n+\n+        ProviderImpl() {\n+            super(\"HybridAndDHAsKEM\", PROVIDER_VER,\n+                    \"Hybrid and DHAsKEM provider\");\n+            put(\"KEM.DH\", DHasKEM.class.getName());\n+\n+            \/\/ Hybrid KeyPairGenerator\/KeyFactory\/KEM\n+\n+            \/\/ The order of shares in the concatenation for group name\n+            \/\/ X25519MLKEM768 has been reversed as per the current\n+            \/\/ draft RFC.\n+            var attrs = Map.of(\"name\", \"X25519MLKEM768\", \"left\", \"ML-KEM-768\",\n+                    \"right\", \"X25519\");\n+            putService(new HybridService(this, \"KeyPairGenerator\",\n+                    \"X25519MLKEM768\",\n+                    \"sun.security.ssl.Hybrid$KeyPairGeneratorImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KEM\",\n+                    \"X25519MLKEM768\",\n+                    \"sun.security.ssl.Hybrid$KEMImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KeyFactory\",\n+                    \"X25519MLKEM768\",\n+                    \"sun.security.ssl.Hybrid$KeyFactoryImpl\",\n+                    null, attrs));\n+\n+            attrs = Map.of(\"name\", \"SecP256r1MLKEM768\", \"left\", \"secp256r1\",\n+                    \"right\", \"ML-KEM-768\");\n+            putService(new HybridService(this, \"KeyPairGenerator\",\n+                    \"SecP256r1MLKEM768\",\n+                    \"sun.security.ssl.Hybrid$KeyPairGeneratorImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KEM\",\n+                    \"SecP256r1MLKEM768\",\n+                    \"sun.security.ssl.Hybrid$KEMImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KeyFactory\",\n+                    \"SecP256r1MLKEM768\",\n+                    \"sun.security.ssl.Hybrid$KeyFactoryImpl\",\n+                    null, attrs));\n+\n+            attrs = Map.of(\"name\", \"SecP384r1MLKEM1024\", \"left\", \"secp384r1\",\n+                    \"right\", \"ML-KEM-1024\");\n+            putService(new HybridService(this, \"KeyPairGenerator\",\n+                    \"SecP384r1MLKEM1024\",\n+                    \"sun.security.ssl.Hybrid$KeyPairGeneratorImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KEM\",\n+                    \"SecP384r1MLKEM1024\",\n+                    \"sun.security.ssl.Hybrid$KEMImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KeyFactory\",\n+                    \"SecP384r1MLKEM1024\",\n+                    \"sun.security.ssl.Hybrid$KeyFactoryImpl\",\n+                    null, attrs));\n+        }\n+    }\n+\n+    private static class HybridService extends Provider.Service {\n+\n+        HybridService(Provider p, String type, String algo, String cn,\n+                      List<String> aliases, Map<String, String> attrs) {\n+            super(p, type, algo, cn, aliases, attrs);\n+        }\n+\n+        @Override\n+        public Object newInstance(Object ctrParamObj)\n+                throws NoSuchAlgorithmException {\n+            String type = getType();\n+            return switch (type) {\n+                case \"KeyPairGenerator\" -> new Hybrid.KeyPairGeneratorImpl(\n+                        getAttribute(\"left\"), getAttribute(\"right\"));\n+                case \"KeyFactory\" -> new Hybrid.KeyFactoryImpl(\n+                        getAttribute(\"left\"), getAttribute(\"right\"));\n+                case \"KEM\" -> new Hybrid.KEMImpl(\n+                        getAttribute(\"left\"), getAttribute(\"right\"));\n+                default -> throw new NoSuchAlgorithmException(\n+                        \"Unexpected value: \" + type);\n+            };\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HybridProvider.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+import sun.security.util.RawKeySpec;\n+\n@@ -28,0 +30,1 @@\n+import javax.crypto.KEM;\n@@ -35,0 +38,1 @@\n+import java.security.KeyFactory;\n@@ -36,0 +40,1 @@\n+import java.security.Provider;\n@@ -37,1 +42,1 @@\n-import java.security.spec.AlgorithmParameterSpec;\n+import java.security.SecureRandom;\n@@ -49,0 +54,2 @@\n+    private final byte[] keyshare;\n+    private final Provider provider;\n@@ -50,0 +57,1 @@\n+    \/\/ Constructor called by Key Agreement\n@@ -54,0 +62,12 @@\n+        this(algorithmName, null, context, localPrivateKey,\n+                peerPublicKey, null);\n+    }\n+\n+    \/\/ When the constructor called by KEM: store the client's public key or the\n+    \/\/ encapsulated message in keyshare.\n+    KAKeyDerivation(String algorithmName,\n+                    NamedGroup namedGroup,\n+                    HandshakeContext context,\n+                    PrivateKey localPrivateKey,\n+                    PublicKey peerPublicKey,\n+                    byte[] keyshare) {\n@@ -58,0 +78,2 @@\n+        this.keyshare = keyshare;\n+        this.provider = (namedGroup != null) ? namedGroup.getProvider() : null;\n@@ -97,6 +119,3 @@\n-    \/**\n-     * Handle the TLSv1.3 objects, which use the HKDF algorithms.\n-     *\/\n-    private SecretKey t13DeriveKey(String type)\n-            throws IOException {\n-        SecretKey sharedSecret = null;\n+    private SecretKey deriveHandshakeSecret(String label,\n+            SecretKey sharedSecret)\n+            throws GeneralSecurityException, IOException {\n@@ -105,5 +124,0 @@\n-        try {\n-            KeyAgreement ka = KeyAgreement.getInstance(algorithmName);\n-            ka.init(localPrivateKey);\n-            ka.doPhase(peerPublicKey, true);\n-            sharedSecret = ka.generateSecret(\"TlsPremasterSecret\");\n@@ -111,2 +125,3 @@\n-            CipherSuite.HashAlg hashAlg = context.negotiatedCipherSuite.hashAlg;\n-            SSLKeyDerivation kd = context.handshakeKeyDerivation;\n+        CipherSuite.HashAlg hashAlg = context.negotiatedCipherSuite.hashAlg;\n+        SSLKeyDerivation kd = context.handshakeKeyDerivation;\n+        try {\n@@ -132,2 +147,80 @@\n-            return hkdf.deriveKey(type, HKDFParameterSpec.ofExtract()\n-                    .addSalt(saltSecret).addIKM(sharedSecret).extractOnly());\n+            var spec = HKDFParameterSpec.ofExtract().addSalt(saltSecret);\n+            if (sharedSecret instanceof Hybrid.SecretKeyImpl hsk) {\n+                spec = spec.addIKM(hsk.k1()).addIKM(hsk.k2());\n+            } else {\n+                spec = spec.addIKM(sharedSecret);\n+            }\n+\n+            return hkdf.deriveKey(label, spec.extractOnly());\n+        } finally {\n+            KeyUtil.destroySecretKeys(earlySecret, saltSecret);\n+        }\n+    }\n+    \/**\n+     * This method is called by the server to perform KEM encapsulation.\n+     * It uses the client's public key (sent by the client as a keyshare)\n+     * to encapsulate a shared secret and returns the encapsulated message.\n+     *\n+     * Package-private, used from KeyShareExtension.SHKeyShareProducer::\n+     * produce().\n+     *\/\n+    KEM.Encapsulated encapsulate(String algorithm, SecureRandom random)\n+            throws IOException {\n+        SecretKey sharedSecret = null;\n+\n+        if (keyshare == null) {\n+            throw new IOException(\"No keyshare available for KEM \" +\n+                    \"encapsulation\");\n+        }\n+\n+        try {\n+            KeyFactory kf = (provider != null) ?\n+                    KeyFactory.getInstance(algorithmName, provider) :\n+                    KeyFactory.getInstance(algorithmName);\n+            var pk = kf.generatePublic(new RawKeySpec(keyshare));\n+\n+            KEM kem = (provider != null) ?\n+                    KEM.getInstance(algorithmName, provider) :\n+                    KEM.getInstance(algorithmName);\n+            KEM.Encapsulator e = kem.newEncapsulator(pk, random);\n+            KEM.Encapsulated enc = e.encapsulate();\n+            sharedSecret = enc.key();\n+\n+            SecretKey derived = deriveHandshakeSecret(algorithm, sharedSecret);\n+\n+            return new KEM.Encapsulated(derived, enc.encapsulation(), null);\n+        } catch (GeneralSecurityException gse) {\n+            throw new SSLHandshakeException(\"Could not generate secret\", gse);\n+        } finally {\n+            KeyUtil.destroySecretKeys(sharedSecret);\n+        }\n+    }\n+\n+    \/**\n+     * Handle the TLSv1.3 objects, which use the HKDF algorithms.\n+     *\/\n+    private SecretKey t13DeriveKey(String type)\n+            throws IOException {\n+        SecretKey sharedSecret = null;\n+\n+        try {\n+            if (keyshare != null) {\n+                \/\/ Using KEM: called by the client after receiving the KEM\n+                \/\/ ciphertext (keyshare) from the server in ServerHello.\n+                \/\/ The client decapsulates it using its private key.\n+                KEM kem = (provider != null)\n+                        ? KEM.getInstance(algorithmName, provider)\n+                        : KEM.getInstance(algorithmName);\n+                var decapsulator = kem.newDecapsulator(localPrivateKey);\n+                sharedSecret = decapsulator.decapsulate(\n+                        keyshare, 0, decapsulator.secretSize(),\n+                        \"TlsPremasterSecret\");\n+            } else {\n+                \/\/ Using traditional DH-style Key Agreement\n+                KeyAgreement ka = KeyAgreement.getInstance(algorithmName);\n+                ka.init(localPrivateKey);\n+                ka.doPhase(peerPublicKey, true);\n+                sharedSecret = ka.generateSecret(\"TlsPremasterSecret\");\n+            }\n+\n+            return deriveHandshakeSecret(type, sharedSecret);\n@@ -137,1 +230,1 @@\n-            KeyUtil.destroySecretKeys(sharedSecret, earlySecret, saltSecret);\n+            KeyUtil.destroySecretKeys(sharedSecret);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KAKeyDerivation.java","additions":110,"deletions":17,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.ssl;\n+\n+import java.io.IOException;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.PrivateKey;\n+import java.security.Provider;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.NamedParameterSpec;\n+import javax.crypto.SecretKey;\n+\n+import sun.security.ssl.NamedGroup.NamedGroupSpec;\n+import sun.security.x509.X509Key;\n+\n+\/**\n+ * Specifics for single or hybrid Key exchanges based on KEM\n+ *\/\n+final class KEMKeyExchange {\n+\n+    static final SSLKeyAgreementGenerator kemKAGenerator\n+            = new KEMKAGenerator();\n+\n+    static final class KEMCredentials implements NamedGroupCredentials {\n+\n+        final NamedGroup namedGroup;\n+        \/\/ Unlike other credentials, we directly store the key share\n+        \/\/ value here, no need to convert to a key\n+        private final byte[] keyshare;\n+\n+        KEMCredentials(byte[] keyshare, NamedGroup namedGroup) {\n+            this.keyshare = keyshare;\n+            this.namedGroup = namedGroup;\n+        }\n+\n+        \/\/ For KEM, server performs encapsulation and the resulting\n+        \/\/ encapsulated message becomes the key_share value sent to\n+        \/\/ the client. It is not a public key, so no PublicKey object\n+        \/\/ to return.\n+        @Override\n+        public PublicKey getPublicKey() {\n+            throw new UnsupportedOperationException(\n+                    \"KEMCredentials stores raw keyshare, not a PublicKey\");\n+        }\n+\n+        public byte[] getKeyShare() {\n+            return keyshare;\n+        }\n+\n+        @Override\n+        public NamedGroup getNamedGroup() {\n+            return namedGroup;\n+        }\n+\n+        \/**\n+         * Instantiates a KEMCredentials object\n+         *\/\n+        static KEMCredentials valueOf(NamedGroup namedGroup,\n+                byte[] encodedPoint) {\n+\n+            if (namedGroup.spec != NamedGroupSpec.NAMED_GROUP_KEM) {\n+                throw new RuntimeException(\n+                        \"Credentials decoding: Not KEM named group\");\n+            }\n+\n+            if (encodedPoint == null || encodedPoint.length == 0) {\n+                return null;\n+            }\n+\n+            return new KEMCredentials(encodedPoint, namedGroup);\n+        }\n+    }\n+\n+    private static class KEMPossession implements SSLPossession {\n+        private final NamedGroup namedGroup;\n+\n+        public KEMPossession(NamedGroup ng) {\n+            this.namedGroup = ng;\n+        }\n+        public NamedGroup getNamedGroup() {\n+            return namedGroup;\n+        }\n+    }\n+\n+    static final class KEMReceiverPossession extends KEMPossession {\n+\n+        private final PrivateKey privateKey;\n+        private final PublicKey publicKey;\n+\n+        KEMReceiverPossession(NamedGroup namedGroup, SecureRandom random) {\n+            super(namedGroup);\n+            String algName = null;\n+            try {\n+                \/\/ For KEM: This receiver side (client) generates a key pair.\n+                algName = ((NamedParameterSpec)namedGroup.keAlgParamSpec).\n+                        getName();\n+                Provider provider = namedGroup.getProvider();\n+                KeyPairGenerator kpg = (provider != null) ?\n+                        KeyPairGenerator.getInstance(algName, provider) :\n+                        KeyPairGenerator.getInstance(algName);\n+\n+                kpg.initialize(namedGroup.keAlgParamSpec, random);\n+                KeyPair kp = kpg.generateKeyPair();\n+                privateKey = kp.getPrivate();\n+                publicKey = kp.getPublic();\n+            } catch (GeneralSecurityException e) {\n+                throw new RuntimeException(\n+                        \"Could not generate keypair for algorithm: \" +\n+                        algName, e);\n+            }\n+        }\n+\n+        @Override\n+        public byte[] encode() {\n+            if (publicKey instanceof X509Key xk) {\n+                return xk.getKeyAsBytes();\n+            } else if (publicKey instanceof Hybrid.PublicKeyImpl hk) {\n+                return hk.getEncoded();\n+            }\n+            throw new ProviderException(\"Unsupported key type: \" + publicKey);\n+        }\n+\n+        \/\/ Package-private\n+        PublicKey getPublicKey() {\n+            return publicKey;\n+        }\n+\n+        \/\/ Package-private\n+        PrivateKey getPrivateKey() {\n+            return privateKey;\n+        }\n+    }\n+\n+    static final class KEMSenderPossession extends KEMPossession {\n+\n+        private SecretKey key;\n+        private final SecureRandom random;\n+\n+        KEMSenderPossession(NamedGroup namedGroup, SecureRandom random) {\n+            super(namedGroup);\n+            this.random = random;\n+        }\n+\n+        \/\/ Package-private\n+        SecureRandom getRandom() {\n+            return random;\n+        }\n+\n+        \/\/ Package-private\n+        SecretKey getKey() {\n+            return key;\n+        }\n+\n+        \/\/ Package-private\n+        void setKey(SecretKey key) {\n+            this.key = key;\n+        }\n+\n+        @Override\n+        public byte[] encode() {\n+            throw new UnsupportedOperationException(\"encode() not supported\");\n+        }\n+    }\n+\n+    private static final class KEMKAGenerator\n+            implements SSLKeyAgreementGenerator {\n+\n+        \/\/ Prevent instantiation of this class.\n+        private KEMKAGenerator() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public SSLKeyDerivation createKeyDerivation(\n+                HandshakeContext context) throws IOException {\n+            for (SSLPossession poss : context.handshakePossessions) {\n+                if (poss instanceof KEMReceiverPossession kposs) {\n+                    NamedGroup ng = kposs.getNamedGroup();\n+                    for (SSLCredentials cred : context.handshakeCredentials) {\n+                        if (cred instanceof KEMCredentials kcred &&\n+                                ng.equals(kcred.namedGroup)) {\n+                            String name = ((NamedParameterSpec)\n+                                    ng.keAlgParamSpec).getName();\n+                            return new KAKeyDerivation(name, ng, context,\n+                                    kposs.getPrivateKey(), null,\n+                                    kcred.getKeyShare());\n+                        }\n+                    }\n+                }\n+            }\n+            context.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                    \"No suitable KEM key agreement \"\n+                    + \"parameters negotiated\");\n+            return null;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KEMKeyExchange.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import java.security.AlgorithmConstraints;\n@@ -32,0 +33,2 @@\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n@@ -300,1 +303,3 @@\n-                    if (pos instanceof NamedGroupPossession) {\n+                    if (pos instanceof NamedGroupPossession ||\n+                            pos instanceof\n+                            KEMKeyExchange.KEMReceiverPossession) {\n@@ -361,12 +366,0 @@\n-                    if (shc.algorithmConstraints != null &&\n-                            kaCred instanceof\n-                                NamedGroupCredentials namedGroupCredentials) {\n-                        if (!shc.algorithmConstraints.permits(\n-                                EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n-                                namedGroupCredentials.getPublicKey())) {\n-                            if (SSLLogger.isOn() &&\n-                                    SSLLogger.isOn(\"ssl,handshake\")) {\n-                                SSLLogger.warning(\n-                                    \"key share entry of \" + ng + \" does not \" +\n-                                    \" comply with algorithm constraints\");\n-                            }\n@@ -374,1 +367,7 @@\n-                            kaCred = null;\n+                    if (!isCredentialPermitted(shc.algorithmConstraints,\n+                            kaCred)) {\n+                        if (SSLLogger.isOn() &&\n+                                SSLLogger.isOn(\"ssl,handshake\")) {\n+                            SSLLogger.warning(\n+                                    \"key share entry of \" + ng + \" does not \" +\n+                                    \"comply with algorithm constraints\");\n@@ -376,3 +375,1 @@\n-                    }\n-\n-                    if (kaCred != null) {\n+                    } else {\n@@ -516,1 +513,2 @@\n-            \/\/ The producing happens in client side only.\n+            \/\/ The producing happens in server side only.\n+\n@@ -574,1 +572,3 @@\n-                    if (!(pos instanceof NamedGroupPossession)) {\n+                    if (!(pos instanceof NamedGroupPossession ||\n+                            pos instanceof\n+                            KEMKeyExchange.KEMSenderPossession)) {\n@@ -582,1 +582,28 @@\n-                    keyShare = new KeyShareEntry(ng.id, pos.encode());\n+\n+                    \/\/ For KEM, perform encapsulation using the clients public\n+                    \/\/ key (KEMCredentials). The resulting encapsulated message\n+                    \/\/ becomes the key_share value sent to the client. The\n+                    \/\/ shared secret derived from encapsulation is stored in\n+                    \/\/ the KEMSenderPossession for later use in the TLS key\n+                    \/\/ schedule.\n+\n+                    \/\/ SSLKeyExchange.createPossessions() returns at most one\n+                    \/\/ key-agreement possession or one KEMSenderPossession\n+                    \/\/ per handshake.\n+                    if (pos instanceof KEMKeyExchange.KEMSenderPossession xp) {\n+                        if (cd instanceof KEMKeyExchange.KEMCredentials kcred\n+                                && ng.equals(kcred.namedGroup)) {\n+                            String name = ((NamedParameterSpec)\n+                                    ng.keAlgParamSpec).getName();\n+                            KAKeyDerivation handshakeKD = new KAKeyDerivation(\n+                                    name, ng, shc, null, null,\n+                                    kcred.getKeyShare());\n+                            var encaped = handshakeKD.encapsulate(\n+                                    \"TlsHandshakeSecret\", xp.getRandom());\n+                            xp.setKey(encaped.key());\n+                            keyShare = new KeyShareEntry(ng.id,\n+                                    encaped.encapsulation());\n+                        }\n+                    } else {\n+                        keyShare = new KeyShareEntry(ng.id, pos.encode());\n+                    }\n@@ -666,11 +693,0 @@\n-                if (chc.algorithmConstraints != null &&\n-                        kaCred instanceof\n-                                NamedGroupCredentials namedGroupCredentials) {\n-                    if (!chc.algorithmConstraints.permits(\n-                            EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n-                            namedGroupCredentials.getPublicKey())) {\n-                        chc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,\n-                            \"key share entry of \" + ng + \" does not \" +\n-                            \" comply with algorithm constraints\");\n-                    }\n-                }\n@@ -678,1 +694,6 @@\n-                if (kaCred != null) {\n+                if (!isCredentialPermitted(chc.algorithmConstraints,\n+                        kaCred)) {\n+                    chc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,\n+                            \"key share entry of \" + ng + \" does not \" +\n+                            \"comply with algorithm constraints\");\n+                } else {\n@@ -699,0 +720,28 @@\n+    private static boolean isCredentialPermitted(\n+            AlgorithmConstraints constraints,\n+            SSLCredentials cred) {\n+\n+        if (constraints == null) return true;\n+        if (cred == null) return false;\n+\n+        if (cred instanceof NamedGroupCredentials namedGroupCred) {\n+            if (namedGroupCred instanceof KEMKeyExchange.KEMCredentials\n+                    kemCred) {\n+                AlgorithmParameterSpec paramSpec = kemCred.getNamedGroup().\n+                        keAlgParamSpec;\n+                String algName = (paramSpec instanceof NamedParameterSpec nps) ?\n+                        nps.getName() : null;\n+                return algName != null && constraints.permits(\n+                        EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n+                        algName,\n+                        null);\n+            } else {\n+                return constraints.permits(\n+                        EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n+                        namedGroupCred.getPublicKey());\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KeyShareExtension.java","additions":81,"deletions":32,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,0 +217,33 @@\n+    ML_KEM_512(0x0200, \"MLKEM512\",\n+            NamedGroupSpec.NAMED_GROUP_KEM,\n+            ProtocolVersion.PROTOCOLS_OF_13,\n+            null),\n+\n+    ML_KEM_768(0x0201, \"MLKEM768\",\n+            NamedGroupSpec.NAMED_GROUP_KEM,\n+            ProtocolVersion.PROTOCOLS_OF_13,\n+            null),\n+\n+    ML_KEM_1024(0x0202, \"MLKEM1024\",\n+            NamedGroupSpec.NAMED_GROUP_KEM,\n+            ProtocolVersion.PROTOCOLS_OF_13,\n+            null),\n+\n+    X25519MLKEM768(0x11ec, \"X25519MLKEM768\",\n+            NamedGroupSpec.NAMED_GROUP_KEM,\n+            ProtocolVersion.PROTOCOLS_OF_13,\n+            Hybrid.X25519_MLKEM768,\n+            HybridProvider.PROVIDER),\n+\n+    SECP256R1MLKEM768(0x11eb, \"SecP256r1MLKEM768\",\n+            NamedGroupSpec.NAMED_GROUP_KEM,\n+            ProtocolVersion.PROTOCOLS_OF_13,\n+            Hybrid.SECP256R1_MLKEM768,\n+            HybridProvider.PROVIDER),\n+\n+    SECP384R1MLKEM1024(0x11ed, \"SecP384r1MLKEM1024\",\n+            NamedGroupSpec.NAMED_GROUP_KEM,\n+            ProtocolVersion.PROTOCOLS_OF_13,\n+            Hybrid.SECP384R1_MLKEM1024,\n+            HybridProvider.PROVIDER),\n+\n@@ -237,0 +270,1 @@\n+    final Provider defaultProvider;\n@@ -242,1 +276,0 @@\n-    \/\/ Constructor used for all NamedGroup types\n@@ -247,0 +280,10 @@\n+        this(id, name, namedGroupSpec, supportedProtocols, keAlgParamSpec,\n+                null);\n+    }\n+\n+    \/\/ Constructor used for all NamedGroup types\n+    NamedGroup(int id, String name,\n+            NamedGroupSpec namedGroupSpec,\n+            ProtocolVersion[] supportedProtocols,\n+            AlgorithmParameterSpec keAlgParamSpec,\n+            Provider defaultProvider) {\n@@ -253,0 +296,1 @@\n+        this.defaultProvider = defaultProvider;\n@@ -269,3 +313,14 @@\n-                algParams =\n-                    AlgorithmParameters.getInstance(namedGroupSpec.algorithm);\n-                algParams.init(keAlgParamSpec);\n+                \/\/ Skip AlgorithmParameters for KEMs (not supported)\n+                \/\/ Check KEM's availability via KeyFactory\n+                if (namedGroupSpec == NamedGroupSpec.NAMED_GROUP_KEM) {\n+                    if (defaultProvider == null) {\n+                        KeyFactory.getInstance(name);\n+                    } else {\n+                        KeyFactory.getInstance(name, defaultProvider);\n+                    }\n+                } else {\n+                    \/\/ ECDHE or others: use AlgorithmParameters as before\n+                    algParams = AlgorithmParameters.getInstance(\n+                            namedGroupSpec.algorithm);\n+                    algParams.init(keAlgParamSpec);\n+                }\n@@ -278,1 +333,2 @@\n-                            \"No AlgorithmParameters for \" + name, exp);\n+                            \"No AlgorithmParameters or KeyFactory for \" + name,\n+                                exp);\n@@ -310,0 +366,4 @@\n+    Provider getProvider() {\n+        return defaultProvider;\n+    }\n+\n@@ -548,0 +608,4 @@\n+    SSLPossession createPossession(boolean isClient, SecureRandom random) {\n+        return spec.createPossession(this, isClient, random);\n+    }\n+\n@@ -569,0 +633,5 @@\n+\n+        default SSLPossession createPossession(NamedGroup ng, boolean isClient,\n+                SecureRandom random) {\n+            return createPossession(ng, random);\n+        }\n@@ -581,0 +650,4 @@\n+        \/\/ Post-Quantum Cryptography (PQC) KEM groups\n+        \/\/ Currently used for hybrid named groups\n+        NAMED_GROUP_KEM(\"KEM\", KEMScheme.instance),\n+\n@@ -637,0 +710,9 @@\n+        public SSLPossession createPossession(\n+                NamedGroup ng, boolean isClient, SecureRandom random) {\n+            if (scheme != null) {\n+                return scheme.createPossession(ng, isClient, random);\n+            }\n+\n+            return null;\n+        }\n+\n@@ -742,0 +824,36 @@\n+    private static class KEMScheme implements NamedGroupScheme {\n+        private static final KEMScheme instance = new KEMScheme();\n+\n+        @Override\n+        public byte[] encodePossessionPublicKey(NamedGroupPossession poss) {\n+            return poss.encode();\n+        }\n+\n+        @Override\n+        public SSLCredentials decodeCredentials(NamedGroup ng,\n+                byte[] encoded) throws IOException, GeneralSecurityException {\n+            return KEMKeyExchange.KEMCredentials.valueOf(ng, encoded);\n+        }\n+\n+        @Override\n+        public SSLPossession createPossession(NamedGroup ng,\n+                SecureRandom random) {\n+            \/\/ Must call createPossession with isClient\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public SSLPossession createPossession(\n+                NamedGroup ng, boolean isClient, SecureRandom random) {\n+            return isClient\n+                    ? new KEMKeyExchange.KEMReceiverPossession(ng, random)\n+                    : new KEMKeyExchange.KEMSenderPossession(ng, random);\n+        }\n+\n+        @Override\n+        public SSLKeyDerivation createKeyDerivation(\n+                HandshakeContext hc) throws IOException {\n+            return KEMKeyExchange.kemKAGenerator.createKeyDerivation(hc);\n+        }\n+    }\n+\n@@ -787,0 +905,3 @@\n+                        \/\/ Hybrid key agreement\n+                        X25519MLKEM768,\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NamedGroup.java","additions":127,"deletions":6,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -573,1 +573,3 @@\n-            return namedGroup.createPossession(hc.sslContext.getSecureRandom());\n+            return namedGroup.createPossession(\n+                    hc instanceof ClientHandshakeContext,\n+                    hc.sslContext.getSecureRandom());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLKeyExchange.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -568,0 +568,28 @@\n+            \/\/ For key derivation, we will either use the traditional Key\n+            \/\/ Agreement (KA) model or the Key Encapsulation Mechanism (KEM)\n+            \/\/ model, depending on what key exchange group is used.\n+            \/\/\n+            \/\/ For KA flows, the server first receives the client's share,\n+            \/\/ then generates its key share, and finally comes here.\n+            \/\/ However, this is changed for KEM: the server\n+            \/\/ must perform both actions  derive the secret and generate\n+            \/\/ the key encapsulation message at the same time during\n+            \/\/ encapsulation in SHKeyShareProducer.\n+            \/\/\n+            \/\/ Traditional Key Agreement (KA):\n+            \/\/   - Both peers generate a key share and exchange it.\n+            \/\/   - Each peer computes a shared secret sometime after\n+            \/\/     receiving the other's key share.\n+            \/\/\n+            \/\/ Key Encapsulation Mechanism (KEM):\n+            \/\/  The client publishes a public key via a KeyShareExtension,\n+            \/\/  which the server uses to:\n+            \/\/\n+            \/\/  - generate the shared secret\n+            \/\/  - encapsulate the message which is sent to the client in\n+            \/\/    another KeyShareExtension\n+            \/\/\n+            \/\/  The derived shared secret must be stored in a\n+            \/\/  KEMSenderPossession so it can be retrieved for handshake\n+            \/\/  traffic secret derivation later.\n+\n@@ -593,3 +621,20 @@\n-            SSLKeyDerivation handshakeKD = ke.createKeyDerivation(shc);\n-            SecretKey handshakeSecret = handshakeKD.deriveKey(\n-                    \"TlsHandshakeSecret\");\n+            SecretKey handshakeSecret = null;\n+\n+            \/\/ For KEM, the shared secret has already been generated and\n+            \/\/ stored in the servers possession (KEMSenderPossession)\n+            \/\/ during encapsulation in SHKeyShareProducer.\n+            \/\/\n+            \/\/ Only one key share is selected by the server, so at most one\n+            \/\/ possession will contain the pre-derived shared secret.\n+            for (var pos : shc.handshakePossessions) {\n+                if (pos instanceof KEMKeyExchange.KEMSenderPossession xp) {\n+                    handshakeSecret = xp.getKey();\n+                    break;\n+                }\n+            }\n+\n+            if (handshakeSecret == null) {\n+                SSLKeyDerivation handshakeKD = ke.createKeyDerivation(shc);\n+                handshakeSecret = handshakeKD.deriveKey(\n+                        \"TlsHandshakeSecret\");\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -107,0 +107,4 @@\n+    public byte[] getKeyAsBytes() {\n+        return bitStringKey.toByteArray();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509Key.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +30,1 @@\n- * @bug 8281236\n+ * @bug 8281236 8314323\n@@ -139,0 +140,54 @@\n+\n+        runTest(new String[] {\n+                        \"X25519MLKEM768\"\n+                },\n+                new String[] {\n+                        \"X25519MLKEM768\"\n+                },\n+                false);\n+\n+        runTest(new String[] {\n+                        \"SecP256r1MLKEM768\"\n+                },\n+                new String[] {\n+                        \"SecP256r1MLKEM768\"\n+                },\n+                false);\n+\n+        runTest(new String[] {\n+                        \"SecP384r1MLKEM1024\"\n+                },\n+                new String[] {\n+                        \"SecP384r1MLKEM1024\"\n+                },\n+                false);\n+\n+        runTest(new String[] {\n+                        \"X25519MLKEM768\"\n+                },\n+                new String[] {\n+                        \"SecP256r1MLKEM768\"\n+                },\n+                true);\n+\n+        runTest(new String[] {\n+                        \"X25519MLKEM768\"\n+                },\n+                new String[0],\n+                true);\n+\n+        runTest(new String[] {\n+                        \"SecP256r1MLKEM768\"\n+                },\n+                null,\n+                true);\n+\n+        runTest(new String[] {\n+                        \"X25519MLKEM768\",\n+                        \"x25519\"\n+                },\n+                new String[] {\n+                        \"X25519MLKEM768\",\n+                        \"x25519\"\n+                },\n+                false);\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/NamedGroups.java","additions":56,"deletions":1,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,5 @@\n-    FFDHE8192(\"ffdhe8192\");\n+    FFDHE8192(\"ffdhe8192\"),\n+\n+    X25519MLKEM768(\"X25519MLKEM768\"),\n+    SECP256R1MLKEM768(\"SecP256r1MLKEM768\"),\n+    SECP384R1MLKEM1024(\"SecP384r1MLKEM1024\");\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/NamedGroup.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8247630\n+ * @bug 8247630 8314323\n@@ -32,1 +32,1 @@\n- * @run main\/othervm ClientHelloKeyShares 29 23\n+ * @run main\/othervm ClientHelloKeyShares 4588 29\n@@ -39,1 +39,6 @@\n- *\/\n+ * @run main\/othervm -Djdk.tls.namedGroups=X25519MLKEM768 ClientHelloKeyShares 4588\n+ * @run main\/othervm -Djdk.tls.namedGroups=x25519,X25519MLKEM768 ClientHelloKeyShares 29 4588\n+ * @run main\/othervm -Djdk.tls.namedGroups=SecP256r1MLKEM768,x25519 ClientHelloKeyShares 4587 29\n+ * @run main\/othervm -Djdk.tls.namedGroups=SecP384r1MLKEM1024,secp256r1 ClientHelloKeyShares 4589 23\n+ * @run main\/othervm -Djdk.tls.namedGroups=X25519MLKEM768,SecP256r1MLKEM768,X25519,secp256r1 ClientHelloKeyShares 4588 29\n+*\/\n@@ -55,4 +60,0 @@\n-    private static final int NG_SECP256R1 = 0x0017;\n-    private static final int NG_SECP384R1 = 0x0018;\n-    private static final int NG_X25519 = 0x001D;\n-    private static final int NG_X448 = 0x001E;\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv13\/ClientHelloKeyShares.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8247630\n+ * @bug 8247630 8314323\n@@ -33,1 +33,3 @@\n- * @run main\/othervm -Djdk.tls.namedGroups=x25519,secp256r1,secp384r1 HRRKeyShares\n+ * @run main\/othervm\n+ *     -Djdk.tls.namedGroups=x25519,secp256r1,secp384r1,X25519MLKEM768,SecP256r1MLKEM768,SecP384r1MLKEM1024\n+ *     HRRKeyShares\n@@ -66,0 +68,4 @@\n+    private static final int NG_X25519_MLKEM768 = 0x11EC;\n+    private static final int NG_SECP256R1_MLKEM768 = 0x11EB;\n+    private static final int NG_SECP384R1_MLKEM1024 = 0x11ED;\n+\n@@ -227,0 +233,12 @@\n+\n+        System.out.println(\"Test 5: Good HRR exchange using X25519MLKEM768\");\n+        hrrKeyShareTest(NG_X25519_MLKEM768, true);\n+        System.out.println();\n+\n+        System.out.println(\"Test 6: Good HRR exchange using SecP256r1MLKEM768\");\n+        hrrKeyShareTest(NG_SECP256R1_MLKEM768, true);\n+        System.out.println();\n+\n+        System.out.println(\"Test 7: Good HRR exchange using SecP384r1MLKEM1024\");\n+        hrrKeyShareTest(NG_SECP384R1_MLKEM1024, true);\n+        System.out.println();\n@@ -337,1 +355,2 @@\n-            \/\/ with a secp384r1 share.\n+            \/\/ with a key share for the HRR requested named\n+            \/\/ group (hrrNamedGroup).\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv13\/HRRKeyShares.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run main\/othervm\/timeout=120 -Djdk.tls.client.protocols=TLSv1.3 FipsModeTLS\n+ * @run main\/othervm\/timeout=120 -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.namedGroups=x25519,secp256r1,secp384r1,secp521r1,x448,ffdhe2048,ffdhe3072,ffdhe4096,ffdhe6144,ffdhe8192 FipsModeTLS\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/fips\/FipsModeTLS.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8246330\n+ * @bug 8246330 8314323\n@@ -32,0 +32,12 @@\n+ * @run main\/othervm -Djdk.tls.namedGroups=\"X25519MLKEM768\"\n+        DisabledCurve DISABLE_NONE PASS\n+ * @run main\/othervm -Djdk.tls.namedGroups=\"X25519MLKEM768\"\n+        DisabledCurve X25519MLKEM768 FAIL\n+ * @run main\/othervm -Djdk.tls.namedGroups=\"SecP256r1MLKEM768\"\n+        DisabledCurve DISABLE_NONE PASS\n+ * @run main\/othervm -Djdk.tls.namedGroups=\"SecP256r1MLKEM768\"\n+        DisabledCurve SecP256r1MLKEM768 FAIL\n+ * @run main\/othervm -Djdk.tls.namedGroups=\"SecP384r1MLKEM1024\"\n+        DisabledCurve DISABLE_NONE PASS\n+ * @run main\/othervm -Djdk.tls.namedGroups=\"SecP384r1MLKEM1024\"\n+        DisabledCurve SecP384r1MLKEM1024 FAIL\n@@ -48,2 +60,4 @@\n-            { { \"TLSv1.2\" }, { \"TLSv1.2\" } }, { { \"TLSv1.1\" }, { \"TLSv1.1\" } },\n-            { { \"TLSv1\" }, { \"TLSv1\" } } };\n+            { { \"TLSv1.2\" }, { \"TLSv1.2\" } },\n+            { { \"TLSv1.1\" }, { \"TLSv1.1\" } },\n+            { { \"TLSv1\" }, { \"TLSv1\" } },\n+            { { \"TLSv1.3\" }, { \"TLSv1.3\" } } };\n@@ -97,1 +111,2 @@\n-        if (disabledName.equals(\"\")) {\n+\n+        if (disabledName.isEmpty()) {\n@@ -99,0 +114,1 @@\n+            Security.setProperty(\"jdk.certpath.disabledAlgorithms\", \"\");\n@@ -101,1 +117,6 @@\n-            Security.setProperty(\"jdk.certpath.disabledAlgorithms\", \"secp384r1\");\n+            Security.setProperty(\"jdk.certpath.disabledAlgorithms\", disabledName);\n+            if (!disabledName.contains(\"MLKEM\")) {\n+                Security.setProperty(\"jdk.disabled.namedCurves\", disabledName);\n+            } else {\n+                Security.setProperty(\"jdk.disabled.namedCurves\", \"\");\n+            }\n@@ -107,0 +128,3 @@\n+        String namedGroups = System.getProperty(\"jdk.tls.namedGroups\", \"\");\n+        boolean hybridGroup = namedGroups.contains(\"MLKEM\");\n+\n@@ -108,0 +132,9 @@\n+            if (hybridGroup) {\n+                String[] clientProtos = protocols[index][0];\n+                String[] serverProtos = protocols[index][1];\n+\n+                if (!(isTLS13(clientProtos) && isTLS13(serverProtos))) {\n+                    continue;\n+                }\n+            }\n+\n@@ -126,0 +159,4 @@\n+\n+    private static boolean isTLS13(String[] protocols) {\n+        return protocols.length == 1 && \"TLSv1.3\".equals(protocols[0]);\n+    }\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/DisabledCurve.java","additions":43,"deletions":6,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import java.util.Arrays;\n+import java.util.List;\n@@ -32,1 +34,1 @@\n-  * @bug 8224650 8242929\n+  * @bug 8224650 8242929 8314323\n@@ -47,0 +49,3 @@\n+  * @run main\/othervm NamedGroupsWithCipherSuite X25519MLKEM768\n+  * @run main\/othervm NamedGroupsWithCipherSuite SecP256r1MLKEM768\n+  * @run main\/othervm NamedGroupsWithCipherSuite SecP384r1MLKEM1024\n@@ -50,1 +55,1 @@\n-    private static final Protocol[] PROTOCOLS = new Protocol[] {\n+    private static final List<Protocol> PROTOCOLS = List.of(\n@@ -55,1 +60,1 @@\n-    };\n+    );\n@@ -57,1 +62,1 @@\n-    private static final CipherSuite[] CIPHER_SUITES = new CipherSuite[] {\n+    private static final List<CipherSuite> CIPHER_SUITES = List.of(\n@@ -78,1 +83,17 @@\n-    };\n+    );\n+\n+    private static final List<String> HYBRID_NAMEDGROUPS = List.of(\n+            \"X25519MLKEM768\",\n+            \"SecP256r1MLKEM768\",\n+            \"SecP384r1MLKEM1024\"\n+    );\n+\n+    private static final List<Protocol> HYBRID_PROTOCOL = List.of(\n+            Protocol.TLSV1_3\n+    );\n+\n+    private static final List<CipherSuite> HYBRID_CIPHER_SUITES = List.of(\n+            CipherSuite.TLS_AES_128_GCM_SHA256,\n+            CipherSuite.TLS_AES_256_GCM_SHA384,\n+            CipherSuite.TLS_CHACHA20_POLY1305_SHA256\n+    );\n@@ -154,4 +175,13 @@\n-        for (Protocol protocol : PROTOCOLS) {\n-            for (CipherSuite cipherSuite : CIPHER_SUITES) {\n-                \/\/ Named group converted to lower case just\n-                \/\/ to satisfy Test condition\n+        boolean hybridGroup = HYBRID_NAMEDGROUPS.contains(namedGroup);\n+        List<Protocol> protocolList = hybridGroup ?\n+                HYBRID_PROTOCOL : PROTOCOLS;\n+        List<CipherSuite> cipherList = hybridGroup ?\n+                HYBRID_CIPHER_SUITES : CIPHER_SUITES;\n+\n+        \/\/ non-Hybrid named group converted to lower case just\n+        \/\/ to satisfy Test condition\n+        String normalizedGroup = hybridGroup ?\n+                namedGroup : namedGroup.toLowerCase();\n+\n+        for (Protocol protocol : protocolList) {\n+            for (CipherSuite cipherSuite : cipherList) {\n@@ -159,2 +189,2 @@\n-                        && groupSupportdByCipher(namedGroup.toLowerCase(),\n-                                cipherSuite)) {\n+                        && groupSupportedByCipher(normalizedGroup,\n+                        cipherSuite)) {\n@@ -163,2 +193,0 @@\n-                    \/\/ Named group converted to lower case just\n-                    \/\/ to satisfy Test condition\n@@ -166,1 +194,1 @@\n-                            cipherSuite, namedGroup.toLowerCase()).run();\n+                            cipherSuite, normalizedGroup).run();\n@@ -172,1 +200,1 @@\n-    private static boolean groupSupportdByCipher(String group,\n+    private static boolean groupSupportedByCipher(String group,\n@@ -174,0 +202,4 @@\n+        if (HYBRID_NAMEDGROUPS.contains(group)) {\n+            return cipherSuite.keyExAlgorithm == null;\n+        }\n+\n@@ -175,1 +207,1 @@\n-                        && xdhGroupSupportdByCipher(cipherSuite))\n+                        && xdhGroupSupportedByCipher(cipherSuite))\n@@ -177,1 +209,1 @@\n-                        && ecdhGroupSupportdByCipher(cipherSuite))\n+                        && ecdhGroupSupportedByCipher(cipherSuite))\n@@ -179,1 +211,1 @@\n-                        && ffdhGroupSupportdByCipher(cipherSuite));\n+                        && ffdhGroupSupportedByCipher(cipherSuite));\n@@ -182,1 +214,1 @@\n-    private static boolean xdhGroupSupportdByCipher(\n+    private static boolean xdhGroupSupportedByCipher(\n@@ -188,1 +220,1 @@\n-    private static boolean ecdhGroupSupportdByCipher(\n+    private static boolean ecdhGroupSupportedByCipher(\n@@ -195,1 +227,1 @@\n-    private static boolean ffdhGroupSupportdByCipher(\n+    private static boolean ffdhGroupSupportedByCipher(\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/NamedGroupsWithCipherSuite.java","additions":54,"deletions":22,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8226374 8242929\n+ * @bug 8226374 8242929 8314323\n@@ -39,0 +39,3 @@\n+ * @run main\/othervm RestrictNamedGroup X25519MLKEM768\n+ * @run main\/othervm RestrictNamedGroup SecP256r1MLKEM768\n+ * @run main\/othervm RestrictNamedGroup SecP384r1MLKEM1024\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/RestrictNamedGroup.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-  * @bug 8171279\n+  * @bug 8171279 8314323\n@@ -39,0 +39,3 @@\n+  * @run main\/othervm SupportedGroups X25519MLKEM768\n+  * @run main\/othervm SupportedGroups SecP256r1MLKEM768\n+  * @run main\/othervm SupportedGroups SecP384r1MLKEM1024\n@@ -48,1 +51,1 @@\n-    private static final String[][][] protocols = {\n+    private static final String[][][] protocolsForClassic = {\n@@ -55,1 +58,9 @@\n-    public SupportedGroups() {\n+    private static final String[][][] protocolsForHybrid = {\n+            {{\"TLSv1.3\"}, {\"TLSv1.3\"}},\n+            {{\"TLSv1.3\", \"TLSv1.2\"}, {\"TLSv1.3\"}},\n+            {{\"TLSv1.3\"}, {\"TLSv1.3\", \"TLSv1.2\"}}\n+    };\n+\n+    private final String[][][] protocols;\n+\n+    public SupportedGroups(String[][][] protocols) {\n@@ -57,0 +68,1 @@\n+        this.protocols = protocols;\n@@ -88,0 +100,4 @@\n+        boolean hybridGroup = hybridNamedGroup(args[0]);\n+        String[][][] protocols = hybridGroup ?\n+                protocolsForHybrid : protocolsForClassic;\n+\n@@ -89,1 +105,1 @@\n-            (new SupportedGroups()).run();\n+            (new SupportedGroups(protocols)).run();\n@@ -92,0 +108,6 @@\n+\n+    private static boolean hybridNamedGroup(String namedGroup) {\n+        return namedGroup.equals(\"X25519MLKEM768\") ||\n+                namedGroup.equals(\"SecP256r1MLKEM768\") ||\n+                namedGroup.equals(\"SecP384r1MLKEM1024\");\n+    }\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/SupportedGroups.java","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import javax.net.ssl.SSLParameters;\n@@ -78,2 +79,9 @@\n-    @Param({\"TLSv1.2\", \"TLS\"})\n-    String tlsVersion;\n+    @Param({\n+            \"TLSv1.2-secp256r1\",\n+            \"TLSv1.3-x25519\", \"TLSv1.3-secp256r1\", \"TLSv1.3-secp384r1\",\n+            \"TLSv1.3-X25519MLKEM768\", \"TLSv1.3-SecP256r1MLKEM768\", \"TLSv1.3-SecP384r1MLKEM1024\"\n+    })\n+    String versionAndGroup;\n+\n+    private String tlsVersion;\n+    private String namedGroup;\n@@ -99,0 +107,4 @@\n+        String[] components = versionAndGroup.split(\"-\", 2);\n+        tlsVersion = components[0];\n+        namedGroup = components[1];\n+\n@@ -198,0 +210,9 @@\n+\n+        \/\/ Set the key exchange named group in client and server engines\n+        SSLParameters clientParams = clientEngine.getSSLParameters();\n+        clientParams.setNamedGroups(new String[]{namedGroup});\n+        clientEngine.setSSLParameters(clientParams);\n+\n+        SSLParameters serverParams = serverEngine.getSSLParameters();\n+        serverParams.setNamedGroups(new String[]{namedGroup});\n+        serverEngine.setSSLParameters(serverParams);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SSLHandshake.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import org.openjdk.jmh.annotations.Fork;\n@@ -32,0 +33,2 @@\n+import java.security.GeneralSecurityException;\n+import java.security.InvalidAlgorithmParameterException;\n@@ -37,0 +40,3 @@\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.ECGenParameterSpec;\n@@ -38,1 +44,1 @@\n-public class KEMBench extends CryptoBase {\n+public abstract class KEMBench extends CryptoBase {\n@@ -42,1 +48,1 @@\n-    @Param({\"ML-KEM-512\", \"ML-KEM-768\", \"ML-KEM-1024\" })\n+    @Param({})\n@@ -45,0 +51,3 @@\n+    @Param({\"\"})        \/\/ Used when the KeyPairGenerator Alg != KEM Alg\n+    private String kpgSpec;\n+\n@@ -51,3 +60,29 @@\n-    public void setup() throws NoSuchAlgorithmException, InvalidKeyException {\n-        kem = (prov == null) ? KEM.getInstance(algorithm) : KEM.getInstance(algorithm, prov);\n-        KeyPairGenerator generator = (prov == null) ? KeyPairGenerator.getInstance(algorithm) : KeyPairGenerator.getInstance(algorithm, prov);\n+    public void setup() throws NoSuchAlgorithmException, InvalidKeyException,\n+            InvalidAlgorithmParameterException {\n+        String kpgAlg;\n+        String kpgParams;\n+        kem = (prov == null) ? KEM.getInstance(algorithm) :\n+                KEM.getInstance(algorithm, prov);\n+\n+        \/\/ By default use the same provider for KEM and KPG\n+        Provider kpgProv = prov;\n+        if (kpgSpec.isEmpty()) {\n+            kpgAlg = algorithm;\n+            kpgParams = \"\";\n+        } else {\n+            \/\/ The key pair generation spec is broken down from a colon-\n+            \/\/ delimited string spec into 3 fields:\n+            \/\/ [0] - the provider name\n+            \/\/ [1] - the algorithm name\n+            \/\/ [2] - the parameters (i.e. the name of the curve)\n+            String[] kpgTok = kpgSpec.split(\":\");\n+            kpgProv = Security.getProvider(kpgTok[0]);\n+            kpgAlg = kpgTok[1];\n+            kpgParams = kpgTok[2];\n+        }\n+        KeyPairGenerator generator = (kpgProv == null) ?\n+                    KeyPairGenerator.getInstance(kpgAlg) :\n+                    KeyPairGenerator.getInstance(kpgAlg, kpgProv);\n+        if (kpgParams != null && !kpgParams.isEmpty()) {\n+            generator.initialize(new ECGenParameterSpec(kpgParams));\n+        }\n@@ -66,0 +101,9 @@\n+    private static Provider getInternalJce() {\n+        try {\n+            Class<?> dhClazz = Class.forName(\"sun.security.ssl.HybridProvider\");\n+            return (Provider) dhClazz.getField(\"PROVIDER\").get(null);\n+        } catch (ReflectiveOperationException exc) {\n+            throw new RuntimeException(exc);\n+        }\n+    }\n+\n@@ -70,1 +114,2 @@\n-            bh.consume(kem.newEncapsulator(kp.getPublic()).encapsulate().encapsulation());\n+            bh.consume(kem.newEncapsulator(kp.getPublic()).encapsulate().\n+                    encapsulation());\n@@ -76,1 +121,2 @@\n-    public void decapsulate(Blackhole bh) throws InvalidKeyException, DecapsulateException {\n+    public void decapsulate(Blackhole bh) throws InvalidKeyException,\n+            DecapsulateException {\n@@ -78,1 +124,2 @@\n-            bh.consume(kem.newDecapsulator(keys[i].getPrivate()).decapsulate(messages[i]));\n+            bh.consume(kem.newDecapsulator(keys[i].getPrivate()).\n+                    decapsulate(messages[i]));\n@@ -82,0 +129,47 @@\n+    public static class MLKEM extends KEMBench {\n+        @Param({\"ML-KEM-512\", \"ML-KEM-768\", \"ML-KEM-1024\" })\n+        private String algorithm;\n+\n+        @Param({\"\"})            \/\/ ML-KEM uses the same alg for KPG and KEM\n+        private String kpgSpec;\n+    }\n+\n+    @Fork(value = 5, jvmArgs = {\"-XX:+AlwaysPreTouch\", \"--add-opens\",\n+            \"java.base\/sun.security.ssl=ALL-UNNAMED\"})\n+    public static class JSSE_DHasKEM extends KEMBench {\n+        @Setup\n+        public void init() {\n+            try {\n+                prov = getInternalJce();\n+                super.setup();\n+            } catch (GeneralSecurityException gse) {\n+                throw new RuntimeException(gse);\n+            }\n+        }\n+\n+        @Param({\"DH\"})\n+        private String algorithm;\n+\n+        @Param({\"SunEC:XDH:x25519\", \"SunEC:EC:secp256r1\", \"SunEC:EC:secp384r1\"})\n+        private String kpgSpec;\n+    }\n+\n+    @Fork(value = 5, jvmArgs = {\"-XX:+AlwaysPreTouch\", \"--add-opens\",\n+            \"java.base\/sun.security.ssl=ALL-UNNAMED\"})\n+    public static class JSSE_Hybrid extends KEMBench {\n+        @Setup\n+        public void init() {\n+            try {\n+                prov = getInternalJce();\n+                super.setup();\n+            } catch (GeneralSecurityException gse) {\n+                throw new RuntimeException(gse);\n+            }\n+        }\n+\n+        @Param({\"X25519MLKEM768\", \"SecP256r1MLKEM768\", \"SecP384r1MLKEM1024\"})\n+        private String algorithm;\n+\n+        @Param({\"\"})            \/\/ ML-KEM uses the same alg for KPG and KEM\n+        private String kpgSpec;\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/KEMBench.java","additions":102,"deletions":8,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import org.openjdk.jmh.annotations.Fork;\n@@ -29,0 +30,1 @@\n+import java.security.GeneralSecurityException;\n@@ -32,0 +34,1 @@\n+import java.security.Provider;\n@@ -48,1 +51,2 @@\n-        if (keyLength > 0) { \/\/ not all key pair generators allow the use of key length\n+        \/\/ not all key pair generators allow the use of key length\n+        if (keyLength > 0) {\n@@ -53,0 +57,9 @@\n+    private static Provider getInternalJce() {\n+        try {\n+            Class<?> dhClazz = Class.forName(\"sun.security.ssl.HybridProvider\");\n+            return (Provider) dhClazz.getField(\"PROVIDER\").get(null);\n+        } catch (ReflectiveOperationException exc) {\n+            throw new RuntimeException(exc);\n+        }\n+    }\n+\n@@ -121,0 +134,19 @@\n+    @Fork(value = 5, jvmArgs = {\"-XX:+AlwaysPreTouch\", \"--add-opens\",\n+            \"java.base\/sun.security.ssl=ALL-UNNAMED\"})\n+    public static class JSSE_Hybrid extends KeyPairGeneratorBench {\n+        @Setup\n+        public void init() {\n+            try {\n+                prov = getInternalJce();\n+                super.setup();\n+            } catch (GeneralSecurityException gse) {\n+                throw new RuntimeException(gse);\n+            }\n+        }\n+\n+        @Param({\"X25519MLKEM768\", \"SecP256r1MLKEM768\", \"SecP384r1MLKEM1024\"})\n+        private String algorithm;\n+\n+        @Param({\"0\"})       \/\/ Hybrid KPGs don't need key lengths\n+        private int keyLength;\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/KeyPairGeneratorBench.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"}]}