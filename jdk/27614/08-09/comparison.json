{"files":[{"patch":"@@ -1,340 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.crypto.provider;\n-\n-import sun.security.util.ArrayUtil;\n-import sun.security.util.CurveDB;\n-import sun.security.util.ECUtil;\n-import sun.security.util.Hybrid;\n-import sun.security.util.NamedCurve;\n-\n-import javax.crypto.DecapsulateException;\n-import javax.crypto.KEM;\n-import javax.crypto.KEMSpi;\n-import javax.crypto.KeyAgreement;\n-import javax.crypto.SecretKey;\n-import javax.crypto.spec.SecretKeySpec;\n-import java.io.IOException;\n-import java.math.BigInteger;\n-import java.security.*;\n-import java.security.interfaces.ECKey;\n-import java.security.interfaces.ECPublicKey;\n-import java.security.interfaces.XECKey;\n-import java.security.interfaces.XECPublicKey;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.security.spec.ECPoint;\n-import java.security.spec.ECPublicKeySpec;\n-import java.security.spec.InvalidKeySpecException;\n-import java.security.spec.KeySpec;\n-import java.security.spec.NamedParameterSpec;\n-import java.security.spec.XECPublicKeySpec;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-\n-import static sun.security.util.SecurityConstants.PROVIDER_VER;\n-\n-\/**\n- * The DH provider is a KEM abstraction layer over traditional DH based\n- * key exchange. It models DH\/ECDH\/XDH as KEMs, like post-quantum algorithms,\n- * so DH\/ECDH\/XDH can be used in hybrid key exchange, alongside post-quantum\n- * KEMs.\n- *\/\n-public class DH implements KEMSpi {\n-\n-    \/\/ DH in its own private provider so we always getInstance from here.\n-    public static final Provider PROVIDER = new ProviderImpl();\n-\n-    private static class ProviderImpl extends Provider {\n-        @java.io.Serial\n-        private static final long serialVersionUID = 0L;\n-        private ProviderImpl() {\n-            super(\"InternalJCE\", PROVIDER_VER, \"\");\n-            put(\"KEM.DH\", DH.class.getName());\n-\n-            \/\/ Hybrid KeyPairGenerator\/KeyFactory\/KEM\n-\n-            \/\/ The order of shares in the concatenation for group name\n-            \/\/ X25519MLKEM768 has been reversed. This is due to historical\n-            \/\/ reasons.\n-            var attrs = Map.of(\"name\", \"X25519MLKEM768\", \"left\", \"ML-KEM-768\",\n-                    \"right\", \"X25519\");\n-            putService(new HybridService(this, \"KeyPairGenerator\",\n-                    \"X25519MLKEM768\", \"sun.security.util.Hybrid$KeyPairGeneratorImpl\",\n-                    null, attrs));\n-            putService(new HybridService(this, \"KEM\",\n-                    \"X25519MLKEM768\", \"sun.security.util.Hybrid$KEMImpl\",\n-                    null, attrs));\n-            putService(new HybridService(this, \"KeyFactory\",\n-                    \"X25519MLKEM768\", \"sun.security.util.Hybrid$KeyFactoryImpl\",\n-                    null, attrs));\n-\n-            attrs = Map.of(\"name\", \"SecP256r1MLKEM768\", \"left\", \"secp256r1\",\n-                    \"right\", \"ML-KEM-768\");\n-            putService(new HybridService(this, \"KeyPairGenerator\",\n-                    \"SecP256r1MLKEM768\", \"sun.security.util.Hybrid$KeyPairGeneratorImpl\",\n-                    null, attrs));\n-            putService(new HybridService(this, \"KEM\",\n-                    \"SecP256r1MLKEM768\", \"sun.security.util.Hybrid$KEMImpl\",\n-                    null, attrs));\n-            putService(new HybridService(this, \"KeyFactory\",\n-                    \"SecP256r1MLKEM768\", \"sun.security.util.Hybrid$KeyFactoryImpl\",\n-                    null, attrs));\n-\n-            attrs = Map.of(\"name\", \"SecP384r1MLKEM1024\", \"left\", \"secp384r1\",\n-                    \"right\", \"ML-KEM-1024\");\n-            putService(new HybridService(this, \"KeyPairGenerator\",\n-                    \"SecP384r1MLKEM1024\", \"sun.security.util.Hybrid$KeyPairGeneratorImpl\",\n-                    null, attrs));\n-            putService(new HybridService(this, \"KEM\",\n-                    \"SecP384r1MLKEM1024\", \"sun.security.util.Hybrid$KEMImpl\",\n-                    null, attrs));\n-            putService(new HybridService(this, \"KeyFactory\",\n-                    \"SecP384r1MLKEM1024\", \"sun.security.util.Hybrid$KeyFactoryImpl\",\n-                    null, attrs));\n-        }\n-    }\n-\n-    @Override\n-    public EncapsulatorSpi engineNewEncapsulator(\n-            PublicKey publicKey, AlgorithmParameterSpec spec,\n-            SecureRandom secureRandom) throws InvalidKeyException {\n-        return new Handler(publicKey, null, secureRandom);\n-    }\n-\n-    @Override\n-    public DecapsulatorSpi engineNewDecapsulator(PrivateKey privateKey,\n-            AlgorithmParameterSpec spec) throws InvalidKeyException {\n-        return new Handler(null, privateKey, null);\n-    }\n-\n-    static final class Handler\n-            implements KEMSpi.EncapsulatorSpi, KEMSpi.DecapsulatorSpi {\n-        private final PublicKey pkR;\n-        private final PrivateKey skR;\n-        private final SecureRandom sr;\n-        private final Params params;\n-\n-        Handler(PublicKey pk, PrivateKey sk, SecureRandom sr)\n-                throws InvalidKeyException {\n-            this.pkR = pk;\n-            this.skR = sk;\n-            this.sr = sr;\n-            this.params = paramsFromKey(pk == null ? sk : pk);\n-        }\n-\n-        @Override\n-        public KEM.Encapsulated engineEncapsulate(int from, int to,\n-                String algorithm) {\n-            KeyPair kpE = params.generateKeyPair(sr);\n-            PrivateKey skE = kpE.getPrivate();\n-            PublicKey pkE = kpE.getPublic();\n-            byte[] pkEm = params.SerializePublicKey(pkE);\n-            try {\n-                SecretKey dh = params.DH(algorithm, skE, pkR);\n-                return new KEM.Encapsulated(\n-                        sub(dh, from, to),\n-                        pkEm, null);\n-            } catch (Exception e) {\n-                throw new ProviderException(\"internal error\", e);\n-            }\n-        }\n-\n-        @Override\n-        public int engineSecretSize() {\n-            return params.Nsecret;\n-        }\n-\n-        @Override\n-        public int engineEncapsulationSize() {\n-            return params.Npk;\n-        }\n-\n-        @Override\n-        public SecretKey engineDecapsulate(byte[] encapsulation, int from,\n-                int to, String algorithm) throws DecapsulateException {\n-            if (encapsulation.length != params.Npk) {\n-                throw new DecapsulateException(\"incorrect encapsulation size\");\n-            }\n-            try {\n-                PublicKey pkE = params.DeserializePublicKey(encapsulation);\n-                SecretKey dh = params.DH(algorithm, skR, pkE);\n-                return sub(dh, from, to);\n-            } catch (IOException | InvalidKeyException e) {\n-                throw new DecapsulateException(\"Cannot decapsulate\", e);\n-            } catch (Exception e) {\n-                throw new ProviderException(\"internal error\", e);\n-            }\n-        }\n-\n-        private SecretKey sub(SecretKey key, int from, int to) {\n-            if (from == 0 && to == params.Nsecret) {\n-                return key;\n-            } else if (\"RAW\".equalsIgnoreCase(key.getFormat())) {\n-                byte[] km = key.getEncoded();\n-                if (km == null) {\n-                    \/\/ Should not happen if format is \"RAW\"\n-                    throw new UnsupportedOperationException(\"Key extract failed\");\n-                } else {\n-                    return new SecretKeySpec(km, from, to - from,\n-                            key.getAlgorithm());\n-                }\n-            } else {\n-                throw new UnsupportedOperationException(\"Cannot extract key\");\n-            }\n-        }\n-\n-        \/\/ This KEM is designed to be able to represent every ECDH and XDH\n-        private Params paramsFromKey(Key k) throws InvalidKeyException {\n-            if (k instanceof ECKey eckey) {\n-                if (ECUtil.equals(eckey.getParams(), CurveDB.P_256)) {\n-                    return Params.P256;\n-                } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_384)) {\n-                    return Params.P384;\n-                } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_521)) {\n-                    return Params.P521;\n-                }\n-            } else if (k instanceof XECKey xkey\n-                    && xkey.getParams() instanceof NamedParameterSpec ns) {\n-                if (ns.getName().equalsIgnoreCase(\n-                        NamedParameterSpec.X25519.getName())) {\n-                    return Params.X25519;\n-                } else if (ns.getName().equalsIgnoreCase(\n-                        NamedParameterSpec.X448.getName())) {\n-                    return Params.X448;\n-                }\n-            }\n-            throw new InvalidKeyException(\"Unsupported key\");\n-        }\n-    }\n-\n-    private enum Params {\n-\n-        P256(32, 2 * 32 + 1,\n-                \"ECDH\", \"EC\", CurveDB.P_256),\n-\n-        P384(48, 2 * 48 + 1,\n-                \"ECDH\", \"EC\", CurveDB.P_384),\n-\n-        P521(66, 2 * 66 + 1,\n-                \"ECDH\", \"EC\", CurveDB.P_521),\n-\n-        X25519(32, 32,\n-                \"XDH\", \"XDH\", NamedParameterSpec.X25519),\n-\n-        X448(56, 56,\n-                \"XDH\", \"XDH\", NamedParameterSpec.X448),\n-        ;\n-        private final int Nsecret;\n-        private final int Npk;\n-        private final String kaAlgorithm;\n-        private final String keyAlgorithm;\n-        private final AlgorithmParameterSpec spec;\n-\n-\n-        Params(int Nsecret, int Npk, String kaAlgorithm, String keyAlgorithm,\n-                AlgorithmParameterSpec spec) {\n-            this.spec = spec;\n-            this.Nsecret = Nsecret;\n-            this.Npk = Npk;\n-            this.kaAlgorithm = kaAlgorithm;\n-            this.keyAlgorithm = keyAlgorithm;\n-        }\n-\n-        private boolean isEC() {\n-            return this == P256 || this == P384 || this == P521;\n-        }\n-\n-        private KeyPair generateKeyPair(SecureRandom sr) {\n-            try {\n-                KeyPairGenerator g = KeyPairGenerator.getInstance(keyAlgorithm);\n-                g.initialize(spec, sr);\n-                return g.generateKeyPair();\n-            } catch (Exception e) {\n-                throw new ProviderException(\"internal error\", e);\n-            }\n-        }\n-\n-        private byte[] SerializePublicKey(PublicKey k) {\n-            if (isEC()) {\n-                ECPoint w = ((ECPublicKey) k).getW();\n-                return ECUtil.encodePoint(w, ((NamedCurve) spec).getCurve());\n-            } else {\n-                byte[] uArray = ((XECPublicKey) k).getU().toByteArray();\n-                ArrayUtil.reverse(uArray);\n-                return Arrays.copyOf(uArray, Npk);\n-            }\n-        }\n-\n-        private PublicKey DeserializePublicKey(byte[] data) throws\n-                IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-            KeySpec keySpec;\n-            if (isEC()) {\n-                NamedCurve curve = (NamedCurve) this.spec;\n-                keySpec = new ECPublicKeySpec(\n-                        ECUtil.decodePoint(data, curve.getCurve()), curve);\n-            } else {\n-                data = data.clone();\n-                ArrayUtil.reverse(data);\n-                keySpec = new XECPublicKeySpec(\n-                        this.spec, new BigInteger(1, data));\n-            }\n-            return KeyFactory.getInstance(keyAlgorithm).generatePublic(keySpec);\n-        }\n-\n-        private SecretKey DH(String alg, PrivateKey skE, PublicKey pkR)\n-                throws NoSuchAlgorithmException, InvalidKeyException {\n-            KeyAgreement ka = KeyAgreement.getInstance(kaAlgorithm);\n-            ka.init(skE);\n-            ka.doPhase(pkR, true);\n-            return ka.generateSecret(alg);\n-        }\n-    }\n-\n-    private static class HybridService extends Provider.Service {\n-\n-        HybridService(Provider p, String type, String algo, String cn,\n-                List<String> aliases, Map<String, String> attrs) {\n-            super(p, type, algo, cn, aliases, attrs);\n-        }\n-\n-        @Override\n-        public Object newInstance(Object ctrParamObj)\n-                throws NoSuchAlgorithmException {\n-            String type = getType();\n-            return switch (type) {\n-                case \"KeyPairGenerator\" -> new Hybrid.KeyPairGeneratorImpl(\n-                        getAttribute(\"left\"), getAttribute(\"right\"));\n-                case \"KeyFactory\" -> new Hybrid.KeyFactoryImpl(\n-                        getAttribute(\"left\"), getAttribute(\"right\"));\n-                case \"KEM\" -> new Hybrid.KEMImpl(\n-                        getAttribute(\"left\"), getAttribute(\"right\"));\n-                default -> throw new NoSuchAlgorithmException(\n-                        \"Unexpected value: \" + type);\n-            };\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DH.java","additions":0,"deletions":340,"binary":false,"changes":340,"status":"deleted"},{"patch":"@@ -0,0 +1,361 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import sun.security.ssl.Hybrid;\n+import sun.security.util.ArrayUtil;\n+import sun.security.util.CurveDB;\n+import sun.security.util.ECUtil;\n+import sun.security.util.NamedCurve;\n+\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.KeyAgreement;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.*;\n+import java.security.interfaces.ECKey;\n+import java.security.interfaces.ECPublicKey;\n+import java.security.interfaces.XECKey;\n+import java.security.interfaces.XECPublicKey;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.ECPoint;\n+import java.security.spec.ECPublicKeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.security.spec.XECPublicKeySpec;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static sun.security.util.SecurityConstants.PROVIDER_VER;\n+\n+\/**\n+ * The DHasKEM class presents a KEM abstraction layer over traditional\n+ * DH-based key exchange, which can be used for either straight\n+ * ECDH\/XDH or TLS hybrid key exchanges.\n+ *\n+ * This class can be alongside standard full post-quantum KEMs\n+ * when hybrid implementations are required.\n+ *\/\n+public class DHasKEM implements KEMSpi {\n+\n+    \/\/ DHasKEM in its own private provider so we always getInstance from here.\n+    public static final Provider PROVIDER = new ProviderImpl();\n+\n+    \/\/ This is an internal provider used in the JSSE code for DH-as-KEM\n+    \/\/ and Hybrid KEM support. It doesn't actually get installed in the\n+    \/\/ system's list of security providers that is searched at runtime.\n+    \/\/ JSSE loads this provider internally.\n+    \/\/ It registers Hybrid KeyPairGenerator, KeyFactory, and KEM\n+    \/\/ implementations for hybrid named groups as Provider services.\n+    private static class ProviderImpl extends Provider {\n+        @java.io.Serial\n+        private static final long serialVersionUID = 0L;\n+        private ProviderImpl() {\n+            super(\"InternalJCEDHasKEM\", PROVIDER_VER,\n+                    \"Internal DHasKEM provider\");\n+            put(\"KEM.DH\", DHasKEM.class.getName());\n+\n+            \/\/ Hybrid KeyPairGenerator\/KeyFactory\/KEM\n+\n+            \/\/ The order of shares in the concatenation for group name\n+            \/\/ X25519MLKEM768 has been reversed. This is due to IETF\n+            \/\/ historical reasons.\n+            var attrs = Map.of(\"name\", \"X25519MLKEM768\", \"left\", \"ML-KEM-768\",\n+                    \"right\", \"X25519\");\n+            putService(new HybridService(this, \"KeyPairGenerator\",\n+                    \"X25519MLKEM768\",\n+                    \"sun.security.ssl.Hybrid$KeyPairGeneratorImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KEM\",\n+                    \"X25519MLKEM768\",\n+                    \"sun.security.ssl.Hybrid$KEMImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KeyFactory\",\n+                    \"X25519MLKEM768\",\n+                    \"sun.security.ssl.Hybrid$KeyFactoryImpl\",\n+                    null, attrs));\n+\n+            attrs = Map.of(\"name\", \"SecP256r1MLKEM768\", \"left\", \"secp256r1\",\n+                    \"right\", \"ML-KEM-768\");\n+            putService(new HybridService(this, \"KeyPairGenerator\",\n+                    \"SecP256r1MLKEM768\",\n+                    \"sun.security.ssl.Hybrid$KeyPairGeneratorImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KEM\",\n+                    \"SecP256r1MLKEM768\",\n+                    \"sun.security.ssl.Hybrid$KEMImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KeyFactory\",\n+                    \"SecP256r1MLKEM768\",\n+                    \"sun.security.ssl.Hybrid$KeyFactoryImpl\",\n+                    null, attrs));\n+\n+            attrs = Map.of(\"name\", \"SecP384r1MLKEM1024\", \"left\", \"secp384r1\",\n+                    \"right\", \"ML-KEM-1024\");\n+            putService(new HybridService(this, \"KeyPairGenerator\",\n+                    \"SecP384r1MLKEM1024\",\n+                    \"sun.security.ssl.Hybrid$KeyPairGeneratorImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KEM\",\n+                    \"SecP384r1MLKEM1024\",\n+                    \"sun.security.ssl.Hybrid$KEMImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KeyFactory\",\n+                    \"SecP384r1MLKEM1024\",\n+                    \"sun.security.ssl.Hybrid$KeyFactoryImpl\",\n+                    null, attrs));\n+        }\n+    }\n+\n+    @Override\n+    public EncapsulatorSpi engineNewEncapsulator(\n+            PublicKey publicKey, AlgorithmParameterSpec spec,\n+            SecureRandom secureRandom) throws InvalidKeyException {\n+        return new Handler(publicKey, null, secureRandom);\n+    }\n+\n+    @Override\n+    public DecapsulatorSpi engineNewDecapsulator(PrivateKey privateKey,\n+            AlgorithmParameterSpec spec) throws InvalidKeyException {\n+        return new Handler(null, privateKey, null);\n+    }\n+\n+    static final class Handler\n+            implements KEMSpi.EncapsulatorSpi, KEMSpi.DecapsulatorSpi {\n+        private final PublicKey pkR;\n+        private final PrivateKey skR;\n+        private final SecureRandom sr;\n+        private final Params params;\n+\n+        Handler(PublicKey pk, PrivateKey sk, SecureRandom sr)\n+                throws InvalidKeyException {\n+            this.pkR = pk;\n+            this.skR = sk;\n+            this.sr = sr;\n+            this.params = paramsFromKey(pk == null ? sk : pk);\n+        }\n+\n+        @Override\n+        public KEM.Encapsulated engineEncapsulate(int from, int to,\n+                String algorithm) {\n+            KeyPair kpE = params.generateKeyPair(sr);\n+            PrivateKey skE = kpE.getPrivate();\n+            PublicKey pkE = kpE.getPublic();\n+            byte[] pkEm = params.SerializePublicKey(pkE);\n+            try {\n+                SecretKey dh = params.DH(algorithm, skE, pkR);\n+                return new KEM.Encapsulated(\n+                        sub(dh, from, to),\n+                        pkEm, null);\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        @Override\n+        public int engineSecretSize() {\n+            return params.secretLen;\n+        }\n+\n+        @Override\n+        public int engineEncapsulationSize() {\n+            return params.publicKeyLen;\n+        }\n+\n+        @Override\n+        public SecretKey engineDecapsulate(byte[] encapsulation, int from,\n+                int to, String algorithm) throws DecapsulateException {\n+            if (encapsulation.length != params.publicKeyLen) {\n+                throw new DecapsulateException(\"incorrect encapsulation size\");\n+            }\n+            try {\n+                PublicKey pkE = params.DeserializePublicKey(encapsulation);\n+                SecretKey dh = params.DH(algorithm, skR, pkE);\n+                return sub(dh, from, to);\n+            } catch (IOException | InvalidKeyException e) {\n+                throw new DecapsulateException(\"Cannot decapsulate\", e);\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        private SecretKey sub(SecretKey key, int from, int to) {\n+            if (from == 0 && to == params.secretLen) {\n+                return key;\n+            } else if (\"RAW\".equalsIgnoreCase(key.getFormat())) {\n+                byte[] km = key.getEncoded();\n+                if (km == null) {\n+                    \/\/ Should not happen if format is \"RAW\"\n+                    throw new UnsupportedOperationException(\n+                            \"Key extract failed\");\n+                } else {\n+                    return new SecretKeySpec(km, from, to - from,\n+                            key.getAlgorithm());\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\"Cannot extract key\");\n+            }\n+        }\n+\n+        \/\/ This KEM is designed to be able to represent every ECDH and XDH\n+        private Params paramsFromKey(Key k) throws InvalidKeyException {\n+            if (k instanceof ECKey eckey) {\n+                if (ECUtil.equals(eckey.getParams(), CurveDB.P_256)) {\n+                    return Params.P256;\n+                } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_384)) {\n+                    return Params.P384;\n+                } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_521)) {\n+                    return Params.P521;\n+                }\n+            } else if (k instanceof XECKey xkey\n+                    && xkey.getParams() instanceof NamedParameterSpec ns) {\n+                if (ns.getName().equalsIgnoreCase(\n+                        NamedParameterSpec.X25519.getName())) {\n+                    return Params.X25519;\n+                } else if (ns.getName().equalsIgnoreCase(\n+                        NamedParameterSpec.X448.getName())) {\n+                    return Params.X448;\n+                }\n+            }\n+            throw new InvalidKeyException(\"Unsupported key\");\n+        }\n+    }\n+\n+    private enum Params {\n+\n+        P256(32, 2 * 32 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_256),\n+\n+        P384(48, 2 * 48 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_384),\n+\n+        P521(66, 2 * 66 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_521),\n+\n+        X25519(32, 32,\n+                \"XDH\", \"XDH\", NamedParameterSpec.X25519),\n+\n+        X448(56, 56,\n+                \"XDH\", \"XDH\", NamedParameterSpec.X448),\n+        ;\n+        private final int secretLen;\n+        private final int publicKeyLen;\n+        private final String kaAlgorithm;\n+        private final String keyAlgorithm;\n+        private final AlgorithmParameterSpec spec;\n+\n+\n+        Params(int secretLen, int publicKeyLen, String kaAlgorithm,\n+                String keyAlgorithm, AlgorithmParameterSpec spec) {\n+            this.spec = spec;\n+            this.secretLen = secretLen;\n+            this.publicKeyLen = publicKeyLen;\n+            this.kaAlgorithm = kaAlgorithm;\n+            this.keyAlgorithm = keyAlgorithm;\n+        }\n+\n+        private boolean isEC() {\n+            return this == P256 || this == P384 || this == P521;\n+        }\n+\n+        private KeyPair generateKeyPair(SecureRandom sr) {\n+            try {\n+                KeyPairGenerator g = KeyPairGenerator.getInstance(keyAlgorithm);\n+                g.initialize(spec, sr);\n+                return g.generateKeyPair();\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        private byte[] SerializePublicKey(PublicKey k) {\n+            if (isEC()) {\n+                ECPoint w = ((ECPublicKey) k).getW();\n+                return ECUtil.encodePoint(w, ((NamedCurve) spec).getCurve());\n+            } else {\n+                byte[] uArray = ((XECPublicKey) k).getU().toByteArray();\n+                ArrayUtil.reverse(uArray);\n+                return Arrays.copyOf(uArray, publicKeyLen);\n+            }\n+        }\n+\n+        private PublicKey DeserializePublicKey(byte[] data) throws\n+                IOException, NoSuchAlgorithmException,\n+                InvalidKeySpecException {\n+            KeySpec keySpec;\n+            if (isEC()) {\n+                NamedCurve curve = (NamedCurve) this.spec;\n+                keySpec = new ECPublicKeySpec(\n+                        ECUtil.decodePoint(data, curve.getCurve()), curve);\n+            } else {\n+                data = data.clone();\n+                ArrayUtil.reverse(data);\n+                keySpec = new XECPublicKeySpec(\n+                        this.spec, new BigInteger(1, data));\n+            }\n+            return KeyFactory.getInstance(keyAlgorithm).\n+                    generatePublic(keySpec);\n+        }\n+\n+        private SecretKey DH(String alg, PrivateKey skE, PublicKey pkR)\n+                throws NoSuchAlgorithmException, InvalidKeyException {\n+            KeyAgreement ka = KeyAgreement.getInstance(kaAlgorithm);\n+            ka.init(skE);\n+            ka.doPhase(pkR, true);\n+            return ka.generateSecret(alg);\n+        }\n+    }\n+\n+    private static class HybridService extends Provider.Service {\n+\n+        HybridService(Provider p, String type, String algo, String cn,\n+                List<String> aliases, Map<String, String> attrs) {\n+            super(p, type, algo, cn, aliases, attrs);\n+        }\n+\n+        @Override\n+        public Object newInstance(Object ctrParamObj)\n+                throws NoSuchAlgorithmException {\n+            String type = getType();\n+            return switch (type) {\n+                case \"KeyPairGenerator\" -> new Hybrid.KeyPairGeneratorImpl(\n+                        getAttribute(\"left\"), getAttribute(\"right\"));\n+                case \"KeyFactory\" -> new Hybrid.KeyFactoryImpl(\n+                        getAttribute(\"left\"), getAttribute(\"right\"));\n+                case \"KEM\" -> new Hybrid.KEMImpl(\n+                        getAttribute(\"left\"), getAttribute(\"right\"));\n+                default -> throw new NoSuchAlgorithmException(\n+                        \"Unexpected value: \" + type);\n+            };\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DHasKEM.java","additions":361,"deletions":0,"binary":false,"changes":361,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package sun.security.util;\n+package sun.security.ssl;\n@@ -28,1 +28,4 @@\n-import com.sun.crypto.provider.DH;\n+import sun.security.util.ArrayUtil;\n+import sun.security.util.CurveDB;\n+import sun.security.util.ECUtil;\n+import sun.security.util.RawKeySpec;\n@@ -35,1 +38,0 @@\n-import java.io.ByteArrayOutputStream;\n@@ -55,0 +57,10 @@\n+\/**\n+ * The Hybrid class wraps two underlying algorithms (left and right sides)\n+ * in a single TLS hybrid named group.\n+ * It implements:\n+ *  - Hybrid KeyPair generation\n+ *  - Hybrid KeyFactory for decoding concatenated hybrid public keys\n+ *  - Hybrid KEM implementation for performing encapsulation and\n+ *    decapsulation over two underlying algorithms (traditional\n+ *    algorithm and post-quantum KEM algorithm)\n+ *\/\n@@ -57,5 +69,2 @@\n-    public record SecretKeyImpl(SecretKey k1, SecretKey k2) implements SecretKey {\n-        @Override\n-        public String getAlgorithm() {\n-            return \"Hybrid\";\n-        }\n+    public static final NamedParameterSpec X25519_MLKEM768 =\n+            new NamedParameterSpec(\"X25519MLKEM768\");\n@@ -63,4 +72,2 @@\n-        @Override\n-        public String getFormat() {\n-            return null;\n-        }\n+    public static final NamedParameterSpec SECP256R1_MLKEM768 =\n+            new NamedParameterSpec(\"SecP256r1MLKEM768\");\n@@ -68,5 +75,2 @@\n-        @Override\n-        public byte[] getEncoded() {\n-            return null;\n-        }\n-    }\n+    public static final NamedParameterSpec SECP384R1_MLKEM1024 =\n+            new NamedParameterSpec(\"SecP384r1MLKEM1024\");\n@@ -101,1 +105,1 @@\n-     * implementation provided by DH.PROVIDER.\n+     * implementation provided by DHasKEM.PROVIDER.\n@@ -107,1 +111,1 @@\n-            return KEM.getInstance(\"DH\", DH.PROVIDER);\n+            return KEM.getInstance(\"DH\", DHasKEM.PROVIDER);\n@@ -140,9 +144,1 @@\n-            try {\n-                left.initialize(leftSpec, random);\n-                right.initialize(rightSpec, random);\n-            } catch (InvalidParameterException ipe) {\n-                throw ipe;\n-            } catch (Exception e) {\n-                throw new ProviderException(\"Failed to initialize hybrid \" +\n-                        \"keypair generator\", e);\n-            }\n+            \/\/ NO-OP (do nothing)\n@@ -156,2 +152,4 @@\n-                    new PublicKeyImpl(\"Hybrid\", kp1.getPublic(), kp2.getPublic()),\n-                    new PrivateKeyImpl(\"Hybrid\", kp1.getPrivate(), kp2.getPrivate()));\n+                    new PublicKeyImpl(\"Hybrid\", kp1.getPublic(),\n+                            kp2.getPublic()),\n+                    new PrivateKeyImpl(\"Hybrid\", kp1.getPrivate(),\n+                            kp2.getPrivate()));\n@@ -233,2 +231,2 @@\n-                    throw new InvalidKeySpecException(\"Failed to decode hybrid\" +\n-                            \" key\", e);\n+                    throw new InvalidKeySpecException(\"Failed to decode \" +\n+                            \"hybrid key\", e);\n@@ -239,0 +237,1 @@\n+                    \"KeySpec type:\" +\n@@ -259,2 +258,2 @@\n-        protected <T extends KeySpec> T engineGetKeySpec(Key key, Class<T> keySpec)\n-                throws InvalidKeySpecException {\n+        protected <T extends KeySpec> T engineGetKeySpec(Key key,\n+                Class<T> keySpec) throws InvalidKeySpecException {\n@@ -274,1 +273,2 @@\n-        public KEMImpl(String left, String right) throws NoSuchAlgorithmException {\n+        public KEMImpl(String left, String right)\n+                throws NoSuchAlgorithmException {\n@@ -285,1 +285,2 @@\n-                        right.newEncapsulator(pk.right, secureRandom), null, null);\n+                        right.newEncapsulator(pk.right, secureRandom),\n+                        null, null);\n@@ -292,2 +293,2 @@\n-                AlgorithmParameterSpec spec) throws InvalidAlgorithmParameterException,\n-                InvalidKeyException {\n+                AlgorithmParameterSpec spec)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n@@ -359,2 +360,2 @@\n-            var right = Arrays.copyOfRange(encapsulation, ld.encapsulationSize(),\n-                    encapsulation.length);\n+            var right = Arrays.copyOfRange(encapsulation,\n+                    ld.encapsulationSize(), encapsulation.length);\n@@ -373,0 +374,18 @@\n+    public record SecretKeyImpl(SecretKey k1, SecretKey k2)\n+            implements SecretKey {\n+        @Override\n+        public String getAlgorithm() {\n+            return \"Generic\";\n+        }\n+\n+        @Override\n+        public String getFormat() {\n+            return null;\n+        }\n+\n+        @Override\n+        public byte[] getEncoded() {\n+            return null;\n+        }\n+    }\n+\n@@ -430,1 +449,1 @@\n-            return new byte[0];\n+            return null;\n@@ -443,9 +462,0 @@\n-\n-    public static final NamedParameterSpec X25519_MLKEM768 =\n-            new NamedParameterSpec(\"X25519MLKEM768\");\n-\n-    public static final NamedParameterSpec SECP256R1_MLKEM768 =\n-            new NamedParameterSpec(\"SecP256r1MLKEM768\");\n-\n-    public static final NamedParameterSpec SECP384R1_MLKEM1024 =\n-            new NamedParameterSpec(\"SecP384r1MLKEM1024\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Hybrid.java","additions":60,"deletions":50,"binary":false,"changes":110,"previous_filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Hybrid.java","status":"renamed"},{"patch":"@@ -27,1 +27,0 @@\n-import sun.security.util.Hybrid;\n@@ -41,0 +40,1 @@\n+import java.security.Provider;\n@@ -54,1 +54,1 @@\n-    private final java.security.Provider provider;\n+    private final Provider provider;\n@@ -118,1 +118,2 @@\n-    private SecretKey deriveHandshakeSecret(String label, SecretKey sharedSecret)\n+    private SecretKey deriveHandshakeSecret(String label,\n+            SecretKey sharedSecret)\n@@ -161,0 +162,3 @@\n+     *\n+     * Package-private, used from KeyShareExtension.SHKeyShareProducer::\n+     * produce().\n@@ -162,1 +166,1 @@\n-    public KEM.Encapsulated encapsulate(String algorithm)\n+    KEM.Encapsulated encapsulate(String algorithm)\n@@ -167,1 +171,2 @@\n-            throw new IOException(\"No keyshare available for KEM encapsulation\");\n+            throw new IOException(\"No keyshare available for KEM \" +\n+                    \"encapsulation\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KAKeyDerivation.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,1 +28,8 @@\n-import java.security.*;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.PrivateKey;\n+import java.security.Provider;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n@@ -30,0 +37,1 @@\n+import javax.crypto.SecretKey;\n@@ -32,1 +40,0 @@\n-import sun.security.util.*;\n@@ -35,2 +42,0 @@\n-import javax.crypto.SecretKey;\n-\n@@ -50,1 +55,1 @@\n-        final byte[] keyshare;\n+        private final byte[] keyshare;\n@@ -67,1 +72,1 @@\n-        public byte[] getKeyshare() {\n+        public byte[] getKeyShare() {\n@@ -77,2 +82,1 @@\n-         * Parse the encoded Point into the KEMCredentials using the\n-         * namedGroup.\n+         * Instantiates a KEMCredentials object\n@@ -81,2 +85,1 @@\n-                byte[] encodedPoint) throws IOException,\n-                GeneralSecurityException {\n+                byte[] encodedPoint) {\n@@ -86,1 +89,1 @@\n-                        \"Credentials decoding:  Not KEM named group\");\n+                        \"Credentials decoding: Not KEM named group\");\n@@ -97,1 +100,1 @@\n-    static class KEMPossession implements SSLPossession {\n+    private static class KEMPossession implements SSLPossession {\n@@ -99,0 +102,1 @@\n+\n@@ -114,0 +118,1 @@\n+            String algName = null;\n@@ -116,1 +121,1 @@\n-                String algName = ((NamedParameterSpec)namedGroup.keAlgParamSpec).\n+                algName = ((NamedParameterSpec)namedGroup.keAlgParamSpec).\n@@ -128,1 +133,2 @@\n-                        \"Could not generate XDH keypair\", e);\n+                        \"Could not generate keypair for algorithm: \" +\n+                        algName, e);\n@@ -142,1 +148,2 @@\n-        public PublicKey getPublicKey() {\n+        \/\/ Package-private\n+        PublicKey getPublicKey() {\n@@ -146,1 +153,2 @@\n-        public PrivateKey getPrivateKey() {\n+        \/\/ Package-private\n+        PrivateKey getPrivateKey() {\n@@ -153,8 +161,0 @@\n-        public SecretKey getKey() {\n-            return key;\n-        }\n-\n-        public void setKey(SecretKey key) {\n-            this.key = key;\n-        }\n-\n@@ -167,0 +167,10 @@\n+        \/\/ Package-private\n+        SecretKey getKey() {\n+            return key;\n+        }\n+\n+        \/\/ Package-private\n+        void setKey(SecretKey key) {\n+            this.key = key;\n+        }\n+\n@@ -190,2 +200,2 @@\n-                            String name = ((NamedParameterSpec) ng.keAlgParamSpec).\n-                                    getName();\n+                            String name = ((NamedParameterSpec)\n+                                    ng.keAlgParamSpec).getName();\n@@ -194,1 +204,1 @@\n-                                    kcred.getKeyshare());\n+                                    kcred.getKeyShare());\n@@ -200,1 +210,1 @@\n-                    \"No sufficient XDHE key agreement \"\n+                    \"No suitable KEM key agreement \"\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KEMKeyExchange.java","additions":38,"deletions":28,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -304,1 +304,2 @@\n-                            pos instanceof KEMKeyExchange.KEMReceiverPossession) {\n+                            pos instanceof\n+                            KEMKeyExchange.KEMReceiverPossession) {\n@@ -572,1 +573,2 @@\n-                            pos instanceof KEMKeyExchange.KEMSenderPossession)) {\n+                            pos instanceof\n+                            KEMKeyExchange.KEMSenderPossession)) {\n@@ -584,2 +586,3 @@\n-                    \/\/ shared secret derived from encapsulation is stored in the\n-                    \/\/ KEMSenderPossession for later use in the TLS key schedule.\n+                    \/\/ shared secret derived from encapsulation is stored in\n+                    \/\/ the KEMSenderPossession for later use in the TLS key\n+                    \/\/ schedule.\n@@ -587,14 +590,12 @@\n-                        for (SSLCredentials cred : shc.handshakeCredentials) {\n-                            if (cred instanceof KEMKeyExchange.KEMCredentials kcred\n-                                    && ng.equals(kcred.namedGroup)) {\n-                                String name = ((NamedParameterSpec) ng.keAlgParamSpec).\n-                                        getName();\n-                                KAKeyDerivation handshakeKD = new KAKeyDerivation(\n-                                        name, ng, shc, null, null,\n-                                        kcred.getKeyshare());\n-                                var encaped = handshakeKD.encapsulate(\n-                                        \"TlsHandshakeSecret\");\n-                                xp.setKey(encaped.key());\n-                                keyShare = new KeyShareEntry(ng.id,\n-                                        encaped.encapsulation());\n-                            }\n+                        if (cd instanceof KEMKeyExchange.KEMCredentials kcred\n+                                && ng.equals(kcred.namedGroup)) {\n+                            String name = ((NamedParameterSpec)\n+                                    ng.keAlgParamSpec).getName();\n+                            KAKeyDerivation handshakeKD = new KAKeyDerivation(\n+                                    name, ng, shc, null, null,\n+                                    kcred.getKeyShare());\n+                            var encaped = handshakeKD.encapsulate(\n+                                    \"TlsHandshakeSecret\");\n+                            xp.setKey(encaped.key());\n+                            keyShare = new KeyShareEntry(ng.id,\n+                                    encaped.encapsulation());\n@@ -723,1 +724,2 @@\n-            if (namedGroupCred instanceof KEMKeyExchange.KEMCredentials kemCred) {\n+            if (namedGroupCred instanceof KEMKeyExchange.KEMCredentials\n+                    kemCred) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KeyShareExtension.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.crypto.provider.DH;\n@@ -43,1 +42,0 @@\n-import sun.security.util.Hybrid;\n@@ -238,1 +236,1 @@\n-            DH.PROVIDER),\n+            DHasKEM.PROVIDER),\n@@ -244,1 +242,1 @@\n-            DH.PROVIDER),\n+            DHasKEM.PROVIDER),\n@@ -250,1 +248,1 @@\n-            DH.PROVIDER),\n+            DHasKEM.PROVIDER),\n@@ -317,2 +315,1 @@\n-                    Provider p = getProvider();\n-                    if (p == null) {\n+                    if (defaultProvider == null) {\n@@ -321,1 +318,1 @@\n-                        KeyFactory.getInstance(name, p);\n+                        KeyFactory.getInstance(name, defaultProvider);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NamedGroup.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -568,5 +568,10 @@\n-            \/\/ Key Encapsulation Mechanism (KEM):\n-            \/\/  The decapsulator (the client) publishes a public key, and the\n-            \/\/  encapsulator (the server) uses it to generate:\n-            \/\/  - the shared secret\n-            \/\/  - the encapsulation (ciphertext), which is sent back to the client.\n+            \/\/ For key derivation, we will either use the traditional Key\n+            \/\/ Agreement (KA) model or the Key Encapsulation Mechanism (KEM)\n+            \/\/ model, depending on what key exchange group is used.\n+            \/\/\n+            \/\/ In JSSE for KA flow, the server usually generates its key\n+            \/\/ share and then derives the shared secret after receiving the\n+            \/\/ client's share. However, this is changed for KEM: the server\n+            \/\/ must perform both actions — derive the secret and generate\n+            \/\/ the key encapsulation message at the same time during\n+            \/\/ encapsulation in SHKeyShareProducer.\n@@ -575,3 +580,3 @@\n-            \/\/  Both peers perform similar operations: generate a key share,\n-            \/\/  send it, and compute a shared secret upon receiving the peer's\n-            \/\/  key share.\n+            \/\/   - Both peers generate a key share and exchange it.\n+            \/\/   - Each peer computes a shared secret upon receiving the\n+            \/\/     other's key share.\n@@ -579,9 +584,9 @@\n-            \/\/ In JSSE, the server usually generates its key share and then\n-            \/\/ derives the secret after receiving the client's share (KA).\n-            \/\/ However, this is changed for KEM: the server (as encapsulator)\n-            \/\/ must perform both actions — derive the secret and generate the\n-            \/\/ encapsulated message at the same time during encapsulation\n-            \/\/ in SHKeyShareProducer.\n-            \/\/ The derived shared secret must be stored in a KEMSenderPossession\n-            \/\/ so it can be retrieved for handshake traffic secret derivation\n-            \/\/ later.\n+            \/\/ Key Encapsulation Mechanism (KEM):\n+            \/\/  The decapsulator (the client) publishes a public key, and\n+            \/\/  the encapsulator (the server) uses it to generate:\n+            \/\/  - the shared secret\n+            \/\/  - the key encapsulation message, which is sent back to the\n+            \/\/    client.\n+            \/\/  - The derived shared secret must be stored in a\n+            \/\/    KEMSenderPossession so it can be retrieved for handshake\n+            \/\/    traffic secret derivation later.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -33,1 +33,3 @@\n- * @run main\/othervm -Djdk.tls.namedGroups=x25519,secp256r1,secp384r1,X25519MLKEM768,SecP256r1MLKEM768,SecP384r1MLKEM1024 HRRKeyShares\n+ * @run main\/othervm\n+ *     -Djdk.tls.namedGroups=x25519,secp256r1,secp384r1,X25519MLKEM768,SecP256r1MLKEM768,SecP384r1MLKEM1024\n+ *     HRRKeyShares\n@@ -353,1 +355,2 @@\n-            \/\/ with a secp384r1 share.\n+            \/\/ with a key share for the HRR requested named\n+            \/\/ group (hrrNamedGroup).\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv13\/HRRKeyShares.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.util.List;\n@@ -54,1 +55,1 @@\n-    private static final Protocol[] PROTOCOLS = new Protocol[] {\n+    private static final List<Protocol> PROTOCOLS = List.of(\n@@ -59,1 +60,1 @@\n-    };\n+    );\n@@ -61,1 +62,1 @@\n-    private static final CipherSuite[] CIPHER_SUITES = new CipherSuite[] {\n+    private static final List<CipherSuite> CIPHER_SUITES = List.of(\n@@ -82,1 +83,1 @@\n-    };\n+    );\n@@ -84,1 +85,1 @@\n-    private static final String[] HYBRID_NAMEDGROUPS = {\n+    private static final List<String> HYBRID_NAMEDGROUPS = List.of(\n@@ -88,1 +89,1 @@\n-    };\n+    );\n@@ -90,1 +91,1 @@\n-    private static final Protocol[] HYBRID_PROTOCOL = new Protocol[] {\n+    private static final List<Protocol> HYBRID_PROTOCOL = List.of(\n@@ -92,1 +93,1 @@\n-    };\n+    );\n@@ -94,1 +95,1 @@\n-    private static final CipherSuite[] HYBRID_CIPHER_SUITES = new CipherSuite[] {\n+    private static final List<CipherSuite> HYBRID_CIPHER_SUITES = List.of(\n@@ -98,1 +99,1 @@\n-    };\n+    );\n@@ -174,3 +175,2 @@\n-        boolean hybridGroup = Arrays.asList(HYBRID_NAMEDGROUPS).\n-                contains(namedGroup);\n-        Protocol[] protocolList = hybridGroup ?\n+        boolean hybridGroup = HYBRID_NAMEDGROUPS.contains(namedGroup);\n+        List<Protocol> protocolList = hybridGroup ?\n@@ -178,1 +178,1 @@\n-        CipherSuite[] cipherList = hybridGroup ?\n+        List<CipherSuite> cipherList = hybridGroup ?\n@@ -189,1 +189,1 @@\n-                        && groupSupportdByCipher(normalizedGroup,\n+                        && groupSupportedByCipher(normalizedGroup,\n@@ -200,1 +200,1 @@\n-    private static boolean groupSupportdByCipher(String group,\n+    private static boolean groupSupportedByCipher(String group,\n@@ -202,1 +202,1 @@\n-        if (Arrays.asList(HYBRID_NAMEDGROUPS).contains(group)) {\n+        if (HYBRID_NAMEDGROUPS.contains(group)) {\n@@ -207,1 +207,1 @@\n-                        && xdhGroupSupportdByCipher(cipherSuite))\n+                        && xdhGroupSupportedByCipher(cipherSuite))\n@@ -209,1 +209,1 @@\n-                        && ecdhGroupSupportdByCipher(cipherSuite))\n+                        && ecdhGroupSupportedByCipher(cipherSuite))\n@@ -211,1 +211,1 @@\n-                        && ffdhGroupSupportdByCipher(cipherSuite));\n+                        && ffdhGroupSupportedByCipher(cipherSuite));\n@@ -214,1 +214,1 @@\n-    private static boolean xdhGroupSupportdByCipher(\n+    private static boolean xdhGroupSupportedByCipher(\n@@ -220,1 +220,1 @@\n-    private static boolean ecdhGroupSupportdByCipher(\n+    private static boolean ecdhGroupSupportedByCipher(\n@@ -227,1 +227,1 @@\n-    private static boolean ffdhGroupSupportdByCipher(\n+    private static boolean ffdhGroupSupportedByCipher(\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/NamedGroupsWithCipherSuite.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    private static final String[][][] protocolForClassic = {\n+    private static final String[][][] protocolsForClassic = {\n@@ -58,1 +58,1 @@\n-    private static final String[][][] protocolForHybrid = {\n+    private static final String[][][] protocolsForHybrid = {\n@@ -101,1 +101,2 @@\n-        String[][][] protocols = hybridGroup ? protocolForHybrid : protocolForClassic;\n+        String[][][] protocols = hybridGroup ?\n+                protocolsForHybrid : protocolsForClassic;\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/SupportedGroups.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-            return (Provider) (dhClazz.getField(\"PROVIDER\").get(null));\n+            return (Provider) dhClazz.getField(\"PROVIDER\").get(null);\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/KeyPairGeneratorBench.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}