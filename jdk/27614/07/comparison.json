{"files":[{"patch":"@@ -0,0 +1,340 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import sun.security.util.ArrayUtil;\n+import sun.security.util.CurveDB;\n+import sun.security.util.ECUtil;\n+import sun.security.util.Hybrid;\n+import sun.security.util.NamedCurve;\n+\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.KeyAgreement;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.*;\n+import java.security.interfaces.ECKey;\n+import java.security.interfaces.ECPublicKey;\n+import java.security.interfaces.XECKey;\n+import java.security.interfaces.XECPublicKey;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.ECPoint;\n+import java.security.spec.ECPublicKeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.security.spec.XECPublicKeySpec;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static sun.security.util.SecurityConstants.PROVIDER_VER;\n+\n+\/**\n+ * The DH provider is a KEM abstraction layer over traditional DH based\n+ * key exchange. It models DH\/ECDH\/XDH as KEMs, like post-quantum algorithms,\n+ * so DH\/ECDH\/XDH can be used in hybrid key exchange, alongside post-quantum\n+ * KEMs.\n+ *\/\n+public class DH implements KEMSpi {\n+\n+    \/\/ DH in its own private provider so we always getInstance from here.\n+    public static final Provider PROVIDER = new ProviderImpl();\n+\n+    private static class ProviderImpl extends Provider {\n+        @java.io.Serial\n+        private static final long serialVersionUID = 0L;\n+        private ProviderImpl() {\n+            super(\"InternalJCE\", PROVIDER_VER, \"\");\n+            put(\"KEM.DH\", DH.class.getName());\n+\n+            \/\/ Hybrid KeyPairGenerator\/KeyFactory\/KEM\n+\n+            \/\/ The order of shares in the concatenation for group name\n+            \/\/ X25519MLKEM768 has been reversed. This is due to historical\n+            \/\/ reasons.\n+            var attrs = Map.of(\"name\", \"X25519MLKEM768\", \"left\", \"ML-KEM-768\",\n+                    \"right\", \"X25519\");\n+            putService(new HybridService(this, \"KeyPairGenerator\",\n+                    \"X25519MLKEM768\", \"sun.security.util.Hybrid$KeyPairGeneratorImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KEM\",\n+                    \"X25519MLKEM768\", \"sun.security.util.Hybrid$KEMImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KeyFactory\",\n+                    \"X25519MLKEM768\", \"sun.security.util.Hybrid$KeyFactoryImpl\",\n+                    null, attrs));\n+\n+            attrs = Map.of(\"name\", \"SecP256r1MLKEM768\", \"left\", \"secp256r1\",\n+                    \"right\", \"ML-KEM-768\");\n+            putService(new HybridService(this, \"KeyPairGenerator\",\n+                    \"SecP256r1MLKEM768\", \"sun.security.util.Hybrid$KeyPairGeneratorImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KEM\",\n+                    \"SecP256r1MLKEM768\", \"sun.security.util.Hybrid$KEMImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KeyFactory\",\n+                    \"SecP256r1MLKEM768\", \"sun.security.util.Hybrid$KeyFactoryImpl\",\n+                    null, attrs));\n+\n+            attrs = Map.of(\"name\", \"SecP384r1MLKEM1024\", \"left\", \"secp384r1\",\n+                    \"right\", \"ML-KEM-1024\");\n+            putService(new HybridService(this, \"KeyPairGenerator\",\n+                    \"SecP384r1MLKEM1024\", \"sun.security.util.Hybrid$KeyPairGeneratorImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KEM\",\n+                    \"SecP384r1MLKEM1024\", \"sun.security.util.Hybrid$KEMImpl\",\n+                    null, attrs));\n+            putService(new HybridService(this, \"KeyFactory\",\n+                    \"SecP384r1MLKEM1024\", \"sun.security.util.Hybrid$KeyFactoryImpl\",\n+                    null, attrs));\n+        }\n+    }\n+\n+    @Override\n+    public EncapsulatorSpi engineNewEncapsulator(\n+            PublicKey publicKey, AlgorithmParameterSpec spec,\n+            SecureRandom secureRandom) throws InvalidKeyException {\n+        return new Handler(publicKey, null, secureRandom);\n+    }\n+\n+    @Override\n+    public DecapsulatorSpi engineNewDecapsulator(PrivateKey privateKey,\n+            AlgorithmParameterSpec spec) throws InvalidKeyException {\n+        return new Handler(null, privateKey, null);\n+    }\n+\n+    static final class Handler\n+            implements KEMSpi.EncapsulatorSpi, KEMSpi.DecapsulatorSpi {\n+        private final PublicKey pkR;\n+        private final PrivateKey skR;\n+        private final SecureRandom sr;\n+        private final Params params;\n+\n+        Handler(PublicKey pk, PrivateKey sk, SecureRandom sr)\n+                throws InvalidKeyException {\n+            this.pkR = pk;\n+            this.skR = sk;\n+            this.sr = sr;\n+            this.params = paramsFromKey(pk == null ? sk : pk);\n+        }\n+\n+        @Override\n+        public KEM.Encapsulated engineEncapsulate(int from, int to,\n+                String algorithm) {\n+            KeyPair kpE = params.generateKeyPair(sr);\n+            PrivateKey skE = kpE.getPrivate();\n+            PublicKey pkE = kpE.getPublic();\n+            byte[] pkEm = params.SerializePublicKey(pkE);\n+            try {\n+                SecretKey dh = params.DH(algorithm, skE, pkR);\n+                return new KEM.Encapsulated(\n+                        sub(dh, from, to),\n+                        pkEm, null);\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        @Override\n+        public int engineSecretSize() {\n+            return params.Nsecret;\n+        }\n+\n+        @Override\n+        public int engineEncapsulationSize() {\n+            return params.Npk;\n+        }\n+\n+        @Override\n+        public SecretKey engineDecapsulate(byte[] encapsulation, int from,\n+                int to, String algorithm) throws DecapsulateException {\n+            if (encapsulation.length != params.Npk) {\n+                throw new DecapsulateException(\"incorrect encapsulation size\");\n+            }\n+            try {\n+                PublicKey pkE = params.DeserializePublicKey(encapsulation);\n+                SecretKey dh = params.DH(algorithm, skR, pkE);\n+                return sub(dh, from, to);\n+            } catch (IOException | InvalidKeyException e) {\n+                throw new DecapsulateException(\"Cannot decapsulate\", e);\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        private SecretKey sub(SecretKey key, int from, int to) {\n+            if (from == 0 && to == params.Nsecret) {\n+                return key;\n+            } else if (\"RAW\".equalsIgnoreCase(key.getFormat())) {\n+                byte[] km = key.getEncoded();\n+                if (km == null) {\n+                    \/\/ Should not happen if format is \"RAW\"\n+                    throw new UnsupportedOperationException(\"Key extract failed\");\n+                } else {\n+                    return new SecretKeySpec(km, from, to - from,\n+                            key.getAlgorithm());\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\"Cannot extract key\");\n+            }\n+        }\n+\n+        \/\/ This KEM is designed to be able to represent every ECDH and XDH\n+        private Params paramsFromKey(Key k) throws InvalidKeyException {\n+            if (k instanceof ECKey eckey) {\n+                if (ECUtil.equals(eckey.getParams(), CurveDB.P_256)) {\n+                    return Params.P256;\n+                } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_384)) {\n+                    return Params.P384;\n+                } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_521)) {\n+                    return Params.P521;\n+                }\n+            } else if (k instanceof XECKey xkey\n+                    && xkey.getParams() instanceof NamedParameterSpec ns) {\n+                if (ns.getName().equalsIgnoreCase(\n+                        NamedParameterSpec.X25519.getName())) {\n+                    return Params.X25519;\n+                } else if (ns.getName().equalsIgnoreCase(\n+                        NamedParameterSpec.X448.getName())) {\n+                    return Params.X448;\n+                }\n+            }\n+            throw new InvalidKeyException(\"Unsupported key\");\n+        }\n+    }\n+\n+    private enum Params {\n+\n+        P256(32, 2 * 32 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_256),\n+\n+        P384(48, 2 * 48 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_384),\n+\n+        P521(66, 2 * 66 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_521),\n+\n+        X25519(32, 32,\n+                \"XDH\", \"XDH\", NamedParameterSpec.X25519),\n+\n+        X448(56, 56,\n+                \"XDH\", \"XDH\", NamedParameterSpec.X448),\n+        ;\n+        private final int Nsecret;\n+        private final int Npk;\n+        private final String kaAlgorithm;\n+        private final String keyAlgorithm;\n+        private final AlgorithmParameterSpec spec;\n+\n+\n+        Params(int Nsecret, int Npk, String kaAlgorithm, String keyAlgorithm,\n+                AlgorithmParameterSpec spec) {\n+            this.spec = spec;\n+            this.Nsecret = Nsecret;\n+            this.Npk = Npk;\n+            this.kaAlgorithm = kaAlgorithm;\n+            this.keyAlgorithm = keyAlgorithm;\n+        }\n+\n+        private boolean isEC() {\n+            return this == P256 || this == P384 || this == P521;\n+        }\n+\n+        private KeyPair generateKeyPair(SecureRandom sr) {\n+            try {\n+                KeyPairGenerator g = KeyPairGenerator.getInstance(keyAlgorithm);\n+                g.initialize(spec, sr);\n+                return g.generateKeyPair();\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        private byte[] SerializePublicKey(PublicKey k) {\n+            if (isEC()) {\n+                ECPoint w = ((ECPublicKey) k).getW();\n+                return ECUtil.encodePoint(w, ((NamedCurve) spec).getCurve());\n+            } else {\n+                byte[] uArray = ((XECPublicKey) k).getU().toByteArray();\n+                ArrayUtil.reverse(uArray);\n+                return Arrays.copyOf(uArray, Npk);\n+            }\n+        }\n+\n+        private PublicKey DeserializePublicKey(byte[] data) throws\n+                IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+            KeySpec keySpec;\n+            if (isEC()) {\n+                NamedCurve curve = (NamedCurve) this.spec;\n+                keySpec = new ECPublicKeySpec(\n+                        ECUtil.decodePoint(data, curve.getCurve()), curve);\n+            } else {\n+                data = data.clone();\n+                ArrayUtil.reverse(data);\n+                keySpec = new XECPublicKeySpec(\n+                        this.spec, new BigInteger(1, data));\n+            }\n+            return KeyFactory.getInstance(keyAlgorithm).generatePublic(keySpec);\n+        }\n+\n+        private SecretKey DH(String alg, PrivateKey skE, PublicKey pkR)\n+                throws NoSuchAlgorithmException, InvalidKeyException {\n+            KeyAgreement ka = KeyAgreement.getInstance(kaAlgorithm);\n+            ka.init(skE);\n+            ka.doPhase(pkR, true);\n+            return ka.generateSecret(alg);\n+        }\n+    }\n+\n+    private static class HybridService extends Provider.Service {\n+\n+        HybridService(Provider p, String type, String algo, String cn,\n+                List<String> aliases, Map<String, String> attrs) {\n+            super(p, type, algo, cn, aliases, attrs);\n+        }\n+\n+        @Override\n+        public Object newInstance(Object ctrParamObj)\n+                throws NoSuchAlgorithmException {\n+            String type = getType();\n+            return switch (type) {\n+                case \"KeyPairGenerator\" -> new Hybrid.KeyPairGeneratorImpl(\n+                        getAttribute(\"left\"), getAttribute(\"right\"));\n+                case \"KeyFactory\" -> new Hybrid.KeyFactoryImpl(\n+                        getAttribute(\"left\"), getAttribute(\"right\"));\n+                case \"KEM\" -> new Hybrid.KEMImpl(\n+                        getAttribute(\"left\"), getAttribute(\"right\"));\n+                default -> throw new NoSuchAlgorithmException(\n+                        \"Unexpected value: \" + type);\n+            };\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DH.java","additions":340,"deletions":0,"binary":false,"changes":340,"status":"added"},{"patch":"@@ -27,0 +27,3 @@\n+import sun.security.util.Hybrid;\n+import sun.security.util.RawKeySpec;\n+\n@@ -28,0 +31,1 @@\n+import javax.crypto.KEM;\n@@ -35,0 +39,1 @@\n+import java.security.KeyFactory;\n@@ -37,1 +42,0 @@\n-import java.security.spec.AlgorithmParameterSpec;\n@@ -49,0 +53,2 @@\n+    private final byte[] keyshare;\n+    private final java.security.Provider provider;\n@@ -50,0 +56,1 @@\n+    \/\/ Constructor called by Key Agreement\n@@ -54,0 +61,12 @@\n+        this(algorithmName, null, context, localPrivateKey,\n+                peerPublicKey, null);\n+    }\n+\n+    \/\/ When the constructor called by KEM: store the client's public key or the\n+    \/\/ encapsulated message in keyshare.\n+    KAKeyDerivation(String algorithmName,\n+                    NamedGroup namedGroup,\n+                    HandshakeContext context,\n+                    PrivateKey localPrivateKey,\n+                    PublicKey peerPublicKey,\n+                    byte[] keyshare) {\n@@ -58,0 +77,2 @@\n+        this.keyshare = keyshare;\n+        this.provider = (namedGroup != null) ? namedGroup.getProvider() : null;\n@@ -97,6 +118,2 @@\n-    \/**\n-     * Handle the TLSv1.3 objects, which use the HKDF algorithms.\n-     *\/\n-    private SecretKey t13DeriveKey(String type)\n-            throws IOException {\n-        SecretKey sharedSecret = null;\n+    private SecretKey deriveHandshakeSecret(String label, SecretKey sharedSecret)\n+            throws GeneralSecurityException, IOException {\n@@ -105,5 +122,0 @@\n-        try {\n-            KeyAgreement ka = KeyAgreement.getInstance(algorithmName);\n-            ka.init(localPrivateKey);\n-            ka.doPhase(peerPublicKey, true);\n-            sharedSecret = ka.generateSecret(\"TlsPremasterSecret\");\n@@ -111,2 +123,3 @@\n-            CipherSuite.HashAlg hashAlg = context.negotiatedCipherSuite.hashAlg;\n-            SSLKeyDerivation kd = context.handshakeKeyDerivation;\n+        CipherSuite.HashAlg hashAlg = context.negotiatedCipherSuite.hashAlg;\n+        SSLKeyDerivation kd = context.handshakeKeyDerivation;\n+        try {\n@@ -132,2 +145,76 @@\n-            return hkdf.deriveKey(type, HKDFParameterSpec.ofExtract()\n-                    .addSalt(saltSecret).addIKM(sharedSecret).extractOnly());\n+            var spec = HKDFParameterSpec.ofExtract().addSalt(saltSecret);\n+            if (sharedSecret instanceof Hybrid.SecretKeyImpl hsk) {\n+                spec = spec.addIKM(hsk.k1()).addIKM(hsk.k2());\n+            } else {\n+                spec = spec.addIKM(sharedSecret);\n+            }\n+\n+            return hkdf.deriveKey(label, spec.extractOnly());\n+        } finally {\n+            KeyUtil.destroySecretKeys(earlySecret, saltSecret);\n+        }\n+    }\n+    \/**\n+     * This method is called by the server to perform KEM encapsulation.\n+     * It uses the client's public key (sent by the client as a keyshare)\n+     * to encapsulate a shared secret and returns the encapsulated message.\n+     *\/\n+    public KEM.Encapsulated encapsulate(String algorithm)\n+            throws IOException {\n+        SecretKey sharedSecret = null;\n+\n+        if (keyshare == null) {\n+            throw new IOException(\"No keyshare available for KEM encapsulation\");\n+        }\n+\n+        try {\n+            KeyFactory kf = (provider != null) ?\n+                    KeyFactory.getInstance(algorithmName, provider) :\n+                    KeyFactory.getInstance(algorithmName);\n+            var pk = kf.generatePublic(new RawKeySpec(keyshare));\n+\n+            KEM kem = (provider != null) ?\n+                    KEM.getInstance(algorithmName, provider) :\n+                    KEM.getInstance(algorithmName);\n+            KEM.Encapsulator e = kem.newEncapsulator(pk);\n+            KEM.Encapsulated enc = e.encapsulate();\n+            sharedSecret = enc.key();\n+\n+            SecretKey derived = deriveHandshakeSecret(algorithm, sharedSecret);\n+\n+            return new KEM.Encapsulated(derived, enc.encapsulation(), null);\n+        } catch (GeneralSecurityException gse) {\n+            throw new SSLHandshakeException(\"Could not generate secret\", gse);\n+        } finally {\n+            KeyUtil.destroySecretKeys(sharedSecret);\n+        }\n+    }\n+\n+    \/**\n+     * Handle the TLSv1.3 objects, which use the HKDF algorithms.\n+     *\/\n+    private SecretKey t13DeriveKey(String type)\n+            throws IOException {\n+        SecretKey sharedSecret = null;\n+\n+        try {\n+            if (keyshare != null) {\n+                \/\/ Using KEM: called by the client after receiving the KEM\n+                \/\/ ciphertext (keyshare) from the server in ServerHello.\n+                \/\/ The client decapsulates it using its private key.\n+                KEM kem = (provider != null)\n+                        ? KEM.getInstance(algorithmName, provider)\n+                        : KEM.getInstance(algorithmName);\n+                var decapsulator = kem.newDecapsulator(localPrivateKey);\n+                sharedSecret = decapsulator.decapsulate(\n+                        keyshare, 0, decapsulator.secretSize(),\n+                        \"TlsPremasterSecret\");\n+            } else {\n+                \/\/ Using traditional DH-style Key Agreement\n+                KeyAgreement ka = KeyAgreement.getInstance(algorithmName);\n+                ka.init(localPrivateKey);\n+                ka.doPhase(peerPublicKey, true);\n+                sharedSecret = ka.generateSecret(\"TlsPremasterSecret\");\n+            }\n+\n+            return deriveHandshakeSecret(type, sharedSecret);\n@@ -137,1 +224,1 @@\n-            KeyUtil.destroySecretKeys(sharedSecret, earlySecret, saltSecret);\n+            KeyUtil.destroySecretKeys(sharedSecret);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KAKeyDerivation.java","additions":104,"deletions":17,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.ssl;\n+\n+import java.io.IOException;\n+import java.security.*;\n+import java.security.spec.NamedParameterSpec;\n+\n+import sun.security.ssl.NamedGroup.NamedGroupSpec;\n+import sun.security.util.*;\n+import sun.security.x509.X509Key;\n+\n+import javax.crypto.SecretKey;\n+\n+\/**\n+ * Specifics for single or hybrid Key exchanges based on KEM\n+ *\/\n+final class KEMKeyExchange {\n+\n+    static final SSLKeyAgreementGenerator kemKAGenerator\n+            = new KEMKAGenerator();\n+\n+    static final class KEMCredentials implements NamedGroupCredentials {\n+\n+        final NamedGroup namedGroup;\n+        \/\/ Unlike other credentials, we directly store the key share\n+        \/\/ value here, no need to convert to a key\n+        final byte[] keyshare;\n+\n+        KEMCredentials(byte[] keyshare, NamedGroup namedGroup) {\n+            this.keyshare = keyshare;\n+            this.namedGroup = namedGroup;\n+        }\n+\n+        \/\/ For KEM, server performs encapsulation and the resulting\n+        \/\/ encapsulated message becomes the key_share value sent to\n+        \/\/ the client. It is not a public key, so no PublicKey object\n+        \/\/ to return.\n+        @Override\n+        public PublicKey getPublicKey() {\n+            throw new UnsupportedOperationException(\n+                    \"KEMCredentials stores raw keyshare, not a PublicKey\");\n+        }\n+\n+        public byte[] getKeyshare() {\n+            return keyshare;\n+        }\n+\n+        @Override\n+        public NamedGroup getNamedGroup() {\n+            return namedGroup;\n+        }\n+\n+        \/**\n+         * Parse the encoded Point into the KEMCredentials using the\n+         * namedGroup.\n+         *\/\n+        static KEMCredentials valueOf(NamedGroup namedGroup,\n+                byte[] encodedPoint) throws IOException,\n+                GeneralSecurityException {\n+\n+            if (namedGroup.spec != NamedGroupSpec.NAMED_GROUP_KEM) {\n+                throw new RuntimeException(\n+                        \"Credentials decoding:  Not KEM named group\");\n+            }\n+\n+            if (encodedPoint == null || encodedPoint.length == 0) {\n+                return null;\n+            }\n+\n+            return new KEMCredentials(encodedPoint, namedGroup);\n+        }\n+    }\n+\n+    static class KEMPossession implements SSLPossession {\n+        private final NamedGroup namedGroup;\n+        public KEMPossession(NamedGroup ng) {\n+            this.namedGroup = ng;\n+        }\n+        public NamedGroup getNamedGroup() {\n+            return namedGroup;\n+        }\n+    }\n+\n+    static final class KEMReceiverPossession extends KEMPossession {\n+\n+        private final PrivateKey privateKey;\n+        private final PublicKey publicKey;\n+\n+        KEMReceiverPossession(NamedGroup namedGroup, SecureRandom random) {\n+            super(namedGroup);\n+            try {\n+                \/\/ For KEM: This receiver side (client) generates a key pair.\n+                String algName = ((NamedParameterSpec)namedGroup.keAlgParamSpec).\n+                        getName();\n+                Provider provider = namedGroup.getProvider();\n+                KeyPairGenerator kpg = (provider != null) ?\n+                        KeyPairGenerator.getInstance(algName, provider) :\n+                        KeyPairGenerator.getInstance(algName);\n+\n+                KeyPair kp = kpg.generateKeyPair();\n+                privateKey = kp.getPrivate();\n+                publicKey = kp.getPublic();\n+            } catch (GeneralSecurityException e) {\n+                throw new RuntimeException(\n+                        \"Could not generate XDH keypair\", e);\n+            }\n+        }\n+\n+        @Override\n+        public byte[] encode() {\n+            if (publicKey instanceof X509Key xk) {\n+                return xk.getKeyAsBytes();\n+            } else if (publicKey instanceof Hybrid.PublicKeyImpl hk) {\n+                return hk.getEncoded();\n+            }\n+            throw new ProviderException(\"Unsupported key type: \" + publicKey);\n+        }\n+\n+        public PublicKey getPublicKey() {\n+            return publicKey;\n+        }\n+\n+        public PrivateKey getPrivateKey() {\n+            return privateKey;\n+        }\n+    }\n+\n+    static final class KEMSenderPossession extends KEMPossession {\n+\n+        public SecretKey getKey() {\n+            return key;\n+        }\n+\n+        public void setKey(SecretKey key) {\n+            this.key = key;\n+        }\n+\n+        private SecretKey key;\n+\n+        KEMSenderPossession(NamedGroup namedGroup) {\n+            super(namedGroup);\n+        }\n+\n+        @Override\n+        public byte[] encode() {\n+            throw new UnsupportedOperationException(\"encode() not supported\");\n+        }\n+    }\n+\n+    private static final class KEMKAGenerator\n+            implements SSLKeyAgreementGenerator {\n+\n+        \/\/ Prevent instantiation of this class.\n+        private KEMKAGenerator() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public SSLKeyDerivation createKeyDerivation(\n+                HandshakeContext context) throws IOException {\n+            for (SSLPossession poss : context.handshakePossessions) {\n+                if (poss instanceof KEMReceiverPossession kposs) {\n+                    NamedGroup ng = kposs.getNamedGroup();\n+                    for (SSLCredentials cred : context.handshakeCredentials) {\n+                        if (cred instanceof KEMCredentials kcred &&\n+                                ng.equals(kcred.namedGroup)) {\n+                            String name = ((NamedParameterSpec) ng.keAlgParamSpec).\n+                                    getName();\n+                            return new KAKeyDerivation(name, ng, context,\n+                                    kposs.getPrivateKey(), null,\n+                                    kcred.getKeyshare());\n+                        }\n+                    }\n+                }\n+            }\n+            context.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                    \"No sufficient XDHE key agreement \"\n+                    + \"parameters negotiated\");\n+            return null;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KEMKeyExchange.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import java.security.AlgorithmConstraints;\n@@ -32,0 +33,2 @@\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n@@ -300,1 +303,2 @@\n-                    if (pos instanceof NamedGroupPossession) {\n+                    if (pos instanceof NamedGroupPossession ||\n+                            pos instanceof KEMKeyExchange.KEMReceiverPossession) {\n@@ -361,12 +365,0 @@\n-                    if (shc.algorithmConstraints != null &&\n-                            kaCred instanceof\n-                                NamedGroupCredentials namedGroupCredentials) {\n-                        if (!shc.algorithmConstraints.permits(\n-                                EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n-                                namedGroupCredentials.getPublicKey())) {\n-                            if (SSLLogger.isOn &&\n-                                    SSLLogger.isOn(\"ssl,handshake\")) {\n-                                SSLLogger.warning(\n-                                    \"key share entry of \" + ng + \" does not \" +\n-                                    \" comply with algorithm constraints\");\n-                            }\n@@ -374,1 +366,7 @@\n-                            kaCred = null;\n+                    if (!isCredentialPermitted(shc.algorithmConstraints,\n+                            kaCred)) {\n+                        if (SSLLogger.isOn &&\n+                                SSLLogger.isOn(\"ssl,handshake\")) {\n+                            SSLLogger.warning(\n+                                    \"key share entry of \" + ng + \" does not \" +\n+                                    \"comply with algorithm constraints\");\n@@ -376,3 +374,1 @@\n-                    }\n-\n-                    if (kaCred != null) {\n+                    } else {\n@@ -516,1 +512,2 @@\n-            \/\/ The producing happens in client side only.\n+            \/\/ The producing happens in server side only.\n+\n@@ -574,1 +571,2 @@\n-                    if (!(pos instanceof NamedGroupPossession)) {\n+                    if (!(pos instanceof NamedGroupPossession ||\n+                            pos instanceof KEMKeyExchange.KEMSenderPossession)) {\n@@ -582,1 +580,25 @@\n-                    keyShare = new KeyShareEntry(ng.id, pos.encode());\n+\n+                    \/\/ For KEM, perform encapsulation using the client’s public\n+                    \/\/ key (KEMCredentials). The resulting encapsulated message\n+                    \/\/ becomes the key_share value sent to the client. The\n+                    \/\/ shared secret derived from encapsulation is stored in the\n+                    \/\/ KEMSenderPossession for later use in the TLS key schedule.\n+                    if (pos instanceof KEMKeyExchange.KEMSenderPossession xp) {\n+                        for (SSLCredentials cred : shc.handshakeCredentials) {\n+                            if (cred instanceof KEMKeyExchange.KEMCredentials kcred\n+                                    && ng.equals(kcred.namedGroup)) {\n+                                String name = ((NamedParameterSpec) ng.keAlgParamSpec).\n+                                        getName();\n+                                KAKeyDerivation handshakeKD = new KAKeyDerivation(\n+                                        name, ng, shc, null, null,\n+                                        kcred.getKeyshare());\n+                                var encaped = handshakeKD.encapsulate(\n+                                        \"TlsHandshakeSecret\");\n+                                xp.setKey(encaped.key());\n+                                keyShare = new KeyShareEntry(ng.id,\n+                                        encaped.encapsulation());\n+                            }\n+                        }\n+                    } else {\n+                        keyShare = new KeyShareEntry(ng.id, pos.encode());\n+                    }\n@@ -666,11 +688,0 @@\n-                if (chc.algorithmConstraints != null &&\n-                        kaCred instanceof\n-                                NamedGroupCredentials namedGroupCredentials) {\n-                    if (!chc.algorithmConstraints.permits(\n-                            EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n-                            namedGroupCredentials.getPublicKey())) {\n-                        chc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,\n-                            \"key share entry of \" + ng + \" does not \" +\n-                            \" comply with algorithm constraints\");\n-                    }\n-                }\n@@ -678,1 +689,6 @@\n-                if (kaCred != null) {\n+                if (!isCredentialPermitted(chc.algorithmConstraints,\n+                        kaCred)) {\n+                    chc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,\n+                            \"key share entry of \" + ng + \" does not \" +\n+                            \"comply with algorithm constraints\");\n+                } else {\n@@ -699,0 +715,27 @@\n+    private static boolean isCredentialPermitted(\n+            AlgorithmConstraints constraints,\n+            SSLCredentials cred) {\n+\n+        if (constraints == null) return true;\n+        if (cred == null) return false;\n+\n+        if (cred instanceof NamedGroupCredentials namedGroupCred) {\n+            if (namedGroupCred instanceof KEMKeyExchange.KEMCredentials kemCred) {\n+                AlgorithmParameterSpec paramSpec = kemCred.getNamedGroup().\n+                        keAlgParamSpec;\n+                String algName = (paramSpec instanceof NamedParameterSpec nps) ?\n+                        nps.getName() : null;\n+                return algName != null && constraints.permits(\n+                        EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n+                        algName,\n+                        null);\n+            } else {\n+                return constraints.permits(\n+                        EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n+                        namedGroupCred.getPublicKey());\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KeyShareExtension.java","additions":75,"deletions":32,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.crypto.provider.DH;\n@@ -42,0 +43,1 @@\n+import sun.security.util.Hybrid;\n@@ -217,0 +219,33 @@\n+    ML_KEM_512(0x0200, \"MLKEM512\",\n+            NamedGroupSpec.NAMED_GROUP_KEM,\n+            ProtocolVersion.PROTOCOLS_OF_13,\n+            null),\n+\n+    ML_KEM_768(0x0201, \"MLKEM768\",\n+            NamedGroupSpec.NAMED_GROUP_KEM,\n+            ProtocolVersion.PROTOCOLS_OF_13,\n+            null),\n+\n+    ML_KEM_1024(0x0202, \"MLKEM1024\",\n+            NamedGroupSpec.NAMED_GROUP_KEM,\n+            ProtocolVersion.PROTOCOLS_OF_13,\n+            null),\n+\n+    X25519MLKEM768(0x11ec, \"X25519MLKEM768\",\n+            NamedGroupSpec.NAMED_GROUP_KEM,\n+            ProtocolVersion.PROTOCOLS_OF_13,\n+            Hybrid.X25519_MLKEM768,\n+            \"DH\"),\n+\n+    SECP256R1MLKEM768(0x11eb, \"SecP256r1MLKEM768\",\n+            NamedGroupSpec.NAMED_GROUP_KEM,\n+            ProtocolVersion.PROTOCOLS_OF_13,\n+            Hybrid.SECP256R1_MLKEM768,\n+            \"DH\"),\n+\n+    SECP384R1MLKEM1024(0x11ed, \"SecP384r1MLKEM1024\",\n+            NamedGroupSpec.NAMED_GROUP_KEM,\n+            ProtocolVersion.PROTOCOLS_OF_13,\n+            Hybrid.SECP384R1_MLKEM1024,\n+            \"DH\"),\n+\n@@ -237,0 +272,1 @@\n+    final String defaultProviderName;\n@@ -242,1 +278,0 @@\n-    \/\/ Constructor used for all NamedGroup types\n@@ -247,0 +282,10 @@\n+        this(id, name, namedGroupSpec, supportedProtocols, keAlgParamSpec,\n+                null);\n+    }\n+\n+    \/\/ Constructor used for all NamedGroup types\n+    NamedGroup(int id, String name,\n+            NamedGroupSpec namedGroupSpec,\n+            ProtocolVersion[] supportedProtocols,\n+            AlgorithmParameterSpec keAlgParamSpec,\n+            String defaultProviderName) {\n@@ -253,0 +298,1 @@\n+        this.defaultProviderName = defaultProviderName;\n@@ -269,3 +315,14 @@\n-                algParams =\n-                    AlgorithmParameters.getInstance(namedGroupSpec.algorithm);\n-                algParams.init(keAlgParamSpec);\n+                \/\/ Skip AlgorithmParameters for KEMs (not supported)\n+                if (namedGroupSpec == NamedGroupSpec.NAMED_GROUP_KEM) {\n+                    Provider p = getProvider();\n+                    if (p == null) {\n+                        KeyFactory.getInstance(name);\n+                    } else {\n+                        KeyFactory.getInstance(name, p);\n+                    }\n+                } else {\n+                    \/\/ ECDHE or others: use AlgorithmParameters as before\n+                    algParams = AlgorithmParameters.getInstance(\n+                            namedGroupSpec.algorithm);\n+                    algParams.init(keAlgParamSpec);\n+                }\n@@ -310,0 +367,8 @@\n+    Provider getProvider() {\n+        if (\"DH\".equals(defaultProviderName)) {\n+            return DH.PROVIDER;\n+        }\n+        \/\/ no fixed provider\n+        return null;\n+    }\n+\n@@ -548,0 +613,4 @@\n+    SSLPossession createPossession(boolean isClient, SecureRandom random) {\n+        return spec.createPossession(this, isClient, random);\n+    }\n+\n@@ -569,0 +638,5 @@\n+\n+        default SSLPossession createPossession(NamedGroup ng, boolean isClient,\n+                SecureRandom random) {\n+            return createPossession(ng, random);\n+        }\n@@ -581,0 +655,4 @@\n+        \/\/ Post-Quantum Cryptography (PQC) KEM groups\n+        \/\/ Currently used for hybrid named groups\n+        NAMED_GROUP_KEM(\"KEM\", KEMScheme.instance),\n+\n@@ -637,0 +715,9 @@\n+        public SSLPossession createPossession(\n+                NamedGroup ng, boolean isClient, SecureRandom random) {\n+            if (scheme != null) {\n+                return scheme.createPossession(ng, isClient, random);\n+            }\n+\n+            return null;\n+        }\n+\n@@ -742,0 +829,36 @@\n+    private static class KEMScheme implements NamedGroupScheme {\n+        private static final KEMScheme instance = new KEMScheme();\n+\n+        @Override\n+        public byte[] encodePossessionPublicKey(NamedGroupPossession poss) {\n+            return poss.encode();\n+        }\n+\n+        @Override\n+        public SSLCredentials decodeCredentials(NamedGroup ng,\n+                byte[] encoded) throws IOException, GeneralSecurityException {\n+            return KEMKeyExchange.KEMCredentials.valueOf(ng, encoded);\n+        }\n+\n+        @Override\n+        public SSLPossession createPossession(NamedGroup ng,\n+                SecureRandom random) {\n+            \/\/ Must call createPossession with isClient\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public SSLPossession createPossession(\n+                NamedGroup ng, boolean isClient, SecureRandom random) {\n+            return isClient\n+                    ? new KEMKeyExchange.KEMReceiverPossession(ng, random)\n+                    : new KEMKeyExchange.KEMSenderPossession(ng);\n+        }\n+\n+        @Override\n+        public SSLKeyDerivation createKeyDerivation(\n+                HandshakeContext hc) throws IOException {\n+            return KEMKeyExchange.kemKAGenerator.createKeyDerivation(hc);\n+        }\n+    }\n+\n@@ -787,0 +910,5 @@\n+                        \/\/ Hybrid key agreements\n+                        X25519MLKEM768,\n+                        SECP256R1MLKEM768,\n+                        SECP384R1MLKEM1024,\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NamedGroup.java","additions":133,"deletions":5,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -573,1 +573,3 @@\n-            return namedGroup.createPossession(hc.sslContext.getSecureRandom());\n+            return namedGroup.createPossession(\n+                    hc instanceof ClientHandshakeContext,\n+                    hc.sslContext.getSecureRandom());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLKeyExchange.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -568,0 +568,21 @@\n+            \/\/ Key Encapsulation Mechanism (KEM):\n+            \/\/  The decapsulator (the client) publishes a public key, and the\n+            \/\/  encapsulator (the server) uses it to generate:\n+            \/\/  - the shared secret\n+            \/\/  - the encapsulation (ciphertext), which is sent back to the client.\n+            \/\/\n+            \/\/ Traditional Key Agreement (KA):\n+            \/\/  Both peers perform similar operations: generate a key share,\n+            \/\/  send it, and compute a shared secret upon receiving the peer's\n+            \/\/  key share.\n+            \/\/\n+            \/\/ In JSSE, the server usually generates its key share and then\n+            \/\/ derives the secret after receiving the client's share (KA).\n+            \/\/ However, this is changed for KEM: the server (as encapsulator)\n+            \/\/ must perform both actions — derive the secret and generate the\n+            \/\/ encapsulated message at the same time during encapsulation\n+            \/\/ in SHKeyShareProducer.\n+            \/\/ The derived shared secret must be stored in a KEMSenderPossession\n+            \/\/ so it can be retrieved for handshake traffic secret derivation\n+            \/\/ later.\n+\n@@ -593,3 +614,21 @@\n-            SSLKeyDerivation handshakeKD = ke.createKeyDerivation(shc);\n-            SecretKey handshakeSecret = handshakeKD.deriveKey(\n-                    \"TlsHandshakeSecret\");\n+            SecretKey handshakeSecret = null;\n+\n+            \/\/ For KEM, the shared secret has already been generated and\n+            \/\/ stored in the server’s possession (KEMSenderPossession)\n+            \/\/ during encapsulation in SHKeyShareProducer.\n+            \/\/\n+            \/\/ Only one key share is selected by the server, so at most one\n+            \/\/ possession will contain the pre-derived shared secret.\n+            for (var pos : shc.handshakePossessions) {\n+                if (pos instanceof KEMKeyExchange.KEMSenderPossession xp\n+                        && xp.getKey() != null) {\n+                    handshakeSecret = xp.getKey();\n+                    break;\n+                }\n+            }\n+\n+            if (handshakeSecret == null) {\n+                SSLKeyDerivation handshakeKD = ke.createKeyDerivation(shc);\n+                handshakeSecret = handshakeKD.deriveKey(\n+                        \"TlsHandshakeSecret\");\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":42,"deletions":3,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,462 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import com.sun.crypto.provider.DH;\n+import sun.security.x509.X509Key;\n+\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.SecretKey;\n+import java.io.ByteArrayOutputStream;\n+import java.math.BigInteger;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.InvalidParameterException;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.KeyFactorySpi;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyPairGeneratorSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+import java.util.Locale;\n+\n+public class Hybrid {\n+\n+    public record SecretKeyImpl(SecretKey k1, SecretKey k2) implements SecretKey {\n+        @Override\n+        public String getAlgorithm() {\n+            return \"Hybrid\";\n+        }\n+\n+        @Override\n+        public String getFormat() {\n+            return null;\n+        }\n+\n+        @Override\n+        public byte[] getEncoded() {\n+            return null;\n+        }\n+    }\n+\n+    private static AlgorithmParameterSpec getSpec(String name) {\n+        if (APS.isGenericEC(name)) {\n+            return new ECGenParameterSpec(name);\n+        } else {\n+            return new NamedParameterSpec(name);\n+        }\n+    }\n+\n+    private static KeyPairGenerator getKeyPairGenerator(String name) throws\n+            NoSuchAlgorithmException {\n+        if (APS.isGenericEC(name)) {\n+            name = \"EC\";\n+        }\n+        return KeyPairGenerator.getInstance(name);\n+    }\n+\n+    private static KeyFactory getKeyFactory(String name) throws\n+            NoSuchAlgorithmException {\n+        if (APS.isGenericEC(name)) {\n+            name = \"EC\";\n+        }\n+        return KeyFactory.getInstance(name);\n+    }\n+\n+    \/**\n+     * Returns a KEM instance for each side of the hybrid algorithm.\n+     * For traditional key exchange algorithms, we use the DH-based KEM\n+     * implementation provided by DH.PROVIDER.\n+     * For ML-KEM post-quantum algorithms, we obtain a KEM instance\n+     * using the given algorithm name.\n+     *\/\n+    private static KEM getKEM(String name) throws NoSuchAlgorithmException {\n+        if (APS.isGenericEC(name) || APS.isXDH(name)) {\n+            return KEM.getInstance(\"DH\", DH.PROVIDER);\n+        } else {\n+            return KEM.getInstance(name);\n+        }\n+    }\n+\n+    public static class KeyPairGeneratorImpl extends KeyPairGeneratorSpi {\n+        private final KeyPairGenerator left;\n+        private final KeyPairGenerator right;\n+        private final AlgorithmParameterSpec leftSpec;\n+        private final AlgorithmParameterSpec rightSpec;\n+\n+        public KeyPairGeneratorImpl(String leftAlg, String rightAlg)\n+                throws NoSuchAlgorithmException  {\n+            left = getKeyPairGenerator(leftAlg);\n+            right = getKeyPairGenerator(rightAlg);\n+            leftSpec = getSpec(leftAlg);\n+            rightSpec = getSpec(rightAlg);\n+\n+            try {\n+                left.initialize(leftSpec);\n+                right.initialize(rightSpec);\n+            } catch (InvalidAlgorithmParameterException iape) {\n+                throw new ProviderException(\"Invalid algorithm parameters \" +\n+                        \"for hybrid keypair generator\", iape);\n+            } catch (Exception e) {\n+                throw new ProviderException(\"Failed to initialize hybrid \" +\n+                        \"keypair generator\", e);\n+            }\n+        }\n+\n+        @Override\n+        public void initialize(int keysize, SecureRandom random) {\n+            try {\n+                left.initialize(leftSpec, random);\n+                right.initialize(rightSpec, random);\n+            } catch (InvalidParameterException ipe) {\n+                throw ipe;\n+            } catch (Exception e) {\n+                throw new ProviderException(\"Failed to initialize hybrid \" +\n+                        \"keypair generator\", e);\n+            }\n+        }\n+\n+        @Override\n+        public KeyPair generateKeyPair() {\n+            var kp1 = left.generateKeyPair();\n+            var kp2 = right.generateKeyPair();\n+            return new KeyPair(\n+                    new PublicKeyImpl(\"Hybrid\", kp1.getPublic(), kp2.getPublic()),\n+                    new PrivateKeyImpl(\"Hybrid\", kp1.getPrivate(), kp2.getPrivate()));\n+        }\n+    }\n+\n+    public static class KeyFactoryImpl extends KeyFactorySpi {\n+        private final KeyFactory left;\n+        private final KeyFactory right;\n+        private final int leftlen;\n+        private final String leftname;\n+        private final String rightname;\n+\n+        public KeyFactoryImpl(String left, String right)\n+                throws NoSuchAlgorithmException {\n+            this.left = getKeyFactory(left);\n+            this.right = getKeyFactory(right);\n+            this.leftlen = leftPublicLength(left);\n+            this.leftname = left;\n+            this.rightname = right;\n+        }\n+\n+        @Override\n+        protected PublicKey engineGeneratePublic(KeySpec keySpec)\n+                throws InvalidKeySpecException {\n+            if (keySpec == null) {\n+                throw new InvalidKeySpecException(\"keySpec must not be null\");\n+            }\n+\n+            if (keySpec instanceof RawKeySpec rks) {\n+                byte[] key = rks.getKeyArr();\n+                if (key == null) {\n+                    throw new InvalidKeySpecException(\n+                            \"RawkeySpec contains null key data\");\n+                }\n+                if (key.length <= leftlen) {\n+                    throw new InvalidKeySpecException(\n+                            \"Hybrid key length \" + key.length +\n+                            \" is too short and its left key length is \" +\n+                            leftlen);\n+                }\n+\n+                byte[] leftKeyBytes = Arrays.copyOfRange(key, 0, leftlen);\n+                byte[] rightKeyBytes = Arrays.copyOfRange(key, leftlen,\n+                        key.length);\n+                PublicKey leftKey, rightKey;\n+\n+                try {\n+                    if (APS.isGenericEC(leftname)) {\n+                        var curve = CurveDB.lookup(leftname);\n+                        var ecSpec = new ECPublicKeySpec(\n+                                ECUtil.decodePoint(leftKeyBytes,\n+                                curve.getCurve()), curve);\n+                        leftKey = left.generatePublic(ecSpec);\n+                    } else if (leftname.startsWith(\"ML-KEM\")) {\n+                        try {\n+                            leftKey = left.generatePublic(new RawKeySpec(\n+                                    leftKeyBytes));\n+                        } catch (Exception e) {\n+                            leftKey = left.generatePublic(new X509EncodedKeySpec(\n+                                    leftKeyBytes));\n+                        }\n+                    } else {\n+                        throw new InvalidKeySpecException(\"Unsupported left\" +\n+                                \" algorithm\" + leftname);\n+                    }\n+\n+                    if (APS.isXDH(rightname)) {\n+                        ArrayUtil.reverse(rightKeyBytes);\n+                        var xecSpec = new XECPublicKeySpec(\n+                                new NamedParameterSpec(rightname),\n+                                new BigInteger(1, rightKeyBytes));\n+                        rightKey = right.generatePublic(xecSpec);\n+                    } else if (rightname.startsWith(\"ML-KEM\")) {\n+                        try {\n+                            rightKey = right.generatePublic(new RawKeySpec(\n+                                    rightKeyBytes));\n+                        } catch (Exception e) {\n+                            rightKey = right.generatePublic(new X509EncodedKeySpec(\n+                                    rightKeyBytes));\n+                        }\n+                    } else {\n+                        throw new InvalidKeySpecException(\"Unsupported right\" +\n+                                \" algorithm: \" + rightname);\n+                    }\n+\n+                    return new PublicKeyImpl(\"Hybrid\", leftKey, rightKey);\n+                } catch (Exception e) {\n+                    throw new InvalidKeySpecException(\"Failed to decode hybrid\" +\n+                            \" key\", e);\n+                }\n+            }\n+\n+            throw new InvalidKeySpecException(\n+                    keySpec.getClass().getName() + \" not supported\");\n+        }\n+\n+        private static int leftPublicLength(String name) {\n+            return switch (name.toLowerCase(Locale.ROOT)) {\n+                case \"secp256r1\" -> 65;\n+                case \"secp384r1\" -> 97;\n+                case \"ml-kem-768\" -> 1184;\n+                default -> throw new IllegalArgumentException(\n+                        \"Unknown named group: \" + name);\n+            };\n+        }\n+\n+        @Override\n+        protected PrivateKey engineGeneratePrivate(KeySpec keySpec) throws\n+                InvalidKeySpecException {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected <T extends KeySpec> T engineGetKeySpec(Key key, Class<T> keySpec)\n+                throws InvalidKeySpecException {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected Key engineTranslateKey(Key key) throws InvalidKeyException {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public static class KEMImpl implements KEMSpi {\n+        private final KEM left;\n+        private final KEM right;\n+\n+        public KEMImpl(String left, String right) throws NoSuchAlgorithmException {\n+            this.left = getKEM(left);\n+            this.right = getKEM(right);\n+        }\n+\n+        @Override\n+        public EncapsulatorSpi engineNewEncapsulator(PublicKey publicKey,\n+                AlgorithmParameterSpec spec, SecureRandom secureRandom) throws\n+                InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (publicKey instanceof PublicKeyImpl pk) {\n+                return new Handler(left.newEncapsulator(pk.left, secureRandom),\n+                        right.newEncapsulator(pk.right, secureRandom), null, null);\n+            }\n+            throw new InvalidKeyException();\n+        }\n+\n+        @Override\n+        public DecapsulatorSpi engineNewDecapsulator(PrivateKey privateKey,\n+                AlgorithmParameterSpec spec) throws InvalidAlgorithmParameterException,\n+                InvalidKeyException {\n+            if (privateKey instanceof PrivateKeyImpl pk) {\n+                return new Handler(null, null, left.newDecapsulator(pk.left),\n+                        right.newDecapsulator(pk.right));\n+            }\n+            throw new InvalidKeyException();\n+        }\n+    }\n+\n+    private static byte[] concat(byte[]... inputs) {\n+        int outLen = 0;\n+        for (byte[] in : inputs) {\n+            outLen += in.length;\n+        }\n+        byte[] out = new byte[outLen];\n+        int pos = 0;\n+        for (byte[] in : inputs) {\n+            System.arraycopy(in, 0, out, pos, in.length);\n+            pos += in.length;\n+        }\n+        return out;\n+    }\n+\n+    private record Handler(KEM.Encapsulator le, KEM.Encapsulator re,\n+            KEM.Decapsulator ld, KEM.Decapsulator rd)\n+            implements KEMSpi.EncapsulatorSpi, KEMSpi.DecapsulatorSpi {\n+        @Override\n+        public KEM.Encapsulated engineEncapsulate(int from, int to,\n+                String algorithm) {\n+            var left = le.encapsulate();\n+            var right = re.encapsulate();\n+            if (from == 0 && to == le.secretSize() + re.secretSize()) {\n+                return new KEM.Encapsulated(\n+                        new SecretKeyImpl(left.key(), right.key()),\n+                        concat(left.encapsulation(), right.encapsulation()),\n+                        null);\n+            } else {\n+                throw new IllegalArgumentException(\n+                        \"Invalid range for encapsulation: from = \" + from +\n+                        \" to = \" + to + \", expected total secret size = \" +\n+                        (le.secretSize() + re.secretSize()));\n+            }\n+        }\n+\n+        @Override\n+        public int engineSecretSize() {\n+            if (le != null) {\n+                return le.secretSize() + re.secretSize();\n+            } else {\n+                return ld.secretSize() + rd.secretSize();\n+            }\n+        }\n+\n+        @Override\n+        public int engineEncapsulationSize() {\n+            if (le != null) {\n+                return le.encapsulationSize() + re.encapsulationSize();\n+            } else {\n+                return ld.encapsulationSize() + rd.encapsulationSize();\n+            }\n+        }\n+\n+        @Override\n+        public SecretKey engineDecapsulate(byte[] encapsulation, int from,\n+                int to, String algorithm) throws DecapsulateException {\n+            var left = Arrays.copyOf(encapsulation, ld.encapsulationSize());\n+            var right = Arrays.copyOfRange(encapsulation, ld.encapsulationSize(),\n+                    encapsulation.length);\n+            if (from == 0 && ld.secretSize() + rd.secretSize() == to) {\n+                return new SecretKeyImpl(ld.decapsulate(left),\n+                        rd.decapsulate(right));\n+            } else {\n+                throw new IllegalArgumentException(\n+                        \"Invalid range for decapsulation: from = \" + from +\n+                        \" to = \" + to + \", expected total secret size = \" +\n+                        (ld.secretSize() + rd.secretSize()));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Hybrid public key combines two underlying public keys (left and right).\n+     * Public keys can be transmitted\/encoded because the hybrid protocol\n+     * requires the public component to be sent.\n+     *\/\n+    public record PublicKeyImpl(String algorithm, PublicKey left,\n+            PublicKey right) implements PublicKey {\n+        @Override\n+        public String getAlgorithm() {\n+            return algorithm;\n+        }\n+\n+        \/\/ getFormat() returns \"RAW\" if both keys are X509Key; otherwise null.\n+        @Override\n+        public String getFormat() {\n+            if (left instanceof X509Key && right instanceof X509Key) {\n+                return \"RAW\";\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        \/\/ getEncoded() returns the concatenation of the encoded bytes of the\n+        \/\/ left and right public keys only if both are X509Key types.\n+        @Override\n+        public byte[] getEncoded() {\n+            if (left instanceof X509Key xk1 && right instanceof X509Key xk2) {\n+                return concat(xk1.getKeyAsBytes(), xk2.getKeyAsBytes());\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Hybrid private key combines two underlying private keys (left and right).\n+     * It is for internal use only. The private keys should never be exported.\n+     *\/\n+    public record PrivateKeyImpl(String algorithm, PrivateKey left,\n+            PrivateKey right) implements PrivateKey {\n+\n+        @Override\n+        public String getAlgorithm() {\n+            return algorithm;\n+        }\n+\n+        \/\/ getFormat() returns null because there is no standard\n+        \/\/ format for a hybrid private key.\n+        @Override\n+        public String getFormat() {\n+            return null;\n+        }\n+\n+        \/\/ getEncoded() returns an empty byte array because there is no\n+        \/\/ standard encoding format for a hybrid private key.\n+        @Override\n+        public byte[] getEncoded() {\n+            return new byte[0];\n+        }\n+    }\n+\n+    private static final class APS {\n+        static boolean isGenericEC(String name) {\n+            return name != null && name.startsWith(\"secp\");\n+        }\n+\n+        static boolean isXDH(String name) {\n+            return name != null && name.equals(\"X25519\");\n+        }\n+    }\n+\n+    public static final NamedParameterSpec X25519_MLKEM768 =\n+            new NamedParameterSpec(\"X25519MLKEM768\");\n+\n+    public static final NamedParameterSpec SECP256R1_MLKEM768 =\n+            new NamedParameterSpec(\"SecP256r1MLKEM768\");\n+\n+    public static final NamedParameterSpec SECP384R1_MLKEM1024 =\n+            new NamedParameterSpec(\"SecP384r1MLKEM1024\");\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Hybrid.java","additions":462,"deletions":0,"binary":false,"changes":462,"status":"added"},{"patch":"@@ -107,0 +107,4 @@\n+    public byte[] getKeyAsBytes() {\n+        return bitStringKey.toByteArray();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509Key.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +30,1 @@\n- * @bug 8281236\n+ * @bug 8281236 8314323\n@@ -139,0 +140,54 @@\n+\n+        runTest(new String[] {\n+                        \"X25519MLKEM768\"\n+                },\n+                new String[] {\n+                        \"X25519MLKEM768\"\n+                },\n+                false);\n+\n+        runTest(new String[] {\n+                        \"SecP256r1MLKEM768\"\n+                },\n+                new String[] {\n+                        \"SecP256r1MLKEM768\"\n+                },\n+                false);\n+\n+        runTest(new String[] {\n+                        \"SecP384r1MLKEM1024\"\n+                },\n+                new String[] {\n+                        \"SecP384r1MLKEM1024\"\n+                },\n+                false);\n+\n+        runTest(new String[] {\n+                        \"X25519MLKEM768\"\n+                },\n+                new String[] {\n+                        \"SecP256r1MLKEM768\"\n+                },\n+                true);\n+\n+        runTest(new String[] {\n+                        \"X25519MLKEM768\"\n+                },\n+                new String[0],\n+                true);\n+\n+        runTest(new String[] {\n+                        \"SecP256r1MLKEM768\"\n+                },\n+                null,\n+                false);\n+\n+        runTest(new String[] {\n+                        \"X25519MLKEM768\",\n+                        \"x25519\"\n+                },\n+                new String[] {\n+                        \"X25519MLKEM768\",\n+                        \"x25519\"\n+                },\n+                false);\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/NamedGroups.java","additions":56,"deletions":1,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,5 @@\n-    FFDHE8192(\"ffdhe8192\");\n+    FFDHE8192(\"ffdhe8192\"),\n+\n+    X25519MLKEM768(\"X25519MLKEM768\"),\n+    SecP256r1MLKEM768(\"SecP256r1MLKEM768\"),\n+    SecP384r1MLKEM1024(\"SecP384r1MLKEM1024\");\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/NamedGroup.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8247630\n+ * @bug 8247630 8314323\n@@ -32,1 +32,1 @@\n- * @run main\/othervm ClientHelloKeyShares 29 23\n+ * @run main\/othervm ClientHelloKeyShares 4588 29\n@@ -39,1 +39,6 @@\n- *\/\n+ * @run main\/othervm -Djdk.tls.namedGroups=X25519MLKEM768 ClientHelloKeyShares 4588\n+ * @run main\/othervm -Djdk.tls.namedGroups=x25519,X25519MLKEM768 ClientHelloKeyShares 29 4588\n+ * @run main\/othervm -Djdk.tls.namedGroups=SecP256r1MLKEM768,x25519 ClientHelloKeyShares 4587 29\n+ * @run main\/othervm -Djdk.tls.namedGroups=SecP384r1MLKEM1024,secp256r1 ClientHelloKeyShares 4589 23\n+ * @run main\/othervm -Djdk.tls.namedGroups=X25519MLKEM768,SecP256r1MLKEM768,X25519,secp256r1 ClientHelloKeyShares 4588 29\n+*\/\n@@ -55,4 +60,0 @@\n-    private static final int NG_SECP256R1 = 0x0017;\n-    private static final int NG_SECP384R1 = 0x0018;\n-    private static final int NG_X25519 = 0x001D;\n-    private static final int NG_X448 = 0x001E;\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv13\/ClientHelloKeyShares.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8247630\n+ * @bug 8247630 8314323\n@@ -33,1 +33,1 @@\n- * @run main\/othervm -Djdk.tls.namedGroups=x25519,secp256r1,secp384r1 HRRKeyShares\n+ * @run main\/othervm -Djdk.tls.namedGroups=x25519,secp256r1,secp384r1,X25519MLKEM768,SecP256r1MLKEM768,SecP384r1MLKEM1024 HRRKeyShares\n@@ -66,0 +66,4 @@\n+    private static final int NG_X25519_MLKEM768 = 0x11EC;\n+    private static final int NG_SECP256R1_MLKEM768 = 0x11EB;\n+    private static final int NG_SECP384R1_MLKEM1024 = 0x11ED;\n+\n@@ -227,0 +231,12 @@\n+\n+        System.out.println(\"Test 5: Good HRR exchange using X25519MLKEM768\");\n+        hrrKeyShareTest(NG_X25519_MLKEM768, true);\n+        System.out.println();\n+\n+        System.out.println(\"Test 6: Good HRR exchange using SecP256r1MLKEM768\");\n+        hrrKeyShareTest(NG_SECP256R1_MLKEM768, true);\n+        System.out.println();\n+\n+        System.out.println(\"Test 7: Good HRR exchange using SecP384r1MLKEM1024\");\n+        hrrKeyShareTest(NG_SECP384R1_MLKEM1024, true);\n+        System.out.println();\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv13\/HRRKeyShares.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run main\/othervm\/timeout=120 -Djdk.tls.client.protocols=TLSv1.3 FipsModeTLS\n+ * @run main\/othervm\/timeout=120 -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.namedGroups=x25519,secp256r1,secp384r1,secp521r1,x448,ffdhe2048,ffdhe3072,ffdhe4096,ffdhe6144,ffdhe8192 FipsModeTLS\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/fips\/FipsModeTLS.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8246330\n+ * @bug 8246330 8314323\n@@ -32,0 +32,12 @@\n+ * @run main\/othervm -Djdk.tls.namedGroups=\"X25519MLKEM768\"\n+        DisabledCurve DISABLE_NONE PASS\n+ * @run main\/othervm -Djdk.tls.namedGroups=\"X25519MLKEM768\"\n+        DisabledCurve X25519MLKEM768 FAIL\n+ * @run main\/othervm -Djdk.tls.namedGroups=\"SecP256r1MLKEM768\"\n+        DisabledCurve DISABLE_NONE PASS\n+ * @run main\/othervm -Djdk.tls.namedGroups=\"SecP256r1MLKEM768\"\n+        DisabledCurve SecP256r1MLKEM768 FAIL\n+ * @run main\/othervm -Djdk.tls.namedGroups=\"SecP384r1MLKEM1024\"\n+        DisabledCurve DISABLE_NONE PASS\n+ * @run main\/othervm -Djdk.tls.namedGroups=\"SecP384r1MLKEM1024\"\n+        DisabledCurve SecP384r1MLKEM1024 FAIL\n@@ -48,2 +60,4 @@\n-            { { \"TLSv1.2\" }, { \"TLSv1.2\" } }, { { \"TLSv1.1\" }, { \"TLSv1.1\" } },\n-            { { \"TLSv1\" }, { \"TLSv1\" } } };\n+            { { \"TLSv1.2\" }, { \"TLSv1.2\" } },\n+            { { \"TLSv1.1\" }, { \"TLSv1.1\" } },\n+            { { \"TLSv1\" }, { \"TLSv1\" } },\n+            { { \"TLSv1.3\" }, { \"TLSv1.3\" } } };\n@@ -97,1 +111,2 @@\n-        if (disabledName.equals(\"\")) {\n+\n+        if (disabledName.isEmpty()) {\n@@ -99,0 +114,1 @@\n+            Security.setProperty(\"jdk.certpath.disabledAlgorithms\", \"\");\n@@ -101,1 +117,6 @@\n-            Security.setProperty(\"jdk.certpath.disabledAlgorithms\", \"secp384r1\");\n+            Security.setProperty(\"jdk.certpath.disabledAlgorithms\", disabledName);\n+            if (!disabledName.contains(\"MLKEM\")) {\n+                Security.setProperty(\"jdk.disabled.namedCurves\", disabledName);\n+            } else {\n+                Security.setProperty(\"jdk.disabled.namedCurves\", \"\");\n+            }\n@@ -107,0 +128,3 @@\n+        String namedGroups = System.getProperty(\"jdk.tls.namedGroups\", \"\");\n+        boolean hybridGroup = namedGroups.contains(\"MLKEM\");\n+\n@@ -108,0 +132,9 @@\n+            if (hybridGroup) {\n+                String[] clientProtos = protocols[index][0];\n+                String[] serverProtos = protocols[index][1];\n+\n+                if (!(isTLS13(clientProtos) && isTLS13(serverProtos))) {\n+                    continue;\n+                }\n+            }\n+\n@@ -126,0 +159,4 @@\n+\n+    private static boolean isTLS13(String[] protocols) {\n+        return protocols.length == 1 && \"TLSv1.3\".equals(protocols[0]);\n+    }\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/DisabledCurve.java","additions":43,"deletions":6,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import java.util.Arrays;\n@@ -32,1 +33,1 @@\n-  * @bug 8224650 8242929\n+  * @bug 8224650 8242929 8314323\n@@ -47,0 +48,3 @@\n+  * @run main\/othervm NamedGroupsWithCipherSuite X25519MLKEM768\n+  * @run main\/othervm NamedGroupsWithCipherSuite SecP256r1MLKEM768\n+  * @run main\/othervm NamedGroupsWithCipherSuite SecP384r1MLKEM1024\n@@ -80,0 +84,16 @@\n+    private static final String[] HYBRID_NAMEDGROUPS = {\n+            \"X25519MLKEM768\",\n+            \"SecP256r1MLKEM768\",\n+            \"SecP384r1MLKEM1024\"\n+    };\n+\n+    private static final Protocol[] HYBRID_PROTOCOL = new Protocol[] {\n+            Protocol.TLSV1_3\n+    };\n+\n+    private static final CipherSuite[] HYBRID_CIPHER_SUITES = new CipherSuite[] {\n+            CipherSuite.TLS_AES_128_GCM_SHA256,\n+            CipherSuite.TLS_AES_256_GCM_SHA384,\n+            CipherSuite.TLS_CHACHA20_POLY1305_SHA256\n+    };\n+\n@@ -154,4 +174,14 @@\n-        for (Protocol protocol : PROTOCOLS) {\n-            for (CipherSuite cipherSuite : CIPHER_SUITES) {\n-                \/\/ Named group converted to lower case just\n-                \/\/ to satisfy Test condition\n+        boolean hybridGroup = Arrays.asList(HYBRID_NAMEDGROUPS).\n+                contains(namedGroup);\n+        Protocol[] protocolList = hybridGroup ?\n+                HYBRID_PROTOCOL : PROTOCOLS;\n+        CipherSuite[] cipherList = hybridGroup ?\n+                HYBRID_CIPHER_SUITES : CIPHER_SUITES;\n+\n+        \/\/ non-Hybrid named group converted to lower case just\n+        \/\/ to satisfy Test condition\n+        String normalizedGroup = hybridGroup ?\n+                namedGroup : namedGroup.toLowerCase();\n+\n+        for (Protocol protocol : protocolList) {\n+            for (CipherSuite cipherSuite : cipherList) {\n@@ -159,2 +189,2 @@\n-                        && groupSupportdByCipher(namedGroup.toLowerCase(),\n-                                cipherSuite)) {\n+                        && groupSupportdByCipher(normalizedGroup,\n+                        cipherSuite)) {\n@@ -163,2 +193,0 @@\n-                    \/\/ Named group converted to lower case just\n-                    \/\/ to satisfy Test condition\n@@ -166,1 +194,1 @@\n-                            cipherSuite, namedGroup.toLowerCase()).run();\n+                            cipherSuite, normalizedGroup).run();\n@@ -174,0 +202,4 @@\n+        if (Arrays.asList(HYBRID_NAMEDGROUPS).contains(group)) {\n+            return cipherSuite.keyExAlgorithm == null;\n+        }\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/NamedGroupsWithCipherSuite.java","additions":43,"deletions":11,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8226374 8242929\n+ * @bug 8226374 8242929 8314323\n@@ -39,0 +39,3 @@\n+ * @run main\/othervm RestrictNamedGroup X25519MLKEM768\n+ * @run main\/othervm RestrictNamedGroup SecP256r1MLKEM768\n+ * @run main\/othervm RestrictNamedGroup SecP384r1MLKEM1024\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/RestrictNamedGroup.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-  * @bug 8171279\n+  * @bug 8171279 8314323\n@@ -39,0 +39,3 @@\n+  * @run main\/othervm SupportedGroups X25519MLKEM768\n+  * @run main\/othervm SupportedGroups SecP256r1MLKEM768\n+  * @run main\/othervm SupportedGroups SecP384r1MLKEM1024\n@@ -48,1 +51,1 @@\n-    private static final String[][][] protocols = {\n+    private static final String[][][] protocolForClassic = {\n@@ -55,1 +58,9 @@\n-    public SupportedGroups() {\n+    private static final String[][][] protocolForHybrid = {\n+            {{\"TLSv1.3\"}, {\"TLSv1.3\"}},\n+            {{\"TLSv1.3\", \"TLSv1.2\"}, {\"TLSv1.3\"}},\n+            {{\"TLSv1.3\"}, {\"TLSv1.3\", \"TLSv1.2\"}}\n+    };\n+\n+    private final String[][][] protocols;\n+\n+    public SupportedGroups(String[][][] protocols) {\n@@ -57,0 +68,1 @@\n+        this.protocols = protocols;\n@@ -88,0 +100,3 @@\n+        boolean hybridGroup = hybridNamedGroup(args[0]);\n+        String[][][] protocols = hybridGroup ? protocolForHybrid : protocolForClassic;\n+\n@@ -89,1 +104,1 @@\n-            (new SupportedGroups()).run();\n+            (new SupportedGroups(protocols)).run();\n@@ -92,0 +107,6 @@\n+\n+    private static boolean hybridNamedGroup(String namedGroup) {\n+        return namedGroup.equals(\"X25519MLKEM768\") ||\n+                namedGroup.equals(\"SecP256r1MLKEM768\") ||\n+                namedGroup.equals(\"SecP384r1MLKEM1024\");\n+    }\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/SupportedGroups.java","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import javax.net.ssl.SSLParameters;\n@@ -78,2 +79,9 @@\n-    @Param({\"TLSv1.2\", \"TLS\"})\n-    String tlsVersion;\n+    @Param({\n+            \"TLSv1.2-secp256r1\",\n+            \"TLSv1.3-x25519\", \"TLSv1.3-secp256r1\", \"TLSv1.3-secp384r1\",\n+            \"TLSv1.3-X25519MLKEM768\", \"TLSv1.3-SecP256r1MLKEM768\", \"TLSv1.3-SecP384r1MLKEM1024\"\n+    })\n+    String versionAndGroup;\n+\n+    private String tlsVersion;\n+    private String namedGroup;\n@@ -99,0 +107,4 @@\n+        String[] components = versionAndGroup.split(\"-\", 2);\n+        tlsVersion = components[0];\n+        namedGroup = components[1];\n+\n@@ -198,0 +210,9 @@\n+\n+        \/\/ Set the key exchange named group in client and server engines\n+        SSLParameters clientParams = clientEngine.getSSLParameters();\n+        clientParams.setNamedGroups(new String[]{namedGroup});\n+        clientEngine.setSSLParameters(clientParams);\n+\n+        SSLParameters serverParams = serverEngine.getSSLParameters();\n+        serverParams.setNamedGroups(new String[]{namedGroup});\n+        serverEngine.setSSLParameters(serverParams);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SSLHandshake.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import org.openjdk.jmh.annotations.Fork;\n@@ -32,0 +33,2 @@\n+import java.security.GeneralSecurityException;\n+import java.security.InvalidAlgorithmParameterException;\n@@ -37,0 +40,3 @@\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.ECGenParameterSpec;\n@@ -45,0 +51,3 @@\n+    @Param({\"\"})        \/\/ Used when the KeyPairGenerator Alg != KEM Alg\n+    private String kpgSpec;\n+\n@@ -51,1 +60,4 @@\n-    public void setup() throws NoSuchAlgorithmException, InvalidKeyException {\n+    public void setup() throws NoSuchAlgorithmException, InvalidKeyException,\n+            InvalidAlgorithmParameterException {\n+        String kpgAlg;\n+        String kpgParams;\n@@ -53,1 +65,17 @@\n-        KeyPairGenerator generator = (prov == null) ? KeyPairGenerator.getInstance(algorithm) : KeyPairGenerator.getInstance(algorithm, prov);\n+\n+        Provider kpgProv = prov;    \/\/ By default use the same provider for KEM and KPG\n+        if (kpgSpec.isEmpty()) {\n+            kpgAlg = algorithm;\n+            kpgParams = \"\";\n+        } else {\n+            String[] kpgTok = kpgSpec.split(\":\");\n+            kpgProv = Security.getProvider(kpgTok[0]); \/\/ kpgTok[0] = provider name\n+            kpgAlg = kpgTok[1];\n+            kpgParams = kpgTok[2];\n+        }\n+        KeyPairGenerator generator = (kpgProv == null) ?\n+                    KeyPairGenerator.getInstance(kpgAlg) :\n+                    KeyPairGenerator.getInstance(kpgAlg, kpgProv);\n+        if (kpgParams != null && !kpgParams.isEmpty()) {\n+            generator.initialize(new ECGenParameterSpec(kpgParams));\n+        }\n@@ -66,0 +94,9 @@\n+    protected static Provider getInternalJce() {\n+        try {\n+            Class<?> dhClazz = Class.forName(\"com.sun.crypto.provider.DH\");\n+            return (Provider) (dhClazz.getField(\"PROVIDER\").get(null));\n+        } catch (ReflectiveOperationException exc) {\n+            throw new RuntimeException(exc);\n+        }\n+    }\n+\n@@ -82,0 +119,45 @@\n+    public static class MLKEM extends KEMBench {\n+        @Param({\"ML-KEM-512\", \"ML-KEM-768\", \"ML-KEM-1024\" })\n+        private String algorithm;\n+\n+        @Param({\"\"})            \/\/ ML-KEM uses the same alg for KPG and KEM\n+        private String kpgSpec;\n+    }\n+\n+    @Fork(value = 5, jvmArgs = {\"-XX:+AlwaysPreTouch\", \"--add-opens\", \"java.base\/com.sun.crypto.provider=ALL-UNNAMED\"})\n+    public static class InternalDH extends KEMBench {\n+        @Setup\n+        public void init() {\n+            try {\n+                prov = getInternalJce();\n+                super.setup();\n+            } catch (GeneralSecurityException gse) {\n+                throw new RuntimeException(gse);\n+            }\n+        }\n+\n+        @Param({\"DH\"})\n+        private String algorithm;\n+\n+        @Param({\"SunEC:XDH:x25519\", \"SunEC:EC:secp256r1\", \"SunEC:EC:secp384r1\"})\n+        private String kpgSpec;\n+    }\n+\n+    @Fork(value = 5, jvmArgs = {\"-XX:+AlwaysPreTouch\", \"--add-opens\", \"java.base\/com.sun.crypto.provider=ALL-UNNAMED\"})\n+    public static class Hybrid extends KEMBench {\n+        @Setup\n+        public void init() {\n+            try {\n+                prov = getInternalJce();\n+                super.setup();\n+            } catch (GeneralSecurityException gse) {\n+                throw new RuntimeException(gse);\n+            }\n+        }\n+\n+        @Param({\"X25519MLKEM768\", \"SecP256r1MLKEM768\", \"SecP384r1MLKEM1024\"})\n+        private String algorithm;\n+\n+        @Param({\"\"})            \/\/ ML-KEM uses the same alg for KPG and KEM\n+        private String kpgSpec;\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/KEMBench.java","additions":84,"deletions":2,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import org.openjdk.jmh.annotations.Fork;\n@@ -29,0 +30,1 @@\n+import java.security.GeneralSecurityException;\n@@ -32,0 +34,1 @@\n+import java.security.Provider;\n@@ -53,0 +56,9 @@\n+    protected static Provider getInternalJce() {\n+        try {\n+            Class<?> dhClazz = Class.forName(\"com.sun.crypto.provider.DH\");\n+            return (Provider) (dhClazz.getField(\"PROVIDER\").get(null));\n+        } catch (ReflectiveOperationException exc) {\n+            throw new RuntimeException(exc);\n+        }\n+    }\n+\n@@ -121,0 +133,18 @@\n+    @Fork(value = 5, jvmArgs = {\"-XX:+AlwaysPreTouch\", \"--add-opens\", \"java.base\/com.sun.crypto.provider=ALL-UNNAMED\"})\n+    public static class Hybrid extends KeyPairGeneratorBench {\n+        @Setup\n+        public void init() {\n+            try {\n+                prov = getInternalJce();\n+                super.setup();\n+            } catch (GeneralSecurityException gse) {\n+                throw new RuntimeException(gse);\n+            }\n+        }\n+\n+        @Param({\"X25519MLKEM768\", \"SecP256r1MLKEM768\", \"SecP384r1MLKEM1024\"})\n+        private String algorithm;\n+\n+        @Param({\"0\"})       \/\/ Hybrid KPGs don't need key lengths\n+        private int keyLength;\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/KeyPairGeneratorBench.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"}]}