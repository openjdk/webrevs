{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,2 @@\n-\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -29,2 +30,0 @@\n-import java.nio.ByteBuffer;\n-\n@@ -34,0 +33,1 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n@@ -35,1 +35,1 @@\n-\/**\n+\/*\n@@ -37,2 +37,5 @@\n- * @bug 8007799 8176379\n- * @summary test Encoder with linemax == 0, line separator should not appear in encoded data\n+ * @bug 8007799 8176379 8331342\n+ * @summary Test that getting a Mime encoder where line length rounds down to 0\n+ *          produces a non line separated encoder (RFC 4648). Ensure correctness\n+ *          of encoded data with the retrieved encoder.\n+ * @run junit Base64GetEncoderTest\n@@ -43,10 +46,14 @@\n-    public static void main(String args[]) throws Throwable {\n-\n-        for (int maxlen = -4; maxlen < 4; maxlen++) {\n-\n-            final Base64.Encoder encoder = Base64.getMimeEncoder(maxlen, \"$$$\".getBytes(US_ASCII));\n-\n-            testEncodeToString(encoder);\n-            testWrapEncode1(encoder);\n-            testEncodeToStringWithLongInputData(encoder);\n-            testWrapEncode2(encoder);\n+    \/\/ Test data that contains a short and a long byte array\n+    private static final byte[][] TEST_INPUT =\n+            {\"foo\".getBytes(US_ASCII), \"quux\".repeat(21).getBytes(US_ASCII)};\n+    private static Base64.Encoder encoder;\n+\n+    \/\/ Retrieved encoder should not have line separators\n+    @ParameterizedTest\n+    @MethodSource(\"roundsToZeroOrSmaller\")\n+    public void getMimeEncoderTest(int lineLength) throws IOException {\n+        encoder = Base64.getMimeEncoder(lineLength, \"$$$\".getBytes(US_ASCII));\n+        \/\/ Test correctness of encoder\n+        for (byte[] data : TEST_INPUT) {\n+            encodeToStringTest(data);\n+            wrapTest(data);\n@@ -56,23 +63,4 @@\n-    private static void testWrapEncode2(final Base64.Encoder encoder)\n-            throws IOException {\n-        System.err.println(\"\\nEncoder.wrap test II \");\n-        final byte[] secondTestBuffer =\n-                \"api\/java_util\/Base64\/index.html#GetEncoderMimeCustom[noLineSeparatorInEncodedString]\"\n-                .getBytes(US_ASCII);\n-        String base64EncodedString;\n-        ByteArrayOutputStream secondEncodingStream = new ByteArrayOutputStream();\n-        OutputStream base64EncodingStream = encoder.wrap(secondEncodingStream);\n-        base64EncodingStream.write(secondTestBuffer);\n-        base64EncodingStream.close();\n-\n-        final byte[] encodedByteArray = secondEncodingStream.toByteArray();\n-\n-        System.err.print(\"result = \" + new String(encodedByteArray, US_ASCII)\n-                + \"  after wrap Base64 encoding of string\");\n-\n-        base64EncodedString = new String(encodedByteArray, US_ASCII);\n-\n-        if (base64EncodedString.contains(\"$$$\")) {\n-            throw new RuntimeException(\n-                    \"Base64 encoding contains line separator after wrap 2 invoked  ... \\n\");\n-        }\n+    \/\/ Line lengths that when rounded down to the nearest multiple of 4,\n+    \/\/ should all produce lineLength <= 0\n+    private static int[] roundsToZeroOrSmaller() {\n+        return new int[]{-4, -3, -2, -1, 0, 1, 2, 3};\n@@ -81,20 +69,2 @@\n-    private static void testEncodeToStringWithLongInputData(\n-            final Base64.Encoder encoder) {\n-        System.err.println(\"\\n\\nEncoder.encodeToStringWithLongInputData test  \");\n-\n-        final byte[] secondTestBuffer =\n-                \"api\/java_util\/Base64\/index.html#GetEncoderMimeCustom[noLineSeparatorInEncodedString]\"\n-                .getBytes(US_ASCII);\n-        String base64EncodedString;\n-        base64EncodedString = encoder.encodeToString(secondTestBuffer);\n-\n-        System.err.println(\"Second Base64 encoded string is \"\n-                + base64EncodedString);\n-\n-        if (base64EncodedString.contains(\"$$$\")) {\n-            throw new RuntimeException(\n-                    \"Base64 encoding contains line separator after encodeToString invoked  ... \\n\");\n-        }\n-    }\n-\n-    private static void testWrapEncode1(final Base64.Encoder encoder)\n+    \/\/ Ensure correctness of the Encoder by testing Encoder.wrap\n+    private static void wrapTest(byte[] inputData)\n@@ -102,4 +72,0 @@\n-        System.err.println(\"\\nEncoder.wrap test I \");\n-\n-        final byte[] bytesIn = \"fo\".getBytes(US_ASCII);\n-        String base64EncodedString;\n@@ -108,1 +74,1 @@\n-        encoding.write(bytesIn);\n+        encoding.write(inputData);\n@@ -110,12 +76,3 @@\n-\n-        final byte[] encodedBytes = encodingStream.toByteArray();\n-\n-        System.err.print(\"result = \" + new String(encodedBytes, US_ASCII)\n-                + \"  after the Base64 encoding \\n\");\n-\n-        base64EncodedString = new String(encodedBytes, US_ASCII);\n-\n-        if (base64EncodedString.contains(\"$$$\")) {\n-            throw new RuntimeException(\n-                    \"Base64 encoding contains line separator after wrap I test ... \\n\");\n-        }\n+        String base64EncodedString = encodingStream.toString(US_ASCII);\n+        assertFalse(base64EncodedString.contains(\"$$$\"),\n+                failMessage(\"Encoder.wrap()\",  base64EncodedString, inputData));\n@@ -124,8 +81,6 @@\n-    private static void testEncodeToString(final Base64.Encoder encoder) {\n-        final byte[] bytesIn = \"fo\".getBytes(US_ASCII);\n-\n-        System.err.println(\"\\nEncoder.encodeToString test  \");\n-\n-        String base64EncodedString = encoder.encodeToString(bytesIn);\n-\n-        System.err.println(\"Base64 encoded string is \" + base64EncodedString);\n+    \/\/ Ensure correctness of the Encoder by testing Encoder.encodeToString\n+    private static void encodeToStringTest(byte[] inputData) {\n+        String base64EncodedString = encoder.encodeToString(inputData);\n+        assertFalse(base64EncodedString.contains(\"$$$\"),\n+                failMessage(\"Encoder.encodeToString()\", base64EncodedString, inputData));\n+    }\n@@ -133,3 +88,5 @@\n-        if (base64EncodedString.contains(\"$$$\")) {\n-            throw new RuntimeException(\"Base64 encoding contains line separator after Encoder.encodeToString invoked ... \\n\");\n-        }\n+    \/\/ Utility to produce a helpful error message\n+    private static String failMessage(String methodName, String encodedString, byte[] bytesIn) {\n+        return \"\\n%s incorrectly produced the String: \\\"%s\\\"\\n\".formatted(methodName, encodedString) +\n+                \"which has line separators. The input String was: \\\"%s\\\"\\n\".formatted(new String(bytesIn, US_ASCII)) +\n+                \"Ensure that getMimeEncoder() returned the correct encoder\";\n","filename":"test\/jdk\/java\/util\/Base64\/Base64GetEncoderTest.java","additions":45,"deletions":88,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -27,1 +27,1 @@\n- *      8014217 8025003 8026330 8028397 8129544 8165243 8176379 8222187\n+ *      8014217 8025003 8026330 8028397 8129544 8165243 8176379 8222187 8331342\n@@ -31,1 +31,1 @@\n- * @run main TestBase64\n+ * @run junit TestBase64\n@@ -41,0 +41,2 @@\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n@@ -46,0 +48,1 @@\n+import java.util.stream.Stream;\n@@ -48,0 +51,4 @@\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -49,88 +56,5 @@\n-public class TestBase64 {\n-\n-    private static final Random rnd = RandomFactory.getRandom();\n-\n-    public static void main(String args[]) throws Throwable {\n-        int numRuns  = 10;\n-        int numBytes = 200;\n-        if (args.length > 1) {\n-            numRuns  = Integer.parseInt(args[0]);\n-            numBytes = Integer.parseInt(args[1]);\n-        }\n-\n-        test(Base64.getEncoder(), Base64.getDecoder(), numRuns, numBytes);\n-        test(Base64.getUrlEncoder(), Base64.getUrlDecoder(), numRuns, numBytes);\n-        test(Base64.getMimeEncoder(), Base64.getMimeDecoder(), numRuns, numBytes);\n-\n-        byte[] nl_1 = new byte[] {'\\n'};\n-        byte[] nl_2 = new byte[] {'\\n', '\\r'};\n-        byte[] nl_3 = new byte[] {'\\n', '\\r', '\\n'};\n-        for (int i = 0; i < 10; i++) {\n-            int len = rnd.nextInt(200) + 4;\n-            test(Base64.getMimeEncoder(len, nl_1),\n-                 Base64.getMimeDecoder(),\n-                 numRuns, numBytes);\n-            test(Base64.getMimeEncoder(len, nl_2),\n-                 Base64.getMimeDecoder(),\n-                 numRuns, numBytes);\n-            test(Base64.getMimeEncoder(len, nl_3),\n-                 Base64.getMimeDecoder(),\n-                 numRuns, numBytes);\n-        }\n-\n-        \/\/ test mime case with < 4 length\n-        for (int len = 0; len < 4; len++) {\n-            test(Base64.getMimeEncoder(len, nl_1),\n-                 Base64.getMimeDecoder(),\n-                 numRuns, numBytes);\n-\n-            test(Base64.getMimeEncoder(len, nl_2),\n-                 Base64.getMimeDecoder(),\n-                 numRuns, numBytes);\n-\n-            test(Base64.getMimeEncoder(len, nl_3),\n-                 Base64.getMimeDecoder(),\n-                 numRuns, numBytes);\n-        }\n-\n-        testNull(Base64.getEncoder());\n-        testNull(Base64.getUrlEncoder());\n-        testNull(Base64.getMimeEncoder());\n-        testNull(Base64.getMimeEncoder(10, new byte[]{'\\n'}));\n-        testNull(Base64.getDecoder());\n-        testNull(Base64.getUrlDecoder());\n-        testNull(Base64.getMimeDecoder());\n-        checkNull(() -> Base64.getMimeEncoder(10, null));\n-\n-        testIOE(Base64.getEncoder());\n-        testIOE(Base64.getUrlEncoder());\n-        testIOE(Base64.getMimeEncoder());\n-        testIOE(Base64.getMimeEncoder(10, new byte[]{'\\n'}));\n-\n-        byte[] src = new byte[1024];\n-        rnd.nextBytes(src);\n-        final byte[] decoded = Base64.getEncoder().encode(src);\n-        testIOE(Base64.getDecoder(), decoded);\n-        testIOE(Base64.getMimeDecoder(), decoded);\n-        testIOE(Base64.getUrlDecoder(), Base64.getUrlEncoder().encode(src));\n-\n-        \/\/ illegal line separator\n-        checkIAE(() -> Base64.getMimeEncoder(10, new byte[]{'\\r', 'N'}));\n-\n-        \/\/ malformed padding\/ending\n-        testMalformedPadding();\n-\n-        \/\/ illegal base64 character\n-        decoded[2] = (byte)0xe0;\n-        checkIAE(() -> Base64.getDecoder().decode(decoded));\n-        checkIAE(() -> Base64.getDecoder().decode(decoded, new byte[1024]));\n-        checkIAE(() -> Base64.getDecoder().decode(ByteBuffer.wrap(decoded)));\n-\n-        \/\/ test single-non-base64 character for mime decoding\n-        testSingleNonBase64MimeDec();\n-\n-        \/\/ test decoding of unpadded data\n-        testDecodeUnpadded();\n-\n-        \/\/ test mime decoding with ignored character after padding\n-        testDecodeIgnoredAfterPadding();\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -138,14 +62,1 @@\n-        \/\/ given invalid args, encoder should not produce output\n-        testEncoderKeepsSilence(Base64.getEncoder());\n-        testEncoderKeepsSilence(Base64.getUrlEncoder());\n-        testEncoderKeepsSilence(Base64.getMimeEncoder());\n-\n-        \/\/ given invalid args, decoder should not consume input\n-        testDecoderKeepsAbstinence(Base64.getDecoder());\n-        testDecoderKeepsAbstinence(Base64.getUrlDecoder());\n-        testDecoderKeepsAbstinence(Base64.getMimeDecoder());\n-\n-        \/\/ tests patch addressing JDK-8222187\n-        \/\/ https:\/\/bugs.openjdk.org\/browse\/JDK-8222187\n-        testJDK_8222187();\n-    }\n+public class TestBase64 {\n@@ -153,2 +64,12 @@\n-    private static void test(Base64.Encoder enc, Base64.Decoder dec,\n-                             int numRuns, int numBytes) throws Throwable {\n+    \/\/ Utilize random to get int values and generate bytes in the arrays\n+    private static final Random RND = RandomFactory.getRandom();\n+    \/\/ We build some random values, so iterates multiple times to get more values\n+    private static final int ITERATIONS = 10;\n+    private static final int BYTES = 200;\n+    private static final Charset ASCII = StandardCharsets.US_ASCII;\n+\n+    \/\/ Check encoded\/decode behavior with associated encoder and decoder\n+    @ParameterizedTest\n+    @MethodSource(\"encodersAndDecoders\")\n+    public void encodeDecodeRoundTripTest(Base64.Encoder enc, Base64.Decoder dec)\n+            throws Throwable {\n@@ -162,2 +83,2 @@\n-            for (int i=0; i<numRuns; i++) {\n-                for (int j=1; j<numBytes; j++) {\n+            for (int i=0; i<ITERATIONS; i++) {\n+                for (int j=1; j<BYTES; j++) {\n@@ -165,1 +86,1 @@\n-                    rnd.nextBytes(orig);\n+                    RND.nextBytes(orig);\n@@ -171,1 +92,1 @@\n-                    checkEqual(orig, decoded,\n+                    assertArrayEquals(orig, decoded,\n@@ -174,3 +95,2 @@\n-                        if (encoded[encoded.length - 1] == '=')\n-                            throw new RuntimeException(\n-                               \"Base64 enc.encode().withoutPadding() has padding!\");\n+                        assertNotEquals('=', encoded[encoded.length - 1],\n+                                \"Base64 enc.encode().withoutPadding() has padding!\");\n@@ -180,2 +100,1 @@\n-                    if (!Arrays.equals(str.getBytes(\"ASCII\"), encoded)) {\n-                        throw new RuntimeException(\n+                    assertArrayEquals(encoded, str.getBytes(ASCII),\n@@ -183,3 +102,3 @@\n-                    }\n-                    byte[] buf = dec.decode(new String(encoded, \"ASCII\"));\n-                    checkEqual(buf, orig, \"Base64 decoding(String) failed!\");\n+\n+                    byte[] buf = dec.decode(new String(encoded, ASCII));\n+                    assertArrayEquals(buf, orig, \"Base64 decoding(String) failed!\");\n@@ -206,1 +125,1 @@\n-                        int n = rnd.nextInt(len);\n+                        int n = RND.nextInt(len);\n@@ -211,2 +130,1 @@\n-                            checkEqual(off, orig.length,\n-                                       \"Base64 stream decoding failed\");\n+                            assertEquals(off, orig.length, \"Base64 stream decoding failed\");\n@@ -221,1 +139,1 @@\n-                    checkEqual(buf, orig, \"Base64 stream decoding failed!\");\n+                    assertArrayEquals(buf, orig, \"Base64 stream decoding failed!\");\n@@ -233,1 +151,1 @@\n-                    checkEqual(buf, orig, \"Base64 stream decoding failed!\");\n+                    assertArrayEquals(buf, orig, \"Base64 stream decoding failed!\");\n@@ -243,1 +161,1 @@\n-                        int n = rnd.nextInt(len);\n+                        int n = RND.nextInt(len);\n@@ -254,1 +172,1 @@\n-                    checkEqual(buf, encoded, \"Base64 stream encoding failed!\");\n+                    assertArrayEquals(buf, encoded, \"Base64 stream encoding failed!\");\n@@ -265,1 +183,1 @@\n-                    checkEqual(buf, encoded, \"Base64 stream encoding failed!\");\n+                    assertArrayEquals(buf, encoded, \"Base64 stream encoding failed!\");\n@@ -268,1 +186,1 @@\n-                    buf = new byte[encoded.length + rnd.nextInt(100)];\n+                    buf = new byte[encoded.length + RND.nextInt(100)];\n@@ -270,1 +188,1 @@\n-                    checkEqual(ret, encoded.length,\n+                    assertEquals(ret, encoded.length,\n@@ -273,1 +191,1 @@\n-                    checkEqual(buf, encoded,\n+                    assertArrayEquals(buf, encoded,\n@@ -277,1 +195,1 @@\n-                    buf = new byte[orig.length + rnd.nextInt(100)];\n+                    buf = new byte[orig.length + RND.nextInt(100)];\n@@ -279,1 +197,1 @@\n-                    checkEqual(ret, orig.length,\n+                    assertEquals(ret, orig.length,\n@@ -282,1 +200,1 @@\n-                    checkEqual(buf, orig,\n+                    assertArrayEquals(buf, orig,\n@@ -294,7 +212,9 @@\n-    private static void testNull(Base64.Encoder enc) {\n-        checkNull(() -> enc.encode(ba_null));\n-        checkNull(() -> enc.encodeToString(ba_null));\n-        checkNull(() -> enc.encode(ba_null, new byte[10]));\n-        checkNull(() -> enc.encode(new byte[10], ba_null));\n-        checkNull(() -> enc.encode(bb_null));\n-        checkNull(() -> enc.wrap((OutputStream)null));\n+    @ParameterizedTest\n+    @MethodSource(\"encoders\")\n+    public void testNull(Base64.Encoder enc) {\n+        assertThrows(NullPointerException.class, () -> enc.encode(ba_null));\n+        assertThrows(NullPointerException.class, () -> enc.encodeToString(ba_null));\n+        assertThrows(NullPointerException.class, () -> enc.encode(ba_null, new byte[10]));\n+        assertThrows(NullPointerException.class, () -> enc.encode(new byte[10], ba_null));\n+        assertThrows(NullPointerException.class, () -> enc.encode(bb_null));\n+        assertThrows(NullPointerException.class, () -> enc.wrap((OutputStream)null));\n@@ -303,7 +223,5 @@\n-    private static void testNull(Base64.Decoder dec) {\n-        checkNull(() -> dec.decode(ba_null));\n-        checkNull(() -> dec.decode(str_null));\n-        checkNull(() -> dec.decode(ba_null, new byte[10]));\n-        checkNull(() -> dec.decode(new byte[10], ba_null));\n-        checkNull(() -> dec.decode(bb_null));\n-        checkNull(() -> dec.wrap((InputStream)null));\n+    \/\/ Ensure Mime throws IAE on null separator\n+    @Test\n+    public void getMimeNullSeparatorTest() {\n+        assertThrows(NullPointerException.class,\n+                () -> Base64.getMimeEncoder(10, null));\n@@ -312,3 +230,5 @@\n-    @FunctionalInterface\n-    private static interface Testable {\n-        public void test() throws Throwable;\n+    \/\/ Ensure Mime throws IAE on bad separator\n+    @Test\n+    public void getMimeIllegalSeparatorTest() {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> Base64.getMimeEncoder(10, new byte[]{'\\r', 'N'}));\n@@ -317,1 +237,29 @@\n-    private static void testIOE(Base64.Encoder enc) throws Throwable {\n+    \/\/ NPE tests\n+    @ParameterizedTest\n+    @MethodSource(\"decoders\")\n+    public void testNull(Base64.Decoder dec) {\n+        assertThrows(NullPointerException.class, () -> dec.decode(ba_null));\n+        assertThrows(NullPointerException.class, () -> dec.decode(str_null));\n+        assertThrows(NullPointerException.class, () -> dec.decode(ba_null, new byte[10]));\n+        assertThrows(NullPointerException.class, () -> dec.decode(new byte[10], ba_null));\n+        assertThrows(NullPointerException.class, () -> dec.decode(bb_null));\n+        assertThrows(NullPointerException.class, () -> dec.wrap((InputStream)null));\n+    }\n+\n+    \/\/ Ensure IAE thrown on illegal data\n+    @Test\n+    public void testIllegalDecoded() {\n+        byte[] src = new byte[1024];\n+        RND.nextBytes(src);\n+        final byte[] encoded = Base64.getEncoder().encode(src);\n+        encoded[2] = (byte)0xe0; \/\/ illegal char\n+        Base64.Decoder dec = Base64.getDecoder();\n+        assertThrows(IllegalArgumentException.class, () -> dec.decode(encoded));\n+        assertThrows(IllegalArgumentException.class, () -> dec.decode(encoded, new byte[1024]));\n+        assertThrows(IllegalArgumentException.class, () -> dec.decode(ByteBuffer.wrap(encoded)));\n+    }\n+\n+    \/\/ General tests to ensure IOException is thrown for encoders when stream closed\n+    @ParameterizedTest\n+    @MethodSource(\"encoders\")\n+    public void testIOE(Base64.Encoder enc) throws Throwable {\n@@ -322,3 +270,3 @@\n-        checkIOE(() -> os.write(10));\n-        checkIOE(() -> os.write(new byte[] {10}));\n-        checkIOE(() -> os.write(new byte[] {10}, 1, 4));\n+        assertThrows(IOException.class, () -> os.write(10));\n+        assertThrows(IOException.class, () -> os.write(new byte[] {10}));\n+        assertThrows(IOException.class, () -> os.write(new byte[] {10}, 1, 4));\n@@ -327,2 +275,5 @@\n-    private static void testIOE(Base64.Decoder dec, byte[] decoded) throws Throwable {\n-        ByteArrayInputStream bais = new ByteArrayInputStream(decoded);\n+    \/\/ General tests to ensure IOException is thrown for decoders when stream closed\n+    @ParameterizedTest\n+    @MethodSource(\"decodersWithEncoded\")\n+    public void testIOE(Base64.Decoder dec, byte[] encoded) throws Throwable {\n+        ByteArrayInputStream bais = new ByteArrayInputStream(encoded);\n@@ -332,19 +283,5 @@\n-        checkIOE(() -> is.read());\n-        checkIOE(() -> is.read(new byte[] {10}));\n-        checkIOE(() -> is.read(new byte[] {10}, 1, 4));\n-        checkIOE(() -> is.available());\n-        checkIOE(() -> is.skip(20));\n-    }\n-\n-    private static final void checkNull(Runnable r) {\n-        try {\n-            r.run();\n-            throw new RuntimeException(\"NPE is not thrown as expected\");\n-        } catch (NullPointerException npe) {}\n-    }\n-\n-    private static final void checkIOE(Testable t) throws Throwable {\n-        try {\n-            t.test();\n-            throw new RuntimeException(\"IOE is not thrown as expected\");\n-        } catch (IOException ioe) {}\n+        assertThrows(IOException.class, () -> is.read());\n+        assertThrows(IOException.class, () -> is.read(new byte[] {10}));\n+        assertThrows(IOException.class, () -> is.read(new byte[] {10}, 1, 4));\n+        assertThrows(IOException.class, () -> is.available());\n+        assertThrows(IOException.class, () -> is.skip(20));\n@@ -353,8 +290,3 @@\n-    private static final void checkIAE(Runnable r) throws Throwable {\n-        try {\n-            r.run();\n-            throw new RuntimeException(\"IAE is not thrown as expected\");\n-        } catch (IllegalArgumentException iae) {}\n-    }\n-\n-    private static void testDecodeIgnoredAfterPadding() throws Throwable {\n+    \/\/ test mime decoding with ignored character after padding\n+    @Test\n+    public void testDecodeIgnoredAfterPadding() {\n@@ -362,6 +294,6 @@\n-            byte[][] src = new byte[][] {\n-                \"A\".getBytes(\"ascii\"),\n-                \"AB\".getBytes(\"ascii\"),\n-                \"ABC\".getBytes(\"ascii\"),\n-                \"ABCD\".getBytes(\"ascii\"),\n-                \"ABCDE\".getBytes(\"ascii\")\n+            byte[][] src = new byte[][]{\n+                    \"A\".getBytes(ASCII),\n+                    \"AB\".getBytes(ASCII),\n+                    \"ABC\".getBytes(ASCII),\n+                    \"ABCD\".getBytes(ASCII),\n+                    \"ABCDE\".getBytes(ASCII)\n@@ -373,1 +305,1 @@\n-            for (int i = 0; i < src.length; i++) {\n+            for (byte[] bytes : src) {\n@@ -375,1 +307,1 @@\n-                byte[] encoded = encM.encode(src[i]);\n+                byte[] encoded = encM.encode(bytes);\n@@ -378,2 +310,2 @@\n-                checkEqual(decM.decode(encoded), src[i], \"Non-base64 char is not ignored\");\n-                byte[] decoded = new byte[src[i].length];\n+                assertArrayEquals(decM.decode(encoded), bytes, \"Non-base64 char is not ignored\");\n+                byte[] decoded = new byte[bytes.length];\n@@ -381,6 +313,3 @@\n-                checkEqual(decoded, src[i], \"Non-base64 char is not ignored\");\n-\n-                try {\n-                    dec.decode(encoded);\n-                    throw new RuntimeException(\"No IAE for non-base64 char\");\n-                } catch (IllegalArgumentException iae) {}\n+                assertArrayEquals(decoded, bytes, \"Non-base64 char is not ignored\");\n+                byte[] finalEncoded = encoded;\n+                assertThrows(IllegalArgumentException.class, () -> dec.decode(finalEncoded));\n@@ -391,1 +320,4 @@\n-    private static void testMalformedPadding() throws Throwable {\n+    \/\/ malformed padding\/ending\n+    @ParameterizedTest\n+    @MethodSource(\"decoders\")\n+    public void testMalformedPadding(Base64.Decoder dec) {\n@@ -412,0 +344,4 @@\n+        for (int i = 0; i < data.length; i += 3) {\n+            final String srcStr = (String) data[i];\n+            final byte[] srcBytes = srcStr.getBytes(ASCII);\n+            final ByteBuffer srcBB = ByteBuffer.wrap(srcBytes);\n@@ -413,16 +349,2 @@\n-        Base64.Decoder[] decs = new Base64.Decoder[] {\n-            Base64.getDecoder(),\n-            Base64.getUrlDecoder(),\n-            Base64.getMimeDecoder()\n-        };\n-\n-        for (Base64.Decoder dec : decs) {\n-            for (int i = 0; i < data.length; i += 3) {\n-                final String srcStr = (String)data[i];\n-                final byte[] srcBytes = srcStr.getBytes(\"ASCII\");\n-                final ByteBuffer srcBB = ByteBuffer.wrap(srcBytes);\n-                byte[] expected = ((String)data[i + 1]).getBytes(\"ASCII\");\n-                int pos = (Integer)data[i + 2];\n-\n-                \/\/ decode(byte[])\n-                checkIAE(() -> dec.decode(srcBytes));\n+            \/\/ decode(byte[])\n+            assertThrows(IllegalArgumentException.class, () -> dec.decode(srcBytes));\n@@ -430,2 +352,2 @@\n-                \/\/ decode(String)\n-                checkIAE(() -> dec.decode(srcStr));\n+            \/\/ decode(String)\n+            assertThrows(IllegalArgumentException.class, () -> dec.decode(srcStr));\n@@ -433,2 +355,2 @@\n-                \/\/ decode(ByteBuffer)\n-                checkIAE(() -> dec.decode(srcBB));\n+            \/\/ decode(ByteBuffer)\n+            assertThrows(IllegalArgumentException.class, () -> dec.decode(srcBB));\n@@ -436,8 +358,6 @@\n-                \/\/ wrap stream\n-                checkIOE(new Testable() {\n-                    public void test() throws IOException {\n-                        try (InputStream is = dec.wrap(new ByteArrayInputStream(srcBytes))) {\n-                            while (is.read() != -1);\n-                        }\n-                }});\n-            }\n+            \/\/ wrap stream\n+            assertThrows(IOException.class, () -> {\n+                try (InputStream is = dec.wrap(new ByteArrayInputStream(srcBytes))) {\n+                    while (is.read() != -1) ;\n+                }\n+            });\n@@ -447,4 +367,3 @@\n-        \/\/ not MIME. In case of MIME, non-base64 character(s)\n-        \/\/ is ignored.\n-        checkIAE(() -> Base64.getDecoder().decode(\"AA==\\u00D2\"));\n-        checkIAE(() -> Base64.getUrlDecoder().decode(\"AA==\\u00D2\"));\n+        \/\/ not MIME. In case of MIME, non-base64 character(s) is ignored.\n+        assertThrows(IllegalArgumentException.class, () -> Base64.getDecoder().decode(\"AA==\\u00D2\"));\n+        assertThrows(IllegalArgumentException.class, () -> Base64.getUrlDecoder().decode(\"AA==\\u00D2\"));\n@@ -454,1 +373,3 @@\n-    private static void  testDecodeUnpadded() throws Throwable {\n+    \/\/ test decoding of unpadded data\n+     @Test\n+     public void  testDecodeUnpadded() throws Throwable {\n@@ -459,2 +380,1 @@\n-        if (ret[0] != 'A')\n-            throw new RuntimeException(\"Decoding unpadding input A failed\");\n+        assertEquals('A', ret[0], \"Decoding unpadding input A failed\");\n@@ -462,2 +382,1 @@\n-        if (ret[0] != 'A' && ret[1] != 'A')\n-            throw new RuntimeException(\"Decoding unpadding input AA failed\");\n+        assertFalse(ret[0] != 'A' && ret[1] != 'A', \"Decoding unpadding input AA failed\");\n@@ -465,6 +384,4 @@\n-        if (dec.wrap(new ByteArrayInputStream(srcA)).read(ret) != 1 &&\n-            ret[0] != 'A')\n-            throw new RuntimeException(\"Decoding unpadding input A from stream failed\");\n-        if (dec.wrap(new ByteArrayInputStream(srcA)).read(ret) != 2 &&\n-            ret[0] != 'A' && ret[1] != 'A')\n-            throw new RuntimeException(\"Decoding unpadding input AA from stream failed\");\n+        assertFalse(dec.wrap(new ByteArrayInputStream(srcA)).read(ret) != 1 &&\n+            ret[0] != 'A', \"Decoding unpadding input A from stream failed\");\n+        assertFalse(dec.wrap(new ByteArrayInputStream(srcA)).read(ret) != 2 &&\n+            ret[0] != 'A' && ret[1] != 'A', \"Decoding unpadding input AA from stream failed\");\n@@ -475,1 +392,2 @@\n-    private static void testSingleNonBase64MimeDec() throws Throwable {\n+    @Test\n+    public void testSingleNonBase64MimeDec() {\n@@ -477,7 +395,4 @@\n-            if (Base64.getMimeDecoder().decode(nonBase64).length != 0) {\n-                throw new RuntimeException(\"non-base64 char is not ignored\");\n-            }\n-            try {\n-                Base64.getDecoder().decode(nonBase64);\n-                throw new RuntimeException(\"No IAE for single non-base64 char\");\n-            } catch (IllegalArgumentException iae) {}\n+            assertEquals(0, Base64.getMimeDecoder().decode(nonBase64).length,\n+                    \"non-base64 char is not ignored\");\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Base64.getDecoder().decode(nonBase64));\n@@ -487,67 +402,4 @@\n-    private static final void testEncode(Base64.Encoder enc, ByteBuffer bin, byte[] expected)\n-        throws Throwable {\n-\n-        ByteBuffer bout = enc.encode(bin);\n-        byte[] buf = new byte[bout.remaining()];\n-        bout.get(buf);\n-        if (bin.hasRemaining()) {\n-            throw new RuntimeException(\n-                \"Base64 enc.encode(ByteBuffer) failed!\");\n-        }\n-        checkEqual(buf, expected, \"Base64 enc.encode(bf, bf) failed!\");\n-    }\n-\n-    private static final void testDecode(Base64.Decoder dec, ByteBuffer bin, byte[] expected)\n-        throws Throwable {\n-\n-        ByteBuffer bout = dec.decode(bin);\n-        byte[] buf = new byte[bout.remaining()];\n-        bout.get(buf);\n-        checkEqual(buf, expected, \"Base64 dec.decode(bf) failed!\");\n-    }\n-\n-    private static final void checkEqual(int v1, int v2, String msg)\n-        throws Throwable {\n-       if (v1 != v2) {\n-           System.out.printf(\"    v1=%d%n\", v1);\n-           System.out.printf(\"    v2=%d%n\", v2);\n-           throw new RuntimeException(msg);\n-       }\n-    }\n-\n-    private static final void checkEqual(byte[] r1, byte[] r2, String msg)\n-        throws Throwable {\n-       if (!Arrays.equals(r1, r2)) {\n-           System.out.printf(\"    r1[%d]=[%s]%n\", r1.length, new String(r1));\n-           System.out.printf(\"    r2[%d]=[%s]%n\", r2.length, new String(r2));\n-           throw new RuntimeException(msg);\n-       }\n-    }\n-\n-    \/\/ remove line feeds,\n-    private static final byte[] normalize(byte[] src) {\n-        int n = 0;\n-        boolean hasUrl = false;\n-        for (int i = 0; i < src.length; i++) {\n-            if (src[i] == '\\r' || src[i] == '\\n')\n-                n++;\n-            if (src[i] == '-' || src[i] == '_')\n-                hasUrl = true;\n-        }\n-        if (n == 0 && hasUrl == false)\n-            return src;\n-        byte[] ret = new byte[src.length - n];\n-        int j = 0;\n-        for (int i = 0; i < src.length; i++) {\n-            if (src[i] == '-')\n-                ret[j++] = '+';\n-            else if (src[i] == '_')\n-                ret[j++] = '\/';\n-            else if (src[i] != '\\r' && src[i] != '\\n')\n-                ret[j++] = src[i];\n-        }\n-        return ret;\n-    }\n-\n-    private static void testEncoderKeepsSilence(Base64.Encoder enc)\n-            throws Throwable {\n+    \/\/ given invalid args, encoder should not produce output\n+    @ParameterizedTest\n+    @MethodSource(\"encoders\")\n+    public void testEncoderKeepsSilence(Base64.Encoder enc) {\n@@ -557,2 +409,2 @@\n-        vals.addAll(List.of(rnd.nextInt(), rnd.nextInt(), rnd.nextInt(),\n-                rnd.nextInt()));\n+        vals.addAll(List.of(RND.nextInt(), RND.nextInt(), RND.nextInt(),\n+                RND.nextInt()));\n@@ -566,3 +418,1 @@\n-                \/\/ invalid args, test them\n-                System.out.println(\"testing off=\" + off + \", len=\" + len);\n-\n+                \/\/ current args are invalid, test them\n@@ -570,8 +420,7 @@\n-                try (OutputStream os = enc.wrap(baos)) {\n-                    os.write(buf, off, len);\n-                    throw new RuntimeException(\"Expected IOOBEx was not thrown\");\n-                } catch (IndexOutOfBoundsException expected) {\n-                }\n-                if (baos.size() > 0)\n-                    throw new RuntimeException(\"No output was expected, but got \"\n-                            + baos.size() + \" bytes\");\n+                assertThrows(IndexOutOfBoundsException.class, () -> {\n+                    try (OutputStream os = enc.wrap(baos)) {\n+                        os.write(buf, off, len);\n+                    }\n+                }, \"Expected IOOBEx was not thrown\");\n+                assertFalse(baos.size() > 0,\n+                        \"No output was expected, but got \" + baos.size() + \" bytes\");\n@@ -582,1 +431,4 @@\n-    private static void testDecoderKeepsAbstinence(Base64.Decoder dec)\n+    \/\/ given invalid args, decoder should not consume input\n+    @ParameterizedTest\n+    @MethodSource(\"decoders\")\n+    public void testDecoderKeepsAbstinence(Base64.Decoder dec)\n@@ -587,2 +439,2 @@\n-        vals.addAll(List.of(rnd.nextInt(), rnd.nextInt(), rnd.nextInt(),\n-                rnd.nextInt()));\n+        vals.addAll(List.of(RND.nextInt(), RND.nextInt(), RND.nextInt(),\n+                RND.nextInt()));\n@@ -596,3 +448,1 @@\n-                \/\/ invalid args, test them\n-                System.out.println(\"testing off=\" + off + \", len=\" + len);\n-\n+                \/\/ current args are invalid, test them\n@@ -602,9 +452,8 @@\n-                try (InputStream is = dec.wrap(bais)) {\n-                    is.read(buf, off, len);\n-                    throw new RuntimeException(\"Expected IOOBEx was not thrown\");\n-                } catch (IndexOutOfBoundsException expected) {\n-                }\n-                if (bais.available() != input.length())\n-                    throw new RuntimeException(\"No input should be consumed, \"\n-                            + \"but consumed \" + (input.length() - bais.available())\n-                            + \" bytes\");\n+                assertThrows(IndexOutOfBoundsException.class, () -> {\n+                    try (InputStream is = dec.wrap(bais)) {\n+                        is.read(buf, off, len);\n+                    }\n+                }, \"Expected IOOBEx was not thrown\");\n+                assertEquals(input.length(), bais.available(),\n+                        \"No input should be consumed, but consumed \"\n+                                + (input.length() - bais.available()) + \" bytes\");\n@@ -615,2 +464,5 @@\n-    private static void testJDK_8222187() throws Throwable {\n-        byte[] orig = \"12345678\".getBytes(\"US-ASCII\");\n+    \/\/ Tests patch addressing JDK-8222187\n+    \/\/ Ensure decoder stream does not add unexpected null bytes at end\n+    @Test\n+    public void unexpectedNullBytesTest() throws Throwable {\n+        byte[] orig = \"12345678\".getBytes(ASCII);\n@@ -632,1 +484,1 @@\n-                checkEqual(decoded, orig, \"Base64 stream decoding failed!\");\n+                assertArrayEquals(decoded, orig, \"Base64 stream decoding failed!\");\n@@ -636,0 +488,70 @@\n+\n+    \/\/ Utilities to test encoding and decoding correctness of Base64\n+    private static void testEncode(Base64.Encoder enc, ByteBuffer bin, byte[] expected) {\n+        ByteBuffer bout = enc.encode(bin);\n+        byte[] buf = new byte[bout.remaining()];\n+        bout.get(buf);\n+        assertFalse(bin.hasRemaining(), \"Base64 enc.encode(ByteBuffer) failed!\");\n+        assertArrayEquals(buf, expected, \"Base64 enc.encode(bf, bf) failed!\");\n+    }\n+\n+    private static void testDecode(Base64.Decoder dec, ByteBuffer bin, byte[] expected) {\n+        ByteBuffer bout = dec.decode(bin);\n+        byte[] buf = new byte[bout.remaining()];\n+        bout.get(buf);\n+        assertArrayEquals(buf, expected, \"Base64 dec.decode(bf) failed!\");\n+    }\n+\n+    \/\/ Data providers\n+    \/\/ Associated encoder and decoder\n+    \/\/ Additionally, provides further test cases for randomized Mime encoders\n+    private static List<Arguments> encodersAndDecoders() {\n+        List<Arguments> args = new ArrayList<>();\n+        args.add(Arguments.of(Base64.getEncoder(), Base64.getDecoder()));\n+        args.add(Arguments.of(Base64.getUrlEncoder(), Base64.getUrlDecoder()));\n+        args.add(Arguments.of(Base64.getMimeEncoder(), Base64.getMimeDecoder()));\n+\n+        byte[] nl_1 = new byte[] {'\\n'};\n+        byte[] nl_2 = new byte[] {'\\n', '\\r'};\n+        byte[] nl_3 = new byte[] {'\\n', '\\r', '\\n'};\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            int len = RND.nextInt(BYTES) + 4;\n+            args.add(Arguments.of(Base64.getMimeEncoder(len, nl_1),\n+                    Base64.getMimeDecoder()));\n+            args.add(Arguments.of(Base64.getMimeEncoder(len, nl_2),\n+                    Base64.getMimeDecoder()));\n+            args.add(Arguments.of(Base64.getMimeEncoder(len, nl_3),\n+                    Base64.getMimeDecoder()));\n+        }\n+        \/\/ test mime case with < 4 length\n+        for (int len = 0; len < 4; len++) {\n+            args.add(Arguments.of(Base64.getMimeEncoder(len, nl_1),\n+                    Base64.getMimeDecoder()));\n+            args.add(Arguments.of(Base64.getMimeEncoder(len, nl_2),\n+                    Base64.getMimeDecoder()));\n+            args.add(Arguments.of(Base64.getMimeEncoder(len, nl_3),\n+                    Base64.getMimeDecoder()));\n+        }\n+        return args;\n+    }\n+\n+    \/\/ Basic encoders\n+    private static Stream<Base64.Encoder> encoders () {\n+        return Stream.of(Base64.getEncoder(), Base64.getMimeEncoder(),\n+                Base64.getUrlEncoder(), Base64.getMimeEncoder(10, new byte[]{'\\n'}));\n+    }\n+\n+    \/\/ Basic decoders\n+    private static Stream<Base64.Decoder> decoders () {\n+        return Stream.of(Base64.getDecoder(), Base64.getMimeDecoder(), Base64.getUrlDecoder());\n+    }\n+\n+    \/\/ Decoders that also provide associated encoded data\n+    private static Stream<Arguments> decodersWithEncoded() {\n+        byte[] src = new byte[1024];\n+        RND.nextBytes(src);\n+        final byte[] decoded = Base64.getEncoder().encode(src);\n+        return Stream.of(Arguments.of(Base64.getDecoder(), decoded),\n+                Arguments.of(Base64.getMimeDecoder(), decoded),\n+                Arguments.of(Base64.getUrlDecoder(), Base64.getUrlEncoder().encode(src)));\n+    }\n","filename":"test\/jdk\/java\/util\/Base64\/TestBase64.java","additions":272,"deletions":350,"binary":false,"changes":622,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,3 @@\n- * @bug 4235519\n- * @author Eric Wang <yiming.wang@oracle.com>\n- * @summary tests java.util.Base64\n+ * @bug 4235519 8331342\n+ * @summary Tests java.util.Base64.Encoder\/Decoder encode\/decode methods.\n+ * @run junit TestBase64Golden\n@@ -31,2 +31,7 @@\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n@@ -38,0 +43,1 @@\n+import java.util.ArrayList;\n@@ -41,2 +47,1 @@\n-import java.util.Objects;\n-import java.util.Random;\n+import java.util.List;\n@@ -44,1 +49,2 @@\n-public class TestBase64Golden {\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -46,3 +52,1 @@\n-    public static void main(String[] args) throws Exception {\n-        test0(Base64Type.BASIC, Base64.getEncoder(), Base64.getDecoder(),\n-              \"plain.txt\", \"baseEncode.txt\");\n+public class TestBase64Golden {\n@@ -50,2 +54,6 @@\n-        test0(Base64Type.URLSAFE, Base64.getUrlEncoder(), Base64.getUrlDecoder(),\n-              \"plain.txt\", \"urlEncode.txt\");\n+    \/\/ To access the data files\n+    private static final String SRCDIR = System.getProperty(\"test.src\", \".\");\n+    private static final Charset DEF_CHARSET = StandardCharsets.US_ASCII;\n+    private static final String DEFAULT_CRLF = \"\\r\\n\";\n+    private static final List<Arguments> encoderTestData = new ArrayList<>();\n+    private static final List<Arguments> decoderTestData = new ArrayList<>();\n@@ -53,3 +61,14 @@\n-        test0(Base64Type.MIME, Base64.getMimeEncoder(), Base64.getMimeDecoder(),\n-              \"plain.txt\", \"mimeEncode.txt\");\n-        test1();\n+    \/\/ Helper enum for building the test data\n+    enum Base64Type {\n+        BASIC(\"baseEncode.txt\", Base64.getEncoder(), Base64.getDecoder()),\n+        URLSAFE(\"urlEncode.txt\", Base64.getUrlEncoder(), Base64.getUrlDecoder()),\n+        MIME(\"mimeEncode.txt\", Base64.getMimeEncoder(), Base64.getMimeDecoder());\n+\n+        Base64Type(String s, Encoder e, Decoder d) {\n+            fileName = s;\n+            encoder = e;\n+            decoder = d;\n+        }\n+        private final String fileName;\n+        private final Base64.Encoder encoder;\n+        private final Base64.Decoder decoder;\n@@ -58,22 +77,26 @@\n-    public static void test0(Base64Type type, Encoder encoder, Decoder decoder,\n-                             String srcFile, String encodedFile) throws Exception {\n-\n-        String[] srcLns = Files.readAllLines(Paths.get(SRCDIR, srcFile), DEF_CHARSET)\n-                               .toArray(new String[0]);\n-        String[] encodedLns = Files.readAllLines(Paths.get(SRCDIR, encodedFile),\n-                                                 DEF_CHARSET)\n-                                   .toArray(new String[0]);\n-        int lns = 0;\n-        for (String srcStr : srcLns) {\n-            String encodedStr = null;\n-            if (type != Base64Type.MIME) {\n-                encodedStr = encodedLns[lns++];\n-            } else {\n-                while (lns < encodedLns.length) {\n-                    String s = encodedLns[lns++];\n-                    if (s.length() == 0)\n-                        break;\n-                    if (encodedStr != null) {\n-                        encodedStr += DEFAULT_CRLF + s;\n-                    } else {\n-                        encodedStr = s;\n+    \/\/ Build the test and expected data from the txt files based off the Base64Type\n+    @BeforeAll\n+    public static void generateTestData() throws IOException {\n+        for (Base64Type type : Base64Type.values()) {\n+            String[] srcLns = Files.readAllLines(Paths.get(SRCDIR, \"plain.txt\"), DEF_CHARSET)\n+                    .toArray(new String[0]);\n+            String[] encodedLns = Files.readAllLines(Paths.get(SRCDIR, type.fileName),\n+                    DEF_CHARSET).toArray(new String[0]);\n+            int lns = 0;\n+            for (String srcStr : srcLns) {\n+                StringBuilder encodedStr = null;\n+                if (type != Base64Type.MIME) {\n+                    encodedStr = new StringBuilder(encodedLns[lns++]);\n+                } else {\n+                    while (lns < encodedLns.length) {\n+                        String s = encodedLns[lns++];\n+                        if (s.length() == 0)\n+                            break;\n+                        if (encodedStr != null) {\n+                            encodedStr.append(DEFAULT_CRLF).append(s);\n+                        } else {\n+                            encodedStr = new StringBuilder(s);\n+                        }\n+                    }\n+                    if (encodedStr == null && srcStr.length() == 0) {\n+                        encodedStr = new StringBuilder();\n@@ -82,3 +105,5 @@\n-                if (encodedStr == null && srcStr.length() == 0) {\n-                    encodedStr = \"\";\n-                }\n+                byte[] srcArr = srcStr.getBytes(DEF_CHARSET);\n+                byte[] encodedArr = encodedStr.toString().getBytes(DEF_CHARSET);\n+                \/\/ Add the encoder\/decoder type with pre\/post encoded data\n+                encoderTestData.add(Arguments.of(type.encoder, encodedArr, srcArr));\n+                decoderTestData.add(Arguments.of(type.decoder, encodedArr, srcArr));\n@@ -86,53 +111,0 @@\n-            System.out.printf(\"%n    src[%d]: %s%n\", srcStr.length(), srcStr);\n-            System.out.printf(\"encoded[%d]: %s%n\", encodedStr.length(), encodedStr);\n-\n-            byte[] srcArr = srcStr.getBytes(DEF_CHARSET);\n-            byte[] encodedArr = encodedStr.getBytes(DEF_CHARSET);\n-\n-            ByteBuffer srcBuf = ByteBuffer.wrap(srcArr);\n-            ByteBuffer encodedBuf = ByteBuffer.wrap(encodedArr);\n-            byte[] resArr = new byte[encodedArr.length];\n-\n-            \/\/ test int encode(byte[], byte[])\n-            int len = encoder.encode(srcArr, resArr);\n-            assertEqual(len, encodedArr.length);\n-            assertEqual(resArr, encodedArr);\n-\n-            \/\/ test byte[] encode(byte[])\n-            resArr = encoder.encode(srcArr);\n-            assertEqual(resArr, encodedArr);\n-\n-            \/\/ test ByteBuffer encode(ByteBuffer)\n-            int limit = srcBuf.limit();\n-            ByteBuffer resBuf = encoder.encode(srcBuf);\n-            assertEqual(srcBuf.position(), limit);\n-            assertEqual(srcBuf.limit(), limit);\n-            assertEqual(resBuf, encodedBuf);\n-            srcBuf.rewind(); \/\/ reset for next test\n-\n-            \/\/ test String encodeToString(byte[])\n-            String resEncodeStr = encoder.encodeToString(srcArr);\n-            assertEqual(resEncodeStr, encodedStr);\n-\n-            \/\/ test int decode(byte[], byte[])\n-            resArr = new byte[srcArr.length];\n-            len = decoder.decode(encodedArr, resArr);\n-            assertEqual(len, srcArr.length);\n-            assertEqual(resArr, srcArr);\n-\n-            \/\/ test byte[] decode(byte[])\n-            resArr = decoder.decode(encodedArr);\n-            assertEqual(resArr, srcArr);\n-\n-            \/\/ test ByteBuffer decode(ByteBuffer)\n-            limit = encodedBuf.limit();\n-            resBuf = decoder.decode(encodedBuf);\n-            assertEqual(encodedBuf.position(), limit);\n-            assertEqual(encodedBuf.limit(), limit);\n-            assertEqual(resBuf, srcBuf);\n-            encodedBuf.rewind(); \/\/ reset for next test\n-\n-            \/\/ test byte[] decode(String)\n-            resArr = decoder.decode(encodedStr);\n-            assertEqual(resArr, srcArr);\n-\n@@ -142,12 +114,3 @@\n-    private static void test1() throws Exception {\n-        byte[] src = new byte[] {\n-            46, -97, -35, -44, 127, -60, -39, -4, -112, 34, -57, 47, -14, 67,\n-            40, 18, 90, -59, 68, 112, 23, 121, -91, 94, 35, 49, 104, 17, 30,\n-            -80, -104, -3, -53, 27, 38, -72, -47, 113, -52, 18, 5, -126 };\n-        Encoder encoder = Base64.getMimeEncoder(49, new byte[] { 0x7e });\n-        byte[] encoded = encoder.encode(src);\n-        Decoder decoder = Base64.getMimeDecoder();\n-        byte[] decoded = decoder.decode(encoded);\n-        if (!Objects.deepEquals(src, decoded)) {\n-            throw new RuntimeException();\n-        }\n+    \/\/ Data providers for encode and decode\n+    private static List<Arguments> encoderData() {\n+        return encoderTestData;\n@@ -156,3 +119,2 @@\n-    \/\/ helper\n-    enum Base64Type {\n-        BASIC, URLSAFE, MIME\n+    private static List<Arguments> decoderData() {\n+        return decoderTestData;\n@@ -161,5 +123,11 @@\n-    private static final String SRCDIR = System.getProperty(\"test.src\", \".\");\n-    private static final Charset DEF_CHARSET = StandardCharsets.US_ASCII;\n-    private static final String DEF_EXCEPTION_MSG =\n-        \"Assertion failed! The result is not same as expected\";\n-    private static final String DEFAULT_CRLF = \"\\r\\n\";\n+    \/\/ Test all the encode* methods for Base64.Encoder\n+    \/\/ test int encode(byte[], byte[])\n+    @ParameterizedTest\n+    @MethodSource(\"encoderData\")\n+    public void encodeNewByteArrayTest(Base64.Encoder encoder,\n+                                       byte[] encodedArr, byte[] srcArr) {\n+        byte[] resArr = new byte[encodedArr.length];\n+        int len = encoder.encode(srcArr, resArr);\n+        assertEquals(len, encodedArr.length);\n+        assertArrayEquals(resArr, encodedArr);\n+    }\n@@ -167,13 +135,87 @@\n-    private static void assertEqual(Object result, Object expect) {\n-        if (!Objects.deepEquals(result, expect)) {\n-            String resultStr = result.toString();\n-            String expectStr = expect.toString();\n-            if (result instanceof byte[]) {\n-                resultStr = new String((byte[]) result, DEF_CHARSET);\n-            }\n-            if (expect instanceof byte[]) {\n-                expectStr = new String((byte[]) expect, DEF_CHARSET);\n-            }\n-            throw new RuntimeException(DEF_EXCEPTION_MSG +\n-                \" result: \" + resultStr + \" expected: \" + expectStr);\n-        }\n+    \/\/ test byte[] encode(byte[])\n+    @ParameterizedTest\n+    @MethodSource(\"encoderData\")\n+    public void encodeToByteArrayTest(Base64.Encoder encoder,\n+                                      byte[] encodedArr, byte[] srcArr) {\n+        assertArrayEquals(encoder.encode(srcArr), encodedArr);\n+    }\n+\n+    \/\/ test ByteBuffer encode(ByteBuffer)\n+    @ParameterizedTest\n+    @MethodSource(\"encoderData\")\n+    public void encoderByteBufferTest(Base64.Encoder encoder,\n+                                      byte[] encodedArr, byte[] srcArr) {\n+        ByteBuffer srcBuf = ByteBuffer.wrap(srcArr);\n+        ByteBuffer encodedBuf = ByteBuffer.wrap(encodedArr);\n+        int limit = srcBuf.limit();\n+        ByteBuffer resBuf = encoder.encode(srcBuf);\n+        assertEquals(srcBuf.position(), limit);\n+        assertEquals(srcBuf.limit(), limit);\n+        assertEquals(resBuf, encodedBuf);\n+    }\n+\n+    \/\/ test String encodeToString(byte[])\n+    @ParameterizedTest\n+    @MethodSource(\"encoderData\")\n+    public void encoderToStringTest(Base64.Encoder encoder,\n+                                    byte[] encodedArr, byte[] srcArr) {\n+        String resEncodeStr = encoder.encodeToString(srcArr);\n+        assertEquals(resEncodeStr, new String(encodedArr, DEF_CHARSET));\n+    }\n+\n+    \/\/ Test all the decode* methods for Base64.Decoder\n+    \/\/ test byte[] decode(byte[])\n+    @ParameterizedTest\n+    @MethodSource(\"decoderData\")\n+    public void decodeNewByteArrayTest(Base64.Decoder decoder,\n+                                       byte[] encodedArr, byte[] srcArr) {\n+        byte[] resArr = decoder.decode(encodedArr);\n+        assertArrayEquals(resArr, srcArr);\n+    }\n+\n+    \/\/ test int decode(byte[], byte[])\n+    @ParameterizedTest\n+    @MethodSource(\"decoderData\")\n+    public void decodeToByteArrayTest(Base64.Decoder decoder,\n+                                      byte[] encodedArr, byte[] srcArr) {\n+        byte[] resArr = new byte[srcArr.length];\n+        int len = decoder.decode(encodedArr, resArr);\n+        assertEquals(len, srcArr.length);\n+        assertArrayEquals(resArr, srcArr);\n+    }\n+\n+    \/\/ test ByteBuffer decode(ByteBuffer)\n+    @ParameterizedTest\n+    @MethodSource(\"decoderData\")\n+    public void decodeByteBufferTest(Base64.Decoder decoder,\n+                                     byte[] encodedArr, byte[] srcArr) {\n+        ByteBuffer srcBuf = ByteBuffer.wrap(srcArr);\n+        ByteBuffer encodedBuf = ByteBuffer.wrap(encodedArr);\n+        int limit = encodedBuf.limit();\n+        ByteBuffer resBuf = decoder.decode(encodedBuf);\n+        assertEquals(encodedBuf.position(), limit);\n+        assertEquals(encodedBuf.limit(), limit);\n+        assertEquals(resBuf, srcBuf);\n+    }\n+\n+    \/\/ test byte[] decode(String)\n+    @ParameterizedTest\n+    @MethodSource(\"decoderData\")\n+    public void decodeEncodedStringTest(Base64.Decoder decoder,\n+                                        byte[] encodedArr, byte[] srcArr) {\n+        byte[] resArr = decoder.decode(new String(encodedArr, DEF_CHARSET));\n+        assertArrayEquals(resArr, srcArr);\n+    }\n+\n+    \/\/ Standalone test for MIME. Not dependent on the golden data.\n+    @Test\n+    public void mimeRoundTripTest()  {\n+        byte[] src = new byte[] {\n+                46, -97, -35, -44, 127, -60, -39, -4, -112, 34, -57, 47, -14, 67,\n+                40, 18, 90, -59, 68, 112, 23, 121, -91, 94, 35, 49, 104, 17, 30,\n+                -80, -104, -3, -53, 27, 38, -72, -47, 113, -52, 18, 5, -126 };\n+        Encoder encoder = Base64.getMimeEncoder(49, new byte[] { 0x7e });\n+        byte[] encoded = encoder.encode(src);\n+        Decoder decoder = Base64.getMimeDecoder();\n+        byte[] decoded = decoder.decode(encoded);\n+        assertArrayEquals(src, decoded);\n","filename":"test\/jdk\/java\/util\/Base64\/TestBase64Golden.java","additions":170,"deletions":128,"binary":false,"changes":298,"status":"modified"}]}