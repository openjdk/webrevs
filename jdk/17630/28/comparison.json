{"files":[{"patch":"@@ -90,0 +90,5 @@\n+        <\/dependency>\n+        <dependency>\n+            <groupId>org.netbeans.api<\/groupId>\n+            <artifactId>org-openide-modules<\/artifactId>\n+            <version>${netbeans.version}<\/version>\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/pom.xml","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,5 @@\n-import com.sun.hotspot.igv.data.services.GroupCallback;\n+import com.sun.hotspot.igv.data.serialization.ParseMonitor;\n+import com.sun.hotspot.igv.data.serialization.Parser;\n+import com.sun.hotspot.igv.data.serialization.Printer;\n+import com.sun.hotspot.igv.data.serialization.Printer.GraphContext;\n+import com.sun.hotspot.igv.data.services.GraphViewer;\n@@ -33,0 +37,1 @@\n+import com.sun.hotspot.igv.settings.Settings;\n@@ -37,6 +42,10 @@\n-import java.io.IOException;\n-import java.io.ObjectInput;\n-import java.io.ObjectOutput;\n-import java.util.HashSet;\n-import java.util.Set;\n-import javax.swing.UIManager;\n+import java.io.*;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.swing.*;\n@@ -44,0 +53,3 @@\n+import javax.swing.filechooser.FileFilter;\n+import org.netbeans.api.progress.ProgressHandle;\n+import org.netbeans.api.progress.ProgressHandleFactory;\n@@ -45,1 +57,0 @@\n-import org.openide.actions.GarbageCollectAction;\n@@ -53,0 +64,1 @@\n+import org.openide.util.Lookup;\n@@ -54,0 +66,1 @@\n+import org.openide.windows.Mode;\n@@ -63,1 +76,0 @@\n-    public static OutlineTopComponent instance;\n@@ -65,0 +77,16 @@\n+    private static final GraphDocument document = new GraphDocument();\n+    private static final int WORK_UNITS = 10000;\n+    private static final FileFilter xmlFileFilter = new FileFilter() {\n+        @Override\n+        public boolean accept(File f) {\n+            return f.getName().toLowerCase().endsWith(\".xml\") || f.isDirectory();\n+        }\n+\n+        @Override\n+        public String getDescription() {\n+            return \"Graph files (*.xml)\";\n+        }\n+    };\n+    private static final Server server = new Server(document, OutlineTopComponent::loadContext);\n+    public static OutlineTopComponent instance;\n+    private final Set<FolderNode> selectedFolders = new HashSet<>();\n@@ -66,1 +94,0 @@\n-    private final GraphDocument document;\n@@ -68,1 +95,2 @@\n-    private SaveAllAction saveAllAction;\n+    private SaveAction saveAction;\n+    private SaveAsAction saveAsAction;\n@@ -71,1 +99,1 @@\n-    private final Set<FolderNode> selectedFolders = new HashSet<>();\n+    private Path documentPath = null;\n@@ -78,2 +106,0 @@\n-\n-        document = new GraphDocument();\n@@ -82,1 +108,74 @@\n-        initReceivers();\n+        server.startServer();\n+    }\n+\n+    public static GraphDocument getDocument() {\n+        return document;\n+    }\n+\n+    \/**\n+     * Gets default instance. Do not use directly: reserved for *.settings files only,\n+     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.\n+     * To obtain the singleton instance, use {@link #findInstance()}.\n+     *\/\n+    public static synchronized OutlineTopComponent getDefault() {\n+        if (instance == null) {\n+            instance = new OutlineTopComponent();\n+        }\n+        return instance;\n+    }\n+\n+    \/**\n+     * Obtain the OutlineTopComponent instance. Never call {@link #getDefault} directly!\n+     *\/\n+    public static synchronized OutlineTopComponent findInstance() {\n+        TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);\n+        if (win == null) {\n+            ErrorManager.getDefault().log(ErrorManager.WARNING, \"Cannot find Outline component. It will not be located properly in the window system.\");\n+            return getDefault();\n+        }\n+        if (win instanceof OutlineTopComponent) {\n+            return (OutlineTopComponent) win;\n+        }\n+        ErrorManager.getDefault().log(ErrorManager.WARNING, \"There seem to be multiple components with the '\" + PREFERRED_ID + \"' ID. That is a potential source of errors and unexpected behavior.\");\n+        return getDefault();\n+    }\n+\n+    \/**\n+     * Stores the provided graph document to the designated file path with associated contexts.\n+     *\/\n+    private static void saveGraphDocument(GraphDocument doc, String path) throws IOException {\n+        if (path == null) {\n+            return;\n+        }\n+\n+        Set<GraphContext> saveContexts = new HashSet<>();\n+        WindowManager manager = WindowManager.getDefault();\n+        for (Mode mode : manager.getModes()) {\n+            List<TopComponent> compList = new ArrayList<>(Arrays.asList(manager.getOpenedTopComponents(mode)));\n+            for (TopComponent comp : compList) {\n+                if (comp instanceof EditorTopComponent etc) {\n+                    InputGraph graph = etc.getModel().getGraph();\n+                    if (graph.isDiffGraph() && graph.getFirstGraph().getGroup() != graph.getSecondGraph().getGroup()) {\n+                        \/\/ don't save diff graphs comparing graphs from different groups\n+                        continue;\n+                    }\n+                    GraphContext graphContext = getGraphContext(etc);\n+                    saveContexts.add(graphContext);\n+                }\n+            }\n+        }\n+\n+        try (Writer writer = new OutputStreamWriter(new FileOutputStream(path))) {\n+            Printer.exportGraphDocument(writer, doc, saveContexts);\n+        }\n+    }\n+\n+    private static GraphContext getGraphContext(EditorTopComponent etc) {\n+        InputGraph openedGraph = etc.getModel().getFirstGraph();\n+        int posDiff = etc.getModel().getSecondPosition() - etc.getModel().getFirstPosition();\n+        if (etc.getModel().getHiddenNodes().isEmpty()) {\n+            return new GraphContext(openedGraph, new AtomicInteger(posDiff), new HashSet<>(), new AtomicBoolean(true));\n+        } else {\n+            Set<Integer> visibleNodes = new HashSet<>(etc.getModel().getVisibleNodes());\n+            return new GraphContext(openedGraph, new AtomicInteger(posDiff), visibleNodes, new AtomicBoolean(false));\n+        }\n@@ -86,1 +185,3 @@\n-        manager = new ExplorerManager();\n+        setDocumentPath(null);\n+        FolderNode.clearGraphNodeMap();\n+        document.clear();\n@@ -88,0 +189,1 @@\n+        manager = new ExplorerManager();\n@@ -90,1 +192,0 @@\n-\n@@ -97,1 +198,1 @@\n-        toolbar.setMinimumSize(new Dimension(0,0)); \/\/ MacOS BUG with ToolbarWithOverflow\n+        toolbar.setMinimumSize(new Dimension(0, 0)); \/\/ MacOS BUG with ToolbarWithOverflow\n@@ -101,0 +202,1 @@\n+        toolbar.add(OpenAction.get(OpenAction.class));\n@@ -102,1 +204,1 @@\n-        toolbar.add(SaveAsAction.get(SaveAsAction.class).createContextAwareInstance(this.getLookup()));\n+        toolbar.addSeparator();\n@@ -104,3 +206,6 @@\n-        saveAllAction = SaveAllAction.get(SaveAllAction.class);\n-        saveAllAction.setEnabled(false);\n-        toolbar.add(saveAllAction);\n+        saveAction = SaveAction.get(SaveAction.class);\n+        saveAction.setEnabled(false);\n+        toolbar.add(saveAction);\n+        saveAsAction = SaveAsAction.get(SaveAsAction.class);\n+        saveAsAction.setEnabled(false);\n+        toolbar.add(saveAsAction);\n@@ -108,0 +213,1 @@\n+        toolbar.addSeparator();\n@@ -109,1 +215,0 @@\n-\n@@ -114,2 +219,0 @@\n-        toolbar.add(GarbageCollectAction.get(GarbageCollectAction.class).getToolbarPresenter());\n-\n@@ -125,1 +228,2 @@\n-        saveAllAction.setEnabled(enableButton);\n+        saveAction.setEnabled(enableButton);\n+        saveAsAction.setEnabled(enableButton);\n@@ -129,19 +233,0 @@\n-    private void initReceivers() {\n-\n-        final GroupCallback callback = g -> {\n-            synchronized(OutlineTopComponent.this) {\n-                g.setParent(getDocument());\n-                getDocument().addElement(g);\n-            }\n-        };\n-\n-        new Server(callback);\n-    }\n-\n-    public void clear() {\n-        document.clear();\n-        FolderNode.clearGraphNodeMap();\n-        root = new FolderNode(document);\n-        manager.setRootContext(root);\n-    }\n-\n@@ -153,32 +238,0 @@\n-    public GraphDocument getDocument() {\n-        return document;\n-    }\n-\n-    \/**\n-     * Gets default instance. Do not use directly: reserved for *.settings files only,\n-     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.\n-     * To obtain the singleton instance, use {@link #findInstance()}.\n-     *\/\n-    public static synchronized OutlineTopComponent getDefault() {\n-        if (instance == null) {\n-            instance = new OutlineTopComponent();\n-        }\n-        return instance;\n-    }\n-\n-    \/**\n-     * Obtain the OutlineTopComponent instance. Never call {@link #getDefault} directly!\n-     *\/\n-    public static synchronized OutlineTopComponent findInstance() {\n-        TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);\n-        if (win == null) {\n-            ErrorManager.getDefault().log(ErrorManager.WARNING, \"Cannot find Outline component. It will not be located properly in the window system.\");\n-            return getDefault();\n-        }\n-        if (win instanceof OutlineTopComponent) {\n-            return (OutlineTopComponent) win;\n-        }\n-        ErrorManager.getDefault().log(ErrorManager.WARNING, \"There seem to be multiple components with the '\" + PREFERRED_ID + \"' ID. That is a potential source of errors and unexpected behavior.\");\n-        return getDefault();\n-    }\n-\n@@ -239,9 +292,6 @@\n-                    EditorTopComponent editor = EditorTopComponent.getActive();\n-                    if (editor != null) {\n-                        InputGraph firstGraph = editor.getModel().getFirstGraph();\n-                        GraphNode firstNode = FolderNode.getGraphNode(firstGraph);\n-                        InputGraph secondGraph = editor.getModel().getSecondGraph();\n-                        GraphNode secondNode = FolderNode.getGraphNode(secondGraph);\n-                        if (firstNode != null && secondNode != null) {\n-                            selectedGraphs = new GraphNode[]{firstNode, secondNode};\n-                        }\n+                    InputGraph firstGraph = graph.getFirstGraph();\n+                    GraphNode firstNode = FolderNode.getGraphNode(firstGraph);\n+                    InputGraph secondGraph = graph.getSecondGraph();\n+                    GraphNode secondNode = FolderNode.getGraphNode(secondGraph);\n+                    if (firstNode != null && secondNode != null) {\n+                        selectedGraphs = new GraphNode[]{firstNode, secondNode};\n@@ -274,4 +324,7 @@\n-    public void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {\n-        \/\/ Not called when user starts application for the first time\n-        super.readExternal(objectInput);\n-        ((BeanTreeView) this.treeView).setRootVisible(false);\n+    public boolean canClose() {\n+        SwingUtilities.invokeLater(() -> {\n+            this.clearWorkspace();\n+            this.open(); \/\/ Reopen the OutlineTopComponent\n+            this.requestActive();\n+        });\n+        return true;\n@@ -280,3 +333,218 @@\n-    @Override\n-    public void writeExternal(ObjectOutput objectOutput) throws IOException {\n-        super.writeExternal(objectOutput);\n+    private void setDocumentPath(String path) {\n+        if (path != null) {\n+            documentPath = Paths.get(path);\n+            setHtmlDisplayName(\"<html><b>\" + documentPath.getFileName().toString() + \"<\/b><\/html>\");\n+            setToolTipText(\"File: \" + path);\n+        } else {\n+            documentPath = null;\n+            setHtmlDisplayName(\"<html><i>untitled<\/i><\/html>\");\n+            setToolTipText(\"No file\");\n+        }\n+\n+    }\n+\n+    \/**\n+     * Clears the workspace by resetting the document path, clearing the document, and resetting the folder structure.\n+     * After clearing the workspace, it will be ready for new documents.\n+     *\/\n+    public void clearWorkspace() {\n+        setDocumentPath(null);\n+        document.clear();\n+        FolderNode.clearGraphNodeMap();\n+        root = new FolderNode(document);\n+        manager.setRootContext(root);\n+        EditorTopComponent.closeAllInstances();\n+    }\n+\n+    \/**\n+     * Opens a file dialog to select and load a graph document.\n+     * Clears the workspace and adds the loaded document to the workspace.\n+     **\/\n+    public void openFile() {\n+        JFileChooser fc = new JFileChooser(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT));\n+        fc.setFileFilter(xmlFileFilter);\n+        if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n+            clearWorkspace();\n+            String path = fc.getSelectedFile().getAbsolutePath();\n+            Settings.get().put(Settings.DIRECTORY, path);\n+            setDocumentPath(path);\n+            try {\n+                loadGraphDocument(path, true);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    private boolean overwriteDialog(String filename) {\n+        JFrame frame = new JFrame();\n+        String message = \"Do you want to overwrite \" + filename + \"?\";\n+        int result = JOptionPane.showConfirmDialog(frame, message, \"Confirm Overwrite\", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n+        if (result == JOptionPane.YES_OPTION) {\n+            frame.dispose();\n+            return true;\n+        }\n+        frame.dispose();\n+        return false;\n+    }\n+\n+    \/**\n+     * Saves the current graph document.\n+     * If the document has no location, let the user specify the file location.\n+     *\/\n+    public void save() {\n+        if (documentPath == null) {\n+            saveAs();\n+            return;\n+        }\n+\n+        String filePath = documentPath.toAbsolutePath().toString();\n+        if (Files.exists(Paths.get(filePath)) && overwriteDialog(documentPath.getFileName().toString())) {\n+            try {\n+                saveGraphDocument(getDocument(), filePath);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        } else {\n+            saveAs();\n+        }\n+    }\n+\n+    public void saveAs() {\n+        JFileChooser fc = new JFileChooser();\n+        fc.setDialogTitle(\"Save As...\");\n+        fc.setFileFilter(xmlFileFilter);\n+        fc.setCurrentDirectory(new File(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT)));\n+        if (fc.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {\n+            String path = fc.getSelectedFile().getAbsolutePath();\n+\n+            \/\/ Ask if the user wants to overwrite the file if it already exists\n+            if (Files.exists(Paths.get(path)) && !overwriteDialog(fc.getSelectedFile().getName())) {\n+                return; \/\/ user does not want to overwrite\n+            }\n+\n+            Settings.get().put(Settings.DIRECTORY, path);\n+            setDocumentPath(path);\n+            try {\n+                saveGraphDocument(getDocument(), path);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Imports graph documents from one or more XML files.\n+     * Displays a file chooser dialog to select one or multiple XML files for import.\n+     * Each selected file is added to the workspace.\n+     **\/\n+    public void importFromXML() {\n+        JFileChooser fc = new JFileChooser();\n+        fc.setFileFilter(xmlFileFilter);\n+        fc.setCurrentDirectory(new File(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT)));\n+        fc.setMultiSelectionEnabled(true);\n+        if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n+            for (final File file : fc.getSelectedFiles()) {\n+                String path = file.getAbsolutePath();\n+                Settings.get().put(Settings.DIRECTORY, path);\n+                try {\n+                    loadGraphDocument(path, false);\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Loads and opens the given a graph contexts (opened graphs and visible nodes).\n+     *\/\n+    private static void loadContext(GraphContext context) {\n+        final GraphViewer viewer = Lookup.getDefault().lookup(GraphViewer.class);\n+        if (viewer != null) {\n+            final int difference = context.posDiff().get();\n+            final InputGraph firstGraph = context.inputGraph();\n+            final Set<Integer> visibleNodes = context.visibleNodes();\n+            final boolean showAll = context.showAll().get();\n+\n+            SwingUtilities.invokeLater(() -> {\n+                InputGraph openedGraph = viewer.view(firstGraph, true);\n+                if (openedGraph != null) {\n+                    EditorTopComponent etc = EditorTopComponent.findEditorForGraph(firstGraph);\n+                    if (etc != null) {\n+                        if (showAll) {\n+                            etc.getModel().setHiddenNodes(new HashSet<>());\n+                        } else {\n+                            etc.getModel().showOnly(visibleNodes);\n+                        }\n+                        int firstGraphIdx = firstGraph.getIndex();\n+                        if (difference > 0) {\n+                            etc.getModel().setPositions(firstGraphIdx, firstGraphIdx + difference);\n+                        } else if (difference < 0) {\n+                            etc.getModel().setPositions(firstGraphIdx + difference, firstGraphIdx);\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Loads a graph document from the given file path, updating progress via a ProgressHandle.\n+     * Parse the XML file, add the parsed document to the workspace, and load associated contexts if specified.\n+     *\/\n+    private void loadGraphDocument(String path, boolean loadContext) throws IOException {\n+        if (path == null || Files.notExists(Path.of(path))) {\n+            return;\n+        }\n+        File file = new File(path);\n+        final FileChannel channel;\n+        final long start;\n+        try {\n+            channel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+            start = channel.size();\n+        } catch (Exception ex) {\n+            Exceptions.printStackTrace(ex);\n+            return;\n+        }\n+\n+        final ProgressHandle handle = ProgressHandleFactory.createHandle(\"Opening file \" + file.getName());\n+        handle.start(WORK_UNITS);\n+\n+        ParseMonitor monitor = new ParseMonitor() {\n+            @Override\n+            public void updateProgress() {\n+                try {\n+                    int prog = (int) (WORK_UNITS * (double) channel.position() \/ (double) start);\n+                    handle.progress(prog);\n+                } catch (IOException ignored) {\n+                }\n+            }\n+\n+            @Override\n+            public void setState(String state) {\n+                updateProgress();\n+                handle.progress(state);\n+            }\n+        };\n+        try {\n+            if (file.getName().endsWith(\".xml\")) {\n+                ArrayList<GraphContext> contexts = new ArrayList<>();\n+                final Parser parser = new Parser(channel, monitor, document, loadContext ? contexts::add : null);\n+                parser.parse();\n+                SwingUtilities.invokeLater(() -> {\n+                    for (Node child : manager.getRootContext().getChildren().getNodes(true)) {\n+                        \/\/ Nodes a lazily created. By expanding and collapsing they are all initialized\n+                        ((BeanTreeView) this.treeView).expandNode(child);\n+                        ((BeanTreeView) this.treeView).collapseNode(child);\n+                    }\n+                    requestActive();\n+                    for (GraphContext ctx : contexts) {\n+                        loadContext(ctx);\n+                    }\n+                });\n+            }\n+        } catch (IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+        handle.finish();\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/OutlineTopComponent.java","additions":362,"deletions":94,"binary":false,"changes":456,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,11 +28,0 @@\n-import com.sun.hotspot.igv.data.GraphDocument;\n-import com.sun.hotspot.igv.data.serialization.GraphParser;\n-import com.sun.hotspot.igv.data.serialization.ParseMonitor;\n-import com.sun.hotspot.igv.data.serialization.Parser;\n-import com.sun.hotspot.igv.settings.Settings;\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.channels.FileChannel;\n-import java.nio.file.StandardOpenOption;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n@@ -40,6 +29,3 @@\n-import javax.swing.JFileChooser;\n-import javax.swing.SwingUtilities;\n-import javax.swing.filechooser.FileFilter;\n-import org.netbeans.api.progress.ProgressHandle;\n-import org.netbeans.api.progress.ProgressHandleFactory;\n-import org.openide.util.*;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.NbBundle;\n@@ -54,1 +40,0 @@\n-    private static final int WORKUNITS = 10000;\n@@ -56,13 +41,3 @@\n-    public static FileFilter getFileFilter() {\n-        return new FileFilter() {\n-\n-            @Override\n-            public boolean accept(File f) {\n-                return f.getName().toLowerCase().endsWith(\".xml\") || f.isDirectory();\n-            }\n-\n-            @Override\n-            public String getDescription() {\n-                return \"Graph files (*.xml)\";\n-            }\n-        };\n+    public ImportAction() {\n+        putValue(Action.SHORT_DESCRIPTION, \"Import from XML...\");\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n@@ -73,64 +48,1 @@\n-        JFileChooser fc = new JFileChooser();\n-        fc.setFileFilter(ImportAction.getFileFilter());\n-        fc.setCurrentDirectory(new File(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT)));\n-        fc.setMultiSelectionEnabled(true);\n-\n-        if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n-            for (final File file : fc.getSelectedFiles()) {\n-                File dir = file;\n-                if (!dir.isDirectory()) {\n-                    dir = dir.getParentFile();\n-                }\n-\n-                Settings.get().put(Settings.DIRECTORY, dir.getAbsolutePath());\n-                try {\n-                    final FileChannel channel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n-                    final ProgressHandle handle = ProgressHandleFactory.createHandle(\"Opening file \" + file.getName());\n-                    handle.start(WORKUNITS);\n-                    final long startTime = System.currentTimeMillis();\n-                    final long start = channel.size();\n-                    ParseMonitor monitor = new ParseMonitor() {\n-                            @Override\n-                            public void updateProgress() {\n-                                try {\n-                                    int prog = (int) (WORKUNITS * (double) channel.position() \/ (double) start);\n-                                    handle.progress(prog);\n-                                } catch (IOException ignored) {}\n-                            }\n-                            @Override\n-                            public void setState(String state) {\n-                                updateProgress();\n-                                handle.progress(state);\n-                            }\n-                        };\n-                    final GraphParser parser;\n-                    final OutlineTopComponent component = OutlineTopComponent.findInstance();\n-                    if (file.getName().endsWith(\".xml\")) {\n-                        parser = new Parser(channel, monitor, null);\n-                    } else {\n-                        parser = null;\n-                    }\n-                    RequestProcessor.getDefault().post(new Runnable() {\n-                            @Override\n-                            public void run() {\n-                                try {\n-                                    final GraphDocument document = parser.parse();\n-                                    if (document != null) {\n-                                        SwingUtilities.invokeLater(() -> {\n-                                            component.requestActive();\n-                                            component.getDocument().addGraphDocument(document);\n-                                        });\n-                                    }\n-                                } catch (IOException ex) {\n-                                    Exceptions.printStackTrace(ex);\n-                                }\n-                                handle.finish();\n-                                long stop = System.currentTimeMillis();\n-                                Logger.getLogger(getClass().getName()).log(Level.INFO, \"Loaded in \" + file + \" in \" + ((stop - startTime) \/ 1000.0) + \" seconds\");\n-                            }\n-                        });\n-                } catch (IOException ex) {\n-                    Exceptions.printStackTrace(ex);\n-                }\n-            }\n-        }\n+        OutlineTopComponent.findInstance().importFromXML();\n@@ -144,6 +56,0 @@\n-    public ImportAction() {\n-        putValue(Action.SHORT_DESCRIPTION, \"Open\");\n-        \/\/ D is the Control key on most platforms, the Command (meta) key on Macintosh\n-        putValue(Action.ACCELERATOR_KEY, Utilities.stringToKey(\"D-O\"));\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/ImportAction.java","additions":8,"deletions":102,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package com.sun.hotspot.igv.coordinator.actions;\n+\n+import com.sun.hotspot.igv.coordinator.OutlineTopComponent;\n+import javax.swing.Action;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.NbBundle;\n+import org.openide.util.Utilities;\n+import org.openide.util.actions.CallableSystemAction;\n+\n+public final class OpenAction extends CallableSystemAction {\n+\n+    public OpenAction() {\n+        putValue(Action.SHORT_DESCRIPTION, \"Open...\");\n+        \/\/ D is the Control key on most platforms, the Command (meta) key on Macintosh\n+        putValue(Action.ACCELERATOR_KEY, Utilities.stringToKey(\"D-O\"));\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n+    }\n+\n+    @Override\n+    public void performAction() {\n+        OutlineTopComponent.findInstance().openFile();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return NbBundle.getMessage(OpenAction.class, \"CTL_OpenAction\");\n+    }\n+\n+    @Override\n+    public HelpCtx getHelpCtx() {\n+        return HelpCtx.DEFAULT_HELP;\n+    }\n+\n+    @Override\n+    protected boolean asynchronous() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected String iconResource() {\n+        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/open.png\";\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/OpenAction.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import org.openide.util.ImageUtilities;\n@@ -40,0 +41,5 @@\n+    public RemoveAction() {\n+        putValue(Action.SHORT_DESCRIPTION, getName());\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n+    }\n+\n@@ -50,4 +56,0 @@\n-    public RemoveAction() {\n-        putValue(Action.SHORT_DESCRIPTION, getName());\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/RemoveAction.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import org.openide.util.ImageUtilities;\n@@ -45,1 +46,2 @@\n-        putValue(Action.SHORT_DESCRIPTION, \"Remove all graphs and groups\");\n+        putValue(Action.SHORT_DESCRIPTION, \"Clear workspace\");\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n@@ -65,1 +67,1 @@\n-        OutlineTopComponent.findInstance().clear();\n+        OutlineTopComponent.findInstance().clearWorkspace();\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/RemoveAllAction.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.hotspot.igv.coordinator.actions;\n+\n+import com.sun.hotspot.igv.coordinator.OutlineTopComponent;\n+import javax.swing.Action;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.NbBundle;\n+import org.openide.util.Utilities;\n+import org.openide.util.actions.CallableSystemAction;\n+\n+\n+public final class SaveAction extends CallableSystemAction {\n+\n+    public SaveAction() {\n+        putValue(Action.SHORT_DESCRIPTION, \"Save\");\n+        \/\/ D is the Control key on most platforms, the Command (meta) key on Macintosh\n+        putValue(Action.ACCELERATOR_KEY, Utilities.stringToKey(\"D-S\"));\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n+    }\n+\n+    @Override\n+    public void performAction() {\n+        OutlineTopComponent.findInstance().save();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return NbBundle.getMessage(SaveAction.class, \"CTL_SaveAction\");\n+    }\n+\n+    @Override\n+    protected String iconResource() {\n+        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/save.png\";\n+    }\n+\n+    @Override\n+    public HelpCtx getHelpCtx() {\n+        return HelpCtx.DEFAULT_HELP;\n+    }\n+\n+    @Override\n+    protected boolean asynchronous() {\n+        return false;\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAction.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.hotspot.igv.coordinator.actions;\n-\n-import com.sun.hotspot.igv.coordinator.OutlineTopComponent;\n-import javax.swing.Action;\n-import org.openide.util.HelpCtx;\n-import org.openide.util.NbBundle;\n-import org.openide.util.Utilities;\n-import org.openide.util.actions.CallableSystemAction;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-\n-public final class SaveAllAction extends CallableSystemAction {\n-\n-    @Override\n-    public void performAction() {\n-        final OutlineTopComponent component = OutlineTopComponent.findInstance();\n-        SaveAsAction.save(component.getDocument());\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return NbBundle.getMessage(SaveAllAction.class, \"CTL_SaveAllAction\");\n-    }\n-\n-    public SaveAllAction() {\n-        putValue(Action.SHORT_DESCRIPTION, \"Save all groups to XML file...\");\n-        \/\/ D is the Control key on most platforms, the Command (meta) key on Macintosh\n-        putValue(Action.ACCELERATOR_KEY, Utilities.stringToKey(\"D-S\"));\n-    }\n-\n-    @Override\n-    protected String iconResource() {\n-        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/saveall.gif\";\n-    }\n-\n-    @Override\n-    public HelpCtx getHelpCtx() {\n-        return HelpCtx.DEFAULT_HELP;\n-    }\n-\n-    @Override\n-    protected boolean asynchronous() {\n-        return false;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAllAction.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,11 +27,1 @@\n-import com.sun.hotspot.igv.coordinator.FolderNode;\n-import com.sun.hotspot.igv.data.Folder;\n-import com.sun.hotspot.igv.data.GraphDocument;\n-import com.sun.hotspot.igv.data.Group;\n-import com.sun.hotspot.igv.data.serialization.Printer;\n-import com.sun.hotspot.igv.settings.Settings;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.OutputStreamWriter;\n-import java.io.Writer;\n-import java.nio.file.Files;\n+import com.sun.hotspot.igv.coordinator.OutlineTopComponent;\n@@ -39,2 +29,0 @@\n-import javax.swing.JFileChooser;\n-import org.openide.nodes.Node;\n@@ -42,0 +30,1 @@\n+import org.openide.util.ImageUtilities;\n@@ -43,1 +32,1 @@\n-import org.openide.util.actions.NodeAction;\n+import org.openide.util.actions.CallableSystemAction;\n@@ -49,1 +38,1 @@\n-public final class SaveAsAction extends NodeAction {\n+public final class SaveAsAction extends CallableSystemAction {\n@@ -52,1 +41,2 @@\n-        putValue(Action.SHORT_DESCRIPTION, \"Save selected groups to XML file...\");\n+        putValue(Action.SHORT_DESCRIPTION, \"Save as...\");\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n@@ -56,40 +46,2 @@\n-    protected void performAction(Node[] activatedNodes) {\n-        GraphDocument doc = new GraphDocument();\n-        for (Node node : activatedNodes) {\n-            if (node instanceof FolderNode) {\n-                FolderNode folderNode = (FolderNode) node;\n-                Folder folder = folderNode.getFolder();\n-                if (folder instanceof Group) {\n-                    Group group = (Group) folder;\n-                    doc.addElement(group);\n-                }\n-            }\n-        }\n-        save(doc);\n-    }\n-\n-    public static void save(GraphDocument doc) {\n-        JFileChooser fc = new JFileChooser();\n-        fc.setFileFilter(ImportAction.getFileFilter());\n-        fc.setCurrentDirectory(new File(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT)));\n-\n-        if (fc.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {\n-            File file = fc.getSelectedFile();\n-            if (!file.getName().contains(\".\")) {\n-                file = new File(file.getAbsolutePath() + \".xml\");\n-            }\n-\n-            File dir = file;\n-            if (!dir.isDirectory()) {\n-                dir = dir.getParentFile();\n-            }\n-            Settings.get().put(Settings.DIRECTORY, dir.getAbsolutePath());\n-            try {\n-                try (Writer writer = new OutputStreamWriter(Files.newOutputStream(file.toPath()))) {\n-                    Printer p = new Printer();\n-                    p.export(writer, doc);\n-                }\n-            } catch (IOException e) {\n-                e.printStackTrace();\n-            }\n-        }\n+    public void performAction() {\n+        OutlineTopComponent.findInstance().saveAs();\n@@ -105,1 +57,1 @@\n-        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/save.png\";\n+        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/save_as.gif\";\n@@ -117,13 +69,0 @@\n-\n-    @Override\n-    protected boolean enable(Node[] nodes) {\n-        if (nodes.length > 0) {\n-            for (Node n : nodes) {\n-                if (!(n instanceof FolderNode) || ((FolderNode) n).isRootNode()) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAsAction.java","additions":10,"deletions":71,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -1,5 +1,2 @@\n-AdvancedOption_DisplayName_Coordinator=Settings\n-AdvancedOption_Tooltip_Coordinator=Visualization Tool Settings\n-CTL_OutlineTopComponent=Outline\n-CTL_SomeAction=test\n-HINT_OutlineTopComponent=Displays loaded groups of graphs.\n+CTL_OutlineTopComponent=Workspace\n+HINT_OutlineTopComponent=Opened groups of graphs.\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/Bundle.properties","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,1 +1,2 @@\n-CTL_ImportAction=Open...\n+CTL_ImportAction=Import...\n+CTL_OpenAction=Open...\n@@ -4,4 +5,4 @@\n-CTL_RemoveAllAction=Remove all graphs and groups\n-CTL_OutlineAction=Outline\n-CTL_SaveAsAction=Save selected groups...\n-CTL_SaveAllAction=Save all groups...\n+CTL_RemoveAllAction=Clear workspace\n+CTL_OutlineAction=Workspace\n+CTL_SaveAction=Save\n+CTL_SaveAsAction=Save as...\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/actions\/Bundle.properties","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/images\/import.png","binary":true,"status":"modified"},{"filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/images\/open.png","binary":true,"status":"added"},{"patch":"","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/images\/save_as.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/images\/saveall.gif","status":"renamed"},{"patch":"@@ -29,0 +29,2 @@\n+            <file name=\"com-sun-hotspot-igv-coordinator-actions-OpenAction.instance\"\/>\n+            <file name=\"com-sun-hotspot-igv-coordinator-actions-SaveAction.instance\"\/>\n@@ -30,1 +32,0 @@\n-            <file name=\"com-sun-hotspot-igv-coordinator-actions-SaveAllAction.instance\"\/>\n@@ -58,0 +59,4 @@\n+            <file name=\"com-sun-hotspot-igv-coordinator-actions-OpenAction.shadow\">\n+                <attr name=\"originalFile\" stringvalue=\"Actions\/File\/com-sun-hotspot-igv-coordinator-actions-OpenAction.instance\"\/>\n+                <attr name=\"position\" intvalue=\"50\"\/>\n+            <\/file>\n@@ -74,0 +79,4 @@\n+            <file name=\"com-sun-hotspot-igv-coordinator-actions-SaveAction.shadow\">\n+                <attr name=\"originalFile\" stringvalue=\"Actions\/File\/com-sun-hotspot-igv-coordinator-actions-SaveAction.instance\"\/>\n+                <attr name=\"position\" intvalue=\"600\"\/>\n+            <\/file>\n@@ -76,5 +85,1 @@\n-                <attr name=\"position\" intvalue=\"500\"\/>\n-            <\/file>\n-            <file name=\"com-sun-hotspot-igv-coordinator-actions-SaveAllAction.shadow\">\n-                <attr name=\"originalFile\" stringvalue=\"Actions\/File\/com-sun-hotspot-igv-coordinator-actions-SaveAllAction.instance\"\/>\n-                <attr name=\"position\" intvalue=\"600\"\/>\n+                <attr name=\"position\" intvalue=\"650\"\/>\n@@ -108,1 +113,0 @@\n-            <file name=\"org-openide-actions-SaveAllAction.shadow_hidden\"\/>\n@@ -110,0 +114,1 @@\n+            <file name=\"org-openide-actions-SaveAllAction.shadow_hidden\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/layer.xml","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-public interface Folder {\n+public interface Folder extends Properties.Provider {\n@@ -36,0 +36,1 @@\n+    Properties getProperties();\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Folder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-public interface FolderElement {\n+public interface FolderElement extends Properties.Provider {\n@@ -33,0 +33,1 @@\n+    Properties getProperties();\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/FolderElement.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-            for (FolderElement e : document.elements) {\n+            for (FolderElement e : document.getElements()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/GraphDocument.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,1 @@\n-        String displayName = (getParent() == null ? \"\" : getParent().getElements().indexOf(this) + 1 + \" - \") + getName();\n+        String displayName = (getParent() == null ? \"\" : getIndex() + 1 + \" - \") + getName();\n@@ -136,0 +136,9 @@\n+    public int getIndex() {\n+        Folder parent = getParent();\n+        if (parent != null) {\n+            return parent.getElements().indexOf(this);\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Group.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/GraphParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.data.Properties;\n@@ -27,0 +28,2 @@\n+import com.sun.hotspot.igv.data.serialization.Printer.GraphContext;\n+import com.sun.hotspot.igv.data.serialization.Printer.GraphContextAction;\n@@ -30,1 +33,0 @@\n-import com.sun.hotspot.igv.data.services.GroupCallback;\n@@ -34,4 +36,3 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -52,1 +53,0 @@\n-    public static final String INDENT = \"  \";\n@@ -56,0 +56,4 @@\n+    public static final String GRAPH_STATES_ELEMENT = \"graphStates\";\n+    public static final String STATE_ELEMENT = \"state\";\n+    public static final String STATE_POSITION_DIFFERENCE = \"difference\";\n+    public static final String POSITION_DIFFERENCE_PROPERTY = \"value\";\n@@ -63,0 +67,2 @@\n+    public static final String VISIBLE_NODES_ELEMENT = \"visibleNodes\";\n+    public static final String ALL_PROPERTY = \"all\";\n@@ -66,6 +72,0 @@\n-    public static final String GROUP_NAME_PROPERTY = \"name\";\n-    public static final String METHOD_IS_PUBLIC_PROPERTY = \"public\";\n-    public static final String METHOD_IS_STATIC_PROPERTY = \"static\";\n-    public static final String TRUE_VALUE = \"true\";\n-    public static final String NODE_NAME_PROPERTY = \"name\";\n-    public static final String EDGE_NAME_PROPERTY = \"name\";\n@@ -92,1 +92,0 @@\n-    public static final String ASSEMBLY_ELEMENT = \"assembly\";\n@@ -94,1 +93,1 @@\n-    private final TopElementHandler<GraphDocument> xmlDocument = new TopElementHandler<>();\n+    private final TopElementHandler<GraphDocument> xmlData = new TopElementHandler<>();\n@@ -97,1 +96,3 @@\n-    private final GroupCallback groupCallback;\n+    private final GraphDocument callbackDocument;\n+    private final GraphContextAction contextAction;\n+    private final Set<GraphContext> contexts = new HashSet<>();\n@@ -100,2 +101,0 @@\n-    private int maxId = 0;\n-    private GraphDocument graphDocument;\n@@ -106,55 +105,0 @@\n-    private int lookupID(String i) {\n-        try {\n-            return Integer.parseInt(i);\n-        } catch (NumberFormatException nfe) {\n-            \/\/ ignore\n-        }\n-        Integer id = idCache.get(i);\n-        if (id == null) {\n-            id = maxId++;\n-            idCache.put(i, id);\n-        }\n-        return id;\n-    }\n-\n-    \/\/ <graphDocument>\n-    private ElementHandler<GraphDocument, Object> topHandler = new ElementHandler<GraphDocument, Object>(TOP_ELEMENT) {\n-\n-        @Override\n-        protected GraphDocument start() throws SAXException {\n-            graphDocument = new GraphDocument();\n-            return graphDocument;\n-        }\n-    };\n-    \/\/ <group>\n-    private ElementHandler<Group, Folder> groupHandler = new XMLParser.ElementHandler<Group, Folder>(GROUP_ELEMENT) {\n-\n-        @Override\n-        protected Group start() throws SAXException {\n-            final Group group = new Group(this.getParentObject());\n-\n-            String differenceProperty = this.readAttribute(DIFFERENCE_PROPERTY);\n-            Parser.this.differenceEncoding.put(group, (differenceProperty != null && (differenceProperty.equals(\"1\") || differenceProperty.equals(\"true\"))));\n-\n-            ParseMonitor monitor = getMonitor();\n-            if (monitor != null) {\n-                monitor.setState(group.getName());\n-            }\n-\n-            final Folder parent = getParentObject();\n-            if (groupCallback == null || parent instanceof Group) {\n-                Runnable addToParent = () -> parent.addElement(group);\n-                if (invokeLater) {\n-                    SwingUtilities.invokeLater(addToParent);\n-                } else {\n-                    addToParent.run();\n-                }\n-            }\n-\n-            return group;\n-        }\n-\n-        @Override\n-        protected void end(String text) throws SAXException {\n-        }\n-    };\n@@ -162,1 +106,1 @@\n-    private ElementHandler<InputMethod, Group> methodHandler = new XMLParser.ElementHandler<InputMethod, Group>(METHOD_ELEMENT) {\n+    private final ElementHandler<InputMethod, Group> methodHandler = new XMLParser.ElementHandler<>(METHOD_ELEMENT) {\n@@ -166,3 +110,3 @@\n-\n-            InputMethod method = parseMethod(this, getParentObject());\n-            getParentObject().setMethod(method);\n+            Group group = getParentObject();\n+            InputMethod method = parseMethod(this, group);\n+            group.setMethod(method);\n@@ -172,12 +116,0 @@\n-\n-    private InputMethod parseMethod(XMLParser.ElementHandler<?,?> handler, Group group) throws SAXException {\n-        String s = handler.readRequiredAttribute(METHOD_BCI_PROPERTY);\n-        int bci = 0;\n-        try {\n-            bci = Integer.parseInt(s);\n-        } catch (NumberFormatException e) {\n-            throw new SAXException(e);\n-        }\n-        InputMethod method = new InputMethod(group, handler.readRequiredAttribute(METHOD_NAME_PROPERTY), handler.readRequiredAttribute(METHOD_SHORT_NAME_PROPERTY), bci);\n-        return method;\n-    }\n@@ -185,1 +117,1 @@\n-    private HandoverElementHandler<InputMethod> bytecodesHandler = new XMLParser.HandoverElementHandler<InputMethod>(BYTECODES_ELEMENT, true) {\n+    private final HandoverElementHandler<InputMethod> bytecodesHandler = new XMLParser.HandoverElementHandler<>(BYTECODES_ELEMENT, true) {\n@@ -188,1 +120,1 @@\n-        protected void end(String text) throws SAXException {\n+        protected void end(String text) {\n@@ -193,1 +125,1 @@\n-    private HandoverElementHandler<InputMethod> inlinedHandler = new XMLParser.HandoverElementHandler<>(INLINE_ELEMENT);\n+    private final HandoverElementHandler<InputMethod> inlinedHandler = new XMLParser.HandoverElementHandler<>(INLINE_ELEMENT);\n@@ -195,1 +127,1 @@\n-    private ElementHandler<InputMethod, InputMethod> inlinedMethodHandler = new XMLParser.ElementHandler<InputMethod, InputMethod>(METHOD_ELEMENT) {\n+    private final ElementHandler<InputMethod, InputMethod> inlinedMethodHandler = new XMLParser.ElementHandler<>(METHOD_ELEMENT) {\n@@ -204,2 +136,6 @@\n-    \/\/ <graph>\n-    private ElementHandler<InputGraph, Group> graphHandler = new XMLParser.ElementHandler<InputGraph, Group>(GRAPH_ELEMENT) {\n+    \/\/ <nodes>\n+    private final HandoverElementHandler<InputGraph> nodesHandler = new HandoverElementHandler<>(NODES_ELEMENT);\n+    \/\/ <controlFlow>\n+    private final HandoverElementHandler<InputGraph> controlFlowHandler = new HandoverElementHandler<>(CONTROL_FLOW_ELEMENT);\n+    private final HandoverElementHandler<InputGraph> graphStatesHandler = new HandoverElementHandler<>(GRAPH_STATES_ELEMENT);\n+    private final ElementHandler<GraphContext, InputGraph> stateHandler = new ElementHandler<>(STATE_ELEMENT) {\n@@ -208,18 +144,5 @@\n-        protected InputGraph start() throws SAXException {\n-            String name = readAttribute(GRAPH_NAME_PROPERTY);\n-            InputGraph curGraph = new InputGraph(name);\n-            if (differenceEncoding.get(getParentObject())) {\n-                InputGraph previous = lastParsedGraph.get(getParentObject());\n-                lastParsedGraph.put(getParentObject(), curGraph);\n-                if (previous != null) {\n-                    for (InputNode n : previous.getNodes()) {\n-                        curGraph.addNode(n);\n-                    }\n-                    for (InputEdge e : previous.getEdges()) {\n-                        curGraph.addEdge(e);\n-                    }\n-                }\n-            }\n-            ParseMonitor monitor = getMonitor();\n-            if (monitor != null) {\n-                monitor.updateProgress();\n+        protected GraphContext start() {\n+            InputGraph inputGraph = getParentObject();\n+            GraphContext graphContext = new GraphContext(inputGraph, new AtomicInteger(0), new HashSet<>(), new AtomicBoolean(false));\n+            if (contextAction != null) {\n+                contexts.add(graphContext);\n@@ -227,1 +150,1 @@\n-            return curGraph;\n+            return graphContext;\n@@ -229,0 +152,2 @@\n+    };\n+    private final ElementHandler<GraphContext, GraphContext> visibleNodesHandler = new ElementHandler<>(VISIBLE_NODES_ELEMENT) {\n@@ -231,38 +156,7 @@\n-        protected void end(String text) throws SAXException {\n-            \/\/ NOTE: Some graphs intentionally don't provide blocks. Instead\n-            \/\/       they later generate the blocks from other information such\n-            \/\/       as node properties (example: ServerCompilerScheduler).\n-            \/\/       Thus, we shouldn't assign nodes that don't belong to any\n-            \/\/       block to some artificial block below unless blocks are\n-            \/\/       defined and nodes are assigned to them.\n-\n-            final InputGraph graph = getObject();\n-            final Group parent = getParentObject();\n-            if (graph.getBlocks().size() > 0) {\n-                boolean blocksContainNodes = false;\n-                for (InputBlock b : graph.getBlocks()) {\n-                    if (b.getNodes().size() > 0) {\n-                        blocksContainNodes = true;\n-                        break;\n-                    }\n-                }\n-\n-                if (!blocksContainNodes) {\n-                    graph.clearBlocks();\n-                    blockConnections.clear();\n-                } else {\n-                    \/\/ Blocks and their nodes defined: add other nodes to an\n-                    \/\/  artificial \"no block\" block\n-                    InputBlock noBlock = null;\n-                    for (InputNode n : graph.getNodes()) {\n-                        if (graph.getBlock(n) == null) {\n-                            if (noBlock == null) {\n-                                noBlock = graph.addArtificialBlock();\n-                            }\n-\n-                            noBlock.addNode(n.getId());\n-                        }\n-\n-                        assert graph.getBlock(n) != null;\n-                    }\n-                }\n+        protected GraphContext start() throws SAXException {\n+            String s = readRequiredAttribute(ALL_PROPERTY);\n+            try {\n+                boolean all = Boolean.parseBoolean(s);\n+                getParentObject().showAll().set(all);\n+            } catch (NumberFormatException e) {\n+                throw new SAXException(e);\n@@ -270,0 +164,4 @@\n+            return getParentObject();\n+        }\n+    };\n+    private final ElementHandler<GraphContext, GraphContext> visibleNodeHandler = new ElementHandler<>(NODE_ELEMENT) {\n@@ -271,7 +169,8 @@\n-            \/\/ Resolve block successors\n-            for (Pair<String, String> p : blockConnections) {\n-                final InputBlock left = graph.getBlock(p.getLeft());\n-                assert left != null;\n-                final InputBlock right = graph.getBlock(p.getRight());\n-                assert right != null;\n-                graph.addBlockEdge(left, right);\n+        @Override\n+        protected GraphContext start() throws SAXException {\n+            String s = readRequiredAttribute(NODE_ID_PROPERTY);\n+            int nodeID;\n+            try {\n+                nodeID = Integer.parseInt(s);\n+            } catch (NumberFormatException e) {\n+                throw new SAXException(e);\n@@ -279,1 +178,5 @@\n-            blockConnections.clear();\n+            getParentObject().visibleNodes().add(nodeID);\n+            return getParentObject();\n+        }\n+    };\n+    private final ElementHandler<GraphContext, GraphContext> differenceHandler = new ElementHandler<>(STATE_POSITION_DIFFERENCE) {\n@@ -281,5 +184,8 @@\n-            Runnable addToParent = () -> parent.addElement(graph);\n-            if (invokeLater) {\n-                SwingUtilities.invokeLater(addToParent);\n-            } else {\n-                addToParent.run();\n+        @Override\n+        protected GraphContext start() throws SAXException {\n+            String s = readRequiredAttribute(POSITION_DIFFERENCE_PROPERTY);\n+            int posDiff;\n+            try {\n+                posDiff = Integer.parseInt(s);\n+            } catch (NumberFormatException e) {\n+                throw new SAXException(e);\n@@ -287,0 +193,2 @@\n+            getParentObject().posDiff().set(posDiff);\n+            return getParentObject();\n@@ -289,4 +197,0 @@\n-    \/\/ <nodes>\n-    private HandoverElementHandler<InputGraph> nodesHandler = new HandoverElementHandler<>(NODES_ELEMENT);\n-    \/\/ <controlFlow>\n-    private HandoverElementHandler<InputGraph> controlFlowHandler = new HandoverElementHandler<>(CONTROL_FLOW_ELEMENT);\n@@ -294,1 +198,1 @@\n-    private ElementHandler<InputBlock, InputGraph> blockHandler = new ElementHandler<InputBlock, InputGraph>(BLOCK_ELEMENT) {\n+    private final ElementHandler<InputBlock, InputGraph> blockHandler = new ElementHandler<>(BLOCK_ELEMENT) {\n@@ -308,1 +212,50 @@\n-    private HandoverElementHandler<InputBlock> blockNodesHandler = new HandoverElementHandler<>(NODES_ELEMENT);\n+    private final HandoverElementHandler<InputBlock> blockNodesHandler = new HandoverElementHandler<>(NODES_ELEMENT);\n+    \/\/ <successors>\n+    private final HandoverElementHandler<InputBlock> successorsHandler = new HandoverElementHandler<>(SUCCESSORS_ELEMENT);\n+    \/\/ <successor>\n+    private final ElementHandler<InputBlock, InputBlock> successorHandler = new ElementHandler<>(SUCCESSOR_ELEMENT) {\n+\n+        @Override\n+        protected InputBlock start() throws SAXException {\n+            String name = readRequiredAttribute(BLOCK_NAME_PROPERTY);\n+            blockConnections.add(new Pair<>(getParentObject().getName(), name));\n+            return getParentObject();\n+        }\n+    };\n+    \/\/ <graph>\n+    private final HandoverElementHandler<InputGraph> edgesHandler = new HandoverElementHandler<>(EDGES_ELEMENT);\n+    \/\/ <edge>\n+    private final EdgeElementHandler edgeHandler = new EdgeElementHandler(EDGE_ELEMENT) {\n+\n+        @Override\n+        protected InputEdge start(InputEdge conn) {\n+            InputGraph inputGraph = getParentObject();\n+            inputGraph.addEdge(conn);\n+            return conn;\n+        }\n+    };\n+    \/\/ <removeEdge>\n+    private final EdgeElementHandler removeEdgeHandler = new EdgeElementHandler(REMOVE_EDGE_ELEMENT) {\n+\n+        @Override\n+        protected InputEdge start(InputEdge conn) {\n+            getParentObject().removeEdge(conn);\n+            return conn;\n+        }\n+    };\n+    \/\/ <properties>\n+    private final HandoverElementHandler<Properties.Provider> propertiesHandler = new HandoverElementHandler<>(PROPERTIES_ELEMENT);\n+    \/\/ <property>\n+    private final ElementHandler<String, Properties.Provider> propertyHandler = new XMLParser.ElementHandler<>(PROPERTY_ELEMENT, true) {\n+\n+        @Override\n+        public String start() throws SAXException {\n+            return readRequiredAttribute(PROPERTY_NAME_PROPERTY);\n+        }\n+\n+        @Override\n+        public void end(String text) {\n+            getParentObject().getProperties().setProperty(getObject(), text.trim());\n+        }\n+    };\n+    private int maxId = 0;\n@@ -310,1 +263,1 @@\n-    private ElementHandler<InputBlock, InputBlock> blockNodeHandler = new ElementHandler<InputBlock, InputBlock>(NODE_ELEMENT) {\n+    private final ElementHandler<InputBlock, InputBlock> blockNodeHandler = new ElementHandler<>(NODE_ELEMENT) {\n@@ -316,1 +269,1 @@\n-            int id = 0;\n+            int id;\n@@ -326,12 +279,0 @@\n-    \/\/ <successors>\n-    private HandoverElementHandler<InputBlock> successorsHandler = new HandoverElementHandler<>(SUCCESSORS_ELEMENT);\n-    \/\/ <successor>\n-    private ElementHandler<InputBlock, InputBlock> successorHandler = new ElementHandler<InputBlock, InputBlock>(SUCCESSOR_ELEMENT) {\n-\n-        @Override\n-        protected InputBlock start() throws SAXException {\n-            String name = readRequiredAttribute(BLOCK_NAME_PROPERTY);\n-            blockConnections.add(new Pair<>(getParentObject().getName(), name));\n-            return getParentObject();\n-        }\n-    };\n@@ -339,1 +280,1 @@\n-    private ElementHandler<InputNode, InputGraph> nodeHandler = new ElementHandler<InputNode, InputGraph>(NODE_ELEMENT) {\n+    private final ElementHandler<InputNode, InputGraph> nodeHandler = new ElementHandler<>(NODE_ELEMENT) {\n@@ -344,1 +285,1 @@\n-            int id = 0;\n+            int id;\n@@ -356,1 +297,1 @@\n-    private ElementHandler<InputNode, InputGraph> removeNodeHandler = new ElementHandler<InputNode, InputGraph>(REMOVE_NODE_ELEMENT) {\n+    private final ElementHandler<InputNode, InputGraph> removeNodeHandler = new ElementHandler<>(REMOVE_NODE_ELEMENT) {\n@@ -361,1 +302,1 @@\n-            int id = 0;\n+            int id;\n@@ -370,5 +311,3 @@\n-    \/\/ <graph>\n-    private HandoverElementHandler<InputGraph> edgesHandler = new HandoverElementHandler<>(EDGES_ELEMENT);\n-\n-    \/\/ Local class for edge elements\n-    private class EdgeElementHandler extends ElementHandler<InputEdge, InputGraph> {\n+    private GraphDocument graphDocument;\n+    \/\/ <graphDocument>\n+    private final ElementHandler<GraphDocument, Object> topHandler = new ElementHandler<>(TOP_ELEMENT) {\n@@ -376,2 +315,4 @@\n-        public EdgeElementHandler(String name) {\n-            super(name);\n+        @Override\n+        protected GraphDocument start() {\n+            graphDocument = new GraphDocument();\n+            return graphDocument;\n@@ -379,0 +320,3 @@\n+    };\n+    \/\/ <group>\n+    private final ElementHandler<Group, Folder> groupHandler = new XMLParser.ElementHandler<>(GROUP_ELEMENT) {\n@@ -381,7 +325,3 @@\n-        protected InputEdge start() throws SAXException {\n-            int fromIndex = 0;\n-            int toIndex = 0;\n-            int from = -1;\n-            int to = -1;\n-            String label = null;\n-            String type = null;\n+        protected Group start() {\n+            final Folder folder = getParentObject();\n+            final Group group = new Group(folder);\n@@ -389,16 +329,2 @@\n-            try {\n-                String fromIndexString = readAttribute(FROM_INDEX_PROPERTY);\n-                if (fromIndexString != null) {\n-                    fromIndex = Integer.parseInt(fromIndexString);\n-                }\n-\n-                String toIndexString = readAttribute(TO_INDEX_PROPERTY);\n-                if (toIndexString == null) {\n-                    toIndexString = readAttribute(TO_INDEX_ALT_PROPERTY);\n-                }\n-                if (toIndexString != null) {\n-                    toIndex = Integer.parseInt(toIndexString);\n-                }\n-\n-                label = readAttribute(LABEL_PROPERTY);\n-                type = readAttribute(TYPE_PROPERTY);\n+            String differenceProperty = this.readAttribute(DIFFERENCE_PROPERTY);\n+            Parser.this.differenceEncoding.put(group, (differenceProperty != null && (differenceProperty.equals(\"1\") || differenceProperty.equals(\"true\"))));\n@@ -406,4 +332,3 @@\n-                from = lookupID(readRequiredAttribute(FROM_PROPERTY));\n-                to = lookupID(readRequiredAttribute(TO_PROPERTY));\n-            } catch (NumberFormatException e) {\n-                throw new SAXException(e);\n+            ParseMonitor monitor = getMonitor();\n+            if (monitor != null) {\n+                monitor.setState(group.getName());\n@@ -412,3 +337,7 @@\n-            InputEdge conn = new InputEdge((char) fromIndex, (char) toIndex, from, to, label, type == null ? \"\" : type);\n-            return start(conn);\n-        }\n+            if (callbackDocument == null || folder instanceof Group) {\n+                if (invokeLater) {\n+                    SwingUtilities.invokeLater(() -> folder.addElement(group));\n+                } else {\n+                    folder.addElement(group);\n+                }\n+            }\n@@ -416,2 +345,1 @@\n-        protected InputEdge start(InputEdge conn) throws SAXException {\n-            return conn;\n+            return group;\n@@ -419,3 +347,0 @@\n-    }\n-    \/\/ <edge>\n-    private EdgeElementHandler edgeHandler = new EdgeElementHandler(EDGE_ELEMENT) {\n@@ -424,3 +349,1 @@\n-        protected InputEdge start(InputEdge conn) throws SAXException {\n-            getParentObject().addEdge(conn);\n-            return conn;\n+        protected void end(String text) {\n@@ -429,2 +352,2 @@\n-    \/\/ <removeEdge>\n-    private EdgeElementHandler removeEdgeHandler = new EdgeElementHandler(REMOVE_EDGE_ELEMENT) {\n+    \/\/ <graph>\n+    private final ElementHandler<InputGraph, Group> graphHandler = new XMLParser.ElementHandler<>(GRAPH_ELEMENT) {\n@@ -433,3 +356,21 @@\n-        protected InputEdge start(InputEdge conn) throws SAXException {\n-            getParentObject().removeEdge(conn);\n-            return conn;\n+        protected InputGraph start() {\n+            Group group = getParentObject();\n+            String name = readAttribute(GRAPH_NAME_PROPERTY);\n+            InputGraph curGraph = new InputGraph(name);\n+            if (differenceEncoding.get(group)) {\n+                InputGraph previous = lastParsedGraph.get(group);\n+                lastParsedGraph.put(group, curGraph);\n+                if (previous != null) {\n+                    for (InputNode n : previous.getNodes()) {\n+                        curGraph.addNode(n);\n+                    }\n+                    for (InputEdge e : previous.getEdges()) {\n+                        curGraph.addEdge(e);\n+                    }\n+                }\n+            }\n+            ParseMonitor monitor = getMonitor();\n+            if (monitor != null) {\n+                monitor.updateProgress();\n+            }\n+            return curGraph;\n@@ -437,5 +378,0 @@\n-    };\n-    \/\/ <properties>\n-    private HandoverElementHandler<Properties.Provider> propertiesHandler = new HandoverElementHandler<>(PROPERTIES_ELEMENT);\n-    \/\/ <properties>\n-    private HandoverElementHandler<Group> groupPropertiesHandler = new HandoverElementHandler<Group>(PROPERTIES_ELEMENT) {\n@@ -444,6 +380,23 @@\n-        public void end(String text) throws SAXException {\n-            if (groupCallback != null && getParentObject().getParent() instanceof GraphDocument) {\n-                final Group group = getParentObject();\n-                Runnable addStarted = () -> groupCallback.started(group);\n-                if (invokeLater) {\n-                    SwingUtilities.invokeLater(addStarted);\n+        protected void end(String text) {\n+            \/\/ NOTE: Some graphs intentionally don't provide blocks. Instead,\n+            \/\/       they later generate the blocks from other information such\n+            \/\/       as node properties (example: ServerCompilerScheduler).\n+            \/\/       Thus, we shouldn't assign nodes that don't belong to any\n+            \/\/       block to some artificial block below unless blocks are\n+            \/\/       defined and nodes are assigned to them.\n+\n+            final InputGraph graph = getObject();\n+\n+            final Group parent = getParentObject();\n+            if (!graph.getBlocks().isEmpty()) {\n+                boolean blocksContainNodes = false;\n+                for (InputBlock b : graph.getBlocks()) {\n+                    if (!b.getNodes().isEmpty()) {\n+                        blocksContainNodes = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (!blocksContainNodes) {\n+                    graph.clearBlocks();\n+                    blockConnections.clear();\n@@ -451,1 +404,14 @@\n-                    addStarted.run();\n+                    \/\/ Blocks and their nodes defined: add other nodes to an\n+                    \/\/  artificial \"no block\" block\n+                    InputBlock noBlock = null;\n+                    for (InputNode n : graph.getNodes()) {\n+                        if (graph.getBlock(n) == null) {\n+                            if (noBlock == null) {\n+                                noBlock = graph.addArtificialBlock();\n+                            }\n+\n+                            noBlock.addNode(n.getId());\n+                        }\n+\n+                        assert graph.getBlock(n) != null;\n+                    }\n@@ -454,0 +420,22 @@\n+\n+            \/\/ Resolve block successors\n+            for (Pair<String, String> p : blockConnections) {\n+                final InputBlock left = graph.getBlock(p.getLeft());\n+                assert left != null;\n+                final InputBlock right = graph.getBlock(p.getRight());\n+                assert right != null;\n+                graph.addBlockEdge(left, right);\n+            }\n+            blockConnections.clear();\n+\n+            if (invokeLater) {\n+                SwingUtilities.invokeLater(() -> parent.addElement(graph));\n+            } else {\n+                parent.addElement(graph);\n+            }\n+            if (contextAction != null) {\n+                for (GraphContext ctx : contexts) {\n+                    contextAction.performAction(ctx);\n+                }\n+            }\n+            contexts.clear();\n@@ -456,7 +444,2 @@\n-    \/\/ <property>\n-    private ElementHandler<String, Properties.Provider> propertyHandler = new XMLParser.ElementHandler<String, Properties.Provider>(PROPERTY_ELEMENT, true) {\n-\n-        @Override\n-        public String start() throws SAXException {\n-            return readRequiredAttribute(PROPERTY_NAME_PROPERTY);\n-         }\n+    \/\/ <properties>\n+    private final HandoverElementHandler<Group> groupPropertiesHandler = new HandoverElementHandler<>(PROPERTIES_ELEMENT) {\n@@ -466,1 +449,9 @@\n-            getParentObject().getProperties().setProperty(getObject(), text.trim());\n+            final Group group = getParentObject();\n+            if (callbackDocument != null && group.getParent() instanceof GraphDocument) {\n+                group.setParent(callbackDocument);\n+                if (invokeLater) {\n+                    SwingUtilities.invokeLater(() -> callbackDocument.addElement(group));\n+                } else {\n+                    callbackDocument.addElement(group);\n+                }\n+            }\n@@ -470,7 +461,3 @@\n-    public Parser(ReadableByteChannel channel) {\n-        this(channel, null, null);\n-    }\n-\n-    public Parser(ReadableByteChannel channel, ParseMonitor monitor, GroupCallback groupCallback) {\n-\n-        this.groupCallback = groupCallback;\n+    public Parser(ReadableByteChannel channel, ParseMonitor monitor, GraphDocument callbackDocument, GraphContextAction contextAction) {\n+        this.callbackDocument = callbackDocument;\n+        this.contextAction = contextAction;\n@@ -481,1 +468,1 @@\n-        xmlDocument.addChild(topHandler);\n+        xmlData.addChild(topHandler);\n@@ -498,0 +485,1 @@\n+        graphHandler.addChild(graphStatesHandler);\n@@ -501,0 +489,5 @@\n+        graphStatesHandler.addChild(stateHandler);\n+        stateHandler.addChild(differenceHandler);\n+        stateHandler.addChild(visibleNodesHandler);\n+        visibleNodesHandler.addChild(visibleNodeHandler);\n+\n@@ -521,0 +514,25 @@\n+    private int lookupID(String i) {\n+        try {\n+            return Integer.parseInt(i);\n+        } catch (NumberFormatException nfe) {\n+            \/\/ ignore\n+        }\n+        Integer id = idCache.get(i);\n+        if (id == null) {\n+            id = maxId++;\n+            idCache.put(i, id);\n+        }\n+        return id;\n+    }\n+\n+    private InputMethod parseMethod(XMLParser.ElementHandler<?, ?> handler, Group group) throws SAXException {\n+        String s = handler.readRequiredAttribute(METHOD_BCI_PROPERTY);\n+        int bci;\n+        try {\n+            bci = Integer.parseInt(s);\n+        } catch (NumberFormatException e) {\n+            throw new SAXException(e);\n+        }\n+        return new InputMethod(group, handler.readRequiredAttribute(METHOD_NAME_PROPERTY), handler.readRequiredAttribute(METHOD_SHORT_NAME_PROPERTY), bci);\n+    }\n+\n@@ -531,1 +549,1 @@\n-            reader.setContentHandler(new XMLParser(xmlDocument, monitor));\n+            reader.setContentHandler(new XMLParser(xmlData, monitor));\n@@ -541,0 +559,1 @@\n+\n@@ -552,4 +571,4 @@\n-            SAXParserFactory pfactory = SAXParserFactory.newInstance();\n-            pfactory.setValidating(false);\n-            pfactory.setNamespaceAware(true);\n-            return pfactory.newSAXParser().getXMLReader();\n+            SAXParserFactory pFactory = SAXParserFactory.newInstance();\n+            pFactory.setValidating(false);\n+            pFactory.setNamespaceAware(true);\n+            return pFactory.newSAXParser().getXMLReader();\n@@ -560,0 +579,48 @@\n+\n+    \/\/ Local class for edge elements\n+    private class EdgeElementHandler extends ElementHandler<InputEdge, InputGraph> {\n+\n+        public EdgeElementHandler(String name) {\n+            super(name);\n+        }\n+\n+        @Override\n+        protected InputEdge start() throws SAXException {\n+            int fromIndex = 0;\n+            int toIndex = 0;\n+            int from;\n+            int to;\n+            String label;\n+            String type;\n+\n+            try {\n+                String fromIndexString = readAttribute(FROM_INDEX_PROPERTY);\n+                if (fromIndexString != null) {\n+                    fromIndex = Integer.parseInt(fromIndexString);\n+                }\n+\n+                String toIndexString = readAttribute(TO_INDEX_PROPERTY);\n+                if (toIndexString == null) {\n+                    toIndexString = readAttribute(TO_INDEX_ALT_PROPERTY);\n+                }\n+                if (toIndexString != null) {\n+                    toIndex = Integer.parseInt(toIndexString);\n+                }\n+\n+                label = readAttribute(LABEL_PROPERTY);\n+                type = readAttribute(TYPE_PROPERTY);\n+\n+                from = lookupID(readRequiredAttribute(FROM_PROPERTY));\n+                to = lookupID(readRequiredAttribute(TO_PROPERTY));\n+            } catch (NumberFormatException e) {\n+                throw new SAXException(e);\n+            }\n+\n+            InputEdge conn = new InputEdge((char) fromIndex, (char) toIndex, from, to, label, type == null ? \"\" : type);\n+            return start(conn);\n+        }\n+\n+        protected InputEdge start(InputEdge conn) {\n+            return conn;\n+        }\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Parser.java","additions":339,"deletions":272,"binary":false,"changes":611,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.InputStream;\n@@ -32,0 +31,3 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n@@ -39,12 +41,1 @@\n-    private final InputStream in;\n-\n-    public Printer() {\n-        this(null);\n-    }\n-\n-    public Printer(InputStream inputStream) {\n-        this.in = inputStream;\n-    }\n-\n-    public void export(Writer writer, GraphDocument document) {\n-\n+    public static void exportGraphDocument(Writer writer, Folder folder, Set<GraphContext> contexts) {\n@@ -52,1 +43,0 @@\n-\n@@ -54,12 +44,8 @@\n-            export(xmlWriter, document);\n-        } catch (IOException ignored) {}\n-    }\n-\n-    private void export(XMLWriter xmlWriter, GraphDocument document) throws IOException {\n-        xmlWriter.startTag(Parser.ROOT_ELEMENT);\n-        xmlWriter.writeProperties(document.getProperties());\n-        for (FolderElement e : document.getElements()) {\n-            if (e instanceof Group) {\n-                export(xmlWriter, (Group) e);\n-            } else if (e instanceof InputGraph) {\n-                export(xmlWriter, (InputGraph)e, null, false);\n+            xmlWriter.startTag(Parser.ROOT_ELEMENT);\n+            xmlWriter.writeProperties(folder.getProperties());\n+            for (FolderElement e : folder.getElements()) {\n+                if (e instanceof Group group) {\n+                    exportGroup(xmlWriter, group, contexts);\n+                } else if (e instanceof InputGraph graph) {\n+                    exportInputGraph(xmlWriter, graph, null, false, contexts);\n+                }\n@@ -67,4 +53,3 @@\n-        }\n-\n-        xmlWriter.endTag();\n-        xmlWriter.flush();\n+            xmlWriter.endTag();\n+            xmlWriter.flush();\n+        } catch (IOException ignored) {}\n@@ -73,1 +58,1 @@\n-    private void export(XMLWriter writer, Group g) throws IOException {\n+    private static void exportGroup(XMLWriter writer, Group g, Set<GraphContext> contexts) throws IOException {\n@@ -79,6 +64,2 @@\n-        boolean shouldExport = true;\n-        if (in != null) {\n-            char c = (char) in.read();\n-            if (c != 'y') {\n-                shouldExport = false;\n-            }\n+        if (g.getMethod() != null) {\n+            exportInputMethod(writer, g.getMethod());\n@@ -87,14 +68,7 @@\n-        if (shouldExport) {\n-            if (g.getMethod() != null) {\n-                export(writer, g.getMethod());\n-            }\n-\n-            InputGraph previous = null;\n-            for (FolderElement e : g.getElements()) {\n-                if (e instanceof InputGraph) {\n-                    InputGraph graph = (InputGraph) e;\n-                    export(writer, graph, previous, true);\n-                    previous = graph;\n-                } else if (e instanceof Group) {\n-                    export(writer, (Group) e);\n-                }\n+        InputGraph previous = null;\n+        for (FolderElement e : g.getElements()) {\n+            if (e instanceof InputGraph graph) {\n+                exportInputGraph(writer, graph, previous, true, contexts);\n+                previous = graph;\n+            } else if (e instanceof Group group) {\n+                exportGroup(writer, group, contexts);\n@@ -107,2 +81,1 @@\n-    public void export(XMLWriter writer, InputGraph graph, InputGraph previous, boolean difference) throws IOException {\n-\n+    private static void exportInputGraph(XMLWriter writer, InputGraph graph, InputGraph previous, boolean difference, Set<GraphContext> contexts) throws IOException {\n@@ -138,1 +111,1 @@\n-                writer.endTag();\n+                writer.endTag(); \/\/ Parser.NODE_ELEMENT\n@@ -142,1 +115,1 @@\n-        writer.endTag();\n+        writer.endTag(); \/\/ Parser.NODES_ELEMENT\n@@ -172,1 +145,1 @@\n-        writer.endTag();\n+        writer.endTag(); \/\/ Parser.EDGES_ELEMENT\n@@ -178,1 +151,1 @@\n-            if (b.getSuccessors().size() > 0) {\n+            if (!b.getSuccessors().isEmpty()) {\n@@ -183,1 +156,1 @@\n-                writer.endTag();\n+                writer.endTag(); \/\/ Parser.SUCCESSORS_ELEMENT\n@@ -186,2 +159,2 @@\n-            if (b.getNodes().size() > 0) {\n-            writer.startTag(Parser.NODES_ELEMENT);\n+            if (!b.getNodes().isEmpty()) {\n+                writer.startTag(Parser.NODES_ELEMENT);\n@@ -191,1 +164,1 @@\n-                writer.endTag();\n+                writer.endTag(); \/\/ Parser.NODES_ELEMENT\n@@ -194,1 +167,1 @@\n-            writer.endTag();\n+            writer.endTag(); \/\/ Parser.BLOCK_ELEMENT\n@@ -197,2 +170,5 @@\n-        writer.endTag();\n-        writer.endTag();\n+        writer.endTag(); \/\/ Parser.CONTROL_FLOW_ELEMENT\n+\n+        exportStates(writer, graph, contexts);\n+\n+        writer.endTag(); \/\/ Parser.GRAPH_ELEMENT\n@@ -201,1 +177,15 @@\n-    private void export(XMLWriter w, InputMethod method) throws IOException {\n+    private static void exportStates(XMLWriter writer, InputGraph exportingGraph, Set<GraphContext> contexts) throws IOException {\n+        Set<GraphContext> contextsContainingGraph = contexts.stream()\n+                .filter(context -> context.inputGraph().equals(exportingGraph))\n+                .collect(Collectors.toSet());\n+\n+        if (contextsContainingGraph.isEmpty()) {\n+            return;\n+        }\n+\n+        writer.startTag(Parser.GRAPH_STATES_ELEMENT);\n+\n+        for (GraphContext context : contextsContainingGraph) {\n+            assert exportingGraph == context.inputGraph();\n+\n+            writer.startTag(Parser.STATE_ELEMENT);\n@@ -203,0 +193,16 @@\n+            writer.simpleTag(Parser.STATE_POSITION_DIFFERENCE,\n+                    new Properties(Parser.POSITION_DIFFERENCE_PROPERTY, Integer.toString(context.posDiff().get())));\n+\n+            writer.startTag(Parser.VISIBLE_NODES_ELEMENT, new Properties(Parser.ALL_PROPERTY, Boolean.toString(context.showAll().get())));\n+            for (Integer hiddenNodeID : context.visibleNodes()) {\n+                writer.simpleTag(Parser.NODE_ELEMENT, new Properties(Parser.NODE_ID_PROPERTY, hiddenNodeID.toString()));\n+            }\n+            writer.endTag(); \/\/ Parser.VISIBLE_NODES_ELEMENT\n+\n+            writer.endTag(); \/\/ Parser.STATES_ELEMENT\n+        }\n+\n+        writer.endTag(); \/\/ Parser.GRAPH_STATE_ELEMENT\n+    }\n+\n+    private static void exportInputMethod(XMLWriter w, InputMethod method) throws IOException {\n@@ -207,1 +213,1 @@\n-        if (method.getInlined().size() > 0) {\n+        if (!method.getInlined().isEmpty()) {\n@@ -210,1 +216,1 @@\n-                export(w, m);\n+                exportInputMethod(w, m);\n@@ -232,1 +238,1 @@\n-    private Properties createProperties(InputEdge edge) {\n+    private static Properties createProperties(InputEdge edge) {\n@@ -245,0 +251,6 @@\n+\n+    public record GraphContext(InputGraph inputGraph, AtomicInteger posDiff, Set<Integer> visibleNodes, AtomicBoolean showAll) { }\n+\n+    public interface GraphContextAction {\n+        void performAction(GraphContext context);\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Printer.java","additions":81,"deletions":69,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-    void view(InputGraph graph, boolean newTab);\n+    InputGraph view(InputGraph graph, boolean newTab);\n@@ -36,1 +36,1 @@\n-    void viewDifference(InputGraph firstGraph, InputGraph secondGraph);\n+    InputGraph viewDifference(InputGraph firstGraph, InputGraph secondGraph);\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/services\/GraphViewer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.hotspot.igv.data.services;\n-\n-import com.sun.hotspot.igv.data.Group;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public interface GroupCallback {\n-\n-    public void started(Group g);\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/services\/GroupCallback.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.HashSet;\n@@ -65,1 +66,0 @@\n-        final Printer printer = new Printer();\n@@ -67,1 +67,1 @@\n-        printer.export(writer, document);\n+        Printer.exportGraphDocument(writer, document, new HashSet<>());\n@@ -74,1 +74,1 @@\n-            Parser parser = new Parser(Channels.newChannel(in));\n+            Parser parser = new Parser(Channels.newChannel(in), null, null, null);\n@@ -76,2 +76,2 @@\n-            final GraphDocument parsedDocument = parser.parse();\n-            Util.assertGraphDocumentEquals(document, parsedDocument);\n+            final GraphDocument exportData = parser.parse();\n+            Util.assertGraphDocumentEquals(document, exportData);\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/ParserTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.hotspot.igv.connection;\n-\n-import com.sun.hotspot.igv.data.serialization.Parser;\n-import com.sun.hotspot.igv.data.services.GroupCallback;\n-import java.io.IOException;\n-import java.nio.channels.SocketChannel;\n-import org.openide.util.Exceptions;\n-\n-public class Client implements Runnable {\n-    private final SocketChannel socket;\n-    private final GroupCallback callback;\n-\n-    public Client(SocketChannel socket, GroupCallback callback) {\n-        this.callback = callback;\n-        this.socket = socket;\n-    }\n-\n-    @Override\n-    public void run() {\n-\n-        try {\n-            final SocketChannel channel = socket;\n-            channel.configureBlocking(true);\n-            channel.socket().getOutputStream().write('y');\n-            new Parser(channel, null, callback).parse();\n-        } catch (IOException ex) {\n-            Exceptions.printStackTrace(ex);\n-        } finally {\n-            try {\n-                socket.close();\n-            } catch (IOException ex) {\n-                Exceptions.printStackTrace(ex);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/NetworkConnection\/src\/main\/java\/com\/sun\/hotspot\/igv\/connection\/Client.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,3 @@\n-import com.sun.hotspot.igv.data.services.GroupCallback;\n+import com.sun.hotspot.igv.data.GraphDocument;\n+import com.sun.hotspot.igv.data.serialization.Parser;\n+import com.sun.hotspot.igv.data.serialization.Printer.GraphContextAction;\n@@ -35,3 +37,0 @@\n-import org.openide.DialogDisplayer;\n-import org.openide.NotifyDescriptor;\n-import org.openide.util.RequestProcessor;\n@@ -45,1 +44,2 @@\n-    private final GroupCallback callback;\n+    private final GraphDocument graphDocument;\n+    private final GraphContextAction contextAction;\n@@ -47,1 +47,0 @@\n-    private Runnable serverRunnable;\n@@ -49,3 +48,6 @@\n-    public Server(GroupCallback callback) {\n-        this.callback = callback;\n-        initializeNetwork();\n+    private volatile boolean isServerRunning;\n+\n+    public Server(GraphDocument graphDocument, GraphContextAction contextAction) {\n+        this.graphDocument = graphDocument;\n+        this.contextAction = contextAction;\n+        port = Integer.parseInt(Settings.get().get(Settings.PORT, Settings.PORT_DEFAULT));\n@@ -59,1 +61,3 @@\n-            initializeNetwork();\n+            port = curPort;\n+            shutdownServer();\n+            startServer();\n@@ -63,3 +67,3 @@\n-    private void initializeNetwork() {\n-        int curPort = Integer.parseInt(Settings.get().get(Settings.PORT, Settings.PORT_DEFAULT));\n-        this.port = curPort;\n+    public void startServer() {\n+        isServerRunning = true;\n+\n@@ -68,4 +72,3 @@\n-            serverSocket.bind(new InetSocketAddress(curPort));\n-        } catch (Throwable ex) {\n-            NotifyDescriptor message = new NotifyDescriptor.Message(\"Could not create server. Listening for incoming data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n-            DialogDisplayer.getDefault().notifyLater(message);\n+            serverSocket.bind(new InetSocketAddress(port));\n+        } catch (IOException ex) {\n+            ex.printStackTrace();\n@@ -75,16 +78,6 @@\n-        Runnable runnable = new Runnable() {\n-\n-            @Override\n-            public void run() {\n-                while (true) {\n-                    try {\n-                        SocketChannel clientSocket = serverSocket.accept();\n-                        if (serverRunnable != this) {\n-                            clientSocket.close();\n-                            return;\n-                        }\n-                        RequestProcessor.getDefault().post(new Client(clientSocket, callback), 0, Thread.MAX_PRIORITY);\n-                    } catch (IOException ex) {\n-                        serverSocket = null;\n-                        NotifyDescriptor message = new NotifyDescriptor.Message(\"Error during listening for incoming connections. Listening for incoming data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n-                        DialogDisplayer.getDefault().notifyLater(message);\n+        Runnable client = () -> {\n+            while (isServerRunning) {\n+                try {\n+                    SocketChannel clientSocket = serverSocket.accept();\n+                    if (!isServerRunning) {\n+                        clientSocket.close();\n@@ -93,0 +86,12 @@\n+                    new Thread(() -> {\n+                        try (clientSocket) {\n+                            clientSocket.configureBlocking(true);\n+                            clientSocket.socket().getOutputStream().write('y');\n+                            new Parser(clientSocket, null, graphDocument, contextAction).parse();\n+                        } catch (IOException ignored) {}\n+                    }).start();\n+                } catch (IOException ex) {\n+                    if (isServerRunning) {\n+                        ex.printStackTrace();\n+                    }\n+                    return;\n@@ -95,0 +100,7 @@\n+            try {\n+                if (serverSocket != null) {\n+                    serverSocket.close();\n+                }\n+            } catch (IOException ex) {\n+                ex.printStackTrace();\n+            }\n@@ -97,1 +109,2 @@\n-        serverRunnable = runnable;\n+        new Thread(client).start();\n+    }\n@@ -99,1 +112,9 @@\n-        RequestProcessor.getDefault().post(runnable, 0, Thread.MAX_PRIORITY);\n+    public void shutdownServer() {\n+        isServerRunning = false;\n+        try {\n+            if (serverSocket != null) {\n+                serverSocket.close();\n+            }\n+        } catch (IOException ex) {\n+            ex.printStackTrace();\n+        }\n","filename":"src\/utils\/IdealGraphVisualizer\/NetworkConnection\/src\/main\/java\/com\/sun\/hotspot\/igv\/connection\/Server.java","additions":57,"deletions":36,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -655,1 +655,1 @@\n-                            centerRectangle(new Rectangle(location.x, location.y, bounds.width, bounds.height));\n+                            centerRectangle(new Rectangle(location.x, location.y, bounds.width, bounds.height), false);\n@@ -875,1 +875,1 @@\n-            centerRectangle(bw.getBounds());\n+            centerRectangle(bw.getBounds(), true);\n@@ -922,1 +922,1 @@\n-            centerRectangle(overallRect);\n+            centerRectangle(overallRect, true);\n@@ -926,1 +926,1 @@\n-    private void centerRectangle(Rectangle r) {\n+    private void centerRectangle(Rectangle r, boolean zoomToFit) {\n@@ -929,12 +929,13 @@\n-\n-        double factor = Math.min(viewRect.getWidth() \/ rect.getWidth(),  viewRect.getHeight() \/ rect.getHeight());\n-        double zoomFactor = getZoomFactor();\n-        double newZoomFactor = zoomFactor * factor;\n-        if (factor < 1.0 || zoomFactor < 1.0) {\n-            newZoomFactor = Math.min(1.0, newZoomFactor);\n-            centredZoom(newZoomFactor, null);\n-            factor = newZoomFactor \/ zoomFactor;\n-            rect.x *= factor;\n-            rect.y *= factor;\n-            rect.width *= factor;\n-            rect.height *= factor;\n+        if (zoomToFit) {\n+            double factor = Math.min(viewRect.getWidth() \/ rect.getWidth(),  viewRect.getHeight() \/ rect.getHeight());\n+            double zoomFactor = getZoomFactor();\n+            double newZoomFactor = zoomFactor * factor;\n+            if (factor < 1.0 || zoomFactor < 1.0) {\n+                newZoomFactor = Math.min(1.0, newZoomFactor);\n+                centredZoom(newZoomFactor, null);\n+                factor = newZoomFactor \/ zoomFactor;\n+                rect.x *= factor;\n+                rect.y *= factor;\n+                rect.width *= factor;\n+                rect.height *= factor;\n+            }\n@@ -942,0 +943,1 @@\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -335,0 +335,8 @@\n+\n+\n+    }\n+\n+    public Set<Integer> getVisibleNodes() {\n+        final Set<Integer> visibleNodes = new HashSet<>(getGraph().getNodesAsSet());\n+        visibleNodes.removeAll(hiddenNodes);\n+        return visibleNodes;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewModel.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,2 +128,1 @@\n-        if (group.getParent() instanceof GraphDocument) {\n-            final GraphDocument doc = (GraphDocument) group.getParent();\n+        if (group.getParent() instanceof GraphDocument doc) {\n@@ -312,2 +311,1 @@\n-                if (t instanceof EditorTopComponent) {\n-                    EditorTopComponent etc = (EditorTopComponent) t;\n+                if (t instanceof EditorTopComponent etc) {\n@@ -323,0 +321,12 @@\n+    public static void closeAllInstances() {\n+        WindowManager manager = WindowManager.getDefault();\n+        for (Mode mode : manager.getModes()) {\n+            TopComponent[] openedTopComponents = manager.getOpenedTopComponents(mode);\n+            for (TopComponent tc : openedTopComponents) {\n+                if (tc instanceof EditorTopComponent etc) {\n+                    etc.close();\n+                }\n+            }\n+        }\n+    }\n+\n@@ -329,5 +339,7 @@\n-        Group group = getModel().getGroup();\n-        if (!group.getParent().getElements().contains(group) ||\n-            group.getGraphs().isEmpty()) {\n-            close();\n-        }\n+        SwingUtilities.invokeLater(() -> {\n+            Group group = getModel().getGroup();\n+            if (!group.getParent().getElements().contains(group) ||\n+                    group.getGraphs().isEmpty()) {\n+                close();\n+            }\n+        });\n@@ -408,2 +420,1 @@\n-                if (topComponent instanceof EditorTopComponent) {\n-                    EditorTopComponent editor = (EditorTopComponent) topComponent;\n+                if (topComponent instanceof EditorTopComponent editor) {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import com.sun.hotspot.igv.graph.Diagram;\n-import com.sun.hotspot.igv.settings.Settings;\n@@ -41,1 +39,1 @@\n-    public void viewDifference(InputGraph firstGraph, InputGraph secondGraph) {\n+    public InputGraph viewDifference(InputGraph firstGraph, InputGraph secondGraph) {\n@@ -44,1 +42,1 @@\n-            view(diffGraph, true);\n+            return view(diffGraph, true);\n@@ -46,5 +44,7 @@\n-            view(firstGraph, true);\n-            EditorTopComponent etc = EditorTopComponent.findEditorForGraph(firstGraph);\n-            if (etc != null) {\n-                etc.getModel().selectDiffGraph(secondGraph);\n-                etc.requestActive();\n+            if (view(firstGraph, true) != null) {\n+                EditorTopComponent etc = EditorTopComponent.findEditorForGraph(firstGraph);\n+                if (etc != null) {\n+                    etc.getModel().selectDiffGraph(secondGraph);\n+                    etc.requestActive();\n+                    return etc.getModel().getGraph();\n+                }\n@@ -52,0 +52,1 @@\n+            return null;\n@@ -56,1 +57,1 @@\n-    public void view(InputGraph graph, boolean newTab) {\n+    public InputGraph view(InputGraph graph, boolean newTab) {\n@@ -62,1 +63,1 @@\n-                return;\n+                return etc.getModel().getGraph();\n@@ -69,0 +70,1 @@\n+        return etc.getModel().getGraph();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/GraphViewerImplementation.java","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"}]}